text :  '  '%NWL%}  , item )  ; %NWL%var defaults =  {%NWL%selected : false ,%NWL%disabled : false%NWL%}  ; %NWL%if ( item . id ! = null )  {%NWL%item . id = item . id . toString (  )  ;%NWL%}%NWL%if ( item . text ! = null )  {%NWL%item . text = item . text . toString (  )  ; %NWL%7
}  ,%NWL%onToggleNoTestTimeout : function (  )%NWL%{%NWL%this . noTestTimeout = !this . noTestTimeout ; %NWL%Firebug . chrome . $ (  " noTestTimeout "  )  . setAttribute (  " checked "  ,%NWL%this . noTestTimeout ? " true "  :  " false "  )  ; %NWL%Firebug . setPref ( FBTestApp . prefDomain ,  " noTestTimeout "  , this . noTestTimeout )  ;%NWL%}  ,%NWL%onToggleRandomTestSelection : function (  )%NWL%{%NWL%this . randomTestSelection = !this . randomTestSelection ; %NWL%3
this . fields = fields ; %NWL%options = !options ? {  }  : options ; %NWL%this . skipValue = options . skip =  = null ? 0 : options . skip ; %NWL%this . limitValue = options . limit =  = null ? 0 : options . limit ; %NWL%this . sortValue = options . sort ; %NWL%this . hint = options . hint ; %NWL%this . explainValue = options . explain ; %NWL%this . snapshot = options . snapshot ; %NWL%this . timeout = options . timeout =  = null ? true : options . timeout ; %NWL%this . tailable = options . tailable ; %NWL%this . awaitdata = options . awaitdata ; %NWL%5
console . error (  ' THREE . DDSLoader . parse : Unsupported FourCC code '  , int32ToFourCC ( fourCC )  )  ; %NWL%return dds ;%NWL%}%NWL%}%NWL%dds . mipmapCount = 1 ; %NWL%if ( header [ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps ! =  = false )  {%NWL%dds . mipmapCount = Math . max ( 1 , header [ off_mipmapCount ]  )  ;%NWL%}%NWL%dds . isCubemap = header [ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false ; %NWL%dds . width = header [ off_width ]  ; %NWL%dds . height = header [ off_height ]  ; %NWL%9
return this ;%NWL%}  ; %NWL%this . useDebug . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useDebug "  ; %NWL%this . usePrefix = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . prefix ;%NWL%}%NWL%options . prefix = value ; %NWL%return this ;%NWL%}  ; %NWL%this . usePrefix . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . usePrefix "  ; %NWL%2
for ( i = 0 ; i < childNodes . length ; i +  = 1 )  {%NWL%childNodes [ i ]  . remove (  )  ;%NWL%}%NWL%}  ; %NWL%self . getParent = getParent = function (  )  {%NWL%return parentNode ;%NWL%}  ; %NWL%self . setParent = setParent = function ( node )  {%NWL%parentNode = node ;%NWL%}  ; %NWL%self . getChildren = getChildren = function (  )  {%NWL%4
describeClusterTest (  { transport :  " xdr_polling "  , encrypted : false }  )  ; %NWL%describeClusterTest (  { transport :  " xdr_polling "  , encrypted : true }  )  ; %NWL%describeClusterTest (  { transport :  " sockjs "  , encrypted : false }  )  ;%NWL%} else {%NWL%describeClusterTest (  { transport :  " sockjs "  , encrypted : false }  )  ; %NWL%describeClusterTest (  { transport :  " sockjs "  , encrypted : true }  )  ;%NWL%}%NWL%it (  " should restore the global config "  , function (  )  {%NWL%Pusher . Dependencies = _Dependencies ; %NWL%Pusher . channel_auth_endpoint = _channel_auth_endpoint ; %NWL%Pusher . channel_auth_transport = _channel_auth_transport ; %NWL%8
} else {%NWL%this . stack =  '  '  ;%NWL%}%NWL%}%NWL%errors . _Abstract = ErrorAbstract ; %NWL%ErrorAbstract . prototype = new Error (  )  ; %NWL%errors . FeedError = function FeedError ( msg )  {%NWL%ErrorAbstract . call ( this , msg )  ;%NWL%}  ; %NWL%errors . FeedError . prototype = new ErrorAbstract (  )  ; %NWL%errors . SiteError = function SiteError ( msg )  {%NWL%6
this . salt = User . makeNewSalt (  )  ; %NWL%var sha = crypto . createHash (  " sha512 "  )  ; %NWL%sha . update ( this . salt + info . password )  ; %NWL%this . hash = sha . digest (  " hex "  )  . toString (  )  ; %NWL%console . log (  " Converted password to hash for "  , this . state . userName )  ;%NWL%}%NWL%else {%NWL%this . salt = info . salt ; %NWL%this . hash = info . hash ;%NWL%}%NWL%this . email = info . email ; %NWL%7
}  )  ; %NWL%this . handleEventProps ( dispatches )  ; %NWL%this . bind (  ' Load Resize '  , function (  )  {%NWL%_updateInfo . call ( this )  ;%NWL%}  , 999 )  ; %NWL%function _updateInfo ( info )  {%NWL%if ( !info )  {%NWL%info = this . exec (  ' Image '  ,  ' getInfo '  )  ;%NWL%}%NWL%this . size = info . size ; %NWL%this . width = info . width ; %NWL%9
this . AddZone = WebPartManager_AddZone ; %NWL%this . IsDragDropEnabled = WebPartManager_IsDragDropEnabled ; %NWL%this . DragDrop = WebPartManager_DragDrop ; %NWL%this . InitiateWebPartDragDrop = WebPartManager_InitiateWebPartDragDrop ; %NWL%this . CompleteWebPartDragDrop = WebPartManager_CompleteWebPartDragDrop ; %NWL%this . ContinueWebPartDragDrop = WebPartManager_ContinueWebPartDragDrop ; %NWL%this . ProcessWebPartDragEnter = WebPartManager_ProcessWebPartDragEnter ; %NWL%this . ProcessWebPartDragOver = WebPartManager_ProcessWebPartDragOver ; %NWL%this . ProcessWebPartDrop = WebPartManager_ProcessWebPartDrop ; %NWL%this . ShowHelp = WebPartManager_ShowHelp ; %NWL%this . ExportWebPart = WebPartManager_ExportWebPart ; %NWL%0
} else if ( ptype =  =  =  " plane "  )  {%NWL%prim . size = meshKit . getFloatNode ( proc ,  " size "  )  ; %NWL%obj . booleanAdd ( CubicVR . primitives . plane ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " cylinder "  )  {%NWL%prim . radius = meshKit . getFloatNode ( proc ,  " radius "  )  ; %NWL%prim . height = meshKit . getFloatNode ( proc ,  " height "  )  ; %NWL%prim . lon = meshKit . getIntNode ( proc ,  " lon "  )  ; %NWL%obj . booleanAdd ( CubicVR . primitives . cylinder ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " torus "  )  {%NWL%prim . innerRadius = meshKit . getFloatNode ( proc ,  " innerRadius "  )  ; %NWL%prim . outerRadius = meshKit . getFloatNode ( proc ,  " outerRadius "  )  ; %NWL%1
utils    = require (  '  .  / utils '  )  ,%NWL%coreHelpers  =  {  }  ,%NWL%registerHelpers ; %NWL%if ( !utils . isProduction )  {%NWL%hbs . handlebars . logger . level = 0 ;%NWL%}%NWL%coreHelpers . asset  = require (  '  .  / asset '  )  ; %NWL%coreHelpers . author  = require (  '  .  / author '  )  ; %NWL%coreHelpers . body_class  = require (  '  .  / body_class '  )  ; %NWL%coreHelpers . content  = require (  '  .  / content '  )  ; %NWL%coreHelpers . date  = require (  '  .  / date '  )  ; %NWL%6
opts . complete ( null ,  { status :  ' cancelled '  }  )  ;%NWL%} else {%NWL%fun ( self , opts , promise )  ;%NWL%}%NWL%}  )  ;%NWL%} else {%NWL%fun ( self , opts , promise )  ;%NWL%}%NWL%promise . on = emitter . on . bind ( emitter )  ; %NWL%promise . once = emitter . once . bind ( emitter )  ; %NWL%promise . addListener = emitter . addListener . bind ( emitter )  ; %NWL%8
}  ; %NWL%var Stat = function ( opts )  {%NWL%this . uid = opts . uid || 0 ; %NWL%this . gid = opts . gid || 0 ; %NWL%this . mode = opts . mode || 0 ; %NWL%this . size = opts . size || 0 ; %NWL%this . mtime = toDate ( opts . mtime )  ; %NWL%this . atime = toDate ( opts . atime )  ; %NWL%this . ctime = toDate ( opts . ctime )  ; %NWL%this . type = opts . type ; %NWL%this . target = opts . target ; %NWL%9
this . init (  )  ; %NWL%this . element . data (  " markdownarea "  , this )  ;%NWL%}  ; %NWL%$ . extend ( Markdownarea . prototype ,  {%NWL%init : function (  )  {%NWL%var $this = this , tpl = Markdownarea . template ; %NWL%tpl = tpl . replace (  / \ { \ : lblPreview\ }  / g , this . options . lblPreview )  ; %NWL%tpl = tpl . replace (  / \ { \ : lblCodeview\ }  / g , this . options . lblCodeview )  ; %NWL%this . markdownarea = $ ( tpl )  ; %NWL%this . content   = this . markdownarea . find (  "  . uk - markdownarea - content "  )  ; %NWL%this . toolbar   = this . markdownarea . find (  "  . uk - markdownarea - toolbar "  )  ; %NWL%9
this . x = this . object . Location . X ; %NWL%this . y = this . object . Location . Y ; %NWL%this . size = this . object . size || 1 ; %NWL%break ; %NWL%case QuadTreeConstants . useObjectPosition : %NWL%this . x = this . object . position . x ; %NWL%this . y = this . object . position . y ; %NWL%break ; %NWL%case QuadTreeConstants . useParam : %NWL%this . x = this . object [ this . _getParam . x ]  ; %NWL%this . y = this . object [ this . _getParam . y ]  ; %NWL%9
var debounce = require (  ' lodash . debounce '  )  ; %NWL%var inquirer = require (  ' inquirer '  )  ; %NWL%var providers = require (  '  .  / providers '  )  ; %NWL%function Insight ( options )  {%NWL%options = options || {  }  ; %NWL%if ( !options . trackingCode || !options . packageName )  {%NWL%throw new Error (  ' Must provide trackingCode and packageName '  )  ;%NWL%}%NWL%this . trackingCode = options . trackingCode ; %NWL%this . trackingProvider = options . trackingProvider || ' google '  ; %NWL%this . packageName = options . packageName ; %NWL%8
}  ; %NWL%ret . isTop = true ; %NWL%ret . _setup = function ( options )  {%NWL%if ( !options . partial )  {%NWL%container . helpers = container . merge ( options . helpers , env . helpers )  ; %NWL%if ( templateSpec . usePartial )  {%NWL%container . partials = container . merge ( options . partials , env . partials )  ;%NWL%}%NWL%} else {%NWL%container . helpers = options . helpers ; %NWL%container . partials = options . partials ; %NWL%9
var AttributeCore  = Y . AttributeCore ,%NWL%AttributeExtras = Y . AttributeExtras ,%NWL%BaseCore   = Y . BaseCore ,%NWL%BaseObservable  = Y . BaseObservable ; %NWL%function Base (  )  {%NWL%BaseCore . apply ( this , arguments )  ; %NWL%BaseObservable . apply ( this , arguments )  ; %NWL%AttributeExtras . apply ( this , arguments )  ;%NWL%}%NWL%Base . _ATTR_CFG = BaseCore . _ATTR_CFG . concat ( BaseObservable . _ATTR_CFG )  ; %NWL%Base . _NON_ATTRS_CFG = BaseCore . _NON_ATTRS_CFG . concat ( BaseObservable . _NON_ATTRS_CFG )  ; %NWL%9
matrix :  [%NWL%[ scale * Math . cos ( rotate )  ,  - scale * Math . sin ( rotate )  , translate [ 0 ]  ]  ,%NWL%[ scale * Math . sin ( rotate )  , scale * Math . cos ( rotate )  , translate [ 1 ]  ]  ,%NWL%[ 0 , 0 , 1 ]%NWL%]%NWL%}  ;%NWL%}  ( possition [ 0 ]  [ 0 ]  , position [ 0 ]  [ 1 ]  , position [ 1 ]  [ 0 ]  , position [ 1 ]  [ 1 ]  , current [ 0 ]  [ 0 ]  , current [ 0 ]  [ 1 ]  , current [ 1 ]  [ 0 ]  , current [ 1 ]  [ 1 ]  )  ; %NWL%var ev = document . createEvent (  ' HTMLEvents '  )  ; %NWL%ev . initEvent (  ' dualtouch '  , true , true )  ; %NWL%ev . rotate = transform . rotate ; %NWL%ev . scale = transform . scale ; %NWL%9
this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%this . query = options . query || '  '  ; %NWL%this . orderby = options . orderby ; %NWL%this . endpoint = options . endpoint || " https :  /  / spreadsheets . google . com "  ; %NWL%this . singleton = !!options . singleton ; %NWL%this . simple_url = !!options . simple_url ; %NWL%this . callbackContext = options . callbackContext ; %NWL%3
}  )%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%shouldCorrectlyExecuteLastStatus : function ( test )  {%NWL%var error_client = new Db ( MONGODB , new Server (  " 127 . 0 . 0 . 1 "  , 27017 ,  { auto_reconnect : false , poolSize : 1 ,  }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%error_client . bson_deserializer = client . bson_deserializer ; %NWL%error_client . bson_serializer = client . bson_serializer ; %NWL%9
unitSystem = google . maps . UnitSystem . METRIC ;%NWL%}%NWL%var base_options =  {%NWL%avoidHighways : false ,%NWL%avoidTolls : false ,%NWL%optimizeWaypoints : false ,%NWL%waypoints :  [  ]%NWL%}  ,%NWL%request_options =  extend_object ( base_options , options )  ; %NWL%request_options . origin =  / string /  . test ( typeof options . origin ) ? options . origin : new google . maps . LatLng ( options . origin [ 0 ]  , options . origin [ 1 ]  )  ; %NWL%request_options . destination =  / string /  . test ( typeof options . destination ) ? options . destination : new google . maps . LatLng ( options . destination [ 0 ]  , options . destination [ 1 ]  )  ; %NWL%9
Stimulus . prototype . init = function ( world , opt_options )  {%NWL%Stimulus . _superClass . init . call ( this , world , opt_options )  ; %NWL%var options = opt_options || {  }  ; %NWL%if ( !options . type || typeof options . type ! =  =  ' string '  )  {%NWL%throw new Error (  ' Stimulus requires \ ' type\ ' parameter as a string .  '  )  ;%NWL%}%NWL%this . type = options . type ; %NWL%this . mass = typeof options . mass ! =  =  ' undefined ' ? options . mass : 50 ; %NWL%this . isStatic = typeof options . isStatic ! =  =  ' undefined ' ? options . isStatic : true ; %NWL%this . width = typeof options . width ! =  =  ' undefined ' ? options . width : 50 ; %NWL%this . height = typeof options . height ! =  =  ' undefined ' ? options . height : 50 ; %NWL%7
this . _webgl = undefined ; %NWL%this . _webglFramebuffer = undefined ; %NWL%this . _webglRenderbuffer = undefined ;%NWL%}%NWL%Class . extend ( RenderTarget )  ; %NWL%RenderTarget . prototype . clone = function (  )  {%NWL%return new RenderTarget (  )  . copy ( this )  ;%NWL%}  ; %NWL%RenderTarget . prototype . copy = function ( other )  {%NWL%this . width = other . width ; %NWL%this . height = other . height ; %NWL%9
}  )  [  ' catch '  ]  ( function ( reply )  {%NWL%validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . registerHandler '  ; %NWL%wrapped . unregisterHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . unregisterHandler '  ; %NWL%wrapped . send . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . send '  ; %NWL%wrapped . publish . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . publish '  ; %NWL%wrapped . getConnectionState . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . getConnectionState '  ; %NWL%6
var index = key >  >  > 0 ; %NWL%return index < max && index =  = key ;%NWL%}%NWL%function ArrayBufferIndex ( value )  {%NWL%this . Value = value ;%NWL%}%NWL%ArrayBufferIndex . prototype = new DataDescriptor ( undefined , 5 )  ; %NWL%function Type ( options )  {%NWL%this . name  = options . name%NWL%this . size  = options . size ; %NWL%this . cast  = options . cast ; %NWL%9
this . angularVelocity = opts . angularVelocity ! = undefined ? opts . angularVelocity : 0 ; %NWL%this . angularVelocitySpread = opts . angularVelocitySpread ! = undefined ? opts . angularVelocitySpread : 0 ; %NWL%this . angularAcceleration = opts . angularAcceleration ! = undefined ? opts . angularAcceleration : 0 ; %NWL%this . angularAccelerationSpread = opts . angularAccelerationSpread ! = undefined ? opts . angularAccelerationSpread : 0 ; %NWL%this . randomAngle = opts . randomAngle ! = undefined ? opts . randomAngle : true ; %NWL%this . emissionRate = opts . emissionRate ! = undefined ? opts . emissionRate : 1 / 60 ; %NWL%this . color = opts . color ! = undefined ? opts . color : new Color ; %NWL%this . colorSpread = opts . colorSpread ! = undefined ? opts . colorSpread : new Color ; %NWL%this . time = opts . time ! = undefined ? opts . time : 0 ; %NWL%this . _time = 0 ; %NWL%this . duration = opts . duration ! = undefined ? opts . duration : 0 ; %NWL%0
}  ,%NWL%function (  )  {%NWL%var scope = QUnit . fixture . find (  " a "  )  . scope (  )  ; %NWL%scope . $apply ( function (  )  {%NWL%scope . foo =  " foo "  ;%NWL%}  )  ; %NWL%stop (  )  ; %NWL%setTimeout ( function (  )  {%NWL%ok ( QUnit . fixture . find (  " a "  )  . getKendoMobileButton (  )  )  ; %NWL%scope . $apply ( function (  )  {%NWL%scope . bar =  " bar "  ; %NWL%4
xpixels : 514 ,%NWL%ypixels : 514 ,%NWL%range :  [  [  - 1 . 2 , 1 . 2 ]  ,  [  - 1 . 2 , 1 . 2 ]  ]%NWL%}  ; %NWL%options . scale =  [ options . xpixels /  ( options . range [ 0 ]  [ 1 ]  - options . range [ 0 ]  [ 0 ]  )  ,%NWL%options . ypixels /  ( options . range [ 1 ]  [ 1 ]  - options . range [ 1 ]  [ 0 ]  )  ]  ; %NWL%graph . init ( options )  ; %NWL%graph . xpixels = options . xpixels ; %NWL%graph . ypixels = options . ypixels ; %NWL%graph . range = options . range ; %NWL%graph . scale = options . scale ; %NWL%7
Extends : jxObject ,%NWL%Family :  ' Jx . Splitter . Snap '  ,%NWL%snap : null ,%NWL%element : null ,%NWL%splitter : null ,%NWL%layout :  ' vertical '  ,%NWL%parameters :  [  ' snap '  ,  ' element '  ,  ' splitter '  ,  ' events '  ]  ,%NWL%init : function (  )  {%NWL%this . snap = this . options . snap ; %NWL%this . element = this . options . element ; %NWL%this . splitter = this . options . splitter ; %NWL%8
Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%proxy . stopImmediatePropagation = proto . stopImmediatePropagation ; %NWL%6
var key = columnKeyXZ ( loc . chunkCorner . x , loc . chunkCorner . z )  ; %NWL%var column = columns [ key ]  ; %NWL%if ( ! column ) return null ; %NWL%var blockType = double_bite ( column . blockType )  ; %NWL%var nibbleIndex = loc . blockIndex >  > 1 ; %NWL%var lowNibble = loc . blockIndex % 2 =  =  = 1 ; %NWL%var biomeId = column . biome . readUInt8 ( loc . biomeBlockIndex )  ; %NWL%var block = new Block ( blockType >  > 4 , biomeId )  ; %NWL%block . metadata = blockType & 0x0f ; %NWL%block . light = nib ( column . light )  ; %NWL%block . skyLight = nib ( column . skyLight )  ; %NWL%9
this . _bep	   = bep ; %NWL%this . name	   = uuid (  )  ; %NWL%this . terminated  = false ; %NWL%this . to		   = node . attrs . to ; %NWL%this . session	  = session ; %NWL%this . attrs    =  {  }  ; %NWL%if ( node . attrs . route )  {%NWL%this . route = helper . route_parse ( node . attrs . route )  ;%NWL%}%NWL%if ( node . attrs . from )  {%NWL%this . from = node . attrs . from ; %NWL%3
if ( typeof this . settings . target ! =  ' undefined '  )  {%NWL%this . target = this . settings . target ;%NWL%}%NWL%if ( typeof this . settings . cssclassregex ! =  ' undefined '  )  {%NWL%this . cssclassregex = this . settings . cssclassregex ;%NWL%}%NWL%if ( typeof this . settings . cssclass ! =  ' undefined '  )  {%NWL%this . cssclass = this . settings . cssclass ;%NWL%}%NWL%if ( typeof this . settings . objectTypeFilter ! =  ' undefined '  )  {%NWL%this . objectTypeFilter = this . settings . objectTypeFilter ; %NWL%1
stackStartFunction : stackStartFunction%NWL%}  )  ;%NWL%}%NWL%assert . fail = fail ; %NWL%assert . ok = function ok ( value , message )  {%NWL%if ( !!!value ) fail ( value , true , message ,  "  =  =  "  , assert . ok )  ;%NWL%}  ; %NWL%assert . equal = function equal ( actual , expected , message )  {%NWL%if ( actual ! = expected ) fail ( actual , expected , message ,  "  =  =  "  , assert . equal )  ;%NWL%}  ; %NWL%assert . notEqual = function notEqual ( actual , expected , message )  {%NWL%7
}%NWL%return loss ;%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%8
[  " simple - auth / authorizers / base "  ,  "  .  /  .  .  / configuration "  ,  " exports "  ]  ,%NWL%function ( __dependency1__ , __dependency2__ , __exports__ )  {%NWL%" use strict "  ; %NWL%var Base = __dependency1__ [  " default "  ]  ; %NWL%var Configuration = __dependency2__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%tokenAttributeName :  ' user_token '  ,%NWL%identificationAttributeName :  ' user_email '  ,%NWL%init : function (  )  {%NWL%this . tokenAttributeName    = Configuration . tokenAttributeName ; %NWL%this . identificationAttributeName = Configuration . identificationAttributeName ; %NWL%9
if ( evt . touches )  {%NWL%for ( i ; i < evt . changedTouches . length ; i +  +  )  {%NWL%touch = evt . changedTouches [ i ]  ; %NWL%this . touchInfo . touchLookup [ touch . identifier ]  . pageX = touch . pageX ; %NWL%this . touchInfo . touchLookup [ touch . identifier ]  . pageY = touch . pageY ;%NWL%}%NWL%}%NWL%else {%NWL%touch = this . touchInfo . touchLookup [ evt . pointerId ]  ; %NWL%touch . pageX = evt . pageX ; %NWL%touch . pageY = evt . pageY ; %NWL%9
return {%NWL%createDefault : function (  )  {%NWL%return new Constructor (  )  ;%NWL%}  ,%NWL%transform : function ( jsonResult )  {%NWL%if ( angular . isArray ( jsonResult )  )  {%NWL%var methods =  [  ]  ; %NWL%angular . forEach ( jsonResult , function ( result )  {%NWL%var method = new Constructor (  )  ; %NWL%method . gatewayResource = gatewayResourceDisplayBuilder . transform ( result . gatewayResource )  ; %NWL%method . shipMethod = shipMethodDisplayBuilder . transform ( result . shipMethod )  ; %NWL%9
var s = new Stream ; %NWL%s . writable = true ; %NWL%s . write = c . write . bind ( c )  ; %NWL%s . end = function ( buf )  {%NWL%if ( buf ! =  = undefined ) s . write ( buf )  ; %NWL%c . end (  )  ; %NWL%close (  )  ;%NWL%}  ; %NWL%s . destroy = c . destroy . bind ( c )  ; %NWL%s . pause = c . pause . bind ( c )  ; %NWL%s . resume = c . resume . bind ( c )  ; %NWL%2
options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%5
"  .  .  /  .  .  / EnhancedGrid "%NWL%]  , function ( declare , array , lang , html , evt , keys , _Plugin , EnhancedGrid )  {%NWL%var Menu = declare (  " dojox . grid . enhanced . plugins . Menu "  , _Plugin ,  {%NWL%name :  " menus "  ,%NWL%types :  [  ' headerMenu '  ,  ' rowMenu '  ,  ' cellMenu '  ,  ' selectedRegionMenu '  ]  ,%NWL%constructor : function (  )  {%NWL%var g = this . grid ; %NWL%g . showMenu = lang . hitch ( g , this . showMenu )  ; %NWL%g . _setRowMenuAttr = lang . hitch ( this ,  ' _setRowMenuAttr '  )  ; %NWL%g . _setCellMenuAttr = lang . hitch ( this ,  ' _setCellMenuAttr '  )  ; %NWL%g . _setSelectedRegionMenuAttr = lang . hitch ( this ,  ' _setSelectedRegionMenuAttr '  )  ; %NWL%8
return {%NWL%sign :  - 1 ,%NWL%value : valueIn . subtract ( valueOut )%NWL%}  ;%NWL%}%NWL%}  ; %NWL%var TransactionIn = function ( data )%NWL%{%NWL%this . outpoint = data . outpoint ; %NWL%if ( data . script instanceof Script )  {%NWL%this . script = data . script ; %NWL%8
initialize : function ( name , url , options )  {%NWL%var newArguments =  [  ]  ; %NWL%newArguments . push ( name , url ,  {  }  , options )  ; %NWL%OpenLayers . Layer . Grid . prototype . initialize . apply ( this , newArguments )  ; %NWL%this . rft_id = options . rft_id ; %NWL%this . format = options . format ; %NWL%if ( !options . imgMetadata )  {%NWL%var request = OpenLayers . Request . issue (  { url : options . metadataUrl , async : false }  )  ; %NWL%this . imgMetadata = eval (  '  (  '  + request . responseText +  '  )  '  )  ;%NWL%} else {%NWL%this . imgMetadata = options . imgMetadata ; %NWL%4
return proxy ;%NWL%}%NWL%}  )  ;%NWL%}  )  ; %NWL%carena . addFeature (  " composer . Pipe "  , function ( obj , options , storage )  {%NWL%var safe =  {%NWL%source : null ,%NWL%target : null%NWL%}%NWL%storage . source = options . source || null ; %NWL%storage . target = options . target || null ; %NWL%9
var _     = require (  ' lodash '  )  ; %NWL%var request   = require (  ' request '  )  ; %NWL%var fs     = require (  ' fs '  )  ; %NWL%function Email ( params )  {%NWL%params = params || {  }  ; %NWL%this . to   = params . to  || [  ]  ; %NWL%this . from  = params . from || '  '  ; %NWL%this . smtpapi = params . smtpapi || new smtpapi_lib (  )  ; %NWL%this . subject = params . subject || '  '  ; %NWL%this . text  = params . text || '  '  ; %NWL%this . html  = params . html || '  '  ; %NWL%6
var step = new angular . scenario . ObjectModel . Step ( name )  ; %NWL%this . steps . push ( step )  ; %NWL%return step ;%NWL%}  ; %NWL%angular . scenario . ObjectModel . Spec . prototype . getLastStep = function (  )  {%NWL%return this . steps [ this . steps . length - 1 ]  ;%NWL%}  ; %NWL%angular . scenario . ObjectModel . Spec . prototype . setStatusFromStep = function ( step )  {%NWL%if ( !this . status || step . status =  =  ' error '  )  {%NWL%this . status = step . status ; %NWL%this . error = step . error ; %NWL%9
finish (  )  ;%NWL%} else {%NWL%if ( typeof obj . options =  =  =  " undefined "  )  {%NWL%obj . options =  {  }  ;%NWL%}%NWL%if ( obj . generator =  = cody . Meta . Generator . textareainput )  {%NWL%obj . min =  ( typeof obj . options . cols =  =  =  " undefined "  ) ? "  "  : obj . options . cols ; %NWL%obj . max =  ( typeof obj . options . rows =  =  =  " undefined "  ) ? "  "  : obj . options . rows ;%NWL%} else {%NWL%obj . min =  ( typeof obj . options . minimum =  =  =  " undefined "  ) ? "  "  : obj . options . minimum ; %NWL%obj . max =  ( typeof obj . options . maximum =  =  =  " undefined "  ) ? "  "  : obj . options . maximum ; %NWL%9
return ret ;%NWL%}  ,%NWL%dateToString : function ( date , _getParsed )  {%NWL%return typeProtos . date . dateToString ( date )  +  ' T '  + typeProtos . time . dateToString ( date , _getParsed )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%if ( typeBugs || !supportsType (  ' range '  ) || !supportsType (  ' time '  ) || !supportsType (  ' month '  ) || !supportsType (  ' datetime - local '  )  )  {%NWL%typeProtos . range = $ . extend (  {  }  , typeProtos . number , typeProtos . range )  ; %NWL%typeProtos . time = $ . extend (  {  }  , typeProtos . date , typeProtos . time )  ; %NWL%typeProtos . month = $ . extend (  {  }  , typeProtos . date , typeProtos . month )  ; %NWL%9
function GitBranchListModel ( options )  {%NWL%this . root = options . root ; %NWL%this . showHistory = options . showHistory =  =  = undefined || options . showHistory ; %NWL%this . showTags = options . showTags =  =  = undefined || options . showTags ; %NWL%this . showStashes = options . showStashes =  =  = undefined || options . showStashes ; %NWL%this . registry = options . registry ; %NWL%this . handleError = options . handleError ; %NWL%this . section = options . section ; %NWL%this . progressService = options . progressService ; %NWL%this . parentId = options . parentId ; %NWL%this . gitClient = options . gitClient ; %NWL%1
elements . buttons . primary . appendChild ( button . element )  ;%NWL%}%NWL%}%NWL%instance . elements = elements ; %NWL%internal . resetHandler = delegate ( instance , onReset )  ; %NWL%internal . beginMoveHandler = delegate ( instance , beginMove )  ; %NWL%internal . beginResizeHandler = delegate ( instance , beginResize )  ; %NWL%internal . bringToFrontHandler = delegate ( instance , bringToFront )  ; %NWL%internal . modalClickHandler = delegate ( instance , modalClickHandler )  ; %NWL%internal . buttonsClickHandler = delegate ( instance , buttonsClickHandler )  ; %NWL%internal . commandsClickHandler = delegate ( instance , commandsClickHandler )  ; %NWL%8
var log = logger . temp [ i ]  ; %NWL%logger . target [ log . level ]  ( log . message )  ; %NWL%delete logger . temp [ i ]  ;%NWL%}%NWL%}  ; %NWL%logger . trace = function ( message )  { logger . temp . push (  { level :  ' trace '  , message : message }  )  ;  }  ; %NWL%logger . debug = function ( message )  { logger . temp . push (  { level :  ' debug '  , message : message }  )  ;  }  ; %NWL%logger . info = function ( message )  { logger . temp . push (  { level :  ' info '  , message : message }  )  ;  }  ; %NWL%logger . warn = function ( message )  { logger . temp . push (  { level :  ' warn '  , message : message }  )  ;  }  ; %NWL%logger . error = function ( message )  { logger . temp . push (  { level :  ' error '  , message : message }  )  ;  }  ; %NWL%logger . fatal = function ( message )  { logger . temp . push (  { level :  ' fatal '  , message : message }  )  ;  }  ; %NWL%5
}  ;%NWL%}%NWL%ReconnectingWebSocket . prototype . onopen = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onclose = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onconnecting = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onmessage = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onerror = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . debugAll = false ; %NWL%ReconnectingWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%ReconnectingWebSocket . OPEN = WebSocket . OPEN ; %NWL%ReconnectingWebSocket . CLOSING = WebSocket . CLOSING ; %NWL%8
}%NWL%AnaglyphArcRotateCamera . prototype . _update = function (  )  {%NWL%this . _updateCamera ( this . _leftCamera )  ; %NWL%this . _updateCamera ( this . _rightCamera )  ; %NWL%this . _leftCamera . alpha = this . alpha - this . _eyeSpace ; %NWL%this . _rightCamera . alpha = this . alpha + this . _eyeSpace ; %NWL%_super . prototype . _update . call ( this )  ;%NWL%}  ; %NWL%AnaglyphArcRotateCamera . prototype . _updateCamera = function ( camera )  {%NWL%camera . beta = this . beta ; %NWL%camera . radius = this . radius ; %NWL%9
if ( dst . alarmType ! =  = _NO_ALARM && prop . alarmTrigger ! =  = undefined && prop . alarmTrigger ! =  = undefined )  {%NWL%dst . alarmTrigger = prop . alarmTrigger | 0 ;%NWL%}%NWL%}  ; %NWL%_eventFilterCheck = function ( filter )  {%NWL%if ( filter . id ! =  = undefined && filter . id ! =  = null )  {%NWL%filter . id = String ( filter . id )  ;%NWL%} else {%NWL%filter . id = undefined ;%NWL%}%NWL%if ( filter . summary ! =  = undefined && filter . summary ! =  = null )  {%NWL%5
pluginIndexes [ plugin . packagePath ]  = index ;%NWL%}%NWL%}  )  ; %NWL%require ( paths , function (  )  {%NWL%var args = arguments ; %NWL%paths . forEach ( function ( name , i )  {%NWL%var module = args [ i ]  ; %NWL%var plugin = config [ pluginIndexes [ name ]  ]  ; %NWL%plugin . setup = module ; %NWL%plugin . provides = module . provides || [  ]  ; %NWL%plugin . consumes = module . consumes || [  ]  ; %NWL%9
}%NWL%if ( this . toPropertyName )  {%NWL%this . setTransformOrigin = function ( node ,  transformOrigin )  {%NWL%return dojo . style ( node , this . toPropertyName , transformOrigin )  ;%NWL%}  ; %NWL%this . getTransformOrigin = function ( node )  {%NWL%return dojo . style ( node , this . toPropertyName )  ;%NWL%}  ;%NWL%} else if ( dojo . isIE )  {%NWL%this . setTransformOrigin = this . _setTransformOriginFilter ; %NWL%this . getTransformOrigin = this . _getTransformOriginFilter ; %NWL%9
this . device . deleteBuffer ( this . vertexBuffer )  ; %NWL%this . device . deleteBuffer ( this . indexBuffer )  ; %NWL%delete this . vertexBuffer ; %NWL%delete this . indexBuffer ; %NWL%delete this . vertexData ; %NWL%delete this . indexData ; %NWL%this . setDirty ( true )  ;%NWL%}%NWL%}  ; %NWL%Mesh . POINTS   = GraphicsDevice . POINTS ; %NWL%Mesh . LINES    = GraphicsDevice . LINES ; %NWL%9
obj . type = this . get (  ' type '  )  ; %NWL%obj . metaType = this . get (  ' meta '  )  . type ; %NWL%obj . date = this . get (  ' meta '  ) ? this . get (  ' meta '  )  . date : new Date (  )  ; %NWL%obj . date = obj . date ? obj . date : new Date (  )  ; %NWL%obj . commId = this . get (  ' meta '  ) ? this . get (  ' meta '  )  . commId : undefined ; %NWL%obj . contents = this . get (  ' contents '  )  ; %NWL%if ( this . get (  ' from '  ) && this . get (  ' from '  )  . authorMsisdn )  {%NWL%obj . authorMsisdn = this . get (  ' from '  )  . authorMsisdn ;%NWL%}%NWL%obj . msisdn = this . get (  ' from '  ) ? this . get (  ' from '  )  . msisdn :  '  '  ; %NWL%obj . displayName = this . get (  ' from '  ) ? this . get (  ' from '  )  . displayName :  '  '  ; %NWL%9
Fast . keys = Fast . object . keys ; %NWL%Fast . values = Fast . object . values ; %NWL%Fast . clone = require (  '  .  / clone '  )  ; %NWL%Fast . map = require (  '  .  / map '  )  ; %NWL%Fast . filter = require (  '  .  / filter '  )  ; %NWL%Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%Fast . reduce = require (  '  .  / reduce '  )  ; %NWL%Fast . reduceRight = require (  '  .  / reduceRight '  )  ; %NWL%Fast . cloneArray = Fast . array . clone ;  /  / @deprecated use fast . array . clone (  )%NWL%Fast . concat = Fast . array . concat ; %NWL%Fast . some = Fast . array . some ; %NWL%9
this . x = 0 ; %NWL%this . y = 0 ; %NWL%this . confidence =  - 10000 ; %NWL%this . detection =  '  '  ; %NWL%this . time = 0 ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . facetrackr . TrackObj (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%c . angle = this . angle ; %NWL%c . x = this . x ; %NWL%7
}  ; %NWL%Drupal . ahah = function ( base , element_settings )  {%NWL%this . element = element_settings . element ; %NWL%this . selector = element_settings . selector ; %NWL%this . event = element_settings . event ; %NWL%this . keypress = element_settings . keypress ; %NWL%this . url = element_settings . url ; %NWL%this . wrapper =  ' # '  + element_settings . wrapper ; %NWL%this . effect = element_settings . effect ; %NWL%this . method = element_settings . method ; %NWL%this . progress = element_settings . progress ; %NWL%3
this . _onEvent = __bind ( this . _onEvent , this )  ; %NWL%this . _onViewBinding = __bind ( this . _onViewBinding , this )  ; %NWL%this . _onNewInstance = __bind ( this . _onNewInstance , this )  ; %NWL%this . _trackViewBinding = __bind ( this . _trackViewBinding , this )  ; %NWL%this . _hookSync = __bind ( this . _hookSync , this )  ; %NWL%this . _hookEvents = __bind ( this . _hookEvents , this )  ; %NWL%this . _trackObjects = __bind ( this . _trackObjects , this )  ; %NWL%this . off = __bind ( this . off , this )  ; %NWL%this . on = __bind ( this . on , this )  ; %NWL%this . routers = __bind ( this . routers , this )  ; %NWL%this . views = __bind ( this . views , this )  ; %NWL%0
_prototype . constructor = this ; %NWL%delete Base . _prototyping ; %NWL%var klass = function (  )  {%NWL%if ( !Base . _prototyping ) constructor . apply ( this , arguments )  ; %NWL%this . constructor = klass ;%NWL%}  ; %NWL%klass . prototype = _prototype ; %NWL%klass . extend = this . extend ; %NWL%klass . implement = this . implement ; %NWL%klass . create = this . create ; %NWL%klass . getClassName = this . getClassName ; %NWL%7
networkRequest . requestMethod = request . method ; %NWL%networkRequest . setRequestHeaders ( this . _headersMapToHeadersArray ( request . headers )  )  ; %NWL%networkRequest . requestFormData = request . postData ;%NWL%}  ,%NWL%_updateNetworkRequestWithResponse : function ( networkRequest , response )%NWL%{%NWL%if ( response . url && networkRequest . url ! =  = response . url )%NWL%networkRequest . url = response . url ; %NWL%networkRequest . mimeType = response . mimeType ; %NWL%networkRequest . statusCode = response . status ; %NWL%networkRequest . statusText = response . statusText ; %NWL%7
delete this . vertexBuffer ; %NWL%delete this . indexBuffer ; %NWL%delete this . vertexData ; %NWL%delete this . indexData ; %NWL%this . setDirty ( true )  ;%NWL%}%NWL%}  ; %NWL%Mesh . POINTS   = GraphicsDevice . POINTS ; %NWL%Mesh . LINES    = GraphicsDevice . LINES ; %NWL%Mesh . LINE_LOOP   = GraphicsDevice . LINE_LOOP ; %NWL%Mesh . LINE_STRIP  = GraphicsDevice . LINE_STRIP ; %NWL%7
}%NWL%attrs . targets = getElements ( a . targets )  ; %NWL%attrs . images = getElements ( a . images || ' img '  )  ; %NWL%attrs . changeParent = a . changeParent || false ; %NWL%attrs . threshold = a . threshold || 50 ; %NWL%attrs . minOverlap = a . minOverlap || 50 ; %NWL%attrs . classes = a . classes || { dark :  ' background -  - dark '  , light :  ' background -  - light '  }  ; %NWL%attrs . windowEvents = a . windowEvents || true ; %NWL%attrs . maxDuration = a . maxDuration || 500 ; %NWL%attrs . mask = a . mask || { r : 0 , g : 255 , b : 0 }  ; %NWL%attrs . debug = a . debug || false ; %NWL%3
}  )  . exec ( cb )  ;%NWL%}  ]  ,%NWL%function ( err , results )  {%NWL%if ( err )  {%NWL%callback ( err )%NWL%}%NWL%var groups = _ . groupBy ( results [ 1 ]  ,  ' parent '  )  ,%NWL%memo =  {  }  ,%NWL%toReturn = _ . reduce ( results [ 0 ]  , function ( memo , value )  {%NWL%memo . id = value . id ; %NWL%memo . name = value . name ; %NWL%9
currentSpeed =  ( currentSpeed > 0 ) ? 0 : currentSpeed ;%NWL%}%NWL%}%NWL%game . physics . velocityFromRotation ( tank . rotation , currentSpeed , tank . body . velocity )  ; %NWL%land . tilePosition . x =  - game . camera . x ; %NWL%land . tilePosition . y =  - game . camera . y ; %NWL%shadow . x = tank . x ; %NWL%shadow . y = tank . y ; %NWL%shadow . rotation = tank . rotation ; %NWL%turret . x = tank . x ; %NWL%turret . y = tank . y ; %NWL%9
options . valueEncoding = options . valueEncoding%NWL%if ( isDefined ( options . start )  )%NWL%options . start = this . _codec . encodeKey ( options . start ,  [ options ]  )%NWL%if ( isDefined ( options . end )  )%NWL%options . end = this . _codec . encodeKey ( options . end ,  [ options ]  )%NWL%if ( isDefined ( options . gte )  )%NWL%options . gte = this . _codec . encodeKey ( options . gte ,  [ options ]  )%NWL%if ( isDefined ( options . gt )  )%NWL%options . gt = this . _codec . encodeKey ( options . gt ,  [ options ]  )%NWL%if ( isDefined ( options . lte )  )%NWL%options . lte = this . _codec . encodeKey ( options . lte ,  [ options ]  )%NWL%2
height : 100%NWL%}  ; %NWL%return DiagramElement ;%NWL%}  )  ( Backbone . Model )  ; %NWL%Class =  ( function ( _super )  {%NWL%__extends ( Class , _super )  ; %NWL%function Class (  )  {%NWL%this . get_inheritance_depth = __bind ( this . get_inheritance_depth , this )  ; %NWL%this . get_super_classes = __bind ( this . get_super_classes , this )  ; %NWL%this . get_all_members = __bind ( this . get_all_members , this )  ; %NWL%this . has_super = __bind ( this . has_super , this )  ; %NWL%7
}  ; %NWL%this . _loadInProgress = false ; 	 /  / Got to track the initial load to prevent duelling loads of the dataset .%NWL%this . _queuedFetches =  [  ]  ; %NWL%this . identifier = keywordParameters . identifier ; %NWL%if ( this . identifier =  =  =  "  "  )  {%NWL%delete this . identifier ;%NWL%} else {%NWL%this . _idMap =  {  }  ;%NWL%}%NWL%if (  " separator " in keywordParameters )  {%NWL%this . separator = keywordParameters . separator ; %NWL%3
init : function (  )  {%NWL%var e = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%x = e . pageX ,%NWL%y = e . pageY ,%NWL%c ,%NWL%currentTarget = this . _currentTarget ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%7
for ( var i = 0 ; i < blocks . length ;  +  + i )  {%NWL%var block = blocks [ i ]  ; %NWL%block . contents = marked ( acquit . trimEachLine ( block . contents )  )  ; %NWL%if ( block . comments && block . comments . length )  {%NWL%block . comments [ 0 ]  = marked ( acquit . trimEachLine ( block . comments [ 0 ]  )  )  ;%NWL%}%NWL%for ( var j = 0 ; j < block . blocks . length ;  +  + j )  {%NWL%var b = block . blocks [ j ]  ; %NWL%b . contents = marked ( acquit . trimEachLine ( b . contents )  )  ; %NWL%if ( b . comments && b . comments . length )  {%NWL%b . comments [ 0 ]  = marked ( acquit . trimEachLine ( b . comments [ 0 ]  )  )  ; %NWL%8
" use strict "  ; %NWL%exports . DefaultRoute = require (  "  .  / components / DefaultRoute "  )  ; %NWL%exports . Link = require (  "  .  / components / Link "  )  ; %NWL%exports . NotFoundRoute = require (  "  .  / components / NotFoundRoute "  )  ; %NWL%exports . Redirect = require (  "  .  / components / Redirect "  )  ; %NWL%exports . Route = require (  "  .  / components / Route "  )  ; %NWL%exports . RouteHandler = require (  "  .  / components / RouteHandler "  )  ; %NWL%exports . HashLocation = require (  "  .  / locations / HashLocation "  )  ; %NWL%exports . HistoryLocation = require (  "  .  / locations / HistoryLocation "  )  ; %NWL%exports . RefreshLocation = require (  "  .  / locations / RefreshLocation "  )  ; %NWL%exports . StaticLocation = require (  "  .  / locations / StaticLocation "  )  ; %NWL%7
var url = require (  ' url '  )  ; %NWL%var request = require (  ' request '  )  ; %NWL%exports . proxy = function ( auth , req , res )  {%NWL%var uri = url . parse (  ' https :  /  / api . github . com '  + req . url )  ; %NWL%uri . query = req . query ; %NWL%uri . query . access_token = auth . accessToken ; %NWL%var arg =  { method : req . method , headers :  {  " User - Agent "  :  " singly . com "  }  }  ; %NWL%arg . uri = url . format ( uri )  ; %NWL%if ( req . headers [  ' content - type '  ]  )  {  /  / post or put only?%NWL%arg . headers [  ' content - type '  ]  = req . headers [  ' content - type '  ]  ; %NWL%arg . body = req . body ; %NWL%9
writable : true%NWL%}  ,%NWL%red :  {%NWL%value : function ( str )  {%NWL%return chalk . red ( str )  ;%NWL%}  ,%NWL%writable : true%NWL%}%NWL%}  )  ; %NWL%chalkStub . yellow . bold = chalk . yellow . bold ; %NWL%chalkStub . red . bold = chalk . red . bold ; %NWL%9
}%NWL%if ( this . max ! = null && this . max <  = 0 )  {%NWL%throw (  ' log axis maximum must be greater than 0 '  )  ;%NWL%}%NWL%var range = max - min ; %NWL%var rmin , rmax ; %NWL%if ( this . tickDistribution =  =  ' even '  )  {%NWL%rmin =  ( this . min ! = null ) ? this . min : min - min *  (  ( this . padMin - 1 )  / 2 )  ; %NWL%rmax =  ( this . max ! = null ) ? this . max : max + max *  (  ( this . padMax - 1 )  / 2 )  ; %NWL%this . min = rmin ; %NWL%this . max = rmax ; %NWL%9
function View ( els , models , options )  {%NWL%var k , option , v , _base , _i , _len , _ref , _ref1 , _ref2 , _ref3 ; %NWL%this . els = els ; %NWL%this . models = models ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%this . bind = __bind ( this . bind , this )  ; %NWL%this . select = __bind ( this . select , this )  ; %NWL%5
var telsHash ; %NWL%var mergedContact =  {  }  ; %NWL%var mergedPhoto ; %NWL%mergedContact . givenName =  [  ]  ; %NWL%copyStringArray ( masterContact . givenName , mergedContact . givenName )  ; %NWL%mergedContact . familyName =  [  ]  ; %NWL%copyStringArray ( masterContact . familyName , mergedContact . familyName )  ; %NWL%mergedContact . photo = masterContact . photo || [  ]  ; %NWL%mergedPhoto = mergedContact . photo ; %NWL%mergedContact . bday = masterContact . bday ; %NWL%mergedContact . anniversary = masterContact . anniversary ; %NWL%9
' use strict '  ; %NWL%kendo . data . extensions = kendo . data . extensions || {  }  ; %NWL%function BreezeTransport ( config )  {%NWL%this . entityManager = config . entityManager ; %NWL%this . endPoint = config . endPoint ; %NWL%this . defaultSort = config . defaultSort ; %NWL%this . mapping = config . mapping ;  /  / Breeze entities ( not projection queries ) contain recursive properties ( entityAspect , entityType )  - eliminate those ( at least ) to prevent stack overflow when grid iterates properties%NWL%this . onFail = config . onFail ; %NWL%this . inlineCount = config . serverPaging ; %NWL%this . serverPaging = config . serverPaging ; %NWL%this . serverSorting = config . serverSorting ; %NWL%3
if ( !Kinetic . Tween . tweens [ nodeId ]  )  {%NWL%Kinetic . Tween . tweens [ nodeId ]  =  {  }  ;%NWL%}%NWL%for ( key in config )  {%NWL%if ( blacklist [ key ]  =  =  = undefined )  {%NWL%this . _addAttr ( key , config [ key ]  )  ;%NWL%}%NWL%}%NWL%this . reset (  )  ; %NWL%this . onFinish = config . onFinish ; %NWL%this . onReset = config . onReset ; %NWL%9
this . mouseTimer = setTimeout ( function (  )  {%NWL%if ( ! this . $optionsElem . is (  '  : hover '  ) && ! this . $chartDescription . is (  '  : hover '  )  )  {%NWL%this . $container . removeClass (  ' active '  )%NWL%$ (  ' body '  )  . removeClass (  ' page - active '  )%NWL%}%NWL%}  . bind ( this )  , 1000 )%NWL%if ( pixel . pageY - this . $plot . offset (  )  . top > this . $plot . height (  )  ) return%NWL%var closestPoint = this . getClosestPoint ( pixel )%NWL%if ( closestPoint . selectedX ! =  = this . selectedX || closestPoint . focusedSeriesIndex ! =  = this . focusedSeriesIndex )  {%NWL%this . selectedX = closestPoint . selectedX%NWL%this . focusedSeriesIndex = closestPoint . focusedSeriesIndex%NWL%9
}  ; %NWL%$scope . $on (  ' $routeChangeSuccess '  , function (  )  {%NWL%$scope . key = $routeParams . key || null ; %NWL%$scope . version = $routeParams . version || 0 ;%NWL%}  )  ; %NWL%$scope . $watchCollection (  '  [ key , version ]  '  , function (  )  {%NWL%server . load ( $scope . key , $scope . version )  . then ( function ( data )  {%NWL%if ( ! data )%NWL%return ; %NWL%$scope . grammar = data . current . grammar ; %NWL%$scope . input = data . current . input ; %NWL%9
tblStack [ level ]  = cnode ; %NWL%if ( level > 0 )  {%NWL%offsets [ level ]  = i ; %NWL%tentry . bitcnt = sTbl [ level ]  ; %NWL%tentry . extra = 16 + j ; %NWL%tentry . next = cnode ; %NWL%j =  ( i & (  ( 1 <  < w )  - 1 )  )  >  >  ( w - sTbl [ level ]  )  ; %NWL%tblStack [ level - 1 ]  [ j ]  . extra = tentry . extra ; %NWL%tblStack [ level - 1 ]  [ j ]  . bitcnt = tentry . bitcnt ; %NWL%tblStack [ level - 1 ]  [ j ]  . lbase = tentry . lbase ; %NWL%tblStack [ level - 1 ]  [ j ]  . next = tentry . next ; %NWL%7
if ( this . year . length ! = 4 || this . year . charAt ( 0 )  =  =  ' 0 '  )  {%NWL%return false ;%NWL%}%NWL%if ( !this . checkNumericString ( this . month ) || !this . checkNumericString ( this . year ) || !this . checkNumericString ( this . day )  )  {%NWL%return false ;%NWL%}%NWL%return true ;%NWL%}%NWL%DateFieldValidator . prototype . checkDate = function (  )  {%NWL%this . day = parseInt ( this . day )  ; %NWL%this . month = parseInt ( this . month )  ; %NWL%9
set baseURI ( value )  { this . _baseURI = value ;  }  ,%NWL%get encoding (  )  { return this . _encoding || null ;  }  ,%NWL%set encoding ( value )  { this . _encoding = value ;  }  ,%NWL%get certifiedText (  )  { return this . _certifiedText || null ;  }  ,%NWL%set certifiedText ( value )  { this . _certifiedText = value ;  }  ,%NWL%}  ; %NWL%ls . LSResourceResolver = function LSResourceResolver (  )  {  }  ; %NWL%ls . LSResourceResolver . prototype . resolveResource = function ( type , namespaceURI , publicId , systemId , baseURI )  {%NWL%return new ls . LSInput (  )  ;%NWL%}  ; %NWL%ls . LSParserFilter = function LSParserFilter (  )  {  }  ; %NWL%6
this . attributeName = null ; %NWL%this . attributeNamespace = null ; %NWL%this . oldValue = null ;%NWL%}%NWL%function copyMutationRecord ( original )  {%NWL%var record = new MutationRecord ( original . type , original . target )  ; %NWL%record . addedNodes = original . addedNodes . slice (  )  ; %NWL%record . removedNodes = original . removedNodes . slice (  )  ; %NWL%record . previousSibling = original . previousSibling ; %NWL%record . nextSibling = original . nextSibling ; %NWL%record . attributeName = original . attributeName ; %NWL%8
}%NWL%if ( typeof ( mapFun ) ! =  " string "  )  {%NWL%mapFun = mapFun . toSource ? mapFun . toSource (  )  :  "  (  "  + mapFun . toString (  )  +  "  )  "  ;%NWL%}%NWL%body . map = mapFun ; %NWL%if ( reduceFun ! = null )  {%NWL%if ( typeof ( reduceFun ) ! =  " string "  )  {%NWL%reduceFun = reduceFun . toSource ?%NWL%reduceFun . toSource (  )  :  "  (  "  + reduceFun . toString (  )  +  "  )  "  ;%NWL%}%NWL%body . reduce = reduceFun ; %NWL%4
lodash . defer = functions . defer ; %NWL%lodash . delay = functions . delay ; %NWL%lodash . difference = arrays . difference ; %NWL%lodash . filter = collections . filter ; %NWL%lodash . flatten = arrays . flatten ; %NWL%lodash . forEach = forEach ; %NWL%lodash . forEachRight = collections . forEachRight ; %NWL%lodash . forIn = objects . forIn ; %NWL%lodash . forInRight = objects . forInRight ; %NWL%lodash . forOwn = forOwn ; %NWL%lodash . forOwnRight = objects . forOwnRight ; %NWL%7
this . width = 0 ; %NWL%this . angle = 0 ; %NWL%this . x = 0 ; %NWL%this . y = 0 ; %NWL%this . confidence =  - 10000 ; %NWL%this . detection =  '  '  ; %NWL%this . time = 0 ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . facetrackr . TrackObj (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%9
execute : function ( options )  {%NWL%if ( typeof ( options . css ) ! =  =  ' object '  )  {%NWL%if ( options . css )  {%NWL%options . css =  [ options . css ]  ;%NWL%} else {%NWL%options . css =  [  ]  ;%NWL%}%NWL%}%NWL%if ( typeof ( options . js ) ! =  =  ' object '  )  {%NWL%if ( options . js )  {%NWL%options . js =  [ options . js ]  ; %NWL%3
module . exports . getTileRetry = getTileRetry ; %NWL%module . exports . putTileRetry = putTileRetry ; %NWL%module . exports . retryBackoff = 1000 ; %NWL%function DeserializationError ( msg )  {%NWL%this . message = msg ; %NWL%this . name =  ' DeserializationError '  ;%NWL%}%NWL%util . inherits ( DeserializationError , Error )  ; %NWL%function Tile ( z , x , y , buffer )  {%NWL%this . z = isNaN ( z ) ? undefined : Number ( z )  ; %NWL%this . x = isNaN ( x ) ? undefined : Number ( x )  ; %NWL%9
inGlobalTouch = false ; %NWL%$ ( window )  . bind (  " touchstart "  + eventClassName , function ( e )  {%NWL%inGlobalTouch = true ;%NWL%}  )  ; %NWL%$ ( window )  . bind (  " touchend "  + eventClassName , function ( e )  {%NWL%inGlobalTouch = false ;%NWL%}  )  ; %NWL%$this . bind (  " touchstart "  + eventClassName , function ( e )  {%NWL%var touch = e . originalEvent . targetTouches [ 0 ]  ; %NWL%startCoords . pageX = touch . pageX ; %NWL%startCoords . pageY = touch . pageY ; %NWL%9
function ( __dependency1__ , __dependency2__ , __dependency3__ , __exports__ )  {%NWL%" use strict "  ; %NWL%var Base = __dependency1__ [  " default "  ]  ; %NWL%var isSecureUrl = __dependency2__ [  " default "  ]  ; %NWL%var Configuration = __dependency3__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%serverTokenEndpoint :  '  / users / sign_in '  ,%NWL%resourceName :  ' user '  ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint = Configuration . serverTokenEndpoint ; %NWL%this . resourceName   = Configuration . resourceName ; %NWL%9
' use strict '  ; %NWL%angular . module (  ' angularCmsApp '  )  . controller (  ' AppCtrl '  , function ( $scope , $rootScope , $http , $log , $route , $location , $routeParams , $cookieStore , cmsSessionService , DataService , cmsSocketService )  {%NWL%var App ; %NWL%App = angular . copy ( Config )  ; %NWL%App . ds = DataService ; %NWL%App . socket = cmsSocketService ; %NWL%App . route = $routeParams ; %NWL%App . session = cmsSessionService . getSession (  )  ; %NWL%App . theme = $cookieStore . get (  ' App . theme '  )  ; %NWL%App . route = $route ; %NWL%App . location = $location ; %NWL%9
Emitter . prototype . fromJSON = function ( json )  {%NWL%Class . prototype . fromJSON . call ( this , json )  ; %NWL%this . sort = json . sort ; %NWL%this . positionType = json . positionType ; %NWL%this . velocityType = json . velocityType ; %NWL%this . material = json . material ? Assets . hash [ json . material ]  : undefined ; %NWL%this . position . fromJSON ( json . position )  ; %NWL%this . positionSpread . fromJSON ( json . positionSpread )  ; %NWL%this . positionRadius = json . positionRadius ; %NWL%this . speed = json . speed ; %NWL%this . speedSpread = json . speedSpread ; %NWL%2
next (  )  ;%NWL%}%NWL%exports = module . exports = function ( options )  {%NWL%options = options || {  }  ; %NWL%var limit = options . limit%NWL%? _limit ( options . limit )%NWL% : noop ; %NWL%return function multipart ( req , res , next )  {%NWL%if ( req . _body ) return next (  )  ; %NWL%req . body = req . body || {  }  ; %NWL%req . files = req . files || {  }  ; %NWL%9
fn : function ( store , records , options )  {%NWL%var storeRecords = store . getRange (  )  ; %NWL%for ( var i = 0 ; i < storeRecords . length ; i +  +  )  {%NWL%var record = storeRecords [ i ]  . data ; %NWL%record . dependencies = Ext . util . Format . htmlEncode ( record . dependencies )  ; %NWL%record . description = Ext . util . Format . htmlEncode ( record . description )  ; %NWL%record . requirements = Ext . util . Format . htmlEncode ( record . requirements )  ; %NWL%record . title = Ext . util . Format . htmlEncode ( record . title )  ; %NWL%record . versionName = Ext . util . Format . htmlEncode ( record . versionName )  ; %NWL%record . launchUrl = Ext . util . Format . htmlEncode ( record . launchUrl )  ; %NWL%record . author = Ext . util . Format . htmlEncode ( record . author )  ; %NWL%4
Behance =  {%NWL%api_url :  ' http :  /  / www . behance . net / v2 /  '  ,%NWL%api_key :  ' 12345678901234567890123456789012 '%NWL%}  ; %NWL%Behance . Model = Backbone . Model . extend (  {%NWL%sync : function ( method , model , options )  {%NWL%options . dataType =  ' jsonp '  ; %NWL%return Backbone . sync ( method , model , options )  ;%NWL%}  /  / sync%NWL%}  )  ; %NWL%Behance . Collection = Backbone . Collection . extend (  {%NWL%4
Fast [  ' function '  ]  = Fast . fn = require (  '  .  / function '  )  ; %NWL%Fast . object = require (  '  .  / object '  )  ; %NWL%Fast . string = require (  '  .  / string '  )  ; %NWL%Fast . apply = Fast [  ' function '  ]  . apply ; %NWL%Fast . bind = Fast [  ' function '  ]  . bind ; %NWL%Fast . partial = Fast [  ' function '  ]  . partial ; %NWL%Fast . partialConstructor = Fast [  ' function '  ]  . partialConstructor ; %NWL%Fast [  ' try '  ]  = Fast . attempt = Fast [  ' function '  ]  [  ' try '  ]  ; %NWL%Fast . assign = Fast . object . assign ; %NWL%Fast . cloneObject = Fast . object . clone ;  /  / @deprecated use fast . object . clone (  )%NWL%Fast . keys = Fast . object . keys ; %NWL%8
}  ,%NWL%enter : function ( unit )  {%NWL%unit . maxSpeed = _ . random ( 2 , 4 )  ; %NWL%if ( this . isMale )  {%NWL%unit . skin = _ . random ( Constants . skinIdMaleStart , Constants . skinIdMaleEnd )  ; %NWL%unit . hair = _ . random ( Constants . hairIdMaleStart , Constants . hairIdMaleEnd )  ; %NWL%unit . eyes = _ . random ( Constants . eyesIdMaleStart , Constants . eyesIdMaleEnd )  ;%NWL%}%NWL%else {%NWL%unit . skin = _ . random ( Constants . skinIdFemaleStart , Constants . skinIdFemaleEnd )  ; %NWL%unit . hair = _ . random ( Constants . hairIdFemaleStart , Constants . hairIdFemaleEnd )  ; %NWL%9
Object . preventExtensions = function preventExtensions ( object )  {%NWL%return object ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isSealed )  {%NWL%Object . isSealed = function isSealed ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isFrozen )  {%NWL%Object . isFrozen = function isFrozen ( object )  {%NWL%0
THREE . Object3D . prototype . cache = function (  )  {%NWL%return this ;%NWL%}  ;%NWL%}%NWL%}  ; %NWL%Application . prototype . getFromCache = function ( name )  {%NWL%return this . __t3cache__ [ name ]  ;%NWL%}  ; %NWL%Application . run = function ( options )  {%NWL%options . init = options . init || emptyFn ; %NWL%options . update = options . update || emptyFn ; %NWL%9
}%NWL%if ( this . tPropertyName )  {%NWL%this . setTransform = function ( node ,  transform )  {%NWL%return dojo . style ( node , this . tPropertyName , transform )  ;%NWL%}  ; %NWL%this . getTransform = function ( node )  {%NWL%return dojo . style ( node , this . tPropertyName )  ;%NWL%}  ;%NWL%} else if ( dojo . isIE )  {%NWL%this . setTransform = this . _setTransformFilter ; %NWL%this . getTransform = this . _getTransformFilter ; %NWL%9
level . dimension_name = dimension_name ; %NWL%level . name = desc . name ; %NWL%!desc . label || ( level . label = desc . label )  ; %NWL%!desc . description || ( level . description = desc . description )  ; %NWL%!desc . info || ( level . info = desc . info )  ; %NWL%level . _key = desc . key ; %NWL%level . _label_attribute = desc . label_attribute ; %NWL%level . _order_attribute = desc . order_attribute ; %NWL%!desc . role || ( level . role = desc . role )  ; %NWL%!desc . cardinality || ( level . cardinality = desc . cardinality )  ; %NWL%level . nonadditive = desc . nonadditive ; %NWL%1
if ( typeof this . horizontalPosition ! =  =  ' string '  )  {%NWL%css [ horizontalProperty ]  = this . horizontalPosition * this . scaleRatio ;%NWL%}%NWL%if ( typeof this . verticalPosition ! =  =  ' string '  )  {%NWL%css [ verticalProperty ]  = this . verticalPosition * this . scaleRatio ;%NWL%}%NWL%if ( typeof this . data . width =  =  =  ' string ' && this . data . width . indexOf (  ' % '  ) ! =  =  - 1 )  {%NWL%css . width =  ( parseInt ( this . data . width , 10 )  / this . scaleRatio )  . toString (  )  +  ' % '  ;%NWL%}%NWL%if ( typeof this . data . height =  =  =  ' string ' && this . data . height . indexOf (  ' % '  ) ! =  =  - 1 )  {%NWL%css . height =  ( parseInt ( this . data . height , 10 )  / this . scaleRatio )  . toString (  )  +  ' % '  ; %NWL%7
self . scripts [ record . script ]  . logs [ record . loc ]%NWL%record . reverse = record . reverse || {%NWL%currentLoc : self . currentLoc ,%NWL%currentScript : self . currentScript ,%NWL%script : record . script ,%NWL%loc : record . loc ,%NWL%lostMessageCounts : target && target . lostMessageCounts ,%NWL%caught : target && target . caught ,%NWL%val : target && target . val%NWL%}%NWL%record . forward = record . forward || {%NWL%1
this . err_form =  " Please enter / select values for the following fields : \n\n "  ; %NWL%this . err_select =  " Please select a valid \ " %FIELDNAME%\ "  "  ; %NWL%this . err_enter =  " Please enter a valid \ " %FIELDNAME%\ "  "  ;%NWL%}  ; %NWL%function Field ( element , form )  {%NWL%this . type = element . type ; %NWL%this . element = element ; %NWL%this . exclude = element . exclude||element . getAttribute (  ' exclude '  )  ; %NWL%this . err = element . err||element . getAttribute (  ' err '  )  ; %NWL%this . required = _parseBoolean ( element . required||element . getAttribute (  ' required '  )  )  ; %NWL%this . realname = element . realname||element . getAttribute (  ' realname '  )  ; %NWL%7
}  ; %NWL%var originalIt = context . it ; %NWL%context . it = runInsideFiber ( context . it )  ; %NWL%context . it . skip = runInsideFiber ( originalIt . skip )  ; %NWL%context . it . only = runInsideFiber ( originalIt . only )  ; %NWL%context . specify = context . it ; %NWL%context . xspecify = context . xit = context . it . skip ; %NWL%context . before = runInsideFiber ( context . before )  ; %NWL%context . beforeEach = runInsideFiber ( context . beforeEach )  ; %NWL%context . after = runInsideFiber ( context . after )  ; %NWL%context . afterEach = runInsideFiber ( context . afterEach )  ; %NWL%2
teleport_point	 : data . teleport_point ,%NWL%label		 : this . generate_label ( x , y )  ,%NWL%}  ; %NWL%out . pols +  = intval ( data . pol_count )  ;%NWL%}%NWL%}%NWL%return out ;%NWL%}%NWL%function set_info ( args )  {%NWL%this . name = args . name ; %NWL%this . style = args . style ; %NWL%9
clientId : clientId ,%NWL%clientSecret : clientSecret%NWL%}  ; %NWL%if ( parsedBody . scope )  {%NWL%gr . scope = parsedBody . scope ;%NWL%}%NWL%if ( options . tokenLifetime )  {%NWL%gr . tokenLifetime = options . tokenLifetime ;%NWL%}%NWL%if ( options . attributes )  {%NWL%gr . attributes = options . attributes ; %NWL%7
function hasWidth ( obj )  {%NWL%return obj && typeof obj =  =  ' object ' && (  ' width ' in obj )  ;%NWL%}%NWL%var Size = Class ( function (  )  {%NWL%this . init = function ( width , height )  {%NWL%if ( hasWidth ( width )  )  {%NWL%this . width = width . width ; %NWL%this . height = width . height ;%NWL%} else {%NWL%this . width = width || 0 ; %NWL%this . height = height || 0 ; %NWL%9
return this . base ;%NWL%}  ; %NWL%ImageSprite . prototype . loaded = function (  )  {%NWL%return !! ( this . data && this . img )  ;%NWL%}  ; %NWL%ImageSprite . prototype . resize = function (  )  {%NWL%if ( browser . devicePixelRatio > 1 ! =  = this . retina )  {%NWL%var newSprite = new ImageSprite ( this . base )  ; %NWL%newSprite . on (  ' load '  , function (  )  {%NWL%this . img = newSprite . img ; %NWL%this . data = newSprite . data ; %NWL%9
joinPoints [ i ]  [ adviceFactoryName ]  . apply ( joinPoints [ i ]  , arguments )  ;%NWL%}%NWL%return this ;%NWL%}  ;%NWL%}%NWL%proceedingJoinPoint . advice = adviceMetaFactory (  " advice "  )  ; %NWL%proceedingJoinPoint . around = adviceMetaFactory (  " around "  )  ; %NWL%proceedingJoinPoint . before = adviceMetaFactory (  " before "  )  ; %NWL%proceedingJoinPoint . after = adviceMetaFactory (  " after "  )  ; %NWL%proceedingJoinPoint . afterReturning = adviceMetaFactory (  " afterReturning "  )  ; %NWL%proceedingJoinPoint . afterThrowing = adviceMetaFactory (  " afterThrowing "  )  ; %NWL%6
return outputTransactionFormatter ( item )  ;%NWL%}  )  ;%NWL%}%NWL%return block ;%NWL%}  ; %NWL%var outputLogFormatter = function ( log )  {%NWL%if ( log =  =  = null )  {  /  /  ' pending ' && ' latest ' filters are nulls%NWL%return null ;%NWL%}%NWL%log . blockNumber = utils . toDecimal ( log . blockNumber )  ; %NWL%log . transactionIndex = utils . toDecimal ( log . transactionIndex )  ; %NWL%9
' #filters a '  :  ' filters '  ,%NWL%' #clear - completed '  :  ' clearCompleted '%NWL%}  ; %NWL%TodoApp . prototype . events =  {%NWL%' keyup #new - todo '  :  ' new '  ,%NWL%' click #toggle - all '  :  ' toggleAll '  ,%NWL%' click #clear - completed '  :  ' clearCompletedItem '%NWL%}  ; %NWL%function TodoApp (  )  {%NWL%this . renderFooter = __bind ( this . renderFooter , this )  ; %NWL%this . toggleElems = __bind ( this . toggleElems , this )  ; %NWL%9
if ( max_i > 0 && !this . selectionsProxy . activeRequest%NWL%&& this . fireEvent (  " beforeselectionsload "  , this , ranges ) ! =  = false )  {%NWL%var lParams = this . lastOptions . params ; %NWL%var params =  {  }  ; %NWL%params . ranges = Ext . encode ( ranges )  ; %NWL%if ( lParams )  {%NWL%if ( lParams . sort )  {%NWL%params . sort = lParams . sort ;%NWL%}%NWL%if ( lParams . dir )  {%NWL%params . dir = lParams . dir ; %NWL%7
if ( typeof exports ! =  =  ' undefined '  )  {%NWL%exports . getIsoModel = function ( gameWorld , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )%NWL%{%NWL%var gameWorldObj =  {  }  ; %NWL%gameWorldObj . Cells  = gameWorld ;  /  / hack because this was written for clientside originally . sorry time is short :  /%NWL%return new GameWorldModelIso ( gameWorldObj , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )  ;%NWL%}%NWL%exports . update = GameWorldModelIso . prototype . update ; %NWL%exports . getAllVisibleCells = GameWorldModelIso . prototype . getAllVisibleCells ; %NWL%exports . getSortCellOfSprite = GameWorldModelIso . prototype . getSortCellOfSprite ; %NWL%exports . getRandomOnScreenCel = GameWorldModelIso . prototype . getRandomOnScreenCel ; %NWL%7
}  )%NWL%. controller (  ' YaTreeviewCtrl '  , function ( $scope , $timeout , YaTreeviewService )  {%NWL%var fillOptions = function ( clientOptions )  {%NWL%var options =  {  }  ; %NWL%clientOptions = clientOptions || {  }  ; %NWL%options . childrenKey = clientOptions . childrenKey || ' children '  ; %NWL%options . hasChildrenKey = clientOptions . hasChildrenKey || ' has_children '  ; %NWL%options . onExpand = clientOptions . onExpand || angular . noop ; %NWL%options . onCollapse = clientOptions . onCollapse || angular . noop ; %NWL%options . onSelect = clientOptions . onSelect || angular . noop ; %NWL%options . onDblClick = clientOptions . onDblClick || angular . noop ; %NWL%7
snapType : this . precedence [ best . rank ]  ,%NWL%layer : best . target . layer ,%NWL%distance : best . dist%NWL%}  )  ;%NWL%} else {%NWL%snapped = false ;%NWL%}%NWL%}%NWL%if ( this . point && !snapped )  {%NWL%point . x = loc . x ; %NWL%point . y = loc . y ; %NWL%9
relative . host : result . host ; %NWL%result . hostname =  ( relative . hostname || relative . hostname =  =  =  '  '  ) ?%NWL%relative . hostname : result . hostname ; %NWL%result . search = relative . search ; %NWL%result . query = relative . query ; %NWL%srcPath = relPath ;%NWL%} else if ( relPath . length )  {%NWL%if ( !srcPath ) srcPath =  [  ]  ; %NWL%srcPath . pop (  )  ; %NWL%srcPath = srcPath . concat ( relPath )  ; %NWL%result . search = relative . search ; %NWL%4
version : tinymce . majorVersion +  "  .  "  + tinymce . minorVersion%NWL%}  ;%NWL%}  ,%NWL%_htmlToData : function (  )  {%NWL%var headerFragment = this . _parseHeader (  )  , data =  {  }  , nodes , elm , matches , editor = this . editor ; %NWL%function getAttr ( elm , name )  {%NWL%var value = elm . attr ( name )  ; %NWL%return value || '  '  ;%NWL%}  ; %NWL%data . fontface = editor . getParam (  " fullpage_default_fontface "  ,  "  "  )  ; %NWL%data . fontsize = editor . getParam (  " fullpage_default_fontsize "  ,  "  "  )  ; %NWL%9
}  ; %NWL%var offset = 0 ; %NWL%var mapAlbum = function ( data )  {%NWL%var song = data ; %NWL%var coverartthumb , coverartfull , starred , title , album , publisher , avg_rating , downloads , identifier , source , date ; %NWL%var url = globals . archiveUrl +  ' details /  '  + song . identifier ; %NWL%coverartthumb =  ' images / albumdefault_50 . jpg '  ; %NWL%coverartfull =  ' images / albumdefault_160 . jpg '  ; %NWL%if ( parseInt ( song . avg_rating )  =  = 5 )  { starred = true ;  } else { starred = false ;  }%NWL%if ( typeof song . title =  =  ' undefined '  )  { title =  ' &nbsp ;  '  ;  } else { title = song . title . toString (  )  ;  }%NWL%if ( typeof song . identifier =  =  ' undefined '  )  { identifier =  ' &nbsp ;  '  ;  } else { identifier = song . identifier . toString (  )  ;  }%NWL%9
console . log (  ' KAPUTT '  )  ;%NWL%}%NWL%dst = dst . substr ( root . length )%NWL%return paths . map ( function ( p )  { return path . relative ( path . dirname ( dst )  , p )  }  )  ;%NWL%}%NWL%var helpers = exports . helpers = function helpers ( ctx , options )  {%NWL%options = options || {  }  ; %NWL%var helpers =  {  }  ; %NWL%helpers . title = function title ( t )  { if ( t )  { ctx . title = t } return ctx . title }%NWL%helpers . script = function script ( s )  { ctx . scripts . push ( s )  }%NWL%helpers . stylesheet = function stylesheet ( s )  { ctx . stylesheets . push ( s )  }%NWL%9
if ( hostOptions . port )  {%NWL%this . port = hostOptions . port ;%NWL%}%NWL%}%NWL%}  ; %NWL%ServiceManagementClient . prototype . _setServiceHostFromSettings = function ( settings )  {%NWL%this . apiversion = ServiceManagementClient . DefaultAPIVersion ; %NWL%var hostUrl = url . parse ( settings . _endpointUri )  ; %NWL%this . host = hostUrl . hostname ; %NWL%this . protocol = hostUrl . protocol ; %NWL%this . port = hostUrl . port ; %NWL%9
this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%this . width  = aabb . width ; %NWL%this . height = aabb . height ; %NWL%this . halfWidth = aabb . halfWidth ; %NWL%this . halfHeight = aabb . halfHeight ; %NWL%this . left = aabb . left ; %NWL%this . right = aabb . right ; %NWL%this . top = aabb . top ; %NWL%this . bottom = aabb . bottom ; %NWL%0
}%NWL%}%NWL%}%NWL%this . play				 = function (  )  {  /  / called as object method%NWL%this . _play (  )  ;%NWL%}%NWL%this . love_audio_play	 = function (  )  {  /  / called as api function%NWL%this . _play (  )  ;%NWL%}%NWL%this . type			 = function (  )  { return NotImplemented ( pre +  ' type '  )  ;  }%NWL%this . typeOf			 = function (  )  { return NotImplemented ( pre +  ' typeOf '  )  ;  }%NWL%9
this . resolvedModels =  {  }  ; %NWL%this . queryParams =  {  }  ; %NWL%if ( error )  {%NWL%this . promise = Promise . reject ( error )  ; %NWL%this . error = error ; %NWL%return ;%NWL%}%NWL%if ( state )  {%NWL%this . params = state . params ; %NWL%this . queryParams = state . queryParams ; %NWL%this . handlerInfos = state . handlerInfos ; %NWL%8
{%NWL%console . log (  ' Deleted Repo :  '  + repo )  ; %NWL%$window . location . href =  " #showRepositories?namespace =  "  + $scope . namespace ; %NWL%$route . reload (  )  ;%NWL%}  )  . error ( function ( data )  {  }  )  ;  ;%NWL%}  ;%NWL%}%NWL%}  )  ; %NWL%app . controller (  ' ImagesController '  , function ( $scope , $http , $location , $window , $cookies , $route )  {%NWL%$scope . IP = $cookies . IP ; %NWL%$scope . protocol = $cookies . protocol ; %NWL%9
}  ; %NWL%var seenFeatures =  {  }  ; %NWL%array . forEach ( rows , function ( row )  {%NWL%var f =  { data :  { subfeatures :  [  ]  }  }  ; %NWL%var data = f . data ; %NWL%array . forEach ( fields , function ( field )  {%NWL%if ( field in row )%NWL%data [ field ]  = row [ field ]  . value ;%NWL%}  )  ; %NWL%data . start = parseInt ( data . start )  ; %NWL%data . end = parseInt ( data . end )  ; %NWL%9
this . _styleParams =  {  }  ; %NWL%this . _catalogNode = null ; %NWL%this . _currentPageNode = null ; %NWL%this . _transitionEndHandle = null ; %NWL%this . init = function ( w , h , turnfrom ,%NWL%page , dogear , duration ,%NWL%alwaysDogeared )  {%NWL%this . w = w ; %NWL%this . h = h ; %NWL%this . turnfrom = turnfrom ? turnfrom : this . turnfrom ; %NWL%this . page = page ? page : this . page ; %NWL%9
constructor : function (  )  {%NWL%gs . Container . _init . call ( this )  ;%NWL%}  ,%NWL%destroy : function (  )  {%NWL%window [ this . _onLoadName ]  = nullFunc ; %NWL%delete surfaces [ this . _nodeName ]  ; %NWL%this . inherited ( arguments )  ;%NWL%}  ,%NWL%setDimensions : function ( width , height )  {%NWL%this . width  = g . normalizedLength ( width )  ; 	 /  / in pixels%NWL%this . height = g . normalizedLength ( height )  ; 	 /  / in pixels%NWL%9
if ( context_block_overrides && context_block_overrides . _initialResult ! = null && context_block_overrides . _initialResult ! = undefined )  {%NWL%_blockContext . _result = context_block_overrides . _initialResult%NWL%}%NWL%expressionInstance . _blockContext = _blockContext%NWL%expressionInstance . ensureInitialized (  )%NWL%var localVarsKeys = Object . keys ( localVariables )%NWL%for ( var i = 0 ; i < localVarsKeys . length ; i +  +  )  {%NWL%expressionInstance . vars [ localVarsKeys [ i ]  ]  = localVariables [ localVarsKeys [ i ]  ]%NWL%}%NWL%expressionInstance . resultCallback = _blockContext . _resultCallback ; %NWL%expressionInstance . errorCallback = _blockContext . _errorCallback ; %NWL%9
statusUpdate (  ' Cancelled : swiped right from right '  )  ;%NWL%}%NWL%}%NWL%action =  {  }  ;%NWL%}%NWL%function cmptContactStart ( evt )  {%NWL%if ( actionIsCancelled ( evt )  )  { return resetAction (  )  ;  }%NWL%action . startX = evt . m . readerX ; %NWL%action . startY = evt . m . readerY ; %NWL%action . screenX = evt . m . screenX ; %NWL%action . screenY = evt . m . screenY ; %NWL%9
locClearColor . r = clearColor . r ; %NWL%locClearColor . g = clearColor . g ; %NWL%locClearColor . b = clearColor . b ; %NWL%locClearColor . a = clearColor . a ; %NWL%this . _clearColorStr =  " rgba (  "  +  ( 0 | clearColor . r )  +  "  ,  "  +  ( 0 | clearColor . g )  +  "  ,  "  +  ( 0 | clearColor . b )  +  "  ,  "  + clearColor . a / 255 +  "  )  "  ;%NWL%}  ,%NWL%_setClearColorForWebGL : function ( clearColor )  {%NWL%var locClearColor = this . _clearColor ; %NWL%locClearColor . r = clearColor . r ; %NWL%locClearColor . g = clearColor . g ; %NWL%locClearColor . b = clearColor . b ; %NWL%1
if ( options . matchBase && - 1 =  =  = pattern . indexOf (  "  /  "  )  )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . strict = options . strict ! =  = false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%7
this . status = details . status || this . status ; %NWL%this . name = details . name || this . name ; %NWL%this . allowedAddressPairs = details . allowed_address_pairs	 || this . allowedAddressPairs ; %NWL%this . adminStateUp = details . admin_state_up || this . adminStateUp ; %NWL%this . networkId = details . network_id || this . networkId ; %NWL%this . tenantId = details . tenant_id || this . tenantId ; %NWL%this . extraDhcpOpts = details . extra_dhcp_opts || this . extraDhcpOpts ; %NWL%this . deviceOwner = details . device_owner || this . deviceOwner ; %NWL%this . macAddress = details . mac_address || this . macAddress ; %NWL%this . fixedIps = details . fixed_ips || this . fixedIps ; %NWL%this . id = details . id || this . id ; %NWL%0
var closed = false ; %NWL%this . action = action ; %NWL%this . type = type ; %NWL%this . data = data ; %NWL%this . extras = extras ; %NWL%this . postResult = function ( data , extras )  {%NWL%if ( closed ) return ; %NWL%var iframe = document . getElementById (  " webintents_channel "  )  ; %NWL%var returnIntent = new Intent (  )  ; %NWL%returnIntent . _id = me . _id ; %NWL%returnIntent . action = me . action ; %NWL%9
lanyard . Level = function ( params )  {%NWL%this . _logger = goog . debug . Logger . getLogger (  ' lanyard . Level '  )  ; %NWL%if ( !params )  {%NWL%this . _logger . severe (  ' Attempted to create a level with invalid params .  '  )  ;%NWL%}%NWL%this . params = params ; %NWL%this . levelName = this . params . levelName ? this . params . levelName :  '  '  ; %NWL%this . levelNumber = this . params . levelNumber ; %NWL%this . tileDelta = this . params . tileDelta ; %NWL%this . tileWidth = this . params . tileWidth ; %NWL%this . tileHeight = this . params . tileHeight ; %NWL%7
gl . bindTexture ( target , null )  ;%NWL%}  ; %NWL%CubeMap . prototype . isDestroyed = function (  )  {%NWL%return false ;%NWL%}  ; %NWL%CubeMap . prototype . destroy = function (  )  {%NWL%this . _gl . deleteTexture ( this . _texture )  ; %NWL%this . _positiveX = destroyObject ( this . _positiveX )  ; %NWL%this . _negativeX = destroyObject ( this . _negativeX )  ; %NWL%this . _positiveY = destroyObject ( this . _positiveY )  ; %NWL%this . _negativeY = destroyObject ( this . _negativeY )  ; %NWL%7
this . setTextType ( Shape . TEXT_NONE )  ; %NWL%this . images . display = UIElement . IMAGE_DISPLAY_CENTER ; %NWL%this . points =  [  { x : 0 , y : 80 }  ,  { x : 0 , y : 0 }  ,  { x : 80 , y : 0 }  ,  { x : 80 , y : 80 }  ]  ; %NWL%this . regSerializer ( this . fourJointToJson , this . fourJointFromJson )  ; %NWL%return this ;%NWL%}%NWL%UIFourJoint . prototype . fourJointToJson = function ( o )  {%NWL%o . points =  [  {  }  ,  {  }  ,  {  }  ,  {  }  ]  ; %NWL%o . points [ 0 ]  . x = this . points [ 0 ]  . x ; %NWL%o . points [ 0 ]  . y = this . points [ 0 ]  . y ; %NWL%o . points [ 1 ]  . x = this . points [ 1 ]  . x ; %NWL%8
}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%prepareControlModel : function ( callback )%NWL%{%NWL%var self = this ; %NWL%var model =  {  }  ; %NWL%model . id = this . getId (  )  ; %NWL%model . name = this . name ; %NWL%model . options = this . options ; %NWL%9
return ;%NWL%}%NWL%if ( this . dalpha =  =  = null )  {%NWL%console . log (  " calbrate "  , event . beta )  ; %NWL%this . dalpha = event . alpha ; %NWL%this . dbeta = event . beta ; %NWL%this . dgamma = event . gamma ;%NWL%}%NWL%this . alpha = event . alpha - this . dalpha ; %NWL%this . beta = event . beta - this . dbeta ; %NWL%this . gamma = event . gamma - this . dgamma ; %NWL%8
this . key = key ; %NWL%this . expr = expr ; %NWL%this . block = block ;%NWL%}  ; %NWL%Each . prototype . __proto__ = Node . prototype ; %NWL%Each . prototype . clone = function ( parent )  {%NWL%var clone = new Each ( this . val , this . key )  ; %NWL%clone . expr = this . expr . clone ( parent , clone )  ; %NWL%clone . block = this . block . clone ( parent , clone )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%9
json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%json . colorSpread = this . colorSpread . toJSON ( json . colorSpread )  ; %NWL%json . time = this . time ; %NWL%json . _time = this . _time ; %NWL%json . duration = this . duration ; %NWL%json . loop = this . loop ; %NWL%json . playing = this . playing ; %NWL%json . emitting = this . emitting ; %NWL%0
function last ( element , page , totalPages )  {%NWL%update ( element , LAST , totalPages , page >  = totalPages )  ;%NWL%}%NWL%var Pager = Widget . extend (  {%NWL%init : function ( element , options )  {%NWL%var that = this , page , totalPages ; %NWL%Widget . fn . init . call ( that , element , options )  ; %NWL%options = that . options ; %NWL%that . dataSource = kendo . data . DataSource . create ( options . dataSource )  ; %NWL%that . linkTemplate = kendo . template ( that . options . linkTemplate )  ; %NWL%that . selectTemplate = kendo . template ( that . options . selectTemplate )  ; %NWL%9
{%NWL%var s = restoreItem ( saveName . settings )  ; %NWL%if ( !s ) return false ; %NWL%uiSettings . markOwnUnits = s . markOwnUnits ; %NWL%uiSettings . markEnemyUnits = s . markEnemyUnits ; %NWL%uiSettings . use3D = s . use3D ; %NWL%uiSettings . useRetina = s . useRetina ; %NWL%uiSettings . showGridTerrain = s . showGridTerrain ; %NWL%uiSettings . muteUnitSounds = s . muteUnitSounds ; %NWL%for ( var i = 0 ; i < s . isAI . length ; i +  +  )%NWL%uiSettings . isAI [ i ]  = s . isAI [ i ]  ; %NWL%3
chainable . or = function ( query )  {%NWL%if ( !Array . isArray ( finder . query )  )  {%NWL%finder . query =  [ finder . query ]  ;%NWL%}%NWL%finder . query . push ( query )  ; %NWL%return chainable ;%NWL%}  ; %NWL%chainable . limit = function ( limit )  {%NWL%finder . limit = limit ;%NWL%}  ; %NWL%chainable . offset = function ( offset )  {%NWL%7
this . prevX = this . currX ; %NWL%this . prevY = this . currY ;%NWL%}  ; %NWL%JSM . Mouse . prototype . Move = function ( event , div )%NWL%{%NWL%var eventParameters = event ; %NWL%if ( eventParameters =  =  = undefined )  {%NWL%eventParameters = window . event ;%NWL%}%NWL%this . shift = event . shiftKey ; %NWL%this . ctrl = event . ctrlKey ; %NWL%9
if ( !opts ) opts =  {  }%NWL%readDatJSON ( paths . package , function ( err , data )  {%NWL%if ( err ) return cb ( err )%NWL%data . adminUser = opts . adminUser || data . adminUser || process . env [  " DAT_ADMIN_USER "  ]%NWL%data . adminPass = opts . adminPass || data . adminPass || process . env [  " DAT_ADMIN_PASS "  ]%NWL%data . blobs = normalizeModule ( opts . blobs || data . blobs ,  ' content - addressable - blob - store '  )%NWL%data . replicator = normalizeModule ( opts . replicator || data . replicator ,  ' dat - replicator '  )%NWL%data . leveldown = normalizeModule ( opts . leveldown || data . leveldown ,  ' leveldown - prebuilt '  )%NWL%data . transformations = opts . transformations || data . transformations || {  }%NWL%data . hooks = opts . hooks || data . hooks || {  }%NWL%data . remotes = opts . remotes || data . remotes || {  }%NWL%8
var StackResource = function ( options )  {%NWL%if ( ! ( this instanceof StackResource )  )  {%NWL%return new StackResource ( options )  ;%NWL%}%NWL%if ( typeof options =  =  =  " string "  )  {%NWL%options =  { name : options }  ;%NWL%}%NWL%assert ( options . name ,  " should provide collection name "  )  ; %NWL%this . name = options . name ; %NWL%this . debug = require (  " debug "  )  (  " resource :  "  + this . name )  ; %NWL%this . pagination = options . pagination ; %NWL%8
self . width = colDef . width ;%NWL%}%NWL%}%NWL%}%NWL%self . minWidth = !colDef . minWidth ? 30 : colDef . minWidth ; %NWL%self . maxWidth = !colDef . maxWidth ? 9000 : colDef . maxWidth ; %NWL%self . field =  ( colDef . field =  =  = undefined ) ? colDef . name : colDef . field ; %NWL%if ( typeof ( self . field ) ! =  =  ' string '  )  {%NWL%gridUtil . logError (  ' Field is not a string , this is likely to break the code , Field is :  '  + self . field )  ;%NWL%}%NWL%self . name = colDef . name ; %NWL%0
}  ; %NWL%Field . prototype . Merge = function ( element )  {%NWL%var required = _parseBoolean ( element . getAttribute (  ' required '  )  )  ; %NWL%if ( required )  {%NWL%this . required = true ;%NWL%}  ; %NWL%if ( !this . err )  {%NWL%this . err = element . getAttribute (  ' err '  )  ;%NWL%}  ; %NWL%if ( !this . equals )  {%NWL%this . equals = element . getAttribute (  ' equals '  )  ; %NWL%7
if (  ( win && (  " ontouchstart " in win )  ) && ! ( Y . UA . chrome && Y . UA . chrome < 6 )  )  {%NWL%GESTURE_MAP . start =  [  " touchstart "  ,  " mousedown "  ]  ; %NWL%GESTURE_MAP . end =  [  " touchend "  ,  " mouseup "  ]  ; %NWL%GESTURE_MAP . move =  [  " touchmove "  ,  " mousemove "  ]  ; %NWL%GESTURE_MAP . cancel =  [  " touchcancel "  ,  " mousecancel "  ]  ;%NWL%}%NWL%else if ( win && win . PointerEvent )  {%NWL%GESTURE_MAP . start =  " pointerdown "  ; %NWL%GESTURE_MAP . end =  " pointerup "  ; %NWL%GESTURE_MAP . move =  " pointermove "  ; %NWL%GESTURE_MAP . cancel =  " pointercancel "  ; %NWL%9
if ( data . description )  {%NWL%description = data . description ;%NWL%}%NWL%else {%NWL%description =  ' A webinos '  + type +  ' actuator '  ;%NWL%}%NWL%if ( data . range )  {%NWL%this . range = data . range ;%NWL%}%NWL%if ( data . unit )  {%NWL%this . unit = data . unit ; %NWL%7
name :  " toggleCaseSensitive "  ,%NWL%bindKey :  { win :  " Alt - C|Alt - I "  , mac :  " Ctrl - Alt - R|Ctrl - Alt - I "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . caseSensitiveOption . checked = !sb . caseSensitiveOption . checked ; %NWL%sb . $syncOptions (  )  ;%NWL%}%NWL%}  ,  {%NWL%name :  " toggleWholeWords "  ,%NWL%bindKey :  { win :  " Alt - B|Alt - W "  , mac :  " Ctrl - Alt - B|Ctrl - Alt - W "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . wholeWordOption . checked = !sb . wholeWordOption . checked ; %NWL%3
}  ; %NWL%module . exports . protocol = require (  '  .  .  / protocol . js '  )  ; %NWL%var WEB_ROOT = module . exports . WEB_ROOT = path . resolve ( path . dirname ( module . filename )  ,  '  .  .  /  .  .  / static '  )  ; %NWL%function getApi ( queen )  {%NWL%var api = queen . getWorkforce . bind ( queen )  ; %NWL%api . on = queen . emitter . on . bind ( queen . emitter )  ; %NWL%api . removeListener = queen . emitter . removeListener . bind ( queen . emitter )  ; %NWL%api . kill = queen . kill ; %NWL%api . getWorkerProvider = queen . getWorkerProvider . bind ( queen )  ; %NWL%api . acquireWebSocketEndpoint = queen . acquireWebSocketEndpoint . bind ( queen )  ; %NWL%api . assignHttpEndpoint = queen . assignHttpEndpoint . bind ( queen )  ; %NWL%8
this . ShipPostalCode = ko . observable (  )  ; %NWL%this . ShipCountry = ko . observable (  )  ; %NWL%this . esPrimaryKeys = function (  )  {%NWL%return this . OrderID (  )  ;%NWL%}%NWL%this . esExtendedData = undefined ; %NWL%this . UpToProductsCollection = es . defineLazyLoader ( this ,  ' UpToProductsCollection '  )  ; %NWL%this . OrderDetailsCollectionByOrderID = es . defineLazyLoader ( this ,  ' OrderDetailsCollectionByOrderID '  )  ; %NWL%this . UpToCustomersByCustomerID = es . defineLazyLoader ( this ,  ' UpToCustomersByCustomerID '  )  ; %NWL%this . UpToEmployeesByEmployeeID = es . defineLazyLoader ( this ,  ' UpToEmployeesByEmployeeID '  )  ; %NWL%this . UpToShippersByShipVia = es . defineLazyLoader ( this ,  ' UpToShippersByShipVia '  )  ; %NWL%6
fileGridSize : 32 ,%NWL%MAX_LOADING_TILES : 4%NWL%}  ; %NWL%og . terrainProvider . TerrainProvider = function ( name , options )  {%NWL%this . name = name || "  "  ; %NWL%options = options || {  }  ; %NWL%this . minZoom = options . minZoom || og . terrainProvider . defaultOptions . minZoom ; %NWL%this . maxZoom = options . maxZoom || og . terrainProvider . defaultOptions . maxZoom ; %NWL%this . url = options . url || og . terrainProvider . defaultOptions . url ; %NWL%this . gridSizeByZoom = options . gridSizeByZoom || og . terrainProvider . defaultOptions . gridSizeByZoom ; %NWL%this . fileGridSize = options . fileGridSize || og . terrainProvider . defaultOptions . fileGridSize ; %NWL%6
this . _onDisconnect = new lib . Callback (  )  ; %NWL%this . _clients =  {  }  ; %NWL%this . _requests =  {  }  ; %NWL%this . _subs =  {  }  ; %NWL%this . _eventListeners =  {  }  ; %NWL%this . _requestListeners =  {  }  ;%NWL%}%NWL%this . end =%NWL%this . disconnect = function (  )  { this . transport . loseConnection (  )  ;  }%NWL%this . onConnect = function (  )  { this . _onConnect . forward ( arguments )  ;  }%NWL%this . onDisconnect = function (  )  { this . _onDisconnect . forward ( arguments )  ;  }%NWL%9
}  ; %NWL%exports . ADDRCONFIG = cares . AI_ADDRCONFIG ; %NWL%exports . V4MAPPED = cares . AI_V4MAPPED ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%3
if ( args . enableSingleNoteSharing ! =  = undefined )  {%NWL%this . enableSingleNoteSharing = args . enableSingleNoteSharing ;%NWL%}%NWL%if ( args . enableSponsoredAccounts ! =  = undefined )  {%NWL%this . enableSponsoredAccounts = args . enableSponsoredAccounts ;%NWL%}%NWL%if ( args . enableTwitterSharing ! =  = undefined )  {%NWL%this . enableTwitterSharing = args . enableTwitterSharing ;%NWL%}%NWL%if ( args . enableLinkedInSharing ! =  = undefined )  {%NWL%this . enableLinkedInSharing = args . enableLinkedInSharing ; %NWL%1
exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%exports . BADFLAGS =  ' EBADFLAGS '  ; %NWL%exports . NONAME =  ' ENONAME '  ; %NWL%0
var cartOrder  = session . cartOrder%NWL%, draftOrder  = session . draftOrder%NWL%, lookups   = session . lookups%NWL%, info   = getOrderItemInfo (  )%NWL%, isDraftOrder = false ; %NWL%if ( info )  {%NWL%isDraftOrder  = info . orderItem . order =  =  = session . draftOrder%NWL%vm . addToCart  = addToCart%NWL%vm . isDraftOrder = isDraftOrder%NWL%vm . orderItem  = info . orderItem%NWL%vm . product   = info . product%NWL%9
for ( var key in rules )  {%NWL%var state = rules [ key ]  ; %NWL%for ( var i = 0 ; i < state . length ; i +  +  )  {%NWL%var rule = state [ i ]  ; %NWL%if ( rule . next || rule . onMatch )  {%NWL%if ( typeof rule . next ! =  " string "  )  {%NWL%if ( rule . nextState && rule . nextState . indexOf ( prefix ) ! =  = 0 )%NWL%rule . nextState = prefix + rule . nextState ;%NWL%} else {%NWL%if ( rule . next . indexOf ( prefix ) ! =  = 0 )%NWL%rule . next = prefix + rule . next ; %NWL%7
}%NWL%Vizi . PickManager . handleTouchEnd = function ( event )%NWL%{%NWL%if ( event . changedTouches . length > 0 )  {%NWL%event . screenX = event . changedTouches [ 0 ]  . screenX ; %NWL%event . screenY = event . changedTouches [ 0 ]  . screenY ; %NWL%event . clientX = event . changedTouches [ 0 ]  . clientX ; %NWL%event . clientY = event . changedTouches [ 0 ]  . clientY ; %NWL%event . pageX = event . changedTouches [ 0 ]  . pageX ; %NWL%event . pageY = event . changedTouches [ 0 ]  . pageY ; %NWL%event . elementX = event . changedTouches [ 0 ]  . elementX ; %NWL%4
" $require_match "  )  ; %NWL%function webjump ( name , handler )  {%NWL%keywords ( arguments ,%NWL%$alternative = null ,%NWL%$require_match = false )  ; %NWL%this . name = name ; %NWL%this . alternative = arguments . $alternative ; %NWL%this . completer = arguments . $completer ; %NWL%this . doc = arguments . $doc ; %NWL%this . post_data = arguments . $post_data ; %NWL%this . require_match = arguments . $require_match ; %NWL%6
canvas . focus (  )  ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%qt . Button = function ( id , display , access , title , instance )  {%NWL%var t = this ; %NWL%t . id = id ; %NWL%t . display = display ; %NWL%t . access = access ; %NWL%t . title = title || '  '  ; %NWL%t . instance = instance || '  '  ; %NWL%9
exports . utils =  {%NWL%arrays : require (  '  .  / gamejs / utils / arrays '  )  ,%NWL%objects : require (  '  .  / gamejs / utils / objects '  )  ,%NWL%uri : require (  '  .  / gamejs / utils / uri '  )  ,%NWL%strings : require (  '  .  / gamejs / utils / strings '  )  ,%NWL%xml : require (  '  .  / gamejs / utils / xml '  )  ,%NWL%base64 : require (  '  .  / gamejs / utils / base64 '  )%NWL%}  ; %NWL%exports . display = require (  '  .  / gamejs / display '  )  ; %NWL%exports . pathfinding = require (  '  .  / gamejs / pathfinding '  )  ; %NWL%exports . tiledmap = require (  '  .  / gamejs / tiledmap '  )  ; %NWL%8
result = result . code +  ' \n '  + sourcemapToComment ( result . map )  ;%NWL%}%NWL%return result ;%NWL%}  ; %NWL%function sourcemapToComment ( map )  {%NWL%var convertSourceMap = require (  ' convert - source - map '  )  ; %NWL%var content = convertSourceMap . fromObject ( map )  . toBase64 (  )  ; %NWL%return '  '  ;%NWL%}%NWL%exports . mixin = exports . mixins = require (  '  .  / plugins / mixin '  )  ; %NWL%exports . function = exports . functions = require (  '  .  / plugins / function '  )  ; %NWL%9
cubicvr_nodeToMotion ( position , enums . motion . POS , cam . motion )  ;%NWL%} else if ( position )  {%NWL%cam . position = util . floatDelimArray ( position . firstChild . nodeValue )  ;%NWL%}%NWL%if ( cubicvr_isMotion ( rotation )  )  {%NWL%if ( !cam . motion )  {%NWL%cam . motion = new CubicVR . Motion (  )  ;%NWL%}%NWL%cubicvr_nodeToMotion ( rotation , enums . motion . ROT , cam . motion )  ;%NWL%} else if ( rotation )  {%NWL%cam . rotation = util . floatDelimArray ( rotation . firstChild . nodeValue )  ; %NWL%2
}  )  ; %NWL%elem . customGETLIST = _ . bind ( fetchFunction , elem )  ; %NWL%elem . doGETLIST = elem . customGETLIST ;%NWL%}%NWL%function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%7
grid . api . registerMethodsFromObject ( publicApi . methods )  ;%NWL%}  ,%NWL%defaultGridOptions : function ( gridOptions )  {%NWL%gridOptions . saveWidths = gridOptions . saveWidths ! =  = false ; %NWL%gridOptions . saveOrder = gridOptions . saveOrder ! =  = false ; %NWL%gridOptions . saveScroll = gridOptions . saveScroll =  =  = true ; %NWL%gridOptions . saveFocus = gridOptions . saveScroll ! =  = true && gridOptions . saveFocus ! =  = false ; %NWL%gridOptions . saveVisible = gridOptions . saveVisible ! =  = false ; %NWL%gridOptions . saveSort = gridOptions . saveSort ! =  = false ; %NWL%gridOptions . saveFilter = gridOptions . saveFilter ! =  = false ; %NWL%gridOptions . saveSelection = gridOptions . saveSelection ! =  = false ; %NWL%3
Utils . extend ( opts , defaults )  ; %NWL%this . opts = defaults ; %NWL%this . frames =  [  ]  ; %NWL%if ( this . firstTick =  = null )  {%NWL%this . firstTick = new Date (  )  ;%NWL%}%NWL%this . container = document . getElementById ( containerId )  ; %NWL%this . container . width =  ' 500 '  ; %NWL%this . container . height =  ' 105 '%NWL%this . width = this . container . width ; %NWL%this . height = this . container . height ; %NWL%9
function ignoreMap ( pattern )  {%NWL%var gmatcher = null%NWL%if ( pattern . slice (  - 3 )  =  =  =  '  "  + pattern%NWL%}%NWL%self . pattern = pattern%NWL%self . strict = options . strict ! =  = false%NWL%self . realpath = !!options . realpath%NWL%self . realpathCache = options . realpathCache || Object . create ( null )%NWL%self . follow = !!options . follow%NWL%self . dot = !!options . dot%NWL%self . mark = !!options . mark%NWL%6
}%NWL%this . tilesets . push ( instileset )  ;%NWL%}%NWL%var layers = map . getElementsByTagName (  ' layer '  )  ; %NWL%this . layers = new Array (  )  ; %NWL%for ( i = 0 ; i < layers . length ; i +  +  )  {%NWL%var inslayer = new Object (  )  ; %NWL%inslayer . properties = new Array (  )  ; %NWL%inslayer . name = layers [ i ]  . attributes . getNamedItem (  " name "  )  . nodeValue ; %NWL%inslayer . width = parseInt ( layers [ i ]  . attributes . getNamedItem (  " width "  )  . nodeValue )  ; %NWL%inslayer . height = parseInt ( layers [ i ]  . attributes . getNamedItem (  " height "  )  . nodeValue )  ; %NWL%9
this . context = params . context ; %NWL%this . centerX = params . centerX ; %NWL%this . centerY = params . centerY ; %NWL%this . arcWidth = params . arcWidth ; %NWL%this . innerRadius = params . innerRadius || 0 ; %NWL%this . fillColor = params . fillColor || ' #fff '  ; %NWL%this . outlineColor = params . outlineColor || this . fillColor ; %NWL%this . progressListener = params . progressListener ; %NWL%this . infoLineLength = params . infoLineLength || 250 ; %NWL%this . horizLineLength = params . horizLineLength || 50 ; %NWL%this . infoListener = params . infoListener ; %NWL%0
Family :  ' Jx . Splitter . Snap '  ,%NWL%snap : null ,%NWL%element : null ,%NWL%splitter : null ,%NWL%layout :  ' vertical '  ,%NWL%parameters :  [  ' snap '  ,  ' element '  ,  ' splitter '  ,  ' events '  ]  ,%NWL%init : function (  )  {%NWL%this . snap = this . options . snap ; %NWL%this . element = this . options . element ; %NWL%this . splitter = this . options . splitter ; %NWL%this . events = this . options . events ; %NWL%7
seriesStyles ,%NWL%seriesSize = 0 ,%NWL%offset = 0 ,%NWL%renderer ,%NWL%n = 0 ,%NWL%ys =  [  ]  ,%NWL%order = this . get (  " order "  )  ,%NWL%config ; %NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? styles : styles [ state ]  ; %NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ; %NWL%markerStyles . border . color = this . _getItemColor ( markerStyles . border . color , i )  ; %NWL%9
data . domain = WebInspector . displayNameForHost ( resource . urlComponents . host )  ; %NWL%data . scheme = resource . urlComponents . scheme ? resource . urlComponents . scheme . toUpperCase (  )  :  "  "  ; %NWL%data . method = resource . requestMethod ; %NWL%data . type = resource . type ; %NWL%data . statusCode = resource . statusCode ; %NWL%data . cached = resource . cached ; %NWL%data . size = resource . size ; %NWL%data . transferSize = resource . transferSize ; %NWL%data . requestSent = resource . requestSentTimestamp - zeroTime ; %NWL%data . duration = resource . receiveDuration ; %NWL%data . latency = resource . latency ; %NWL%3
var f = document . forms [ 0 ]  , nl = f . elements , ed = tinyMCEPopup . editor , dom = ed . dom , n = ed . selection . getNode (  )  ; %NWL%tinyMCEPopup . resizeToInnerSize (  )  ; %NWL%this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%8
dojo . declare (  " dojox . data . OpmlStore "  , null ,  {%NWL%constructor : function ( keywordParameters )  {%NWL%this . _xmlData = null ; %NWL%this . _arrayOfTopLevelItems =  [  ]  ; %NWL%this . _arrayOfAllItems =  [  ]  ; %NWL%this . _metadataNodes = null ; %NWL%this . _loadFinished = false ; %NWL%this . url = keywordParameters . url ; %NWL%this . _opmlData = keywordParameters . data ;  /  / XML DOM Document%NWL%if ( keywordParameters . label )  {%NWL%this . label = keywordParameters . label ; %NWL%7
var j$ =  {  }  ; %NWL%jRequire . base ( j$ , jasmineGlobal )  ; %NWL%j$ . util = jRequire . util (  )  ; %NWL%j$ . errors = jRequire . errors (  )  ; %NWL%j$ . Any = jRequire . Any ( j$ )  ; %NWL%j$ . Anything = jRequire . Anything ( j$ )  ; %NWL%j$ . CallTracker = jRequire . CallTracker (  )  ; %NWL%j$ . MockDate = jRequire . MockDate (  )  ; %NWL%j$ . Clock = jRequire . Clock (  )  ; %NWL%j$ . DelayedFunctionScheduler = jRequire . DelayedFunctionScheduler (  )  ; %NWL%j$ . Env = jRequire . Env ( j$ )  ; %NWL%4
bulletHTML :  '  < ul class =  " orbit - bullets "  >  <  / ul >  '  ,%NWL%init : function ( element , options )  {%NWL%var $imageSlides ,%NWL%imagesLoadedCount = 0 ,%NWL%self = this ; %NWL%this . clickTimer = $ . proxy ( this . clickTimer , this )  ; %NWL%this . addBullet = $ . proxy ( this . addBullet , this )  ; %NWL%this . resetAndUnlock = $ . proxy ( this . resetAndUnlock , this )  ; %NWL%this . stopClock = $ . proxy ( this . stopClock , this )  ; %NWL%this . startTimerAfterMouseLeave = $ . proxy ( this . startTimerAfterMouseLeave , this )  ; %NWL%this . clearClockMouseLeaveTimer = $ . proxy ( this . clearClockMouseLeaveTimer , this )  ; %NWL%5
" cerebral / lib / Backbone "%NWL%]  ,%NWL%function ( $ , _ , Backbone )  {%NWL%function Module ( attributes )  {%NWL%if ( !attributes [  ' name '  ] ||%NWL%!attributes [  ' root '  ]  )  {%NWL%throw new TypeError (  ' Module attributes must contain name and root '  )%NWL%}%NWL%attributes = _ . extend (  {  }  , attributes )%NWL%this . name = attributes [  ' name '  ]%NWL%this . root = attributes [  ' root '  ]%NWL%9
var i = 0 ; %NWL%var id = 0 ; %NWL%while ( i < numRows )%NWL%{%NWL%var row = rows [ i ]  ; %NWL%var newRow = new Object (  )  ; %NWL%newRow . ds_RowID = id +  +  ; %NWL%this . data . push ( newRow )  ; %NWL%this . dataHash [ newRow . ds_RowID ]  = newRow ; %NWL%newRow . ds_PageNumber = row . ds_PageNumber ; %NWL%newRow . ds_PageSize = row . ds_PageSize ; %NWL%9
}  ,%NWL%move : function ( x , y )  {%NWL%var change = this . getArgs ( x , y )  ; %NWL%this . x +  = change . x ; %NWL%this . y +  = change . y ; %NWL%return this ;%NWL%}  ,%NWL%moveTo : function ( x , y )  {%NWL%var pos = this . getArgs ( x , y , this . x , this . y )  ; %NWL%this . x = pos . x ; %NWL%this . y = pos . y ; %NWL%9
for ( var docName in queues )%NWL%{%NWL%count +  +  ;%NWL%}%NWL%return count +  ' share ( s )  '  + this . clientCount +  ' client ( s )  '  ;%NWL%}  ; %NWL%events = new Events ( this )  ; %NWL%this . listen = events . listen ; %NWL%this . removeListener = events . removeListener ; %NWL%this . hasListeners = events . hasListeners ; %NWL%this . listenFromVersion = events . listenFromVersion ; %NWL%7
sensorDefinitions . goLinkCO2 . sensorName = i18n . t (  " sensor . names . goLinkCO2 "  )  ; %NWL%sensorDefinitions . goLinkO2 . measurementName = i18n . t (  " sensor . measurements . O2_concentration "  )  ; %NWL%sensorDefinitions . goLinkO2 . sensorName = i18n . t (  " sensor . names . goLinkO2 "  )  ; %NWL%sensorDefinitions . labQuestMotion . measurementName = i18n . t (  " sensor . measurements . distance "  )  ; %NWL%sensorDefinitions . labQuestMotion . sensorName = i18n . t (  " sensor . names . labQuestMotion "  )  ; %NWL%sensorDefinitions . labQuestTemperature . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . labQuestTemperature . sensorName = i18n . t (  " sensor . names . labQuestTemperature "  )  ; %NWL%sensorDefinitions . labQuestLight . measurementName = i18n . t (  " sensor . measurements . light_intensity "  )  ; %NWL%sensorDefinitions . labQuestLight . sensorName = i18n . t (  " sensor . names . labQuestLight "  )  ; %NWL%sensorDefinitions . labQuestForce . measurementName = i18n . t (  " sensor . measurements . force "  )  ; %NWL%sensorDefinitions . labQuestForce . sensorName = i18n . t (  " sensor . names . labQuestForce "  )  ; %NWL%0
}  ; %NWL%outerElement . remove = outerElement . remove . bind ( outerElement )  ; %NWL%outerElement . clear = function (  )  {%NWL%this . insidePanel . innerHTML =  "  "  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . clear = outerElement . clear . bind ( outerElement )  ; %NWL%outerElement . getItems = function (  )  {%NWL%return this . querySelectorAll (  '  [ data - bb - type = item ]  '  )  ;%NWL%}  ; %NWL%outerElement . getItems = outerElement . getItems . bind ( outerElement )  ; %NWL%1
\n\%NWL%vec3 normalEC ; \n\%NWL%#ifdef FACE_FORWARD\n\%NWL%normalEC = normalize ( faceforward ( v_normalEC , vec3 ( 0 . 0 , 0 . 0 , 1 . 0 )  ,  - v_normalEC )  )  ; \n\%NWL%#else\n\%NWL%normalEC = normalize ( v_normalEC )  ; \n\%NWL%#endif\n\%NWL%\n\%NWL%czm_materialInput materialInput ; \n\%NWL%materialInput . normalEC = normalEC ; \n\%NWL%materialInput . positionToEyeEC = positionToEyeEC ; \n\%NWL%9
}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . getElementById (  " imageform "  )  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%img . hspace = f . hspace . value ; %NWL%img . vspace = f . vspace . value ; %NWL%7
d . top = this . originalTop - topd +  ' px '  ;%NWL%}%NWL%if ( this . options . scaleX )  {%NWL%d . left = this . originalLeft - leftd +  ' px '  ;%NWL%}%NWL%} else {%NWL%if ( this . options . scaleY )  {%NWL%d . top =  - topd +  ' px '  ;%NWL%}%NWL%if ( this . options . scaleX )  {%NWL%d . left =  - leftd +  ' px '  ; %NWL%7
tagName :  ' div '  ,%NWL%defaultValue :  '  '  ,%NWL%initialize : function ( options )  {%NWL%var editor = this ; %NWL%var options = options || {  }  ; %NWL%if ( options . model )  {%NWL%if ( !options . key ) throw " Missing option :  ' key '  "  ; %NWL%this . model = options . model ; %NWL%this . value = this . model . get ( options . key )  ;%NWL%} else if ( options . value )  {%NWL%this . value = options . value ; %NWL%7
BoxItem . prototype . redraw = function (  )  {%NWL%var dom = this . dom ; %NWL%if ( !dom )  {%NWL%this . dom =  {  }  ; %NWL%dom = this . dom ; %NWL%dom . box = document . createElement (  ' DIV '  )  ; %NWL%dom . content = document . createElement (  ' DIV '  )  ; %NWL%dom . content . className =  ' content '  ; %NWL%dom . box . appendChild ( dom . content )  ; %NWL%dom . line = document . createElement (  ' DIV '  )  ; %NWL%dom . line . className =  ' line '  ; %NWL%7
internals . Reply . prototype . interface = function ( request , realm , next )  {    /  / next ( err || response , data )  ; %NWL%var reply = function ( err , response , data )  {%NWL%reply . _data = data ;      /  / Held for later%NWL%return reply . response ( err ! =  = null && err ! =  = undefined ? err : response )  ;%NWL%}  ; %NWL%reply . _replied = false ; %NWL%reply . _next = Hoek . once ( next )  ; %NWL%reply . realm = realm ; %NWL%reply . request = request ; %NWL%reply . response = internals . response ; %NWL%reply . close = internals . close ; %NWL%9
lodash . forOwnRight = objects . forOwnRight ; %NWL%lodash . functions = objects . functions ; %NWL%lodash . groupBy = collections . groupBy ; %NWL%lodash . indexBy = collections . indexBy ; %NWL%lodash . initial = arrays . initial ; %NWL%lodash . intersection = arrays . intersection ; %NWL%lodash . invert = objects . invert ; %NWL%lodash . invoke = collections . invoke ; %NWL%lodash . keys = objects . keys ; %NWL%lodash . map = collections . map ; %NWL%lodash . mapValues = objects . mapValues ; %NWL%0
_ajax (  {%NWL%global : false ,%NWL%url : mockHandler . proxy ,%NWL%type : mockHandler . proxyType ,%NWL%data : mockHandler . data ,%NWL%dataType : requestSettings . dataType =  =  =  " script " ? " text / plain "  : requestSettings . dataType ,%NWL%complete : function ( xhr , txt )  {%NWL%mockHandler . responseXML = xhr . responseXML ; %NWL%mockHandler . responseText = xhr . responseText ; %NWL%mockHandler . status = xhr . status ; %NWL%mockHandler . statusText = xhr . statusText ; %NWL%7
nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%0
}%NWL%_ . addClass ( elem ,  " dk - option - selected "  )  ; %NWL%elem . setAttribute (  " aria - selected "  ,  " true "  )  ; %NWL%combobox . setAttribute (  " aria - activedescendant "  , elem . id )  ; %NWL%combobox . className =  " dk - selected "  + option . className ; %NWL%combobox . innerHTML = option . text ; %NWL%this . selectedOptions [ 0 ]  = elem ; %NWL%option . selected = true ;%NWL%}%NWL%this . selectedIndex = select . selectedIndex ; %NWL%this . value = select . value ; %NWL%9
return callback ( e , results )  ;%NWL%}%NWL%if ( rs )  {%NWL%var csses = rs . csses . map ( function ( css )  {%NWL%var data =  {  }  ; %NWL%data . name = css . name ; %NWL%data . url = css . name ; %NWL%if ( css . err )  {%NWL%data . err = css . err ; %NWL%data . error = css . error ; %NWL%data . msg = css . msg ; %NWL%5
OO . ui . BookletLayout . super . call ( this , config )  ; %NWL%this . currentPageName = null ; %NWL%this . pages =  {  }  ; %NWL%this . ignoreFocus = false ; %NWL%this . stackLayout = new OO . ui . StackLayout (  { continuous : !!config . continuous }  )  ; %NWL%this . $content . append ( this . stackLayout . $element )  ; %NWL%this . autoFocus = config . autoFocus =  =  = undefined || !!config . autoFocus ; %NWL%this . outlineVisible = false ; %NWL%this . outlined = !!config . outlined ; %NWL%if ( this . outlined )  {%NWL%this . editable = !!config . editable ; %NWL%8
this . height = this . _oElement . height ; %NWL%if ( showPolaroidFooter )  {%NWL%this . currentBorder = this . borderwidth ; %NWL%this . width +  =  ( 2 * this . currentBorder )  ; %NWL%this . height +  = this . currentBorder + this . polaroidheight ;%NWL%}%NWL%this . setImageCoords (  )  ;%NWL%}  ; %NWL%Canvas . Img . prototype . setImageCoords = function (  )  {%NWL%this . left = parseInt ( this . left )  ; %NWL%this . top = parseInt ( this . top )  ; %NWL%9
if ( data . body )  {%NWL%parameters . body = data . body ;%NWL%}%NWL%break ; %NWL%case " address "  : %NWL%parameters . name = data . name ; %NWL%parameters . address = data . address ; %NWL%break ; %NWL%case " list "  : %NWL%parameters . title = data . title ; %NWL%parameters . items = data . items ; %NWL%1
defaultFunc . reset (  )  ;%NWL%} else {%NWL%hasOnePassingSelector = true ;%NWL%}%NWL%var rules = this . rules ? this . rules . slice ( 0 )  : null ,%NWL%ruleset = new ( tree . Ruleset )  ( selectors , rules , this . strictImports )  ,%NWL%rule , subRule ; %NWL%ruleset . originalRuleset = this ; %NWL%ruleset . root = this . root ; %NWL%ruleset . firstRoot = this . firstRoot ; %NWL%ruleset . allowImports = this . allowImports ; %NWL%8
var ScreenTapGesture = function ( data )  {%NWL%this . position = data . position ; %NWL%this . direction = data . direction ; %NWL%this . progress = data . progress ;%NWL%}%NWL%ScreenTapGesture . prototype . toString = function (  )  {%NWL%return " ScreenTapGesture [  "  + JSON . stringify ( this )  +  "  ]  "  ;%NWL%}%NWL%var KeyTapGesture = function ( data )  {%NWL%this . position = data . position ; %NWL%this . direction = data . direction ; %NWL%1
_  = require (  ' underscore '  )  ; %NWL%var Flavor = exports . Flavor = function Flavor ( client , details )  {%NWL%base . Flavor . call ( this , client , details )  ;%NWL%}  ; %NWL%util . inherits ( Flavor , base . Flavor )  ; %NWL%Flavor . prototype . _setProperties = function ( details )  {%NWL%this . id  = details . id ; %NWL%this . name = details . name ; %NWL%this . ram  = details . ram ; %NWL%this . disk = details . disk ; %NWL%this . vcpus = details . vcpus ; %NWL%6
start : 0%NWL%}%NWL%}  ,%NWL%listeners :  {%NWL%load :  {%NWL%fn : function ( store , records , options )  {%NWL%var storeRecords = store . getRange (  )  ; %NWL%for ( var i = 0 ; i < storeRecords . length ; i +  +  )  {%NWL%var record = storeRecords [ i ]  . data ; %NWL%record . dependencies = Ext . util . Format . htmlEncode ( record . dependencies )  ; %NWL%record . description = Ext . util . Format . htmlEncode ( record . description )  ; %NWL%9
}  )  ;%NWL%}%NWL%if ( _ . isBlank ( req . body . surname )  )  {%NWL%return next (  {%NWL%message :  ' Last name was blank '  ,%NWL%param :  ' surname '%NWL%}  )  ;%NWL%}%NWL%user . email = req . body . email ; %NWL%user . name = req . body . name ; %NWL%user . surname = req . body . surname ; %NWL%8
var self = this ,%NWL%result ; %NWL%self . _row = pattern ; %NWL%result = self . _decode (  )  ; %NWL%if ( result =  =  = null )  {%NWL%self . _row . reverse (  )  ; %NWL%result = self . _decode (  )  ; %NWL%if ( result )  {%NWL%result . direction = BarcodeReader . DIRECTION . REVERSE ; %NWL%result . start = self . _row . length - result . start ; %NWL%result . end = self . _row . length - result . end ; %NWL%9
ui . $content . append ( ui . $pg )  ; %NWL%ui . $header . addClass (  ' hide '  )  ; %NWL%ui . $nav . addClass (  ' hide '  )  ; %NWL%ui . $pg . on (  ' submit . login '  , this . login )  ;%NWL%}  ,%NWL%login : function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var $form = $ ( e . target )%NWL%, data =  {  }  ; %NWL%data . user = $form . find (  ' input [ name = user ]  '  )  . val (  )  ; %NWL%data . pass = $form . find (  ' input [ name = pass ]  '  )  . val (  )  ; %NWL%9
Model . min = persistUtil . bind (  ' min '  , Model . min , Model )  ; %NWL%Model . max = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . max . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . max = persistUtil . bind (  ' max '  , Model . max , Model )  ; %NWL%Model . sum = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . sum . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . sum = persistUtil . bind (  ' sum '  , Model . sum , Model )  ; %NWL%0
this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertFailedScenario = function assertFailedScenario (  )  {%NWL%this . assertPartialOutput (  " 1 scenario (  "  + this . color . format (  " failed "  ,  " 1 failed "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertFailure (  )  ;%NWL%}  ; %NWL%proto . assertPendingScenario = function assertPendingScenario (  )  {%NWL%this . assertPartialOutput (  " 1 scenario (  "  + this . color . format (  " pending "  ,  " 1 pending "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertUndefinedScenario = function assertUndefinedScenario (  )  {%NWL%2
Model . last = persistUtil . bind (  ' last '  , Model . last , Model )  ; %NWL%Model . deleteAll = function ( connection , callback )  {%NWL%var query = this . using ( connection )  ; %NWL%return query . deleteAll . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . deleteAll = persistUtil . bind (  ' deleteAll '  , Model . deleteAll , Model )  ; %NWL%Model . min = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . min . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . min = persistUtil . bind (  ' min '  , Model . min , Model )  ; %NWL%0
async = require (  ' async '  )  ,%NWL%fs = require (  ' fs '  )  ,%NWL%fu = require (  '  .  / fileUtil '  )  ,%NWL%resources = require (  '  .  / util / resources '  )  ; %NWL%function Context ( options , config , plugins , libraries , event )  {%NWL%this . _package = options . package ; %NWL%this . _platform = options . platform ; %NWL%this . _plugins = plugins ; %NWL%this . mode = options . mode ; %NWL%this . module = options . module ; %NWL%this . fileConfig = options . fileConfig ; %NWL%8
SC . ListItemView = SC . ListItemView . extend (  {%NWL%deprecatedRenderWarning : function (  )  {  }%NWL%}  )  ; %NWL%SC . ExceptionHandler . enabled = true ; %NWL%SC . ExceptionHandler . handleException = function ( e )  {%NWL%console . log (  ' ERROR :  '  + e )  ;%NWL%}  ; %NWL%SC . MenuItemView = SC . MenuItemView . extend (  {%NWL%escapeHTML : NO%NWL%}  )  ; %NWL%SC . SelectButtonView = SC . SelectButtonView . extend (  {%NWL%0
if ( !isNaN ( e . theta ) && !isNaN ( e . phi ) && ( e . theta ! = hpl . theta || e . phi ! = hpl . phi )  )  {%NWL%hpl . theta = e . theta ; %NWL%hpl . phi = e . phi ; %NWL%hpl . update_convolver (  )  ;%NWL%}%NWL%}%NWL%var mouse_down = function ( e )  {%NWL%hpl . moving = false ;  /  / Interrupt automation%NWL%if ( !isNaN ( e . theta ) && !isNaN ( e . phi ) && ( e . theta ! = hpl . theta || e . phi ! = hpl . phi )  )  {%NWL%hpl . theta = e . theta ; %NWL%hpl . phi = e . phi ; %NWL%1
context . beginPath (  )  ; %NWL%context . rect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . clip (  )  ; %NWL%context . save (  )  ; %NWL%context . fillStyle = chartOptions . grid . fillStyle ; %NWL%context . clearRect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . fillRect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . restore (  )  ; %NWL%context . save (  )  ; %NWL%context . lineWidth = chartOptions . grid . lineWidth ; %NWL%context . strokeStyle = chartOptions . grid . strokeStyle ; %NWL%4
localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%addCustomOperation ( localElem )  ; %NWL%return onElemRestangularized ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%9
}%NWL%}%NWL%return target ;%NWL%}  ; %NWL%jQuery . extend (  {%NWL%noConflict : function ( deep )  {%NWL%if ( window . $ =  =  = jQuery )  {%NWL%window . $ = _$ ;%NWL%}%NWL%if ( deep && window . jQuery =  =  = jQuery )  {%NWL%window . jQuery = _jQuery ; %NWL%7
smooth :  ' smooth '%NWL%}  ,%NWL%updaters :  {%NWL%smooth : function ( attr )  {%NWL%var dataX = attr . dataX ,%NWL%dataY = attr . dataY ,%NWL%path ; %NWL%if ( attr . smooth && dataX && dataY && dataX . length > 2 && dataY . length > 2 )  {%NWL%path = Ext . draw . Draw . smooth ( dataX , dataY , 3 )  ; %NWL%this . smoothX = path . smoothX ; %NWL%this . smoothY = path . smoothY ; %NWL%9
if ( args . enableSharedNotebooks ! =  = undefined )  {%NWL%this . enableSharedNotebooks = args . enableSharedNotebooks ;%NWL%}%NWL%if ( args . enableSingleNoteSharing ! =  = undefined )  {%NWL%this . enableSingleNoteSharing = args . enableSingleNoteSharing ;%NWL%}%NWL%if ( args . enableSponsoredAccounts ! =  = undefined )  {%NWL%this . enableSponsoredAccounts = args . enableSponsoredAccounts ;%NWL%}%NWL%if ( args . enableTwitterSharing ! =  = undefined )  {%NWL%this . enableTwitterSharing = args . enableTwitterSharing ; %NWL%1
el . onmousewheel = function ( e )  {%NWL%if ( e . wheelDeltaY > 0 )  {%NWL%map . zoom ( map . zoom (  )  + 0 . 3 )  ;%NWL%} else {%NWL%map . zoom ( map . zoom (  )  - 0 . 3 )  ;%NWL%}%NWL%}%NWL%drag . on (  ' move '  , function ( dx , dy )  {%NWL%var s = 1 . 0 / Math . pow ( 2 , zoom )  ; %NWL%target_center . x = drag_init . x + dx * s ; %NWL%target_center . y = drag_init . y + dy * s ; %NWL%9
assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%if ( actual ! =  = expected )  {%NWL%fail ( actual , expected , message ,  '  =  =  =  '  , assert . strictEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . notStrictEqual = function notStrictEqual ( actual , expected , message )  {%NWL%0
var state = this . _getState ( type )  ,%NWL%ycoords = this . get (  " ycoords "  )  ,%NWL%marker = this . _markers [ i ]  ,%NWL%styles = this . get (  " styles "  )  . marker ,%NWL%h = styles . height ,%NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? this . _copyObject ( styles )  : this . _copyObject ( styles [ state ]  )  ,%NWL%fillColor ,%NWL%borderColor ; %NWL%markerStyles . y =  ( ycoords [ i ]  - h / 2 )  ; %NWL%markerStyles . x = marker . get (  " x "  )  ; %NWL%markerStyles . width = marker . get (  " width "  )  ; %NWL%9
checkPropTypes (%NWL%name ,%NWL%contextTypes ,%NWL%descriptor . _context ,%NWL%ReactPropTypeLocations . context%NWL%)  ;%NWL%}%NWL%return descriptor ;%NWL%}  ; %NWL%validatedFactory . prototype = factory . prototype ; %NWL%validatedFactory . type = factory . type ; %NWL%9
exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%0
var api = exports ; %NWL%api . Triple = require (  '  .  / RDFNode . js '  )  . Triple ; %NWL%api . RDFNode = require (  "  .  / RDFNode . js "  )  . RDFNode ; %NWL%api . NamedNode = require (  "  .  / RDFNode . js "  )  . NamedNode ; %NWL%api . BlankNode = require (  "  .  / RDFNode . js "  )  . BlankNode ; %NWL%api . Literal = require (  "  .  / RDFNode . js "  )  . Literal ; %NWL%api . Profile = require (  '  .  / Profile . js '  )  . Profile ; %NWL%api . RDFEnvironment = require (  '  .  / RDFEnvironment . js '  )  . RDFEnvironment ; %NWL%api . TurtleParser = require (  '  .  / TurtleParser . js '  )  . Turtle ; %NWL%api . DataSerializer = function (  )  {  }%NWL%api . Graph = require (  "  .  / Graph . js "  )  . Graph ; %NWL%2
exports . rescrop = function ( options )  {%NWL%var deferred = Q . defer (  )  ; %NWL%function imgResCrop (  )  {%NWL%if ( options . src =  =  = undefined || options . dst =  =  = undefined ) return deferred . reject ( error_messages [  ' path '  ]  )  ; %NWL%if ( options . width =  =  = undefined ) return deferred . reject ( error_messages [  ' dim '  ]  )  ; %NWL%options . height = options . height || options . width ; %NWL%options . cropwidth = options . cropwidth || options . width ; %NWL%options . cropheight = options . cropheight || options . height ; %NWL%options . gravity = options . gravity || ' Center '  ; %NWL%options . x = options . x || 0 ; %NWL%options . y = options . y || 0 ; %NWL%9
else {%NWL%if ( shift_nums [ character ] && e . shiftKey )  {  /  / Stupid Shift key bug created by using lowercase%NWL%character = shift_nums [ character ]  ; %NWL%if ( character =  = k ) kp +  +  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( kp =  = keys . length &&%NWL%modifiers . ctrl . pressed =  = modifiers . ctrl . wanted &&%NWL%modifiers . shift . pressed =  = modifiers . shift . wanted &&%NWL%9
' click . response_hider '   :  ' hideResponse '  ,%NWL%' click . toggleOperation '  :  ' toggleOperationContent '  ,%NWL%' mouseenter . api - ic '   :  ' mouseEnter '  ,%NWL%' mouseout . api - ic '    :  ' mouseExit '  ,%NWL%}  ,%NWL%initialize : function ( opts )  {%NWL%opts = opts || {  }  ; %NWL%this . router = opts . router ; %NWL%this . auths = opts . auths ; %NWL%this . parentId = this . model . parentId ; %NWL%this . nickname = this . model . nickname ; %NWL%9
list [ name ]  = value ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( !to_form )  {%NWL%data . type = get (  ' media_type '  )  . options [ get (  ' media_type '  )  . selectedIndex ]  . value ; %NWL%data . width = getVal (  ' width '  )  ; %NWL%data . height = getVal (  ' height '  )  ; %NWL%9
return this ;%NWL%}  ; %NWL%proto . set = function ( aabb )  {%NWL%this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%this . width  = aabb . width ; %NWL%this . height = aabb . height ; %NWL%this . halfWidth = aabb . halfWidth ; %NWL%this . halfHeight = aabb . halfHeight ; %NWL%this . left = aabb . left ; %NWL%3
var preloadImg = new Image (  )  ; %NWL%function resetImageData (  )  {%NWL%var formObj = document . forms [ 0 ]  ; %NWL%formObj . width . value = formObj . height . value =  "  "  ;%NWL%}%NWL%function updateImageData (  )  {%NWL%var formObj = document . forms [ 0 ]  ; %NWL%if ( formObj . width . value =  =  "  "  )%NWL%formObj . width . value = preloadImg . width ; %NWL%if ( formObj . height . value =  =  "  "  )%NWL%formObj . height . value = preloadImg . height ; %NWL%8
var replaceEl = this . getElement ( id )  ; %NWL%if ( ! replaceEl )  {%NWL%log ( WARN ,  ' Got unknown element in update :  '  , id )  ; %NWL%continue ;%NWL%}%NWL%this . setElement ( replaceEl , updates [ id ]  )  ;%NWL%}%NWL%}  ,%NWL%processRange : function ( range )  {%NWL%range . start = this . getElement ( command . range . start )  ; %NWL%range . end = this . getElement ( command . range . end )  ; %NWL%9
this . interval = options [  ' interval '  ]  ; %NWL%this . lineWidth = options [  ' lineWidth '  ]  ; %NWL%this . strokeStyle = options [  ' strokeStyle '  ]  ; %NWL%this . fillStyle = options [  ' fillStyle '  ]  ; %NWL%this . gridcolor = options [  ' gridcolor '  ]  ; %NWL%this . background = options [  ' background '  ]  ; %NWL%this . showdots = options [  ' showdots '  ]  ; %NWL%this . showshadow = options [  ' showshadow '  ]  ; %NWL%this . showgrid = options [  ' showgrid '  ]  ; %NWL%this . showline = options [  ' showline '  ]  ; %NWL%this . showfill = options [  ' showfill '  ]  ; %NWL%0
log . warn (  ' %s is not supported anymore . \n Please use `karma . %s` instead .  '  , name , name )  ; %NWL%return constant [ name ]  ;%NWL%}  }  )  ;%NWL%}  )  ; %NWL%var Config = function (  )  {%NWL%var config = this ; %NWL%this . LOG_DISABLE = constant . LOG_DISABLE ; %NWL%this . LOG_ERROR = constant . LOG_ERROR ; %NWL%this . LOG_WARN = constant . LOG_WARN ; %NWL%this . LOG_INFO = constant . LOG_INFO ; %NWL%this . LOG_DEBUG = constant . LOG_DEBUG ; %NWL%6
}%NWL%if ( options . my [ 1 ]  =  =  =  " bottom "  )  {%NWL%position . top -  = elemHeight ;%NWL%} else if ( options . my [ 1 ]  =  =  =  " center "  )  {%NWL%position . top -  = elemHeight / 2 ;%NWL%}%NWL%position . left +  = myOffset [ 0 ]  ; %NWL%position . top +  = myOffset [ 1 ]  ; %NWL%if ( !$ . support . offsetFractions )  {%NWL%position . left = round ( position . left )  ; %NWL%position . top = round ( position . top )  ; %NWL%9
r . count = node . count ;%NWL%} else {%NWL%r = this . getMinNode_ ( node . right )  ; %NWL%this . traverse_ ( function ( node )  {%NWL%node . count -  -  ; %NWL%return node . parent ;%NWL%}  , r )  ; %NWL%if ( r ! = node . right )  {%NWL%r . parent . left = r . right ; %NWL%if ( r . right ) r . right . parent = r . parent ; %NWL%r . right = node . right ; %NWL%0
translateBy : function ( offset )  {%NWL%this . left +  = offset . x ; %NWL%this . right +  = offset . x ; %NWL%this . top +  = offset . y ; %NWL%this . bottom +  = offset . y ; %NWL%return this ;%NWL%}  ,%NWL%round : function (  )  {%NWL%this . top = Math . round ( this . top )  ; %NWL%this . right = Math . round ( this . right )  ; %NWL%this . bottom = Math . round ( this . bottom )  ; %NWL%8
return declare (  " dojox . data . FileStore "  , null ,  {%NWL%constructor : function ( args )  {%NWL%if ( args && args . label )  {%NWL%this . label = args . label ;%NWL%}%NWL%if ( args && args . url )  {%NWL%this . url = args . url ;%NWL%}%NWL%if ( args && args . options )  {%NWL%if ( lang . isArray ( args . options )  )  {%NWL%this . options = args . options ; %NWL%3
}%NWL%if ( typeof props =  =  =  " string "  )  {%NWL%props =  { path : props }%NWL%}%NWL%props . ignoreFiles =  [  "  . jamignore "  ,%NWL%"  . gitignore "  ,%NWL%" package . json "  ]%NWL%Ignore . call ( this , props )%NWL%this . bundled = props . bundled%NWL%this . bundleLinks = props . bundleLinks%NWL%this . package = props . package%NWL%8
angle = percentage * maxDegrees ; %NWL%options . startAngle = lastAngle ; %NWL%options . endAngle = lastAngle + angle ; %NWL%options . fillColor = chartOption . fillColor ; %NWL%options . color = chartOption . color || ' #000 '  ; %NWL%options . radiusX = this . options . radiusX || this . options . radius ; %NWL%options . radiusY = this . options . radiusY || this . options . radius ; %NWL%options . rotation = 0 ; %NWL%options . key = key ; %NWL%options . value = value ; %NWL%options . displayName = chartOption . displayName ; %NWL%3
}%NWL%}  ; %NWL%Y . EventFacade = function ( e , currentTarget )  {%NWL%if ( !e )  {%NWL%e = EMPTY ;%NWL%}%NWL%this . _event = e ; %NWL%this . details = e . details ; %NWL%this . type = e . type ; %NWL%this . _type = e . type ; %NWL%this . target = e . target ; %NWL%7
function normalizeTolerance ( t )  {%NWL%return t =  =  = Object ( t ) ? t :  { down : t , up : t }  ;%NWL%}%NWL%function Headroom ( elem , options )  {%NWL%options = extend ( options , Headroom . options )  ; %NWL%this . lastKnownScrollY = 0 ; %NWL%this . elem    = elem ; %NWL%this . debouncer   = new Debouncer ( this . update . bind ( this )  )  ; %NWL%this . tolerance   = normalizeTolerance ( options . tolerance )  ; %NWL%this . classes    = options . classes ; %NWL%this . offset    = options . offset ; %NWL%9
goog . dom . TextRange . prototype . browserRangeWrapper_ = null ; %NWL%goog . dom . TextRange . prototype . startNode_ = null ; %NWL%goog . dom . TextRange . prototype . startOffset_ = null ; %NWL%goog . dom . TextRange . prototype . endNode_ = null ; %NWL%goog . dom . TextRange . prototype . endOffset_ = null ; %NWL%goog . dom . TextRange . prototype . isReversed_ = false ; %NWL%goog . dom . TextRange . prototype . clone = function (  )  {%NWL%var range = new goog . dom . TextRange (  )  ; %NWL%range . browserRangeWrapper_ = this . browserRangeWrapper_ ; %NWL%range . startNode_ = this . startNode_ ; %NWL%range . startOffset_ = this . startOffset_ ; %NWL%8
} else if ( typeof key =  =  ' string '  )  {%NWL%return settings [ key ]  ;%NWL%}%NWL%if ( settings . minTime )  {%NWL%settings . minTime = _time2int ( settings . minTime )  ;%NWL%}%NWL%if ( settings . maxTime )  {%NWL%settings . maxTime = _time2int ( settings . maxTime )  ;%NWL%}%NWL%if ( settings . durationTime )  {%NWL%settings . durationTime = _time2int ( settings . durationTime )  ; %NWL%4
function Track ( opt , timeline )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . timeline = timeline ; %NWL%this . _selectors =  [  ]  ; %NWL%this . _endParams =  [  ]  ; %NWL%this . _selectedElems =  [  ]  ; %NWL%this . _isHidingSelectedElems = false ; %NWL%this . _isPlaying = false ; %NWL%if ( !this . _paramFactory ) this . _paramFactory = new ParamFactory (  {  }  , this . timeline )  ; %NWL%this . _onSelectClick = this . _onSelectClick . bind ( this )  ; %NWL%this . _onChangeSelectors = this . _onChangeSelectors . bind ( this )  ; %NWL%9
}%NWL%}  )  ; %NWL%exports . getInnerId = deprecateFunction ( getInnerId ,%NWL%' require (  " window - utils "  )  . getInnerId is deprecated ,  '  +%NWL%' please use require (  " sdk / window / utils "  )  . getInnerId instead '%NWL%)  ; %NWL%exports . getOuterId = deprecateFunction ( getOuterId ,%NWL%' require (  " window - utils "  )  . getOuterId is deprecated ,  '  +%NWL%' please use require (  " sdk / window / utils "  )  . getOuterId instead '%NWL%)  ; %NWL%exports . isBrowser = deprecateFunction ( isBrowser ,%NWL%2
lodash . forEachRight = collections . forEachRight ; %NWL%lodash . forIn = objects . forIn ; %NWL%lodash . forInRight = objects . forInRight ; %NWL%lodash . forOwn = forOwn ; %NWL%lodash . forOwnRight = objects . forOwnRight ; %NWL%lodash . functions = objects . functions ; %NWL%lodash . groupBy = collections . groupBy ; %NWL%lodash . indexBy = collections . indexBy ; %NWL%lodash . initial = arrays . initial ; %NWL%lodash . intersection = arrays . intersection ; %NWL%lodash . invert = objects . invert ; %NWL%1
this . radial . x -  = this . radial . box . bounds . width / 2 ; %NWL%this . radial . y -  = this . radial . box . bounds . height / 1 . 5 ; %NWL%this . madeWith . scaleX = this . scaled ; %NWL%this . madeWith . scaleY = this . scaled ; %NWL%this . madeWith . rotPointX = 0 ; %NWL%this . madeWith . rotPointY = 0 ; %NWL%this . madeWith . x -  = this . madeWith . box . bounds . width / 2 ; %NWL%this . madeWith . y -  = this . madeWith . box . bounds . height * 2 ; %NWL%this . kiwijsLogo . scaleX = this . scaled ; %NWL%this . kiwijsLogo . scaleY = this . scaled ; %NWL%this . kiwijsLogo . x -  = this . kiwijsLogo . box . bounds . width / 2 ; %NWL%0
}  ;%NWL%}  ,%NWL%Fetch : function ( callback )  {%NWL%this . callback = callback ; %NWL%this . init (  )  ; %NWL%return this ;%NWL%}  ,%NWL%Store : function ( config )  {%NWL%this . audioBlob = config . audioBlob ; %NWL%this . videoBlob = config . videoBlob ; %NWL%this . gifBlob = config . gifBlob ; %NWL%8
}%NWL%function updateLine ( diff_x , diff_y )  {%NWL%var i = connections . length ; %NWL%while ( i -  -  )  {%NWL%var conn = connections [ i ]  ; %NWL%var line = conn . connector ; %NWL%var elem = conn . elem ; %NWL%var pre = conn . is_start? ' start '  :  ' end '  ; %NWL%var bb = $ ( line )  . data ( pre +  ' _bb '  )  ; %NWL%bb . x = conn . start_x + diff_x ; %NWL%bb . y = conn . start_y + diff_y ; %NWL%9