text :  '  '%NWL%}  , item )  ; %NWL%var defaults =  {%NWL%selected : false ,%NWL%disabled : false%NWL%}  ; %NWL%if ( item . id ! = null )  {%NWL%item . id = item . id . toString (  )  ;%NWL%}%NWL%if ( item . text ! = null )  {%NWL%item . text = item . text . toString (  )  ; %NWL%7
}  ,%NWL%onToggleNoTestTimeout : function (  )%NWL%{%NWL%this . noTestTimeout = !this . noTestTimeout ; %NWL%Firebug . chrome . $ (  " noTestTimeout "  )  . setAttribute (  " checked "  ,%NWL%this . noTestTimeout ? " true "  :  " false "  )  ; %NWL%Firebug . setPref ( FBTestApp . prefDomain ,  " noTestTimeout "  , this . noTestTimeout )  ;%NWL%}  ,%NWL%onToggleRandomTestSelection : function (  )%NWL%{%NWL%this . randomTestSelection = !this . randomTestSelection ; %NWL%3
this . fields = fields ; %NWL%options = !options ? {  }  : options ; %NWL%this . skipValue = options . skip =  = null ? 0 : options . skip ; %NWL%this . limitValue = options . limit =  = null ? 0 : options . limit ; %NWL%this . sortValue = options . sort ; %NWL%this . hint = options . hint ; %NWL%this . explainValue = options . explain ; %NWL%this . snapshot = options . snapshot ; %NWL%this . timeout = options . timeout =  = null ? true : options . timeout ; %NWL%this . tailable = options . tailable ; %NWL%this . awaitdata = options . awaitdata ; %NWL%5
console . error (  ' THREE . DDSLoader . parse : Unsupported FourCC code '  , int32ToFourCC ( fourCC )  )  ; %NWL%return dds ;%NWL%}%NWL%}%NWL%dds . mipmapCount = 1 ; %NWL%if ( header [ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps ! =  = false )  {%NWL%dds . mipmapCount = Math . max ( 1 , header [ off_mipmapCount ]  )  ;%NWL%}%NWL%dds . isCubemap = header [ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false ; %NWL%dds . width = header [ off_width ]  ; %NWL%dds . height = header [ off_height ]  ; %NWL%9
return this ;%NWL%}  ; %NWL%this . useDebug . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useDebug "  ; %NWL%this . usePrefix = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . prefix ;%NWL%}%NWL%options . prefix = value ; %NWL%return this ;%NWL%}  ; %NWL%this . usePrefix . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . usePrefix "  ; %NWL%2
for ( i = 0 ; i < childNodes . length ; i +  = 1 )  {%NWL%childNodes [ i ]  . remove (  )  ;%NWL%}%NWL%}  ; %NWL%self . getParent = getParent = function (  )  {%NWL%return parentNode ;%NWL%}  ; %NWL%self . setParent = setParent = function ( node )  {%NWL%parentNode = node ;%NWL%}  ; %NWL%self . getChildren = getChildren = function (  )  {%NWL%4
describeClusterTest (  { transport :  " xdr_polling "  , encrypted : false }  )  ; %NWL%describeClusterTest (  { transport :  " xdr_polling "  , encrypted : true }  )  ; %NWL%describeClusterTest (  { transport :  " sockjs "  , encrypted : false }  )  ;%NWL%} else {%NWL%describeClusterTest (  { transport :  " sockjs "  , encrypted : false }  )  ; %NWL%describeClusterTest (  { transport :  " sockjs "  , encrypted : true }  )  ;%NWL%}%NWL%it (  " should restore the global config "  , function (  )  {%NWL%Pusher . Dependencies = _Dependencies ; %NWL%Pusher . channel_auth_endpoint = _channel_auth_endpoint ; %NWL%Pusher . channel_auth_transport = _channel_auth_transport ; %NWL%8
} else {%NWL%this . stack =  '  '  ;%NWL%}%NWL%}%NWL%errors . _Abstract = ErrorAbstract ; %NWL%ErrorAbstract . prototype = new Error (  )  ; %NWL%errors . FeedError = function FeedError ( msg )  {%NWL%ErrorAbstract . call ( this , msg )  ;%NWL%}  ; %NWL%errors . FeedError . prototype = new ErrorAbstract (  )  ; %NWL%errors . SiteError = function SiteError ( msg )  {%NWL%6
this . salt = User . makeNewSalt (  )  ; %NWL%var sha = crypto . createHash (  " sha512 "  )  ; %NWL%sha . update ( this . salt + info . password )  ; %NWL%this . hash = sha . digest (  " hex "  )  . toString (  )  ; %NWL%console . log (  " Converted password to hash for "  , this . state . userName )  ;%NWL%}%NWL%else {%NWL%this . salt = info . salt ; %NWL%this . hash = info . hash ;%NWL%}%NWL%this . email = info . email ; %NWL%7
}  )  ; %NWL%this . handleEventProps ( dispatches )  ; %NWL%this . bind (  ' Load Resize '  , function (  )  {%NWL%_updateInfo . call ( this )  ;%NWL%}  , 999 )  ; %NWL%function _updateInfo ( info )  {%NWL%if ( !info )  {%NWL%info = this . exec (  ' Image '  ,  ' getInfo '  )  ;%NWL%}%NWL%this . size = info . size ; %NWL%this . width = info . width ; %NWL%9
this . AddZone = WebPartManager_AddZone ; %NWL%this . IsDragDropEnabled = WebPartManager_IsDragDropEnabled ; %NWL%this . DragDrop = WebPartManager_DragDrop ; %NWL%this . InitiateWebPartDragDrop = WebPartManager_InitiateWebPartDragDrop ; %NWL%this . CompleteWebPartDragDrop = WebPartManager_CompleteWebPartDragDrop ; %NWL%this . ContinueWebPartDragDrop = WebPartManager_ContinueWebPartDragDrop ; %NWL%this . ProcessWebPartDragEnter = WebPartManager_ProcessWebPartDragEnter ; %NWL%this . ProcessWebPartDragOver = WebPartManager_ProcessWebPartDragOver ; %NWL%this . ProcessWebPartDrop = WebPartManager_ProcessWebPartDrop ; %NWL%this . ShowHelp = WebPartManager_ShowHelp ; %NWL%this . ExportWebPart = WebPartManager_ExportWebPart ; %NWL%0
} else if ( ptype =  =  =  " plane "  )  {%NWL%prim . size = meshKit . getFloatNode ( proc ,  " size "  )  ; %NWL%obj . booleanAdd ( CubicVR . primitives . plane ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " cylinder "  )  {%NWL%prim . radius = meshKit . getFloatNode ( proc ,  " radius "  )  ; %NWL%prim . height = meshKit . getFloatNode ( proc ,  " height "  )  ; %NWL%prim . lon = meshKit . getIntNode ( proc ,  " lon "  )  ; %NWL%obj . booleanAdd ( CubicVR . primitives . cylinder ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " torus "  )  {%NWL%prim . innerRadius = meshKit . getFloatNode ( proc ,  " innerRadius "  )  ; %NWL%prim . outerRadius = meshKit . getFloatNode ( proc ,  " outerRadius "  )  ; %NWL%1
utils    = require (  '  .  / utils '  )  ,%NWL%coreHelpers  =  {  }  ,%NWL%registerHelpers ; %NWL%if ( !utils . isProduction )  {%NWL%hbs . handlebars . logger . level = 0 ;%NWL%}%NWL%coreHelpers . asset  = require (  '  .  / asset '  )  ; %NWL%coreHelpers . author  = require (  '  .  / author '  )  ; %NWL%coreHelpers . body_class  = require (  '  .  / body_class '  )  ; %NWL%coreHelpers . content  = require (  '  .  / content '  )  ; %NWL%coreHelpers . date  = require (  '  .  / date '  )  ; %NWL%6
opts . complete ( null ,  { status :  ' cancelled '  }  )  ;%NWL%} else {%NWL%fun ( self , opts , promise )  ;%NWL%}%NWL%}  )  ;%NWL%} else {%NWL%fun ( self , opts , promise )  ;%NWL%}%NWL%promise . on = emitter . on . bind ( emitter )  ; %NWL%promise . once = emitter . once . bind ( emitter )  ; %NWL%promise . addListener = emitter . addListener . bind ( emitter )  ; %NWL%8
}  ; %NWL%var Stat = function ( opts )  {%NWL%this . uid = opts . uid || 0 ; %NWL%this . gid = opts . gid || 0 ; %NWL%this . mode = opts . mode || 0 ; %NWL%this . size = opts . size || 0 ; %NWL%this . mtime = toDate ( opts . mtime )  ; %NWL%this . atime = toDate ( opts . atime )  ; %NWL%this . ctime = toDate ( opts . ctime )  ; %NWL%this . type = opts . type ; %NWL%this . target = opts . target ; %NWL%9
this . init (  )  ; %NWL%this . element . data (  " markdownarea "  , this )  ;%NWL%}  ; %NWL%$ . extend ( Markdownarea . prototype ,  {%NWL%init : function (  )  {%NWL%var $this = this , tpl = Markdownarea . template ; %NWL%tpl = tpl . replace (  / \ { \ : lblPreview\ }  / g , this . options . lblPreview )  ; %NWL%tpl = tpl . replace (  / \ { \ : lblCodeview\ }  / g , this . options . lblCodeview )  ; %NWL%this . markdownarea = $ ( tpl )  ; %NWL%this . content   = this . markdownarea . find (  "  . uk - markdownarea - content "  )  ; %NWL%this . toolbar   = this . markdownarea . find (  "  . uk - markdownarea - toolbar "  )  ; %NWL%9
this . x = this . object . Location . X ; %NWL%this . y = this . object . Location . Y ; %NWL%this . size = this . object . size || 1 ; %NWL%break ; %NWL%case QuadTreeConstants . useObjectPosition : %NWL%this . x = this . object . position . x ; %NWL%this . y = this . object . position . y ; %NWL%break ; %NWL%case QuadTreeConstants . useParam : %NWL%this . x = this . object [ this . _getParam . x ]  ; %NWL%this . y = this . object [ this . _getParam . y ]  ; %NWL%9
var debounce = require (  ' lodash . debounce '  )  ; %NWL%var inquirer = require (  ' inquirer '  )  ; %NWL%var providers = require (  '  .  / providers '  )  ; %NWL%function Insight ( options )  {%NWL%options = options || {  }  ; %NWL%if ( !options . trackingCode || !options . packageName )  {%NWL%throw new Error (  ' Must provide trackingCode and packageName '  )  ;%NWL%}%NWL%this . trackingCode = options . trackingCode ; %NWL%this . trackingProvider = options . trackingProvider || ' google '  ; %NWL%this . packageName = options . packageName ; %NWL%8
}  ; %NWL%ret . isTop = true ; %NWL%ret . _setup = function ( options )  {%NWL%if ( !options . partial )  {%NWL%container . helpers = container . merge ( options . helpers , env . helpers )  ; %NWL%if ( templateSpec . usePartial )  {%NWL%container . partials = container . merge ( options . partials , env . partials )  ;%NWL%}%NWL%} else {%NWL%container . helpers = options . helpers ; %NWL%container . partials = options . partials ; %NWL%9
var AttributeCore  = Y . AttributeCore ,%NWL%AttributeExtras = Y . AttributeExtras ,%NWL%BaseCore   = Y . BaseCore ,%NWL%BaseObservable  = Y . BaseObservable ; %NWL%function Base (  )  {%NWL%BaseCore . apply ( this , arguments )  ; %NWL%BaseObservable . apply ( this , arguments )  ; %NWL%AttributeExtras . apply ( this , arguments )  ;%NWL%}%NWL%Base . _ATTR_CFG = BaseCore . _ATTR_CFG . concat ( BaseObservable . _ATTR_CFG )  ; %NWL%Base . _NON_ATTRS_CFG = BaseCore . _NON_ATTRS_CFG . concat ( BaseObservable . _NON_ATTRS_CFG )  ; %NWL%9
matrix :  [%NWL%[ scale * Math . cos ( rotate )  ,  - scale * Math . sin ( rotate )  , translate [ 0 ]  ]  ,%NWL%[ scale * Math . sin ( rotate )  , scale * Math . cos ( rotate )  , translate [ 1 ]  ]  ,%NWL%[ 0 , 0 , 1 ]%NWL%]%NWL%}  ;%NWL%}  ( possition [ 0 ]  [ 0 ]  , position [ 0 ]  [ 1 ]  , position [ 1 ]  [ 0 ]  , position [ 1 ]  [ 1 ]  , current [ 0 ]  [ 0 ]  , current [ 0 ]  [ 1 ]  , current [ 1 ]  [ 0 ]  , current [ 1 ]  [ 1 ]  )  ; %NWL%var ev = document . createEvent (  ' HTMLEvents '  )  ; %NWL%ev . initEvent (  ' dualtouch '  , true , true )  ; %NWL%ev . rotate = transform . rotate ; %NWL%ev . scale = transform . scale ; %NWL%9
this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%this . query = options . query || '  '  ; %NWL%this . orderby = options . orderby ; %NWL%this . endpoint = options . endpoint || " https :  /  / spreadsheets . google . com "  ; %NWL%this . singleton = !!options . singleton ; %NWL%this . simple_url = !!options . simple_url ; %NWL%this . callbackContext = options . callbackContext ; %NWL%3
}  )%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%shouldCorrectlyExecuteLastStatus : function ( test )  {%NWL%var error_client = new Db ( MONGODB , new Server (  " 127 . 0 . 0 . 1 "  , 27017 ,  { auto_reconnect : false , poolSize : 1 ,  }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%error_client . bson_deserializer = client . bson_deserializer ; %NWL%error_client . bson_serializer = client . bson_serializer ; %NWL%9
unitSystem = google . maps . UnitSystem . METRIC ;%NWL%}%NWL%var base_options =  {%NWL%avoidHighways : false ,%NWL%avoidTolls : false ,%NWL%optimizeWaypoints : false ,%NWL%waypoints :  [  ]%NWL%}  ,%NWL%request_options =  extend_object ( base_options , options )  ; %NWL%request_options . origin =  / string /  . test ( typeof options . origin ) ? options . origin : new google . maps . LatLng ( options . origin [ 0 ]  , options . origin [ 1 ]  )  ; %NWL%request_options . destination =  / string /  . test ( typeof options . destination ) ? options . destination : new google . maps . LatLng ( options . destination [ 0 ]  , options . destination [ 1 ]  )  ; %NWL%9
Stimulus . prototype . init = function ( world , opt_options )  {%NWL%Stimulus . _superClass . init . call ( this , world , opt_options )  ; %NWL%var options = opt_options || {  }  ; %NWL%if ( !options . type || typeof options . type ! =  =  ' string '  )  {%NWL%throw new Error (  ' Stimulus requires \ ' type\ ' parameter as a string .  '  )  ;%NWL%}%NWL%this . type = options . type ; %NWL%this . mass = typeof options . mass ! =  =  ' undefined ' ? options . mass : 50 ; %NWL%this . isStatic = typeof options . isStatic ! =  =  ' undefined ' ? options . isStatic : true ; %NWL%this . width = typeof options . width ! =  =  ' undefined ' ? options . width : 50 ; %NWL%this . height = typeof options . height ! =  =  ' undefined ' ? options . height : 50 ; %NWL%7
this . _webgl = undefined ; %NWL%this . _webglFramebuffer = undefined ; %NWL%this . _webglRenderbuffer = undefined ;%NWL%}%NWL%Class . extend ( RenderTarget )  ; %NWL%RenderTarget . prototype . clone = function (  )  {%NWL%return new RenderTarget (  )  . copy ( this )  ;%NWL%}  ; %NWL%RenderTarget . prototype . copy = function ( other )  {%NWL%this . width = other . width ; %NWL%this . height = other . height ; %NWL%9
}  )  [  ' catch '  ]  ( function ( reply )  {%NWL%validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . registerHandler '  ; %NWL%wrapped . unregisterHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . unregisterHandler '  ; %NWL%wrapped . send . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . send '  ; %NWL%wrapped . publish . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . publish '  ; %NWL%wrapped . getConnectionState . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . getConnectionState '  ; %NWL%6
var index = key >  >  > 0 ; %NWL%return index < max && index =  = key ;%NWL%}%NWL%function ArrayBufferIndex ( value )  {%NWL%this . Value = value ;%NWL%}%NWL%ArrayBufferIndex . prototype = new DataDescriptor ( undefined , 5 )  ; %NWL%function Type ( options )  {%NWL%this . name  = options . name%NWL%this . size  = options . size ; %NWL%this . cast  = options . cast ; %NWL%9
this . angularVelocity = opts . angularVelocity ! = undefined ? opts . angularVelocity : 0 ; %NWL%this . angularVelocitySpread = opts . angularVelocitySpread ! = undefined ? opts . angularVelocitySpread : 0 ; %NWL%this . angularAcceleration = opts . angularAcceleration ! = undefined ? opts . angularAcceleration : 0 ; %NWL%this . angularAccelerationSpread = opts . angularAccelerationSpread ! = undefined ? opts . angularAccelerationSpread : 0 ; %NWL%this . randomAngle = opts . randomAngle ! = undefined ? opts . randomAngle : true ; %NWL%this . emissionRate = opts . emissionRate ! = undefined ? opts . emissionRate : 1 / 60 ; %NWL%this . color = opts . color ! = undefined ? opts . color : new Color ; %NWL%this . colorSpread = opts . colorSpread ! = undefined ? opts . colorSpread : new Color ; %NWL%this . time = opts . time ! = undefined ? opts . time : 0 ; %NWL%this . _time = 0 ; %NWL%this . duration = opts . duration ! = undefined ? opts . duration : 0 ; %NWL%0
}  ,%NWL%function (  )  {%NWL%var scope = QUnit . fixture . find (  " a "  )  . scope (  )  ; %NWL%scope . $apply ( function (  )  {%NWL%scope . foo =  " foo "  ;%NWL%}  )  ; %NWL%stop (  )  ; %NWL%setTimeout ( function (  )  {%NWL%ok ( QUnit . fixture . find (  " a "  )  . getKendoMobileButton (  )  )  ; %NWL%scope . $apply ( function (  )  {%NWL%scope . bar =  " bar "  ; %NWL%4
xpixels : 514 ,%NWL%ypixels : 514 ,%NWL%range :  [  [  - 1 . 2 , 1 . 2 ]  ,  [  - 1 . 2 , 1 . 2 ]  ]%NWL%}  ; %NWL%options . scale =  [ options . xpixels /  ( options . range [ 0 ]  [ 1 ]  - options . range [ 0 ]  [ 0 ]  )  ,%NWL%options . ypixels /  ( options . range [ 1 ]  [ 1 ]  - options . range [ 1 ]  [ 0 ]  )  ]  ; %NWL%graph . init ( options )  ; %NWL%graph . xpixels = options . xpixels ; %NWL%graph . ypixels = options . ypixels ; %NWL%graph . range = options . range ; %NWL%graph . scale = options . scale ; %NWL%7
Extends : jxObject ,%NWL%Family :  ' Jx . Splitter . Snap '  ,%NWL%snap : null ,%NWL%element : null ,%NWL%splitter : null ,%NWL%layout :  ' vertical '  ,%NWL%parameters :  [  ' snap '  ,  ' element '  ,  ' splitter '  ,  ' events '  ]  ,%NWL%init : function (  )  {%NWL%this . snap = this . options . snap ; %NWL%this . element = this . options . element ; %NWL%this . splitter = this . options . splitter ; %NWL%8
Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%proxy . stopImmediatePropagation = proto . stopImmediatePropagation ; %NWL%6
var key = columnKeyXZ ( loc . chunkCorner . x , loc . chunkCorner . z )  ; %NWL%var column = columns [ key ]  ; %NWL%if ( ! column ) return null ; %NWL%var blockType = double_bite ( column . blockType )  ; %NWL%var nibbleIndex = loc . blockIndex >  > 1 ; %NWL%var lowNibble = loc . blockIndex % 2 =  =  = 1 ; %NWL%var biomeId = column . biome . readUInt8 ( loc . biomeBlockIndex )  ; %NWL%var block = new Block ( blockType >  > 4 , biomeId )  ; %NWL%block . metadata = blockType & 0x0f ; %NWL%block . light = nib ( column . light )  ; %NWL%block . skyLight = nib ( column . skyLight )  ; %NWL%9
this . _bep	   = bep ; %NWL%this . name	   = uuid (  )  ; %NWL%this . terminated  = false ; %NWL%this . to		   = node . attrs . to ; %NWL%this . session	  = session ; %NWL%this . attrs    =  {  }  ; %NWL%if ( node . attrs . route )  {%NWL%this . route = helper . route_parse ( node . attrs . route )  ;%NWL%}%NWL%if ( node . attrs . from )  {%NWL%this . from = node . attrs . from ; %NWL%3
if ( typeof this . settings . target ! =  ' undefined '  )  {%NWL%this . target = this . settings . target ;%NWL%}%NWL%if ( typeof this . settings . cssclassregex ! =  ' undefined '  )  {%NWL%this . cssclassregex = this . settings . cssclassregex ;%NWL%}%NWL%if ( typeof this . settings . cssclass ! =  ' undefined '  )  {%NWL%this . cssclass = this . settings . cssclass ;%NWL%}%NWL%if ( typeof this . settings . objectTypeFilter ! =  ' undefined '  )  {%NWL%this . objectTypeFilter = this . settings . objectTypeFilter ; %NWL%1
stackStartFunction : stackStartFunction%NWL%}  )  ;%NWL%}%NWL%assert . fail = fail ; %NWL%assert . ok = function ok ( value , message )  {%NWL%if ( !!!value ) fail ( value , true , message ,  "  =  =  "  , assert . ok )  ;%NWL%}  ; %NWL%assert . equal = function equal ( actual , expected , message )  {%NWL%if ( actual ! = expected ) fail ( actual , expected , message ,  "  =  =  "  , assert . equal )  ;%NWL%}  ; %NWL%assert . notEqual = function notEqual ( actual , expected , message )  {%NWL%7
}%NWL%return loss ;%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%8
[  " simple - auth / authorizers / base "  ,  "  .  /  .  .  / configuration "  ,  " exports "  ]  ,%NWL%function ( __dependency1__ , __dependency2__ , __exports__ )  {%NWL%" use strict "  ; %NWL%var Base = __dependency1__ [  " default "  ]  ; %NWL%var Configuration = __dependency2__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%tokenAttributeName :  ' user_token '  ,%NWL%identificationAttributeName :  ' user_email '  ,%NWL%init : function (  )  {%NWL%this . tokenAttributeName    = Configuration . tokenAttributeName ; %NWL%this . identificationAttributeName = Configuration . identificationAttributeName ; %NWL%9
if ( evt . touches )  {%NWL%for ( i ; i < evt . changedTouches . length ; i +  +  )  {%NWL%touch = evt . changedTouches [ i ]  ; %NWL%this . touchInfo . touchLookup [ touch . identifier ]  . pageX = touch . pageX ; %NWL%this . touchInfo . touchLookup [ touch . identifier ]  . pageY = touch . pageY ;%NWL%}%NWL%}%NWL%else {%NWL%touch = this . touchInfo . touchLookup [ evt . pointerId ]  ; %NWL%touch . pageX = evt . pageX ; %NWL%touch . pageY = evt . pageY ; %NWL%9
return {%NWL%createDefault : function (  )  {%NWL%return new Constructor (  )  ;%NWL%}  ,%NWL%transform : function ( jsonResult )  {%NWL%if ( angular . isArray ( jsonResult )  )  {%NWL%var methods =  [  ]  ; %NWL%angular . forEach ( jsonResult , function ( result )  {%NWL%var method = new Constructor (  )  ; %NWL%method . gatewayResource = gatewayResourceDisplayBuilder . transform ( result . gatewayResource )  ; %NWL%method . shipMethod = shipMethodDisplayBuilder . transform ( result . shipMethod )  ; %NWL%9
var s = new Stream ; %NWL%s . writable = true ; %NWL%s . write = c . write . bind ( c )  ; %NWL%s . end = function ( buf )  {%NWL%if ( buf ! =  = undefined ) s . write ( buf )  ; %NWL%c . end (  )  ; %NWL%close (  )  ;%NWL%}  ; %NWL%s . destroy = c . destroy . bind ( c )  ; %NWL%s . pause = c . pause . bind ( c )  ; %NWL%s . resume = c . resume . bind ( c )  ; %NWL%2
options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%5
"  .  .  /  .  .  / EnhancedGrid "%NWL%]  , function ( declare , array , lang , html , evt , keys , _Plugin , EnhancedGrid )  {%NWL%var Menu = declare (  " dojox . grid . enhanced . plugins . Menu "  , _Plugin ,  {%NWL%name :  " menus "  ,%NWL%types :  [  ' headerMenu '  ,  ' rowMenu '  ,  ' cellMenu '  ,  ' selectedRegionMenu '  ]  ,%NWL%constructor : function (  )  {%NWL%var g = this . grid ; %NWL%g . showMenu = lang . hitch ( g , this . showMenu )  ; %NWL%g . _setRowMenuAttr = lang . hitch ( this ,  ' _setRowMenuAttr '  )  ; %NWL%g . _setCellMenuAttr = lang . hitch ( this ,  ' _setCellMenuAttr '  )  ; %NWL%g . _setSelectedRegionMenuAttr = lang . hitch ( this ,  ' _setSelectedRegionMenuAttr '  )  ; %NWL%8
return {%NWL%sign :  - 1 ,%NWL%value : valueIn . subtract ( valueOut )%NWL%}  ;%NWL%}%NWL%}  ; %NWL%var TransactionIn = function ( data )%NWL%{%NWL%this . outpoint = data . outpoint ; %NWL%if ( data . script instanceof Script )  {%NWL%this . script = data . script ; %NWL%8
initialize : function ( name , url , options )  {%NWL%var newArguments =  [  ]  ; %NWL%newArguments . push ( name , url ,  {  }  , options )  ; %NWL%OpenLayers . Layer . Grid . prototype . initialize . apply ( this , newArguments )  ; %NWL%this . rft_id = options . rft_id ; %NWL%this . format = options . format ; %NWL%if ( !options . imgMetadata )  {%NWL%var request = OpenLayers . Request . issue (  { url : options . metadataUrl , async : false }  )  ; %NWL%this . imgMetadata = eval (  '  (  '  + request . responseText +  '  )  '  )  ;%NWL%} else {%NWL%this . imgMetadata = options . imgMetadata ; %NWL%4
return proxy ;%NWL%}%NWL%}  )  ;%NWL%}  )  ; %NWL%carena . addFeature (  " composer . Pipe "  , function ( obj , options , storage )  {%NWL%var safe =  {%NWL%source : null ,%NWL%target : null%NWL%}%NWL%storage . source = options . source || null ; %NWL%storage . target = options . target || null ; %NWL%9
var _     = require (  ' lodash '  )  ; %NWL%var request   = require (  ' request '  )  ; %NWL%var fs     = require (  ' fs '  )  ; %NWL%function Email ( params )  {%NWL%params = params || {  }  ; %NWL%this . to   = params . to  || [  ]  ; %NWL%this . from  = params . from || '  '  ; %NWL%this . smtpapi = params . smtpapi || new smtpapi_lib (  )  ; %NWL%this . subject = params . subject || '  '  ; %NWL%this . text  = params . text || '  '  ; %NWL%this . html  = params . html || '  '  ; %NWL%6
var step = new angular . scenario . ObjectModel . Step ( name )  ; %NWL%this . steps . push ( step )  ; %NWL%return step ;%NWL%}  ; %NWL%angular . scenario . ObjectModel . Spec . prototype . getLastStep = function (  )  {%NWL%return this . steps [ this . steps . length - 1 ]  ;%NWL%}  ; %NWL%angular . scenario . ObjectModel . Spec . prototype . setStatusFromStep = function ( step )  {%NWL%if ( !this . status || step . status =  =  ' error '  )  {%NWL%this . status = step . status ; %NWL%this . error = step . error ; %NWL%9
finish (  )  ;%NWL%} else {%NWL%if ( typeof obj . options =  =  =  " undefined "  )  {%NWL%obj . options =  {  }  ;%NWL%}%NWL%if ( obj . generator =  = cody . Meta . Generator . textareainput )  {%NWL%obj . min =  ( typeof obj . options . cols =  =  =  " undefined "  ) ? "  "  : obj . options . cols ; %NWL%obj . max =  ( typeof obj . options . rows =  =  =  " undefined "  ) ? "  "  : obj . options . rows ;%NWL%} else {%NWL%obj . min =  ( typeof obj . options . minimum =  =  =  " undefined "  ) ? "  "  : obj . options . minimum ; %NWL%obj . max =  ( typeof obj . options . maximum =  =  =  " undefined "  ) ? "  "  : obj . options . maximum ; %NWL%9
return ret ;%NWL%}  ,%NWL%dateToString : function ( date , _getParsed )  {%NWL%return typeProtos . date . dateToString ( date )  +  ' T '  + typeProtos . time . dateToString ( date , _getParsed )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%if ( typeBugs || !supportsType (  ' range '  ) || !supportsType (  ' time '  ) || !supportsType (  ' month '  ) || !supportsType (  ' datetime - local '  )  )  {%NWL%typeProtos . range = $ . extend (  {  }  , typeProtos . number , typeProtos . range )  ; %NWL%typeProtos . time = $ . extend (  {  }  , typeProtos . date , typeProtos . time )  ; %NWL%typeProtos . month = $ . extend (  {  }  , typeProtos . date , typeProtos . month )  ; %NWL%9
function GitBranchListModel ( options )  {%NWL%this . root = options . root ; %NWL%this . showHistory = options . showHistory =  =  = undefined || options . showHistory ; %NWL%this . showTags = options . showTags =  =  = undefined || options . showTags ; %NWL%this . showStashes = options . showStashes =  =  = undefined || options . showStashes ; %NWL%this . registry = options . registry ; %NWL%this . handleError = options . handleError ; %NWL%this . section = options . section ; %NWL%this . progressService = options . progressService ; %NWL%this . parentId = options . parentId ; %NWL%this . gitClient = options . gitClient ; %NWL%1
elements . buttons . primary . appendChild ( button . element )  ;%NWL%}%NWL%}%NWL%instance . elements = elements ; %NWL%internal . resetHandler = delegate ( instance , onReset )  ; %NWL%internal . beginMoveHandler = delegate ( instance , beginMove )  ; %NWL%internal . beginResizeHandler = delegate ( instance , beginResize )  ; %NWL%internal . bringToFrontHandler = delegate ( instance , bringToFront )  ; %NWL%internal . modalClickHandler = delegate ( instance , modalClickHandler )  ; %NWL%internal . buttonsClickHandler = delegate ( instance , buttonsClickHandler )  ; %NWL%internal . commandsClickHandler = delegate ( instance , commandsClickHandler )  ; %NWL%8
var log = logger . temp [ i ]  ; %NWL%logger . target [ log . level ]  ( log . message )  ; %NWL%delete logger . temp [ i ]  ;%NWL%}%NWL%}  ; %NWL%logger . trace = function ( message )  { logger . temp . push (  { level :  ' trace '  , message : message }  )  ;  }  ; %NWL%logger . debug = function ( message )  { logger . temp . push (  { level :  ' debug '  , message : message }  )  ;  }  ; %NWL%logger . info = function ( message )  { logger . temp . push (  { level :  ' info '  , message : message }  )  ;  }  ; %NWL%logger . warn = function ( message )  { logger . temp . push (  { level :  ' warn '  , message : message }  )  ;  }  ; %NWL%logger . error = function ( message )  { logger . temp . push (  { level :  ' error '  , message : message }  )  ;  }  ; %NWL%logger . fatal = function ( message )  { logger . temp . push (  { level :  ' fatal '  , message : message }  )  ;  }  ; %NWL%5
}  ;%NWL%}%NWL%ReconnectingWebSocket . prototype . onopen = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onclose = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onconnecting = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onmessage = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onerror = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . debugAll = false ; %NWL%ReconnectingWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%ReconnectingWebSocket . OPEN = WebSocket . OPEN ; %NWL%ReconnectingWebSocket . CLOSING = WebSocket . CLOSING ; %NWL%8
}%NWL%AnaglyphArcRotateCamera . prototype . _update = function (  )  {%NWL%this . _updateCamera ( this . _leftCamera )  ; %NWL%this . _updateCamera ( this . _rightCamera )  ; %NWL%this . _leftCamera . alpha = this . alpha - this . _eyeSpace ; %NWL%this . _rightCamera . alpha = this . alpha + this . _eyeSpace ; %NWL%_super . prototype . _update . call ( this )  ;%NWL%}  ; %NWL%AnaglyphArcRotateCamera . prototype . _updateCamera = function ( camera )  {%NWL%camera . beta = this . beta ; %NWL%camera . radius = this . radius ; %NWL%9
if ( dst . alarmType ! =  = _NO_ALARM && prop . alarmTrigger ! =  = undefined && prop . alarmTrigger ! =  = undefined )  {%NWL%dst . alarmTrigger = prop . alarmTrigger | 0 ;%NWL%}%NWL%}  ; %NWL%_eventFilterCheck = function ( filter )  {%NWL%if ( filter . id ! =  = undefined && filter . id ! =  = null )  {%NWL%filter . id = String ( filter . id )  ;%NWL%} else {%NWL%filter . id = undefined ;%NWL%}%NWL%if ( filter . summary ! =  = undefined && filter . summary ! =  = null )  {%NWL%5
pluginIndexes [ plugin . packagePath ]  = index ;%NWL%}%NWL%}  )  ; %NWL%require ( paths , function (  )  {%NWL%var args = arguments ; %NWL%paths . forEach ( function ( name , i )  {%NWL%var module = args [ i ]  ; %NWL%var plugin = config [ pluginIndexes [ name ]  ]  ; %NWL%plugin . setup = module ; %NWL%plugin . provides = module . provides || [  ]  ; %NWL%plugin . consumes = module . consumes || [  ]  ; %NWL%9
}%NWL%if ( this . toPropertyName )  {%NWL%this . setTransformOrigin = function ( node ,  transformOrigin )  {%NWL%return dojo . style ( node , this . toPropertyName , transformOrigin )  ;%NWL%}  ; %NWL%this . getTransformOrigin = function ( node )  {%NWL%return dojo . style ( node , this . toPropertyName )  ;%NWL%}  ;%NWL%} else if ( dojo . isIE )  {%NWL%this . setTransformOrigin = this . _setTransformOriginFilter ; %NWL%this . getTransformOrigin = this . _getTransformOriginFilter ; %NWL%9
this . device . deleteBuffer ( this . vertexBuffer )  ; %NWL%this . device . deleteBuffer ( this . indexBuffer )  ; %NWL%delete this . vertexBuffer ; %NWL%delete this . indexBuffer ; %NWL%delete this . vertexData ; %NWL%delete this . indexData ; %NWL%this . setDirty ( true )  ;%NWL%}%NWL%}  ; %NWL%Mesh . POINTS   = GraphicsDevice . POINTS ; %NWL%Mesh . LINES    = GraphicsDevice . LINES ; %NWL%9
obj . type = this . get (  ' type '  )  ; %NWL%obj . metaType = this . get (  ' meta '  )  . type ; %NWL%obj . date = this . get (  ' meta '  ) ? this . get (  ' meta '  )  . date : new Date (  )  ; %NWL%obj . date = obj . date ? obj . date : new Date (  )  ; %NWL%obj . commId = this . get (  ' meta '  ) ? this . get (  ' meta '  )  . commId : undefined ; %NWL%obj . contents = this . get (  ' contents '  )  ; %NWL%if ( this . get (  ' from '  ) && this . get (  ' from '  )  . authorMsisdn )  {%NWL%obj . authorMsisdn = this . get (  ' from '  )  . authorMsisdn ;%NWL%}%NWL%obj . msisdn = this . get (  ' from '  ) ? this . get (  ' from '  )  . msisdn :  '  '  ; %NWL%obj . displayName = this . get (  ' from '  ) ? this . get (  ' from '  )  . displayName :  '  '  ; %NWL%9
Fast . keys = Fast . object . keys ; %NWL%Fast . values = Fast . object . values ; %NWL%Fast . clone = require (  '  .  / clone '  )  ; %NWL%Fast . map = require (  '  .  / map '  )  ; %NWL%Fast . filter = require (  '  .  / filter '  )  ; %NWL%Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%Fast . reduce = require (  '  .  / reduce '  )  ; %NWL%Fast . reduceRight = require (  '  .  / reduceRight '  )  ; %NWL%Fast . cloneArray = Fast . array . clone ;  /  / @deprecated use fast . array . clone (  )%NWL%Fast . concat = Fast . array . concat ; %NWL%Fast . some = Fast . array . some ; %NWL%9
this . x = 0 ; %NWL%this . y = 0 ; %NWL%this . confidence =  - 10000 ; %NWL%this . detection =  '  '  ; %NWL%this . time = 0 ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . facetrackr . TrackObj (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%c . angle = this . angle ; %NWL%c . x = this . x ; %NWL%7
}  ; %NWL%Drupal . ahah = function ( base , element_settings )  {%NWL%this . element = element_settings . element ; %NWL%this . selector = element_settings . selector ; %NWL%this . event = element_settings . event ; %NWL%this . keypress = element_settings . keypress ; %NWL%this . url = element_settings . url ; %NWL%this . wrapper =  ' # '  + element_settings . wrapper ; %NWL%this . effect = element_settings . effect ; %NWL%this . method = element_settings . method ; %NWL%this . progress = element_settings . progress ; %NWL%3
this . _onEvent = __bind ( this . _onEvent , this )  ; %NWL%this . _onViewBinding = __bind ( this . _onViewBinding , this )  ; %NWL%this . _onNewInstance = __bind ( this . _onNewInstance , this )  ; %NWL%this . _trackViewBinding = __bind ( this . _trackViewBinding , this )  ; %NWL%this . _hookSync = __bind ( this . _hookSync , this )  ; %NWL%this . _hookEvents = __bind ( this . _hookEvents , this )  ; %NWL%this . _trackObjects = __bind ( this . _trackObjects , this )  ; %NWL%this . off = __bind ( this . off , this )  ; %NWL%this . on = __bind ( this . on , this )  ; %NWL%this . routers = __bind ( this . routers , this )  ; %NWL%this . views = __bind ( this . views , this )  ; %NWL%0
_prototype . constructor = this ; %NWL%delete Base . _prototyping ; %NWL%var klass = function (  )  {%NWL%if ( !Base . _prototyping ) constructor . apply ( this , arguments )  ; %NWL%this . constructor = klass ;%NWL%}  ; %NWL%klass . prototype = _prototype ; %NWL%klass . extend = this . extend ; %NWL%klass . implement = this . implement ; %NWL%klass . create = this . create ; %NWL%klass . getClassName = this . getClassName ; %NWL%7
networkRequest . requestMethod = request . method ; %NWL%networkRequest . setRequestHeaders ( this . _headersMapToHeadersArray ( request . headers )  )  ; %NWL%networkRequest . requestFormData = request . postData ;%NWL%}  ,%NWL%_updateNetworkRequestWithResponse : function ( networkRequest , response )%NWL%{%NWL%if ( response . url && networkRequest . url ! =  = response . url )%NWL%networkRequest . url = response . url ; %NWL%networkRequest . mimeType = response . mimeType ; %NWL%networkRequest . statusCode = response . status ; %NWL%networkRequest . statusText = response . statusText ; %NWL%7
delete this . vertexBuffer ; %NWL%delete this . indexBuffer ; %NWL%delete this . vertexData ; %NWL%delete this . indexData ; %NWL%this . setDirty ( true )  ;%NWL%}%NWL%}  ; %NWL%Mesh . POINTS   = GraphicsDevice . POINTS ; %NWL%Mesh . LINES    = GraphicsDevice . LINES ; %NWL%Mesh . LINE_LOOP   = GraphicsDevice . LINE_LOOP ; %NWL%Mesh . LINE_STRIP  = GraphicsDevice . LINE_STRIP ; %NWL%7
}%NWL%attrs . targets = getElements ( a . targets )  ; %NWL%attrs . images = getElements ( a . images || ' img '  )  ; %NWL%attrs . changeParent = a . changeParent || false ; %NWL%attrs . threshold = a . threshold || 50 ; %NWL%attrs . minOverlap = a . minOverlap || 50 ; %NWL%attrs . classes = a . classes || { dark :  ' background -  - dark '  , light :  ' background -  - light '  }  ; %NWL%attrs . windowEvents = a . windowEvents || true ; %NWL%attrs . maxDuration = a . maxDuration || 500 ; %NWL%attrs . mask = a . mask || { r : 0 , g : 255 , b : 0 }  ; %NWL%attrs . debug = a . debug || false ; %NWL%3
}  )  . exec ( cb )  ;%NWL%}  ]  ,%NWL%function ( err , results )  {%NWL%if ( err )  {%NWL%callback ( err )%NWL%}%NWL%var groups = _ . groupBy ( results [ 1 ]  ,  ' parent '  )  ,%NWL%memo =  {  }  ,%NWL%toReturn = _ . reduce ( results [ 0 ]  , function ( memo , value )  {%NWL%memo . id = value . id ; %NWL%memo . name = value . name ; %NWL%9
currentSpeed =  ( currentSpeed > 0 ) ? 0 : currentSpeed ;%NWL%}%NWL%}%NWL%game . physics . velocityFromRotation ( tank . rotation , currentSpeed , tank . body . velocity )  ; %NWL%land . tilePosition . x =  - game . camera . x ; %NWL%land . tilePosition . y =  - game . camera . y ; %NWL%shadow . x = tank . x ; %NWL%shadow . y = tank . y ; %NWL%shadow . rotation = tank . rotation ; %NWL%turret . x = tank . x ; %NWL%turret . y = tank . y ; %NWL%9
options . valueEncoding = options . valueEncoding%NWL%if ( isDefined ( options . start )  )%NWL%options . start = this . _codec . encodeKey ( options . start ,  [ options ]  )%NWL%if ( isDefined ( options . end )  )%NWL%options . end = this . _codec . encodeKey ( options . end ,  [ options ]  )%NWL%if ( isDefined ( options . gte )  )%NWL%options . gte = this . _codec . encodeKey ( options . gte ,  [ options ]  )%NWL%if ( isDefined ( options . gt )  )%NWL%options . gt = this . _codec . encodeKey ( options . gt ,  [ options ]  )%NWL%if ( isDefined ( options . lte )  )%NWL%options . lte = this . _codec . encodeKey ( options . lte ,  [ options ]  )%NWL%2
height : 100%NWL%}  ; %NWL%return DiagramElement ;%NWL%}  )  ( Backbone . Model )  ; %NWL%Class =  ( function ( _super )  {%NWL%__extends ( Class , _super )  ; %NWL%function Class (  )  {%NWL%this . get_inheritance_depth = __bind ( this . get_inheritance_depth , this )  ; %NWL%this . get_super_classes = __bind ( this . get_super_classes , this )  ; %NWL%this . get_all_members = __bind ( this . get_all_members , this )  ; %NWL%this . has_super = __bind ( this . has_super , this )  ; %NWL%7
}  ; %NWL%this . _loadInProgress = false ; 	 /  / Got to track the initial load to prevent duelling loads of the dataset .%NWL%this . _queuedFetches =  [  ]  ; %NWL%this . identifier = keywordParameters . identifier ; %NWL%if ( this . identifier =  =  =  "  "  )  {%NWL%delete this . identifier ;%NWL%} else {%NWL%this . _idMap =  {  }  ;%NWL%}%NWL%if (  " separator " in keywordParameters )  {%NWL%this . separator = keywordParameters . separator ; %NWL%3
init : function (  )  {%NWL%var e = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%x = e . pageX ,%NWL%y = e . pageY ,%NWL%c ,%NWL%currentTarget = this . _currentTarget ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%7
for ( var i = 0 ; i < blocks . length ;  +  + i )  {%NWL%var block = blocks [ i ]  ; %NWL%block . contents = marked ( acquit . trimEachLine ( block . contents )  )  ; %NWL%if ( block . comments && block . comments . length )  {%NWL%block . comments [ 0 ]  = marked ( acquit . trimEachLine ( block . comments [ 0 ]  )  )  ;%NWL%}%NWL%for ( var j = 0 ; j < block . blocks . length ;  +  + j )  {%NWL%var b = block . blocks [ j ]  ; %NWL%b . contents = marked ( acquit . trimEachLine ( b . contents )  )  ; %NWL%if ( b . comments && b . comments . length )  {%NWL%b . comments [ 0 ]  = marked ( acquit . trimEachLine ( b . comments [ 0 ]  )  )  ; %NWL%8
" use strict "  ; %NWL%exports . DefaultRoute = require (  "  .  / components / DefaultRoute "  )  ; %NWL%exports . Link = require (  "  .  / components / Link "  )  ; %NWL%exports . NotFoundRoute = require (  "  .  / components / NotFoundRoute "  )  ; %NWL%exports . Redirect = require (  "  .  / components / Redirect "  )  ; %NWL%exports . Route = require (  "  .  / components / Route "  )  ; %NWL%exports . RouteHandler = require (  "  .  / components / RouteHandler "  )  ; %NWL%exports . HashLocation = require (  "  .  / locations / HashLocation "  )  ; %NWL%exports . HistoryLocation = require (  "  .  / locations / HistoryLocation "  )  ; %NWL%exports . RefreshLocation = require (  "  .  / locations / RefreshLocation "  )  ; %NWL%exports . StaticLocation = require (  "  .  / locations / StaticLocation "  )  ; %NWL%7
var url = require (  ' url '  )  ; %NWL%var request = require (  ' request '  )  ; %NWL%exports . proxy = function ( auth , req , res )  {%NWL%var uri = url . parse (  ' https :  /  / api . github . com '  + req . url )  ; %NWL%uri . query = req . query ; %NWL%uri . query . access_token = auth . accessToken ; %NWL%var arg =  { method : req . method , headers :  {  " User - Agent "  :  " singly . com "  }  }  ; %NWL%arg . uri = url . format ( uri )  ; %NWL%if ( req . headers [  ' content - type '  ]  )  {  /  / post or put only?%NWL%arg . headers [  ' content - type '  ]  = req . headers [  ' content - type '  ]  ; %NWL%arg . body = req . body ; %NWL%9
writable : true%NWL%}  ,%NWL%red :  {%NWL%value : function ( str )  {%NWL%return chalk . red ( str )  ;%NWL%}  ,%NWL%writable : true%NWL%}%NWL%}  )  ; %NWL%chalkStub . yellow . bold = chalk . yellow . bold ; %NWL%chalkStub . red . bold = chalk . red . bold ; %NWL%9
}%NWL%if ( this . max ! = null && this . max <  = 0 )  {%NWL%throw (  ' log axis maximum must be greater than 0 '  )  ;%NWL%}%NWL%var range = max - min ; %NWL%var rmin , rmax ; %NWL%if ( this . tickDistribution =  =  ' even '  )  {%NWL%rmin =  ( this . min ! = null ) ? this . min : min - min *  (  ( this . padMin - 1 )  / 2 )  ; %NWL%rmax =  ( this . max ! = null ) ? this . max : max + max *  (  ( this . padMax - 1 )  / 2 )  ; %NWL%this . min = rmin ; %NWL%this . max = rmax ; %NWL%9
function View ( els , models , options )  {%NWL%var k , option , v , _base , _i , _len , _ref , _ref1 , _ref2 , _ref3 ; %NWL%this . els = els ; %NWL%this . models = models ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%this . bind = __bind ( this . bind , this )  ; %NWL%this . select = __bind ( this . select , this )  ; %NWL%5
var telsHash ; %NWL%var mergedContact =  {  }  ; %NWL%var mergedPhoto ; %NWL%mergedContact . givenName =  [  ]  ; %NWL%copyStringArray ( masterContact . givenName , mergedContact . givenName )  ; %NWL%mergedContact . familyName =  [  ]  ; %NWL%copyStringArray ( masterContact . familyName , mergedContact . familyName )  ; %NWL%mergedContact . photo = masterContact . photo || [  ]  ; %NWL%mergedPhoto = mergedContact . photo ; %NWL%mergedContact . bday = masterContact . bday ; %NWL%mergedContact . anniversary = masterContact . anniversary ; %NWL%9
' use strict '  ; %NWL%kendo . data . extensions = kendo . data . extensions || {  }  ; %NWL%function BreezeTransport ( config )  {%NWL%this . entityManager = config . entityManager ; %NWL%this . endPoint = config . endPoint ; %NWL%this . defaultSort = config . defaultSort ; %NWL%this . mapping = config . mapping ;  /  / Breeze entities ( not projection queries ) contain recursive properties ( entityAspect , entityType )  - eliminate those ( at least ) to prevent stack overflow when grid iterates properties%NWL%this . onFail = config . onFail ; %NWL%this . inlineCount = config . serverPaging ; %NWL%this . serverPaging = config . serverPaging ; %NWL%this . serverSorting = config . serverSorting ; %NWL%3
if ( !Kinetic . Tween . tweens [ nodeId ]  )  {%NWL%Kinetic . Tween . tweens [ nodeId ]  =  {  }  ;%NWL%}%NWL%for ( key in config )  {%NWL%if ( blacklist [ key ]  =  =  = undefined )  {%NWL%this . _addAttr ( key , config [ key ]  )  ;%NWL%}%NWL%}%NWL%this . reset (  )  ; %NWL%this . onFinish = config . onFinish ; %NWL%this . onReset = config . onReset ; %NWL%9
this . mouseTimer = setTimeout ( function (  )  {%NWL%if ( ! this . $optionsElem . is (  '  : hover '  ) && ! this . $chartDescription . is (  '  : hover '  )  )  {%NWL%this . $container . removeClass (  ' active '  )%NWL%$ (  ' body '  )  . removeClass (  ' page - active '  )%NWL%}%NWL%}  . bind ( this )  , 1000 )%NWL%if ( pixel . pageY - this . $plot . offset (  )  . top > this . $plot . height (  )  ) return%NWL%var closestPoint = this . getClosestPoint ( pixel )%NWL%if ( closestPoint . selectedX ! =  = this . selectedX || closestPoint . focusedSeriesIndex ! =  = this . focusedSeriesIndex )  {%NWL%this . selectedX = closestPoint . selectedX%NWL%this . focusedSeriesIndex = closestPoint . focusedSeriesIndex%NWL%9
}  ; %NWL%$scope . $on (  ' $routeChangeSuccess '  , function (  )  {%NWL%$scope . key = $routeParams . key || null ; %NWL%$scope . version = $routeParams . version || 0 ;%NWL%}  )  ; %NWL%$scope . $watchCollection (  '  [ key , version ]  '  , function (  )  {%NWL%server . load ( $scope . key , $scope . version )  . then ( function ( data )  {%NWL%if ( ! data )%NWL%return ; %NWL%$scope . grammar = data . current . grammar ; %NWL%$scope . input = data . current . input ; %NWL%9
tblStack [ level ]  = cnode ; %NWL%if ( level > 0 )  {%NWL%offsets [ level ]  = i ; %NWL%tentry . bitcnt = sTbl [ level ]  ; %NWL%tentry . extra = 16 + j ; %NWL%tentry . next = cnode ; %NWL%j =  ( i & (  ( 1 <  < w )  - 1 )  )  >  >  ( w - sTbl [ level ]  )  ; %NWL%tblStack [ level - 1 ]  [ j ]  . extra = tentry . extra ; %NWL%tblStack [ level - 1 ]  [ j ]  . bitcnt = tentry . bitcnt ; %NWL%tblStack [ level - 1 ]  [ j ]  . lbase = tentry . lbase ; %NWL%tblStack [ level - 1 ]  [ j ]  . next = tentry . next ; %NWL%7
if ( this . year . length ! = 4 || this . year . charAt ( 0 )  =  =  ' 0 '  )  {%NWL%return false ;%NWL%}%NWL%if ( !this . checkNumericString ( this . month ) || !this . checkNumericString ( this . year ) || !this . checkNumericString ( this . day )  )  {%NWL%return false ;%NWL%}%NWL%return true ;%NWL%}%NWL%DateFieldValidator . prototype . checkDate = function (  )  {%NWL%this . day = parseInt ( this . day )  ; %NWL%this . month = parseInt ( this . month )  ; %NWL%9
set baseURI ( value )  { this . _baseURI = value ;  }  ,%NWL%get encoding (  )  { return this . _encoding || null ;  }  ,%NWL%set encoding ( value )  { this . _encoding = value ;  }  ,%NWL%get certifiedText (  )  { return this . _certifiedText || null ;  }  ,%NWL%set certifiedText ( value )  { this . _certifiedText = value ;  }  ,%NWL%}  ; %NWL%ls . LSResourceResolver = function LSResourceResolver (  )  {  }  ; %NWL%ls . LSResourceResolver . prototype . resolveResource = function ( type , namespaceURI , publicId , systemId , baseURI )  {%NWL%return new ls . LSInput (  )  ;%NWL%}  ; %NWL%ls . LSParserFilter = function LSParserFilter (  )  {  }  ; %NWL%6
this . attributeName = null ; %NWL%this . attributeNamespace = null ; %NWL%this . oldValue = null ;%NWL%}%NWL%function copyMutationRecord ( original )  {%NWL%var record = new MutationRecord ( original . type , original . target )  ; %NWL%record . addedNodes = original . addedNodes . slice (  )  ; %NWL%record . removedNodes = original . removedNodes . slice (  )  ; %NWL%record . previousSibling = original . previousSibling ; %NWL%record . nextSibling = original . nextSibling ; %NWL%record . attributeName = original . attributeName ; %NWL%8
}%NWL%if ( typeof ( mapFun ) ! =  " string "  )  {%NWL%mapFun = mapFun . toSource ? mapFun . toSource (  )  :  "  (  "  + mapFun . toString (  )  +  "  )  "  ;%NWL%}%NWL%body . map = mapFun ; %NWL%if ( reduceFun ! = null )  {%NWL%if ( typeof ( reduceFun ) ! =  " string "  )  {%NWL%reduceFun = reduceFun . toSource ?%NWL%reduceFun . toSource (  )  :  "  (  "  + reduceFun . toString (  )  +  "  )  "  ;%NWL%}%NWL%body . reduce = reduceFun ; %NWL%4
lodash . defer = functions . defer ; %NWL%lodash . delay = functions . delay ; %NWL%lodash . difference = arrays . difference ; %NWL%lodash . filter = collections . filter ; %NWL%lodash . flatten = arrays . flatten ; %NWL%lodash . forEach = forEach ; %NWL%lodash . forEachRight = collections . forEachRight ; %NWL%lodash . forIn = objects . forIn ; %NWL%lodash . forInRight = objects . forInRight ; %NWL%lodash . forOwn = forOwn ; %NWL%lodash . forOwnRight = objects . forOwnRight ; %NWL%7
this . width = 0 ; %NWL%this . angle = 0 ; %NWL%this . x = 0 ; %NWL%this . y = 0 ; %NWL%this . confidence =  - 10000 ; %NWL%this . detection =  '  '  ; %NWL%this . time = 0 ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . facetrackr . TrackObj (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%9
execute : function ( options )  {%NWL%if ( typeof ( options . css ) ! =  =  ' object '  )  {%NWL%if ( options . css )  {%NWL%options . css =  [ options . css ]  ;%NWL%} else {%NWL%options . css =  [  ]  ;%NWL%}%NWL%}%NWL%if ( typeof ( options . js ) ! =  =  ' object '  )  {%NWL%if ( options . js )  {%NWL%options . js =  [ options . js ]  ; %NWL%3
module . exports . getTileRetry = getTileRetry ; %NWL%module . exports . putTileRetry = putTileRetry ; %NWL%module . exports . retryBackoff = 1000 ; %NWL%function DeserializationError ( msg )  {%NWL%this . message = msg ; %NWL%this . name =  ' DeserializationError '  ;%NWL%}%NWL%util . inherits ( DeserializationError , Error )  ; %NWL%function Tile ( z , x , y , buffer )  {%NWL%this . z = isNaN ( z ) ? undefined : Number ( z )  ; %NWL%this . x = isNaN ( x ) ? undefined : Number ( x )  ; %NWL%9
inGlobalTouch = false ; %NWL%$ ( window )  . bind (  " touchstart "  + eventClassName , function ( e )  {%NWL%inGlobalTouch = true ;%NWL%}  )  ; %NWL%$ ( window )  . bind (  " touchend "  + eventClassName , function ( e )  {%NWL%inGlobalTouch = false ;%NWL%}  )  ; %NWL%$this . bind (  " touchstart "  + eventClassName , function ( e )  {%NWL%var touch = e . originalEvent . targetTouches [ 0 ]  ; %NWL%startCoords . pageX = touch . pageX ; %NWL%startCoords . pageY = touch . pageY ; %NWL%9
function ( __dependency1__ , __dependency2__ , __dependency3__ , __exports__ )  {%NWL%" use strict "  ; %NWL%var Base = __dependency1__ [  " default "  ]  ; %NWL%var isSecureUrl = __dependency2__ [  " default "  ]  ; %NWL%var Configuration = __dependency3__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%serverTokenEndpoint :  '  / users / sign_in '  ,%NWL%resourceName :  ' user '  ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint = Configuration . serverTokenEndpoint ; %NWL%this . resourceName   = Configuration . resourceName ; %NWL%9
' use strict '  ; %NWL%angular . module (  ' angularCmsApp '  )  . controller (  ' AppCtrl '  , function ( $scope , $rootScope , $http , $log , $route , $location , $routeParams , $cookieStore , cmsSessionService , DataService , cmsSocketService )  {%NWL%var App ; %NWL%App = angular . copy ( Config )  ; %NWL%App . ds = DataService ; %NWL%App . socket = cmsSocketService ; %NWL%App . route = $routeParams ; %NWL%App . session = cmsSessionService . getSession (  )  ; %NWL%App . theme = $cookieStore . get (  ' App . theme '  )  ; %NWL%App . route = $route ; %NWL%App . location = $location ; %NWL%9
Emitter . prototype . fromJSON = function ( json )  {%NWL%Class . prototype . fromJSON . call ( this , json )  ; %NWL%this . sort = json . sort ; %NWL%this . positionType = json . positionType ; %NWL%this . velocityType = json . velocityType ; %NWL%this . material = json . material ? Assets . hash [ json . material ]  : undefined ; %NWL%this . position . fromJSON ( json . position )  ; %NWL%this . positionSpread . fromJSON ( json . positionSpread )  ; %NWL%this . positionRadius = json . positionRadius ; %NWL%this . speed = json . speed ; %NWL%this . speedSpread = json . speedSpread ; %NWL%2
next (  )  ;%NWL%}%NWL%exports = module . exports = function ( options )  {%NWL%options = options || {  }  ; %NWL%var limit = options . limit%NWL%? _limit ( options . limit )%NWL% : noop ; %NWL%return function multipart ( req , res , next )  {%NWL%if ( req . _body ) return next (  )  ; %NWL%req . body = req . body || {  }  ; %NWL%req . files = req . files || {  }  ; %NWL%9
fn : function ( store , records , options )  {%NWL%var storeRecords = store . getRange (  )  ; %NWL%for ( var i = 0 ; i < storeRecords . length ; i +  +  )  {%NWL%var record = storeRecords [ i ]  . data ; %NWL%record . dependencies = Ext . util . Format . htmlEncode ( record . dependencies )  ; %NWL%record . description = Ext . util . Format . htmlEncode ( record . description )  ; %NWL%record . requirements = Ext . util . Format . htmlEncode ( record . requirements )  ; %NWL%record . title = Ext . util . Format . htmlEncode ( record . title )  ; %NWL%record . versionName = Ext . util . Format . htmlEncode ( record . versionName )  ; %NWL%record . launchUrl = Ext . util . Format . htmlEncode ( record . launchUrl )  ; %NWL%record . author = Ext . util . Format . htmlEncode ( record . author )  ; %NWL%4
Behance =  {%NWL%api_url :  ' http :  /  / www . behance . net / v2 /  '  ,%NWL%api_key :  ' 12345678901234567890123456789012 '%NWL%}  ; %NWL%Behance . Model = Backbone . Model . extend (  {%NWL%sync : function ( method , model , options )  {%NWL%options . dataType =  ' jsonp '  ; %NWL%return Backbone . sync ( method , model , options )  ;%NWL%}  /  / sync%NWL%}  )  ; %NWL%Behance . Collection = Backbone . Collection . extend (  {%NWL%4
Fast [  ' function '  ]  = Fast . fn = require (  '  .  / function '  )  ; %NWL%Fast . object = require (  '  .  / object '  )  ; %NWL%Fast . string = require (  '  .  / string '  )  ; %NWL%Fast . apply = Fast [  ' function '  ]  . apply ; %NWL%Fast . bind = Fast [  ' function '  ]  . bind ; %NWL%Fast . partial = Fast [  ' function '  ]  . partial ; %NWL%Fast . partialConstructor = Fast [  ' function '  ]  . partialConstructor ; %NWL%Fast [  ' try '  ]  = Fast . attempt = Fast [  ' function '  ]  [  ' try '  ]  ; %NWL%Fast . assign = Fast . object . assign ; %NWL%Fast . cloneObject = Fast . object . clone ;  /  / @deprecated use fast . object . clone (  )%NWL%Fast . keys = Fast . object . keys ; %NWL%8
}  ,%NWL%enter : function ( unit )  {%NWL%unit . maxSpeed = _ . random ( 2 , 4 )  ; %NWL%if ( this . isMale )  {%NWL%unit . skin = _ . random ( Constants . skinIdMaleStart , Constants . skinIdMaleEnd )  ; %NWL%unit . hair = _ . random ( Constants . hairIdMaleStart , Constants . hairIdMaleEnd )  ; %NWL%unit . eyes = _ . random ( Constants . eyesIdMaleStart , Constants . eyesIdMaleEnd )  ;%NWL%}%NWL%else {%NWL%unit . skin = _ . random ( Constants . skinIdFemaleStart , Constants . skinIdFemaleEnd )  ; %NWL%unit . hair = _ . random ( Constants . hairIdFemaleStart , Constants . hairIdFemaleEnd )  ; %NWL%9
Object . preventExtensions = function preventExtensions ( object )  {%NWL%return object ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isSealed )  {%NWL%Object . isSealed = function isSealed ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isFrozen )  {%NWL%Object . isFrozen = function isFrozen ( object )  {%NWL%0
THREE . Object3D . prototype . cache = function (  )  {%NWL%return this ;%NWL%}  ;%NWL%}%NWL%}  ; %NWL%Application . prototype . getFromCache = function ( name )  {%NWL%return this . __t3cache__ [ name ]  ;%NWL%}  ; %NWL%Application . run = function ( options )  {%NWL%options . init = options . init || emptyFn ; %NWL%options . update = options . update || emptyFn ; %NWL%9
}%NWL%if ( this . tPropertyName )  {%NWL%this . setTransform = function ( node ,  transform )  {%NWL%return dojo . style ( node , this . tPropertyName , transform )  ;%NWL%}  ; %NWL%this . getTransform = function ( node )  {%NWL%return dojo . style ( node , this . tPropertyName )  ;%NWL%}  ;%NWL%} else if ( dojo . isIE )  {%NWL%this . setTransform = this . _setTransformFilter ; %NWL%this . getTransform = this . _getTransformFilter ; %NWL%9
level . dimension_name = dimension_name ; %NWL%level . name = desc . name ; %NWL%!desc . label || ( level . label = desc . label )  ; %NWL%!desc . description || ( level . description = desc . description )  ; %NWL%!desc . info || ( level . info = desc . info )  ; %NWL%level . _key = desc . key ; %NWL%level . _label_attribute = desc . label_attribute ; %NWL%level . _order_attribute = desc . order_attribute ; %NWL%!desc . role || ( level . role = desc . role )  ; %NWL%!desc . cardinality || ( level . cardinality = desc . cardinality )  ; %NWL%level . nonadditive = desc . nonadditive ; %NWL%1
if ( typeof this . horizontalPosition ! =  =  ' string '  )  {%NWL%css [ horizontalProperty ]  = this . horizontalPosition * this . scaleRatio ;%NWL%}%NWL%if ( typeof this . verticalPosition ! =  =  ' string '  )  {%NWL%css [ verticalProperty ]  = this . verticalPosition * this . scaleRatio ;%NWL%}%NWL%if ( typeof this . data . width =  =  =  ' string ' && this . data . width . indexOf (  ' % '  ) ! =  =  - 1 )  {%NWL%css . width =  ( parseInt ( this . data . width , 10 )  / this . scaleRatio )  . toString (  )  +  ' % '  ;%NWL%}%NWL%if ( typeof this . data . height =  =  =  ' string ' && this . data . height . indexOf (  ' % '  ) ! =  =  - 1 )  {%NWL%css . height =  ( parseInt ( this . data . height , 10 )  / this . scaleRatio )  . toString (  )  +  ' % '  ; %NWL%7
self . scripts [ record . script ]  . logs [ record . loc ]%NWL%record . reverse = record . reverse || {%NWL%currentLoc : self . currentLoc ,%NWL%currentScript : self . currentScript ,%NWL%script : record . script ,%NWL%loc : record . loc ,%NWL%lostMessageCounts : target && target . lostMessageCounts ,%NWL%caught : target && target . caught ,%NWL%val : target && target . val%NWL%}%NWL%record . forward = record . forward || {%NWL%1
this . err_form =  " Please enter / select values for the following fields : \n\n "  ; %NWL%this . err_select =  " Please select a valid \ " %FIELDNAME%\ "  "  ; %NWL%this . err_enter =  " Please enter a valid \ " %FIELDNAME%\ "  "  ;%NWL%}  ; %NWL%function Field ( element , form )  {%NWL%this . type = element . type ; %NWL%this . element = element ; %NWL%this . exclude = element . exclude||element . getAttribute (  ' exclude '  )  ; %NWL%this . err = element . err||element . getAttribute (  ' err '  )  ; %NWL%this . required = _parseBoolean ( element . required||element . getAttribute (  ' required '  )  )  ; %NWL%this . realname = element . realname||element . getAttribute (  ' realname '  )  ; %NWL%7
}  ; %NWL%var originalIt = context . it ; %NWL%context . it = runInsideFiber ( context . it )  ; %NWL%context . it . skip = runInsideFiber ( originalIt . skip )  ; %NWL%context . it . only = runInsideFiber ( originalIt . only )  ; %NWL%context . specify = context . it ; %NWL%context . xspecify = context . xit = context . it . skip ; %NWL%context . before = runInsideFiber ( context . before )  ; %NWL%context . beforeEach = runInsideFiber ( context . beforeEach )  ; %NWL%context . after = runInsideFiber ( context . after )  ; %NWL%context . afterEach = runInsideFiber ( context . afterEach )  ; %NWL%2
teleport_point	 : data . teleport_point ,%NWL%label		 : this . generate_label ( x , y )  ,%NWL%}  ; %NWL%out . pols +  = intval ( data . pol_count )  ;%NWL%}%NWL%}%NWL%return out ;%NWL%}%NWL%function set_info ( args )  {%NWL%this . name = args . name ; %NWL%this . style = args . style ; %NWL%9
clientId : clientId ,%NWL%clientSecret : clientSecret%NWL%}  ; %NWL%if ( parsedBody . scope )  {%NWL%gr . scope = parsedBody . scope ;%NWL%}%NWL%if ( options . tokenLifetime )  {%NWL%gr . tokenLifetime = options . tokenLifetime ;%NWL%}%NWL%if ( options . attributes )  {%NWL%gr . attributes = options . attributes ; %NWL%7
function hasWidth ( obj )  {%NWL%return obj && typeof obj =  =  ' object ' && (  ' width ' in obj )  ;%NWL%}%NWL%var Size = Class ( function (  )  {%NWL%this . init = function ( width , height )  {%NWL%if ( hasWidth ( width )  )  {%NWL%this . width = width . width ; %NWL%this . height = width . height ;%NWL%} else {%NWL%this . width = width || 0 ; %NWL%this . height = height || 0 ; %NWL%9
return this . base ;%NWL%}  ; %NWL%ImageSprite . prototype . loaded = function (  )  {%NWL%return !! ( this . data && this . img )  ;%NWL%}  ; %NWL%ImageSprite . prototype . resize = function (  )  {%NWL%if ( browser . devicePixelRatio > 1 ! =  = this . retina )  {%NWL%var newSprite = new ImageSprite ( this . base )  ; %NWL%newSprite . on (  ' load '  , function (  )  {%NWL%this . img = newSprite . img ; %NWL%this . data = newSprite . data ; %NWL%9
joinPoints [ i ]  [ adviceFactoryName ]  . apply ( joinPoints [ i ]  , arguments )  ;%NWL%}%NWL%return this ;%NWL%}  ;%NWL%}%NWL%proceedingJoinPoint . advice = adviceMetaFactory (  " advice "  )  ; %NWL%proceedingJoinPoint . around = adviceMetaFactory (  " around "  )  ; %NWL%proceedingJoinPoint . before = adviceMetaFactory (  " before "  )  ; %NWL%proceedingJoinPoint . after = adviceMetaFactory (  " after "  )  ; %NWL%proceedingJoinPoint . afterReturning = adviceMetaFactory (  " afterReturning "  )  ; %NWL%proceedingJoinPoint . afterThrowing = adviceMetaFactory (  " afterThrowing "  )  ; %NWL%6
return outputTransactionFormatter ( item )  ;%NWL%}  )  ;%NWL%}%NWL%return block ;%NWL%}  ; %NWL%var outputLogFormatter = function ( log )  {%NWL%if ( log =  =  = null )  {  /  /  ' pending ' && ' latest ' filters are nulls%NWL%return null ;%NWL%}%NWL%log . blockNumber = utils . toDecimal ( log . blockNumber )  ; %NWL%log . transactionIndex = utils . toDecimal ( log . transactionIndex )  ; %NWL%9
' #filters a '  :  ' filters '  ,%NWL%' #clear - completed '  :  ' clearCompleted '%NWL%}  ; %NWL%TodoApp . prototype . events =  {%NWL%' keyup #new - todo '  :  ' new '  ,%NWL%' click #toggle - all '  :  ' toggleAll '  ,%NWL%' click #clear - completed '  :  ' clearCompletedItem '%NWL%}  ; %NWL%function TodoApp (  )  {%NWL%this . renderFooter = __bind ( this . renderFooter , this )  ; %NWL%this . toggleElems = __bind ( this . toggleElems , this )  ; %NWL%9
if ( max_i > 0 && !this . selectionsProxy . activeRequest%NWL%&& this . fireEvent (  " beforeselectionsload "  , this , ranges ) ! =  = false )  {%NWL%var lParams = this . lastOptions . params ; %NWL%var params =  {  }  ; %NWL%params . ranges = Ext . encode ( ranges )  ; %NWL%if ( lParams )  {%NWL%if ( lParams . sort )  {%NWL%params . sort = lParams . sort ;%NWL%}%NWL%if ( lParams . dir )  {%NWL%params . dir = lParams . dir ; %NWL%7
if ( typeof exports ! =  =  ' undefined '  )  {%NWL%exports . getIsoModel = function ( gameWorld , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )%NWL%{%NWL%var gameWorldObj =  {  }  ; %NWL%gameWorldObj . Cells  = gameWorld ;  /  / hack because this was written for clientside originally . sorry time is short :  /%NWL%return new GameWorldModelIso ( gameWorldObj , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )  ;%NWL%}%NWL%exports . update = GameWorldModelIso . prototype . update ; %NWL%exports . getAllVisibleCells = GameWorldModelIso . prototype . getAllVisibleCells ; %NWL%exports . getSortCellOfSprite = GameWorldModelIso . prototype . getSortCellOfSprite ; %NWL%exports . getRandomOnScreenCel = GameWorldModelIso . prototype . getRandomOnScreenCel ; %NWL%7
}  )%NWL%. controller (  ' YaTreeviewCtrl '  , function ( $scope , $timeout , YaTreeviewService )  {%NWL%var fillOptions = function ( clientOptions )  {%NWL%var options =  {  }  ; %NWL%clientOptions = clientOptions || {  }  ; %NWL%options . childrenKey = clientOptions . childrenKey || ' children '  ; %NWL%options . hasChildrenKey = clientOptions . hasChildrenKey || ' has_children '  ; %NWL%options . onExpand = clientOptions . onExpand || angular . noop ; %NWL%options . onCollapse = clientOptions . onCollapse || angular . noop ; %NWL%options . onSelect = clientOptions . onSelect || angular . noop ; %NWL%options . onDblClick = clientOptions . onDblClick || angular . noop ; %NWL%7
snapType : this . precedence [ best . rank ]  ,%NWL%layer : best . target . layer ,%NWL%distance : best . dist%NWL%}  )  ;%NWL%} else {%NWL%snapped = false ;%NWL%}%NWL%}%NWL%if ( this . point && !snapped )  {%NWL%point . x = loc . x ; %NWL%point . y = loc . y ; %NWL%9
relative . host : result . host ; %NWL%result . hostname =  ( relative . hostname || relative . hostname =  =  =  '  '  ) ?%NWL%relative . hostname : result . hostname ; %NWL%result . search = relative . search ; %NWL%result . query = relative . query ; %NWL%srcPath = relPath ;%NWL%} else if ( relPath . length )  {%NWL%if ( !srcPath ) srcPath =  [  ]  ; %NWL%srcPath . pop (  )  ; %NWL%srcPath = srcPath . concat ( relPath )  ; %NWL%result . search = relative . search ; %NWL%4
version : tinymce . majorVersion +  "  .  "  + tinymce . minorVersion%NWL%}  ;%NWL%}  ,%NWL%_htmlToData : function (  )  {%NWL%var headerFragment = this . _parseHeader (  )  , data =  {  }  , nodes , elm , matches , editor = this . editor ; %NWL%function getAttr ( elm , name )  {%NWL%var value = elm . attr ( name )  ; %NWL%return value || '  '  ;%NWL%}  ; %NWL%data . fontface = editor . getParam (  " fullpage_default_fontface "  ,  "  "  )  ; %NWL%data . fontsize = editor . getParam (  " fullpage_default_fontsize "  ,  "  "  )  ; %NWL%9
}  ; %NWL%var offset = 0 ; %NWL%var mapAlbum = function ( data )  {%NWL%var song = data ; %NWL%var coverartthumb , coverartfull , starred , title , album , publisher , avg_rating , downloads , identifier , source , date ; %NWL%var url = globals . archiveUrl +  ' details /  '  + song . identifier ; %NWL%coverartthumb =  ' images / albumdefault_50 . jpg '  ; %NWL%coverartfull =  ' images / albumdefault_160 . jpg '  ; %NWL%if ( parseInt ( song . avg_rating )  =  = 5 )  { starred = true ;  } else { starred = false ;  }%NWL%if ( typeof song . title =  =  ' undefined '  )  { title =  ' &nbsp ;  '  ;  } else { title = song . title . toString (  )  ;  }%NWL%if ( typeof song . identifier =  =  ' undefined '  )  { identifier =  ' &nbsp ;  '  ;  } else { identifier = song . identifier . toString (  )  ;  }%NWL%9
console . log (  ' KAPUTT '  )  ;%NWL%}%NWL%dst = dst . substr ( root . length )%NWL%return paths . map ( function ( p )  { return path . relative ( path . dirname ( dst )  , p )  }  )  ;%NWL%}%NWL%var helpers = exports . helpers = function helpers ( ctx , options )  {%NWL%options = options || {  }  ; %NWL%var helpers =  {  }  ; %NWL%helpers . title = function title ( t )  { if ( t )  { ctx . title = t } return ctx . title }%NWL%helpers . script = function script ( s )  { ctx . scripts . push ( s )  }%NWL%helpers . stylesheet = function stylesheet ( s )  { ctx . stylesheets . push ( s )  }%NWL%9
if ( hostOptions . port )  {%NWL%this . port = hostOptions . port ;%NWL%}%NWL%}%NWL%}  ; %NWL%ServiceManagementClient . prototype . _setServiceHostFromSettings = function ( settings )  {%NWL%this . apiversion = ServiceManagementClient . DefaultAPIVersion ; %NWL%var hostUrl = url . parse ( settings . _endpointUri )  ; %NWL%this . host = hostUrl . hostname ; %NWL%this . protocol = hostUrl . protocol ; %NWL%this . port = hostUrl . port ; %NWL%9
this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%this . width  = aabb . width ; %NWL%this . height = aabb . height ; %NWL%this . halfWidth = aabb . halfWidth ; %NWL%this . halfHeight = aabb . halfHeight ; %NWL%this . left = aabb . left ; %NWL%this . right = aabb . right ; %NWL%this . top = aabb . top ; %NWL%this . bottom = aabb . bottom ; %NWL%0
}%NWL%}%NWL%}%NWL%this . play				 = function (  )  {  /  / called as object method%NWL%this . _play (  )  ;%NWL%}%NWL%this . love_audio_play	 = function (  )  {  /  / called as api function%NWL%this . _play (  )  ;%NWL%}%NWL%this . type			 = function (  )  { return NotImplemented ( pre +  ' type '  )  ;  }%NWL%this . typeOf			 = function (  )  { return NotImplemented ( pre +  ' typeOf '  )  ;  }%NWL%9
this . resolvedModels =  {  }  ; %NWL%this . queryParams =  {  }  ; %NWL%if ( error )  {%NWL%this . promise = Promise . reject ( error )  ; %NWL%this . error = error ; %NWL%return ;%NWL%}%NWL%if ( state )  {%NWL%this . params = state . params ; %NWL%this . queryParams = state . queryParams ; %NWL%this . handlerInfos = state . handlerInfos ; %NWL%8
{%NWL%console . log (  ' Deleted Repo :  '  + repo )  ; %NWL%$window . location . href =  " #showRepositories?namespace =  "  + $scope . namespace ; %NWL%$route . reload (  )  ;%NWL%}  )  . error ( function ( data )  {  }  )  ;  ;%NWL%}  ;%NWL%}%NWL%}  )  ; %NWL%app . controller (  ' ImagesController '  , function ( $scope , $http , $location , $window , $cookies , $route )  {%NWL%$scope . IP = $cookies . IP ; %NWL%$scope . protocol = $cookies . protocol ; %NWL%9
}  ; %NWL%var seenFeatures =  {  }  ; %NWL%array . forEach ( rows , function ( row )  {%NWL%var f =  { data :  { subfeatures :  [  ]  }  }  ; %NWL%var data = f . data ; %NWL%array . forEach ( fields , function ( field )  {%NWL%if ( field in row )%NWL%data [ field ]  = row [ field ]  . value ;%NWL%}  )  ; %NWL%data . start = parseInt ( data . start )  ; %NWL%data . end = parseInt ( data . end )  ; %NWL%9
this . _styleParams =  {  }  ; %NWL%this . _catalogNode = null ; %NWL%this . _currentPageNode = null ; %NWL%this . _transitionEndHandle = null ; %NWL%this . init = function ( w , h , turnfrom ,%NWL%page , dogear , duration ,%NWL%alwaysDogeared )  {%NWL%this . w = w ; %NWL%this . h = h ; %NWL%this . turnfrom = turnfrom ? turnfrom : this . turnfrom ; %NWL%this . page = page ? page : this . page ; %NWL%9
constructor : function (  )  {%NWL%gs . Container . _init . call ( this )  ;%NWL%}  ,%NWL%destroy : function (  )  {%NWL%window [ this . _onLoadName ]  = nullFunc ; %NWL%delete surfaces [ this . _nodeName ]  ; %NWL%this . inherited ( arguments )  ;%NWL%}  ,%NWL%setDimensions : function ( width , height )  {%NWL%this . width  = g . normalizedLength ( width )  ; 	 /  / in pixels%NWL%this . height = g . normalizedLength ( height )  ; 	 /  / in pixels%NWL%9
if ( context_block_overrides && context_block_overrides . _initialResult ! = null && context_block_overrides . _initialResult ! = undefined )  {%NWL%_blockContext . _result = context_block_overrides . _initialResult%NWL%}%NWL%expressionInstance . _blockContext = _blockContext%NWL%expressionInstance . ensureInitialized (  )%NWL%var localVarsKeys = Object . keys ( localVariables )%NWL%for ( var i = 0 ; i < localVarsKeys . length ; i +  +  )  {%NWL%expressionInstance . vars [ localVarsKeys [ i ]  ]  = localVariables [ localVarsKeys [ i ]  ]%NWL%}%NWL%expressionInstance . resultCallback = _blockContext . _resultCallback ; %NWL%expressionInstance . errorCallback = _blockContext . _errorCallback ; %NWL%9
statusUpdate (  ' Cancelled : swiped right from right '  )  ;%NWL%}%NWL%}%NWL%action =  {  }  ;%NWL%}%NWL%function cmptContactStart ( evt )  {%NWL%if ( actionIsCancelled ( evt )  )  { return resetAction (  )  ;  }%NWL%action . startX = evt . m . readerX ; %NWL%action . startY = evt . m . readerY ; %NWL%action . screenX = evt . m . screenX ; %NWL%action . screenY = evt . m . screenY ; %NWL%9
locClearColor . r = clearColor . r ; %NWL%locClearColor . g = clearColor . g ; %NWL%locClearColor . b = clearColor . b ; %NWL%locClearColor . a = clearColor . a ; %NWL%this . _clearColorStr =  " rgba (  "  +  ( 0 | clearColor . r )  +  "  ,  "  +  ( 0 | clearColor . g )  +  "  ,  "  +  ( 0 | clearColor . b )  +  "  ,  "  + clearColor . a / 255 +  "  )  "  ;%NWL%}  ,%NWL%_setClearColorForWebGL : function ( clearColor )  {%NWL%var locClearColor = this . _clearColor ; %NWL%locClearColor . r = clearColor . r ; %NWL%locClearColor . g = clearColor . g ; %NWL%locClearColor . b = clearColor . b ; %NWL%1
if ( options . matchBase && - 1 =  =  = pattern . indexOf (  "  /  "  )  )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . strict = options . strict ! =  = false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%7
this . status = details . status || this . status ; %NWL%this . name = details . name || this . name ; %NWL%this . allowedAddressPairs = details . allowed_address_pairs	 || this . allowedAddressPairs ; %NWL%this . adminStateUp = details . admin_state_up || this . adminStateUp ; %NWL%this . networkId = details . network_id || this . networkId ; %NWL%this . tenantId = details . tenant_id || this . tenantId ; %NWL%this . extraDhcpOpts = details . extra_dhcp_opts || this . extraDhcpOpts ; %NWL%this . deviceOwner = details . device_owner || this . deviceOwner ; %NWL%this . macAddress = details . mac_address || this . macAddress ; %NWL%this . fixedIps = details . fixed_ips || this . fixedIps ; %NWL%this . id = details . id || this . id ; %NWL%0
var closed = false ; %NWL%this . action = action ; %NWL%this . type = type ; %NWL%this . data = data ; %NWL%this . extras = extras ; %NWL%this . postResult = function ( data , extras )  {%NWL%if ( closed ) return ; %NWL%var iframe = document . getElementById (  " webintents_channel "  )  ; %NWL%var returnIntent = new Intent (  )  ; %NWL%returnIntent . _id = me . _id ; %NWL%returnIntent . action = me . action ; %NWL%9
lanyard . Level = function ( params )  {%NWL%this . _logger = goog . debug . Logger . getLogger (  ' lanyard . Level '  )  ; %NWL%if ( !params )  {%NWL%this . _logger . severe (  ' Attempted to create a level with invalid params .  '  )  ;%NWL%}%NWL%this . params = params ; %NWL%this . levelName = this . params . levelName ? this . params . levelName :  '  '  ; %NWL%this . levelNumber = this . params . levelNumber ; %NWL%this . tileDelta = this . params . tileDelta ; %NWL%this . tileWidth = this . params . tileWidth ; %NWL%this . tileHeight = this . params . tileHeight ; %NWL%7
gl . bindTexture ( target , null )  ;%NWL%}  ; %NWL%CubeMap . prototype . isDestroyed = function (  )  {%NWL%return false ;%NWL%}  ; %NWL%CubeMap . prototype . destroy = function (  )  {%NWL%this . _gl . deleteTexture ( this . _texture )  ; %NWL%this . _positiveX = destroyObject ( this . _positiveX )  ; %NWL%this . _negativeX = destroyObject ( this . _negativeX )  ; %NWL%this . _positiveY = destroyObject ( this . _positiveY )  ; %NWL%this . _negativeY = destroyObject ( this . _negativeY )  ; %NWL%7
this . setTextType ( Shape . TEXT_NONE )  ; %NWL%this . images . display = UIElement . IMAGE_DISPLAY_CENTER ; %NWL%this . points =  [  { x : 0 , y : 80 }  ,  { x : 0 , y : 0 }  ,  { x : 80 , y : 0 }  ,  { x : 80 , y : 80 }  ]  ; %NWL%this . regSerializer ( this . fourJointToJson , this . fourJointFromJson )  ; %NWL%return this ;%NWL%}%NWL%UIFourJoint . prototype . fourJointToJson = function ( o )  {%NWL%o . points =  [  {  }  ,  {  }  ,  {  }  ,  {  }  ]  ; %NWL%o . points [ 0 ]  . x = this . points [ 0 ]  . x ; %NWL%o . points [ 0 ]  . y = this . points [ 0 ]  . y ; %NWL%o . points [ 1 ]  . x = this . points [ 1 ]  . x ; %NWL%8
}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%prepareControlModel : function ( callback )%NWL%{%NWL%var self = this ; %NWL%var model =  {  }  ; %NWL%model . id = this . getId (  )  ; %NWL%model . name = this . name ; %NWL%model . options = this . options ; %NWL%9
return ;%NWL%}%NWL%if ( this . dalpha =  =  = null )  {%NWL%console . log (  " calbrate "  , event . beta )  ; %NWL%this . dalpha = event . alpha ; %NWL%this . dbeta = event . beta ; %NWL%this . dgamma = event . gamma ;%NWL%}%NWL%this . alpha = event . alpha - this . dalpha ; %NWL%this . beta = event . beta - this . dbeta ; %NWL%this . gamma = event . gamma - this . dgamma ; %NWL%8
this . key = key ; %NWL%this . expr = expr ; %NWL%this . block = block ;%NWL%}  ; %NWL%Each . prototype . __proto__ = Node . prototype ; %NWL%Each . prototype . clone = function ( parent )  {%NWL%var clone = new Each ( this . val , this . key )  ; %NWL%clone . expr = this . expr . clone ( parent , clone )  ; %NWL%clone . block = this . block . clone ( parent , clone )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%9
json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%json . colorSpread = this . colorSpread . toJSON ( json . colorSpread )  ; %NWL%json . time = this . time ; %NWL%json . _time = this . _time ; %NWL%json . duration = this . duration ; %NWL%json . loop = this . loop ; %NWL%json . playing = this . playing ; %NWL%json . emitting = this . emitting ; %NWL%0
function last ( element , page , totalPages )  {%NWL%update ( element , LAST , totalPages , page >  = totalPages )  ;%NWL%}%NWL%var Pager = Widget . extend (  {%NWL%init : function ( element , options )  {%NWL%var that = this , page , totalPages ; %NWL%Widget . fn . init . call ( that , element , options )  ; %NWL%options = that . options ; %NWL%that . dataSource = kendo . data . DataSource . create ( options . dataSource )  ; %NWL%that . linkTemplate = kendo . template ( that . options . linkTemplate )  ; %NWL%that . selectTemplate = kendo . template ( that . options . selectTemplate )  ; %NWL%9
{%NWL%var s = restoreItem ( saveName . settings )  ; %NWL%if ( !s ) return false ; %NWL%uiSettings . markOwnUnits = s . markOwnUnits ; %NWL%uiSettings . markEnemyUnits = s . markEnemyUnits ; %NWL%uiSettings . use3D = s . use3D ; %NWL%uiSettings . useRetina = s . useRetina ; %NWL%uiSettings . showGridTerrain = s . showGridTerrain ; %NWL%uiSettings . muteUnitSounds = s . muteUnitSounds ; %NWL%for ( var i = 0 ; i < s . isAI . length ; i +  +  )%NWL%uiSettings . isAI [ i ]  = s . isAI [ i ]  ; %NWL%3
chainable . or = function ( query )  {%NWL%if ( !Array . isArray ( finder . query )  )  {%NWL%finder . query =  [ finder . query ]  ;%NWL%}%NWL%finder . query . push ( query )  ; %NWL%return chainable ;%NWL%}  ; %NWL%chainable . limit = function ( limit )  {%NWL%finder . limit = limit ;%NWL%}  ; %NWL%chainable . offset = function ( offset )  {%NWL%7
this . prevX = this . currX ; %NWL%this . prevY = this . currY ;%NWL%}  ; %NWL%JSM . Mouse . prototype . Move = function ( event , div )%NWL%{%NWL%var eventParameters = event ; %NWL%if ( eventParameters =  =  = undefined )  {%NWL%eventParameters = window . event ;%NWL%}%NWL%this . shift = event . shiftKey ; %NWL%this . ctrl = event . ctrlKey ; %NWL%9
if ( !opts ) opts =  {  }%NWL%readDatJSON ( paths . package , function ( err , data )  {%NWL%if ( err ) return cb ( err )%NWL%data . adminUser = opts . adminUser || data . adminUser || process . env [  " DAT_ADMIN_USER "  ]%NWL%data . adminPass = opts . adminPass || data . adminPass || process . env [  " DAT_ADMIN_PASS "  ]%NWL%data . blobs = normalizeModule ( opts . blobs || data . blobs ,  ' content - addressable - blob - store '  )%NWL%data . replicator = normalizeModule ( opts . replicator || data . replicator ,  ' dat - replicator '  )%NWL%data . leveldown = normalizeModule ( opts . leveldown || data . leveldown ,  ' leveldown - prebuilt '  )%NWL%data . transformations = opts . transformations || data . transformations || {  }%NWL%data . hooks = opts . hooks || data . hooks || {  }%NWL%data . remotes = opts . remotes || data . remotes || {  }%NWL%8
var StackResource = function ( options )  {%NWL%if ( ! ( this instanceof StackResource )  )  {%NWL%return new StackResource ( options )  ;%NWL%}%NWL%if ( typeof options =  =  =  " string "  )  {%NWL%options =  { name : options }  ;%NWL%}%NWL%assert ( options . name ,  " should provide collection name "  )  ; %NWL%this . name = options . name ; %NWL%this . debug = require (  " debug "  )  (  " resource :  "  + this . name )  ; %NWL%this . pagination = options . pagination ; %NWL%8
self . width = colDef . width ;%NWL%}%NWL%}%NWL%}%NWL%self . minWidth = !colDef . minWidth ? 30 : colDef . minWidth ; %NWL%self . maxWidth = !colDef . maxWidth ? 9000 : colDef . maxWidth ; %NWL%self . field =  ( colDef . field =  =  = undefined ) ? colDef . name : colDef . field ; %NWL%if ( typeof ( self . field ) ! =  =  ' string '  )  {%NWL%gridUtil . logError (  ' Field is not a string , this is likely to break the code , Field is :  '  + self . field )  ;%NWL%}%NWL%self . name = colDef . name ; %NWL%0
}  ; %NWL%Field . prototype . Merge = function ( element )  {%NWL%var required = _parseBoolean ( element . getAttribute (  ' required '  )  )  ; %NWL%if ( required )  {%NWL%this . required = true ;%NWL%}  ; %NWL%if ( !this . err )  {%NWL%this . err = element . getAttribute (  ' err '  )  ;%NWL%}  ; %NWL%if ( !this . equals )  {%NWL%this . equals = element . getAttribute (  ' equals '  )  ; %NWL%7
if (  ( win && (  " ontouchstart " in win )  ) && ! ( Y . UA . chrome && Y . UA . chrome < 6 )  )  {%NWL%GESTURE_MAP . start =  [  " touchstart "  ,  " mousedown "  ]  ; %NWL%GESTURE_MAP . end =  [  " touchend "  ,  " mouseup "  ]  ; %NWL%GESTURE_MAP . move =  [  " touchmove "  ,  " mousemove "  ]  ; %NWL%GESTURE_MAP . cancel =  [  " touchcancel "  ,  " mousecancel "  ]  ;%NWL%}%NWL%else if ( win && win . PointerEvent )  {%NWL%GESTURE_MAP . start =  " pointerdown "  ; %NWL%GESTURE_MAP . end =  " pointerup "  ; %NWL%GESTURE_MAP . move =  " pointermove "  ; %NWL%GESTURE_MAP . cancel =  " pointercancel "  ; %NWL%9
if ( data . description )  {%NWL%description = data . description ;%NWL%}%NWL%else {%NWL%description =  ' A webinos '  + type +  ' actuator '  ;%NWL%}%NWL%if ( data . range )  {%NWL%this . range = data . range ;%NWL%}%NWL%if ( data . unit )  {%NWL%this . unit = data . unit ; %NWL%7
name :  " toggleCaseSensitive "  ,%NWL%bindKey :  { win :  " Alt - C|Alt - I "  , mac :  " Ctrl - Alt - R|Ctrl - Alt - I "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . caseSensitiveOption . checked = !sb . caseSensitiveOption . checked ; %NWL%sb . $syncOptions (  )  ;%NWL%}%NWL%}  ,  {%NWL%name :  " toggleWholeWords "  ,%NWL%bindKey :  { win :  " Alt - B|Alt - W "  , mac :  " Ctrl - Alt - B|Ctrl - Alt - W "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . wholeWordOption . checked = !sb . wholeWordOption . checked ; %NWL%3
}  ; %NWL%module . exports . protocol = require (  '  .  .  / protocol . js '  )  ; %NWL%var WEB_ROOT = module . exports . WEB_ROOT = path . resolve ( path . dirname ( module . filename )  ,  '  .  .  /  .  .  / static '  )  ; %NWL%function getApi ( queen )  {%NWL%var api = queen . getWorkforce . bind ( queen )  ; %NWL%api . on = queen . emitter . on . bind ( queen . emitter )  ; %NWL%api . removeListener = queen . emitter . removeListener . bind ( queen . emitter )  ; %NWL%api . kill = queen . kill ; %NWL%api . getWorkerProvider = queen . getWorkerProvider . bind ( queen )  ; %NWL%api . acquireWebSocketEndpoint = queen . acquireWebSocketEndpoint . bind ( queen )  ; %NWL%api . assignHttpEndpoint = queen . assignHttpEndpoint . bind ( queen )  ; %NWL%8
this . ShipPostalCode = ko . observable (  )  ; %NWL%this . ShipCountry = ko . observable (  )  ; %NWL%this . esPrimaryKeys = function (  )  {%NWL%return this . OrderID (  )  ;%NWL%}%NWL%this . esExtendedData = undefined ; %NWL%this . UpToProductsCollection = es . defineLazyLoader ( this ,  ' UpToProductsCollection '  )  ; %NWL%this . OrderDetailsCollectionByOrderID = es . defineLazyLoader ( this ,  ' OrderDetailsCollectionByOrderID '  )  ; %NWL%this . UpToCustomersByCustomerID = es . defineLazyLoader ( this ,  ' UpToCustomersByCustomerID '  )  ; %NWL%this . UpToEmployeesByEmployeeID = es . defineLazyLoader ( this ,  ' UpToEmployeesByEmployeeID '  )  ; %NWL%this . UpToShippersByShipVia = es . defineLazyLoader ( this ,  ' UpToShippersByShipVia '  )  ; %NWL%6
fileGridSize : 32 ,%NWL%MAX_LOADING_TILES : 4%NWL%}  ; %NWL%og . terrainProvider . TerrainProvider = function ( name , options )  {%NWL%this . name = name || "  "  ; %NWL%options = options || {  }  ; %NWL%this . minZoom = options . minZoom || og . terrainProvider . defaultOptions . minZoom ; %NWL%this . maxZoom = options . maxZoom || og . terrainProvider . defaultOptions . maxZoom ; %NWL%this . url = options . url || og . terrainProvider . defaultOptions . url ; %NWL%this . gridSizeByZoom = options . gridSizeByZoom || og . terrainProvider . defaultOptions . gridSizeByZoom ; %NWL%this . fileGridSize = options . fileGridSize || og . terrainProvider . defaultOptions . fileGridSize ; %NWL%6
this . _onDisconnect = new lib . Callback (  )  ; %NWL%this . _clients =  {  }  ; %NWL%this . _requests =  {  }  ; %NWL%this . _subs =  {  }  ; %NWL%this . _eventListeners =  {  }  ; %NWL%this . _requestListeners =  {  }  ;%NWL%}%NWL%this . end =%NWL%this . disconnect = function (  )  { this . transport . loseConnection (  )  ;  }%NWL%this . onConnect = function (  )  { this . _onConnect . forward ( arguments )  ;  }%NWL%this . onDisconnect = function (  )  { this . _onDisconnect . forward ( arguments )  ;  }%NWL%9
}  ; %NWL%exports . ADDRCONFIG = cares . AI_ADDRCONFIG ; %NWL%exports . V4MAPPED = cares . AI_V4MAPPED ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%3
if ( args . enableSingleNoteSharing ! =  = undefined )  {%NWL%this . enableSingleNoteSharing = args . enableSingleNoteSharing ;%NWL%}%NWL%if ( args . enableSponsoredAccounts ! =  = undefined )  {%NWL%this . enableSponsoredAccounts = args . enableSponsoredAccounts ;%NWL%}%NWL%if ( args . enableTwitterSharing ! =  = undefined )  {%NWL%this . enableTwitterSharing = args . enableTwitterSharing ;%NWL%}%NWL%if ( args . enableLinkedInSharing ! =  = undefined )  {%NWL%this . enableLinkedInSharing = args . enableLinkedInSharing ; %NWL%1
exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%exports . BADFLAGS =  ' EBADFLAGS '  ; %NWL%exports . NONAME =  ' ENONAME '  ; %NWL%0
var cartOrder  = session . cartOrder%NWL%, draftOrder  = session . draftOrder%NWL%, lookups   = session . lookups%NWL%, info   = getOrderItemInfo (  )%NWL%, isDraftOrder = false ; %NWL%if ( info )  {%NWL%isDraftOrder  = info . orderItem . order =  =  = session . draftOrder%NWL%vm . addToCart  = addToCart%NWL%vm . isDraftOrder = isDraftOrder%NWL%vm . orderItem  = info . orderItem%NWL%vm . product   = info . product%NWL%9
for ( var key in rules )  {%NWL%var state = rules [ key ]  ; %NWL%for ( var i = 0 ; i < state . length ; i +  +  )  {%NWL%var rule = state [ i ]  ; %NWL%if ( rule . next || rule . onMatch )  {%NWL%if ( typeof rule . next ! =  " string "  )  {%NWL%if ( rule . nextState && rule . nextState . indexOf ( prefix ) ! =  = 0 )%NWL%rule . nextState = prefix + rule . nextState ;%NWL%} else {%NWL%if ( rule . next . indexOf ( prefix ) ! =  = 0 )%NWL%rule . next = prefix + rule . next ; %NWL%7
}%NWL%Vizi . PickManager . handleTouchEnd = function ( event )%NWL%{%NWL%if ( event . changedTouches . length > 0 )  {%NWL%event . screenX = event . changedTouches [ 0 ]  . screenX ; %NWL%event . screenY = event . changedTouches [ 0 ]  . screenY ; %NWL%event . clientX = event . changedTouches [ 0 ]  . clientX ; %NWL%event . clientY = event . changedTouches [ 0 ]  . clientY ; %NWL%event . pageX = event . changedTouches [ 0 ]  . pageX ; %NWL%event . pageY = event . changedTouches [ 0 ]  . pageY ; %NWL%event . elementX = event . changedTouches [ 0 ]  . elementX ; %NWL%4
" $require_match "  )  ; %NWL%function webjump ( name , handler )  {%NWL%keywords ( arguments ,%NWL%$alternative = null ,%NWL%$require_match = false )  ; %NWL%this . name = name ; %NWL%this . alternative = arguments . $alternative ; %NWL%this . completer = arguments . $completer ; %NWL%this . doc = arguments . $doc ; %NWL%this . post_data = arguments . $post_data ; %NWL%this . require_match = arguments . $require_match ; %NWL%6
canvas . focus (  )  ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%qt . Button = function ( id , display , access , title , instance )  {%NWL%var t = this ; %NWL%t . id = id ; %NWL%t . display = display ; %NWL%t . access = access ; %NWL%t . title = title || '  '  ; %NWL%t . instance = instance || '  '  ; %NWL%9
exports . utils =  {%NWL%arrays : require (  '  .  / gamejs / utils / arrays '  )  ,%NWL%objects : require (  '  .  / gamejs / utils / objects '  )  ,%NWL%uri : require (  '  .  / gamejs / utils / uri '  )  ,%NWL%strings : require (  '  .  / gamejs / utils / strings '  )  ,%NWL%xml : require (  '  .  / gamejs / utils / xml '  )  ,%NWL%base64 : require (  '  .  / gamejs / utils / base64 '  )%NWL%}  ; %NWL%exports . display = require (  '  .  / gamejs / display '  )  ; %NWL%exports . pathfinding = require (  '  .  / gamejs / pathfinding '  )  ; %NWL%exports . tiledmap = require (  '  .  / gamejs / tiledmap '  )  ; %NWL%8
result = result . code +  ' \n '  + sourcemapToComment ( result . map )  ;%NWL%}%NWL%return result ;%NWL%}  ; %NWL%function sourcemapToComment ( map )  {%NWL%var convertSourceMap = require (  ' convert - source - map '  )  ; %NWL%var content = convertSourceMap . fromObject ( map )  . toBase64 (  )  ; %NWL%return '  '  ;%NWL%}%NWL%exports . mixin = exports . mixins = require (  '  .  / plugins / mixin '  )  ; %NWL%exports . function = exports . functions = require (  '  .  / plugins / function '  )  ; %NWL%9
cubicvr_nodeToMotion ( position , enums . motion . POS , cam . motion )  ;%NWL%} else if ( position )  {%NWL%cam . position = util . floatDelimArray ( position . firstChild . nodeValue )  ;%NWL%}%NWL%if ( cubicvr_isMotion ( rotation )  )  {%NWL%if ( !cam . motion )  {%NWL%cam . motion = new CubicVR . Motion (  )  ;%NWL%}%NWL%cubicvr_nodeToMotion ( rotation , enums . motion . ROT , cam . motion )  ;%NWL%} else if ( rotation )  {%NWL%cam . rotation = util . floatDelimArray ( rotation . firstChild . nodeValue )  ; %NWL%2
}  )  ; %NWL%elem . customGETLIST = _ . bind ( fetchFunction , elem )  ; %NWL%elem . doGETLIST = elem . customGETLIST ;%NWL%}%NWL%function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%7
grid . api . registerMethodsFromObject ( publicApi . methods )  ;%NWL%}  ,%NWL%defaultGridOptions : function ( gridOptions )  {%NWL%gridOptions . saveWidths = gridOptions . saveWidths ! =  = false ; %NWL%gridOptions . saveOrder = gridOptions . saveOrder ! =  = false ; %NWL%gridOptions . saveScroll = gridOptions . saveScroll =  =  = true ; %NWL%gridOptions . saveFocus = gridOptions . saveScroll ! =  = true && gridOptions . saveFocus ! =  = false ; %NWL%gridOptions . saveVisible = gridOptions . saveVisible ! =  = false ; %NWL%gridOptions . saveSort = gridOptions . saveSort ! =  = false ; %NWL%gridOptions . saveFilter = gridOptions . saveFilter ! =  = false ; %NWL%gridOptions . saveSelection = gridOptions . saveSelection ! =  = false ; %NWL%3
Utils . extend ( opts , defaults )  ; %NWL%this . opts = defaults ; %NWL%this . frames =  [  ]  ; %NWL%if ( this . firstTick =  = null )  {%NWL%this . firstTick = new Date (  )  ;%NWL%}%NWL%this . container = document . getElementById ( containerId )  ; %NWL%this . container . width =  ' 500 '  ; %NWL%this . container . height =  ' 105 '%NWL%this . width = this . container . width ; %NWL%this . height = this . container . height ; %NWL%9
function ignoreMap ( pattern )  {%NWL%var gmatcher = null%NWL%if ( pattern . slice (  - 3 )  =  =  =  '  "  + pattern%NWL%}%NWL%self . pattern = pattern%NWL%self . strict = options . strict ! =  = false%NWL%self . realpath = !!options . realpath%NWL%self . realpathCache = options . realpathCache || Object . create ( null )%NWL%self . follow = !!options . follow%NWL%self . dot = !!options . dot%NWL%self . mark = !!options . mark%NWL%6
}%NWL%this . tilesets . push ( instileset )  ;%NWL%}%NWL%var layers = map . getElementsByTagName (  ' layer '  )  ; %NWL%this . layers = new Array (  )  ; %NWL%for ( i = 0 ; i < layers . length ; i +  +  )  {%NWL%var inslayer = new Object (  )  ; %NWL%inslayer . properties = new Array (  )  ; %NWL%inslayer . name = layers [ i ]  . attributes . getNamedItem (  " name "  )  . nodeValue ; %NWL%inslayer . width = parseInt ( layers [ i ]  . attributes . getNamedItem (  " width "  )  . nodeValue )  ; %NWL%inslayer . height = parseInt ( layers [ i ]  . attributes . getNamedItem (  " height "  )  . nodeValue )  ; %NWL%9
this . context = params . context ; %NWL%this . centerX = params . centerX ; %NWL%this . centerY = params . centerY ; %NWL%this . arcWidth = params . arcWidth ; %NWL%this . innerRadius = params . innerRadius || 0 ; %NWL%this . fillColor = params . fillColor || ' #fff '  ; %NWL%this . outlineColor = params . outlineColor || this . fillColor ; %NWL%this . progressListener = params . progressListener ; %NWL%this . infoLineLength = params . infoLineLength || 250 ; %NWL%this . horizLineLength = params . horizLineLength || 50 ; %NWL%this . infoListener = params . infoListener ; %NWL%0
Family :  ' Jx . Splitter . Snap '  ,%NWL%snap : null ,%NWL%element : null ,%NWL%splitter : null ,%NWL%layout :  ' vertical '  ,%NWL%parameters :  [  ' snap '  ,  ' element '  ,  ' splitter '  ,  ' events '  ]  ,%NWL%init : function (  )  {%NWL%this . snap = this . options . snap ; %NWL%this . element = this . options . element ; %NWL%this . splitter = this . options . splitter ; %NWL%this . events = this . options . events ; %NWL%7
seriesStyles ,%NWL%seriesSize = 0 ,%NWL%offset = 0 ,%NWL%renderer ,%NWL%n = 0 ,%NWL%ys =  [  ]  ,%NWL%order = this . get (  " order "  )  ,%NWL%config ; %NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? styles : styles [ state ]  ; %NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ; %NWL%markerStyles . border . color = this . _getItemColor ( markerStyles . border . color , i )  ; %NWL%9
data . domain = WebInspector . displayNameForHost ( resource . urlComponents . host )  ; %NWL%data . scheme = resource . urlComponents . scheme ? resource . urlComponents . scheme . toUpperCase (  )  :  "  "  ; %NWL%data . method = resource . requestMethod ; %NWL%data . type = resource . type ; %NWL%data . statusCode = resource . statusCode ; %NWL%data . cached = resource . cached ; %NWL%data . size = resource . size ; %NWL%data . transferSize = resource . transferSize ; %NWL%data . requestSent = resource . requestSentTimestamp - zeroTime ; %NWL%data . duration = resource . receiveDuration ; %NWL%data . latency = resource . latency ; %NWL%3
var f = document . forms [ 0 ]  , nl = f . elements , ed = tinyMCEPopup . editor , dom = ed . dom , n = ed . selection . getNode (  )  ; %NWL%tinyMCEPopup . resizeToInnerSize (  )  ; %NWL%this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%8
dojo . declare (  " dojox . data . OpmlStore "  , null ,  {%NWL%constructor : function ( keywordParameters )  {%NWL%this . _xmlData = null ; %NWL%this . _arrayOfTopLevelItems =  [  ]  ; %NWL%this . _arrayOfAllItems =  [  ]  ; %NWL%this . _metadataNodes = null ; %NWL%this . _loadFinished = false ; %NWL%this . url = keywordParameters . url ; %NWL%this . _opmlData = keywordParameters . data ;  /  / XML DOM Document%NWL%if ( keywordParameters . label )  {%NWL%this . label = keywordParameters . label ; %NWL%7
var j$ =  {  }  ; %NWL%jRequire . base ( j$ , jasmineGlobal )  ; %NWL%j$ . util = jRequire . util (  )  ; %NWL%j$ . errors = jRequire . errors (  )  ; %NWL%j$ . Any = jRequire . Any ( j$ )  ; %NWL%j$ . Anything = jRequire . Anything ( j$ )  ; %NWL%j$ . CallTracker = jRequire . CallTracker (  )  ; %NWL%j$ . MockDate = jRequire . MockDate (  )  ; %NWL%j$ . Clock = jRequire . Clock (  )  ; %NWL%j$ . DelayedFunctionScheduler = jRequire . DelayedFunctionScheduler (  )  ; %NWL%j$ . Env = jRequire . Env ( j$ )  ; %NWL%4
bulletHTML :  '  < ul class =  " orbit - bullets "  >  <  / ul >  '  ,%NWL%init : function ( element , options )  {%NWL%var $imageSlides ,%NWL%imagesLoadedCount = 0 ,%NWL%self = this ; %NWL%this . clickTimer = $ . proxy ( this . clickTimer , this )  ; %NWL%this . addBullet = $ . proxy ( this . addBullet , this )  ; %NWL%this . resetAndUnlock = $ . proxy ( this . resetAndUnlock , this )  ; %NWL%this . stopClock = $ . proxy ( this . stopClock , this )  ; %NWL%this . startTimerAfterMouseLeave = $ . proxy ( this . startTimerAfterMouseLeave , this )  ; %NWL%this . clearClockMouseLeaveTimer = $ . proxy ( this . clearClockMouseLeaveTimer , this )  ; %NWL%5
" cerebral / lib / Backbone "%NWL%]  ,%NWL%function ( $ , _ , Backbone )  {%NWL%function Module ( attributes )  {%NWL%if ( !attributes [  ' name '  ] ||%NWL%!attributes [  ' root '  ]  )  {%NWL%throw new TypeError (  ' Module attributes must contain name and root '  )%NWL%}%NWL%attributes = _ . extend (  {  }  , attributes )%NWL%this . name = attributes [  ' name '  ]%NWL%this . root = attributes [  ' root '  ]%NWL%9
var i = 0 ; %NWL%var id = 0 ; %NWL%while ( i < numRows )%NWL%{%NWL%var row = rows [ i ]  ; %NWL%var newRow = new Object (  )  ; %NWL%newRow . ds_RowID = id +  +  ; %NWL%this . data . push ( newRow )  ; %NWL%this . dataHash [ newRow . ds_RowID ]  = newRow ; %NWL%newRow . ds_PageNumber = row . ds_PageNumber ; %NWL%newRow . ds_PageSize = row . ds_PageSize ; %NWL%9
}  ,%NWL%move : function ( x , y )  {%NWL%var change = this . getArgs ( x , y )  ; %NWL%this . x +  = change . x ; %NWL%this . y +  = change . y ; %NWL%return this ;%NWL%}  ,%NWL%moveTo : function ( x , y )  {%NWL%var pos = this . getArgs ( x , y , this . x , this . y )  ; %NWL%this . x = pos . x ; %NWL%this . y = pos . y ; %NWL%9
for ( var docName in queues )%NWL%{%NWL%count +  +  ;%NWL%}%NWL%return count +  ' share ( s )  '  + this . clientCount +  ' client ( s )  '  ;%NWL%}  ; %NWL%events = new Events ( this )  ; %NWL%this . listen = events . listen ; %NWL%this . removeListener = events . removeListener ; %NWL%this . hasListeners = events . hasListeners ; %NWL%this . listenFromVersion = events . listenFromVersion ; %NWL%7
sensorDefinitions . goLinkCO2 . sensorName = i18n . t (  " sensor . names . goLinkCO2 "  )  ; %NWL%sensorDefinitions . goLinkO2 . measurementName = i18n . t (  " sensor . measurements . O2_concentration "  )  ; %NWL%sensorDefinitions . goLinkO2 . sensorName = i18n . t (  " sensor . names . goLinkO2 "  )  ; %NWL%sensorDefinitions . labQuestMotion . measurementName = i18n . t (  " sensor . measurements . distance "  )  ; %NWL%sensorDefinitions . labQuestMotion . sensorName = i18n . t (  " sensor . names . labQuestMotion "  )  ; %NWL%sensorDefinitions . labQuestTemperature . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . labQuestTemperature . sensorName = i18n . t (  " sensor . names . labQuestTemperature "  )  ; %NWL%sensorDefinitions . labQuestLight . measurementName = i18n . t (  " sensor . measurements . light_intensity "  )  ; %NWL%sensorDefinitions . labQuestLight . sensorName = i18n . t (  " sensor . names . labQuestLight "  )  ; %NWL%sensorDefinitions . labQuestForce . measurementName = i18n . t (  " sensor . measurements . force "  )  ; %NWL%sensorDefinitions . labQuestForce . sensorName = i18n . t (  " sensor . names . labQuestForce "  )  ; %NWL%0
}  ; %NWL%outerElement . remove = outerElement . remove . bind ( outerElement )  ; %NWL%outerElement . clear = function (  )  {%NWL%this . insidePanel . innerHTML =  "  "  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . clear = outerElement . clear . bind ( outerElement )  ; %NWL%outerElement . getItems = function (  )  {%NWL%return this . querySelectorAll (  '  [ data - bb - type = item ]  '  )  ;%NWL%}  ; %NWL%outerElement . getItems = outerElement . getItems . bind ( outerElement )  ; %NWL%1
\n\%NWL%vec3 normalEC ; \n\%NWL%#ifdef FACE_FORWARD\n\%NWL%normalEC = normalize ( faceforward ( v_normalEC , vec3 ( 0 . 0 , 0 . 0 , 1 . 0 )  ,  - v_normalEC )  )  ; \n\%NWL%#else\n\%NWL%normalEC = normalize ( v_normalEC )  ; \n\%NWL%#endif\n\%NWL%\n\%NWL%czm_materialInput materialInput ; \n\%NWL%materialInput . normalEC = normalEC ; \n\%NWL%materialInput . positionToEyeEC = positionToEyeEC ; \n\%NWL%9
}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . getElementById (  " imageform "  )  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%img . hspace = f . hspace . value ; %NWL%img . vspace = f . vspace . value ; %NWL%7
d . top = this . originalTop - topd +  ' px '  ;%NWL%}%NWL%if ( this . options . scaleX )  {%NWL%d . left = this . originalLeft - leftd +  ' px '  ;%NWL%}%NWL%} else {%NWL%if ( this . options . scaleY )  {%NWL%d . top =  - topd +  ' px '  ;%NWL%}%NWL%if ( this . options . scaleX )  {%NWL%d . left =  - leftd +  ' px '  ; %NWL%7
tagName :  ' div '  ,%NWL%defaultValue :  '  '  ,%NWL%initialize : function ( options )  {%NWL%var editor = this ; %NWL%var options = options || {  }  ; %NWL%if ( options . model )  {%NWL%if ( !options . key ) throw " Missing option :  ' key '  "  ; %NWL%this . model = options . model ; %NWL%this . value = this . model . get ( options . key )  ;%NWL%} else if ( options . value )  {%NWL%this . value = options . value ; %NWL%7
BoxItem . prototype . redraw = function (  )  {%NWL%var dom = this . dom ; %NWL%if ( !dom )  {%NWL%this . dom =  {  }  ; %NWL%dom = this . dom ; %NWL%dom . box = document . createElement (  ' DIV '  )  ; %NWL%dom . content = document . createElement (  ' DIV '  )  ; %NWL%dom . content . className =  ' content '  ; %NWL%dom . box . appendChild ( dom . content )  ; %NWL%dom . line = document . createElement (  ' DIV '  )  ; %NWL%dom . line . className =  ' line '  ; %NWL%7
internals . Reply . prototype . interface = function ( request , realm , next )  {    /  / next ( err || response , data )  ; %NWL%var reply = function ( err , response , data )  {%NWL%reply . _data = data ;      /  / Held for later%NWL%return reply . response ( err ! =  = null && err ! =  = undefined ? err : response )  ;%NWL%}  ; %NWL%reply . _replied = false ; %NWL%reply . _next = Hoek . once ( next )  ; %NWL%reply . realm = realm ; %NWL%reply . request = request ; %NWL%reply . response = internals . response ; %NWL%reply . close = internals . close ; %NWL%9
lodash . forOwnRight = objects . forOwnRight ; %NWL%lodash . functions = objects . functions ; %NWL%lodash . groupBy = collections . groupBy ; %NWL%lodash . indexBy = collections . indexBy ; %NWL%lodash . initial = arrays . initial ; %NWL%lodash . intersection = arrays . intersection ; %NWL%lodash . invert = objects . invert ; %NWL%lodash . invoke = collections . invoke ; %NWL%lodash . keys = objects . keys ; %NWL%lodash . map = collections . map ; %NWL%lodash . mapValues = objects . mapValues ; %NWL%0
_ajax (  {%NWL%global : false ,%NWL%url : mockHandler . proxy ,%NWL%type : mockHandler . proxyType ,%NWL%data : mockHandler . data ,%NWL%dataType : requestSettings . dataType =  =  =  " script " ? " text / plain "  : requestSettings . dataType ,%NWL%complete : function ( xhr , txt )  {%NWL%mockHandler . responseXML = xhr . responseXML ; %NWL%mockHandler . responseText = xhr . responseText ; %NWL%mockHandler . status = xhr . status ; %NWL%mockHandler . statusText = xhr . statusText ; %NWL%7
nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%0
}%NWL%_ . addClass ( elem ,  " dk - option - selected "  )  ; %NWL%elem . setAttribute (  " aria - selected "  ,  " true "  )  ; %NWL%combobox . setAttribute (  " aria - activedescendant "  , elem . id )  ; %NWL%combobox . className =  " dk - selected "  + option . className ; %NWL%combobox . innerHTML = option . text ; %NWL%this . selectedOptions [ 0 ]  = elem ; %NWL%option . selected = true ;%NWL%}%NWL%this . selectedIndex = select . selectedIndex ; %NWL%this . value = select . value ; %NWL%9
return callback ( e , results )  ;%NWL%}%NWL%if ( rs )  {%NWL%var csses = rs . csses . map ( function ( css )  {%NWL%var data =  {  }  ; %NWL%data . name = css . name ; %NWL%data . url = css . name ; %NWL%if ( css . err )  {%NWL%data . err = css . err ; %NWL%data . error = css . error ; %NWL%data . msg = css . msg ; %NWL%5
OO . ui . BookletLayout . super . call ( this , config )  ; %NWL%this . currentPageName = null ; %NWL%this . pages =  {  }  ; %NWL%this . ignoreFocus = false ; %NWL%this . stackLayout = new OO . ui . StackLayout (  { continuous : !!config . continuous }  )  ; %NWL%this . $content . append ( this . stackLayout . $element )  ; %NWL%this . autoFocus = config . autoFocus =  =  = undefined || !!config . autoFocus ; %NWL%this . outlineVisible = false ; %NWL%this . outlined = !!config . outlined ; %NWL%if ( this . outlined )  {%NWL%this . editable = !!config . editable ; %NWL%8
this . height = this . _oElement . height ; %NWL%if ( showPolaroidFooter )  {%NWL%this . currentBorder = this . borderwidth ; %NWL%this . width +  =  ( 2 * this . currentBorder )  ; %NWL%this . height +  = this . currentBorder + this . polaroidheight ;%NWL%}%NWL%this . setImageCoords (  )  ;%NWL%}  ; %NWL%Canvas . Img . prototype . setImageCoords = function (  )  {%NWL%this . left = parseInt ( this . left )  ; %NWL%this . top = parseInt ( this . top )  ; %NWL%9
if ( data . body )  {%NWL%parameters . body = data . body ;%NWL%}%NWL%break ; %NWL%case " address "  : %NWL%parameters . name = data . name ; %NWL%parameters . address = data . address ; %NWL%break ; %NWL%case " list "  : %NWL%parameters . title = data . title ; %NWL%parameters . items = data . items ; %NWL%1
defaultFunc . reset (  )  ;%NWL%} else {%NWL%hasOnePassingSelector = true ;%NWL%}%NWL%var rules = this . rules ? this . rules . slice ( 0 )  : null ,%NWL%ruleset = new ( tree . Ruleset )  ( selectors , rules , this . strictImports )  ,%NWL%rule , subRule ; %NWL%ruleset . originalRuleset = this ; %NWL%ruleset . root = this . root ; %NWL%ruleset . firstRoot = this . firstRoot ; %NWL%ruleset . allowImports = this . allowImports ; %NWL%8
var ScreenTapGesture = function ( data )  {%NWL%this . position = data . position ; %NWL%this . direction = data . direction ; %NWL%this . progress = data . progress ;%NWL%}%NWL%ScreenTapGesture . prototype . toString = function (  )  {%NWL%return " ScreenTapGesture [  "  + JSON . stringify ( this )  +  "  ]  "  ;%NWL%}%NWL%var KeyTapGesture = function ( data )  {%NWL%this . position = data . position ; %NWL%this . direction = data . direction ; %NWL%1
_  = require (  ' underscore '  )  ; %NWL%var Flavor = exports . Flavor = function Flavor ( client , details )  {%NWL%base . Flavor . call ( this , client , details )  ;%NWL%}  ; %NWL%util . inherits ( Flavor , base . Flavor )  ; %NWL%Flavor . prototype . _setProperties = function ( details )  {%NWL%this . id  = details . id ; %NWL%this . name = details . name ; %NWL%this . ram  = details . ram ; %NWL%this . disk = details . disk ; %NWL%this . vcpus = details . vcpus ; %NWL%6
start : 0%NWL%}%NWL%}  ,%NWL%listeners :  {%NWL%load :  {%NWL%fn : function ( store , records , options )  {%NWL%var storeRecords = store . getRange (  )  ; %NWL%for ( var i = 0 ; i < storeRecords . length ; i +  +  )  {%NWL%var record = storeRecords [ i ]  . data ; %NWL%record . dependencies = Ext . util . Format . htmlEncode ( record . dependencies )  ; %NWL%record . description = Ext . util . Format . htmlEncode ( record . description )  ; %NWL%9
}  )  ;%NWL%}%NWL%if ( _ . isBlank ( req . body . surname )  )  {%NWL%return next (  {%NWL%message :  ' Last name was blank '  ,%NWL%param :  ' surname '%NWL%}  )  ;%NWL%}%NWL%user . email = req . body . email ; %NWL%user . name = req . body . name ; %NWL%user . surname = req . body . surname ; %NWL%8
var self = this ,%NWL%result ; %NWL%self . _row = pattern ; %NWL%result = self . _decode (  )  ; %NWL%if ( result =  =  = null )  {%NWL%self . _row . reverse (  )  ; %NWL%result = self . _decode (  )  ; %NWL%if ( result )  {%NWL%result . direction = BarcodeReader . DIRECTION . REVERSE ; %NWL%result . start = self . _row . length - result . start ; %NWL%result . end = self . _row . length - result . end ; %NWL%9
ui . $content . append ( ui . $pg )  ; %NWL%ui . $header . addClass (  ' hide '  )  ; %NWL%ui . $nav . addClass (  ' hide '  )  ; %NWL%ui . $pg . on (  ' submit . login '  , this . login )  ;%NWL%}  ,%NWL%login : function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var $form = $ ( e . target )%NWL%, data =  {  }  ; %NWL%data . user = $form . find (  ' input [ name = user ]  '  )  . val (  )  ; %NWL%data . pass = $form . find (  ' input [ name = pass ]  '  )  . val (  )  ; %NWL%9
Model . min = persistUtil . bind (  ' min '  , Model . min , Model )  ; %NWL%Model . max = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . max . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . max = persistUtil . bind (  ' max '  , Model . max , Model )  ; %NWL%Model . sum = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . sum . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . sum = persistUtil . bind (  ' sum '  , Model . sum , Model )  ; %NWL%0
this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertFailedScenario = function assertFailedScenario (  )  {%NWL%this . assertPartialOutput (  " 1 scenario (  "  + this . color . format (  " failed "  ,  " 1 failed "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertFailure (  )  ;%NWL%}  ; %NWL%proto . assertPendingScenario = function assertPendingScenario (  )  {%NWL%this . assertPartialOutput (  " 1 scenario (  "  + this . color . format (  " pending "  ,  " 1 pending "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertUndefinedScenario = function assertUndefinedScenario (  )  {%NWL%2
Model . last = persistUtil . bind (  ' last '  , Model . last , Model )  ; %NWL%Model . deleteAll = function ( connection , callback )  {%NWL%var query = this . using ( connection )  ; %NWL%return query . deleteAll . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . deleteAll = persistUtil . bind (  ' deleteAll '  , Model . deleteAll , Model )  ; %NWL%Model . min = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . min . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . min = persistUtil . bind (  ' min '  , Model . min , Model )  ; %NWL%0
async = require (  ' async '  )  ,%NWL%fs = require (  ' fs '  )  ,%NWL%fu = require (  '  .  / fileUtil '  )  ,%NWL%resources = require (  '  .  / util / resources '  )  ; %NWL%function Context ( options , config , plugins , libraries , event )  {%NWL%this . _package = options . package ; %NWL%this . _platform = options . platform ; %NWL%this . _plugins = plugins ; %NWL%this . mode = options . mode ; %NWL%this . module = options . module ; %NWL%this . fileConfig = options . fileConfig ; %NWL%8
SC . ListItemView = SC . ListItemView . extend (  {%NWL%deprecatedRenderWarning : function (  )  {  }%NWL%}  )  ; %NWL%SC . ExceptionHandler . enabled = true ; %NWL%SC . ExceptionHandler . handleException = function ( e )  {%NWL%console . log (  ' ERROR :  '  + e )  ;%NWL%}  ; %NWL%SC . MenuItemView = SC . MenuItemView . extend (  {%NWL%escapeHTML : NO%NWL%}  )  ; %NWL%SC . SelectButtonView = SC . SelectButtonView . extend (  {%NWL%0
if ( !isNaN ( e . theta ) && !isNaN ( e . phi ) && ( e . theta ! = hpl . theta || e . phi ! = hpl . phi )  )  {%NWL%hpl . theta = e . theta ; %NWL%hpl . phi = e . phi ; %NWL%hpl . update_convolver (  )  ;%NWL%}%NWL%}%NWL%var mouse_down = function ( e )  {%NWL%hpl . moving = false ;  /  / Interrupt automation%NWL%if ( !isNaN ( e . theta ) && !isNaN ( e . phi ) && ( e . theta ! = hpl . theta || e . phi ! = hpl . phi )  )  {%NWL%hpl . theta = e . theta ; %NWL%hpl . phi = e . phi ; %NWL%1
context . beginPath (  )  ; %NWL%context . rect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . clip (  )  ; %NWL%context . save (  )  ; %NWL%context . fillStyle = chartOptions . grid . fillStyle ; %NWL%context . clearRect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . fillRect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . restore (  )  ; %NWL%context . save (  )  ; %NWL%context . lineWidth = chartOptions . grid . lineWidth ; %NWL%context . strokeStyle = chartOptions . grid . strokeStyle ; %NWL%4
localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%addCustomOperation ( localElem )  ; %NWL%return onElemRestangularized ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%9
}%NWL%}%NWL%return target ;%NWL%}  ; %NWL%jQuery . extend (  {%NWL%noConflict : function ( deep )  {%NWL%if ( window . $ =  =  = jQuery )  {%NWL%window . $ = _$ ;%NWL%}%NWL%if ( deep && window . jQuery =  =  = jQuery )  {%NWL%window . jQuery = _jQuery ; %NWL%7
smooth :  ' smooth '%NWL%}  ,%NWL%updaters :  {%NWL%smooth : function ( attr )  {%NWL%var dataX = attr . dataX ,%NWL%dataY = attr . dataY ,%NWL%path ; %NWL%if ( attr . smooth && dataX && dataY && dataX . length > 2 && dataY . length > 2 )  {%NWL%path = Ext . draw . Draw . smooth ( dataX , dataY , 3 )  ; %NWL%this . smoothX = path . smoothX ; %NWL%this . smoothY = path . smoothY ; %NWL%9
if ( args . enableSharedNotebooks ! =  = undefined )  {%NWL%this . enableSharedNotebooks = args . enableSharedNotebooks ;%NWL%}%NWL%if ( args . enableSingleNoteSharing ! =  = undefined )  {%NWL%this . enableSingleNoteSharing = args . enableSingleNoteSharing ;%NWL%}%NWL%if ( args . enableSponsoredAccounts ! =  = undefined )  {%NWL%this . enableSponsoredAccounts = args . enableSponsoredAccounts ;%NWL%}%NWL%if ( args . enableTwitterSharing ! =  = undefined )  {%NWL%this . enableTwitterSharing = args . enableTwitterSharing ; %NWL%1
el . onmousewheel = function ( e )  {%NWL%if ( e . wheelDeltaY > 0 )  {%NWL%map . zoom ( map . zoom (  )  + 0 . 3 )  ;%NWL%} else {%NWL%map . zoom ( map . zoom (  )  - 0 . 3 )  ;%NWL%}%NWL%}%NWL%drag . on (  ' move '  , function ( dx , dy )  {%NWL%var s = 1 . 0 / Math . pow ( 2 , zoom )  ; %NWL%target_center . x = drag_init . x + dx * s ; %NWL%target_center . y = drag_init . y + dy * s ; %NWL%9
assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%if ( actual ! =  = expected )  {%NWL%fail ( actual , expected , message ,  '  =  =  =  '  , assert . strictEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . notStrictEqual = function notStrictEqual ( actual , expected , message )  {%NWL%0
var state = this . _getState ( type )  ,%NWL%ycoords = this . get (  " ycoords "  )  ,%NWL%marker = this . _markers [ i ]  ,%NWL%styles = this . get (  " styles "  )  . marker ,%NWL%h = styles . height ,%NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? this . _copyObject ( styles )  : this . _copyObject ( styles [ state ]  )  ,%NWL%fillColor ,%NWL%borderColor ; %NWL%markerStyles . y =  ( ycoords [ i ]  - h / 2 )  ; %NWL%markerStyles . x = marker . get (  " x "  )  ; %NWL%markerStyles . width = marker . get (  " width "  )  ; %NWL%9
checkPropTypes (%NWL%name ,%NWL%contextTypes ,%NWL%descriptor . _context ,%NWL%ReactPropTypeLocations . context%NWL%)  ;%NWL%}%NWL%return descriptor ;%NWL%}  ; %NWL%validatedFactory . prototype = factory . prototype ; %NWL%validatedFactory . type = factory . type ; %NWL%9
exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%0
var api = exports ; %NWL%api . Triple = require (  '  .  / RDFNode . js '  )  . Triple ; %NWL%api . RDFNode = require (  "  .  / RDFNode . js "  )  . RDFNode ; %NWL%api . NamedNode = require (  "  .  / RDFNode . js "  )  . NamedNode ; %NWL%api . BlankNode = require (  "  .  / RDFNode . js "  )  . BlankNode ; %NWL%api . Literal = require (  "  .  / RDFNode . js "  )  . Literal ; %NWL%api . Profile = require (  '  .  / Profile . js '  )  . Profile ; %NWL%api . RDFEnvironment = require (  '  .  / RDFEnvironment . js '  )  . RDFEnvironment ; %NWL%api . TurtleParser = require (  '  .  / TurtleParser . js '  )  . Turtle ; %NWL%api . DataSerializer = function (  )  {  }%NWL%api . Graph = require (  "  .  / Graph . js "  )  . Graph ; %NWL%2
exports . rescrop = function ( options )  {%NWL%var deferred = Q . defer (  )  ; %NWL%function imgResCrop (  )  {%NWL%if ( options . src =  =  = undefined || options . dst =  =  = undefined ) return deferred . reject ( error_messages [  ' path '  ]  )  ; %NWL%if ( options . width =  =  = undefined ) return deferred . reject ( error_messages [  ' dim '  ]  )  ; %NWL%options . height = options . height || options . width ; %NWL%options . cropwidth = options . cropwidth || options . width ; %NWL%options . cropheight = options . cropheight || options . height ; %NWL%options . gravity = options . gravity || ' Center '  ; %NWL%options . x = options . x || 0 ; %NWL%options . y = options . y || 0 ; %NWL%9
else {%NWL%if ( shift_nums [ character ] && e . shiftKey )  {  /  / Stupid Shift key bug created by using lowercase%NWL%character = shift_nums [ character ]  ; %NWL%if ( character =  = k ) kp +  +  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( kp =  = keys . length &&%NWL%modifiers . ctrl . pressed =  = modifiers . ctrl . wanted &&%NWL%modifiers . shift . pressed =  = modifiers . shift . wanted &&%NWL%9
' click . response_hider '   :  ' hideResponse '  ,%NWL%' click . toggleOperation '  :  ' toggleOperationContent '  ,%NWL%' mouseenter . api - ic '   :  ' mouseEnter '  ,%NWL%' mouseout . api - ic '    :  ' mouseExit '  ,%NWL%}  ,%NWL%initialize : function ( opts )  {%NWL%opts = opts || {  }  ; %NWL%this . router = opts . router ; %NWL%this . auths = opts . auths ; %NWL%this . parentId = this . model . parentId ; %NWL%this . nickname = this . model . nickname ; %NWL%9
list [ name ]  = value ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( !to_form )  {%NWL%data . type = get (  ' media_type '  )  . options [ get (  ' media_type '  )  . selectedIndex ]  . value ; %NWL%data . width = getVal (  ' width '  )  ; %NWL%data . height = getVal (  ' height '  )  ; %NWL%9
return this ;%NWL%}  ; %NWL%proto . set = function ( aabb )  {%NWL%this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%this . width  = aabb . width ; %NWL%this . height = aabb . height ; %NWL%this . halfWidth = aabb . halfWidth ; %NWL%this . halfHeight = aabb . halfHeight ; %NWL%this . left = aabb . left ; %NWL%3
var preloadImg = new Image (  )  ; %NWL%function resetImageData (  )  {%NWL%var formObj = document . forms [ 0 ]  ; %NWL%formObj . width . value = formObj . height . value =  "  "  ;%NWL%}%NWL%function updateImageData (  )  {%NWL%var formObj = document . forms [ 0 ]  ; %NWL%if ( formObj . width . value =  =  "  "  )%NWL%formObj . width . value = preloadImg . width ; %NWL%if ( formObj . height . value =  =  "  "  )%NWL%formObj . height . value = preloadImg . height ; %NWL%8
var replaceEl = this . getElement ( id )  ; %NWL%if ( ! replaceEl )  {%NWL%log ( WARN ,  ' Got unknown element in update :  '  , id )  ; %NWL%continue ;%NWL%}%NWL%this . setElement ( replaceEl , updates [ id ]  )  ;%NWL%}%NWL%}  ,%NWL%processRange : function ( range )  {%NWL%range . start = this . getElement ( command . range . start )  ; %NWL%range . end = this . getElement ( command . range . end )  ; %NWL%9
this . interval = options [  ' interval '  ]  ; %NWL%this . lineWidth = options [  ' lineWidth '  ]  ; %NWL%this . strokeStyle = options [  ' strokeStyle '  ]  ; %NWL%this . fillStyle = options [  ' fillStyle '  ]  ; %NWL%this . gridcolor = options [  ' gridcolor '  ]  ; %NWL%this . background = options [  ' background '  ]  ; %NWL%this . showdots = options [  ' showdots '  ]  ; %NWL%this . showshadow = options [  ' showshadow '  ]  ; %NWL%this . showgrid = options [  ' showgrid '  ]  ; %NWL%this . showline = options [  ' showline '  ]  ; %NWL%this . showfill = options [  ' showfill '  ]  ; %NWL%0
log . warn (  ' %s is not supported anymore . \n Please use `karma . %s` instead .  '  , name , name )  ; %NWL%return constant [ name ]  ;%NWL%}  }  )  ;%NWL%}  )  ; %NWL%var Config = function (  )  {%NWL%var config = this ; %NWL%this . LOG_DISABLE = constant . LOG_DISABLE ; %NWL%this . LOG_ERROR = constant . LOG_ERROR ; %NWL%this . LOG_WARN = constant . LOG_WARN ; %NWL%this . LOG_INFO = constant . LOG_INFO ; %NWL%this . LOG_DEBUG = constant . LOG_DEBUG ; %NWL%6
}%NWL%if ( options . my [ 1 ]  =  =  =  " bottom "  )  {%NWL%position . top -  = elemHeight ;%NWL%} else if ( options . my [ 1 ]  =  =  =  " center "  )  {%NWL%position . top -  = elemHeight / 2 ;%NWL%}%NWL%position . left +  = myOffset [ 0 ]  ; %NWL%position . top +  = myOffset [ 1 ]  ; %NWL%if ( !$ . support . offsetFractions )  {%NWL%position . left = round ( position . left )  ; %NWL%position . top = round ( position . top )  ; %NWL%9
r . count = node . count ;%NWL%} else {%NWL%r = this . getMinNode_ ( node . right )  ; %NWL%this . traverse_ ( function ( node )  {%NWL%node . count -  -  ; %NWL%return node . parent ;%NWL%}  , r )  ; %NWL%if ( r ! = node . right )  {%NWL%r . parent . left = r . right ; %NWL%if ( r . right ) r . right . parent = r . parent ; %NWL%r . right = node . right ; %NWL%0
translateBy : function ( offset )  {%NWL%this . left +  = offset . x ; %NWL%this . right +  = offset . x ; %NWL%this . top +  = offset . y ; %NWL%this . bottom +  = offset . y ; %NWL%return this ;%NWL%}  ,%NWL%round : function (  )  {%NWL%this . top = Math . round ( this . top )  ; %NWL%this . right = Math . round ( this . right )  ; %NWL%this . bottom = Math . round ( this . bottom )  ; %NWL%8
return declare (  " dojox . data . FileStore "  , null ,  {%NWL%constructor : function ( args )  {%NWL%if ( args && args . label )  {%NWL%this . label = args . label ;%NWL%}%NWL%if ( args && args . url )  {%NWL%this . url = args . url ;%NWL%}%NWL%if ( args && args . options )  {%NWL%if ( lang . isArray ( args . options )  )  {%NWL%this . options = args . options ; %NWL%3
}%NWL%if ( typeof props =  =  =  " string "  )  {%NWL%props =  { path : props }%NWL%}%NWL%props . ignoreFiles =  [  "  . jamignore "  ,%NWL%"  . gitignore "  ,%NWL%" package . json "  ]%NWL%Ignore . call ( this , props )%NWL%this . bundled = props . bundled%NWL%this . bundleLinks = props . bundleLinks%NWL%this . package = props . package%NWL%8
angle = percentage * maxDegrees ; %NWL%options . startAngle = lastAngle ; %NWL%options . endAngle = lastAngle + angle ; %NWL%options . fillColor = chartOption . fillColor ; %NWL%options . color = chartOption . color || ' #000 '  ; %NWL%options . radiusX = this . options . radiusX || this . options . radius ; %NWL%options . radiusY = this . options . radiusY || this . options . radius ; %NWL%options . rotation = 0 ; %NWL%options . key = key ; %NWL%options . value = value ; %NWL%options . displayName = chartOption . displayName ; %NWL%3
}%NWL%}  ; %NWL%Y . EventFacade = function ( e , currentTarget )  {%NWL%if ( !e )  {%NWL%e = EMPTY ;%NWL%}%NWL%this . _event = e ; %NWL%this . details = e . details ; %NWL%this . type = e . type ; %NWL%this . _type = e . type ; %NWL%this . target = e . target ; %NWL%7
function normalizeTolerance ( t )  {%NWL%return t =  =  = Object ( t ) ? t :  { down : t , up : t }  ;%NWL%}%NWL%function Headroom ( elem , options )  {%NWL%options = extend ( options , Headroom . options )  ; %NWL%this . lastKnownScrollY = 0 ; %NWL%this . elem    = elem ; %NWL%this . debouncer   = new Debouncer ( this . update . bind ( this )  )  ; %NWL%this . tolerance   = normalizeTolerance ( options . tolerance )  ; %NWL%this . classes    = options . classes ; %NWL%this . offset    = options . offset ; %NWL%9
goog . dom . TextRange . prototype . browserRangeWrapper_ = null ; %NWL%goog . dom . TextRange . prototype . startNode_ = null ; %NWL%goog . dom . TextRange . prototype . startOffset_ = null ; %NWL%goog . dom . TextRange . prototype . endNode_ = null ; %NWL%goog . dom . TextRange . prototype . endOffset_ = null ; %NWL%goog . dom . TextRange . prototype . isReversed_ = false ; %NWL%goog . dom . TextRange . prototype . clone = function (  )  {%NWL%var range = new goog . dom . TextRange (  )  ; %NWL%range . browserRangeWrapper_ = this . browserRangeWrapper_ ; %NWL%range . startNode_ = this . startNode_ ; %NWL%range . startOffset_ = this . startOffset_ ; %NWL%8
} else if ( typeof key =  =  ' string '  )  {%NWL%return settings [ key ]  ;%NWL%}%NWL%if ( settings . minTime )  {%NWL%settings . minTime = _time2int ( settings . minTime )  ;%NWL%}%NWL%if ( settings . maxTime )  {%NWL%settings . maxTime = _time2int ( settings . maxTime )  ;%NWL%}%NWL%if ( settings . durationTime )  {%NWL%settings . durationTime = _time2int ( settings . durationTime )  ; %NWL%4
function Track ( opt , timeline )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . timeline = timeline ; %NWL%this . _selectors =  [  ]  ; %NWL%this . _endParams =  [  ]  ; %NWL%this . _selectedElems =  [  ]  ; %NWL%this . _isHidingSelectedElems = false ; %NWL%this . _isPlaying = false ; %NWL%if ( !this . _paramFactory ) this . _paramFactory = new ParamFactory (  {  }  , this . timeline )  ; %NWL%this . _onSelectClick = this . _onSelectClick . bind ( this )  ; %NWL%this . _onChangeSelectors = this . _onChangeSelectors . bind ( this )  ; %NWL%9
}%NWL%}  )  ; %NWL%exports . getInnerId = deprecateFunction ( getInnerId ,%NWL%' require (  " window - utils "  )  . getInnerId is deprecated ,  '  +%NWL%' please use require (  " sdk / window / utils "  )  . getInnerId instead '%NWL%)  ; %NWL%exports . getOuterId = deprecateFunction ( getOuterId ,%NWL%' require (  " window - utils "  )  . getOuterId is deprecated ,  '  +%NWL%' please use require (  " sdk / window / utils "  )  . getOuterId instead '%NWL%)  ; %NWL%exports . isBrowser = deprecateFunction ( isBrowser ,%NWL%2
lodash . forEachRight = collections . forEachRight ; %NWL%lodash . forIn = objects . forIn ; %NWL%lodash . forInRight = objects . forInRight ; %NWL%lodash . forOwn = forOwn ; %NWL%lodash . forOwnRight = objects . forOwnRight ; %NWL%lodash . functions = objects . functions ; %NWL%lodash . groupBy = collections . groupBy ; %NWL%lodash . indexBy = collections . indexBy ; %NWL%lodash . initial = arrays . initial ; %NWL%lodash . intersection = arrays . intersection ; %NWL%lodash . invert = objects . invert ; %NWL%1
this . radial . x -  = this . radial . box . bounds . width / 2 ; %NWL%this . radial . y -  = this . radial . box . bounds . height / 1 . 5 ; %NWL%this . madeWith . scaleX = this . scaled ; %NWL%this . madeWith . scaleY = this . scaled ; %NWL%this . madeWith . rotPointX = 0 ; %NWL%this . madeWith . rotPointY = 0 ; %NWL%this . madeWith . x -  = this . madeWith . box . bounds . width / 2 ; %NWL%this . madeWith . y -  = this . madeWith . box . bounds . height * 2 ; %NWL%this . kiwijsLogo . scaleX = this . scaled ; %NWL%this . kiwijsLogo . scaleY = this . scaled ; %NWL%this . kiwijsLogo . x -  = this . kiwijsLogo . box . bounds . width / 2 ; %NWL%0
}  ;%NWL%}  ,%NWL%Fetch : function ( callback )  {%NWL%this . callback = callback ; %NWL%this . init (  )  ; %NWL%return this ;%NWL%}  ,%NWL%Store : function ( config )  {%NWL%this . audioBlob = config . audioBlob ; %NWL%this . videoBlob = config . videoBlob ; %NWL%this . gifBlob = config . gifBlob ; %NWL%8
}%NWL%function updateLine ( diff_x , diff_y )  {%NWL%var i = connections . length ; %NWL%while ( i -  -  )  {%NWL%var conn = connections [ i ]  ; %NWL%var line = conn . connector ; %NWL%var elem = conn . elem ; %NWL%var pre = conn . is_start? ' start '  :  ' end '  ; %NWL%var bb = $ ( line )  . data ( pre +  ' _bb '  )  ; %NWL%bb . x = conn . start_x + diff_x ; %NWL%bb . y = conn . start_y + diff_y ; %NWL%9
this . bounds . intersectsBounds ( maxExtent , false )  )  ; %NWL%this . shouldDraw =  ( withinMaxExtent || this . layer . displayOutsideMaxExtent )  ; %NWL%this . clear (  )  ; %NWL%return this . shouldDraw ;%NWL%}  ,%NWL%moveTo : function ( bounds , position , redraw )  {%NWL%if ( redraw =  = null )  {%NWL%redraw = true ;%NWL%}%NWL%this . bounds = bounds . clone (  )  ; %NWL%this . position = position . clone (  )  ; %NWL%9
this . window = window || 0 ; %NWL%this . colormap = colormap || 0 ; %NWL%this . white = white || 0 ; %NWL%this . black = black || 0 ; %NWL%this . current_input_masks = current_input_masks || 0 ; %NWL%this . height_px = height_px || 0 ; %NWL%this . width_px = width_px || 0 ; %NWL%this . height_mm = height_mm || 0 ; %NWL%this . width_mm = width_mm || 0 ; %NWL%this . maps_min = maps_min || 0 ; %NWL%this . maps_max = maps_max || 0 ; %NWL%0
} else {%NWL%_p . selectionType =  ' single '  ;%NWL%}%NWL%} else {%NWL%_p . selectionType = selType ;%NWL%}%NWL%if ( $$ . is . number ( options . minZoom ) && $$ . is . number ( options . maxZoom ) && options . minZoom < options . maxZoom )  {%NWL%_p . minZoom = options . minZoom ; %NWL%_p . maxZoom = options . maxZoom ;%NWL%} else if ( $$ . is . number ( options . minZoom ) && options . maxZoom =  =  = undefined )  {%NWL%_p . minZoom = options . minZoom ; %NWL%8
targetAttachment :  ' auto auto '%NWL%}  ; %NWL%this . options = $ . extend ( defaults , this . options )  ; %NWL%_ref = this . options , this . element = _ref . element , this . target = _ref . target ; %NWL%if ( this . element . jquery )  {%NWL%this . $element = this . element ; %NWL%this . element = this . element [ 0 ]  ;%NWL%}%NWL%if ( this . target . jquery )  {%NWL%this . $target = this . target ; %NWL%this . target = this . target [ 0 ]  ; %NWL%6
options . name = options . title ;%NWL%} else {%NWL%options . name = FileUtils . getFilenameWithoutExtension ( fileName )  . replace (  / \ . min$ /  ,  "  "  )  ;%NWL%}%NWL%options . name = options . name . toLocaleLowerCase (  )  . replace (  /  [ \W ]  / g ,  '  -  '  )  ;%NWL%}%NWL%this . file    = file ; %NWL%this . name    = options . name ; %NWL%this . displayName  = options . title || toDisplayName ( fileName )  ; %NWL%this . dark    = options . theme ! =  = undefined && options . theme . dark =  =  = true ; %NWL%this . addModeClass  = options . theme ! =  = undefined && options . theme . addModeClass =  =  = true ; %NWL%9
self . realpathCache = options . realpathCache || Object . create ( null )%NWL%self . follow = !!options . follow%NWL%self . dot = !!options . dot%NWL%self . mark = !!options . mark%NWL%self . nodir = !!options . nodir%NWL%if ( self . nodir )%NWL%self . mark = true%NWL%self . sync = !!options . sync%NWL%self . nounique = !!options . nounique%NWL%self . nonull = !!options . nonull%NWL%self . nosort = !!options . nosort%NWL%1
var i = args . object . indexOf (  '  .  '  )  ; %NWL%if ( i < 0 )  {%NWL%args . object = dojox . wire . ml . _getValue ( args . object )  ;%NWL%} else {%NWL%args . property = args . object . substring ( i + 1 )  ; %NWL%args . object = dojox . wire . ml . _getValue ( args . object . substring ( 0 , i )  )  ;%NWL%}%NWL%}%NWL%}%NWL%if ( args . dataStore )  {%NWL%args . dataStore = dojox . wire . ml . _getValue ( args . dataStore )  ; %NWL%2
_GP . components [ com ]  = new Glyph ( data . components [ com ]  )  ;%NWL%}%NWL%}%NWL%for ( var gl in data . glyphs )  {%NWL%if ( data . glyphs . hasOwnProperty ( gl )  )  {%NWL%_GP . glyphs [ gl ]  = new Glyph ( data . glyphs [ gl ]  )  ;%NWL%}%NWL%}%NWL%for ( var lig in data . ligatures )  {%NWL%if ( data . ligatures . hasOwnProperty ( lig )  )  {%NWL%_GP . ligatures [ lig ]  = new Glyph ( data . ligatures [ lig ]  )  ; %NWL%0
EventBus : EventBusOriginal ,%NWL%getOptions : function (  )  {%NWL%return angular . extend (  {  }  , options )  ;%NWL%}%NWL%}  ; %NWL%EventBusStub . reconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . reconnect "  ; %NWL%EventBusStub . close . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . close "  ; %NWL%EventBusStub . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . login "  ; %NWL%EventBusStub . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . send "  ; %NWL%EventBusStub . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . publish "  ; %NWL%EventBusStub . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . registerHandler "  ; %NWL%5
FormValidator . prototype . _validateForm = function ( evt )  {%NWL%this . errors =  [  ]  ; %NWL%for ( var key in this . fields )  {%NWL%if ( this . fields . hasOwnProperty ( key )  )  {%NWL%var field = this . fields [ key ] || {  }  ,%NWL%element = this . form [ field . name ]  ; %NWL%if ( element && element ! =  = undefined )  {%NWL%field . id = attributeValue ( element ,  ' id '  )  ; %NWL%field . element = element ; %NWL%field . type =  ( element . length > 0 ) ? element [ 0 ]  . type : element . type ; %NWL%field . value = attributeValue ( element ,  ' value '  )  ; %NWL%7
}%NWL%}%NWL%}  ; %NWL%function Draft ( opts )  {%NWL%var draft = opts || {  }  ; %NWL%if ( draft . id && typeof draft . id ! =  =  ' number '  )  {%NWL%throw new Error (  ' Draft id must be a number '  )  ;%NWL%}%NWL%this . id = draft . id || guid (  )  ; %NWL%this . recipients = draft . recipients || [  ]  ; %NWL%this . content = draft . content || [  ]  ; %NWL%9
Stream . call ( this )  ; %NWL%if ( !stream . _stackEmitter )  {%NWL%StackEmitter . call ( stream )  ;%NWL%}%NWL%stream . _stacks . push ( this )  ; %NWL%this . stream = stream ; %NWL%events = events || {  }  ; %NWL%if ( ! (  ' data ' in events )  )%NWL%events . data = proxyEvent (  ' data '  )  ; %NWL%if ( ! (  ' end ' in events )  )%NWL%events . end = proxyEvent (  ' end '  )  ; %NWL%8
if ( spec . hasOwnProperty ( key )  )  {%NWL%_UIObjectState . spec [ key ]  = spec [ key ]  ;%NWL%}%NWL%}%NWL%return _updateChildrenFromSpec ( false , true )  ;%NWL%}  ; %NWL%xfClusterInstance . restoreVisualState = function ( state )  {%NWL%this . cleanState (  )  ; %NWL%_UIObjectState . xfId = state . xfId ; %NWL%_UIObjectState . UIType = state . UIType ; %NWL%_UIObjectState . isExpanded = state . isExpanded ; %NWL%8
this . sy =  - this . sy ;%NWL%} else if ( this . y > Game . height )  {  /  / Bottom%NWL%this . sy = this . sx = 0 ; %NWL%this . y = this . x = 1000 ; %NWL%Screen . gameover (  )  ; %NWL%Game . canvas . addEventListener (  ' click '  , Game . restartGame , false )  ; %NWL%return ;%NWL%}%NWL%if ( this . x < 1 )  {%NWL%this . x = 1 ;  /  / Prevents the ball from getting stuck at fast speeds%NWL%this . sx =  - this . sx ; %NWL%0
}  ,  {%NWL%value :  ' uirouterModule '  ,%NWL%name :  ' angular - ui - router . js '  ,%NWL%checked : true%NWL%}  ]%NWL%}  ]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%var hasMod = function ( mod )  { return props . modules . indexOf ( mod ) ! =  =  - 1 ;  }  ; %NWL%this . resourceModule = hasMod (  ' resourceModule '  )  ; %NWL%this . cookiesModule = hasMod (  ' cookiesModule '  )  ; %NWL%this . sanitizeModule = hasMod (  ' sanitizeModule '  )  ; %NWL%8
encodeURIComponent ( href )  ,  ' # '  , callbackId ]  . join (  '  '  )  ; %NWL%var window = args . frame . contentWindow || args . frame ; %NWL%window . location = docUrl ;%NWL%}  ,%NWL%_loadATInFrameCb2 : function ( res , args )  {%NWL%var window = args . frame . contentWindow || args . frame ; %NWL%var document = window . document ; %NWL%var iFrameAria = window . Aria ; %NWL%iFrameAria . rootFolderPath = this . bootRootFolderPath ; %NWL%iFrameAria . debug = Aria . debug ; %NWL%iFrameAria . memCheckMode = Aria . memCheckMode ; %NWL%9
var monthes =  [ 0 , 31 , 59 , 90 , 120 , 151 , 181 , 212 , 243 , 273 , 304 , 334 , 365 ]  ; %NWL%function dayFromMonth ( year , month )  {%NWL%var t = month > 1 ? 1 : 0 ; %NWL%return monthes [ month ]  + Math . floor (  ( year - 1969 + t )  / 4 )  - Math . floor (  ( year - 1901 + t )  / 100 )  + Math . floor (  ( year - 1601 + t )  / 400 )  + 365 *  ( year - 1970 )  ;%NWL%}%NWL%for ( var key in NativeDate )  {%NWL%Date [ key ]  = NativeDate [ key ]  ;%NWL%}%NWL%Date . now = NativeDate . now ; %NWL%Date . UTC = NativeDate . UTC ; %NWL%Date . prototype = NativeDate . prototype ; %NWL%8
this . scrollBorder  =  { x : 0 , y : 0 }  ; %NWL%this . page    = 0 ; %NWL%this . preventScroll = false ; %NWL%this . pageCssProperties =  {%NWL%margin : 0%NWL%}  ; %NWL%this . _onStart = proxy ( this . _onStart , this )  ; %NWL%this . _onMove = proxy ( this . _onMove , this )  ; %NWL%this . _onEnd = proxy ( this . _onEnd , this )  ; %NWL%this . _onKeydown = proxy ( this . _onKeydown , this )  ; %NWL%this . _sizePages = proxy ( this . _sizePages , this )  ; %NWL%6
function save_prefs (  )  {%NWL%var prefs = conf . get_current_profile (  )  . preferences ; %NWL%prefs . lang = $ (  ' #sel_prefs_lang '  )  . val (  )  ; %NWL%prefs . theme = $ (  ' #sel_prefs_theme '  )  . val (  )  ; %NWL%prefs . theme_path = $ (  ' #sel_prefs_theme '  )  . children (  ' option [ value =  "  '  + $ (  ' #sel_prefs_theme '  )  . val (  )  +  '  "  ]  '  )  . attr (  ' path '  )  ; %NWL%prefs . custom_font = $ (  ' #tbox_prefs_custom_font '  )  . val (  )  ; %NWL%prefs . font_size = $ (  ' #range_prefs_font_size '  )  . val (  )  ; %NWL%if ( prefs . font_size =  =  =  '  '  )  {%NWL%prefs . font_size = 12 ;%NWL%}%NWL%prefs . line_height = $ (  ' #range_prefs_line_height '  )  . val (  )  ; %NWL%6
trigger : OpenLayers . Function . bind ( this . previousTrigger , this )  ,%NWL%displayClass : this . displayClass +  "  "  + this . displayClass +  " Previous "%NWL%}  ; %NWL%OpenLayers . Util . extend ( previousOptions , this . previousOptions )  ; %NWL%this . previous = new OpenLayers . Control . Button ( previousOptions )  ; %NWL%var nextOptions =  {%NWL%trigger : OpenLayers . Function . bind ( this . nextTrigger , this )  ,%NWL%displayClass : this . displayClass +  "  "  + this . displayClass +  " Next "%NWL%}  ; %NWL%OpenLayers . Util . extend ( nextOptions , this . nextOptions )  ; %NWL%this . next = new OpenLayers . Control . Button ( nextOptions )  ; %NWL%4
exports . AnonymousCloudCredentials = azureCommon . AnonymousCloudCredentials ; %NWL%exports . SharedAccessSignature = storage . SharedAccessSignature ; %NWL%exports . SharedKey = storage . SharedKey ; %NWL%exports . SharedKeyLite = storage . SharedKeyLite ; %NWL%exports . SharedKeyTable = storage . SharedKeyTable ; %NWL%exports . SharedKeyLiteTable = storage . SharedKeyLiteTable ; %NWL%exports . LinearRetryPolicyFilter = azureCommon . LinearRetryPolicyFilter ; %NWL%exports . ExponentialRetryPolicyFilter = azureCommon . ExponentialRetryPolicyFilter ; %NWL%exports . UserAgentFilter = azureCommon . UserAgentFilter ; %NWL%exports . ProxyFilter = azureCommon . ProxyFilter ; %NWL%exports . LogFilter = azureCommon . LogFilter ; %NWL%0
if ( typeof y =  =  =  ' undefined '  )  {%NWL%this . empty = true ;%NWL%} else {%NWL%this . top =  - this . halfHeight + this . y ; %NWL%this . bottom = this . halfHeight + this . y ;%NWL%}%NWL%return this ;%NWL%}  ; %NWL%proto . set = function ( aabb )  {%NWL%this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%9
var newPath = new an . Path (  )  ; %NWL%this . edges . forEach ( function ( edg )  {%NWL%newPath . addEdge ( edg . duplicate (  )  )  ;%NWL%}  )  ; %NWL%this . copyAttributes ( this , newPath )  ; %NWL%return newPath ;%NWL%}%NWL%self . prototype . copyAttributes = function ( from , to )  {%NWL%to . complete = from . complete ; %NWL%to . closePath = from . closePath ; %NWL%to . lineWidth = from . lineWidth ; %NWL%8
var Range = require (  "  .  / range "  )  . Range ; %NWL%function LineWidgets ( session )  {%NWL%this . session = session ; %NWL%this . session . widgetManager = this ; %NWL%this . session . getRowLength = this . getRowLength ; %NWL%this . session . $getWidgetScreenLength = this . $getWidgetScreenLength ; %NWL%this . updateOnChange = this . updateOnChange . bind ( this )  ; %NWL%this . renderWidgets = this . renderWidgets . bind ( this )  ; %NWL%this . measureWidgets = this . measureWidgets . bind ( this )  ; %NWL%this . session . _changedWidgets =  [  ]  ; %NWL%this . $onChangeEditor = this . $onChangeEditor . bind ( this )  ; %NWL%6
addCustomOperation ( localElem )  ; %NWL%return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . putElement = _ . bind ( putElementFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%7
suffix   : suffix ,%NWL%globalize  : globalize ,%NWL%cacheDns  : cacheDns ,%NWL%mock   : mock =  =  = true ,%NWL%global_tags : global_tags%NWL%}  ;%NWL%}%NWL%this . host   = options . host || ' localhost '  ; %NWL%this . port   = options . port || 8125 ; %NWL%this . prefix   = options . prefix || '  '  ; %NWL%this . suffix   = options . suffix || '  '  ; %NWL%9
this . mVB_Tex = g_mVB_Tex_font ; %NWL%this . mVB_Pos2 = g_mVB_Pos2_font ; %NWL%this . mVB_Tex2 = g_mVB_Tex2_font ; %NWL%this . mBufferVertices = 0 ;%NWL%}%NWL%this . addCharToBuffer  = function ( c , draw_x , draw_y )  { this . addCharToBufferS ( c , draw_x , draw_y , 1 , 1 )  ;  }%NWL%this . addCharToBufferS = function ( c , draw_x , draw_y , sx , sy )  {%NWL%var gi = this . getGlyphInfo ( c )  ; %NWL%if ( gi =  = null ) return ; %NWL%if ( this . mVB_Pos =  = null )  { MainPrint ( this . TAG ,  " addCharToBufferS : mVB_Pos = null "  )  ; return ;  }%NWL%if ( this . mVB_Tex =  = null )  { MainPrint ( this . TAG ,  " addCharToBufferS : mVB_Tex = null "  )  ; return ;  }%NWL%9
}  ; %NWL%return Proxy . prototype . sync . call ( this , method , options )  ;%NWL%}  ,%NWL%call : function ( fname , args , options )  {%NWL%Proxy . prototype . callSyncher . call ( this , fname , args , options )  ;%NWL%}  ,%NWL%_initialize : function ( attributes , options )  {%NWL%if ( options . name )  {%NWL%this . name = options . name ;%NWL%}%NWL%this . params = options . params ; %NWL%8
if ( typeof ( define ) ! =  =  " function "  )  {%NWL%var define = require (  " amdefine "  )  ( module )  ;%NWL%}%NWL%define (%NWL%function (  )  {%NWL%" use strict "  ; %NWL%var defineProperty = Object . defineProperty ; %NWL%function RectOffset ( left , right , top , bottom )  {%NWL%this . left = left || 0 . 0 ; %NWL%this . right = right || 0 . 0 ; %NWL%this . top = top || 0 . 0 ; %NWL%8
< i class =  " icon icon - share " style =  " cursor : pointer ;  "  >  <  / i >  <  / a >  '  ,  {%NWL%doctype : doctype ,%NWL%name : encodeURIComponent ( name )%NWL%}  )  ;%NWL%}  ,%NWL%make_date_range_columns : function (  )  {%NWL%this . columns =  [  ]  ; %NWL%var me = this ; %NWL%var range = this . filter_inputs . range . val (  )  ; %NWL%this . from_date = dateutil . user_to_str ( this . filter_inputs . from_date . val (  )  )  ; %NWL%this . to_date = dateutil . user_to_str ( this . filter_inputs . to_date . val (  )  )  ; %NWL%9
return this . className + uniqueId (  )  ;%NWL%}  ; %NWL%GuiCanvas . prototype . create = function ( src )  {%NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%this . contex = canvas . getContext (  " 2d "  )  ; %NWL%this . contex . imageSmoothingEnabled = false ; %NWL%this . contex . webkitImageSmoothingEnabled = false ; %NWL%this . contex . mozImageSmoothingEnabled = false ; %NWL%canvas . id = this . id ; %NWL%canvas . width = this . width ; %NWL%canvas . height = this . height ; %NWL%8
this . material = opts . material ! = undefined ? opts . material : undefined ; %NWL%this . positionSpread = opts . positionSpread ! = undefined ? opts . positionSpread : new Vec3 ( 0 . 5 , 0 . 5 , 0 . 5 )  ; %NWL%this . positionRadius = opts . positionRadius ! = undefined ? opts . positionRadius : 0 . 5 ; %NWL%this . speed = opts . speed ! = undefined ? opts . speed : 0 ; %NWL%this . speedSpread = opts . speedSpread ! = undefined ? opts . speedSpread : 0 ; %NWL%this . particleSystem = undefined ; %NWL%this . worldSpace = opts . worldSpace ! = undefined ? opts . worldSpace : true ; %NWL%this . position = opts . position ! = undefined ? opts . position : new Vec3 ; %NWL%this . minEmission = opts . minEmission ! = undefined ? opts . minEmission : 1 ; %NWL%this . maxEmission = opts . maxEmission ! = undefined ? opts . maxEmission : 2 ; %NWL%this . minLife = opts . minLife ! = undefined ? opts . minLife : 1 ; %NWL%8
}%NWL%}  ; %NWL%HiddenMeow . prototype . Meow_ToString = function (  )  {%NWL%return Meow_JSON . Meow_StringOps ( Meow_Power )  ;%NWL%}  ; %NWL%HiddenMeow . Meow_Create = function ( Meow_Data )  {%NWL%HiddenMeow1 = Meow_JSON . Meow_Parse ( Meow_Data )  ; %NWL%HiddenMeow2 = new HiddenMeow ( HiddenMeow1 . Meow_Nodes . length , HiddenMeow1 . Meow_Char )  ; %NWL%HiddenMeow2 . Meow_Nodes = HiddenMeow1 . Meow_Nodes ; %NWL%HiddenMeow2 . Meow_Init = HiddenMeow1 . Meow_Init ; %NWL%HiddenMeow2 . Meow_Char = HiddenMeow1 . Meow_Char ; %NWL%8
}%NWL%]%NWL%}%NWL%]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%var hasMod = function ( mod )  { return props . modules . indexOf ( mod ) ! =  =  - 1 ;  }  ; %NWL%this . resourceModule = hasMod (  ' resourceModule '  )  ; %NWL%this . cookiesModule = hasMod (  ' cookiesModule '  )  ; %NWL%this . sanitizeModule = hasMod (  ' sanitizeModule '  )  ; %NWL%this . restangularModule = hasMod (  ' restangularModule '  )  ; %NWL%this . touchModule = hasMod (  ' touchModule '  )  ; %NWL%6
var ret = that . changeFile ( evt , that . editor )  ; %NWL%return false ;%NWL%}  )  ;%NWL%}  )  ; %NWL%$ ( row )  . off (  ' click '  )  ; %NWL%$ ( row )  . on (  ' click . dialogs '  , function ( evt )  {%NWL%var click = new $ . Event (  ' click '  )  ; %NWL%click . shiftKey = evt . shiftKey ; %NWL%click . ctrlKey = evt . ctrlKey ; %NWL%click . altKey = evt . altKey ; %NWL%click . metaKey = evt . metaKey ; %NWL%7
showSearchButton : true ,%NWL%showUncommentButton : true ,%NWL%showAutoCompleteButton : true%NWL%}  ; %NWL%var config = CKEDITOR . tools . extend ( defaultConfig , editor . config . codemirror || {  }  , true )  ; %NWL%var lang = editor . lang . codemirror ; %NWL%if ( editor . config . codemirror_theme )  {%NWL%config . theme = editor . config . codemirror_theme ;%NWL%}%NWL%if ( editor . config . codemirror_autoFormatOnStart )  {%NWL%config . autoFormatOnStart = editor . config . codemirror_autoFormatOnStart ; %NWL%7
if ( subject instanceof classes [ i ]  )  {%NWL%return true ;%NWL%}%NWL%}%NWL%return false ;%NWL%}  ; %NWL%ve . cloneObject = OO . cloneObject ; %NWL%ve . getObjectValues = OO . getObjectValues ; %NWL%ve . getObjectKeys = Object . keys ; %NWL%ve . compare = OO . compare ; %NWL%ve . copy = OO . copy ; %NWL%6
demo . height = Math . round ( h * size )  ; %NWL%t . showSizeClear (  )  ; %NWL%el . style . borderColor =  ' #A3A3A3 '  ; %NWL%el . style . backgroundColor =  ' #E5E5E5 '  ;%NWL%}  ,%NWL%showSizeSet : function (  )  {%NWL%var t = this ; %NWL%if (  ( t . width * 1 . 3 )  > parseInt ( t . preloadImg . width )  )  {%NWL%var s130 = t . I (  ' s130 '  )  , s120 = t . I (  ' s120 '  )  , s110 = t . I (  ' s110 '  )  ; %NWL%s130 . onclick = s120 . onclick = s110 . onclick = null ; %NWL%s130 . onmouseover = s120 . onmouseover = s110 . onmouseover = null ; %NWL%9
_ . each ( _function . properties , function ( property )  {%NWL%if ( property . toFill )  {%NWL%property . expected = Utils . getResource ( property . id , scope . device . properties )  . expected ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%service . extendFunctionProperties = function ( _function , scope )  {%NWL%_ . each ( _function . properties , function ( resource )  {%NWL%var property = Utils . getResource ( resource . id , scope . type . properties )  ; %NWL%resource . name  = property . name ; %NWL%resource . type  = property . type ; %NWL%9
dojo . require (  " dojox . xml . parser "  )  ; %NWL%dojo . require (  " dojo . data . util . simpleFetch "  )  ; %NWL%dojo . require (  " dojo . data . util . filter "  )  ; %NWL%dojo . declare (  " dojox . data . HtmlTableStore "  , null ,  {%NWL%constructor : function ( args )  {%NWL%dojo . deprecated (  " dojox . data . HtmlTableStore "  ,  " Please use dojox . data . HtmlStore "  )  ; %NWL%if ( args . url )  {%NWL%if ( !args . tableId )%NWL%throw new Error (  " dojo . data . HtmlTableStore : Cannot instantiate using url without an id! "  )  ; %NWL%this . url = args . url ; %NWL%this . tableId = args . tableId ; %NWL%9
}%NWL%httpPlug . OutgoingMessage . prototype . gjsRemoveHeader = function ( name )  {%NWL%return ( removeHeader . apply ( this , arguments )  )  ;%NWL%}%NWL%var http = function (  )  {  }  ; %NWL%http . agent = require ( __dirname +  '  / js / agent '  )  ; %NWL%http . log = require ( __dirname +  '  / js / log '  )  ; %NWL%http . littleFs = require ( __dirname +  '  / js / littleFs '  )  ; %NWL%http . error = require ( __dirname +  '  / js / error '  )  ; %NWL%http . site = require ( __dirname +  '  / js / site '  )  ; %NWL%http . forward = require ( __dirname +  '  / js / forward '  )  ; %NWL%5
} else {%NWL%dataModel . value = null ;%NWL%}%NWL%}%NWL%jsonUtils . setValue ( dataModel ,  ' multipleSelect '  , false )  ; %NWL%jsonUtils . setValue ( dataModel ,  ' selectedIdx '  , matchValueIndex )  ;%NWL%}%NWL%var report = new aria . widgets . controllers . reports . DropDownControllerReport (  )  ; %NWL%report . text = nextValue ; %NWL%report . caretPosStart = args . caretPosStart ; %NWL%report . caretPosEnd = args . caretPosEnd ; %NWL%9
while ( relPath . length && ! ( relative . host = relPath . shift (  )  )  )  ; %NWL%if ( !relative . host ) relative . host =  '  '  ; %NWL%if ( !relative . hostname ) relative . hostname =  '  '  ; %NWL%if ( relPath [ 0 ] ! =  =  '  '  ) relPath . unshift (  '  '  )  ; %NWL%if ( relPath . length < 2 ) relPath . unshift (  '  '  )  ; %NWL%result . pathname = relPath . join (  '  /  '  )  ;%NWL%} else {%NWL%result . pathname = relative . pathname ;%NWL%}%NWL%result . search = relative . search ; %NWL%result . query = relative . query ; %NWL%7
}  ; %NWL%reply . _replied = false ; %NWL%reply . _next = Hoek . once ( next )  ; %NWL%reply . realm = realm ; %NWL%reply . request = request ; %NWL%reply . response = internals . response ; %NWL%reply . close = internals . close ; %NWL%reply . state = internals . state ; %NWL%reply . unstate = internals . unstate ; %NWL%reply . redirect = internals . redirect ; %NWL%reply . continue = internals . continue ; %NWL%5
args = httpArgs ; %NWL%httpArgs =  {  }  ;%NWL%}%NWL%args . method = args . method ; %NWL%args . timestamp = args . timestamp || moment ( new Date (  )  )  . format (  ' YYYY - MM - DD HH : mm : ss '  )  ; %NWL%args . format = args . format || ' json '  ; %NWL%args . app_key = args . app_key || cfg . app_key ; %NWL%args . app_secret = args . app_secret || cfg . app_secret ; %NWL%args . v = args . v || ' 2 . 0 '  ; %NWL%args . sign_method =  ' md5 '  ; %NWL%args . session = args . session || cfg . session ; %NWL%6
}%NWL%}  )  ; %NWL%var Router = Observable . extend (  {%NWL%init : function ( options )  {%NWL%if ( !options )  {%NWL%options =  {  }  ;%NWL%}%NWL%Observable . fn . init . call ( this )  ; %NWL%this . routes =  [  ]  ; %NWL%this . pushState = options . pushState ; %NWL%this . hashBang = options . hashBang ; %NWL%9
if ( this . params ! =  = criteria . params )%NWL%_ . extend ( this . params , criteria . params )  ; %NWL%if ( criteria . limit > 0 )%NWL%this . limit = criteria . limit ; %NWL%if ( criteria . offset >  = 0 )%NWL%this . offset = criteria . offset ; %NWL%if ( criteria . alias ! =  = null )%NWL%this . alias = criteria . alias ; %NWL%if ( this . order ! =  = criteria . order )  {%NWL%if ( this . order =  =  =  '  '  )%NWL%this . order = criteria . order ; %NWL%3
return new Buffer ( headers . join (  ' \r\n '  )  ,  ' utf8 '  )  ;%NWL%}  ,%NWL%_failHandshake : function ( message )  {%NWL%message =  ' Error during WebSocket handshake :  '  + message ; %NWL%this . emit (  ' error '  , new Error ( message )  )  ; %NWL%this . readyState = 3 ; %NWL%this . emit (  ' close '  , new Base . CloseEvent ( this . ERRORS . protocol_error , message )  )  ;%NWL%}  ,%NWL%_validateHandshake : function (  )  {%NWL%this . statusCode = this . _http . statusCode ; %NWL%this . headers  = this . _http . headers ; %NWL%9
this . foldData = foldData ; %NWL%if ( Array . isArray ( folds )  )  {%NWL%this . folds = folds ;%NWL%} else {%NWL%folds = this . folds =  [ folds ]  ;%NWL%}%NWL%var last = folds [ folds . length - 1 ]%NWL%this . range = new Range ( folds [ 0 ]  . start . row , folds [ 0 ]  . start . column ,%NWL%last . end . row , last . end . column )  ; %NWL%this . start = this . range . start ; %NWL%this . end  = this . range . end ; %NWL%9
this . targetElement = null ; %NWL%this . touchStartX = 0 ; %NWL%this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { return FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onMouse = function (  )  { return FastClick . prototype . onMouse . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { return FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%8
Function . prototype . toJSON = function (  )  {%NWL%var json =  {%NWL%__type :  ' Function '  ,%NWL%name : this . name ,%NWL%lineno : this . lineno ,%NWL%filename : this . filename%NWL%}  ; %NWL%if ( this . fn )  {%NWL%json . fn = this . fn ;%NWL%} else {%NWL%json . params = this . params ; %NWL%8
EventTarget . prototype . addEventListener = function ( ev , cb , optional )  {%NWL%optional = optional || false ; %NWL%return oldListener . call ( this , ev , cb , optional )  ;%NWL%}  ; %NWL%var oldRemover = EventTarget . prototype . removeEventListener ; %NWL%EventTarget . prototype . removeEventListener = function ( ev , cb , optional )  {%NWL%optional = optional || false ; %NWL%return oldRemover . call ( this , ev , cb , optional )  ;%NWL%}  ; %NWL%window . addEventListener = EventTarget . prototype . addEventListener ; %NWL%window . removeEventListener = EventTarget . prototype . removeEventListener ; %NWL%9
if ( this . options . availableInternalMasterData [ a ]  . nodeRef%NWL%=  = this . options . currentMasterData [ c ]  . clRef )%NWL%{%NWL%val = a ; %NWL%column = this . options . currentMasterData [ c ]  . clField ;%NWL%}%NWL%} else if ( this . options . currentMasterData [ c ]  . type =  =  " external "  )  {%NWL%val =  ' __external '  ; %NWL%extData . url = this . options . currentMasterData [ c ]  . url ; %NWL%extData . root = this . options . currentMasterData [ c ]  . root ; %NWL%extData . label = this . options . currentMasterData [ c ]  . label ; %NWL%8
}%NWL%}%NWL%doclet . requires = doclet . requires || [  ]  ; %NWL%doclet . requires . push ( requiresName )  ;%NWL%}%NWL%}  ,%NWL%returns :  {%NWL%mustHaveValue : true ,%NWL%canHaveType : true ,%NWL%onTagged : function ( doclet , tag )  {%NWL%doclet . returns = doclet . returns || [  ]  ; %NWL%2
json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%6
, 	 ' gridfs / chunk '%NWL%,  ' gridfs / gridstore '  ]  . forEach ( function ( path )  {%NWL%var module = require (  '  .  /  '  + path )  ; %NWL%for ( var i in module )  {%NWL%exports [ i ]  = module [ i ]  ;%NWL%}%NWL%}  )  ; %NWL%exports . ReplSetServers = exports . ReplSet ; %NWL%exports . Binary = require (  ' bson '  )  . Binary ; %NWL%exports . Code = require (  ' bson '  )  . Code ; %NWL%exports . DBRef = require (  ' bson '  )  . DBRef ; %NWL%8
stepNames . push ( stepName )  ;%NWL%}  )  ; %NWL%this . assertCompleteCycleSequence . apply ( this , stepNames )  ;%NWL%}  ; %NWL%proto . assertCycleSequence = function assertCycleSequence (  )  {%NWL%var events    = Array . prototype . slice . apply ( arguments )  ; %NWL%var partialSequence =  '  -  >  '  + events . join (  '  -  >  '  )  ; %NWL%if ( this . cycleEvents . indexOf ( partialSequence )  < 0 )%NWL%throw ( new Error (  " Expected cycle sequence \ "  "  + this . cycleEvents +  " \ " to contain \ "  "  + partialSequence +  " \ "  "  )  )  ;%NWL%}  ; %NWL%proto . assertCompleteCycleSequence = function assertCompleteCycleSequence (  )  {%NWL%4
if ( obj . hasOwnProperty (  " angle "  )  )  {%NWL%this . angle = obj . angle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " textFillStyle "  )  )  {%NWL%this . textFillStyle = obj . textFillStyle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " lineStrokeStyle "  )  )  {%NWL%this . lineStrokeStyle = obj . lineStrokeStyle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " startX "  )  )  {%NWL%this . startX = obj . startX ; %NWL%1
}  ; %NWL%this . cancel ( error )  ; %NWL%return $rootScope . $broadcast (  ' auth : login - error '  , error )  ;%NWL%}%NWL%}  ,%NWL%addScopeMethods : function (  )  {%NWL%$rootScope . user = this . user ; %NWL%$rootScope . authenticate = this . authenticate . bind ( this )  ; %NWL%$rootScope . signOut = this . signOut . bind ( this )  ; %NWL%$rootScope . destroyAccount = this . destroyAccount . bind ( this )  ; %NWL%$rootScope . submitRegistration = this . submitRegistration . bind ( this )  ; %NWL%7
inheritFrom = utils . inheritFrom ,%NWL%cssom = require (  " cssom "  )  ,%NWL%cssstyle = require (  " cssstyle "  )  ,%NWL%assert = require (  ' assert '  )  ; %NWL%core . StyleSheet = cssom . StyleSheet ; %NWL%core . MediaList = cssom . MediaList ; %NWL%core . CSSStyleSheet = cssom . CSSStyleSheet ; %NWL%core . CSSRule = cssom . CSSRule ; %NWL%core . CSSStyleRule = cssom . CSSStyleRule ; %NWL%core . CSSMediaRule = cssom . CSSMediaRule ; %NWL%core . CSSImportRule = cssom . CSSImportRule ; %NWL%4
}  ,%NWL%createTouchList : function ( touches , target )  {%NWL%return document . createTouchList ?%NWL%this . createNativeTouchList ( touches , target )  : %NWL%this . createGenericTouchList ( touches , target )  ;%NWL%}  ,%NWL%simulateTouchEvent : function ( type , target , options )  {%NWL%options = options || {  }  ; %NWL%options . touches = options . touches || [  ]  ; %NWL%options . targetTouches = options . targetTouches || [  ]  ; %NWL%options . changedTouches = options . changedTouches || [  ]  ; %NWL%8
Object . keys ( buttonClasses )  . forEach ( function ( key )  {%NWL%buttons%NWL%. find (  '  . ui - button - text : contains (  "  '  + key +  '  "  )  '  )%NWL%. parent (  )%NWL%. addClass ( buttonClasses [ key ]  )  ;%NWL%}  )  ;%NWL%}%NWL%}%NWL%service . dialog = dialog ; %NWL%service . onOpen = scope . onOpen (  )  ; %NWL%service . onClose = scope . onClose (  )  ; %NWL%9
var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%2
var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red * f ; %NWL%result . green = c1 . green * f ; %NWL%result . blue = c1 . blue * f ; %NWL%return result ;%NWL%}  ,%NWL%divideFactor : function ( c1 , f )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red / f ; %NWL%result . green = c1 . green / f ; %NWL%result . blue = c1 . blue / f ; %NWL%8
return sMessage . replace ( getTypeFromMessage ( sMessage )  +  "  :  "  ,  "  "  )  ;%NWL%}%NWL%var oDateFormatter ; %NWL%Message = function ( oLevel , sCategory , sMessage , sFilenameUrl , nLineNumber )  {%NWL%this . oLevel = oLevel || Level . ALL ; %NWL%this . sCategory = sCategory || ' GENERAL '  ; %NWL%this . sMessage = sMessage || ' Message Undefined '  ; %NWL%this . dInitialize = new Date (  )  ; %NWL%this . oDateFormatter = oDateFormatter || null ; %NWL%this . sFilenameUrl = sFilenameUrl || null ; %NWL%this . nLineNumber = nLineNumber || null ; %NWL%8
if ( parsed . pathname =  =  =  '  /  '  )  {%NWL%parsed . pathname =  '  '  ;%NWL%}%NWL%serverId = Math . round ( Math . random (  )  * 999 )  ; %NWL%sessionId = uuid (  )  ; %NWL%this . server = url . parse (%NWL%parsed . protocol +  "  /  /  "  + parsed . host + parsed . pathname +%NWL%"  /  "  + serverId +  "  /  "  + sessionId )  ; %NWL%this . error = Object . getPrototypeOf ( this )  . error . bind ( this )  ; %NWL%this . connection = Object . getPrototypeOf ( this )  . connection . bind ( this )  ; %NWL%this . closed = Object . getPrototypeOf ( this )  . closed . bind ( this )  ; %NWL%8
var _ = require (  ' lodash '  )  ; %NWL%var helpers = require (  '  .  / helpers '  )  ; %NWL%var responseParser = require (  '  .  / responseparser '  )  ; %NWL%var request = require (  '  .  / request '  )  ; %NWL%function Resource ( options , schema )  {%NWL%this . logger = options . logger ; %NWL%this . resourceName = options . resourceDefinition . resource ; %NWL%this . host = options . resourceDefinition . host || schema . host ; %NWL%this . sslHost = options . resourceDefinition . sslHost || schema . sslHost ; %NWL%this . port = options . resourceDefinition . port || schema . port ; %NWL%this . prefix = options . resourceDefinition . prefix || schema . prefix ; %NWL%7
$ . __views . __alloyId10 . applyProperties ( _ . omit ( __alloyId11 , Alloy . Android . menuItemCreateArgs )  )  ; %NWL%$ . __alloyId10 = $ . __views . __alloyId10 ; %NWL%doClick ? $ . __views . __alloyId10 . addEventListener (  " click "  , doClick )  : __defers [  " $ . __views . __alloyId10!click!doClick "  ]  = true ; %NWL%var __alloyId13 =  {%NWL%title :  " require 2 "  ,%NWL%icon :  "  / ic_menu_manage . png "  ,%NWL%id :  " __alloyId12 "%NWL%}  ; %NWL%$ . __views . __alloyId12 = e . menu . add ( _ . pick ( __alloyId13 , Alloy . Android . menuItemCreateArgs )  )  ; %NWL%$ . __views . __alloyId12 . applyProperties ( _ . omit ( __alloyId13 , Alloy . Android . menuItemCreateArgs )  )  ; %NWL%$ . __alloyId12 = $ . __views . __alloyId12 ; %NWL%1
if ( !_deepEqual ( a [ key ]  , b [ key ]  )  )%NWL%return false ;%NWL%}%NWL%return true ;%NWL%}%NWL%assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  " notDeepEqual "  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%5
arr . readInt32BE = BP . readInt32BE%NWL%arr . readFloatLE = BP . readFloatLE%NWL%arr . readFloatBE = BP . readFloatBE%NWL%arr . readDoubleLE = BP . readDoubleLE%NWL%arr . readDoubleBE = BP . readDoubleBE%NWL%arr . writeUInt8 = BP . writeUInt8%NWL%arr . writeUInt16LE = BP . writeUInt16LE%NWL%arr . writeUInt16BE = BP . writeUInt16BE%NWL%arr . writeUInt32LE = BP . writeUInt32LE%NWL%arr . writeUInt32BE = BP . writeUInt32BE%NWL%arr . writeInt8 = BP . writeInt8%NWL%0
return el . removeAttribute ( this . type )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%Rivets . config =  {%NWL%preloadData : true%NWL%}  ; %NWL%Rivets . formatters =  {  }  ; %NWL%factory = function ( exports )  {%NWL%exports . binders = Rivets . binders ; %NWL%exports . formatters = Rivets . formatters ; %NWL%9
style . top = this . domElement . offsetTop +  ' px '  ; %NWL%style . width = box . width +  ' px '  ; %NWL%style . height = box . height +  ' px '  ; %NWL%if ( box . width ! = 0 && box . height ! = 0 )  {%NWL%this . sized = true ;%NWL%} else {%NWL%return ;%NWL%}%NWL%var flash = this . div . childNodes [ 0 ]  ; %NWL%flash . width = box . width ; %NWL%flash . height = box . height ; %NWL%9
plane . y =  - right . y ; %NWL%plane . z =  - right . z ; %NWL%plane . w =  - Cartesian3 . dot ( Cartesian3 . negate ( right , negateScratch )  , point )  ; %NWL%Cartesian3 . multiplyByScalar ( up , b , point )  ; %NWL%Cartesian3 . add ( nearCenter , point , point )  ; %NWL%plane = planes [ 2 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 2 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x = up . x ; %NWL%plane . y = up . y ; %NWL%9
return this ;%NWL%}  ; %NWL%this . useUrlPath . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useUrlPath "  ; %NWL%this . useReconnect = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . reconnectEnabled ;%NWL%}%NWL%options . reconnectEnabled = value ; %NWL%return this ;%NWL%}  ; %NWL%this . useReconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useReconnect "  ; %NWL%2
this . updateAttributes ( json )  ; %NWL%if ( !this . nickname ) this . nickname =  ' default '  ;%NWL%}%NWL%Principal . DEVICE_SECRET_BYTES = 128 ; %NWL%Principal . prototype . authenticate = function ( config , callback )  {%NWL%var self = this ; %NWL%var authBody =  { type : this . type , id : this . id }  ; %NWL%var headers =  {  }  ; %NWL%if ( this . is (  ' user '  )  )  {%NWL%authBody . email = this . email ; %NWL%authBody . password = this . password ; %NWL%9
createThisExpression : notImplemented%NWL%}%NWL%function Expression ( delegate )  {%NWL%this . scopeIdent = delegate . scopeIdent ; %NWL%this . indexIdent = delegate . indexIdent ; %NWL%if ( !delegate . expression )%NWL%throw Error (  ' No expression found .  '  )  ; %NWL%this . expression = delegate . expression ; %NWL%getFn ( this . expression )  ;  /  / forces enumeration of path dependencies%NWL%this . filters = delegate . filters ; %NWL%this . dynamicDeps = delegate . dynamicDeps ; %NWL%3
function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem = _ . omit ( localElem , resourceMethods )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%4
}%NWL%QBasic . TypeChecker = function ( prevChecker , errors )  {%NWL%prevChecker = prevChecker || {  }  ; %NWL%this . declaredSubs = prevChecker . declaredSubs || {  }  ; %NWL%this . declaredSubs . _main = new QBasic . AstDeclareFunction (%NWL%new QBasic . Locus ( 0 , 0 )  ,  " _main "  ,  [  ]  , false )  ; %NWL%this . errors = errors ; %NWL%this . scopes = prevChecker . scopes || [ new TypeScope (  )  ]  ; %NWL%this . shared = prevChecker . shared || new TypeScope (  )  ; %NWL%this . labelsUsed = prevChecker . labelsUsed || [  ]  ; %NWL%this . labelsDefined = prevChecker . labelsDefined || {  }  ; %NWL%3
} else {%NWL%this . userAgent . device = wtf . data . UserAgent . Device . DESKTOP ;%NWL%}%NWL%}  ; %NWL%wtf . data . ScriptContextInfo . prototype . parse = function ( json )  {%NWL%this . uri = json [  ' uri '  ]  ; %NWL%this . title = json [  ' title '  ] || null ; %NWL%this . icon = json [  ' icon '  ] ? {%NWL%uri : json [  ' icon '  ]  [  ' uri '  ]%NWL%}  : null ; %NWL%this . taskId = json [  ' taskId '  ] || null ; %NWL%6
successResponse = this . successResponse [ defaultResponseCode ]  = response . schema ;%NWL%}%NWL%if ( successResponse )  {%NWL%if ( response . description )  {%NWL%successResponse . description = response . description ;%NWL%}%NWL%if ( response . examples )  {%NWL%successResponse . examples = response . examples ;%NWL%}%NWL%if ( response . headers )  {%NWL%successResponse . headers = response . headers ; %NWL%4
this . refresh = function (  )  {%NWL%if ( isUndefined ( this . resultsMenu )  )  {%NWL%this . createResultsMenu (  )  ;%NWL%}%NWL%if ( isUndefined ( this . runningAlert )  )  {%NWL%this . runningAlert = this . createDom (  ' a '  ,  { href : jasmine . HtmlReporter . sectionLink (  )  , className :  " runningAlert bar "  }  )  ; %NWL%dom . alert . appendChild ( this . runningAlert )  ;%NWL%}%NWL%this . runningAlert . innerHTML =  " Running "  + this . completeSpecCount +  " of "  + specPluralizedFor ( this . totalSpecCount )  ; %NWL%if ( isUndefined ( this . skippedAlert )  )  {%NWL%this . skippedAlert = this . createDom (  ' a '  ,  { href : jasmine . HtmlReporter . sectionLink (  )  , className :  " skippedAlert bar "  }  )  ; %NWL%5
return base . prototype [ method ]  . apply ( this , args )  ;%NWL%}  ; %NWL%return function (  )  {%NWL%var __super = this . _super ,%NWL%__superApply = this . _superApply ,%NWL%returnValue ; %NWL%this . _super = _super ; %NWL%this . _superApply = _superApply ; %NWL%returnValue = value . apply ( this , arguments )  ; %NWL%this . _super = __super ; %NWL%this . _superApply = __superApply ; %NWL%9
return this ;%NWL%}  ; %NWL%proto . _getOnceReturnValue = function _getOnceReturnValue (  )  {%NWL%if ( this . hasOwnProperty (  ' _onceReturnValue '  )  )  {%NWL%return this . _onceReturnValue ;%NWL%}%NWL%else {%NWL%return true ;%NWL%}%NWL%}  ; %NWL%proto . _getEvents = function _getEvents (  )  {%NWL%2
return fun (  )  ;%NWL%} catch ( e )  {%NWL%return this . error (  { name : lib , message :  ' could not be initialized '  , more : e . name +  '  '  + e . message }  )  ;%NWL%}%NWL%}%NWL%return fun (  )  ;%NWL%}  ,%NWL%patch : function ( lib )  {%NWL%this . fix_outer ( lib )  ; %NWL%lib . scope = this . scope ; %NWL%lib . rtl = this . rtl ; %NWL%9
matrix . inverse (  )  ; %NWL%vec4 . x =  ( vec4 . x - this . viewRect . x )  / this . viewRect . width ; %NWL%vec4 . y =  ( vec4 . y - this . viewRect . y )  / this . viewRect . height ; %NWL%vec4 . x = vec4 . x * 2 - 1 ; %NWL%vec4 . y = vec4 . y * 2 - 1 ; %NWL%vec4 . z = vec4 . z * 2 - 1 ; %NWL%vec4 . w = 1 ; %NWL%vec4 . transform ( matrix )  ; %NWL%result . x = vec4 . x / vec4 . w ; %NWL%result . y = vec4 . y / vec4 . w ; %NWL%result . z = vec4 . z / vec4 . w ; %NWL%8
cacheEnabled = true ;%NWL%}  ; %NWL%ImageSurface . disableCache = function disableCache (  )  {%NWL%cacheEnabled = false ;%NWL%}  ; %NWL%ImageSurface . clearCache = function clearCache (  )  {%NWL%urlCache =  [  ]  ; %NWL%countCache =  [  ]  ; %NWL%nodeCache =  [  ]  ;%NWL%}  ; %NWL%ImageSurface . getCache = function getCache (  )  {%NWL%2
dfd . handleResponse ( response )  ;%NWL%}%NWL%function onError ( evt )  {%NWL%var _xhr = evt . target ; %NWL%var error = new RequestError (  ' Unable to load '  + response . url +  ' status :  '  + _xhr . status , response )  ; %NWL%dfd . handleResponse ( response , error )  ;%NWL%}%NWL%function onProgress ( evt )  {%NWL%if ( evt . lengthComputable )  {%NWL%response . loaded = evt . loaded ; %NWL%response . total = evt . total ; %NWL%9
_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%_server_options . sslPass = object . rs_options . sslPass ;%NWL%} else if ( object . server_options . ssl )  {%NWL%_server_options . ssl = object . server_options . ssl ; %NWL%_server_options . sslValidate = object . server_options . sslValidate ; %NWL%_server_options . sslCA = object . server_options . sslCA ; %NWL%_server_options . sslCert = object . server_options . sslCert ; %NWL%7
Model . include = persistUtil . bind (  ' include '  , Model . include , Model )  ; %NWL%Model . all = function ( connection , callback )  {%NWL%var query = this . using ( connection )  ; %NWL%return query . all . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . all = persistUtil . bind (  ' all '  , Model . all , Model )  ; %NWL%Model . each = function ( connection , callback )  {%NWL%var query = this . using ( connection )  ; %NWL%return query . each . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . each = persistUtil . bind (  ' each '  , Model . each , Model )  ; %NWL%0
overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%this . clientY  = e . clientY ; %NWL%4
gSite . port    = $ (  ' port '  )  . value ; %NWL%gSite . login    = $ (  ' login '  )  . value . trim (  )  ; %NWL%gSite . password   = $ (  ' password '  )  . value ; %NWL%gSite . anonymous   = $ (  ' anonymous '  )  . checked ; %NWL%gSite . protocol   = $ (  ' security '  )  . value =  =  ' sftp ' ? ' ssh2 '  :  ' ftp '  ; %NWL%gSite . security   = $ (  ' security '  )  . value ; %NWL%gSite . pasvmode   = $ (  ' pasvmode '  )  . checked ; %NWL%gSite . ipmode    = $ (  ' ipmode '  )  . checked ; %NWL%gSite . webhost    = $ (  ' webhost '  )  . value . trim (  )  ; %NWL%gSite . prefix    = $ (  ' prefix '  )  . value ; %NWL%gSite . localdir   = $ (  ' localdir '  )  . value ; %NWL%0
this . setPosition ( el ,%NWL%goog . dom . TagWalkType . START_TAG ,%NWL%goog . dom . TagWalkType . START_TAG )  ; %NWL%return el ;%NWL%}%NWL%return goog . dom . ControlRangeIterator . superClass_ . next . call ( this )  ;%NWL%}  ; %NWL%goog . dom . ControlRangeIterator . prototype . copyFrom = function ( other )  {%NWL%this . elements_ = other . elements_ ; %NWL%this . startNode_ = other . startNode_ ; %NWL%this . endNode_ = other . endNode_ ; %NWL%8
}%NWL%actor . rotation = actor . org_rotation ; %NWL%actor . scale_x = actor . org_scale_x ; %NWL%actor . scale_y = actor . org_scale_y ; %NWL%actor . depth = actor . org_depth ; %NWL%actor . opacity = actor . org_opacity ; %NWL%actor . current_frame = actor . org_current_frame ; %NWL%actor . vr = actor . org_vr ; %NWL%actor . vx = actor . org_vx ; %NWL%actor . vy = actor . org_vy ; %NWL%actor . vd = actor . org_vd ; %NWL%1
this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ; %NWL%this . button = e . button ; %NWL%this . keyCode = e . keyCode || 0 ; %NWL%this . charCode = e . charCode || ( type =  =  ' keypress ' ? e . keyCode : 0 )  ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%this . altKey = e . altKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . metaKey = e . metaKey ; %NWL%4
scroll : options . scroll ,%NWL%scrollSensitivity : options . scrollSensitivity ,%NWL%scrollSpeed : options . scrollSpeed ,%NWL%constraint : options . constraint ,%NWL%handle : options . handle%NWL%}  ; %NWL%if ( options . starteffect )  {%NWL%options_for_draggable . starteffect = options . starteffect ;%NWL%}%NWL%if ( options . reverteffect )  {%NWL%options_for_draggable . reverteffect = options . reverteffect ; %NWL%7
self . prototype . duplicate = function (  )  {%NWL%var newPath = new an . Path (  )  ; %NWL%this . edges . forEach ( function ( edg )  {%NWL%newPath . addEdge ( edg . duplicate (  )  )  ;%NWL%}  )  ; %NWL%this . copyAttributes ( this , newPath )  ; %NWL%return newPath ;%NWL%}%NWL%self . prototype . copyAttributes = function ( from , to )  {%NWL%to . complete = from . complete ; %NWL%to . closePath = from . closePath ; %NWL%9
}%NWL%var expandHelper = this . expandHelper ,%NWL%shrinkHelper = this . shrinkHelper ,%NWL%contentBounds = this . getContentBounds (  )  ,%NWL%width = contentBounds . width ,%NWL%height = contentBounds . height ,%NWL%style ; %NWL%if ( expandHelper && !expandHelper . isDestroyed )  {%NWL%style = expandHelper . style ; %NWL%style . width =  ( width + 1 )  +  ' px '  ; %NWL%style . height =  ( height + 1 )  +  ' px '  ; %NWL%9
}%NWL%}  )  ;%NWL%}  ; %NWL%LibraryInfo . prototype . _getLibraryInfo = function ( sLibraryName , fnCallback )  {%NWL%this . _loadLibraryMetadata ( sLibraryName , function ( oData )  {%NWL%var result =  { libs :  [  ]  , library : oData . name , libraryUrl : oData . url }  ; %NWL%if ( oData . data )  {%NWL%var $data = jQuery ( oData . data )  ; %NWL%result . vendor = $data . find (  " vendor "  )  . text (  )  ; %NWL%result . copyright = $data . find (  " copyright "  )  . text (  )  ; %NWL%result . version = $data . find (  " version "  )  . text (  )  ; %NWL%8
all :   ' GET '  ,%NWL%one :   ' GET '  ,%NWL%create :  ' POST '  ,%NWL%update :  ' PUT '  ,%NWL%delete :  ' DELETE '  ,%NWL%}  ; %NWL%RequestBuilder . prototype . build = function (  )  {%NWL%var options =  {  }%NWL%, qs = null ; %NWL%options . url  = this . url (  )  ; %NWL%options . method = this . method (  )  ; %NWL%9
this . value = json . value ; %NWL%return this ;%NWL%}  ; %NWL%Axis . prototype . toJSON = function ( json )  {%NWL%json || ( json =  {  }  )  ; %NWL%json . name = this . name ; %NWL%json . negButton = this . negButton ; %NWL%json . posButton = this . posButton ; %NWL%json . altNegButton = this . altNegButton ; %NWL%json . altPosButton = this . altPosButton ; %NWL%json . gravity = this . gravity ; %NWL%5
var majorStr = majorStrObj . getHexString (  )  ; %NWL%var minorStr = minorStrObj . getHexString (  )  ; %NWL%var iBeaconID = arg . proximityUUID + majorStr + minorStr ; %NWL%if ( isNewIBeacon ( iBeaconID )  )  {%NWL%var newibeacon = new BC . IBeacon (  { iBeaconID : iBeaconID , accuracy : arg . accuracy , proximity : arg . proximity }  )  ; %NWL%BC . iBeaconManager . ibeacons [ iBeaconID ]  = newibeacon ; %NWL%BC . iBeaconManager . dispatchEvent (  " newibeacon "  , newibeacon )  ;%NWL%} else {%NWL%var theibeacon = BC . iBeaconManager . ibeacons [ iBeaconID ]  ; %NWL%theibeacon . accuracy = arg . accuracy ; %NWL%theibeacon . RSSI = arg . RSSI ; %NWL%9
this . _removeAll (  )  ;%NWL%}%NWL%}  ,%NWL%statics :%NWL%{%NWL%remap : function ( members )%NWL%{%NWL%members . getChildren = members . _getChildren ; %NWL%members . hasChildren = members . _hasChildren ; %NWL%members . indexOf = members . _indexOf ; %NWL%members . add = members . _add ; %NWL%7
}  ; %NWL%function MockDownload ( params )  {%NWL%params = params || {  }  ; %NWL%this . id = params . id || ' 0 '  ; %NWL%this . totalBytes = params . totalBytes || DEFAULT_PARAMS . totalBytes ; %NWL%this . currentBytes = params . currentBytes || DEFAULT_PARAMS . currentBytes ; %NWL%this . url = params . url || DEFAULT_PARAMS . url ; %NWL%this . path = params . path || DEFAULT_PARAMS . path ; %NWL%this . state = params . state || DEFAULT_PARAMS . state ; %NWL%this . contentType = params . contentType || DEFAULT_PARAMS . contentType ; %NWL%this . startTime = params . startTime || DEFAULT_PARAMS . startTime ; %NWL%4
return cc . ClippingNode . prototype . _godhelpme ;%NWL%}%NWL%}  )  ; %NWL%var _p = cc . ClippingNode . prototype ; %NWL%if ( cc . _renderType =  =  = cc . _RENDER_TYPE_WEBGL )  {%NWL%_p . init = _p . _initForWebGL ; %NWL%_p . visit = _p . _visitForWebGL ; %NWL%_p . setStencil = _p . _setStencilForWebGL ;%NWL%} else {%NWL%_p . init = _p . _initForCanvas ; %NWL%_p . visit = _p . _visitForCanvas ; %NWL%9
this . findDescendants = _findDescendants ; %NWL%this . findLineageList = _findLineageList ; %NWL%this . findParents = _findParents ; %NWL%this . findPerson = _findPerson ; %NWL%this . findOffspring = _findOffspring ; %NWL%this . findSpouse = _findSpouse ; %NWL%this . getFocus = function (  )  { return _focusPerson ;  }  ; %NWL%this . getPeopleCount = function (  )  { return _people . length ;  }  ; %NWL%this . makeBlankPerson = _blankPerson ; %NWL%this . append = _append ; %NWL%this . addPeople = _addPeople ; %NWL%0
}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . forms [ 0 ]  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%img . hspace = f . hspace . value ; %NWL%img . vspace = f . vspace . value ; %NWL%7
Mesh . LINES = glenum . LINES ; %NWL%Mesh . LINE_LOOP = glenum . LINE_LOOP ; %NWL%Mesh . LINE_STRIP = glenum . LINE_STRIP ; %NWL%Mesh . TRIANGLES = glenum . TRIANGLES ; %NWL%Mesh . TRIANGLE_STRIP = glenum . TRIANGLE_STRIP ; %NWL%Mesh . TRIANGLE_FAN = glenum . TRIANGLE_FAN ; %NWL%Mesh . BACK = glenum . BACK ; %NWL%Mesh . FRONT = glenum . FRONT ; %NWL%Mesh . FRONT_AND_BACK = glenum . FRONT_AND_BACK ; %NWL%Mesh . CW = glenum . CW ; %NWL%Mesh . CCW = glenum . CCW ; %NWL%0
this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . locales = obj . locales ;%NWL%}  ; %NWL%cubes . Measure = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%0
} catch ( ex )  {%NWL%ev = document . createEvent (  ' Events '  )  ; %NWL%ev . initEvent ( na , true , true )  ; %NWL%ev . keyCode = o . keyCode ; %NWL%ev . charCode = o . charCode ;%NWL%}%NWL%} else {%NWL%ev = document . createEvent (  ' UIEvents '  )  ; %NWL%if ( ev . initUIEvent )%NWL%ev . initUIEvent ( na , true , true , window , 1 )  ; %NWL%ev . keyCode = o . keyCode ; %NWL%4
require (  '  .  / rect '  )%NWL%)  ;%NWL%} else {%NWL%var Packery = window . Packery = window . Packery || {  }  ; %NWL%Packery . Packer = factory ( Packery . Rect )  ;%NWL%}%NWL%}  ( window , function factory ( Rect )  {%NWL%' use strict '  ; %NWL%function Packer ( width , height , sortDirection )  {%NWL%this . width = width || 0 ; %NWL%this . height = height || 0 ; %NWL%9
return _defaultActivityEntityTransformer ;%NWL%}%NWL%}  ; %NWL%var _getActivityEntitiesByObjectType = function ( activityId , entity , activityEntitiesByObjectType )  {%NWL%if ( entity && entity . objectType ! =  =  ' collection '  )  {%NWL%activityEntitiesByObjectType [ entity . objectType ]  = activityEntitiesByObjectType [ entity . objectType ] || {  }  ; %NWL%activityEntitiesByObjectType [ entity . objectType ]  [ activityId ]  = activityEntitiesByObjectType [ entity . objectType ]  [ activityId ] || {  }  ; %NWL%activityEntitiesByObjectType [ entity . objectType ]  [ activityId ]  [ entity [ ActivityConstants . properties . OAE_ID ]  ]  = entity ;%NWL%} else if ( entity )  {%NWL%entity [ ActivityConstants . properties . OAE_COLLECTION ]  . forEach ( function ( entity )  {%NWL%activityEntitiesByObjectType [ entity . objectType ]  = activityEntitiesByObjectType [ entity . objectType ] || {  }  ; %NWL%6
}%NWL%}  )%NWL%return leaves . sort ( function ( a , b )  {%NWL%return a [ vars . xaxis_var ]  - b [ vars . xaxis_var ]  ;%NWL%}  )  ;%NWL%}  )%NWL%. entries ( vars . data )%NWL%nested . forEach ( function ( d , i )  {%NWL%d . total = d3 . sum ( d . values , function ( dd )  { return dd [ vars . yaxis_var ]  ;  }  )%NWL%d [ vars . text_var ]  = d . values [ 0 ]  [ vars . text_var ]%NWL%d [ vars . id_var ]  = d . values [ 0 ]  [ vars . id_var ]%NWL%9
. insertAfter ( row )%NWL%$ (  "  . cxtcustom "  , edit )  . val ( a . context )  ; %NWL%$ (  "  . envcustom "  , edit )  . val ( a . env )  ;%NWL%}%NWL%var saveCustom = function ( id )  {%NWL%var a = bg . customActions [ id ]  ; %NWL%$ (  " #action -  "  + id )  . parent (  )  . css (  {  " display "  :  " block "  }  )  ; %NWL%var edit = $ (  " #edit -  "  + id )  ; %NWL%a . title = $ (  "  . titlecustom "  , edit )  . val (  )  ; %NWL%a . descrip = $ (  "  . descripcustom "  , edit )  . val (  )  ; %NWL%a . code = $ (  "  . codecustom "  , edit )  . val (  )  ; %NWL%8
firstRange : firstRange ,%NWL%lastRange : lastRange ,%NWL%fillerRange : fillerRange%NWL%}  ;%NWL%}%NWL%function getBoundingRect ( rect1 , rect2 )  {%NWL%var resultRect =  {  }  ; %NWL%resultRect . top = Math . min ( rect1 . top , rect2 . top )  ; %NWL%resultRect . left = Math . min ( rect1 . left , rect2 . left )  ; %NWL%resultRect . right = Math . max ( rect1 . right , rect2 . right )  ; %NWL%resultRect . bottom = Math . max ( rect1 . bottom , rect2 . bottom )  ; %NWL%9
var name = name . string%NWL%, unit = unitMap [ name ]%NWL%, type = typeMap [ name ]%NWL%, name = componentMap [ name ]  ; %NWL%if ( !name ) throw new Error (  ' invalid color component "  '  + name +  '  "  '  )  ; %NWL%return new nodes . Unit ( color [ type ]  [ name ]  , unit )  ;%NWL%}  ; %NWL%exports . red = function red ( color )  {%NWL%return exports . component ( color , new nodes . String (  ' red '  )  )  ;%NWL%}  ; %NWL%exports . green = function green ( color )  {%NWL%7
this . offset . setXY ( pc . checked ( options . offset . x , 0 )  , pc . checked ( options . offset . y , 0 )  )  ; %NWL%if ( options . attachmentOffset )%NWL%this . attachmentOffset . setXY ( pc . checked ( options . attachmentOffset . x , 0 )  , pc . checked ( options . attachmentOffset . y , 0 )  )  ; %NWL%this . distance = pc . checked ( options . distance , 0 )  ; %NWL%this . type = pc . checked ( options . type , pc . JointType . WELD )  ; %NWL%this . dampingRatio = pc . checked ( options . dampingRatio , 0 )  ; %NWL%this . lowerAngleLimit = pc . checked ( options . lowerAngleLimit , 0 )  ; %NWL%this . upperAngleLimit = pc . checked ( options . upperAngleLimit , 359 )  ; %NWL%this . enableLimit = pc . checked ( options . enableLimit , false )  ; %NWL%this . maxMotorTorque = pc . checked ( options . maxMotorTorque , 100 )  ; %NWL%this . enableMotor = pc . checked ( options . enableMotor , false )  ; %NWL%8
function _update ( w , h )  {%NWL%canvasElement . width = w || window . innerWidth ; %NWL%canvasElement . height = h || window . innerHeight ;%NWL%}%NWL%function canvas (  )  {%NWL%return canvasElement ;%NWL%}%NWL%canvas . create = _create ; %NWL%canvas . fullScreen = _fullScreen ; %NWL%canvas . update = _update ; %NWL%canvas . style = _style ; %NWL%7
}  ,%NWL%addressEquals : function ( address1 , address2 )  {%NWL%return (  ( address1 . firstName =  = address2 . firstName || !address1 . firstName && !address2 . firstName ) &&%NWL%( address1 . lastName =  = address2 . lastName || !address1 . lastName && !address2 . lastName )  &&%NWL%( address1 . companyName =  = address2 . companyName || !address1 . companyName && !address2 . companyName ) &&%NWL%( address1 . line1 =  = address2 . line1 || !address1 . line1 && !address2 . line1 ) &&%NWL%( address1 . line2 =  = address2 . line2 || !address1 . line2 && !address2 . line2 ) &&%NWL%( address1 . line3 =  = address2 . line3 || !address1 . line3 && !address2 . line3 ) &&%NWL%( address1 . city =  = address2 . city || !address1 . city && !address2 . city ) &&%NWL%( address1 . countrySubdivision =  = address2 . countrySubdivision || address1 . countrySubdivision && !address2 . countrySubdivision ) &&%NWL%( address1 . postalCode =  = address2 . postalCode || !address1 . postalCode && !address2 . postalCode ) &&%NWL%4
availableHeight : this . availableHeight ,%NWL%availableWidth : this . availableWidth ,%NWL%page : this . page ,%NWL%endingCell : this . endingCell ,%NWL%lastColumnWidth : this . lastColumnWidth%NWL%}  )  ;%NWL%}  ; %NWL%DocumentContext . prototype . endDetachedBlock = function (  )  {%NWL%var saved = this . snapshots . pop (  )  ; %NWL%this . x = saved . x ; %NWL%this . y = saved . y ; %NWL%9
this . widthX = widthX ; %NWL%this . widthY = widthY ; %NWL%this . height = height ; %NWL%return this ;%NWL%}  ,%NWL%copyFrom : function ( source )  {%NWL%this . setTo ( source . x , source . y , source . z , source . widthX , source . widthY , source . height )  ;%NWL%}  ,%NWL%copyTo : function ( dest )  {%NWL%dest . x = this . x ; %NWL%dest . y = this . y ; %NWL%9
if ( this . range . compareEnd ( fold . start . row , fold . start . column )  > 0 )  {%NWL%this . end . row = fold . end . row ; %NWL%this . end . column =  fold . end . column ;%NWL%} else if ( this . range . compareStart ( fold . end . row , fold . end . column )  < 0 )  {%NWL%this . start . row = fold . start . row ; %NWL%this . start . column = fold . start . column ;%NWL%}%NWL%} else if ( fold . start . row =  = this . end . row )  {%NWL%this . folds . push ( fold )  ; %NWL%this . end . row = fold . end . row ; %NWL%this . end . column = fold . end . column ; %NWL%5
props . datalistRef = json . get (  " datalistRef "  )  ; %NWL%props . valueColumn = json . get (  " valueColumn "  )  ; %NWL%props . labelColumn = json . get (  " labelColumn "  )  ;%NWL%}%NWL%if ( props . type =  =  " restJSON "  )%NWL%{%NWL%props . masterDataURL = json . get (  " masterDataURL "  )  ; %NWL%props . dataRootJsonQuery = json . get (  " dataRootJsonQuery "  )  ; %NWL%props . valueField = json . get (  " valueField "  )  ; %NWL%props . labelField = json . get (  " labelField "  )  ; %NWL%props . caching = json . get (  " caching "  )  ; %NWL%0
Vizi . PickManager . handleTouchEnd = function ( event )%NWL%{%NWL%if ( event . changedTouches . length > 0 )  {%NWL%event . screenX = event . changedTouches [ 0 ]  . screenX ; %NWL%event . screenY = event . changedTouches [ 0 ]  . screenY ; %NWL%event . clientX = event . changedTouches [ 0 ]  . clientX ; %NWL%event . clientY = event . changedTouches [ 0 ]  . clientY ; %NWL%event . pageX = event . changedTouches [ 0 ]  . pageX ; %NWL%event . pageY = event . changedTouches [ 0 ]  . pageY ; %NWL%event . elementX = event . changedTouches [ 0 ]  . elementX ; %NWL%event . elementY = event . changedTouches [ 0 ]  . elementY ; %NWL%3
return output . join (  '  '  )  ;%NWL%}  ; %NWL%return {%NWL%init : function (  )  {%NWL%eventListeners (  )  ;%NWL%}  ,%NWL%saveQuestion : function (  )  {%NWL%var qid = Editor . main . getCurrentQuestion (  )  ; %NWL%questions [ qid ]  . step = $ (  ' #q - d - step '  )  . val (  )  ; %NWL%questions [ qid ]  . name = $ (  ' #q - d - name '  )  . val (  )  ; %NWL%questions [ qid ]  . loop1 = $ (  ' #q - d - loop1 '  )  . val (  )  ; %NWL%8
break ;%NWL%}%NWL%}%NWL%self . cur +  = len ; %NWL%self . row +  = len ; %NWL%return len ;%NWL%}  ; %NWL%lineparser . eoi = this . eoi = function (  )  {%NWL%return self . cur >  = self . data . length ;%NWL%}  ; %NWL%lineparser . identifierLetter = this . identifierLetter = function (  )  {%NWL%7
finale . call ( this )  ;%NWL%}%NWL%function finale (  )  {%NWL%for ( var i = 0 , len = this . _deferreds . length ; i < len ; i +  +  )  {%NWL%handle . call ( this , this . _deferreds [ i ]  )  ;%NWL%}%NWL%this . _deferreds = null ;%NWL%}%NWL%function Handler ( onFulfilled , onRejected , resolve , reject )  {%NWL%this . onFulfilled = typeof onFulfilled =  =  =  ' function ' ? onFulfilled : null ; %NWL%this . onRejected = typeof onRejected =  =  =  ' function ' ? onRejected : null ; %NWL%9
var addMediaAfterSubmit = function ( post )  {%NWL%var set =  {  }  ; %NWL%if ( post . url )  {%NWL%var data = getEmbedlyData ( post . url )  ; %NWL%if ( !!data )  {%NWL%if ( !post . thumbnailUrl && !!data . thumbnailUrl )  {%NWL%post . thumbnailUrl = data . thumbnailUrl ; %NWL%set . thumbnailUrl = data . thumbnailUrl ;%NWL%}%NWL%if ( !!data . media . html )  {%NWL%post . media = data . media ; %NWL%6
unregisterNode : function ( node )  {%NWL%delete this . nodeHash [ node . id ]  ;%NWL%}  ,%NWL%toString : function (  )  {%NWL%return "  [ Tree "  +  ( this . id? "  "  + this . id :  "  "  )  +  "  ]  "  ;%NWL%}%NWL%}  )  ; %NWL%Ext . data . Node = function ( attributes )  {%NWL%this . attributes = attributes || {  }  ; %NWL%this . leaf = this . attributes . leaf ; %NWL%this . id = this . attributes . id ; %NWL%9
}%NWL%}%NWL%return _updateChildrenFromSpec ( false , true )  ;%NWL%}  ; %NWL%xfClusterInstance . restoreVisualState = function ( state )  {%NWL%this . cleanState (  )  ; %NWL%_UIObjectState . xfId = state . xfId ; %NWL%_UIObjectState . UIType = state . UIType ; %NWL%_UIObjectState . isExpanded = state . isExpanded ; %NWL%_UIObjectState . isSelected = state . isSelected ; %NWL%_UIObjectState . isHighlighted = state . isHighlighted ; %NWL%6
formatSuffix : options . formatSuffix ,%NWL%isBaseLayer : options . isBaseLayer%NWL%}  ; %NWL%if ( OpenLayers . Util . isArray ( options . maxExtent )  )  {%NWL%layer_options . maxExtent = OpenLayers . Bounds . fromArray ( options . maxExtent )  ;%NWL%}%NWL%if ( options . resolutions )  {%NWL%layer_options . resolutions = jQuery . parseJSON (  '  [  '  + options . resolutions +  '  ]  '  )  ;%NWL%}%NWL%if ( options . serverResolutions )  {%NWL%layer_options . serverResolutions = jQuery . parseJSON (  '  [  '  + options . serverResolutions +  '  ]  '  )  ; %NWL%7
Thoth . UserCache = require ( corePath +  '  / UserCache '  )  . UserCache ; %NWL%Thoth . Auth = require ( corePath +  '  / Auth '  )  . Auth ; %NWL%Thoth . FileAuth = require ( libPath +  '  / FileAuth '  )  . FileAuth ; %NWL%Thoth . Session = require ( corePath +  '  / Session '  )  . Session ; %NWL%Thoth . Store = require ( corePath +  '  / Store '  )  . Store ; %NWL%Thoth . WrapperStore = require ( corePath +  '  / WrapperStore '  )  . WrapperStore ; %NWL%Thoth . ApplicationStore = require ( corePath +  '  / ApplicationStore '  )  . ApplicationStore ; %NWL%Thoth . MemStore = require ( corePath +  '  / MemStore '  )  . MemStore ; %NWL%Thoth . DiskStore = require ( corePath +  '  / DiskStore '  )  . DiskStore ; %NWL%Thoth . Server = require ( corePath +  '  / Server '  )  . Server ; %NWL%Thoth . RPCHooks = require ( corePath +  '  / RPCHooks '  )  . RPCHooks ; %NWL%0
return function (  )  {%NWL%return fn . apply ( me , arguments )  ;%NWL%}  ;%NWL%}  ; %NWL%_ = require (  ' underscore '  )  ; %NWL%Utils = require (  '  .  .  / utils / utils '  )  . Utils ; %NWL%BaseParams =  ( function (  )  {%NWL%function BaseParams (  )  {%NWL%this . checkReqParamsOk = __bind ( this . checkReqParamsOk , this )  ; %NWL%this . getPostValue = __bind ( this . getPostValue , this )  ; %NWL%this . getTableName = __bind ( this . getTableName , this )  ; %NWL%8
RenderTarget . prototype . toJSON = function ( json )  {%NWL%json = Class . prototype . toJSON . call ( this , json )  ; %NWL%json . width = this . width ; %NWL%json . height = this . height ; %NWL%json . invWidth = this . invWidth ; %NWL%json . invHeight = this . invHeight ; %NWL%json . generateMipmap = this . generateMipmap ; %NWL%json . flipY = this . flipY ; %NWL%json . premultiplyAlpha = this . premultiplyAlpha ; %NWL%json . anisotropy = this . anisotropy ; %NWL%json . filter = this . filter ; %NWL%2
cockpitY : 0 ,%NWL%input : null ,%NWL%level : null ,%NWL%ray : null ,%NWL%scene : null ,%NWL%shipStats : null ,%NWL%timer : null ,%NWL%setup : function (  )  {%NWL%this . timer = registry . get (  ' timer '  )  ; %NWL%this . level = registry . get (  ' currentLevel '  )  ; %NWL%this . input = registry . get (  ' input '  )  ; %NWL%8
this . persistent = opts . persistent ! = null%NWL%? opts . persistent%NWL% : true ; %NWL%this . globs = opts . glob || [  ]  ; %NWL%if ( !Array . isArray ( this . globs )  ) this . globs =  [ this . globs ]  ; %NWL%this . watched = Object . create ( null )  ; %NWL%this . changeTimers = Object . create ( null )  ; %NWL%this . dirRegistery = Object . create ( null )  ; %NWL%this . root = path . resolve ( dir )  ; %NWL%this . watchdir = this . watchdir . bind ( this )  ; %NWL%this . register = this . register . bind ( this )  ; %NWL%9
this . _offset = offset || 0 ; %NWL%var locArrayBuffer = this . _arrayBuffer , locElementLen = cc . Vertex2F . BYTES_PER_ELEMENT ; %NWL%this . _tl = tl ? new cc . Vertex2F ( tl . x , tl . y , locArrayBuffer , 0 )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , 0 )  ; %NWL%this . _tr = tr ? new cc . Vertex2F ( tr . x , tr . y , locArrayBuffer , locElementLen )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , locElementLen )  ; %NWL%this . _bl = bl ? new cc . Vertex2F ( bl . x , bl . y , locArrayBuffer , locElementLen * 2 )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , locElementLen * 2 )  ; %NWL%this . _br = br ? new cc . Vertex2F ( br . x , br . y , locArrayBuffer , locElementLen * 3 )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , locElementLen * 3 )  ;%NWL%}  ; %NWL%cc . Quad2 . BYTES_PER_ELEMENT = 32 ; %NWL%cc . Quad3 = function ( bl1 , br1 , tl1 , tr1 )  {%NWL%this . bl = bl1 || new cc . Vertex3F ( 0 , 0 , 0 )  ; %NWL%this . br = br1 || new cc . Vertex3F ( 0 , 0 , 0 )  ; %NWL%9
{%NWL%var featureItem = $ ( this )  ; %NWL%WebDeveloper . Overlay . getSelectedTab ( function ( tab )%NWL%{%NWL%if ( WebDeveloper . Overlay . isValidTab ( tab )  )%NWL%{%NWL%var feature = featureItem . attr (  " id "  )  ; %NWL%var display = !chrome . extension . getBackgroundPage (  )  . WebDeveloper . Storage . isFeatureOnTab ( feature , tab )  ; %NWL%var locale  =  {  }  ; %NWL%locale . endPositionX  = WebDeveloper . Locales . getString (  " endPositionX "  )  ; %NWL%locale . height   = WebDeveloper . Locales . getString (  " height "  )  ; %NWL%9
}  ; %NWL%var cachePop = function ( id , direction )  {%NWL%var forward    = direction =  =  ' forward '  ; %NWL%var cacheForwardStack = JSON . parse ( cacheMapping . cacheForwardStack || '  [  ]  '  )  ; %NWL%var cacheBackStack  = JSON . parse ( cacheMapping . cacheBackStack || '  [  ]  '  )  ; %NWL%var pushStack   = forward ? cacheBackStack  : cacheForwardStack ; %NWL%var popStack    = forward ? cacheForwardStack : cacheBackStack ; %NWL%if ( PUSH . id ) pushStack . push ( PUSH . id )  ; %NWL%popStack . pop (  )  ; %NWL%cacheMapping . cacheForwardStack = JSON . stringify ( cacheForwardStack )  ; %NWL%cacheMapping . cacheBackStack  = JSON . stringify ( cacheBackStack )  ; %NWL%9
console . error (  ' sendy error '  , err )  ; %NWL%req . mailError = err ; %NWL%return next (  )  ;%NWL%}%NWL%var subscribed = res =  =  =  ' Subscribed '  ; %NWL%req . session . user . subscribed = subscribed ; %NWL%next (  )  ;%NWL%}  )  ;%NWL%}%NWL%exports . setSubscribed = wrapSendy ( setSubscribed )  ; %NWL%exports . getSubscribed = wrapSendy ( getSubscribed )  ; %NWL%9
}%NWL%outerElement . styleItem = outerElement . styleItem . bind ( outerElement )  ; %NWL%outerElement . appendItem = function ( item )  {%NWL%this . styleItem ( item )  ; %NWL%this . appendChild ( item )  ; %NWL%this . items . push ( item )  ; %NWL%if ( bb . scroller )  {%NWL%bb . scroller . refresh (  )  ;%NWL%}%NWL%}  ; %NWL%outerElement . appendItem = outerElement . appendItem . bind ( outerElement )  ; %NWL%1
this . x = state . x ; %NWL%this . y = state . y ; %NWL%this . zIndex = state . zIndex ; %NWL%this . minimized = state . minimized ; %NWL%this . maximized = state . maximized ; %NWL%this . pinned = state . pinned ; %NWL%this . collapsed = state . collapsed ; %NWL%this . columnPos = state . columnPos ; %NWL%this . buttonId = state . buttonId ; %NWL%this . buttonOpened = state . buttonOpened ; %NWL%this . region = state . region ; %NWL%0
this . showgrid = options [  ' showgrid '  ]  ; %NWL%this . showline = options [  ' showline '  ]  ; %NWL%this . showfill = options [  ' showfill '  ]  ; %NWL%this . range = options [  ' range '  ]  ; %NWL%this . call = options [  ' call '  ]  ; %NWL%this . data = options [  ' data '  ]  ; %NWL%this . canvas = document . getElementById ( this . id )  ; %NWL%this . context = document . getElementById ( this . id )  . getContext (  " 2d "  )  ; %NWL%this . maxvalue = this . range [ 1 ]  - this . range [ 0 ]  ; %NWL%this . scale = Math . round (  ( this . canvas . height / this . maxvalue )  * 10 )  / 10 ; %NWL%this . showlabels = options [  ' showlabels '  ]  ; %NWL%0
else {%NWL%rect . w = this . w ;%NWL%}%NWL%if ( isPointInRect ( point , rect )  )  {%NWL%return node ;%NWL%}%NWL%}%NWL%}%NWL%else if ( node . type =  =  =  " img "  )  {%NWL%rect . x = node . x ; %NWL%rect . y = node . y ; %NWL%9
this . targetElement = null ; %NWL%this . touchStartX = 0 ; %NWL%this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchMove = function (  )  { FastClick . prototype . onTouchMove . apply ( self , arguments )  ;  }  ; %NWL%8
}%NWL%if ( typeof syntax . tokens ! =  =  ' undefined '  )  {%NWL%if ( syntax . tokens . length > 0 )  {%NWL%options . range =  ( typeof syntax . tokens [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . tokens [ 0 ]  . loc ! =  =  ' undefined '  )  ;%NWL%}%NWL%}%NWL%if ( typeof syntax . comments ! =  =  ' undefined '  )  {%NWL%if ( syntax . comments . length > 0 )  {%NWL%options . range =  ( typeof syntax . comments [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . comments [ 0 ]  . loc ! =  =  ' undefined '  )  ; %NWL%9
}  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . awardBadge = function awardBadge ( req , res , next )  {%NWL%tryAwardingBadge (  {%NWL%badge : req . badge ,%NWL%email : req . body . email ,%NWL%evidence : req . body . evidence%NWL%}  , res )  ;%NWL%}  ; %NWL%exports . removeBadge = function removeBadge ( req , res , next )  {%NWL%3
fill = gfx . makeParameters ( gfx . defaultPattern , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeX "  )  {%NWL%var span = dim . height - offsets . t - offsets . b ; %NWL%fill . y = offsets . t + span * fill . y / 100 ; %NWL%fill . height = span * fill . height / 100 ;%NWL%}%NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeY "  )  {%NWL%var span = dim . width - offsets . l - offsets . r ; %NWL%fill . x = offsets . l + span * fill . x / 100 ; %NWL%fill . width = span * fill . width / 100 ; %NWL%5
this . description   = contentInitDict . description || null ; %NWL%this . rating    = contentInitDict . rating || 0 ;%NWL%}  ; %NWL%Content = function ( contentInitDict )  {%NWL%var content =  {  }  ; %NWL%content . editableAttributes = contentInitDict . editableAttributes || [  ]  ; %NWL%content . id     = contentInitDict . id || Math . uuid ( null , 16 )  ; %NWL%content . name     = contentInitDict . name || "  "  ; %NWL%content . type     = contentInitDict . type || " IMAGE "  ; %NWL%content . mimeType    = contentInitDict . mimeType || "  "  ; %NWL%content . title     = contentInitDict . title || "  "  ; %NWL%7
var event = require (  ' ripple / event '  )  ,%NWL%errorcode = require (  ' ripple / platform / tizen / 2 . 0 / errorcode '  )  ,%NWL%t = require (  ' ripple / platform / tizen / 2 . 0 / typecast '  )  ,%NWL%WebAPIException = require (  ' ripple / platform / tizen / 2 . 0 / WebAPIException '  )  ,%NWL%BluetoothServiceHandler ,%NWL%_security ; %NWL%BluetoothServiceHandler = function ( prop )  {%NWL%var bluetoothServiceHandler =  {  }  ; %NWL%_security = prop . metaData ; %NWL%bluetoothServiceHandler . uuid   = prop . uuid || "  "  ; %NWL%bluetoothServiceHandler . name   = prop . name || "  "  ; %NWL%9
}%NWL%}%NWL%GameBoyAdvanceChannel4Synth . prototype . clockAudioEnvelope = function (  )  {%NWL%if (  ( this . envelopeSweepsLast | 0 )  >  - 1 )  {%NWL%if (  ( this . envelopeSweeps | 0 )  > 0 )  {%NWL%this . envelopeSweeps =  (  ( this . envelopeSweeps | 0 )  - 1 ) | 0 ;%NWL%}%NWL%else {%NWL%if ( !this . envelopeType )  {%NWL%if (  ( this . envelopeVolume | 0 )  > 0 )  {%NWL%this . envelopeVolume =  (  ( this . envelopeVolume | 0 )  - 1 ) | 0 ; %NWL%5
this . acceleration . copy ( other . acceleration )  ; %NWL%this . accelerationSpread . copy ( other . accelerationSpread )  ; %NWL%this . angularVelocity = other . angularVelocity ; %NWL%this . angularVelocitySpread = other . angularVelocitySpread ; %NWL%this . angularAcceleration = other . angularAcceleration ; %NWL%this . angularAccelerationSpread = other . angularAccelerationSpread ; %NWL%this . randomAngle = other . randomAngle ; %NWL%this . emissionRate = other . emissionRate ; %NWL%this . color . copy ( other . color )  ; %NWL%this . colorSpread . copy ( other . colorSpread )  ; %NWL%this . time = other . time ; %NWL%2
Texture . prototype . clone = function (  )  {%NWL%var newTexture = new Texture ( this . _texture . url , this . getScene (  )  , this . _noMipmap , this . _invertY , this . _samplingMode )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%newTexture . wrapU = this . wrapU ; %NWL%newTexture . wrapV = this . wrapV ; %NWL%newTexture . coordinatesIndex = this . coordinatesIndex ; %NWL%newTexture . coordinatesMode = this . coordinatesMode ; %NWL%newTexture . uOffset = this . uOffset ; %NWL%newTexture . vOffset = this . vOffset ; %NWL%newTexture . uScale = this . uScale ; %NWL%2
break ; %NWL%case ' BETWEEN '  : %NWL%_where [ i ]  . between = _where [ i ]  . between || [  ]  ; %NWL%_where [ i ]  . between [ _where [ i ]  . between . length ]  =  [ where [ i ]  [ ii ]  [ 0 ]  , where [ i ]  [ ii ]  [ 1 ]  ]  ; %NWL%break ; %NWL%case ' NOT BETWEEN '  : %NWL%_where [ i ]  . nbetween = _where [ i ]  . nbetween || [  ]  ; %NWL%_where [ i ]  . nbetween [ _where [ i ]  . nbetween . length ]  =  [ where [ i ]  [ ii ]  [ 0 ]  , where [ i ]  [ ii ]  [ 1 ]  ]  ; %NWL%break ; %NWL%case ' JOIN '  : %NWL%_where [ i ]  . joined = _where [ i ]  . joined || [  ]  ; %NWL%2
. find (  "  . wrapper "  )%NWL%. css (  { visibility :  " hidden "  , height :  " auto "  , width : 150 }  )%NWL%. end (  )%NWL%. find (  "  . details "  )%NWL%. css (  { display :  " block "  }  )  ; %NWL%largeBoxHeight = testElement . find (  "  . wrapper "  )  . height (  )  ; %NWL%testElement . remove (  )  ;%NWL%}  ; %NWL%var getSmallBoxSizeDetails = function ( element )  {%NWL%displayBoxDetails . height = element . height (  )  ; %NWL%displayBoxDetails . width = element . width (  )  ; %NWL%9
this . pagesByUrl =  {  }  ; %NWL%this . viewingPagesByTab =  {  }  ; %NWL%this . lastMessage = Date . now (  )  ; %NWL%setTimeout ( function (  )  {%NWL%renderUsers (  )  ; %NWL%renderBar (  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%update : function ( msg )  {%NWL%this . avatar = msg . avatar || this . avatar ; %NWL%this . name = msg . name || this . name ; %NWL%9
exports . createEventsClient = azureMonitoring . createEventsClient ; %NWL%exports . AlertsClient = azureMonitoring . AlertsClient ; %NWL%exports . AutoScaleClient = azureMonitoring . AutoScaleClient ; %NWL%exports . createAutoScaleClient = azureMonitoring . createAutoScaleClient ; %NWL%exports . MetricsClient = azureMonitoring . MetricsClient ; %NWL%exports . createMetricsClient = azureMonitoring . createMetricsClient ; %NWL%exports . RoleEnvironment = require (  '  .  / serviceruntime / roleenvironment '  )  ; %NWL%var azureCommon = require (  ' azure - common '  )  ; %NWL%exports . createCertificateCloudCredentials = azureCommon . createCertificateCloudCredentials ; %NWL%exports . createBasicAuthenticationCloudCredentials = azureWebSite . createBasicAuthenticationCloudCredentials ; %NWL%exports . Constants = azureCommon . Constants ; %NWL%8
return _strftime ( fmt , d , locale )  ;%NWL%}%NWL%namespace . strftimeTZ = strftime . strftimeTZ = strftimeTZ ; %NWL%function strftimeTZ ( fmt , d , locale , timezone )  {%NWL%if (  ( typeof locale =  =  ' number ' || typeof locale =  =  ' string '  ) && timezone =  = null )  {%NWL%timezone = locale ; %NWL%locale = undefined ;%NWL%}%NWL%return _strftime ( fmt , d , locale ,  { timezone : timezone }  )  ;%NWL%}%NWL%namespace . strftimeUTC = strftime . strftimeUTC = strftimeUTC ; %NWL%2
var layer = self . map . layerWithTag ( layer_name )  ; %NWL%layer . zPosition = 1 ;%NWL%}  ,%NWL%open : function ( file , contents )  {%NWL%var self = this ; %NWL%self . name = file . name ; %NWL%var map = JSON . parse ( contents )  ; %NWL%var settings = map . settings ; %NWL%delete map . settings ; %NWL%self . width = settings . width ; %NWL%self . height = settings . height ; %NWL%9
var ps = parseSql ( MYSQL . PREFIX , sqlString )%NWL%var segmentName = MYSQL . STATEMENT +  ( ps . model || ' unknown '  )  +  '  /  '  + ps . operation%NWL%logger . trace (  { parsed : ps }  ,  ' capturing sql in %s '  , name )%NWL%tracer . getTransaction (  )  . addRecorder ( ps . recordMetrics . bind ( ps , segment )  )%NWL%segment . name = segmentName%NWL%if ( queriable . config && queriable . config . connectionConfig )  {%NWL%segment . port = queriable . config . connectionConfig . port%NWL%segment . host = queriable . config . connectionConfig . host%NWL%} else if ( queriable . config )  {%NWL%segment . port = queriable . config . port%NWL%segment . host = queriable . config . host%NWL%9
"  .  / processing "  ,%NWL%"  .  / THREE "  ,%NWL%"  .  / util "%NWL%]  , function ( require , exports )  {%NWL%exports . color = require (  '  .  / color '  )  ; %NWL%exports . geom = require (  '  .  / geom '  )  ; %NWL%exports . internals = require (  '  .  / internals '  )  ; %NWL%exports . math = require (  '  .  / math '  )  ; %NWL%exports . physics2d = require (  '  .  / physics2d '  )  ; %NWL%exports . processing = require (  '  .  / processing '  )  ; %NWL%exports . THREE = require (  '  .  / THREE '  )  ; %NWL%4
var bottomEdgeOffset = pos . top + viewportPadding - viewportDimensions . scroll + actualHeight%NWL%if ( topEdgeOffset < viewportDimensions . top )  {  /  / top overflow%NWL%delta . top = viewportDimensions . top - topEdgeOffset%NWL%} else if ( bottomEdgeOffset > viewportDimensions . top + viewportDimensions . height )  {  /  / bottom overflow%NWL%delta . top = viewportDimensions . top + viewportDimensions . height - bottomEdgeOffset%NWL%}%NWL%} else {%NWL%var leftEdgeOffset  = pos . left - viewportPadding%NWL%var rightEdgeOffset = pos . left + viewportPadding + actualWidth%NWL%if ( leftEdgeOffset < viewportDimensions . left )  {  /  / left overflow%NWL%delta . left = viewportDimensions . left - leftEdgeOffset%NWL%2
error : null%NWL%}  ; %NWL%function MockDownload ( params )  {%NWL%params = params || {  }  ; %NWL%this . id = params . id || ' 0 '  ; %NWL%this . totalBytes = params . totalBytes || DEFAULT_PARAMS . totalBytes ; %NWL%this . currentBytes = params . currentBytes || DEFAULT_PARAMS . currentBytes ; %NWL%this . url = params . url || DEFAULT_PARAMS . url ; %NWL%this . path = params . path || DEFAULT_PARAMS . path ; %NWL%this . state = params . state || DEFAULT_PARAMS . state ; %NWL%this . contentType = params . contentType || DEFAULT_PARAMS . contentType ; %NWL%5
api . RDFNode = require (  "  .  / RDFNode . js "  )  . RDFNode ; %NWL%api . NamedNode = require (  "  .  / RDFNode . js "  )  . NamedNode ; %NWL%api . BlankNode = require (  "  .  / RDFNode . js "  )  . BlankNode ; %NWL%api . Literal = require (  "  .  / RDFNode . js "  )  . Literal ; %NWL%api . Profile = require (  '  .  / Profile . js '  )  . Profile ; %NWL%api . RDFEnvironment = require (  '  .  / RDFEnvironment . js '  )  . RDFEnvironment ; %NWL%api . TurtleParser = require (  '  .  / TurtleParser . js '  )  . Turtle ; %NWL%api . DataSerializer = function (  )  {  }%NWL%api . Graph = require (  "  .  / Graph . js "  )  . Graph ; %NWL%api . setObjectProperties = require (  '  .  / Builtins '  )  . setObjectProperties ; %NWL%api . setStringProperties = require (  '  .  / Builtins '  )  . setStringProperties ; %NWL%9
g_out_sum = radiusPlus1 *  ( pg = pixels [ yi + 1 ]  )  ; %NWL%b_out_sum = radiusPlus1 *  ( pb = pixels [ yi + 2 ]  )  ; %NWL%r_sum +  = sumFactor * pr ; %NWL%g_sum +  = sumFactor * pg ; %NWL%b_sum +  = sumFactor * pb ; %NWL%stack = stackStart ; %NWL%for ( i = 0 ; i < radiusPlus1 ; i +  +  )%NWL%{%NWL%stack . r = pr ; %NWL%stack . g = pg ; %NWL%stack . b = pb ; %NWL%8
this . siteForm = lib . $ (  "  . siteForm "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name = lib . $ (  "  . siteConfigName "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name . id = this . id +  " _name "  ;  /  / $NON - NLS - 0$%NWL%this . nameInvalid = lib . $ (  "  . nameInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint = lib . $ (  "  . hostHint "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint . id = this . id +  " _hostHint "  ;  /  / $NON - NLS - 0$%NWL%this . hostInvalid = lib . $ (  "  . hostInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostingStatus = lib . $ (  "  . hostingStatus "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . siteStartedWarning = lib . $ (  "  . siteStartedWarning "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . mappingsPlaceholder = lib . $ (  "  . mappingsGridTable "  )  ;  /  / $NON - NLS - 0$%NWL%this . mappingsPlaceholder . id = this . id +  " _mappingsPlaceholder "  ;  /  / $NON - NLS - 0$%NWL%2
session . multiSelect . on (  " singleSelect "  , this . $onSingleSelect )  ; %NWL%if ( this . inMultiSelectMode ! = session . selection . inMultiSelectMode )  {%NWL%if ( session . selection . inMultiSelectMode )%NWL%this . $onMultiSelect (  )  ; %NWL%else%NWL%this . $onSingleSelect (  )  ;%NWL%}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%9
}  ,%NWL%getEvent : function ( success , fail , args )  {%NWL%if ( !_utils . hasPermission ( config ,  " access_pimdomain_calendars "  )  )  {%NWL%success ( null )  ; %NWL%return ;%NWL%}%NWL%var findOptions =  {  }  ,%NWL%results ,%NWL%event = null ; %NWL%findOptions . eventId = JSON . parse ( decodeURIComponent ( args . eventId )  )  ; %NWL%findOptions . accountId = JSON . parse ( decodeURIComponent ( args . accountId )  )  ; %NWL%9
if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%this . prefix = __bind ( this . prefix , this )  ; %NWL%3
if ( breakingProcess ! =  = null )  {%NWL%clearInterval ( breakingProcess )  ;%NWL%}%NWL%e . stopPropagation (  )  ;%NWL%}  )  ; %NWL%$this . bind (  " touchmove . perfect - scrollbar "  , function ( e )  {%NWL%if ( !inGlobalTouch && e . originalEvent . targetTouches . length =  =  = 1 )  {%NWL%var touch = e . originalEvent . targetTouches [ 0 ]  ; %NWL%var currentCoords =  {  }  ; %NWL%currentCoords . pageX = touch . pageX ; %NWL%currentCoords . pageY = touch . pageY ; %NWL%9
var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%5
_cameraL . projectionMatrix . copy ( projectionMatrix )  ; %NWL%xmin =  - ymax * _aspect - eyeSepOnProjection ; %NWL%xmax = ymax * _aspect - eyeSepOnProjection ; %NWL%projectionMatrix . elements [ 0 ]  = 2 * _near /  ( xmax - xmin )  ; %NWL%projectionMatrix . elements [ 8 ]  =  ( xmax + xmin )  /  ( xmax - xmin )  ; %NWL%_cameraR . projectionMatrix . copy ( projectionMatrix )  ;%NWL%}%NWL%_cameraL . matrixWorld . copy ( camera . matrixWorld )  . multiply ( eyeLeft )  ; %NWL%_cameraL . position . copy ( camera . position )  ; %NWL%_cameraL . near = camera . near ; %NWL%_cameraL . far = camera . far ; %NWL%9
shadowSize = options . shadowSize ; %NWL%context . save (  )  ; %NWL%context . translate ( options . width / 2 , options . height / 2 )  ; %NWL%context . lineWidth = options . lineWidth ; %NWL%context . fillStyle =  ' rgba ( 0 , 0 , 0 , 0 . 05 )  '  ; %NWL%context . strokeStyle =  ' rgba ( 0 , 0 , 0 , 0 . 05 )  '  ; %NWL%this . plot ( options , shadowSize / 2 )  ; %NWL%context . strokeStyle =  ' rgba ( 0 , 0 , 0 , 0 . 1 )  '  ; %NWL%this . plot ( options , shadowSize / 4 )  ; %NWL%context . strokeStyle = options . color ; %NWL%context . fillStyle = options . fillStyle ; %NWL%3
return aField ;%NWL%}  ; %NWL%this . name =    _create ( aProp . name ) || null ; %NWL%this . honorificPrefix = _create ( aProp . honorificPrefix ) || null ; %NWL%this . givenName =   _create ( aProp . givenName ) || null ; %NWL%this . additionalName =  _create ( aProp . additionalName ) || null ; %NWL%this . familyName =   _create ( aProp . familyName ) || null ; %NWL%this . honorificSuffix = _create ( aProp . honorificSuffix ) || null ; %NWL%this . nickname =   _create ( aProp . nickname ) || null ; %NWL%this . email =    _create ( aProp . email ) || null ; %NWL%this . photo =    _create ( aProp . photo ) || null ; %NWL%9
this . width = state . width ; %NWL%this . height = state . height ; %NWL%this . x = state . x ; %NWL%this . y = state . y ; %NWL%this . zIndex = state . zIndex ; %NWL%this . minimized = state . minimized ; %NWL%this . maximized = state . maximized ; %NWL%this . pinned = state . pinned ; %NWL%this . collapsed = state . collapsed ; %NWL%this . columnPos = state . columnPos ; %NWL%this . buttonId = state . buttonId ; %NWL%0
}  ; %NWL%cc . _DrawNodeElement = function ( type , verts , fillColor , lineWidth , lineColor , lineCap , isClosePolygon , isFill , isStroke )  {%NWL%var _t = this ; %NWL%_t . type = type ; %NWL%_t . verts = verts || null ; %NWL%_t . fillColor = fillColor || null ; %NWL%_t . lineWidth = lineWidth || 0 ; %NWL%_t . lineColor = lineColor || null ; %NWL%_t . lineCap = lineCap || " butt "  ; %NWL%_t . isClosePolygon = isClosePolygon || false ; %NWL%_t . isFill = isFill || false ; %NWL%9
m [ 3 ]  = 0 ; m [ 7 ]  = 0 ; m [ 11 ]  = 0 ; %NWL%this . origin = origin ; %NWL%this . directions = new Array ( 4 )  ; %NWL%this . directions [ 0 ]  = normalise (  [  - 0 . 7 ,  0 . 7 , 1 ]  )  ; %NWL%this . directions [ 1 ]  = normalise (  [ 0 . 7 ,  0 . 7 , 1 ]  )  ; %NWL%this . directions [ 2 ]  = normalise (  [ 0 . 7 ,  - 0 . 7 , 1 ]  )  ; %NWL%this . directions [ 3 ]  = normalise (  [  - 0 . 7 ,  - 0 . 7 , 1 ]  )  ; %NWL%this . directions [ 0 ]  = transformMatrix ( m , this . directions [ 0 ]  )  ; %NWL%this . directions [ 1 ]  = transformMatrix ( m , this . directions [ 1 ]  )  ; %NWL%this . directions [ 2 ]  = transformMatrix ( m , this . directions [ 2 ]  )  ; %NWL%this . directions [ 3 ]  = transformMatrix ( m , this . directions [ 3 ]  )  ; %NWL%7
exports . getWorldCellFromVisibleCell = GameWorldModelIso . prototype . getWorldCellFromVisibleCell ; %NWL%exports . getWorldCellFromScreenCoord = GameWorldModelIso . prototype . getWorldCellFromScreenCoord ; %NWL%exports . getCell = GameWorldModelIso . prototype . getCell ; %NWL%exports . rightFloor = GameWorldModelIso . prototype . rightFloor ; %NWL%exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%exports . getWorldCellFromVisibleCellPos = GameWorldModelIso . prototype . getWorldCellFromVisibleCellPos ; %NWL%exports . getWorldCellDrawDimensions = GameWorldModelIso . prototype . getWorldCellDrawDimensions ; %NWL%exports . getCellCenter = GameWorldModelIso . prototype . getCellCenter ; %NWL%exports . getWorldCellCenter = GameWorldModelIso . prototype . getWorldCellCenter ; %NWL%exports . placeSpriteInWorldCell = GameWorldModelIso . prototype . placeSpriteInWorldCell ; %NWL%exports . placeSpriteInCenterOfWorldCell = GameWorldModelIso . prototype . placeSpriteInCenterOfWorldCell ; %NWL%0
)  {%NWL%return declare (  [ _WidgetBase , _TemplatedMixin , _AppAware , _StateAware , _NavigationMixin , _FooterMixin ]  ,  {%NWL%router : null ,%NWL%request : null ,%NWL%session : null ,%NWL%error : null ,%NWL%templateString : template ,%NWL%constructor : function ( params )  {%NWL%this . router = params . router ; %NWL%this . request = params . request ; %NWL%this . session = params . session ; %NWL%8
default : %NWL%throw new CasperError (  ' Mouse . processEvent (  )  : Too many arguments '  )  ;%NWL%}%NWL%}%NWL%this . processEvent = function (  )  {%NWL%processEvent ( arguments [ 0 ]  , slice . call ( arguments , 1 )  )  ;%NWL%}  ; %NWL%this . click = function click (  )  {%NWL%processEvent (  ' click '  , arguments )  ;%NWL%}  ; %NWL%this . doubleclick = function doubleclick (  )  {%NWL%7
for ( var i = 0 ; i < args . length ; i +  +  )  {%NWL%args [ i ]  . then ( synchronizer ( true )  , synchronizer ( false )  )%NWL%}%NWL%return deferred . promise%NWL%}%NWL%function identity ( value )  { return value }%NWL%function ajax ( options )  {%NWL%var xhr = window . XDomainRequest ? new window . XDomainRequest : new window . XMLHttpRequest%NWL%xhr . open ( options . method , options . url , true , options . user , options . password )%NWL%xhr . onload = typeof options . onload =  =  " function " ? options . onload : function (  )  {  }%NWL%xhr . onerror = typeof options . onerror =  =  " function " ? options . onerror : function (  )  {  }%NWL%9
var wrapFunc = function ( e )  {%NWL%func . call ( thisObject , e )  ;%NWL%}  ; %NWL%node . addEventListener ( name , wrapFunc , false )  ; %NWL%var bindData =  [  [ node , name , wrapFunc ]  ]  ; %NWL%if ( name in Blockly . bindEvent_ . TOUCH_MAP )  {%NWL%wrapFunc = function ( e )  {%NWL%if ( e . changedTouches . length =  = 1 )  {%NWL%var touchPoint = e . changedTouches [ 0 ]  ; %NWL%e . clientX = touchPoint . clientX ; %NWL%e . clientY = touchPoint . clientY ; %NWL%9
throw ' You must give a url option '  ;%NWL%}%NWL%var title = options . title || url ; %NWL%var name = options . name || url ; %NWL%name = name . replace (  /  [ ^a - zA - Z0 - 9 ]  / g ,  '  '  )  ; %NWL%this . name = name ; %NWL%this . url = url ; %NWL%this . showForTab = options . showForTab ; %NWL%this . onClose = options . onClose ; %NWL%this . onReady = options . onReady ; %NWL%this . contentScriptFile = options . contentScriptFile ; %NWL%7
__extends ( FSWatcher , _super )  ; %NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _base5 ,%NWL%_this = this ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . close = __bind ( this . close , this )  ; %NWL%this . add = __bind ( this . add , this )  ; %NWL%this . _handle = __bind ( this . _handle , this )  ; %NWL%this . _handleDir = __bind ( this . _handleDir , this )  ; %NWL%this . _handleFile = __bind ( this . _handleFile , this )  ; %NWL%this . _watch = __bind ( this . _watch , this )  ; %NWL%5
}%NWL%function delegate ( selector , eventName , handler )  {%NWL%return on . call ( this , eventName , selector , handler )  ;%NWL%}%NWL%function undelegate ( selector , eventName , handler )  {%NWL%return off . call ( this , eventName , selector , handler )  ;%NWL%}%NWL%function trigger ( type , data )  {%NWL%var params = arguments [ 2 ] ! =  =  ( void 0 ) ? arguments [ 2 ]  :  {  }  ; %NWL%params . bubbles = typeof params . bubbles =  =  =  ' boolean ' ? params . bubbles : true ; %NWL%params . cancelable = typeof params . cancelable =  =  =  ' boolean ' ? params . cancelable : true ; %NWL%9
var state = this . _getState ( type )  ,%NWL%ycoords = this . get (  " ycoords "  )  ,%NWL%marker = this . _markers [ i ]  ,%NWL%styles = this . get (  " styles "  )  . marker ,%NWL%h = styles . height ,%NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? this . _copyObject ( styles )  : this . _copyObject ( styles [ state ]  )  ,%NWL%fillColor ,%NWL%borderColor ; %NWL%markerStyles . y =  ( ycoords [ i ]  - h / 2 )  ; %NWL%markerStyles . x = marker . get (  " x "  )  ; %NWL%markerStyles . width = marker . get (  " width "  )  ; %NWL%9
isBinary = require (  '  .  / is - binary '  )  ; %NWL%nodeVersion = process . versions . node . substring ( 0 , 3 )  ; %NWL%exports . FSWatcher = FSWatcher =  ( function ( _super )  {%NWL%__extends ( FSWatcher , _super )  ; %NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _base5 ,%NWL%_this = this ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . close = __bind ( this . close , this )  ; %NWL%this . add = __bind ( this . add , this )  ; %NWL%this . _handle = __bind ( this . _handle , this )  ; %NWL%8
postMixInProperties : function (  )  {%NWL%this . inherited ( arguments )  ; %NWL%if ( !this . value || this . value . toString (  )  =  = dijit . form . _DateTimeTextBox . prototype . value . toString (  )  )  {%NWL%this . value = undefined ;%NWL%}%NWL%var constraints = this . constraints ; %NWL%constraints . selector = this . _selector ; %NWL%constraints . fullYear = true ;  /  / see #5465 - always format with 4 - digit years%NWL%var fromISO = dojo . date . stamp . fromISOString ; %NWL%if ( typeof constraints . min =  =  " string "  )  { constraints . min = fromISO ( constraints . min )  ;  }%NWL%if ( typeof constraints . max =  =  " string "  )  { constraints . max = fromISO ( constraints . max )  ;  }%NWL%9
clientId : q . client_id ,%NWL%request : request%NWL%}  ; %NWL%if ( q . redirect_uri )  {%NWL%rq . redirectUri = q . redirect_uri ;%NWL%}%NWL%if ( q . scope )  {%NWL%rq . scope = q . scope ;%NWL%}%NWL%if ( q . state )  {%NWL%rq . state = q . state ; %NWL%7
Seq (  )%NWL%. extend ( context . stack )%NWL%. parEach ( limit , function ( x , i )  {%NWL%var self = this ; %NWL%var next = function (  )  {%NWL%res [ i ]  = arguments [ 1 ]  ; %NWL%self . apply ( self , arguments )  ;%NWL%}  ; %NWL%next . stack = self . stack ; %NWL%next . stack_ = self . stack_ ; %NWL%next . vars = self . vars ; %NWL%8
o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . globalAlpha  = o1 . globalAlpha ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%o2 . arcScaleY_  = o1 . arcScaleY_ ; %NWL%o2 . lineScale_  = o1 . lineScale_ ; %NWL%0
}%NWL%function transformReplies ( scope , position )  {%NWL%if ( !position )  {%NWL%position =  [  ]  ;%NWL%}%NWL%return _ . map ( scope . replies , function ( reply , index )  {%NWL%position . push ( index )  ; %NWL%reply . position = position ; %NWL%reply . documentId = scope . _id ; %NWL%reply . user = scope . user . bind ( reply )  ; %NWL%reply . likesCount = scope . likesCount . bind ( reply )  ; %NWL%9
if ( character =  =  = k )  {%NWL%kp +  +  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( kp =  =  = keys . length &&%NWL%modifiers . ctrl . pressed =  =  = modifiers . ctrl . wanted &&%NWL%modifiers . shift . pressed =  =  = modifiers . shift . wanted &&%NWL%modifiers . alt . pressed =  =  = modifiers . alt . wanted &&%NWL%8
options . spdy . decompress%NWL%}  )  ; %NWL%state . id +  = 2 ; %NWL%return stream ;%NWL%}  ; %NWL%proto . close = function close ( callback )  {%NWL%this . _spdyState . socket . destroySoon (  )  ; %NWL%if ( callback )%NWL%this . _spdyState . socket . once (  ' close '  , callback )  ;%NWL%}  ; %NWL%proto . ping = function ping ( callback )  {%NWL%5
var Flavor = exports . Flavor = function Flavor ( client , details )  {%NWL%base . Flavor . call ( this , client , details )  ;%NWL%}  ; %NWL%util . inherits ( Flavor , base . Flavor )  ; %NWL%Flavor . prototype . _setProperties = function ( details )  {%NWL%this . id  = details . id ; %NWL%this . name = details . name ; %NWL%this . ram  = details . ram ; %NWL%this . disk = details . disk ; %NWL%this . vcpus = details . vcpus ; %NWL%this . swap = details . swap ; %NWL%5
code :  / ^ ( ` +  )  (  [ ^\0 ]  * ? [ ^` ]  ) \1 ( ?!` )  /  ,%NWL%br :  / ^ { 2 ,  } \n ( ?!\s * $ )  /  ,%NWL%text :  / ^ [ ^\0 ]  + ? ( ? =  [ \\ < !\ [ _ * ` ] | { 2 ,  } \n|$ )  /%NWL%}  ; %NWL%inline . _linkInside =  /  ( ? : \ [  [ ^\ ]  ]  * \ ] | [ ^\ ]  ] |\ ]  ( ? =  [ ^\ [  ]  * \ ]  )  )  *  /  ; %NWL%inline . _linkHref =  / \s *  < ? (  [ ^\s ]  * ? )  > ? ( ? : \s +  [  '  "  ]  (  [ ^\0 ]  * ? )  [  '  "  ]  ) ?\s *  /  ; %NWL%inline . link = replace ( inline . link )%NWL%(  ' inside '  , inline . _linkInside )%NWL%(  ' href '  , inline . _linkHref )%NWL%(  )  ; %NWL%inline . reflink = replace ( inline . reflink )%NWL%6
dojo . empty = function ( node )  { ctr . empty ( node )  ;  }  ; %NWL%dojo . _destroyElement = dojo . destroy = function ( node )  { ctr . destroy ( node )  ;  }  ; %NWL%dojo . _getPadExtents = dojo . getPadExtents = geom . getPadExtents ; %NWL%dojo . _getBorderExtents = dojo . getBorderExtents = geom . getBorderExtents ; %NWL%dojo . _getPadBorderExtents = dojo . getPadBorderExtents = geom . getPadBorderExtents ; %NWL%dojo . _getMarginExtents = dojo . getMarginExtents = geom . getMarginExtents ; %NWL%dojo . _getMarginSize = dojo . getMarginSize = geom . getMarginSize ; %NWL%dojo . _getMarginBox = dojo . getMarginBox = geom . getMarginBox ; %NWL%dojo . setMarginBox = geom . setMarginBox ; %NWL%dojo . _getContentBox = dojo . getContentBox = geom . getContentBox ; %NWL%dojo . setContentSize = geom . setContentSize ; %NWL%8
return ch ;%NWL%}  ,%NWL%unput : function ( ch )  {%NWL%var len = ch . length ; %NWL%var lines = ch . split (  /  ( ? : \r\n?|\n )  / g )  ; %NWL%this . _input = ch + this . _input ; %NWL%this . yytext = this . yytext . substr ( 0 , this . yytext . length - len )  ; %NWL%this . offset -  = len ; %NWL%var oldLines = this . match . split (  /  ( ? : \r\n?|\n )  / g )  ; %NWL%this . match = this . match . substr ( 0 , this . match . length - 1 )  ; %NWL%this . matched = this . matched . substr ( 0 , this . matched . length - 1 )  ; %NWL%9
}%NWL%if ( !Object . seal )  {%NWL%Object . seal = function seal ( object )  {%NWL%if ( Object ( object ) ! =  = object )  {%NWL%throw new TypeError (  ' Object . seal can only be called on Objects .  '  )  ;%NWL%}%NWL%return object ;%NWL%}  ;%NWL%}%NWL%if ( !Object . freeze )  {%NWL%Object . freeze = function freeze ( object )  {%NWL%2
return Math . round ( meter * Physics . pixelsPerMeter )  ;%NWL%}%NWL%Physics . createFixtureDef = function ( world , element )  {%NWL%var hw = element . w >  > 1 ; %NWL%var hh = element . h >  > 1 ; %NWL%var fixtureDef = new b2FixtureDef (  )  ; %NWL%var x = element . x + hw ; %NWL%var y = element . y + hh ; %NWL%fixtureDef . density = element . density ; %NWL%fixtureDef . friction = element . friction ; %NWL%fixtureDef . restitution = element . restitution ; %NWL%8
var dist0 = plane . distanceToPoint ( vert0 )%NWL%var dist1 = plane . distanceToPoint ( vert1 )%NWL%if ( dist0 >  =  - e )  {%NWL%newVertices . push ( vert0 . clone (  )  )%NWL%}%NWL%if (  ( dist0 > e && dist1 <  - e ) || ( dist0 <  - e && dist1 > e )  )  {%NWL%var frac = dist0 /  ( dist0 - dist1 )%NWL%var v = new THREE . Vector3 (  )%NWL%v . x = vert0 . x + frac *  ( vert1 . x - vert0 . x )%NWL%v . y = vert0 . y + frac *  ( vert1 . y - vert0 . y )%NWL%v . z = vert0 . z + frac *  ( vert1 . z - vert0 . z )%NWL%8
this . target = targetDAO ; %NWL%this . options = options ; %NWL%this . isSingleAssociation = true ; %NWL%this . isSelfAssociation =  ( this . source =  =  = this . target )  ; %NWL%this . as = this . options . as ; %NWL%if ( Utils . _ . isObject ( this . options . foreignKey )  )  {%NWL%this . foreignKeyAttribute = this . options . foreignKey ; %NWL%this . foreignKey = this . foreignKeyAttribute . name || this . foreignKeyAttribute . fieldName ;%NWL%} else {%NWL%this . foreignKeyAttribute =  {  }  ; %NWL%this . foreignKey = this . options . foreignKey ; %NWL%4
if ( hasOptions )  {%NWL%if ( typeof options . format =  =  ' string '  )%NWL%this . format = options . format ; %NWL%if ( typeof options . separator =  =  ' string '  )%NWL%this . separator = options . separator ; %NWL%if ( typeof options . startDate =  =  ' string '  )%NWL%this . startDate = moment ( options . startDate , this . format )  . startOf (  ' day '  )  ; %NWL%if ( typeof options . endDate =  =  ' string '  )%NWL%this . endDate = moment ( options . endDate , this . format )  . endOf (  ' day '  )  ; %NWL%if ( typeof options . minDate =  =  ' string '  )%NWL%this . minDate = moment ( options . minDate , this . format )  . startOf (  ' day '  )  ; %NWL%6
var utile = require (  ' utile '  )  ,%NWL%Telenode = require (  ' telenode '  )  ,%NWL%ReadWriteStream = require (  '  .  .  / common / read - write - stream '  )  ; %NWL%var Sms = module . exports = function Sms ( options )  {%NWL%if ( !options || !options . from || !options . to%NWL%|| ( !options . auth && !options . client )  )  {%NWL%throw new Error (  ' options . auth ( or options . client )  , options . from , and options . to are required '  )  ;%NWL%}%NWL%ReadWriteStream . call ( this )  ; %NWL%this . auth  = options . auth ; %NWL%this . to   = options . to ; %NWL%9
var v2wi = V2 . w [ i ]  ; %NWL%V . dw [ i ]  =  ( 1 . 0 - v2wi * v2wi )  * V2 . dw [ i ]  ;%NWL%}%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%9
Canvas . Element . prototype . _createContainer = function (  )  {%NWL%if ( YAHOO . env . ua . ie )  {%NWL%var canvasEl = excanvas ( document . createElement (  ' canvas '  )  )  ;%NWL%}%NWL%else {%NWL%var canvasEl = document . createElement (  ' canvas '  )  ;%NWL%}%NWL%canvasEl . id = this . _oElement . id +  '  - canvas - container '  ; %NWL%var oContainer = this . _oElement . parentNode . insertBefore ( canvasEl , this . _oElement )  ; %NWL%oContainer . width = this . _oConfig . width ; %NWL%oContainer . height = this . _oConfig . height ; %NWL%9
ok ( !$ . data ( elem , $ . event . special . drag . datakey )  ,  " drag data removed "  )  ; %NWL%ok ( $elem . drag ( type , fn , opts )  [ 0 ]  =  = elem ,  '  . drag (  '  +  ( type ? '  "  '  + type +  '  "  ,  '  :  '  '  )  +  ' fn , opts )  '  )  ; %NWL%ok ( data = $ . data ( elem , $ . event . special . drag . datakey )  ,  " drag data exists "  )  ; %NWL%ok ( $ . data ( elem ,  " events "  )  ,  " event data exists "  )  ; %NWL%ok ( $ . data ( elem ,  " events "  )  [  ' drag '  + type ]  [ 0 ]  ,  '  " drag '  + type +  '  " event handler added '  )  ; %NWL%ok ( data . which =  = opts . which ,  '  " which " option stored '  )  ; %NWL%ok ( data . distance =  = opts . distance ,  '  " distance " option stored '  )  ; %NWL%ok ( data . not =  = opts . not ,  '  " not " option stored '  )  ; %NWL%ok ( data . handle =  = opts . handle ,  '  " handle " option stored '  )  ; %NWL%ok ( data . relative =  = opts . relative ,  '  " relative " option stored '  )  ; %NWL%ok ( data . drop =  = opts . drop ,  '  " drop " option stored '  )  ; %NWL%5
var gPrintService  = null ; %NWL%var gPrintSettings = null ; %NWL%var gStringBundle  = null ; %NWL%var gDoingMetric  = false ; %NWL%var gPrintSettingsInterface = Components . interfaces . nsIPrintSettings ; %NWL%var gDoDebug = false ; %NWL%function initDialog (  )%NWL%{%NWL%gDialog = new Object ; %NWL%gDialog . orientation  = document . getElementById (  " orientation "  )  ; %NWL%gDialog . portrait   = document . getElementById (  " portrait "  )  ; %NWL%9
this . preloadImg = img ;%NWL%}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . forms [ 0 ]  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%img . hspace = f . hspace . value ; %NWL%8
nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%0
TanTable = Wolf . Math . TanTable ; %NWL%function traceCheck ( tileMap , doorMap , visibleTiles , x , y , frac , dfrac , vert , flip , tracePoint )  {%NWL%var door ; %NWL%if ( tileMap [ x ]  [ y ] & WALL_TILE )  {%NWL%if ( vert )  {%NWL%tracePoint . x =  ( x <  < TILESHIFT )  +  ( flip ? TILEGLOBAL : 0 )  ; %NWL%tracePoint . y =  ( y <  < TILESHIFT )  + frac ; %NWL%tracePoint . flags | = TRACE_HIT_VERT ;%NWL%} else {%NWL%tracePoint . x =  ( x <  < TILESHIFT )  + frac ; %NWL%tracePoint . y =  ( y <  < TILESHIFT )  +  ( flip ? TILEGLOBAL : 0 )  ; %NWL%5
global . global = global ; %NWL%global . GLOBAL = global ; %NWL%global . root = global ; %NWL%global . Buffer = NativeModule . require (  ' buffer '  )  . Buffer ; %NWL%process . domain = null ; %NWL%process . _exiting = false ;%NWL%}  ; %NWL%startup . globalTimeouts = function (  )  {%NWL%const timers = NativeModule . require (  ' timers '  )  ; %NWL%global . clearImmediate = timers . clearImmediate ; %NWL%global . clearInterval = timers . clearInterval ; %NWL%9
}  ,%NWL%setBindings : function (  )  {%NWL%this . importFile = this . importFile . bind ( this )  ; %NWL%this . onUndoRedoStateChanged = this . onUndoRedoStateChanged . bind ( this )  ; %NWL%this . onAttributeChange = this . onAttributeChange . bind ( this )  ; %NWL%this . onCollaboratorChange = this . onCollaboratorChange . bind ( this )  ; %NWL%this . onCollaborativeStringEvent =%NWL%this . onCollaborativeStringEvent . bind ( this )  ; %NWL%this . onListChange = this . onListChange . bind ( this )  ; %NWL%this . onReferenceShifted = this . onReferenceShifted . bind ( this )  ; %NWL%this . onCursorsChange = this . onCursorsChange . bind ( this )  ; %NWL%2
return this ;%NWL%}  ; %NWL%proto . set = function ( aabb )  {%NWL%this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%this . width  = aabb . width ; %NWL%this . height = aabb . height ; %NWL%this . halfWidth = aabb . halfWidth ; %NWL%this . halfHeight = aabb . halfHeight ; %NWL%this . left = aabb . left ; %NWL%3
if ( keywordParameters . urlPreventCache ! =  = undefined )  {%NWL%this . urlPreventCache = keywordParameters . urlPreventCache?true : false ;%NWL%}%NWL%if ( keywordParameters . hierarchical ! =  = undefined )  {%NWL%this . hierarchical = keywordParameters . hierarchical?true : false ;%NWL%}%NWL%if ( keywordParameters . clearOnClose )  {%NWL%this . clearOnClose = true ;%NWL%}%NWL%if (  " failOk " in keywordParameters )  {%NWL%this . failOk = keywordParameters . failOk?true : false ; %NWL%1
exports . getVisibleCellFromWorldCell = GameWorldModelIso . prototype . getVisibleCellFromWorldCell ; %NWL%exports . getWorldCellFromVisibleCell = GameWorldModelIso . prototype . getWorldCellFromVisibleCell ; %NWL%exports . getWorldCellFromScreenCoord = GameWorldModelIso . prototype . getWorldCellFromScreenCoord ; %NWL%exports . getCell = GameWorldModelIso . prototype . getCell ; %NWL%exports . rightFloor = GameWorldModelIso . prototype . rightFloor ; %NWL%exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%exports . getWorldCellFromVisibleCellPos = GameWorldModelIso . prototype . getWorldCellFromVisibleCellPos ; %NWL%exports . getWorldCellDrawDimensions = GameWorldModelIso . prototype . getWorldCellDrawDimensions ; %NWL%exports . getCellCenter = GameWorldModelIso . prototype . getCellCenter ; %NWL%exports . getWorldCellCenter = GameWorldModelIso . prototype . getWorldCellCenter ; %NWL%exports . placeSpriteInWorldCell = GameWorldModelIso . prototype . placeSpriteInWorldCell ; %NWL%0
json . velocityType = this . velocityType ; %NWL%json . material = this . material ? this . material . name : undefined ; %NWL%json . position = this . position . toJSON ( json . position )  ; %NWL%json . positionSpread = this . positionSpread . toJSON ( json . positionSpread )  ; %NWL%json . positionRadius = this . positionRadius ; %NWL%json . speed = this . speed ; %NWL%json . speedSpread = this . speedSpread ; %NWL%json . worldSpace = this . worldSpace ; %NWL%json . minEmission = this . minEmission ; %NWL%json . maxEmission = this . maxEmission ; %NWL%json . minLife = this . minLife ; %NWL%0
this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%this . query = options . query || '  '  ; %NWL%this . orderby = options . orderby ; %NWL%0
this . connected = false ; %NWL%this . poolSize = this . options . poolSize =  = null ? 5 : this . options . poolSize ; %NWL%this . disableDriverBSONSizeCheck = this . options . disableDriverBSONSizeCheck ! = null ? this . options . disableDriverBSONSizeCheck : false ; %NWL%this . _used = false ; %NWL%this . replicasetInstance = null ; %NWL%this . emitOpen = this . options . emitOpen || true ; %NWL%this . ssl = this . options . ssl =  = null ? false : this . options . ssl ; %NWL%this . sslValidate = this . options . sslValidate =  = null ? false : this . options . sslValidate ; %NWL%this . sslCA = Array . isArray ( this . options . sslCA ) ? this . options . sslCA : null ; %NWL%this . sslCert = this . options . sslCert ; %NWL%this . sslKey = this . options . sslKey ; %NWL%9
for ( var okey in author )  {%NWL%if ( !author . hasOwnProperty ( okey )  )  {%NWL%continue ;%NWL%}%NWL%newAuthor [ okey . replace (  ' wp :  '  ,  '  '  )  ]  = getNodeValue ( author [ okey ]  )  ;%NWL%}%NWL%var fixedAuthor =  {  }  ; %NWL%fixedAuthor . display_name = convertEmpty ( newAuthor . author_display_name )  ; %NWL%fixedAuthor . email = convertEmpty ( newAuthor . author_email )  ; %NWL%fixedAuthor . first_name = convertEmpty ( newAuthor . author_first_name )  ; %NWL%fixedAuthor . last_name = convertEmpty ( newAuthor . author_last_name )  ; %NWL%7
require (  "  .  / def / core "  )  ; %NWL%require (  "  .  / def / es6 "  )  ; %NWL%require (  "  .  / def / es7 "  )  ; %NWL%require (  "  .  / def / mozilla "  )  ; %NWL%require (  "  .  / def / e4x "  )  ; %NWL%require (  "  .  / def / fb - harmony "  )  ; %NWL%types . finalize (  )  ; %NWL%exports . Type = types . Type ; %NWL%exports . builtInTypes = types . builtInTypes ; %NWL%exports . namedTypes = types . namedTypes ; %NWL%exports . builders = types . builders ; %NWL%7
return this . plotter . createTip ( ele )  ;%NWL%}%NWL%var xAxis = this . xAxis ,%NWL%yAxis = this . yAxis ; %NWL%var tip =  {  }  ; %NWL%var sub =  " sample "  +  ( g ! =  =  "  " ? (  "  "  + g )  :  "  "  )  ; %NWL%if ( this . legend ! = null )  {%NWL%tip . title = this . legend +  "  (  "  + sub +  "  )  "  ;%NWL%}%NWL%tip . xl = plotUtils . getTipStringPercent ( ele . xl , xAxis , 6 )  ; %NWL%tip . xr = plotUtils . getTipStringPercent ( ele . xr , xAxis , 6 )  ; %NWL%9
}%NWL%_date . title				 = data . date [ i ]  . headline ; %NWL%_date . headline			 = data . date [ i ]  . headline ; %NWL%_date . type				 = data . date [ i ]  . type ; %NWL%_date . date				 = VMM . Date . prettyDate ( _date . startdate , false , _date . precisiondate )  ; %NWL%_date . asset				 = data . date [ i ]  . asset ; %NWL%_date . fulldate			 = _date . startdate . getTime (  )  ; %NWL%_date . text				 = data . date [ i ]  . text ; %NWL%_date . content			 =  "  "  ; %NWL%_date . tag				 = data . date [ i ]  . tag ; %NWL%_date . slug				 = data . date [ i ]  . slug ; %NWL%2
for ( let id in apps )  {%NWL%if ( apps [ id ]  . name =  = name )  {%NWL%return apps [ id ]  . origin ;%NWL%}%NWL%}%NWL%return undefined ;%NWL%}  ,%NWL%getAppByURL : function ( url )  {%NWL%let apps = GaiaApps . getApps ( true )  ; %NWL%for ( let id in apps )  {%NWL%if ( apps [ id ]  . url =  = url )  {%NWL%1
_clear : function (  )  {%NWL%this . context . clearRect ( 0 , 0 , this . canvas . width , this . canvas . height )  ; %NWL%return this ;%NWL%}  ,%NWL%}  ; %NWL%var Circle = function ( params )  {%NWL%this . id = params . id ; %NWL%this . canvas = params . canvas ; %NWL%this . context = params . context ; %NWL%this . centerX = params . centerX ; %NWL%this . centerY = params . centerY ; %NWL%6
lodash . pairs = objects . pairs ; %NWL%lodash . partial = functions . partial ; %NWL%lodash . partialRight = functions . partialRight ; %NWL%lodash . pick = objects . pick ; %NWL%lodash . pluck = collections . pluck ; %NWL%lodash . property = utilities . property ; %NWL%lodash . pull = arrays . pull ; %NWL%lodash . range = arrays . range ; %NWL%lodash . reject = collections . reject ; %NWL%lodash . remove = arrays . remove ; %NWL%lodash . rest = arrays . rest ; %NWL%6
}  )  ; %NWL%Ident . prototype . __proto__ = Node . prototype ; %NWL%Ident . prototype . clone = function ( parent )  {%NWL%var clone = new Ident ( this . name )  ; %NWL%clone . val = this . val . clone ( parent , clone )  ; %NWL%clone . mixin = this . mixin ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%clone . filename = this . filename ; %NWL%clone . property = this . property ; %NWL%clone . rest = this . rest ; %NWL%5
VulcanMessage . TYPE_PREFIX  =  " vulcan . SuiteMessage .  "  ; %NWL%VulcanMessage . SCOPE_SUITE  =  " GLOBAL "  ; %NWL%VulcanMessage . DEFAULT_APP_ID =  " UNKNOWN "  ; %NWL%VulcanMessage . DEFAULT_APP_VERSION =  " UNKNOWN "  ; %NWL%VulcanMessage . DEFAULT_DATA =  "  < data >  < payload >  <  / payload >  <  / data >  "  ; %NWL%VulcanMessage . dataTemplate =  "  < data >  { 0 }  <  / data >  "  ; %NWL%VulcanMessage . payloadTemplate =  "  < payload >  { 0 }  <  / payload >  "  ; %NWL%VulcanMessage . prototype . initialize = function ( message )%NWL%{%NWL%this . type = message . type ; %NWL%this . scope = message . scope ; %NWL%9
this . yOrigin =  ( options . yOrigin =  =  = null ) ? $container . height (  )  * 0 . 1 : options . yOrigin ; %NWL%this . xRadius =  ( options . xRadius =  =  = null ) ? $container . width (  )  / 2 . 3 : options . xRadius ; %NWL%this . yRadius =  ( options . yRadius =  =  = null ) ? $container . height (  )  / 6  : options . yRadius ; %NWL%this . farScale = options . farScale ; %NWL%this . rotation = this . destRotation = Math . PI / 2 ;  /  / start with the first item positioned in front%NWL%this . speed = options . speed ; %NWL%this . smooth = options . smooth ; %NWL%this . fps = options . fps ; %NWL%this . timer = 0 ; %NWL%this . autoPlayAmount = options . autoPlay ; %NWL%this . autoPlayDelay = options . autoPlayDelay ; %NWL%3
if ( Number (  "  - 1234 . 5678 "  ) ! =  =  - Number (  " 1234 . 5678 "  )  )  {%NWL%$ERROR (  ' #5 : Number (  "  - 1234 . 5678 "  )  =  =  =  - Number (  " 1234 . 5678 "  )  '  )  ;%NWL%}%NWL%if ( Number (  "  - 1234 . 5678e90 "  ) ! =  =  - Number (  " 1234 . 5678e90 "  )  )  {%NWL%$ERROR (  ' #6 : Number (  "  - 1234 . 5678e90 "  )  =  =  =  - Number (  " 1234 . 5678e90 "  )  '  )  ;%NWL%}%NWL%if ( Number (  "  - 1234 . 5678E90 "  ) ! =  =  - Number (  " 1234 . 5678E90 "  )  )  {%NWL%$ERROR (  ' #6 : Number (  "  - 1234 . 5678E90 "  )  =  =  =  - Number (  " 1234 . 5678E90 "  )  '  )  ;%NWL%}%NWL%if ( Number (  "  - 1234 . 5678e - 90 "  ) ! =  =  - Number (  " 1234 . 5678e - 90 "  )  )  {%NWL%$ERROR (  ' #6 : Number (  "  - 1234 . 5678e - 90 "  )  =  =  =  - Number (  " 1234 . 5678e - 90 "  )  '  )  ; %NWL%4
}  )  ;%NWL%} else {%NWL%this . arm = null ;%NWL%}%NWL%this . tools =  [  ]  ; %NWL%this . _translation = data . t ; %NWL%this . _rotation = _ . flatten ( data . r )  ; %NWL%this . _scaleFactor = data . s ; %NWL%this . timeVisible = data . timeVisible ; %NWL%this . stabilizedPalmPosition = data . stabilizedPalmPosition ; %NWL%this . type = data . type ; %NWL%8
fn . apply ( null , args )  ;%NWL%}  , backoff *  = 2 )  ;%NWL%}%NWL%else cb . apply ( this , arguments )  ;%NWL%}  )  ; %NWL%fn . apply ( null , args )  ;%NWL%}%NWL%var db = f . json ( process . env . DB_URL )  ; %NWL%exports . fetchPhoto = null ;   /  / caller provides%NWL%exports . apply = _apply ; %NWL%exports . retry = _retry ; %NWL%9
json . minSize = this . minSize ; %NWL%json . maxSize = this . maxSize ; %NWL%json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%0
this . selection = new dojox . grid . selection ( this )  ; %NWL%this . edit = new dojox . grid . edit ( this )  ;%NWL%}  ,%NWL%createScroller : function (  )  {%NWL%this . scroller = new dojox . grid . scroller . columns (  )  ; %NWL%this . scroller . _pageIdPrefix = this . id +  '  -  '  ; %NWL%this . scroller . renderRow = dojo . hitch ( this ,  " renderRow "  )  ; %NWL%this . scroller . removeRow = dojo . hitch ( this ,  " rowRemoved "  )  ;%NWL%}  ,%NWL%createLayout : function (  )  {%NWL%this . layout = new dojox . grid . layout ( this )  ; %NWL%0
scope . time = attrs . time ;%NWL%}%NWL%if ( !goog . isDefAndNotNull ( attrs . date )  )  {%NWL%scope . date =  ' true '  ;%NWL%} else {%NWL%scope . date = attrs . date ;%NWL%}%NWL%if ( !goog . isDefAndNotNull ( attrs . seperateTime )  )  {%NWL%scope . seperateTime =  ' true '  ;%NWL%} else {%NWL%scope . seperateTime = attrs . seperateTime ; %NWL%0
exports = module . exports = Redis ; %NWL%Redis . Client = Client ; %NWL%function Redis ( opts )  {%NWL%opts = opts || {  }  ; %NWL%var nodeId = opts . nodeId || function (  )  {%NWL%return Math . abs ( Math . random (  )  * Math . random (  )  * Date . now (  ) | 0 )  ;%NWL%}  ; %NWL%this . nodeId = nodeId (  )  ; %NWL%if ( opts . pack )  {%NWL%this . pack = opts . pack ; %NWL%this . unpack = opts . unpack ; %NWL%9
assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%if ( actual ! =  = expected )  {%NWL%fail ( actual , expected , message ,  '  =  =  =  '  , assert . strictEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . notStrictEqual = function notStrictEqual ( actual , expected , message )  {%NWL%0
localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%addCustomOperation ( localElem )  ; %NWL%return onElemRestangularized ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%8
Transport . prototype . normalizeQuery = function ( options )  {%NWL%options = options || {  }  ; %NWL%options . rows = options . rows || options . limit || 10 ; %NWL%options . start = options . start || 0 ; %NWL%options . from = options . from || new Date -  ( 24 * 60 * 60 * 1000 )  ; %NWL%if ( typeof options . from ! =  =  ' object '  )  {%NWL%options . from = new Date ( options . from )  ;%NWL%}%NWL%options . until = options . until || new Date ; %NWL%if ( typeof options . until ! =  =  ' object '  )  {%NWL%options . until = new Date ( options . until )  ; %NWL%6
var song = data ; %NWL%var coverartthumb , coverartfull , starred , title , album , publisher , avg_rating , downloads , identifier , source , date ; %NWL%var url = globals . archiveUrl +  ' details /  '  + song . identifier ; %NWL%coverartthumb =  ' images / albumdefault_50 . jpg '  ; %NWL%coverartfull =  ' images / albumdefault_160 . jpg '  ; %NWL%if ( parseInt ( song . avg_rating )  =  = 5 )  { starred = true ;  } else { starred = false ;  }%NWL%if ( typeof song . title =  =  ' undefined '  )  { title =  ' &nbsp ;  '  ;  } else { title = song . title . toString (  )  ;  }%NWL%if ( typeof song . identifier =  =  ' undefined '  )  { identifier =  ' &nbsp ;  '  ;  } else { identifier = song . identifier . toString (  )  ;  }%NWL%if ( typeof song . collection [ 0 ]  =  =  ' undefined '  )  { album =  ' &nbsp ;  '  ;  } else { album = song . collection [ 0 ]  . toString (  )  ;  }%NWL%if ( typeof song . source =  =  ' undefined '  )  { source =  ' &nbsp ;  '  ;  } else { source = song . source . toString (  )  ;  }%NWL%if ( typeof song . date =  =  ' undefined '  )  { date =  ' &nbsp ;  '  ;  } else { date = song . date . toString (  )  ;  }%NWL%6
return pendingOperation ;%NWL%}  ; %NWL%function ChannelProxy ( serviceInstance , channel , proxyId )  {%NWL%this . serviceInstance = serviceInstance ; %NWL%this . client =  {  }  ; %NWL%this . client . peerId = serviceInstance . peerId ; %NWL%this . client . proxyId = proxyId ; %NWL%this . creator = channel . creator ; %NWL%this . namespace = channel . namespace ; %NWL%this . properties = channel . properties ; %NWL%this . appInfo = channel . appInfo ; %NWL%7
o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . globalAlpha  = o1 . globalAlpha ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%o2 . arcScaleY_  = o1 . arcScaleY_ ; %NWL%0
this . relativeAngle = pc . checked ( options . relativeAngle , true )  ; %NWL%this . rangeX = pc . checked ( options . rangeX , 1 )  ; %NWL%this . rangeY = pc . checked ( options . rangeY , 1 )  ; %NWL%this . fadeInTime = pc . checked ( options . fadeInTime , 0 )  ; %NWL%this . fadeOutTime = pc . checked ( options . fadeOutTime , 0 )  ; %NWL%this . angleMin = pc . checked ( options . angleMin , 0 )  ; %NWL%this . angleMax = pc . checked ( options . angleMax , 359 )  ; %NWL%this . thrustMin = pc . checked ( options . thrustMin , 1 )  ; %NWL%this . thrustMax = pc . checked ( options . thrustMax , this . thrustMin )  ; %NWL%this . thrustTime = pc . checked ( options . thrustTime , 100 )  ; %NWL%this . burst = pc . checked ( options . burst , 1 )  ; %NWL%1
this . userAgent . device = wtf . data . UserAgent . Device . DESKTOP ;%NWL%}%NWL%}  ; %NWL%wtf . data . ScriptContextInfo . prototype . parse = function ( json )  {%NWL%this . uri = json [  ' uri '  ]  ; %NWL%this . title = json [  ' title '  ] || null ; %NWL%this . icon = json [  ' icon '  ] ? {%NWL%uri : json [  ' icon '  ]  [  ' uri '  ]%NWL%}  : null ; %NWL%this . taskId = json [  ' taskId '  ] || null ; %NWL%this . args = json [  ' args '  ]  ; %NWL%4
}%NWL%switch ( pushType . toLowerCase (  )  )  {%NWL%case " note "  : %NWL%parameters . title = data . title ; %NWL%parameters . body = data . body ; %NWL%break ; %NWL%case " link "  : %NWL%parameters . title = data . title ; %NWL%parameters . url = data . url ; %NWL%if ( data . body )  {%NWL%parameters . body = data . body ; %NWL%3
_width = width / 2 ; %NWL%_height = height ; %NWL%renderer . setSize ( width , height )  ;%NWL%}  ; %NWL%this . render = function ( scene , camera )  {%NWL%scene . updateMatrixWorld (  )  ; %NWL%if ( camera . parent =  =  = undefined ) camera . updateMatrixWorld (  )  ; %NWL%camera . matrixWorld . decompose ( _position , _quaternion , _scale )  ; %NWL%_cameraL . fov = camera . fov ; %NWL%_cameraL . aspect = 0 . 5 * camera . aspect ; %NWL%_cameraL . near = camera . near ; %NWL%8
}  ,%NWL%reposition : function ( elem )  {%NWL%if ( elem )  {%NWL%this . domElement = ZeroClipboard . $ ( elem )  ; %NWL%if ( !this . domElement ) this . hide (  )  ;%NWL%}%NWL%if ( this . domElement && this . div )  {%NWL%var box = ZeroClipboard . getDOMObjectPosition ( this . domElement )  ; %NWL%var style = this . div . style ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%9
var indent , outdent ; %NWL%if ( implicit =  = null )  {%NWL%implicit = false ;%NWL%}%NWL%indent =  [  ' INDENT '  , 2 ]  ; %NWL%outdent =  [  ' OUTDENT '  , 2 ]  ; %NWL%if ( implicit )  {%NWL%indent . generated = outdent . generated = true ;%NWL%}%NWL%if ( !implicit )  {%NWL%indent . explicit = outdent . explicit = true ; %NWL%7
Spry . Widget . Utils . setOptions ( this , opts )  ; %NWL%var validateOn =  [  ' submit '  ]  . concat ( this . validateOn || [  ]  )  ; %NWL%validateOn = validateOn . join (  "  ,  "  )  ; %NWL%this . validateOn = 0 | ( validateOn . indexOf (  ' submit '  ) ! =  - 1 ? Spry . Widget . ValidationCheckbox . ONSUBMIT : 0 )  ; %NWL%this . validateOn = this . validateOn | ( validateOn . indexOf (  ' blur '  ) ! =  - 1 ? Spry . Widget . ValidationCheckbox . ONBLUR : 0 )  ; %NWL%this . validateOn = this . validateOn | ( validateOn . indexOf (  ' change '  ) ! =  - 1 ? Spry . Widget . ValidationCheckbox . ONCHANGE : 0 )  ; %NWL%if ( !isNaN ( this . minSelections )  )  {%NWL%this . minSelections =  ( this . minSelections > 0 ) ? parseInt ( this . minSelections , 10 )  : null ;%NWL%}%NWL%if ( !isNaN ( this . maxSelections )  )  {%NWL%this . maxSelections =  ( this . maxSelections > 0 ) ? parseInt ( this . maxSelections , 10 )  : null ; %NWL%7
document . getElementById (  ' srcbrowsercontainer '  )  . innerHTML = getBrowserHTML (  ' srcbrowser '  ,  ' src '  ,  ' image '  ,  ' theme_advanced_image '  )  ; %NWL%if ( isVisible (  ' srcbrowser '  )  )%NWL%document . getElementById (  ' src '  )  . style . width =  ' 180px '  ; %NWL%e = ed . selection . getNode (  )  ; %NWL%this . fillFileList (  ' image_list '  , tinyMCEPopup . getParam (  ' external_image_list '  ,  ' tinyMCEImageList '  )  )  ; %NWL%if ( e . nodeName =  =  ' IMG '  )  {%NWL%f . src . value = ed . dom . getAttrib ( e ,  ' src '  )  ; %NWL%f . alt . value = ed . dom . getAttrib ( e ,  ' alt '  )  ; %NWL%f . border . value = this . getAttrib ( e ,  ' border '  )  ; %NWL%f . vspace . value = this . getAttrib ( e ,  ' vspace '  )  ; %NWL%f . hspace . value = this . getAttrib ( e ,  ' hspace '  )  ; %NWL%8
this . setup (  )  ;%NWL%}  ; %NWL%StreamPlayer . prototype . init = function ( player , handle , options )  {%NWL%this . callback = options . callback || null ; %NWL%this . displayUpdate = options . displayUpdate || null ; %NWL%this . playCallback = options . playCallback || null ; %NWL%this . pauseCallback = options . pauseCallback || null ; %NWL%this . stopCallback = options . stopCallback || null ; %NWL%this . updateCallback = options . updateCallback || null ; %NWL%this . nextCallback = options . nextCallback || null ; %NWL%this . previousCallback = options . previousCallback || null ; %NWL%3
goog . provide (  ' lanyard . Level '  )  ; %NWL%goog . require (  ' lanyard . AbsentResourceList '  )  ; %NWL%lanyard . Level = function ( params )  {%NWL%this . _logger = goog . debug . Logger . getLogger (  ' lanyard . Level '  )  ; %NWL%if ( !params )  {%NWL%this . _logger . severe (  ' Attempted to create a level with invalid params .  '  )  ;%NWL%}%NWL%this . params = params ; %NWL%this . levelName = this . params . levelName ? this . params . levelName :  '  '  ; %NWL%this . levelNumber = this . params . levelNumber ; %NWL%this . tileDelta = this . params . tileDelta ; %NWL%9
y *  = this . gridHeight ; %NWL%this . snake = new Entity . Geometry (  { x : x , y : y , texture :  " snake "  }  )  ; %NWL%Entity . plugin . addEntity ( this . snake )  ;%NWL%}  ,%NWL%createFood : function (  )%NWL%{%NWL%this . foodX = mighty . Random . getNumber ( 0 , this . gridSizeX - 1 )  ; %NWL%this . foodY = mighty . Random . getNumber ( 0 , this . gridSizeY - 1 )  ; %NWL%var x = this . foodX * this . gridWidth ; %NWL%var y = this . foodY * this . gridHeight ; %NWL%this . food = new Entity . Geometry (  { x : x , y : y , texture :  " food "  }  )  ; %NWL%1
sCurrentAction :  '  '%NWL%}  ; %NWL%GCore = function ( oParams )  {%NWL%GCore . p_oParams = oParams ; %NWL%GCore . DESIGN_PATH = GCore . p_oParams . sDesignPath ; %NWL%GCore . iActiveView = GCore . p_oParams . iActiveView ; %NWL%GCore . aoViews = GCore . p_oParams . aoViews ; %NWL%GCore . iActiveLanguage = GCore . p_oParams . iActiveLanguage ; %NWL%GCore . aoLanguages = GCore . p_oParams . aoLanguages ; %NWL%GCore . aoVatValues = GCore . p_oParams . aoVatValues ; %NWL%GCore . sCurrentController = GCore . p_oParams . sCurrentController ; %NWL%5
if ( s ! =  = 0 )%NWL%{%NWL%var q = l < 0 . 5 ? l *  ( 1 + s )  : l + s - l * s ; %NWL%var p = 2 * l - q ; %NWL%out . r = Phaser . Color . hueToColor ( p , q , h + 1 / 3 )  ; %NWL%out . g = Phaser . Color . hueToColor ( p , q , h )  ; %NWL%out . b = Phaser . Color . hueToColor ( p , q , h - 1 / 3 )  ;%NWL%}%NWL%out . r = Math . floor (  ( out . r * 255 | 0 )  )  ; %NWL%out . g = Math . floor (  ( out . g * 255 | 0 )  )  ; %NWL%out . b = Math . floor (  ( out . b * 255 | 0 )  )  ; %NWL%9
scope . styles . push ( style )  ;%NWL%}%NWL%}  )  ; %NWL%attrs . $observe (  ' symbol '  , function ( symbol )  {%NWL%scope . symbol = ngxUtils . noUndefined ( symbol ,  ' \u2605 '  )  ;  /  / black star%NWL%}  )  ; %NWL%attrs . $observe (  ' readOnly '  , function ( readOnly )  {%NWL%scope . readOnly = angular . isDefined ( readOnly )  ;%NWL%}  )  ; %NWL%attrs . $observe (  ' clearable '  , function ( clearable )  {%NWL%scope . clearable = angular . isDefined ( clearable )  ; %NWL%7
}  ; %NWL%proto . include = function ( aabb )  {%NWL%if ( aabb )  {%NWL%if ( this . empty )  {%NWL%this . set ( aabb )  ;%NWL%} else {%NWL%if ( this . left > aabb . left )  {%NWL%this . left = aabb . left ;%NWL%}%NWL%if ( this . right < aabb . right )  {%NWL%this . right = aabb . right ; %NWL%7
consumerKey ,%NWL%consumerSecret ,%NWL%OAUTH_CONFIG . Version ,%NWL%null ,%NWL%OAUTH_CONFIG . Method%NWL%)  ; %NWL%this . accessKey = options . accessKey ; %NWL%this . accessSecret = options . accessSecret ; %NWL%this . _token = options . _token ; %NWL%this . _token_secret = options . _token_secret ; %NWL%this . _results = options . _results ; %NWL%6
}%NWL%function updateLine ( diff_x , diff_y )  {%NWL%var i = connections . length ; %NWL%while ( i -  -  )  {%NWL%var conn = connections [ i ]  ; %NWL%var line = conn . connector ; %NWL%var elem = conn . elem ; %NWL%var pre = conn . is_start? ' start '  :  ' end '  ; %NWL%var bb = elData ( line , pre +  ' _bb '  )  ; %NWL%bb . x = conn . start_x + diff_x ; %NWL%bb . y = conn . start_y + diff_y ; %NWL%9
exports . canvas = require (  '  .  / lib / widget / canvas '  )%NWL%exports . gauge = require (  '  .  / lib / widget / gauge . js '  )%NWL%exports . log = require (  '  .  / lib / widget / log . js '  )%NWL%exports . picture = require (  '  .  / lib / widget / picture . js '  )%NWL%exports . sparkline = require (  '  .  / lib / widget / sparkline . js '  )%NWL%exports . table = require (  '  .  / lib / widget / table . js '  )%NWL%exports . tree = require (  '  .  / lib / widget / tree . js '  )%NWL%exports . bar = require (  '  .  / lib / widget / charts / bar '  )%NWL%exports . line = require (  '  .  / lib / widget / charts / line '  )%NWL%exports . OutputBuffer = require (  '  .  / lib / server - utils '  )  . OutputBuffer%NWL%exports . InputBuffer = require (  '  .  / lib / server - utils '  )  . InputBuffer%NWL%9
if ( this . recurse )  {%NWL%fns . push (  [ routes [ r ]  . before , routes [ r ]  . on ]  . filter ( Boolean )  )  ; %NWL%next . after = next . after . concat (  [ routes [ r ]  . after ]  . filter ( Boolean )  )  ; %NWL%if ( routes =  =  = this . routes )  {%NWL%fns . push (  [ routes [  " before "  ]  , routes [  " on "  ]  ]  . filter ( Boolean )  )  ; %NWL%next . after = next . after . concat (  [ routes [  " after "  ]  ]  . filter ( Boolean )  )  ;%NWL%}%NWL%}%NWL%fns . matched = true ; %NWL%fns . captures = next . captures ; %NWL%fns . after = next . after ; %NWL%9
var fooRelation =  {  }  ,%NWL%barRelation =  {  }  ; %NWL%var relations =  [ fooRelation , barRelation ]  ; %NWL%var childRelation1 =  {  }  ; %NWL%var joinRelation1 =  {  }  ; %NWL%var childRelation2 =  {  }  ; %NWL%var joinRelation2 =  {  }  ; %NWL%var childTable1 =  {  }  ; %NWL%var childTable2 =  {  }  ; %NWL%childRelation1 . childTable = childTable1 ; %NWL%childRelation1 . joinRelation = joinRelation1 ; %NWL%9
bounds = shape . getBounds (  )  ; %NWL%box . left = Y_LANG . isNumber ( box . left ) ? Math . min ( box . left , bounds . left )  : bounds . left ; %NWL%box . top = Y_LANG . isNumber ( box . top ) ? Math . min ( box . top , bounds . top )  : bounds . top ; %NWL%box . right = Y_LANG . isNumber ( box . right ) ? Math . max ( box . right , bounds . right )  : bounds . right ; %NWL%box . bottom = Y_LANG . isNumber ( box . bottom ) ? Math . max ( box . bottom , bounds . bottom )  : bounds . bottom ;%NWL%}%NWL%}%NWL%box . left = Y_LANG . isNumber ( box . left ) ? box . left : 0 ; %NWL%box . top = Y_LANG . isNumber ( box . top ) ? box . top : 0 ; %NWL%box . right = Y_LANG . isNumber ( box . right ) ? box . right : 0 ; %NWL%box . bottom = Y_LANG . isNumber ( box . bottom ) ? box . bottom : 0 ; %NWL%7
Zotero . Group . prototype = new Zotero . Entry (  )  ; %NWL%Zotero . Group . prototype . loadObject = function ( ob )  {%NWL%var group = this ; %NWL%group . title = ob . title ; %NWL%group . author = ob . author ; %NWL%group . tagID = ob . tagID ; %NWL%group . published = ob . published ; %NWL%group . updated = ob . updated ; %NWL%group . links = ob . links ; %NWL%group . numItems = ob . numItems ; %NWL%group . items = ob . items ; %NWL%3
lessonController . get ( slugCompleted . slug , mapCallback )  ;%NWL%}  , function ( err , results )  {%NWL%console . log (  ' err :  '  + err )  ; %NWL%console . log (  ' results :  '  + results )  ; %NWL%console . log (  ' typeof err :  '  + typeof err )  ; %NWL%console . log (  ' typeof results :  '  + typeof results )  ; %NWL%console . log (  ' slugsCompletedSorted len :  '  + slugsCompletedSorted . length )  ; %NWL%for ( let i = 0 ; i < slugsCompletedSorted . length ; i +  +  )  {%NWL%console . log ( results [ i ]  . title )  ; %NWL%slugsCompletedSorted [ i ]  . title = results [ i ]  . title ; %NWL%slugsCompletedSorted [ i ]  . type = results [ i ]  . type ; %NWL%9
}%NWL%$scope . $watch (  ' newtask . description '  , function (  )  {%NWL%if ( $scope . newtask . description )  {%NWL%document . getElementById (  ' new - description '  )  . classList . remove (  ' error '  )%NWL%}%NWL%}  )%NWL%}%NWL%function TableCtrl ( $scope , stateService , $http )  {%NWL%$scope . state = stateService%NWL%$scope . urgency = stateService . urgency%NWL%$scope . taskNotDone = stateService . taskNotDone%NWL%9
radius = outer . style [ radius ]  . split (  / \s +  /  )  ; %NWL%outer . borderBox . radii [ index ]  [ 0 ]  = toPixels ( radius [ 0 ]  , outer . borderBox . width , outer . unitsMap )  ; %NWL%outer . borderBox . radii [ index ]  [ 1 ]  = toPixels ( radius . length > 1 ? radius [ 1 ]  : radius [ 0 ]  , outer . borderBox . height , outer . unitsMap )  ;%NWL%}  )  ; %NWL%var parseLength = function ( length )  { return parseInt ( length )  ;  }  ; %NWL%this . margins =  [ this . style . marginTop , this . style . marginRight , this . style . marginBottom , this . style . marginLeft ]  ; %NWL%this . margins = this . margins . map ( parseLength )  ; %NWL%this . borders =  [ this . style . borderTop , this . style . borderRight , this . style . borderBottom , this . style . borderLeft ]  ; %NWL%this . borders = this . borders . map ( parseLength )  ; %NWL%this . paddings =  [ this . style . paddingTop , this . style . paddingRight , this . style . paddingBottom , this . style . paddingLeft ]  ; %NWL%this . paddings = this . paddings . map ( parseLength )  ; %NWL%6
if ( !dojo . _hasResource [  " dojox . drawing . manager . Stencil "  ]  )  {  /  / _hasResource checks added by build . Do not use _hasResource directly in your code .%NWL%dojo . _hasResource [  " dojox . drawing . manager . Stencil "  ]  = true ; %NWL%dojo . provide (  " dojox . drawing . manager . Stencil "  )  ;%NWL%( function (  )  {%NWL%var surface , surfaceNode ; %NWL%dojox . drawing . manager . Stencil = dojox . drawing . util . oo . declare (%NWL%function ( options )  {%NWL%surface = options . surface ; %NWL%this . canvas = options . canvas ; %NWL%this . defaults = dojox . drawing . defaults . copy (  )  ; %NWL%this . undo = options . undo ; %NWL%8
case FormatterWorker . CSSParserStates . PropertyName : %NWL%if ( tokenValue =  =  =  "  :  " && tokenType =  =  = UndefTokenType )  {%NWL%property . name = property . name . trim (  )  ; %NWL%state = FormatterWorker . CSSParserStates . PropertyValue ;%NWL%} else if ( tokenType [  " property "  ]  )  {%NWL%property . name +  = tokenValue ;%NWL%}%NWL%break ; %NWL%case FormatterWorker . CSSParserStates . PropertyValue : %NWL%if ( tokenValue =  =  =  "  ;  " && tokenType =  =  = UndefTokenType )  {%NWL%property . value = property . value . trim (  )  ; %NWL%2
' use strict '  ; %NWL%define ( function ( require )  {%NWL%var oauthFetch = require (  '  .  / oauth2 / fetch '  )  ,%NWL%cards = require (  ' cards '  )  ; %NWL%return [%NWL%require (  '  .  / base '  )  ( require (  ' template! .  / setup_fix_oauth2 . html '  )  )  ,%NWL%{%NWL%extraClasses :  [  ' anim - fade '  ,  ' anim - overlay '  ]  ,%NWL%onArgs : function ( args )  {%NWL%this . account = args . account ; %NWL%this . restoreCard = args . restoreCard ; %NWL%9
raw : true ,%NWL%tolerant :  ( typeof syntax . errors ! =  =  ' undefined '  )  ,%NWL%source : null%NWL%}  ; %NWL%if ( options . comment )  {%NWL%options . attachComment = hasAttachedComment ( syntax )  ;%NWL%}%NWL%if ( typeof syntax . tokens ! =  =  ' undefined '  )  {%NWL%if ( syntax . tokens . length > 0 )  {%NWL%options . range =  ( typeof syntax . tokens [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . tokens [ 0 ]  . loc ! =  =  ' undefined '  )  ; %NWL%9
lightSource : function ( _entity , _config )  {%NWL%this . entity = _entity ; %NWL%this . color = _config . color ; %NWL%this . shadowColor = _config . shadowColor ? _config . shadowColor : this . color ; %NWL%this . useGradients = _config . useGradients ? _config . useGradients : false ; %NWL%this . shadowGradientStart = _config . shadowGradientStart ; %NWL%this . shadowGradientStop = _config . shadowGradientStop ; %NWL%this . lightGradientStart = _config . lightGradientStart ; %NWL%this . lightGradientStop = _config . lightGradientStop ; %NWL%this . radius = _config . radius ; %NWL%this . angleSpread = _config . angleSpread ; %NWL%2
var adaptDataForShowing = function adaptDataForShowing ( contact )  {%NWL%var output =  {%NWL%' uid '  :  '  - 1 '  ,%NWL%' givenName '  :  '  '  ,%NWL%' familyName '  :  '  '  ,%NWL%' email1 '  :  '  '  ,%NWL%' contactPictureUri '  :  '  '%NWL%}  ; %NWL%output . uid = contact . uid ; %NWL%if ( contact . familyName )  {%NWL%output . familyName = contact . familyName ; %NWL%8
el [ i ]  . style . webkitTransform = snabbtjs . mat_to_css ( matrix )  ; %NWL%el [ i ]  . style . transform = snabbtjs . mat_to_css ( matrix )  ;%NWL%}%NWL%} else {%NWL%el . style . webkitTransform = snabbtjs . mat_to_css ( matrix )  ; %NWL%el . style . transform = snabbtjs . mat_to_css ( matrix )  ;%NWL%}%NWL%}  ;%NWL%; snabbtjs . State = function ( config )  {%NWL%this . ax = snabbtjs . option_or_default ( config . ax , 0 )  ; %NWL%this . ay = snabbtjs . option_or_default ( config . ay , 0 )  ; %NWL%9
}%NWL%else if ( typeof ( appendElem )  =  =  ' undefined '  )  {%NWL%appendElem = document . getElementsByTagName (  ' body '  )  [ 0 ]  ;%NWL%}%NWL%var box = ZeroClipboard . getDOMObjectPosition ( this . domElement , appendElem )  ; %NWL%this . div = document . createElement (  ' div '  )  ; %NWL%var style = this . div . style ; %NWL%style . position =  ' absolute '  ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%style . width =  '  '  + box . width +  ' px '  ; %NWL%8
input . disable = input . disable . bind ( input )  ; %NWL%input . show = function (  )  {%NWL%this . touchTarget . style . display =  ' block '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%input . show = input . show . bind ( input )  ; %NWL%input . hide = function (  )  {%NWL%this . touchTarget . style . display =  ' none '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%input . hide = input . hide . bind ( input )  ; %NWL%0
_get_columns = function ( options )  {%NWL%if ( $ . isEmptyObject ( options . columns )  )  {%NWL%return _columns [ options . key + options . gid ] || false ;%NWL%} else {%NWL%return options . columns ;%NWL%}%NWL%}  ,%NWL%_options = function ( options )  {%NWL%options = $ . extend (  {  }  , $ . fn . sheetrock . options , options )  ; %NWL%options . key = _key ( options . url )  ; %NWL%options . gid = _gid ( options . url )  ; %NWL%9
if ( parameters . barBorderSize )  {%NWL%f . barBorderSize = parameters . barBorderSize ;%NWL%}%NWL%if ( parameters . barBackgroundWidth )  {%NWL%f . barBackgroundWidth = parameters . barBackgroundWidth ;%NWL%}%NWL%if ( parameters . barBackgroundHeight )  {%NWL%f . barBackgroundHeight = parameters . barBackgroundHeight ;%NWL%}%NWL%if ( parameters . assetTracker )  {%NWL%f . assetTracker = parameters . assetTracker ; %NWL%1
typecastBucketProps : function ( props )  {%NWL%keys =  [  ' w '  ,  ' r '  ,  ' dw '  ,  ' rw '  ,  ' n_val '  ,  ' young_vclock '  ,  ' old_vclock '  ,  ' small_vclock '  ,  ' big_vclock '  ]  ; %NWL%for ( var i = 0 ; i < keys . length ; i +  +  )  {%NWL%key = keys [ i ]  ; %NWL%val = parseInt ( props [ key ]  , 10 )  ; %NWL%if ( val )  {%NWL%props [ key ]  = parseInt ( props [ key ]  , 10 )  ;%NWL%}%NWL%}%NWL%props . allow_mult   = !!props . allow_mult ; %NWL%props . last_write_wins = !!props . last_write_wins ; %NWL%9
outputColor . add ( lightContribution )  ; %NWL%if ( material instanceof THREE . MeshPhongMaterial )  {%NWL%halfVector . addVectors ( lightVector , eyeVector )  . normalize (  )  ; %NWL%var dotNormalHalf = Math . max ( normalVector . dot ( halfVector )  , 0 . 0 )  ; %NWL%var specularIntensity = Math . max ( Math . pow ( dotNormalHalf , material . shininess )  , 0 . 0 )  * diffuseIntensity ; %NWL%var specularNormalization =  ( material . shininess + 2 . 0 )  / 8 . 0 ; %NWL%specularColor . copyGammaToLinear ( material . specular )  ; %NWL%var alpha = Math . pow ( Math . max ( 1 . 0 - lightVector . dot ( halfVector )  , 0 . 0 )  , 5 . 0 )  ; %NWL%schlick . r = specularColor . r +  ( 1 . 0 - specularColor . r )  * alpha ; %NWL%schlick . g = specularColor . g +  ( 1 . 0 - specularColor . g )  * alpha ; %NWL%schlick . b = specularColor . b +  ( 1 . 0 - specularColor . b )  * alpha ; %NWL%9
}%NWL%YAHOO . log (  ' Fetching image with id "  '  + this . domId +  '  "  .  '  ,  ' info '  ,  ' imageloader '  )  ; %NWL%this . _applyUrl ( el )  ; %NWL%if ( this . setVisible )  {%NWL%el . style . visibility =  ' visible '  ;%NWL%}%NWL%if ( this . width )  {%NWL%el . width = this . width ;%NWL%}%NWL%if ( this . height )  {%NWL%el . height = this . height ; %NWL%7
}%NWL%if ( SV . svs . maxclients > 1 )%NWL%Cvar . SetValue (  ' deathmatch '  , 1 )  ; %NWL%else%NWL%Cvar . SetValue (  ' deathmatch '  , 0 )  ;%NWL%}  ; %NWL%Host . InitLocal = function (  )%NWL%{%NWL%Host . InitCommands (  )  ; %NWL%Host . framerate = Cvar . RegisterVariable (  ' host_framerate '  ,  ' 0 '  )  ; %NWL%Host . speeds = Cvar . RegisterVariable (  ' host_speeds '  ,  ' 0 '  )  ; %NWL%9
exports . BINARY  = exports . BINARY ; %NWL%exports . CP1250  = exports . CP1250_GENERAL_CI ; %NWL%exports . CP1251  = exports . CP1251_GENERAL_CI ; %NWL%exports . CP1256  = exports . CP1256_GENERAL_CI ; %NWL%exports . CP1257  = exports . CP1257_GENERAL_CI ; %NWL%exports . CP866  = exports . CP866_GENERAL_CI ; %NWL%exports . CP850  = exports . CP850_GENERAL_CI ; %NWL%exports . CP852  = exports . CP852_GENERAL_CI ; %NWL%exports . CP932  = exports . CP932_JAPANESE_CI ; %NWL%exports . DEC8  = exports . DEC8_SWEDISH_CI ; %NWL%exports . EUCJPMS  = exports . EUCJPMS_JAPANESE_CI ; %NWL%8
if ( this . bones . LeftUpLeg . x >  = this . zw )  {%NWL%this . bones . LeftUpLeg . x = 0 ; %NWL%this . bones . RightUpLeg . x = 0 ; %NWL%this . bones . LeftLowLeg . x = 0 ; %NWL%this . bones . RightLowLeg . x = 0 ;%NWL%}%NWL%}%NWL%}  ; %NWL%Human . bone = function ( x , y , z , w , h , d )  {%NWL%this . x = x || 0 ; %NWL%this . y = y || 0 ; %NWL%9
on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%e . pageX = data . pageX ; %NWL%e . pageY = data . pageY ; %NWL%7
Hoek . assert ( schema && schema . isJoi ,  ' Invalid schema object '  )  ; %NWL%Hoek . assert ( schema . _type =  =  =  ' any ' || schema . _type =  =  = this . _type ,  ' Cannot merge with another type :  '  , schema . _type )  ; %NWL%var obj = this . clone (  )  ; %NWL%obj . _settings = obj . _settings ? internals . concatSettings ( obj . _settings , schema . _settings )  : schema . _settings ; %NWL%obj . _valids . merge ( schema . _valids , schema . _invalids )  ; %NWL%obj . _invalids . merge ( schema . _invalids , schema . _valids )  ; %NWL%obj . _tests = obj . _tests . concat ( schema . _tests )  ; %NWL%obj . _refs = obj . _refs . concat ( schema . _refs )  ; %NWL%Hoek . merge ( obj . _flags , schema . _flags )  ; %NWL%obj . _description = schema . _description || obj . _description ; %NWL%obj . _unit = schema . _unit || obj . _unit ; %NWL%9
json . maxOrthographicSize = this . maxOrthographicSize ; %NWL%return json ;%NWL%}  ; %NWL%Camera . prototype . fromJSON = function ( json )  {%NWL%Component . prototype . fromJSON . call ( this , json )  ; %NWL%this . width = json . width ; %NWL%this . height = json . height ; %NWL%this . aspect = json . aspect ; %NWL%this . autoResize = json . autoResize ; %NWL%this . background . fromJSON ( json . background )  ; %NWL%this . far = json . far ; %NWL%5
, ra_int%NWL%, dec%NWL%, dec_int ; %NWL%if ( params . debug )  {%NWL%console . log (  " 1CP - X :  "  , current_position . x )  ; %NWL%console . log (  " 1CP - Y :  "  , current_position . y )  ; %NWL%console . log (  " 1CP - Z :  "  , current_position . z )  ;%NWL%}%NWL%current_position . x = 3 * current_position . x + desired_position . x ; %NWL%current_position . y = 3 * current_position . y + desired_position . y ; %NWL%current_position . z = 3 * current_position . z + desired_position . z ; %NWL%8
this . _isProduction = isProduction ; %NWL%isProduction && this . setLevel ( logging . NONE )  ;%NWL%}%NWL%this . setLevel = function ( level )  {%NWL%this . _level = level ; %NWL%if ( this . _isProduction )  {%NWL%level = logging . NONE ;%NWL%}%NWL%this . DEBUG = level <  = logging . DEBUG ; %NWL%this . LOG  = level <  = logging . LOG ; %NWL%this . INFO  = level <  = logging . INFO ; %NWL%8
}%NWL%function fillSelectElement ( selector , options )  {%NWL%selector . innerHTML =  '  '  ; %NWL%options . sort ( function ( a , b )  {%NWL%return ( a . text > b . text )  ;%NWL%}  )  ; %NWL%for ( var i = 0 ; i < options . length ; i +  +  )  {%NWL%var option = document . createElement (  ' option '  )  ; %NWL%option . textContent = options [ i ]  . text ; %NWL%option . selected = options [ i ]  . selected ; %NWL%option . value = options [ i ]  . value ; %NWL%9
height = Math . max ( height , type_size . height )  ;%NWL%}%NWL%return {%NWL%' width '  : insets . left + insets . right + my . columns * width +  ( my . columns - 1 )  * my . hgap ,%NWL%' height '  : insets . top + insets . bottom + my . rows * height +  ( my . rows - 1 )  * my . vgap%NWL%}  ;%NWL%}  ;%NWL%}%NWL%that . preferred = typeLayout (  ' preferred '  )  ; %NWL%that . minimum = typeLayout (  ' minimum '  )  ; %NWL%that . maximum = typeLayout (  ' maximum '  )  ; %NWL%8
}  )  ; %NWL%var T = !!graph . getNode ( this . root )  . visited ; %NWL%graph . eachNode ( function ( node )  {%NWL%node . eachAdjacency ( function ( adj )  {%NWL%var nodeTo = adj . nodeTo ; %NWL%if ( !!nodeTo . visited =  =  = T )  {%NWL%$ . each ( property , function ( p )  {%NWL%var vp = node . getPos ( p )  , up = nodeTo . getPos ( p )  ; %NWL%dpos . x = vp . x - up . x ; %NWL%dpos . y = vp . y - up . y ; %NWL%dpos . z = vp . z - up . z ; %NWL%8
exports . extend = require (  ' pouchdb - extend '  )  ; %NWL%exports . ajax = require (  '  .  / deps / ajax '  )  ; %NWL%exports . createBlob = require (  '  .  / deps / blob '  )  ; %NWL%exports . uuid = require (  '  .  / deps / uuid '  )  ; %NWL%exports . getArguments = require (  ' argsarray '  )  ; %NWL%var buffer = require (  '  .  / deps / buffer '  )  ; %NWL%var errors = require (  '  .  / deps / errors '  )  ; %NWL%var EventEmitter = require (  ' events '  )  . EventEmitter ; %NWL%var collections = require (  ' pouchdb - collections '  )  ; %NWL%exports . Map = collections . Map ; %NWL%exports . Set = collections . Set ; %NWL%9
}  )  ; %NWL%_Widget . markupFactory = function ( node , cell )  {%NWL%BaseCell . markupFactory ( node , cell )  ; %NWL%var widgetProps = lang . trim ( domAttr . get ( node ,  " widgetProps "  ) || "  "  )  ; %NWL%var constraint = lang . trim ( domAttr . get ( node ,  " constraint "  ) || "  "  )  ; %NWL%var widgetClass = lang . trim ( domAttr . get ( node ,  " widgetClass "  ) || "  "  )  ; %NWL%if ( widgetProps )  {%NWL%cell . widgetProps = json . fromJson ( widgetProps )  ;%NWL%}%NWL%if ( constraint )  {%NWL%cell . constraint = json . fromJson ( constraint )  ; %NWL%7
}  , options )  ; %NWL%var body_def   = new b2BodyDef (  )  ; %NWL%var fix_def   = new b2FixtureDef ; %NWL%fix_def . density  = options . density ; %NWL%fix_def . friction  = options . friction ; %NWL%fix_def . restitution  = options . restitution ; %NWL%fix_def . shape   = new b2PolygonShape (  )  ; %NWL%fix_def . shape . SetAsBox ( width / scale , height / scale )  ; %NWL%body_def . position . Set ( x / scale , y / scale )  ; %NWL%body_def . linearDamping = options . linearDamping ; %NWL%body_def . angularDamping = options . angularDamping ; %NWL%9
material . bumpScale = new THREE . Vector2 ( data . bumpScale , data . bumpScale )  ;%NWL%}%NWL%}%NWL%if ( data . alphaMap ! =  = undefined )  {%NWL%material . alphaMap = getTexture ( data . alphaMap )  ;%NWL%}%NWL%if ( data . envMap ! =  = undefined )  {%NWL%material . envMap = getTexture ( data . envMap )  ;%NWL%}%NWL%if ( data . normalMap ! =  = undefined )  {%NWL%material . normalMap = getTexture ( data . normalMap )  ; %NWL%4
calls : 0 ,%NWL%duration : 0 . 0 ,%NWL%min : Number . MAX_VALUE ,%NWL%max : 0 . 0 ,%NWL%sumOfSquares : 0 . 0%NWL%}  ;%NWL%}%NWL%prevProfile . calls = profile . calls ; %NWL%prevProfile . duration = profile . duration ; %NWL%prevProfile . min = profile . min ; %NWL%prevProfile . max = profile . max ; %NWL%7
var normalizedLX = LSValues . x / this . moveSensibility ; %NWL%var normalizedLY = LSValues . y / this . moveSensibility ; %NWL%LSValues . x = Math . abs ( normalizedLX )  > 0 . 005 ? 0 + normalizedLX : 0 ; %NWL%LSValues . y = Math . abs ( normalizedLY )  > 0 . 005 ? 0 + normalizedLY : 0 ; %NWL%var cameraTransform = BABYLON . Matrix . RotationYawPitchRoll ( this . rotation . y , this . rotation . x , 0 )  ; %NWL%var deltaTransform = BABYLON . Vector3 . TransformCoordinates ( new BABYLON . Vector3 ( LSValues . x , 0 ,  - LSValues . y )  , cameraTransform )  ; %NWL%this . cameraDirection = this . cameraDirection . add ( deltaTransform )  ;%NWL%}  ; %NWL%OculusGamepadCamera . prototype . _updateCamera = function ( camera )  {%NWL%camera . minZ = this . minZ ; %NWL%camera . maxZ = this . maxZ ; %NWL%9
}%NWL%Highcharts . wrap ( Highcharts . Series . prototype ,  ' alignDataLabel '  , function ( proceed )  {%NWL%if ( this . chart . is3d (  ) && ( this . type =  =  =  ' column ' || this . type =  =  =  ' columnrange '  )  )  {%NWL%var series = this ,%NWL%chart = series . chart ; %NWL%var args = arguments ,%NWL%alignTo = args [ 4 ]  ; %NWL%var pos =  (  { x : alignTo . x , y : alignTo . y , z : series . z }  )  ; %NWL%pos = perspective (  [ pos ]  , chart , true )  [ 0 ]  ; %NWL%alignTo . x = pos . x ; %NWL%alignTo . y = pos . y ; %NWL%9
if ( typeof options . showWeekNumbers =  =  ' boolean '  )  {%NWL%this . showWeekNumbers = options . showWeekNumbers ;%NWL%}%NWL%if ( typeof options . buttonClasses =  =  ' string '  )  {%NWL%this . buttonClasses =  [ options . buttonClasses ]  ;%NWL%}%NWL%if ( typeof options . buttonClasses =  =  ' object '  )  {%NWL%this . buttonClasses = options . buttonClasses ;%NWL%}%NWL%if ( typeof options . showDropdowns =  =  ' boolean '  )  {%NWL%this . showDropdowns = options . showDropdowns ; %NWL%1
list = this . _protrusion (  { x1 : r , y1 : b , x2 : p , y2 : p }  ,  " SE "  , list )  ; %NWL%list = this . _protrusion (  { x1 : l , y1 : b , x2 : r , y2 : p }  ,  " S "  , list )  ; %NWL%list = this . _protrusion (  { x1 : n , y1 : b , x2 : l , y2 : p }  ,  " SW "  , list )  ; %NWL%list = this . _protrusion (  { x1 : n , y1 : t , x2 : l , y2 : b }  ,  " W "  , list )  ; %NWL%list = this . _protrusion (  { x1 : n , y1 : n , x2 : l , y2 : t }  ,  " NW "  , list )  ; %NWL%return list ;%NWL%}  ; %NWL%function Collision ( targetNode , obstacleNode , overlapCoords , overlapType )%NWL%{%NWL%this . target   = targetNode ; %NWL%this . obstacle   = obstacleNode ; %NWL%9
} else if ( typeof entry =  =  =  ' object '  )  {%NWL%var subChatMessage = new ChatMessage ( entry )  ; %NWL%that . extra . push ( subChatMessage )  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%this . bold = json . bold ; %NWL%this . italic = json . italic ; %NWL%this . underlined = json . underlined ; %NWL%this . strikethrough = json . strikethrough ; %NWL%this . obfuscated = json . obfuscated ; %NWL%6
result . push ( this . content [ ic ]  )  ;%NWL%}%NWL%}%NWL%return result ;%NWL%}  ; %NWL%Page . prototype . scrapeFrom = function ( controller )  {%NWL%var self = this ; %NWL%self . title = controller . getParam (  " title "  , self . title )  ; %NWL%self . active = controller . getParam (  " active "  ,  " N "  )  ; %NWL%self . keywords = controller . getParam (  " keywords "  ,  "  "  )  ; %NWL%self . description = controller . getParam (  " description "  ,  "  "  )  ; %NWL%9
this . confidence =  - 10000 ; %NWL%this . detection =  '  '  ; %NWL%this . time = 0 ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . facetrackr . TrackObj (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%c . angle = this . angle ; %NWL%c . x = this . x ; %NWL%c . y = this . y ; %NWL%c . confidence = this . confidence ; %NWL%5
}%NWL%var prop = this . properties [ p ]  ; %NWL%if ( lang . isFunction ( prop )  )  {%NWL%prop = prop ( n )  ;%NWL%}%NWL%prop = pm [ p ]  = _mixin (  {  }  ,  ( lang . isObject ( prop ) ? prop :  { end : prop }  )  )  ; %NWL%if ( lang . isFunction ( prop . start )  )  {%NWL%prop . start = prop . start ( n )  ;%NWL%}%NWL%if ( lang . isFunction ( prop . end )  )  {%NWL%prop . end = prop . end ( n )  ; %NWL%7
initialize : function ( options )%NWL%{%NWL%options || ( options =  {  }  )  ; %NWL%if ( !options . hasher )%NWL%this . hasher		 = typeof ( SHA1 ) ! =  ' undefined ' ? SHA1 : null ; %NWL%else%NWL%this . hasher		 = options . hasher ; %NWL%if ( options . key_size && options . key_size % 4 ! = 0 )%NWL%throw new Error (  ' Key size must be a multiple of 4 bytes .  '  )  ; %NWL%else%NWL%this . key_size = options . key_size ; %NWL%6
this . ovmap . zoomToMaxExtent (  )  ; %NWL%this . wComp = parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - left - width '  )  )  +%NWL%parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - right - width '  )  )  ; %NWL%this . wComp =  ( this . wComp ) ? this . wComp : 2 ; %NWL%this . hComp = parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - top - width '  )  )  +%NWL%parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - bottom - width '  )  )  ; %NWL%this . hComp =  ( this . hComp ) ? this . hComp : 2 ; %NWL%5
exports . ReplSetServers = exports . ReplSet ; %NWL%exports . Binary = require (  ' bson '  )  . Binary ; %NWL%exports . Code = require (  ' bson '  )  . Code ; %NWL%exports . DBRef = require (  ' bson '  )  . DBRef ; %NWL%exports . Double = require (  ' bson '  )  . Double ; %NWL%exports . Long = require (  ' bson '  )  . Long ; %NWL%exports . MinKey = require (  ' bson '  )  . MinKey ; %NWL%exports . MaxKey = require (  ' bson '  )  . MaxKey ; %NWL%exports . ObjectID = require (  ' bson '  )  . ObjectID ; %NWL%exports . Symbol = require (  ' bson '  )  . Symbol ; %NWL%exports . Timestamp = require (  ' bson '  )  . Timestamp ; %NWL%1
internals . Any . prototype . isImmutable = true ;   /  / Prevents Hoek from deep cloning schema objects%NWL%internals . Any . prototype . clone = function (  )  {%NWL%var obj = Object . create ( Object . getPrototypeOf ( this )  )  ; %NWL%obj . isJoi = true ; %NWL%obj . _type = this . _type ; %NWL%obj . _settings = internals . concatSettings ( this . _settings )  ; %NWL%obj . _valids = Hoek . clone ( this . _valids )  ; %NWL%obj . _invalids = Hoek . clone ( this . _invalids )  ; %NWL%obj . _tests = this . _tests . slice (  )  ; %NWL%obj . _refs = this . _refs . slice (  )  ; %NWL%obj . _flags = Hoek . clone ( this . _flags )  ; %NWL%6
var EventEmitter = require (  " events "  )  . EventEmitter ; %NWL%var clone = require (  " clone "  )  ; %NWL%var when = require (  " when "  )  ; %NWL%var flows = require (  "  .  / flows "  )  ; %NWL%var credentials = require (  '  .  / credentials '  )%NWL%function Node ( n )  {%NWL%this . id = n . id ; %NWL%flows . add ( this )  ; %NWL%this . type = n . type ; %NWL%if ( n . name )  {%NWL%this . name = n . name ; %NWL%6
this . url = this . urlTemplate ; %NWL%this . refSeq = args . refSeq ; %NWL%this . baseUrl = args . baseUrl ; %NWL%this . density = 0 ; %NWL%this . url = Util . resolveUrl (%NWL%this . baseUrl ,%NWL%Util . fillTemplate ( args . urlTemplate ,%NWL%{  ' refseq '  : this . refSeq . name }%NWL%)%NWL%)  ; %NWL%this . queryTemplate = args . queryTemplate ; %NWL%1
}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function (  )  {  }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%9
} else {%NWL%params . options . _requester = requester%NWL%}%NWL%}%NWL%return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . patch = def ( request . patch )%NWL%9
}  ,%NWL%{%NWL%updateProjectionMatrix : function (  )  {%NWL%var rad = this . fov / 180 * Math . PI ; %NWL%this . projectionMatrix . perspective ( rad , this . aspect , this . near , this . far )  ;%NWL%}  ,%NWL%clone : function (  )  {%NWL%var camera = Camera . prototype . clone . call ( this )  ; %NWL%camera . fov = this . fov ; %NWL%camera . aspect = this . aspect ; %NWL%camera . near = this . near ; %NWL%8
nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%nl . lang . value = dom . getAttrib ( n ,  ' lang '  )  ; %NWL%0
this . centerX = params . centerX ; %NWL%this . centerY = params . centerY ; %NWL%this . arcWidth = params . arcWidth ; %NWL%this . innerRadius = params . innerRadius || 0 ; %NWL%this . fillColor = params . fillColor || ' #fff '  ; %NWL%this . outlineColor = params . outlineColor || this . fillColor ; %NWL%this . progressListener = params . progressListener ; %NWL%this . infoLineLength = params . infoLineLength || 250 ; %NWL%this . horizLineLength = params . horizLineLength || 50 ; %NWL%this . infoListener = params . infoListener ; %NWL%this . infoLineAngle = params . infoLineAngle ; %NWL%0
constructor : function ( obj )  {%NWL%this . name = obj . name ; %NWL%this . clientId = obj . clientId ; %NWL%this . clientSecret = obj . clientSecret ; %NWL%this . authUrl = obj . authUrl ; %NWL%this . tokenUrl = obj . tokenUrl ; %NWL%this . type = obj . type ; %NWL%this . grantType = obj . grantType ; %NWL%this . authentication = obj . authentication ; %NWL%this . override = obj . override ; %NWL%this . authHeader = obj . authHeader ; %NWL%1
return goog . dom . TextRangeIterator . superClass_ . next . call ( this )  ;%NWL%}  ; %NWL%goog . dom . TextRangeIterator . prototype . skipTag = function (  )  {%NWL%goog . dom . TextRangeIterator . superClass_ . skipTag . apply ( this )  ; %NWL%if ( goog . dom . contains ( this . node , this . endNode_ )  )  {%NWL%throw goog . iter . StopIteration ;%NWL%}%NWL%}  ; %NWL%goog . dom . TextRangeIterator . prototype . copyFrom = function ( other )  {%NWL%this . startNode_ = other . startNode_ ; %NWL%this . endNode_ = other . endNode_ ; %NWL%9
require (  ' elements / delegation '  )  ; %NWL%var Resizer = new prime (  {%NWL%mixin :  [ Bound , Options ]  ,%NWL%DRAG_EVENTS : DragEvents ,%NWL%options :  {%NWL%minSize : 5%NWL%}  ,%NWL%constructor : function ( container , options )  {%NWL%this . setOptions ( options )  ; %NWL%this . history = this . options . history || {  }  ; %NWL%this . builder = this . options . builder || {  }  ; %NWL%9
this . onafterinit  = function (  )     { this . called . push (  " onafterinit "  )  ;        }  ; %NWL%this . onbeforestartup = function (  )     { this . called . push (  " onbeforestartup "  )  ;       }  ; %NWL%this . onafterstartup  = function (  )     { this . called . push (  " onafterstartup "  )  ;       }  ; %NWL%this . onbeforepanic  = function (  )     { this . called . push (  " onbeforepanic "  )  ;       }  ; %NWL%this . onafterpanic  = function (  )     { this . called . push (  " onafterpanic "  )  ;       }  ; %NWL%this . onbeforecalm  = function (  )     { this . called . push (  " onbeforecalm "  )  ;       }  ; %NWL%this . onaftercalm  = function (  )     { this . called . push (  " onaftercalm "  )  ;        }  ; %NWL%this . onenternone  = function (  )     { this . called . push (  " onenternone "  )  ;        }  ; %NWL%this . onentergreen  = function (  )     { this . called . push (  " onentergreen "  )  ;       }  ; %NWL%this . onenterred   = function (  )     { this . called . push (  " onenterred "  )  ;        }  ; %NWL%this . onleavenone  = function (  )     { this . called . push (  " onleavenone "  )  ;        }  ; %NWL%0
fill : 		 {  }  ,%NWL%font : 		 "  "  ,%NWL%fontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = dojo . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%du . updateWithPattern ( this . opt , kwArgs , this . optionalParams )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%9
extra . angle = act . angle ;%NWL%}%NWL%if ( extra . x =  =  = undefined )  {%NWL%if ( atk . initPosition . type =  =  =  ' actor '  )  {%NWL%extra . x = act . x ; %NWL%extra . y = act . y ;%NWL%}%NWL%if ( atk . initPosition . type =  =  =  ' mouse '  )  {%NWL%var end = Attack . getInitPosition ( atk , act )  ; %NWL%extra . x = end . x ; %NWL%extra . y = end . y ; %NWL%9
$timeout ( function (  )  {%NWL%console . log (  " Initializing complete .  "  )%NWL%initialize . resolve (  )  ;%NWL%}  , 0 )  ;%NWL%}  ]  )  ; %NWL%app . constant (  " availableLanguages "  , languages )  ; %NWL%app . provider (  " translationData "  , function translationDataProvider (  )  {%NWL%this . add = _ . bind ( translationData . add , translationData )  ; %NWL%this . load = _ . bind ( translationData . load , translationData )  ; %NWL%this . language = _ . bind ( translationData . language , translationData )  ; %NWL%this . default_language = _ . bind ( translationData . default_language , translationData )  ; %NWL%7
}%NWL%}%NWL%}  ,%NWL%renderLinks : function (  )  {%NWL%for ( var key in allLinks )  {%NWL%if ( allLinks . hasOwnProperty ( key )  )  {%NWL%var linkUI = allLinks [ key ]  ; %NWL%cachedFromPos . x = linkUI . position . from . x ; %NWL%cachedFromPos . y = linkUI . position . from . y ; %NWL%cachedToPos . x = linkUI . position . to . x ; %NWL%cachedToPos . y = linkUI . position . to . y ; %NWL%9
_bound : false ,%NWL%init : function ( options )%NWL%{%NWL%this . _super (  ' scale '  )  ; %NWL%if ( pc . valid ( options )  )%NWL%this . config ( options )  ;%NWL%}  ,%NWL%config : function ( options )%NWL%{%NWL%this . x = pc . checked ( options . x , 1 )  ; %NWL%this . y = pc . checked ( options . y , 1 )  ; %NWL%9
o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%o2 . arcScaleY_  = o1 . arcScaleY_ ; %NWL%0
this . animating = false ;%NWL%}  ,%NWL%zoom : function ( x , y , scale , time )  {%NWL%var that = this ,%NWL%relScale = scale / that . scale ; %NWL%if ( !that . options . useTransform ) return ; %NWL%time =  ( time || 200 )  +  ' ms '%NWL%x = x - that . wrapperOffsetLeft - that . x ; %NWL%y = y - that . wrapperOffsetTop - that . y ; %NWL%that . x = x - x * relScale + that . x ; %NWL%that . y = y - y * relScale + that . y ; %NWL%9
json . speed = this . speed ; %NWL%json . speedSpread = this . speedSpread ; %NWL%json . worldSpace = this . worldSpace ; %NWL%json . minEmission = this . minEmission ; %NWL%json . maxEmission = this . maxEmission ; %NWL%json . minLife = this . minLife ; %NWL%json . maxLife = this . maxLife ; %NWL%json . minSize = this . minSize ; %NWL%json . maxSize = this . maxSize ; %NWL%json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%9
console . error (  ' THREE . DDSLoader . parse : Unsupported FourCC code '  , int32ToFourCC ( fourCC )  )  ; %NWL%return dds ;%NWL%}%NWL%}%NWL%dds . mipmapCount = 1 ; %NWL%if ( header [ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps ! =  = false )  {%NWL%dds . mipmapCount = Math . max ( 1 , header [ off_mipmapCount ]  )  ;%NWL%}%NWL%dds . isCubemap = header [ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false ; %NWL%dds . width = header [ off_width ]  ; %NWL%dds . height = header [ off_height ]  ; %NWL%9
this . aggregates = obj . aggregates ;%NWL%}%NWL%}  ; %NWL%cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . locales = obj . locales ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%0
cnl [ i ]  ( obj )  ;%NWL%}  ;%NWL%}  ; %NWL%function FilePackage ( file , receiving , params )  {%NWL%_this = this ; %NWL%this . name = file . name ; %NWL%this . size = file . size ; %NWL%if ( receiving )  {%NWL%this . uid = file . uid ; %NWL%this . isText = file . isText ; %NWL%this . mimeType = file . mimeType ; %NWL%5
this . fbo = new Framebuffer ( this . gl )  . bind (  )  . color ( this )  ;%NWL%}%NWL%this . gl . readPixels ( 0 , 0 , this . width , this . height , this . gl . RGBA , this . gl . UNSIGNED_BYTE , dst )  ; %NWL%this . fbo . unbind (  )  ; %NWL%return dst ;%NWL%}  ; %NWL%Texture2D . prototype . toPNG = function (  )  {%NWL%var canvas , ctx , data , i , imgdata , result , url , _i , _ref ; %NWL%canvas = document . createElement (  ' canvas '  )  ; %NWL%canvas . height = this . height ; %NWL%canvas . width = this . width ; %NWL%9
}  ,%NWL%warn : function ( msg )  {%NWL%this . log ( Level . WARN , msg )  ;%NWL%}  ,%NWL%error : function ( msg )  {%NWL%this . log ( Level . ERROR , msg )  ;%NWL%}%NWL%}  ; %NWL%var exportBasicOptions = function ( exports , options )  {%NWL%exports . name = options . name ; %NWL%exports . version = options . version ; %NWL%9
}  ,%NWL%getStepDefinitionInner2 : function (  )  {%NWL%return '  ,  (  '  ;%NWL%}  ,%NWL%getStepDefinitionEnd : function (  )  {%NWL%return '  )  -  > \n # '  + this . getStepDefinitionEndComment (  )  +  ' \n callback . pending (  ) \n '  ;%NWL%}%NWL%}  ; %NWL%_ . extend ( CoffeeScriptSyntax . prototype , Syntax . prototype )  ; %NWL%exports . JavaScript  = JavaScriptSyntax ; %NWL%exports . CoffeeScript = CoffeeScriptSyntax ; %NWL%9
gSite . pasvmode   = $ (  ' pasvmode '  )  . checked ; %NWL%gSite . ipmode    = $ (  ' ipmode '  )  . checked ; %NWL%gSite . webhost    = $ (  ' webhost '  )  . value . trim (  )  ; %NWL%gSite . prefix    = $ (  ' prefix '  )  . value ; %NWL%gSite . localdir   = $ (  ' localdir '  )  . value ; %NWL%gSite . remotedir   = $ (  ' remotedir '  )  . value ; %NWL%gSite . treesync   = $ (  ' treesync '  )  . checked ; %NWL%gSite . encoding   = $ (  ' encoding '  )  . getAttribute (  " label "  )  ; %NWL%gSite . notes    = $ (  ' notes '  )  . value ; %NWL%gSite . timezone   =  ( parseInt ( $ (  ' timezoneHours '  )  . value )  * 60 )  + parseInt ( $ (  ' timezoneMinutes '  )  . value )  ; %NWL%gSite . privatekey   = $ (  ' privatekey '  )  . value ; %NWL%3
_scene . volume . transform = Array . apply (  [  ]  , volume . transform . matrix )  ;%NWL%}%NWL%if ( _data . labelmap . file . length > 0 )  {%NWL%_scene . labelmap . visible = volume . labelmap . visible ; %NWL%_scene . labelmap . opacity = volume . labelmap . opacity ;%NWL%}%NWL%if ( _data . mesh . file . length > 0 )  {%NWL%_scene . mesh . visible = mesh . visible ; %NWL%_scene . mesh . opacity = mesh . opacity ; %NWL%_scene . mesh . color = mesh . color ; %NWL%_scene . mesh . transform = Array . apply (  [  ]  , mesh . transform . matrix )  ; %NWL%0
return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . putElement = _ . bind ( putElementFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%6
var dbz =  ( end . bz - start . bz )  ; %NWL%var dsx =  ( end . sx - start . sx )  ; %NWL%var dsy =  ( end . sy - start . sy )  ; %NWL%var dskewx =  ( end . skew_x - start . skew_x )  ; %NWL%var dskewy =  ( end . skew_y - start . skew_y )  ; %NWL%var dwidth =  ( end . width - start . width )  ; %NWL%var dheight =  ( end . height - start . height )  ; %NWL%var dopacity =  ( end . opacity - start . opacity )  ; %NWL%result . ax = start . ax + tween_value * dax ; %NWL%result . ay = start . ay + tween_value * day ; %NWL%result . az = start . az + tween_value * daz ; %NWL%8
this . el = el ; %NWL%this . prev = __bind ( this . prev , this )  ; %NWL%this . next = __bind ( this . next , this )  ; %NWL%this . stop = __bind ( this . stop , this )  ; %NWL%this . play = __bind ( this . play , this )  ; %NWL%this . to = __bind ( this . to , this )  ; %NWL%this . _createArrows = __bind ( this . _createArrows , this )  ; %NWL%this . _createPagination = __bind ( this . _createPagination , this )  ; %NWL%this . _enableBindKeys = __bind ( this . _enableBindKeys , this )  ; %NWL%this . _enablesFluidBehavior = __bind ( this . _enablesFluidBehavior , this )  ; %NWL%this . _enablesAutoPlay = __bind ( this . _enablesAutoPlay , this )  ; %NWL%1
var FileDetails = function ( directoryEntry )  {%NWL%this . _offset = 0 ; %NWL%this . _maxSize = 0 ; %NWL%this . parent = path . dirname ( directoryEntry . fileName )  ; %NWL%this . filename = path . basename ( directoryEntry . fileName )  ; %NWL%this . path = path . normalize ( directoryEntry . fileName )  ; %NWL%this . type = directoryEntry . fileAttributes . type ; %NWL%this . mode = directoryEntry . fileAttributes . mode ; %NWL%this . compressionMethod = directoryEntry . compressionMethod ; %NWL%this . modified = directoryEntry . modifiedTime ; %NWL%this . crc32 = directoryEntry . crc32 ; %NWL%8
if ( typeof object . server_options . auto_reconnect ! =  ' boolean '  )  {%NWL%object . server_options . auto_reconnect = true ;%NWL%}%NWL%for ( var i = 0 ; i < object . servers . length ; i +  +  )  {%NWL%var _server_options =  { poolSize : 1 , socketOptions :  { connectTimeoutMS : 1000 }  , auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%6
this . offset = 0 ; %NWL%this . targetValue = null ; %NWL%this . valueAnimatorFunction = valueAnimatorFunction ; %NWL%if ( options ! =  = undefined )  {%NWL%if ( options . duration ! =  = undefined )%NWL%this . duration = options . duration ; %NWL%if ( options . blending ! =  = undefined )  {%NWL%this . blendingFunction = window . Infertek . Animations . FrameBlendingFunctions . GetBlendingByName ( options . blending )  ;%NWL%}%NWL%if ( options . offset ! =  = undefined )%NWL%this . offset = options . offset ; %NWL%5
goog . require (  ' app . InputEvent '  )  ; %NWL%goog . provide (  ' app . Controls '  )  ; %NWL%app . Controls = function ( el , state )  {%NWL%this . $el = $ ( el )  ; %NWL%this . state = state ; %NWL%this . startX =  - 1 ; %NWL%this . latestX =  - 1 ; %NWL%this . dragging = false ; %NWL%this . onDragStart_ = this . onDragStart_ . bind ( this )  ; %NWL%this . onDragMove_ = this . onDragMove_ . bind ( this )  ; %NWL%this . onDragEnd_ = this . onDragEnd_ . bind ( this )  ; %NWL%8
return _cursor . isClosed (  )  ;%NWL%}%NWL%this . rewind = function (  )  {%NWL%return _cursor . rewind (  )  ;%NWL%}%NWL%this . limit = function ( limit , callback )  {%NWL%_cursor . limit ( limit , callback )  ; %NWL%_scope_options . limit = limit ; %NWL%return this ;%NWL%}%NWL%this . skip = function ( skip , callback )  {%NWL%5
module . exports . toBadgekitBadge = function toBadgekitBadge ( badge )  {%NWL%var newBadge =  {  }  ; %NWL%newBadge . id = badge . slug ; %NWL%newBadge . description = badge . strapline ; %NWL%newBadge . name = badge . name ; %NWL%newBadge . status = badge . archived ? ' archived '  :  ' published '  ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%newBadge . timeUnits = badge . timeUnits ; %NWL%4
exports . getCell = GameWorldModelIso . prototype . getCell ; %NWL%exports . rightFloor = GameWorldModelIso . prototype . rightFloor ; %NWL%exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%exports . getWorldCellFromVisibleCellPos = GameWorldModelIso . prototype . getWorldCellFromVisibleCellPos ; %NWL%exports . getWorldCellDrawDimensions = GameWorldModelIso . prototype . getWorldCellDrawDimensions ; %NWL%exports . getCellCenter = GameWorldModelIso . prototype . getCellCenter ; %NWL%exports . getWorldCellCenter = GameWorldModelIso . prototype . getWorldCellCenter ; %NWL%exports . placeSpriteInWorldCell = GameWorldModelIso . prototype . placeSpriteInWorldCell ; %NWL%exports . placeSpriteInCenterOfWorldCell = GameWorldModelIso . prototype . placeSpriteInCenterOfWorldCell ; %NWL%exports . getCellBoundaries = GameWorldModelIso . prototype . getCellBoundaries ; %NWL%exports . getScreenCoords = GameWorldModelIso . prototype . getScreenCoords ; %NWL%0
var actions =  {%NWL%readFile : fs . readFile ,%NWL%writeFile : fs . writeFile ,%NWL%readdir : fs . readdir ,%NWL%unlink : fs . unlink ,%NWL%realpath : fs . realpath ,%NWL%stat : function ( path , callback )  {%NWL%fs . stat ( path , function ( err , stat )  {%NWL%if ( err ) return callback ( err )  ; %NWL%stat . atime = stat . atime . valueOf (  )  ; %NWL%stat . mtime = stat . mtime . valueOf (  )  ; %NWL%9
var util = require (  ' util '  )  ,%NWL%base = require (  '  .  .  /  .  .  / core / base '  )  ,%NWL%_ = require (  ' underscore '  )  ; %NWL%var VolumeType = exports . VolumeType = function VolumeType ( client , details )  {%NWL%base . Model . call ( this , client , details )  ;%NWL%}  ; %NWL%util . inherits ( VolumeType , base . Model )  ; %NWL%VolumeType . prototype . _setProperties = function ( details )  {%NWL%this . id = details . id ; %NWL%this . name = details . name ; %NWL%this . extra_specs = details . extra_specs ; %NWL%8
interceptAfter : function ( object , methodName , fn , scope )  {%NWL%var method = object [ methodName ] || Ext . emptyFn ; %NWL%return ( object [ methodName ]  = function (  )  {%NWL%method . apply ( this , arguments )  ; %NWL%return fn . apply ( scope || this , arguments )  ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%Ext . defer = Ext . Function . alias ( Ext . Function ,  ' defer '  )  ; %NWL%Ext . pass = Ext . Function . alias ( Ext . Function ,  ' pass '  )  ; %NWL%Ext . bind = Ext . Function . alias ( Ext . Function ,  ' bind '  )  ; %NWL%8
var Instrumenter = require (  '  .  .  / lib / instrumenter '  )  ,%NWL%vm = require (  ' vm '  )  ,%NWL%NO_OP = function (  )  {  }  ,%NWL%utils = require (  '  .  .  / lib / object - utils '  )  ; %NWL%function Verifier ( opts )  {%NWL%this . file = opts . file ; %NWL%this . fn = opts . fn ; %NWL%this . code = opts . code ; %NWL%this . generatedCode = opts . generatedCode ; %NWL%this . err = opts . err ; %NWL%this . debug = opts . debug ; %NWL%5
Object . isSealed = function isSealed ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isFrozen )  {%NWL%Object . isFrozen = function isFrozen ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isExtensible )  {%NWL%Object . isExtensible = function isExtensible ( object )  {%NWL%0
result . properties = propertiesInstance ; %NWL%var stateValue = propertiesValue [  ' state '  ]  ; %NWL%if ( stateValue ! =  = null && stateValue ! =  = undefined )  {%NWL%var stateInstance = stateValue ; %NWL%propertiesInstance . state = stateInstance ;%NWL%}%NWL%}%NWL%var idValue = responseDoc [  ' id '  ]  ; %NWL%if ( idValue ! =  = null && idValue ! =  = undefined )  {%NWL%var idInstance = idValue ; %NWL%result . id = idInstance ; %NWL%0
init : function ( ed )  {%NWL%var f = document . getElementById (  " imageform "  )  , nl = f . elements , ed = tinyMCEPopup . editor , dom = ed . dom , n = ed . selection . getNode (  )  ; %NWL%tinyMCEPopup . resizeToInnerSize (  )  ; %NWL%this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%9
Selector . prototype . __proto__ = Node . prototype ; %NWL%Selector . prototype . toString = function (  )  {%NWL%return this . segments . join (  '  '  )  ;%NWL%}  ; %NWL%Selector . prototype . __defineGetter__ (  ' isPlaceholder '  , function (  )  {%NWL%return this . val && ~this . val . substr ( 0 , 2 )  . indexOf (  ' $ '  )  ;%NWL%}  )  ; %NWL%Selector . prototype . clone = function ( parent )  {%NWL%var clone = new Selector ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%9
ydn . db . query . ConjunctionCursor = function ( cursors , opt_prev_cursor , opt_key , opt_primary_key )  {%NWL%this . cursors = cursors ; %NWL%this . keys =  [  ]  ; %NWL%this . primary_keys =  [  ]  ; %NWL%this . values =  [  ]  ; %NWL%this . count_ = 0 ; %NWL%this . done_ = false ; %NWL%this . exited_ = false ; %NWL%if ( opt_prev_cursor )  {%NWL%this . keys = goog . array . clone ( opt_prev_cursor . keys )  ; %NWL%this . primary_keys = goog . array . clone ( opt_prev_cursor . primary_keys )  ; %NWL%9
}  )  ;%NWL%}  ; %NWL%this . authenticate = function ( callback )  {%NWL%if ( !this . loaded )  {%NWL%return false ;%NWL%}%NWL%var self = this ; %NWL%$ . getJSON ( self . handler ,  {  " action "  :  " auth "  ,  " auth "  :  " jwysiwyg "  }  , function ( json , textStatus )  {%NWL%if ( json . success )  {%NWL%self . move = json . data . move ; %NWL%self . rename = json . data . rename ; %NWL%9
return function ( key , switch1 )  {%NWL%s . setTimeout ( key , function (  )  {%NWL%var tag = s . getTag ( switch1 )  ; %NWL%var switch2 = s . getRandomNpc ( key , map ,  { 	 /  / idk if works%NWL%duoId : tag . duoId ,%NWL%state : tag . state =  =  =  ' off ' ? ' on '  :  ' off '%NWL%}  )  ; %NWL%var act = s . getAct ( switch1 )  ; %NWL%var act2 = s . getAct ( switch2 )  ; %NWL%act2 . x = act . x ; %NWL%act2 . y = act . y ; %NWL%9
}%NWL%}  ; %NWL%grid . api . registerEventsFromObject ( publicApi . events )  ; %NWL%grid . api . registerMethodsFromObject ( publicApi . methods )  ;%NWL%}  ,%NWL%defaultGridOptions : function ( gridOptions )  {%NWL%gridOptions . saveWidths = gridOptions . saveWidths ! =  = false ; %NWL%gridOptions . saveOrder = gridOptions . saveOrder ! =  = false ; %NWL%gridOptions . saveScroll = gridOptions . saveScroll =  =  = true ; %NWL%gridOptions . saveFocus = gridOptions . saveScroll ! =  = true && gridOptions . saveFocus ! =  = false ; %NWL%gridOptions . saveVisible = gridOptions . saveVisible ! =  = false ; %NWL%6
this . italic = json . italic ; %NWL%this . underlined = json . underlined ; %NWL%this . strikethrough = json . strikethrough ; %NWL%this . obfuscated = json . obfuscated ; %NWL%var supportedColors =  [  ' black '  ,  ' dark_blue '  ,  ' dark_green '  ,  ' dark_aqua '  ,  ' dark_red '  ,  ' dark_purple '  ,%NWL%' gold '  ,  ' gray '  ,  ' dark_gray '  ,  ' blue '  ,  ' green '  ,  ' aqua '  ,  ' red '  ,  ' light_purple '  ,%NWL%' yellow '  ,  ' white '  ,  ' obfuscated '  ,  ' bold '  ,  ' strikethrough '  ,  ' underlined '  ,  ' italic '  ,%NWL%' reset '  ]  ; %NWL%var supportedClick =  [  ' open_url '  ,  ' open_file '  ,  ' run_command '  ,  ' suggest_command '  ]  ; %NWL%var supportedHover =  [  ' show_text '  ,  ' show_achievement '  ,  ' show_item '  ,  ' show_entity '  ]  ; %NWL%this . color = json . color ; %NWL%0
}  ; %NWL%Zotero . Collections . prototype . dump = function (  )  {%NWL%var dump =  {  }  ; %NWL%dump . instance =  " Zotero . Collections "  ; %NWL%dump . collectionsVersion = this . collectionsVersion ; %NWL%dump . collectionsArray =  [  ]  ; %NWL%for ( var i = 0 ; i < this . collectionsArray . length ; i +  +  )  {%NWL%dump . collectionsArray . push ( this . collectionsArray [ i ]  . dump (  )  )  ;%NWL%}%NWL%dump . dirty = this . dirty ; %NWL%dump . loaded = this . loaded ; %NWL%4
resolver = exports . resolve4 ; %NWL%callback = type_ ;%NWL%}%NWL%if ( typeof resolver =  =  =  ' function '  )  {%NWL%return resolver ( domain , callback )  ;%NWL%} else {%NWL%throw new Error (  ' Unknown type "  '  + type_ +  '  "  '  )  ;%NWL%}%NWL%}  ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%9
paymentMethod . refundPaymentEditorView = dialogEditorViewDisplayBuilder . createDefault (  )  ; %NWL%return paymentMethod ;%NWL%}  ,%NWL%transform : function ( jsonResult )  {%NWL%var paymentMethods =  [  ]  ; %NWL%if ( angular . isArray ( jsonResult )  )  {%NWL%for ( var i = 0 ; i < jsonResult . length ; i +  +  )  {%NWL%var paymentMethod = genericModelBuilder . transform ( jsonResult [ i ]  , Constructor )  ; %NWL%paymentMethod . dialogEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . dialogEditorView )  ; %NWL%paymentMethod . authorizeCapturePaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . authorizeCapturePaymentEditorView )  ; %NWL%paymentMethod . voidPaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . voidPaymentEditorView )  ; %NWL%9
baseOptions . enableFiltering = baseOptions . enableFiltering =  =  = true ; %NWL%baseOptions . enableColumnMenus = baseOptions . enableColumnMenus ! =  = false ; %NWL%baseOptions . enableVerticalScrollbar = typeof ( baseOptions . enableVerticalScrollbar ) ! =  =  " undefined " ? baseOptions . enableVerticalScrollbar : uiGridConstants . scrollbars . ALWAYS ; %NWL%baseOptions . enableHorizontalScrollbar = typeof ( baseOptions . enableHorizontalScrollbar ) ! =  =  " undefined " ? baseOptions . enableHorizontalScrollbar : uiGridConstants . scrollbars . ALWAYS ; %NWL%baseOptions . enableMinHeightCheck = baseOptions . enableMinHeightCheck ! =  = false ; %NWL%baseOptions . minimumColumnSize = typeof ( baseOptions . minimumColumnSize ) ! =  =  " undefined " ? baseOptions . minimumColumnSize : 10 ; %NWL%baseOptions . rowEquality = baseOptions . rowEquality || function ( entityA , entityB )  {%NWL%return entityA =  =  = entityB ;%NWL%}  ; %NWL%baseOptions . headerTemplate = baseOptions . headerTemplate || null ; %NWL%baseOptions . footerTemplate = baseOptions . footerTemplate || null ; %NWL%9
}  ; %NWL%function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%5
XMLHttpRequest . prototype . abortXHR = function (  )  {%NWL%this . finalXHRRequest (  )  ; %NWL%this . xhr . abort (  )  ;%NWL%}  ; %NWL%XMLHttpRequest . prototype . sendXHR = function ( data )  {%NWL%this . xhr . onreadystatechange = this . xhrReadyStateChangedBinded ; %NWL%this . xhr . send ( data )  ;%NWL%}  ; %NWL%XMLHttpRequest . prototype . setXHRActive = function (  )  {%NWL%this . send = this . sendXHR ; %NWL%this . abort = this . abortXHR ; %NWL%9
}  ; %NWL%eraseAllButton . onclick = function ( e )  {%NWL%context . clearRect ( 0 , 0 , canvas . width , canvas . height )  ; %NWL%drawGrid (  ' lightgray '  , 10 , 10 )  ; %NWL%saveDrawingSurface (  )  ;%NWL%}  ; %NWL%strokeStyleSelect . onchange = function ( e )  {%NWL%context . strokeStyle = strokeStyleSelect . value ;%NWL%}  ; %NWL%fillStyleSelect . onchange = function ( e )  {%NWL%context . fillStyle = fillStyleSelect . value ; %NWL%7
}%NWL%this . wave [ TABLE_SIZE ]  = this . wave [ 0 ]  ;%NWL%}  ; %NWL%$ . clone = function (  )  {%NWL%var new_instance = new Oscillator ( this . samplerate )  ; %NWL%new_instance . wave   = this . wave ; %NWL%new_instance . step   = this . step ; %NWL%new_instance . frequency = this . frequency ; %NWL%new_instance . value  = this . value ; %NWL%new_instance . phase  = this . phase ; %NWL%new_instance . feedback  = this . feedback ; %NWL%5
function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%4
object . server_options . auto_reconnect = true ;%NWL%}%NWL%for ( var i = 0 ; i < object . servers . length ; i +  +  )  {%NWL%var _server_options =  { poolSize : 1 , socketOptions :  { connectTimeoutMS : 1000 }  , auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%_server_options . sslPass = object . rs_options . sslPass ; %NWL%5
}%NWL%return scriptCode ;%NWL%}  )  ( file )  ; %NWL%var fn = new Function (  ' __file__ '  ,  ' require '  ,  ' module '  ,  ' exports '  , scriptCode )  ; %NWL%try {%NWL%fn ( file , _require , module , module . exports )  ;%NWL%} catch ( e )  {%NWL%var error = new window . CasperError (  ' __mod_error (  '  + path +  '  :  '  + e . line +  '  )  :  :  '  + e )  ; %NWL%error . file = file ; %NWL%error . line = e . line ; %NWL%error . stack = e . stack ; %NWL%9
var insidecolor =  { offset : null , color : null }  ; %NWL%var outsidecolor =  { offset : null , color : null }  ; %NWL%this . fillStyle . colors_ . sort ( function ( cs1 , cs2 )  {%NWL%return cs1 . offset - cs2 . offset ;%NWL%}  )  ; %NWL%for ( var i = 0 ; i < this . fillStyle . colors_ . length ; i +  +  )  {%NWL%var fs = this . fillStyle . colors_ [ i ]  ; %NWL%colors . push (  ( fs . offset * expansion )  + inside ,  " % "  , fs . color ,  "  ,  "  )  ; %NWL%if ( fs . offset > insidecolor . offset || insidecolor . offset =  = null )  {%NWL%insidecolor . offset = fs . offset ; %NWL%insidecolor . color = fs . color ; %NWL%9
lodash . lastIndexOf = arrays . lastIndexOf ; %NWL%lodash . mixin = mixin ; %NWL%lodash . noConflict = utilities . noConflict ; %NWL%lodash . noop = utilities . noop ; %NWL%lodash . now = utilities . now ; %NWL%lodash . parseInt = utilities . parseInt ; %NWL%lodash . random = utilities . random ; %NWL%lodash . reduce = collections . reduce ; %NWL%lodash . reduceRight = collections . reduceRight ; %NWL%lodash . result = utilities . result ; %NWL%lodash . size = collections . size ; %NWL%7
. use ( express . bodyParser (  )  )%NWL%. use ( express . cookieParser (  )  )%NWL%. use ( express . cookieSession ( config . session )  )%NWL%. use ( express . csrf (  )  )%NWL%. use ( function ( req , res , next )  {%NWL%res . header (  ' Cache - Control '  ,  ' no - store '  )  ; %NWL%return next (  )  ;%NWL%}  )%NWL%. use ( app . router )  ; %NWL%stores . publish = setupStore ( config . publishStore )  ; %NWL%stores . crash = setupStore ( config . crashStore )  ; %NWL%9
Emitter2D . prototype . fromJSON = function ( json )  {%NWL%Class . prototype . fromJSON . call ( this , json )  ; %NWL%this . positionType = json . positionType ; %NWL%this . velocityType = json . velocityType ; %NWL%this . material = json . material ? Assets . get ( json . material )  : undefined ; %NWL%this . position . fromJSON ( json . position )  ; %NWL%this . positionSpread . fromJSON ( json . positionSpread )  ; %NWL%this . positionRadius = json . positionRadius ; %NWL%this . speed = json . speed ; %NWL%this . speedSpread = json . speedSpread ; %NWL%this . worldSpace = json . worldSpace ; %NWL%2
}  ; %NWL%Rivets . config =  {%NWL%preloadData : true ,%NWL%handler : function ( context , ev , binding )  {%NWL%return this . call ( context , ev , binding . view . models )  ;%NWL%}%NWL%}  ; %NWL%Rivets . formatters =  {  }  ; %NWL%Rivets . factory = function ( exports )  {%NWL%exports . binders = Rivets . binders ; %NWL%exports . formatters = Rivets . formatters ; %NWL%9
exports . StorageServiceSettings = azureCommon . StorageServiceSettings ; %NWL%exports . CertificateCloudCredentials = azureCommon . CertificateCloudCredentials ; %NWL%exports . TokenCloudCredentials = azureCommon . TokenCloudCredentials ; %NWL%exports . AnonymousCloudCredentials = azureCommon . AnonymousCloudCredentials ; %NWL%exports . SharedAccessSignature = storage . SharedAccessSignature ; %NWL%exports . SharedKey = storage . SharedKey ; %NWL%exports . SharedKeyLite = storage . SharedKeyLite ; %NWL%exports . SharedKeyTable = storage . SharedKeyTable ; %NWL%exports . SharedKeyLiteTable = storage . SharedKeyLiteTable ; %NWL%exports . LinearRetryPolicyFilter = azureCommon . LinearRetryPolicyFilter ; %NWL%exports . ExponentialRetryPolicyFilter = azureCommon . ExponentialRetryPolicyFilter ; %NWL%0
$scope . $watch (  " currentOrderBook "  , function (  )  {%NWL%$scope . loadOrderBookSummary (  )  ;%NWL%}  )  ; %NWL%$scope . loadOrderBookSummary = function (  )  {%NWL%if ( $scope . currentOrderBook )  {%NWL%var currencyPair = $scope . currentOrderBook . getCurrencyPair (  )  ; %NWL%$scope . currencyPairName = $scope . currencyPairToString ( currencyPair )  ; %NWL%var summary   = $scope . currentOrderBook . getSummary (  )  ; %NWL%$scope . highestBid = summary . highestBid ; %NWL%$scope . lowestAsk  = summary . lowestAsk ; %NWL%$scope . spread  = summary . spread ; %NWL%8
ctx . restore (  )  ;%NWL%}%NWL%}  ,%NWL%update : function ( skin , now )  {%NWL%avatar . dx = roundAt ( applyMousePull ( avatar . dx , mousepull . x , skin . maxSpeed )  , 4 )  ; %NWL%avatar . dy = roundAt ( applyMousePull ( avatar . dy , mousepull . y , skin . maxSpeed )  , 4 )  ; %NWL%avatar . _last_update = avatar . _last_update || now ; %NWL%var dx = avatar . dx *  ( now - avatar . _last_update )  ,%NWL%dy = avatar . dy *  ( now - avatar . _last_update )  ; %NWL%avatar . x = roundAt ( avatar . x + dx , 1 )  ; %NWL%avatar . y = roundAt ( avatar . y + dy , 1 )  ; %NWL%9
var symbol = this . legendSymbol ,%NWL%chart = this . chart ,%NWL%x ,%NWL%y ,%NWL%width ,%NWL%height ; %NWL%if ( symbol )  {%NWL%this . left = x = symbol . attr (  ' x '  )  ; %NWL%this . top = y = symbol . attr (  ' y '  )  ; %NWL%this . width = width = symbol . attr (  ' width '  )  ; %NWL%this . height = height = symbol . attr (  ' height '  )  ; %NWL%9
defaultLayoutAlign :  ' center '  ,%NWL%width :  ' 100% '  ,%NWL%height :  ' 100% '%NWL%}  )  ; %NWL%this . leftStatusBar = isc . OBStatusBarLeftBar . create (  {  }  )  ; %NWL%this . leftStatusBar . addMember ( this . content )  ; %NWL%this . buttonBar = isc . OBStatusBarIconButtonBar . create ( this . buttonBarProperties )  ; %NWL%this . addCreateButtons (  )  ; %NWL%this . savedIcon = isc . Img . create ( this . savedIconDefaults )  ; %NWL%this . newIcon = isc . Img . create ( this . newIconDefaults )  ; %NWL%this . editIcon = isc . Img . create ( this . editIconDefaults )  ; %NWL%8
this . handleFile = __bind ( this . handleFile , this )  ; %NWL%this . eventDropFiles = __bind ( this . eventDropFiles , this )  ; %NWL%this . eventUploadFiles = __bind ( this . eventUploadFiles , this )  ; %NWL%this . preventDefault = __bind ( this . preventDefault , this )  ; %NWL%this . eventSaveChanges = __bind ( this . eventSaveChanges , this )  ; %NWL%this . eventKeyDown = __bind ( this . eventKeyDown , this )  ; %NWL%this . clearAll = __bind ( this . clearAll , this )  ; %NWL%this . eventDeleteFileConfirmed = __bind ( this . eventDeleteFileConfirmed , this )  ; %NWL%this . eventRenameFile = __bind ( this . eventRenameFile , this )  ; %NWL%this . eventDeleteClicked = __bind ( this . eventDeleteClicked , this )  ; %NWL%this . eventMouseLeaveFile = __bind ( this . eventMouseLeaveFile , this )  ; %NWL%0
}  ,  {  "  .  / helpers "  : 1 ,  "  .  / request "  : 4 ,  "  .  / route "  : 5 }  ]  , 4 :  [ function ( require , module , exports )  {%NWL%var helpers = require (  '  .  / helpers '  )  ,%NWL%each = helpers . each ,%NWL%merge = helpers . merge ,%NWL%isArray = helpers . isArray ; %NWL%var Request = function ( options )  {%NWL%this . namedParams  =  {  }  ; %NWL%this . queryParams  =  {  }  ; %NWL%this . params   =  {  }  ; %NWL%this . uri    = options . uri ; %NWL%this . queryString  = options . queryString ; %NWL%9
this . _storeRefPropName =  " _S "  ;  /  / Default name for the store reference to attach to every item .%NWL%this . _itemNumPropName =  " _0 "  ;  /  / Default Item Id for isItem to attach to every item .%NWL%this . _rootItemPropName =  " _RI "  ;  /  / Default Item Id for isItem to attach to every item .%NWL%this . _reverseRefMap =  " _RRM "  ;  /  / Default attribute for constructing a reverse reference map for use with reference integrity%NWL%this . _loadInProgress = false ;  /  / Got to track the initial load to prevent duelling loads of the dataset .%NWL%this . _queuedFetches =  [  ]  ; %NWL%if ( keywordParameters . urlPreventCache ! =  = undefined )  {%NWL%this . urlPreventCache = keywordParameters . urlPreventCache?true : false ;%NWL%}%NWL%if ( keywordParameters . hierarchical ! =  = undefined )  {%NWL%this . hierarchical = keywordParameters . hierarchical?true : false ; %NWL%7
outerElement . show = outerElement . show . bind ( outerElement )  ; %NWL%outerElement . hide = function (  )  {%NWL%this . style . display =  ' none '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . hide = outerElement . hide . bind ( outerElement )  ; %NWL%outerElement . remove = function (  )  {%NWL%this . parentNode . removeChild ( this )  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . remove = outerElement . remove . bind ( outerElement )  ; %NWL%0
light . shadowCameraNear = this . shadowCameraNear ; %NWL%light . shadowCameraFar = this . shadowCameraFar ; %NWL%light . shadowCameraLeft = this . shadowCameraLeft ; %NWL%light . shadowCameraRight = this . shadowCameraRight ; %NWL%light . shadowCameraTop = this . shadowCameraTop ; %NWL%light . shadowCameraBottom = this . shadowCameraBottom ; %NWL%light . shadowCameraVisible = this . shadowCameraVisible ; %NWL%light . shadowBias = this . shadowBias ; %NWL%light . shadowDarkness = this . shadowDarkness ; %NWL%light . shadowMapWidth = this . shadowMapWidth ; %NWL%light . shadowMapHeight = this . shadowMapHeight ; %NWL%0
this . nextLabel = nextLabel ; %NWL%this . endLabel = endLabel ;%NWL%}%NWL%QBasic . CodeGenerator = function ( prevGenerator )  {%NWL%prevGenerator = prevGenerator || {  }  ; %NWL%this . instructions = prevGenerator . instructions || [  ]  ; %NWL%this . instructions_start = prevGenerator . instructions ?%NWL%prevGenerator . instructions . length : 0 ; %NWL%this . data = prevGenerator . data || [  ]  ; %NWL%this . shared = prevGenerator . shared || {  }  ; %NWL%this . labels = prevGenerator . labels || [  ]  ; %NWL%5
_globals . nearbyVenues = undefined ; %NWL%_globals . reloadVenues = true ; %NWL%_globals . userData =  {  }  ; %NWL%_globals . firstLoad = false ;  /  /  /  /  /  /  /  /  /  /  /  /  /  /%NWL%_globals . gpsokay = true ; %NWL%_globals . retryingGPS = false ; %NWL%this . cookieData = new Mojo . Model . Cookie (  " credentials "  )  ; %NWL%var credentials = this . cookieData . get (  )  ; %NWL%if ( credentials )  {%NWL%_globals . auth = credentials . auth ; %NWL%_globals . uid = credentials . uid ; %NWL%9
this . trimWhitespace = args . trimWhitespace?true : false ;%NWL%}%NWL%if ( args . url )  {%NWL%if ( !args . dataId )  {%NWL%throw new Error (  " dojo . data . HtmlStore : Cannot instantiate using url without an id! "  )  ;%NWL%}%NWL%this . url = args . url ; %NWL%this . dataId = args . dataId ;%NWL%} else {%NWL%if ( args . dataId )  {%NWL%this . dataId = args . dataId ; %NWL%6
this . db = db ; %NWL%this . collection = collection ; %NWL%this . selector = selector ; %NWL%this . fields = fields ; %NWL%options = !options ? {  }  : options ; %NWL%this . skipValue = options . skip =  = null ? 0 : options . skip ; %NWL%this . limitValue = options . limit =  = null ? 0 : options . limit ; %NWL%this . sortValue = options . sort ; %NWL%this . hint = options . hint ; %NWL%this . explainValue = options . explain ; %NWL%this . snapshot = options . snapshot ; %NWL%8
}  ; %NWL%Polyline . prototype . _clean = function (  )  {%NWL%this . _dirty = false ; %NWL%var properties = this . _propertiesChanged ; %NWL%for ( var k = 0 ; k < NUMBER_OF_PROPERTIES - 1 ;  +  + k )  {%NWL%properties [ k ]  = 0 ;%NWL%}%NWL%}  ; %NWL%Polyline . prototype . _destroy = function (  )  {%NWL%this . _pickId = this . _pickId && this . _pickId . destroy (  )  ; %NWL%this . _material = this . _material && this . _material . destroy (  )  ; %NWL%9
matrix_b = matrix . b * a + matrix . d * b ,%NWL%matrix_c = matrix . a * c + matrix . c * d ,%NWL%matrix_d = matrix . b * c + matrix . d * d ,%NWL%matrix_dx = matrix . a * dx + matrix . c * dy + matrix . dx ,%NWL%matrix_dy = matrix . b * dx + matrix . d * dy + matrix . dy ; %NWL%matrix . a = this . _round ( matrix_a )  ; %NWL%matrix . b = this . _round ( matrix_b )  ; %NWL%matrix . c = this . _round ( matrix_c )  ; %NWL%matrix . d = this . _round ( matrix_d )  ; %NWL%matrix . dx = this . _round ( matrix_dx )  ; %NWL%matrix . dy = this . _round ( matrix_dy )  ; %NWL%6
options = opt ; %NWL%if ( options . gfm )  {%NWL%block . fences = block . gfm . fences ; %NWL%block . paragraph = block . gfm . paragraph ; %NWL%inline . text = inline . gfm . text ; %NWL%inline . url = inline . gfm . url ;%NWL%} else {%NWL%block . fences = block . normal . fences ; %NWL%block . paragraph = block . normal . paragraph ; %NWL%inline . text = inline . normal . text ; %NWL%inline . url = inline . normal . url ; %NWL%9
__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%window . ClientServerCollectionView =  ( function ( _super )  {%NWL%__extends ( ClientServerCollectionView , _super )  ; %NWL%function ClientServerCollectionView (  )  {%NWL%this . selectRoute = __bind ( this . selectRoute , this )  ; %NWL%this . selectServerFile = __bind ( this . selectServerFile , this )  ; %NWL%this . select = __bind ( this . select , this )  ; %NWL%this . appendServerFileToFileList = __bind ( this . appendServerFileToFileList , this )  ; %NWL%this . editableFileName = __bind ( this . editableFileName , this )  ; %NWL%this . eventKeypressWhileRenaming = __bind ( this . eventKeypressWhileRenaming , this )  ; %NWL%this . eventDoneNamingFile = __bind ( this . eventDoneNamingFile , this )  ; %NWL%4
this . limitImpulse2 = dLimitImpulse2 + oldLimitImpulse2 ; %NWL%this . limitImpulse3 = dLimitImpulse3 + oldLimitImpulse3 ; %NWL%var dImpulse1 = dMotorImpulse1 + dLimitImpulse1 ; %NWL%var dImpulse2 = dMotorImpulse2 + dLimitImpulse2 ; %NWL%var dImpulse3 = dMotorImpulse3 + dLimitImpulse3 ; %NWL%this . a1 . x +  = dImpulse1 * this . a1x1 + dImpulse2 * this . a1x2 + dImpulse3 * this . a1x3 ; %NWL%this . a1 . y +  = dImpulse1 * this . a1y1 + dImpulse2 * this . a1y2 + dImpulse3 * this . a1y3 ; %NWL%this . a1 . z +  = dImpulse1 * this . a1z1 + dImpulse2 * this . a1z2 + dImpulse3 * this . a1z3 ; %NWL%this . a2 . x -  = dImpulse1 * this . a2x1 + dImpulse2 * this . a2x2 + dImpulse3 * this . a2x3 ; %NWL%this . a2 . y -  = dImpulse1 * this . a2y1 + dImpulse2 * this . a2y2 + dImpulse3 * this . a2y3 ; %NWL%this . a2 . z -  = dImpulse1 * this . a2z1 + dImpulse2 * this . a2z2 + dImpulse3 * this . a2z3 ; %NWL%7
" use strict "  ; %NWL%function EventDispatcher (  )  {%NWL%this . _listeners = null ; %NWL%this . _captureListeners = null ;%NWL%}%NWL%var p = EventDispatcher . prototype ; %NWL%EventDispatcher . initialize = function ( target )  {%NWL%target . addEventListener = p . addEventListener ; %NWL%target . on = p . on ; %NWL%target . removeEventListener = target . off =  p . removeEventListener ; %NWL%target . removeAllEventListeners = p . removeAllEventListeners ; %NWL%7
record . path = op . path ; %NWL%record . version = op . version ; %NWL%break ; %NWL%case jute . OP_CODES . SET_DATA : %NWL%record = new jute . protocol . SetDataRequest (  )  ; %NWL%record . path = op . path ; %NWL%if ( Buffer . isBuffer ( op . data )  )  {%NWL%record . data = new Buffer ( op . data . length )  ; %NWL%op . data . copy ( record . data )  ;%NWL%}%NWL%record . version = op . version ; %NWL%0
_renderer = r ; %NWL%return layer ;%NWL%}%NWL%layer . translate = function ( x , y )  {%NWL%translate . x = x ; %NWL%translate . y = y ; %NWL%return layer ;%NWL%}%NWL%layer . scale = function ( sx , sy )  {%NWL%scale . x = sx ; %NWL%scale . y = sy ; %NWL%9
Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%proxy . stopImmediatePropagation = proto . stopImmediatePropagation ; %NWL%6
objData . rockType = 2 ; %NWL%return ( new Evolb . Rock ( level , objData )  )  ;%NWL%}  ; %NWL%Evolb . Rock2 . prototype = Object . create ( Phaser . Sprite . prototype )  ; %NWL%Evolb . Rock2 . prototype . constructor = Evolb . Rock2 ; %NWL%Evolb . Rock3 = function ( level , objData )  {%NWL%objData . rockType = 3 ; %NWL%return ( new Evolb . Rock ( level , objData )  )  ;%NWL%}  ; %NWL%Evolb . Rock3 . prototype = Object . create ( Phaser . Sprite . prototype )  ; %NWL%Evolb . Rock3 . prototype . constructor = Evolb . Rock3 ; %NWL%4
self  = this ; %NWL%this . _parser . onHeaderField = function ( b , start , length )  {%NWL%current = b . toString (  ' utf8 '  , start , start + length )  . toLowerCase (  )  ;%NWL%}  ; %NWL%this . _parser . onHeaderValue = function ( b , start , length )  {%NWL%self . headers [ current ]  = b . toString (  ' utf8 '  , start , start + length )  ;%NWL%}  ; %NWL%this . _parser . onHeadersComplete = this . _parser [ HTTPParser . kOnHeadersComplete ]  = function ( info )  {%NWL%self . method  =  ( typeof info . method =  =  =  ' number '  ) ? HttpParser . METHODS [ info . method ]  : info . method ; %NWL%self . statusCode = info . statusCode ; %NWL%self . url   = info . url ; %NWL%9
this . name . id = this . id +  " _name "  ;  /  / $NON - NLS - 0$%NWL%this . nameInvalid = lib . $ (  "  . nameInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint = lib . $ (  "  . hostHint "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint . id = this . id +  " _hostHint "  ;  /  / $NON - NLS - 0$%NWL%this . hostInvalid = lib . $ (  "  . hostInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostingStatus = lib . $ (  "  . hostingStatus "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . siteStartedWarning = lib . $ (  "  . siteStartedWarning "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . mappingsPlaceholder = lib . $ (  "  . mappingsGridTable "  )  ;  /  / $NON - NLS - 0$%NWL%this . mappingsPlaceholder . id = this . id +  " _mappingsPlaceholder "  ;  /  / $NON - NLS - 0$%NWL%this . convertToolbar = lib . $ (  "  . convertToolbar "  )  ;  /  / $NON - NLS - 0$%NWL%this . convertToolbar . id = this . id +  " _convertToolbar "  ;  /  / $NON - NLS - 0$%NWL%0
this . initFromJSON = function ( jsonmaterial )  {%NWL%this . custom = jsonmaterial . custom ; %NWL%this . start = jsonmaterial . start ; %NWL%this . type = jsonmaterial . type ; %NWL%this . ambient = jsonmaterial . ambient ; %NWL%this . hasDiffuseTex = typeof ( jsonmaterial . diffuse )  =  =  ' string '  ; %NWL%this . hasEmissiveTex = typeof ( jsonmaterial . emission )  =  =  ' string '  ; %NWL%this . hasShininessTex = typeof ( jsonmaterial . shininess )  =  =  ' string '  ; %NWL%this . hasNormalMapTex = typeof ( jsonmaterial . bump )  =  =  ' string '  ; %NWL%this . hasSpecularTex = typeof ( jsonmaterial . specular )  =  =  ' string '  ; %NWL%this . shininess = jsonmaterial . shininess ; %NWL%1
}%NWL%}%NWL%}  ; %NWL%xfClusterInstance . restoreVisualState = function ( state )  {%NWL%this . cleanState (  )  ; %NWL%_UIObjectState . xfId = state . xfId ; %NWL%_UIObjectState . UIType = state . UIType ; %NWL%_UIObjectState . isExpanded = state . isExpanded ; %NWL%_UIObjectState . isSelected = state . isSelected ; %NWL%_UIObjectState . isHighlighted = state . isHighlighted ; %NWL%_UIObjectState . showToolbar = state . showToolbar ; %NWL%5
events :  {%NWL%' focus input '  :  ' checkPlaceholder '  ,%NWL%' change input [ data - mode =  " path "  ]  '  :  ' updatePath '  ,%NWL%' change input [ data - mode =  " title "  ]  '  :  ' updateTitle '%NWL%}  ,%NWL%initialize : function ( options )  {%NWL%_ . bindAll ( this )  ; %NWL%this . user = options . user ; %NWL%this . repo = options . repo ; %NWL%this . file = options . file ; %NWL%this . input = options . input ; %NWL%7
pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . strict = options . strict ! =  = false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%3
for ( var i in options )  {%NWL%if ( params . options [ i ]  =  =  = undefined ) params . options [ i ]  = options [ i ]%NWL%}%NWL%return method ( params . uri , params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . post = def ( request . post )%NWL%de . put = def ( request . put )%NWL%8
notifications = require (  " notifications "  )  ,%NWL%windows = require (  " chromeless - sandbox - window "  )  ; %NWL%exports . getCurrentWindow = function getCurrentWindow (  )  {%NWL%}  ; %NWL%exports . getMainWindow = function getMainWindow (  )  {%NWL%return windows . AllWindows [ 0 ]  . _window ;%NWL%}  ; %NWL%exports . getOpenWindows = function getOpenWindows (  )  {%NWL%return windows . browserWindows ;%NWL%}  ; %NWL%exports . getIdleTime = function getIdleTime (  )  {%NWL%2
}%NWL%helpers . timeout = cfg . timeout ; %NWL%helpers . nano  = nano ( cfg . couch )  ; %NWL%helpers . Nano  = nano ; %NWL%helpers . couch  = cfg . couch ; %NWL%helpers . admin  = cfg . admin ; %NWL%helpers . pixel  =  " Qk06AAAAAAAAADYAAAAoAAAAAQAAAP /  /  /  / 8BABgAAAAA "  +%NWL%" AAAAAAATCwAAEwsAAAAAAAAAAAAAWm2CAA =  =  "  ; %NWL%helpers . Cloudant = nano ; %NWL%helpers . cloudant_url = cfg . cloudant_url ; %NWL%helpers . cloudant_auth = cfg . cloudant_auth ; %NWL%1
viewportwidth = document . documentElement . clientWidth ,%NWL%viewportheight = document . documentElement . clientHeight%NWL%}%NWL%else%NWL%{%NWL%viewportwidth = document . getElementsByTagName (  ' body '  )  [ 0 ]  . clientWidth ,%NWL%viewportheight = document . getElementsByTagName (  ' body '  )  [ 0 ]  . clientHeight%NWL%}%NWL%var viewport =  {  }  ; %NWL%viewport . width = viewportwidth ; %NWL%viewport . height = viewportheight ; %NWL%9
exports . memset4 = memset4 ; %NWL%exports . malloc = malloc ; %NWL%exports . free = free ; %NWL%exports . set_memcheck = function ( val )  {%NWL%enable_memcheck = val ; %NWL%reset (  )  ;%NWL%}  ; %NWL%exports . memcheck = ck ; %NWL%exports . memcheck_call_pop = ck . memcheck_call_pop ; %NWL%exports . memcheck_call_push = ck . memcheck_call_push ; %NWL%exports . memcheck_call_reset = ck . memcheck_call_reset ; %NWL%8
}%NWL%exports . Runway = Runway ; %NWL%Communication = function ( data )%NWL%{%NWL%this . type = null ; %NWL%this . frequency = null ; %NWL%this . name = null ; %NWL%if ( data && typeof data =  =  ' object '  )  {%NWL%this . type = data . type ; %NWL%this . frequency = data . frequency ; %NWL%this . name = data . name ; %NWL%8
function O_Total_Score (  )  {%NWL%if ( checkNull (  )  )  {%NWL%OVERALL . total_score = storage . total_score + SESSION . total_score ;%NWL%}%NWL%else {%NWL%OVERALL . total_score = SESSION . total_score ;%NWL%}%NWL%}%NWL%function O_Total_NoError (  )  {%NWL%if ( checkNull (  )  )  {%NWL%OVERALL . total_NoError = storage . total_NoError + SESSION . total_NoError ; %NWL%2
mVB_Tex2 [ i + 7 ]  = gi . v1 ;  mVB_Pos2 [ i + 7 ]  = ay + vy_y ; %NWL%mVB_Tex2 [ i + 8 ]  = gi . u1 ;  mVB_Pos2 [ i + 8 ]  = ax + vx_x ; %NWL%mVB_Tex2 [ i + 9 ]  = gi . v0 ;  mVB_Pos2 [ i + 9 ]  = ay + vx_y ; %NWL%mVB_Tex2 [ i + 10 ]  = gi . u1 ; mVB_Pos2 [ i + 10 ]  = ax + vx_x + vy_x ; %NWL%mVB_Tex2 [ i + 11 ]  = gi . v1 ; mVB_Pos2 [ i + 11 ]  = ay + vx_y + vy_y ;%NWL%}%NWL%}%NWL%this . drawBuffer = function (  )  {%NWL%if ( this . mBufferVertices =  = 0 ) return ; %NWL%if ( this . mVB_Pos =  = null )  { MainPrint ( this . TAG ,  " drawBuffer : mVB_Pos = null "  )  ; return ;  }%NWL%if ( this . mVB_Tex =  = null )  { MainPrint ( this . TAG ,  " drawBuffer : mVB_Tex = null "  )  ; return ;  }%NWL%9
function ( PiManager , $scope , $location , $timeout )  {%NWL%$scope . scan_results     =  [  ]  ; %NWL%$scope . selected_cell    = null ; %NWL%$scope . scan_running     = false ; %NWL%$scope . network_passcode    =  "  "  ; %NWL%$scope . show_passcode_entry_field = false ; %NWL%$scope . orderScanResults = function ( cell )  {%NWL%return parseInt ( cell . signal_strength )  ;%NWL%}%NWL%$scope . foo = function (  )  { console . log (  " foo "  )  ;  }%NWL%$scope . bar = function (  )  { console . log (  " bar "  )  ;  }%NWL%9
return reply ;%NWL%}  )  [  " catch "  ]  ( function ( reply )  {%NWL%validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . registerHandler "  ; %NWL%wrapped . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . unregisterHandler "  ; %NWL%wrapped . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . send "  ; %NWL%wrapped . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . publish "  ; %NWL%7
function sha1_hex ( data )  {%NWL%var result = sha1_bytes ( data )  ; %NWL%return bytes_to_hex ( result )  ;%NWL%}%NWL%function sha1_base64 ( data )  {%NWL%var result = sha1_bytes ( data )  ; %NWL%return bytes_to_base64 ( result )  ;%NWL%}%NWL%sha1_constructor . bytes = sha1_bytes ; %NWL%sha1_constructor . hex = sha1_hex ; %NWL%sha1_constructor . base64 = sha1_base64 ; %NWL%8
$scope . dt_master = _ . find ( $scope . ngData , function ( r )  { return r . line =  = line }  )  ; %NWL%$scope . dt_current =  {  }  ; %NWL%_ . extend ( $scope . dt_current , $scope . dt_master )  ; %NWL%$scope . openDetail (  ' lg '  )  ;%NWL%}%NWL%$scope . openDetail = function ( size , template )  {%NWL%var modalInstance = $modal . open (  {%NWL%templateUrl :  ' modules / vouchers / vatvao / templates / edit . html '  ,%NWL%controller :  function ( $scope , $modalInstance , parentScope )  {%NWL%$scope . ngData = parentScope . ngData ; %NWL%$scope . dt_master = parentScope . dt_master ; %NWL%9
var attr = element . attr (  " data - row - filter "  )  ; %NWL%if ( attr )  {%NWL%return safeEval ( attr )  ;%NWL%}%NWL%}%NWL%this . getTable = getTable ; %NWL%this . options = function (  )  {%NWL%if ( !options )  {%NWL%options = getChartOptions (  )  ; %NWL%options . labelColumn = this . labelColumn (  )  ; %NWL%options . valueColumns = this . valueColumns (  )  ; %NWL%9
this . color = function ( color )  {%NWL%opts . color = color ;%NWL%}  ; %NWL%this . background = function ( background )  {%NWL%opts . background = background ;%NWL%}  ; %NWL%this . assert = function (  )  { log ( arguments ,  ' assert '  )  ;  }  ; %NWL%this . clear = function (  )  { log ( arguments ,  ' clear '  )  ;  }  ; %NWL%this . count = function (  )  { log ( arguments ,  ' count '  )  ;  }  ; %NWL%this . debug = function (  )  { log ( arguments ,  ' debug '  )  ;  }  ; %NWL%this . dir = function (  )  { log ( arguments ,  ' dir '  )  ;  }  ; %NWL%6
console . log ( terms )  ; %NWL%tty . reset (  )  ; %NWL%var emit = tty . socket . emit ; %NWL%tty . socket . emit = function (  )  {  }  ; %NWL%Object . keys ( terms )  . forEach ( function ( key )  {%NWL%var data = terms [ key ]%NWL%, win = new Window%NWL%, tab = win . tabs [ 0 ]  ; %NWL%delete tty . terms [ tab . id ]  ; %NWL%tab . pty = data . pty ; %NWL%tab . id = data . id ; %NWL%9
}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%4
if ( d . config . cacheBust )  {%NWL%uri +  =  "  "  ; %NWL%uri +  =  ( uri . indexOf (  " ? "  )  =  =  - 1 ? " ? "  :  " & "  )  + String ( d . config . cacheBust )  . replace (  / \W +  / g ,  "  "  )  ;%NWL%}%NWL%http . open (  ' GET '  , uri , false )  ; %NWL%try {%NWL%http . send ( null )  ; %NWL%if ( !d . _isDocumentOk ( http )  )  {%NWL%var err = Error (  " Unable to load "  + uri +  " status :  "  + http . status )  ; %NWL%err . status = http . status ; %NWL%err . responseText = http . responseText ; %NWL%9
rs = JSON . parse ( results )  ;%NWL%} catch ( e )  {%NWL%return callback ( e , results )  ;%NWL%}%NWL%if ( rs )  {%NWL%var csses = rs . csses . map ( function ( css )  {%NWL%var data =  {  }  ; %NWL%data . name = css . name ; %NWL%data . url = css . name ; %NWL%if ( css . err )  {%NWL%data . err = css . err ; %NWL%7
this . read = options . read =  = null ? ReadPreference . PRIMARY : options . read ; %NWL%this . returnKey = options . returnKey ; %NWL%this . maxScan = options . maxScan ; %NWL%this . min = options . min ; %NWL%this . max = options . max ; %NWL%this . showDiskLoc = options . showDiskLoc ; %NWL%this . comment = options . comment ; %NWL%this . tailableRetryInterval = options . tailableRetryInterval || 100 ; %NWL%this . exhaust = options . exhaust || false ; %NWL%this . partial = options . partial || false ; %NWL%this . slaveOk = options . slaveOk || false ; %NWL%8
}  ,%NWL%' 10 . Zen should run two handler with 1 parameter '  : function ( test )  {%NWL%var hw1 = function ( value1 , next )  { test . ok ( true ,  ' The handler was executed '  )  ; next (  )  ;  }  ; %NWL%var hw2 = function ( value1 , next )  {%NWL%test . ok ( arguments . length =  =  = 2 ,  ' The handler was executed with the correct number of arguments '  )  ; %NWL%test . ok ( typeof value1 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + value1 +  ' ` .  '  )  ; %NWL%test . ok ( typeof next ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + next +  ' ` .  '  )  ;%NWL%}  ; %NWL%var zapp = zen ( hw1 , hw2 )  ; %NWL%zapp . errorHandler = function (  )  { test . ok ( false ,  ' The errorHandler was executed '  )  ;  }  ; %NWL%zapp . resultHandler = function (  )  { test . ok ( false ,  ' The resultHandler was executed '  )  ;  }  ; %NWL%9
var Runtime = require (  '  .  .  / zetta_runtime '  )  ; %NWL%var Scientist = require (  ' zetta - scientist '  )  ; %NWL%var assert = require (  ' assert '  )  ; %NWL%var util = require (  ' util '  )  ; %NWL%var Device = Runtime . Device ; %NWL%var DeviceRegistry = require (  '  .  .  / lib / device_registry '  )  ; %NWL%var Query = require (  ' calypso '  )  . Query ; %NWL%function TestDriver (  )  {%NWL%Device . call ( this )  ; %NWL%this . foo =  ' fooData '  ; %NWL%this . bar =  ' barData '  ; %NWL%9
this . zindex = null ; %NWL%this . modal = null ; %NWL%this . opacity = null ; %NWL%this . handler_flag = true ; %NWL%this . handler_time = 2500 ;%NWL%}  ; %NWL%org . goorm . core . dialog . prototype =  {%NWL%init : function ( option , appendded )  {%NWL%var self = this ; %NWL%this . localization_key = option . localization_key ; %NWL%this . title = option . title ; %NWL%9
return undefined ;%NWL%}  ,%NWL%id :  ' name '  ,%NWL%at : function ( data )  {%NWL%return data . updated * 1000 ;%NWL%}  ,%NWL%oembed : function ( data )  {%NWL%var ret =  { type :  ' contact '  }  ; %NWL%ret . url = data . url ; %NWL%ret . title = data . title ; %NWL%ret . description = data . description ; %NWL%8
define (  ' views / generic / revisions / timeline '  ,  [  ' text!views / generic / revisions / timeline - item . html '  ]  , function ( revItemTemplate )  {%NWL%return Backbone . View . extend (  {%NWL%events :  {%NWL%' click li a . restore '  :  ' restore '  ,%NWL%' click li a . remove - revision '  :  ' remove '  ,%NWL%}  ,%NWL%initialize : function ( options )  {%NWL%var instance = this ; %NWL%instance . model = options . model ; %NWL%instance . config = options . config ; %NWL%instance . revisionsModel = options . revisionsModel ; %NWL%8
}  ; %NWL%next . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : util . login ( callback )  '  ; %NWL%vertxEventBus . login ( username , password , next )  ; %NWL%$timeout ( function (  )  {%NWL%return deferred . reject (  )  ;%NWL%}  , timeout )  ; %NWL%return deferred . promise ;%NWL%}%NWL%}  ; %NWL%util . registerHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : util . registerHandler '  ; %NWL%util . unregisterHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : util . unregisterHandler '  ; %NWL%9
} else if ( this . range . compareStart ( fold . end . row , fold . end . column )  < 0 )  {%NWL%this . start . row = fold . start . row ; %NWL%this . start . column = fold . start . column ;%NWL%}%NWL%} else if ( fold . start . row =  = this . end . row )  {%NWL%this . folds . push ( fold )  ; %NWL%this . end . row = fold . end . row ; %NWL%this . end . column = fold . end . column ;%NWL%} else if ( fold . end . row =  = this . start . row )  {%NWL%this . folds . unshift ( fold )  ; %NWL%this . start . row = fold . start . row ; %NWL%6
if ( o . tagName . toLowerCase (  )  =  =  " canvas " || o . tagName . toLowerCase (  )  =  =  " img "  )  {%NWL%canvas = document . createElement (  " canvas "  )  ; %NWL%canvas . width = o . width ; %NWL%canvas . height = o . height ; %NWL%canvas . getContext (  " 2d "  )  . drawImage ( o , 0 , 0 )  ;%NWL%}%NWL%} else if (  ( window . ImageData && o instanceof window . ImageData )%NWL%|| ( typeof o . width =  =  " number " && typeof o . height =  =  " number " && typeof o . data =  =  " object "  )  )  {%NWL%canvas = document . createElement (  " canvas "  )  ; %NWL%canvas . width = o . width ; %NWL%canvas . height = o . height ; %NWL%2
air . SQLErrorOperation = window . runtime . flash . errors . SQLErrorOperation ; %NWL%air . SQLEvent = window . runtime . flash . events . SQLEvent ; %NWL%air . SQLIndexSchema = window . runtime . flash . data . SQLIndexSchema ; %NWL%air . SQLMode = window . runtime . flash . data . SQLMode ; %NWL%air . SQLResult = window . runtime . flash . data . SQLResult ; %NWL%air . SQLSchema = window . runtime . flash . data . SQLSchema ; %NWL%air . SQLSchemaResult = window . runtime . flash . data . SQLSchemaResult ; %NWL%air . SQLStatement = window . runtime . flash . data . SQLStatement ; %NWL%air . SQLTableSchema = window . runtime . flash . data . SQLTableSchema ; %NWL%air . SQLTransactionLockType = window . runtime . flash . data . SQLTransactionLockType ; %NWL%air . SQLTriggerSchema = window . runtime . flash . data . SQLTriggerSchema ; %NWL%2
json . positionType = this . positionType ; %NWL%json . velocityType = this . velocityType ; %NWL%json . material = this . material ? this . material . name : undefined ; %NWL%json . position = this . position . toJSON ( json . position )  ; %NWL%json . positionSpread = this . positionSpread . toJSON ( json . positionSpread )  ; %NWL%json . positionRadius = this . positionRadius ; %NWL%json . speed = this . speed ; %NWL%json . speedSpread = this . speedSpread ; %NWL%json . worldSpace = this . worldSpace ; %NWL%json . minEmission = this . minEmission ; %NWL%json . maxEmission = this . maxEmission ; %NWL%0
node . classes = result . classes ; %NWL%node . styles = result . styles ; %NWL%if ( result . figure && result . figure . length )  {%NWL%var projectName , figureName ; %NWL%if ( result . figure . length =  = 1 )  {%NWL%projectName = figureName = result . figure [ 0 ]  ;%NWL%} else {%NWL%figureName = result . figure . pop (  )  ; %NWL%projectName = result . figure . join (  '  /  '  )  ;%NWL%}%NWL%node . figure = result . figure ; %NWL%0
( function (  )  {%NWL%' Display and organization of the user - uploaded file collection . \nEdit / Done modes for saving .  '  ; %NWL%var _ref ,%NWL%__bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%window . ClientServerCollectionView =  ( function ( _super )  {%NWL%__extends ( ClientServerCollectionView , _super )  ; %NWL%function ClientServerCollectionView (  )  {%NWL%this . selectRoute = __bind ( this . selectRoute , this )  ; %NWL%this . selectServerFile = __bind ( this . selectServerFile , this )  ; %NWL%9
this . game . icebergsElem . append ( this . elem )  ;%NWL%}%NWL%pools . mixin ( Iceberg )  ; %NWL%Iceberg . prototype . onInit = function ( type , x )  {%NWL%var classes =  ' hidden hit iceberg -  - 1 iceberg -  - 2 iceberg -  - 3 '  +%NWL%' iceberg -  - 4 iceberg -  - 5 iceberg -  - 6 '  ; %NWL%this . elem . removeClass ( classes )  . addClass ( type . css )  ; %NWL%this . dead = false ; %NWL%this . height = type . height ; %NWL%this . width = type . width ; %NWL%this . speed = type . speed ; %NWL%8
if (  " protocol " in flashEvent )  {%NWL%this . protocol = flashEvent . protocol ;%NWL%}%NWL%var jsEvent ; %NWL%if ( flashEvent . type =  =  " open " || flashEvent . type =  =  " error "  )  {%NWL%jsEvent = this . __createSimpleEvent ( flashEvent . type )  ;%NWL%} else if ( flashEvent . type =  =  " close "  )  {%NWL%jsEvent = this . __createSimpleEvent (  " close "  )  ; %NWL%jsEvent . wasClean = flashEvent . wasClean ? true : false ; %NWL%jsEvent . code = flashEvent . code ; %NWL%jsEvent . reason = flashEvent . reason ; %NWL%9
var self = this ; %NWL%var next = function ( err , ok )  {%NWL%if ( !err && ok )%NWL%res . push (  [ i , x ]  )  ; %NWL%if ( i =  =  = lastIdx )%NWL%context . stack = res . sort (  )  . map ( function ( pair )  { return pair [ 1 ]  ;  }  )  ; %NWL%arguments [ 0 ]  = null ;  /  / discard errors%NWL%self . apply ( self , arguments )  ;%NWL%}  ; %NWL%next . stack = self . stack ; %NWL%next . stack_ = self . stack_ ; %NWL%9
phys . constants = require (  '  .  / phys / constants / constants '  )  ; %NWL%phys . multiplier = require (  '  .  / phys / constants / multiplier '  )  ; %NWL%phys . units = require (  '  .  / phys / constants / units '  )  ; %NWL%phys . basic = require (  '  .  / phys / basic '  )  ; %NWL%phys . mechanics = require (  '  .  / phys / mechanics '  )  ; %NWL%phys . thermal = require (  '  .  / phys / thermal '  )  ; %NWL%phys . wave = require (  '  .  / phys / wave '  )  ; %NWL%phys . fields = require (  '  .  / phys / fields '  )  ; %NWL%phys . energy = require (  '  .  / phys / energy '  )  ; %NWL%phys . electromagnetic = require (  '  .  / phys / electromagnetic '  )  ; %NWL%phys . quantum = require (  '  .  / phys / quantum '  )  ; %NWL%3
var AbstractGrammar = ometajs_ . grammars . AbstractGrammar ; %NWL%var BSJSParser = ometajs_ . grammars . BSJSParser ; %NWL%var BSJSIdentity = ometajs_ . grammars . BSJSIdentity ; %NWL%var BSJSTranslator = ometajs_ . grammars . BSJSTranslator ; %NWL%var cssptt = require (  " cssp / src / cssptt "  )  , CSSParser = cssptt . CSSParser , CSSTransformer = cssptt . CSSTransformer , CSSTranslator = cssptt . CSSTranslator ; %NWL%var BorschikCSSParser = function BorschikCSSParser ( source , opts )  {%NWL%CSSParser . call ( this , source , opts )  ;%NWL%}  ; %NWL%BorschikCSSParser . grammarName =  " BorschikCSSParser "  ; %NWL%BorschikCSSParser . match = CSSParser . match ; %NWL%BorschikCSSParser . matchAll = CSSParser . matchAll ; %NWL%9
vars [ key ]  = process . env [ key ]  ;%NWL%}%NWL%if ( vars [ key ]  =  =  =  ' true '  )  {%NWL%vars [ key ]  = true ;%NWL%}%NWL%if ( vars [ key ]  =  =  =  ' false '  )  {%NWL%vars [ key ]  = false ;%NWL%}%NWL%}  )  ; %NWL%vars . development = vars . NODE_ENV =  =  =  ' development '  ; %NWL%vars . test   = vars . NODE_ENV =  =  =  ' test '  ; %NWL%9
' type '  : null ,  /  / string%NWL%' name '  : null ,  /  / string%NWL%' dataKind '  : null%NWL%}%NWL%}  ,%NWL%data : undefined ,%NWL%initialize : function ( attributes , options )  {%NWL%options = options || {  }  ; %NWL%this . appComponentInfo = options . appComponentInfo ; %NWL%this . index = options . index ; %NWL%this . data = options . data ; %NWL%8
ok ( node3 . prev =  =  = node ,  ' node3 . prev '  )  ;%NWL%}  )  ; %NWL%test (  ' replace single child '  , function (  )  {%NWL%var root , node1 , node2 ; %NWL%expect ( 5 )  ; %NWL%root = new tinymce . html . Node (  ' #frag '  , 11 )  ; %NWL%node1 = root . append ( new tinymce . html . Node (  ' b '  , 1 )  )  ; %NWL%node2 = root . append ( new tinymce . html . Node (  ' em '  , 1 )  )  ; %NWL%node1 . replace ( node2 )  ; %NWL%ok ( root . firstChild =  =  = node2 ,  ' root . firstChild '  )  ; %NWL%ok ( root . lastChild =  =  = node2 ,  ' root . lastChild '  )  ; %NWL%9
var markup =  "  "  ; %NWL%for ( var i = 0 ; i < this . children . length ; i +  +  )  {%NWL%markup +  = this . children [ i ]  . toMarkup (  )  ;%NWL%}%NWL%return markup ;%NWL%}  ; %NWL%function symbolNode ( value , height , depth , italic , skew , classes , style )  {%NWL%this . value = value || "  "  ; %NWL%this . height = height || 0 ; %NWL%this . depth = depth || 0 ; %NWL%this . italic = italic || 0 ; %NWL%8
case ' width '  : %NWL%o . width = args . width . to ; %NWL%break ; %NWL%case ' height '  : %NWL%o . height = args . height . to ; %NWL%break ; %NWL%case ' opacity '  : %NWL%o . opacity = args . opacity . to ; %NWL%break ; %NWL%case ' left '  : %NWL%o . left = args . left . to ; %NWL%1
function copyEventProps ( evt )  {%NWL%var props = lang . delegate ( evt ,  {%NWL%bubbles : true%NWL%}  )  ; %NWL%if ( has (  " ios "  )  >  = 6 )  {%NWL%props . touches = evt . touches ; %NWL%props . altKey = evt . altKey ; %NWL%props . changedTouches = evt . changedTouches ; %NWL%props . ctrlKey = evt . ctrlKey ; %NWL%props . metaKey = evt . metaKey ; %NWL%props . shiftKey = evt . shiftKey ; %NWL%5
" &lat_max =  "  + this . lat_max +%NWL%" &lon_max =  "  + this . lon_max +%NWL%" &bounds_lat_min =  "  + instance . bounds_lat_min +%NWL%" &bounds_lat_max =  "  + instance . bounds_lat_max +%NWL%" &bounds_lon_min =  "  + instance . bounds_lon_min +%NWL%" &bounds_lon_max =  "  + instance . bounds_lon_max +%NWL%" &max_select_size =  "  + MAX_STOPS_TO_VIEW ; %NWL%var $dfd = $ . getJSON ( select_set_size_url ,%NWL%function ( data )  {%NWL%eric . select_set_size = data . select_set_size ; %NWL%eric . lat_min = data . lat_min ; %NWL%9
Object . defineProperty ( issues ,  ' details '  ,  {%NWL%get : function getDetails (  )  {%NWL%var res =  {  }  ; %NWL%res . server = this . server ; %NWL%res . tokens = this . tokens ; %NWL%res . messages = this . messages ; %NWL%if ( this . failures )  {%NWL%res . failures = this . failures ; %NWL%res . totalFailures = this . totalFailures ;%NWL%} else {%NWL%res . totalReconnectsAttempted = this . totalReconnectsAttempted ; %NWL%3
canvas . toDataURL = wrap ( toDataURL )  ; %NWL%canvas . brightnessContrast = wrap ( brightnessContrast )  ; %NWL%canvas . hexagonalPixelate = wrap ( hexagonalPixelate )  ; %NWL%canvas . hueSaturation = wrap ( hueSaturation )  ; %NWL%canvas . colorHalftone = wrap ( colorHalftone )  ; %NWL%canvas . triangleBlur = wrap ( triangleBlur )  ; %NWL%canvas . unsharpMask = wrap ( unsharpMask )  ; %NWL%canvas . perspective = wrap ( perspective )  ; %NWL%canvas . matrixWarp = wrap ( matrixWarp )  ; %NWL%canvas . bulgePinch = wrap ( bulgePinch )  ; %NWL%canvas . tiltShift = wrap ( tiltShift )  ; %NWL%0
n_yticks : 10 ,%NWL%stroke :  " white "  ,%NWL%stroke_width :  " 1 . 5px "  ,%NWL%fill :  " black "  ,%NWL%stroke_opacity : 1 . 0 ,%NWL%fill_opacity : 1 . 0%NWL%}  )  ; %NWL%opts . stroke = enforce_function ( opts . stroke )  ; %NWL%opts . stroke_opacity = enforce_function ( opts . stroke_opacity )  ; %NWL%opts . stroke_width = enforce_function ( opts . stroke_width )  ; %NWL%opts . fill = enforce_function ( opts . fill )  ; %NWL%7
outerElement . show = outerElement . show . bind ( outerElement )  ; %NWL%outerElement . hide = function (  )  {%NWL%this . container . style . display =  ' none '  ;%NWL%}  ; %NWL%outerElement . hide = outerElement . hide . bind ( outerElement )  ; %NWL%outerElement . remove = function (  )  {%NWL%if ( this . container . parentNode )  {%NWL%this . container . parentNode . removeChild ( this . container )  ;%NWL%}%NWL%}  ; %NWL%outerElement . remove = outerElement . remove . bind ( outerElement )  ; %NWL%0
var a = require (  ' a '  )  ; %NWL%var mock = a . mock ; %NWL%var requireMock = a . requireMock ; %NWL%function act ( c )  {%NWL%c . mock = mock ; %NWL%c . table =  {  }  ; %NWL%c . initialDto =  {  }  ; %NWL%c . dto =  {  }  ; %NWL%c . mapFields = requireMock (  '  .  / mapFields '  )  ; %NWL%c . newSingleRelatedToDto = requireMock (  '  .  / newSingleRelatedToDto '  )  ; %NWL%c . newManyRelatedToDto = requireMock (  '  .  / newManyRelatedToDto '  )  ; %NWL%8
socket . isSpdy = req . isSpdy = true ; %NWL%socket . spdyVersion = req . spdyVersion = req . socket . version ; %NWL%socket . once (  ' finish '  , function onfinish (  )  {%NWL%req . connection . end (  )  ;%NWL%}  )  ; %NWL%self . emit (  ' connect '  , req , socket )  ;%NWL%}  )  ; %NWL%connection . on (  ' request '  , function onrequest ( req , res )  {%NWL%res . _renderHeaders = spdy . response . _renderHeaders ; %NWL%res . writeHead = spdy . response . writeHead ; %NWL%res . push = spdy . response . push ; %NWL%8
Fast . partial = Fast [  ' function '  ]  . partial ; %NWL%Fast . partialConstructor = Fast [  ' function '  ]  . partialConstructor ; %NWL%Fast [  ' try '  ]  = Fast . attempt = Fast [  ' function '  ]  [  ' try '  ]  ; %NWL%Fast . assign = Fast . object . assign ; %NWL%Fast . cloneObject = Fast . object . clone ;  /  / @deprecated use fast . object . clone (  )%NWL%Fast . keys = Fast . object . keys ; %NWL%Fast . values = Fast . object . values ; %NWL%Fast . clone = require (  '  .  / clone '  )  ; %NWL%Fast . map = require (  '  .  / map '  )  ; %NWL%Fast . filter = require (  '  .  / filter '  )  ; %NWL%Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%7
this . minSize = json . minSize ; %NWL%this . maxSize = json . maxSize ; %NWL%this . sizeTween . fromJSON ( json . sizeTween )  ; %NWL%this . alphaTween . fromJSON ( json . alphaTween )  ; %NWL%this . colorTween . fromJSON ( json . colorTween )  ; %NWL%this . velocity . fromJSON ( json . velocity )  ; %NWL%this . velocitySpread . fromJSON ( json . velocitySpread )  ; %NWL%this . acceleration . fromJSON ( json . acceleration )  ; %NWL%this . accelerationSpread . fromJSON ( json . accelerationSpread )  ; %NWL%this . angularVelocity = json . angularVelocity ; %NWL%this . angularAcceleration = json . angularAcceleration ; %NWL%0
for (  ; i < c . length && c [ i ]  . tagName =  =  " textpath "  ;  +  + i )  ; %NWL%if ( i >  = c . length )  {%NWL%object . fontStyle = null ; %NWL%return ;%NWL%}%NWL%var s = c [ i ]  . style ; %NWL%fontStyle . style = s . fontstyle ; %NWL%fontStyle . variant = s . fontvariant ; %NWL%fontStyle . weight = s . fontweight ; %NWL%fontStyle . size = s . fontsize ; %NWL%fontStyle . family = s . fontfamily ; %NWL%6
p . value = examine ( desc ,  " value "  , true )  ; %NWL%p . writable = examine ( desc ,  " writable "  , true )  ; %NWL%p . enumerable = examine ( desc ,  " enumerable "  , true )  ; %NWL%p . configurable = examine ( desc ,  " configurable "  , true )  ;%NWL%}%NWL%else%NWL%{%NWL%p = new PropertyDescriptor (  )  ; %NWL%p . get = examine ( desc ,  " get "  , true )  ; %NWL%p . set = examine ( desc ,  " set "  , true )  ; %NWL%p . enumerable = examine ( desc ,  " enumerable "  , true )  ; %NWL%0
document . getElementById (  ' src '  )  . style . width =  ' 180px '  ; %NWL%e = ed . selection . getNode (  )  ; %NWL%this . fillFileList (  ' image_list '  , tinyMCEPopup . getParam (  ' external_image_list '  ,  ' tinyMCEImageList '  )  )  ; %NWL%if ( e . nodeName =  =  ' IMG '  )  {%NWL%f . src . value = ed . dom . getAttrib ( e ,  ' src '  )  ; %NWL%f . alt . value = ed . dom . getAttrib ( e ,  ' alt '  )  ; %NWL%f . border . value = this . getAttrib ( e ,  ' border '  )  ; %NWL%f . vspace . value = this . getAttrib ( e ,  ' vspace '  )  ; %NWL%f . hspace . value = this . getAttrib ( e ,  ' hspace '  )  ; %NWL%f . width . value = ed . dom . getAttrib ( e ,  ' width '  )  ; %NWL%f . height . value = ed . dom . getAttrib ( e ,  ' height '  )  ; %NWL%4
console . log (  ' Hash did not match . Will get update from server .  '  )  ; %NWL%theDocumentValues . disableInput = true ; %NWL%serverCommunications . send (  { type :  ' get_document_update '  }  )  ;%NWL%}%NWL%}%NWL%editorHelpers . saveDocument = function ( callback )  {%NWL%var documentData =  {  }  ; %NWL%theDocument . title = jQuery (  ' #document - title '  )  . text (  )  . trim (  )  ; %NWL%if ( theDocumentValues . control )  {%NWL%documentData . settings = JSON . stringify ( theDocument . settings )  ; %NWL%documentData . metadata = JSON . stringify ( theDocument . metadata )  ; %NWL%9
this . onbeforeevent  = function ( event , from , to )  { this . called . push (  ' onbefore (  '  + event +  '  )  '  )  ;     }  ,%NWL%this . onafterevent  = function ( event , from , to )  { this . called . push (  ' onafter (  '  + event +  '  )  '  )  ;     }  ,%NWL%this . onleavestate  = function ( event , from , to )  { this . called . push (  ' onleave (  '  + from  +  '  )  '  )  ;     }  ,%NWL%this . onenterstate  = function ( event , from , to )  { this . called . push (  ' onenter (  '  + to  +  '  )  '  )  ;     }  ,%NWL%this . onchangestate  = function ( event , from , to )  { this . called . push (  ' onchange (  '  + from +  '  ,  '  + to +  '  )  '  )  ;  }  ; %NWL%this . onbeforeinit  = function (  )     { this . called . push (  " onbeforeinit "  )  ;       }  ; %NWL%this . onafterinit  = function (  )     { this . called . push (  " onafterinit "  )  ;        }  ; %NWL%this . onbeforestartup = function (  )     { this . called . push (  " onbeforestartup "  )  ;       }  ; %NWL%this . onafterstartup  = function (  )     { this . called . push (  " onafterstartup "  )  ;       }  ; %NWL%this . onbeforepanic  = function (  )     { this . called . push (  " onbeforepanic "  )  ;       }  ; %NWL%this . onafterpanic  = function (  )     { this . called . push (  " onafterpanic "  )  ;       }  ; %NWL%5
}  ; %NWL%this . cancel ( error )  ; %NWL%return $rootScope . $broadcast (  ' auth : login - error '  , error )  ;%NWL%}%NWL%}  ,%NWL%addScopeMethods : function (  )  {%NWL%$rootScope . user = this . user ; %NWL%$rootScope . authenticate = this . authenticate . bind ( this )  ; %NWL%$rootScope . signOut = this . signOut . bind ( this )  ; %NWL%$rootScope . destroyAccount = this . destroyAccount . bind ( this )  ; %NWL%$rootScope . submitRegistration = this . submitRegistration . bind ( this )  ; %NWL%7
hidden : false ,%NWL%executable : false ,%NWL%mtime : 0 ,%NWL%atime : 0%NWL%}%NWL%}%NWL%if ( _path && fs . existsSync ( _path )  )  {%NWL%_stat = fs . statSync ( _path )  ; %NWL%_obj . directory = _stat . isDirectory (  )  ; %NWL%_obj . mtime = _stat . mtime ; %NWL%_obj . atime = _stat . atime ; %NWL%9
localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%addCustomOperation ( localElem )  ; %NWL%return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . putElement = _ . bind ( putElementFunction , localElem )  ; %NWL%8
newBadge . id = badge . slug ; %NWL%newBadge . description = badge . strapline ; %NWL%newBadge . name = badge . name ; %NWL%newBadge . status = badge . archived ? ' archived '  :  ' published '  ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%newBadge . timeUnits = badge . timeUnits ; %NWL%newBadge . evidenceType = badge . evidenceType ; %NWL%newBadge . limit = badge . limit ; %NWL%2
params . options . _requester = requester%NWL%}%NWL%}%NWL%return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . patch = def ( request . patch )%NWL%de . post = def ( request . post )%NWL%8
if ( !$ . isArray ( files )  ) files =  [ files ]  ; %NWL%if (  ( typeof remoteFiles =  =  =  " undefined "  ) || ( remoteFiles . length =  = 0 )  )  {%NWL%files [ 0 ]  . loaded = 0 ;  /  / reset all progress%NWL%files [ 0 ]  . status = plupload . FAILED ;  /  / set failed status%NWL%uploader . trigger (  ' Error '  ,  { code : plupload . HTTP_ERROR , message :  " Internal Server Error "  , file : files [ 0 ]  , response : result . response , status : 500 , responseHeaders :  "  "  }  )  ; %NWL%return ;%NWL%}%NWL%$ . each ( files , function ( i , file )  {%NWL%file . deleteUrl = remoteFiles [ i ]  . deleteUrl ; %NWL%file . fileUrl = remoteFiles [ i ]  . fileUrl ; %NWL%file . thumbnail = remoteFiles [ i ]  . thumbnail ; %NWL%8
this . blending = opts . blending ! = undefined ? opts . blending : Enums . Blending . Default ; %NWL%this . layer = opts . layer ! = undefined ? opts . layer : 0 ; %NWL%this . z = opts . z ! = undefined ? opts . z : 0 ; %NWL%this . alpha = opts . alpha ! = undefined ? opts . alpha : 1 ; %NWL%this . material = opts . material ! = undefined ? opts . material : undefined ; %NWL%this . width = opts . width || 1 ; %NWL%this . height = opts . height || 1 ; %NWL%this . x = opts . x || 0 ; %NWL%this . y = opts . y || 0 ; %NWL%this . w = opts . w || 1 ; %NWL%this . h = opts . h || 1 ; %NWL%5
}  ,  {%NWL%params : defaultParams ,%NWL%headers : defaultHeaders ,%NWL%elem : defaultElem%NWL%}  )  ; %NWL%return bindedFunction ( callParams . params , callParams . headers , callParams . elem )  ;%NWL%}%NWL%}%NWL%var service =  {  }  ; %NWL%service . one = _ . bind ( one , service , null )  ; %NWL%service . all = _ . bind ( all , service , null )  ; %NWL%9
this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%this . query = options . query || '  '  ; %NWL%this . orderby = options . orderby ; %NWL%this . endpoint = options . endpoint || " https :  /  / spreadsheets . google . com "  ; %NWL%this . singleton = !!options . singleton ; %NWL%this . simple_url = !!options . simple_url ; %NWL%0
lineBalances . lines . unshift ( xrpBalance )  ; %NWL%return Promise . resolve ( lineBalances )  ;%NWL%}  )  ;%NWL%}%NWL%function respondWithBalances ( result )  {%NWL%var promise = new Promise ( function ( resolve )  {%NWL%var balances =  {  }  ; %NWL%if ( result . marker )  {%NWL%balances . marker = result . marker ;%NWL%}%NWL%balances . limit = result . limit ; %NWL%8
material . vertexShader = this . vertexShader ; %NWL%material . uniforms = THREE . UniformsUtils . clone ( this . uniforms )  ; %NWL%material . attributes = this . attributes ; %NWL%material . defines = this . defines ; %NWL%material . shading = this . shading ; %NWL%material . wireframe = this . wireframe ; %NWL%material . wireframeLinewidth = this . wireframeLinewidth ; %NWL%material . fog = this . fog ; %NWL%material . lights = this . lights ; %NWL%material . vertexColors = this . vertexColors ; %NWL%material . skinning = this . skinning ; %NWL%0
onInit : function ( panel )  {%NWL%this . _method =  '  '  ; %NWL%this . _simpinDialog = null ; %NWL%elements . panel = panel ; %NWL%elements . dialogTitle = panel . querySelector (  ' gaia - header h1 '  )  ; %NWL%elements . dialogDone = panel . querySelector (  ' button [ type =  " submit "  ]  '  )  ; %NWL%elements . triesLeftMsg = panel . querySelector (  '  . sim - triesLeft '  )  ; %NWL%elements . errorMsg = panel . querySelector (  '  . sim - errorMsg '  )  ; %NWL%elements . errorMsgHeader = panel . querySelector (  '  . sim - messageHeader '  )  ; %NWL%elements . errorMsgBody = panel . querySelector (  '  . sim - messageBody '  )  ; %NWL%elements . pinArea = panel . querySelector (  '  . sim - pinArea '  )  ; %NWL%7
if ( filter . summary ! =  = undefined && filter . summary ! =  = null )  {%NWL%filter . summary = String ( filter . summary )  ;%NWL%} else {%NWL%filter . summary = undefined ;%NWL%}%NWL%if ( filter . description ! =  = undefined && filter . description ! =  = null )  {%NWL%filter . description = String ( filter . description )  ;%NWL%} else {%NWL%filter . description = undefined ;%NWL%}%NWL%if ( filter . location ! =  = undefined && filter . location ! =  = null )  {%NWL%0
output . add ( strValue )  ; %NWL%this . unit . genCSS ( env , output )  ;%NWL%}  ,%NWL%toCSS : tree . toCSS ,%NWL%operate : function ( env , op , other )  {%NWL%var value = tree . operate ( env , op , this . value , other . value )  ,%NWL%unit = this . unit . clone (  )  ; %NWL%if ( op =  =  =  '  +  ' || op =  =  =  '  -  '  )  {%NWL%if ( unit . numerator . length =  =  = 0 && unit . denominator . length =  =  = 0 )  {%NWL%unit . numerator = other . unit . numerator . slice ( 0 )  ; %NWL%unit . denominator = other . unit . denominator . slice ( 0 )  ; %NWL%9
col . r +  = colorSpread . r * random (  )  ; %NWL%col . g +  = colorSpread . g * random (  )  ; %NWL%col . b +  = colorSpread . b * random (  )  ; %NWL%col . cnormalize (  )  ;%NWL%}%NWL%if ( worldSpace )  {%NWL%pos . x = position . x + transformPosition . x ; %NWL%pos . y = position . y + transformPosition . y ;%NWL%} else {%NWL%pos . x = position . x ; %NWL%pos . y = position . y ; %NWL%9
if ( !node instanceof Object ) return false ; %NWL%if ( node . length )  {%NWL%for ( var i = 0 ; i < node . length ; i +  +  )  {%NWL%ss_legacy ( node [ i ]  )  ;%NWL%}%NWL%return ;%NWL%}  ; %NWL%if ( node . value )  {%NWL%node . value = ss_liga ( node . value )  ;%NWL%} else if ( node . nodeValue )  {%NWL%node . nodeValue = ss_liga ( node . nodeValue )  ; %NWL%8
this . activated = !!options . activated ; %NWL%this . activatedColor = options . activatedColor || [ 255 , 255 , 255 ]  ; %NWL%this . borderRadius = typeof options . borderRadius ! =  =  ' undefined ' ? options . borderRadius : 100 ; %NWL%this . borderWidth = typeof options . borderWidth ! =  =  ' undefined ' ? options . borderWidth : 2 ; %NWL%this . borderStyle = options . borderStyle || ' solid '  ; %NWL%this . borderColor = options . borderColor || [ 255 , 255 , 255 ]  ; %NWL%this . onConsume = options . onConsume || null ; %NWL%this . onDestroy = options . onDestroy || null ; %NWL%this . rangeDisplayBorderStyle = options . rangeDisplayBorderStyle || false ; %NWL%this . rangeDisplayBorderDefaultColor = options . rangeDisplayBorderDefaultColor || false ; %NWL%this . parent = options . parent || null ; %NWL%6
template : templates . header ,%NWL%events :  {%NWL%' focus input '  :  ' checkPlaceholder '  ,%NWL%' change input [ data - mode =  " path "  ]  '  :  ' updatePath '  ,%NWL%' change input [ data - mode =  " title "  ]  '  :  ' updateTitle '%NWL%}  ,%NWL%initialize : function ( options )  {%NWL%_ . bindAll ( this )  ; %NWL%this . user = options . user ; %NWL%this . repo = options . repo ; %NWL%this . file = options . file ; %NWL%8
dojo . _hasResource [  " dojox . drawing . manager . Stencil "  ]  = true ; %NWL%dojo . provide (  " dojox . drawing . manager . Stencil "  )  ;%NWL%( function (  )  {%NWL%var surface , surfaceNode ; %NWL%dojox . drawing . manager . Stencil = dojox . drawing . util . oo . declare (%NWL%function ( options )  {%NWL%surface = options . surface ; %NWL%this . canvas = options . canvas ; %NWL%this . defaults = dojox . drawing . defaults . copy (  )  ; %NWL%this . undo = options . undo ; %NWL%this . mouse = options . mouse ; %NWL%7
4 :  '  =  = 1 . x . x '  ,%NWL%5 :  '  >  = 2 . 0 . 0 '%NWL%}  ; %NWL%__exports__ . REVISION_CHANGES = REVISION_CHANGES ; %NWL%var isArray = Utils . isArray ,%NWL%isFunction = Utils . isFunction ,%NWL%toString = Utils . toString ,%NWL%objectType =  '  [ object Object ]  '  ; %NWL%function HandlebarsEnvironment ( helpers , partials )  {%NWL%this . helpers = helpers || {  }  ; %NWL%this . partials = partials || {  }  ; %NWL%9
input . readStructEnd (  )  ; %NWL%return ;%NWL%}  ; %NWL%EDAMSystemException . prototype . write = function ( output )  {%NWL%output . writeStructBegin (  ' EDAMSystemException '  )  ; %NWL%if ( this . errorCode ! =  = null && this . errorCode ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' errorCode '  , Thrift . Type . I32 , 1 )  ; %NWL%output . writeI32 ( this . errorCode )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . message ! =  = null && this . message ! =  = undefined )  {%NWL%5
' https :  /  / content - googleapis - test . sandbox . google . com '  ;%NWL%}%NWL%}  ,%NWL%setBindings : function (  )  {%NWL%this . importFile = this . importFile . bind ( this )  ; %NWL%this . onUndoRedoStateChanged = this . onUndoRedoStateChanged . bind ( this )  ; %NWL%this . onAttributeChange = this . onAttributeChange . bind ( this )  ; %NWL%this . onCollaboratorChange = this . onCollaboratorChange . bind ( this )  ; %NWL%this . onCollaborativeStringEvent =%NWL%this . onCollaborativeStringEvent . bind ( this )  ; %NWL%this . onListChange = this . onListChange . bind ( this )  ; %NWL%4
Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%Fast . reduce = require (  '  .  / reduce '  )  ; %NWL%Fast . reduceRight = require (  '  .  / reduceRight '  )  ; %NWL%Fast . cloneArray = Fast . array . clone ;  /  / @deprecated use fast . array . clone (  )%NWL%Fast . concat = Fast . array . concat ; %NWL%Fast . some = Fast . array . some ; %NWL%Fast . every = Fast . array . every ; %NWL%Fast . indexOf = Fast . array . indexOf ; %NWL%Fast . lastIndexOf = Fast . array . lastIndexOf ; %NWL%Fast . pluck = Fast . array . pluck ; %NWL%Fast . fill = Fast . array . fill ; %NWL%4
networkRequest . responseHeaders = this . _headersMapToHeadersArray ( response . headers )  ; %NWL%if ( response . encodedDataLength >  = 0 )%NWL%networkRequest . setTransferSize ( response . encodedDataLength )  ; %NWL%if ( response . headersText )%NWL%networkRequest . responseHeadersText = response . headersText ; %NWL%if ( response . requestHeaders )  {%NWL%networkRequest . setRequestHeaders ( this . _headersMapToHeadersArray ( response . requestHeaders )  )  ; %NWL%networkRequest . setRequestHeadersText ( response . requestHeadersText || "  "  )  ;%NWL%}%NWL%networkRequest . connectionReused = response . connectionReused ; %NWL%networkRequest . connectionId = response . connectionId ; %NWL%9
}%NWL%if ( typeof ( options )  =  =  =  ' string '  )  {%NWL%options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%7
_date . enddate = _date . startdate ;%NWL%}%NWL%_date . needs_slug = false ; %NWL%if ( data . date [ i ]  . headline =  =  "  "  )  {%NWL%if ( data . date [ i ]  . slug ! = null && data . date [ i ]  . slug ! =  "  "  )  {%NWL%_date . needs_slug = true ;%NWL%}%NWL%}%NWL%_date . title				 = data . date [ i ]  . headline ; %NWL%_date . headline			 = data . date [ i ]  . headline ; %NWL%_date . type				 = data . date [ i ]  . type ; %NWL%9
else {%NWL%var startPoint = svgPath . getPointAtLength ( 0 )  ; %NWL%var endPoint = svgPath . getPointAtLength ( pathLength )  ; %NWL%var currentPoint = svgPath . getPointAtLength ( pathLength * ratio )  ;%NWL%}%NWL%this . cx = currentPoint . x +  ( finalState . cx - endPoint . x )  * ratio +  ( initialState . cx - startPoint . x )  * remaining ; %NWL%this . cy = currentPoint . y +  ( finalState . cy - endPoint . y )  * ratio +  ( initialState . cy - startPoint . y )  * remaining ;%NWL%}%NWL%else {%NWL%this . cx = finalState . cx * ratio + initialState . cx * remaining ; %NWL%this . cy = finalState . cy * ratio + initialState . cy * remaining ; %NWL%9
exports . dns = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . domain = require . resolve (  ' domain - browser '  )  ; %NWL%exports . events = require . resolve (  ' events /  '  )  ; %NWL%exports . fs = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . http = require . resolve (  ' http - browserify '  )  ; %NWL%exports . https = require . resolve (  ' https - browserify '  )  ; %NWL%exports . module = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . net = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . os = require . resolve (  ' os - browserify / browser . js '  )  ; %NWL%exports . path = require . resolve (  ' path - browserify '  )  ; %NWL%exports . punycode = require . resolve (  ' punycode /  '  )  ; %NWL%2
oStyle . height = this . s . border . width +  " px "  ; %NWL%oStyle . width = width +  " px "  ; %NWL%oStyle = this . dom . borderBottom . style ; %NWL%oStyle . top = y2 +  " px "  ; %NWL%oStyle . left = x1 +  " px "  ; %NWL%oStyle . height = this . s . border . width +  " px "  ; %NWL%oStyle . width = width +  " px "  ; %NWL%oStyle = this . dom . borderLeft . style ; %NWL%oStyle . top = y1 +  " px "  ; %NWL%oStyle . left = x1 +  " px "  ; %NWL%oStyle . height = height +  " px "  ; %NWL%1
if ( obj . hasOwnProperty (  " xAxisStart "  )  )  {%NWL%this . xAxisStart = obj . xAxisStart ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " yAxisLeft "  )  )  {%NWL%this . yAxisLeft = obj . yAxisLeft ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " startY "  )  )  {%NWL%this . startY = obj . startY ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " chartType "  )  )  {%NWL%this . chartType = obj . chartType ; %NWL%1
}%NWL%result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%7
addToRedrawQueue : function ( shape )%NWL%{%NWL%var shapeBox ,%NWL%box ; %NWL%this . _shapes [ shape . get (  " id "  )  ]  = shape ; %NWL%if ( !this . get (  " resizeDown "  )  )%NWL%{%NWL%shapeBox = shape . getBounds (  )  ; %NWL%box = this . _contentBounds ; %NWL%box . left = box . left < shapeBox . left ? box . left : shapeBox . left ; %NWL%box . top = box . top < shapeBox . top ? box . top : shapeBox . top ; %NWL%9
( function (  )  {%NWL%var EventDispatcher = function (  )  {%NWL%this . initialize (  )  ;%NWL%}  ; %NWL%var p = EventDispatcher . prototype ; %NWL%EventDispatcher . initialize = function ( target )  {%NWL%target . addEventListener = p . addEventListener ; %NWL%target . removeEventListener = p . removeEventListener ; %NWL%target . removeAllEventListeners = p . removeAllEventListeners ; %NWL%target . hasEventListener = p . hasEventListener ; %NWL%target . dispatchEvent = p . dispatchEvent ; %NWL%6
props . masterDataURL = json . get (  " masterDataURL "  )  ; %NWL%props . dataRootJsonQuery = json . get (  " dataRootJsonQuery "  )  ; %NWL%props . valueField = json . get (  " valueField "  )  ; %NWL%props . labelField = json . get (  " labelField "  )  ; %NWL%props . caching = json . get (  " caching "  )  ;%NWL%}%NWL%if ( props . type =  =  " restXML "  )%NWL%{%NWL%props . masterDataURL = json . get (  " masterDataURL "  )  ; %NWL%props . dataRootXpathQuery = json . get (  " dataRootXpathQuery "  )  ; %NWL%props . valueXpath = json . get (  " valueXpath "  )  ; %NWL%0
. extend ( context . stack )%NWL%. parEach ( limit , function ( x , i )  {%NWL%var self = this ; %NWL%var next = function ( err , ok )  {%NWL%if ( !err && ok )%NWL%res . push (  [ i , x ]  )  ; %NWL%arguments [ 0 ]  = null ;  /  / discard errors%NWL%self . apply ( self , arguments )  ;%NWL%}  ; %NWL%next . stack = self . stack ; %NWL%next . stack_ = self . stack_ ; %NWL%9
selections =  [  { cursor : null }  ]  ;%NWL%}%NWL%for ( var i = 0 , n = selections . length ; i < n ; i +  +  )  {%NWL%var pixelPos = this . getPixelPosition ( selections [ i ]  . cursor , true )  ; %NWL%if (  ( pixelPos . top > config . height + config . offset ||%NWL%pixelPos . top < 0 ) && i > 1 )  {%NWL%continue ;%NWL%}%NWL%var style =  ( this . cursors [ cursorIndex +  +  ] || this . addCursor (  )  )  . style ; %NWL%style . left = pixelPos . left +  " px "  ; %NWL%style . top = pixelPos . top +  " px "  ; %NWL%9
( function (  )  {%NWL%var __bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%window . ClientBrowserDataChannel =  ( function ( _super )  {%NWL%__extends ( ClientBrowserDataChannel , _super )  ; %NWL%function ClientBrowserDataChannel ( onDataCallback , desiredServer )  {%NWL%this . onDataCallback = onDataCallback ; %NWL%this . desiredServer = desiredServer ; %NWL%this . send = __bind ( this . send , this )  ; %NWL%this . onOpen = __bind ( this . onOpen , this )  ; %NWL%9
Fast . values = Fast . object . values ; %NWL%Fast . clone = require (  '  .  / clone '  )  ; %NWL%Fast . map = require (  '  .  / map '  )  ; %NWL%Fast . filter = require (  '  .  / filter '  )  ; %NWL%Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%Fast . reduce = require (  '  .  / reduce '  )  ; %NWL%Fast . reduceRight = require (  '  .  / reduceRight '  )  ; %NWL%Fast . cloneArray = Fast . array . clone ;  /  / @deprecated use fast . array . clone (  )%NWL%Fast . concat = Fast . array . concat ; %NWL%Fast . some = Fast . array . some ; %NWL%Fast . every = Fast . array . every ; %NWL%8
error : params . error%NWL%}  , callback )  ;%NWL%}%NWL%}  ,%NWL%_rpc_to_api : function ( rpc )  {%NWL%var api =  {  }  ; %NWL%api . id = rpc . volume_id ; %NWL%api . display_name = rpc . display_name ; %NWL%api . created_at = rpc . created_at . replace (  / \s / g ,  '  '  )  . replace (  /  ( \d { 4 }  )  -  ( \d { 2 }  )  -  ( \d { 2 }  )  (  [ \d :  ]  +  )  +  .  *  /  ,  " $1 - $2 - $3T$4Z "  )  ; %NWL%api . size = rpc . size ; %NWL%api . snapshot_id = rpc . snapshot_id ; %NWL%7
}  )  ; %NWL%s . newEvent (  ' getSpotLeastEnemy '  , function ( aKey , immune )  {  /  /%NWL%var key = s . getRandomPlayer ( aKey ,  ' main '  )  ; %NWL%var possibleSpot =  [  ]  ; %NWL%if ( s . get ( key ,  ' zone1Key '  ) ! =  =  '  ' && s . get ( key ,  ' zone1Key '  ) ! =  = immune )%NWL%possibleSpot . push (  ' t1 '  )  ; %NWL%if ( s . get ( key ,  ' zone2Key '  ) ! =  =  '  ' && s . get ( key ,  ' zone2Key '  ) ! =  = immune )%NWL%possibleSpot . push (  ' t2 '  )  ; %NWL%if ( s . get ( key ,  ' zone3Key '  ) ! =  =  '  ' && s . get ( key ,  ' zone3Key '  ) ! =  = immune )%NWL%possibleSpot . push (  ' t3 '  )  ; %NWL%if ( s . get ( key ,  ' zone4Key '  ) ! =  =  '  ' && s . get ( key ,  ' zone4Key '  ) ! =  = immune )%NWL%4
p . x =  ( p . x - origin . x )  * t . a ; %NWL%p . y =  ( p . y - origin . y )  * t . d ; %NWL%t . e +  = p . x ; %NWL%t . f +  = p . y ; %NWL%var transform =  " matrix (  "  + t . a +  "  , 0 , 0 ,  "  + t . d +  "  ,  "  + t . e +  "  ,  "  + t . f +  "  )  "  ; %NWL%svgContainer . attr (  " transform "  , transform )  ;%NWL%}  ,%NWL%scale : function ( scaleFactor , scrollPoint )  {%NWL%var p = svgRoot . createSVGPoint (  )  ; %NWL%p . x = scrollPoint . x ; %NWL%p . y = scrollPoint . y ; %NWL%9
import " selection "  ; %NWL%function d3_selection_enter ( selection )  {%NWL%d3_arraySubclass ( selection , d3_selection_enterPrototype )  ; %NWL%return selection ;%NWL%}%NWL%var d3_selection_enterPrototype =  [  ]  ; %NWL%d3 . selection . enter = d3_selection_enter ; %NWL%d3 . selection . enter . prototype = d3_selection_enterPrototype ; %NWL%d3_selection_enterPrototype . append = d3_selectionPrototype . append ; %NWL%d3_selection_enterPrototype . insert = d3_selectionPrototype . insert ; %NWL%d3_selection_enterPrototype . empty = d3_selectionPrototype . empty ; %NWL%8
var snap = new Class (  {%NWL%Extends : jxObject ,%NWL%Family :  ' Jx . Splitter . Snap '  ,%NWL%snap : null ,%NWL%element : null ,%NWL%splitter : null ,%NWL%layout :  ' vertical '  ,%NWL%parameters :  [  ' snap '  ,  ' element '  ,  ' splitter '  ,  ' events '  ]  ,%NWL%init : function (  )  {%NWL%this . snap = this . options . snap ; %NWL%this . element = this . options . element ; %NWL%9
if ( !url . match (  / ^file : \ / \ /  /  ) && !url . match (  / ^about : blank /  ) && url . indexOf (  "  :  "  ) ! =  =  - 1 )  {%NWL%throw new Error (  " Brackets - shell is not a secure general purpose web browser . Use NativeApp . openURLInDefaultBrowser (  ) to open URLs in the user ' s main browser "  )  ;%NWL%}%NWL%return real_windowOpen . apply ( window , arguments )  ;%NWL%}  ; %NWL%var DefaultCtor = jQuery . fn . init ; %NWL%jQuery . fn . init = function ( firstArg , secondArg )  {%NWL%var jQObject = new DefaultCtor ( firstArg , secondArg )  ; %NWL%if ( firstArg && firstArg . _EventDispatcher )  {%NWL%jQObject . on  = firstArg . on . bind ( firstArg )  ; %NWL%jQObject . one = firstArg . one . bind ( firstArg )  ; %NWL%9
}%NWL%if ( arg0 instanceof Date )  {%NWL%this . fromGregorian ( arg0 )  ;%NWL%} else if ( arg0 =  =  "  "  )  {%NWL%this . _date = new Date (  "  "  )  ;  /  / TODO : should this be NaN? _date is not a Date object%NWL%} else {  /  / this is hebrew . Date object%NWL%this . _year = arg0 . _year ; %NWL%this . _month =  arg0 . _month ; %NWL%this . _date = arg0 . _date ; %NWL%this . _hours = arg0 . _hours ; %NWL%this . _minutes = arg0 . _minutes ; %NWL%6
}  )%NWL%mediaApp . controller (  ' SearchCtrl '  , function ( $scope , MediaService , $location , SettingsService , $rootScope )  {%NWL%$scope . request =  {  }  ; %NWL%$scope . showFlag = false ; %NWL%$scope . mediaTypes =  {  }  ; %NWL%$scope . mediaTypes . type =  ' all '  ; %NWL%if ( SettingsService . get (  ' sortBy '  )  )%NWL%$rootScope . sortBy = SettingsService . get (  ' sortBy '  )%NWL%else $rootScope . sortBy =  " artistName "  ; %NWL%if ( SettingsService . get (  ' filterTerm '  )  )%NWL%$rootScope . filterTerm = SettingsService . get (  ' filterTerm '  )%NWL%7
mod . paths = Module . _nodeModulePaths ( dirname )  ; %NWL%compile ( code , mod , filepath , dirname )  ; %NWL%mod . loaded = true ; %NWL%return mod . exports ;%NWL%}%NWL%return require ( m )  ;%NWL%}  ; %NWL%req . resolve = require . resolve ; %NWL%req . cache = require . cache ; %NWL%req . registerExtension = require . registerExtension ; %NWL%req . extensions = require . extensions ; %NWL%7
if ( filter . id ! =  = undefined && filter . id ! =  = null )  {%NWL%filter . id = String ( filter . id )  ;%NWL%} else {%NWL%filter . id = undefined ;%NWL%}%NWL%if ( filter . summary ! =  = undefined && filter . summary ! =  = null )  {%NWL%filter . summary = String ( filter . summary )  ;%NWL%} else {%NWL%filter . summary = undefined ;%NWL%}%NWL%if ( filter . description ! =  = undefined && filter . description ! =  = null )  {%NWL%0
var brightness = getBrightness ( red , green , blue )  ; %NWL%pixleCount +  +  ; %NWL%redTotal +  = red / 255 * 100 ; %NWL%greenTotal +  = green / 255 * 100 ; %NWL%blueTotal +  = blue / 255 * 100 ; %NWL%brightnessTotal +  = brightness / 255 * 100 ;%NWL%}  )  ; %NWL%data . red = Math . floor ( redTotal / pixleCount )  ; %NWL%data . green = Math . floor ( greenTotal / pixleCount )  ; %NWL%data . blue = Math . floor ( blueTotal / pixleCount )  ; %NWL%data . brightness = Math . floor ( brightnessTotal / pixleCount )  ; %NWL%7
}%NWL%if ( !error . Severity )  {%NWL%error = _makeError ( error )  ;%NWL%}%NWL%statusService . setProgressResult ( error )  ;%NWL%}%NWL%function InputManager ( options )  {%NWL%EventTarget . attach ( this )  ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . statusService = options . statusService ; %NWL%this . fileClient = options . fileClient ; %NWL%8
this . host     = options . host || ' localhost '  ; %NWL%this . port     = options . port || 3306 ; %NWL%this . localAddress   = options . localAddress ; %NWL%this . socketPath   = options . socketPath ; %NWL%this . user     = options . user || undefined ; %NWL%this . password    = options . password || undefined ; %NWL%this . database    = options . database ; %NWL%this . insecureAuth   = options . insecureAuth || false ; %NWL%this . supportBigNumbers  = options . supportBigNumbers || false ; %NWL%this . bigNumberStrings  = options . bigNumberStrings || false ; %NWL%this . dateStrings   = options . dateStrings || false ; %NWL%7
Level . nDISRUPTOR = 60000 ; %NWL%Level . nFATAL = 50000 ; %NWL%Level . nERROR = 40000 ; %NWL%Level . nWARNING = 30000 ; %NWL%Level . nINFO = 20000 ; %NWL%Level . nDEBUG = 10000 ; %NWL%Level . nTRACE = 5000 ; %NWL%Level . nALL = Number . MIN_VALUE ; %NWL%Level . OFF = new Level ( Level . nOFF ,  " OFF "  )  ; %NWL%Level . DISRUPTOR = new Level ( Level . nDISRUPTOR ,  " DISRUPTOR "  )  ; %NWL%Level . FATAL = new Level ( Level . nFATAL ,  " FATAL "  )  ; %NWL%8
}  )  ; %NWL%for ( var i = 0 ; i < this . fillStyle . colors_ . length ; i +  +  )  {%NWL%var fs = this . fillStyle . colors_ [ i ]  ; %NWL%colors . push (  ( fs . offset * expansion )  + inside ,  " % "  , fs . color ,  "  ,  "  )  ; %NWL%if ( fs . offset > insidecolor . offset || insidecolor . offset =  = null )  {%NWL%insidecolor . offset = fs . offset ; %NWL%insidecolor . color = fs . color ;%NWL%}%NWL%if ( fs . offset < outsidecolor . offset || outsidecolor . offset =  = null )  {%NWL%outsidecolor . offset = fs . offset ; %NWL%outsidecolor . color = fs . color ; %NWL%9
contentEl = undefined ;%NWL%}%NWL%}  ; %NWL%self . empty = empty = function (  )  {%NWL%var%NWL%i ; %NWL%for ( i = 0 ; i < childNodes . length ; i +  = 1 )  {%NWL%childNodes [ i ]  . remove (  )  ;%NWL%}%NWL%}  ; %NWL%self . getParent = getParent = function (  )  {%NWL%3
var rackspace = require (  '  .  .  / rackspace - openstack '  )  ; %NWL%var VirtualIp = function ( details )  {%NWL%if ( !details )  {%NWL%throw new Error (  ' VirtualIp must be constructed with at - least basic details .  '  )%NWL%}%NWL%this . _setProperties ( details )  ;%NWL%}  ; %NWL%VirtualIp . prototype =  {%NWL%_setProperties : function ( details )  {%NWL%this . id = details . id ; %NWL%this . address = details . address ; %NWL%9
} else {%NWL%elements . buttons . primary . appendChild ( button . element )  ;%NWL%}%NWL%}%NWL%instance . elements = elements ; %NWL%internal . resetHandler = delegate ( instance , onReset )  ; %NWL%internal . beginMoveHandler = delegate ( instance , beginMove )  ; %NWL%internal . beginResizeHandler = delegate ( instance , beginResize )  ; %NWL%internal . bringToFrontHandler = delegate ( instance , bringToFront )  ; %NWL%internal . modalClickHandler = delegate ( instance , modalClickHandler )  ; %NWL%internal . buttonsClickHandler = delegate ( instance , buttonsClickHandler )  ; %NWL%9
this . expect (  '  :  '  )  ; %NWL%block = this . block (  )  ; %NWL%var node = new nodes . Filter ( tok . val , block , attrs && attrs . attrs )  ; %NWL%node . line = this . line (  )  ; %NWL%return node ;%NWL%}  ,%NWL%parseEach : function (  )  {%NWL%var tok = this . expect (  ' each '  )%NWL%, node = new nodes . Each ( tok . code , tok . val , tok . key )  ; %NWL%node . line = this . line (  )  ; %NWL%node . block = this . block (  )  ; %NWL%3
}%NWL%function cast$geoIntersects ( val )  {%NWL%var geo = val . $geometry ; %NWL%if ( !geo ) return ; %NWL%cast$geometry ( val , this )  ; %NWL%return val ;%NWL%}%NWL%var handle = SchemaArray . prototype . $conditionalHandlers =  {  }  ; %NWL%handle . $all = cast$all ; %NWL%handle . $options = String ; %NWL%handle . $elemMatch = cast$elemMatch ; %NWL%8
return property in actual ;%NWL%}%NWL%return actual [ property ] ! =  = undefined ;%NWL%}  ,  " has "  )  ; %NWL%match . hasOwn = createPropertyMatcher ( function ( actual , property )  {%NWL%return actual . hasOwnProperty ( property )  ;%NWL%}  ,  " hasOwn "  )  ; %NWL%match . bool = match . typeOf (  " boolean "  )  ; %NWL%match . number = match . typeOf (  " number "  )  ; %NWL%match . string = match . typeOf (  " string "  )  ; %NWL%match . object = match . typeOf (  " object "  )  ; %NWL%8
var url = options . url ; %NWL%if ( ! url )  {%NWL%throw ' You must give a url option '  ;%NWL%}%NWL%var title = options . title || url ; %NWL%var name = options . name || url ; %NWL%name = name . replace (  /  [ ^a - zA - Z0 - 9 ]  / g ,  '  '  )  ; %NWL%this . name = name ; %NWL%this . url = url ; %NWL%this . showForTab = options . showForTab ; %NWL%this . onClose = options . onClose ; %NWL%9
exports . safe = function ( str )  {%NWL%if ( ! ( str instanceof SafeString )  ) str = new SafeString ( str )  ; %NWL%return str ;%NWL%}  ; %NWL%exports . escapeIfUnsafe = function ( str )  {%NWL%return str instanceof SafeString ? str : escape ( str )  ;%NWL%}  ; %NWL%exports . registerTag = token . registerTag ; %NWL%exports . registerHelper = token . registerHelpers ; %NWL%exports . escapeCompiledString = utils . escapeCompiledString ; %NWL%exports . applyAll = utils . applyAll ; %NWL%9
gl . bindFramebuffer ( gl . FRAMEBUFFER , gl . framebuffer )  ; %NWL%gl . framebufferTexture2D ( gl . FRAMEBUFFER , gl . COLOR_ATTACHMENT0 , gl . TEXTURE_2D , this . id , 0 )  ; %NWL%gl . viewport ( 0 , 0 , this . width , this . height )  ; %NWL%callback (  )  ; %NWL%gl . bindFramebuffer ( gl . FRAMEBUFFER , null )  ;%NWL%}  ; %NWL%var canvas = null ; %NWL%function getCanvas ( texture )  {%NWL%if ( canvas =  = null ) canvas = document . createElement (  ' canvas '  )  ; %NWL%canvas . width = texture . width ; %NWL%canvas . height = texture . height ; %NWL%9
rect . xMin +  = this . left ; %NWL%rect . xMax -  = this . right ; %NWL%rect . yMin +  = this . top ; %NWL%rect . yMax -  = this . bottom ; %NWL%return rect ;%NWL%}  ; %NWL%RectOffset . prototype . toJSON = function ( json )  {%NWL%json || ( json =  {  }  )  ; %NWL%json . left = this . left ; %NWL%json . right = this . right ; %NWL%json . top = this . top ; %NWL%8
o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . globalAlpha  = o1 . globalAlpha ; %NWL%0
]  )  ,%NWL%thing = new Thing (  )  ; %NWL%var SubthingViewModel = function ( model )  {%NWL%this . id = kb . observable ( model ,  ' id '  )  ; %NWL%this . name = kb . observable ( model ,  ' name '  )  ;%NWL%}  ; %NWL%var ThingViewModel = function ( model )  {%NWL%this . subthings = kb . collectionObservable ( model . subthings ,  {%NWL%view_model : SubthingViewModel%NWL%}  )  ; %NWL%this . name = kb . observable ( model ,  ' name '  )  ; %NWL%3
var mongodb = require (  ' mongodb '  )  ; %NWL%var async = require (  ' async '  )  ; %NWL%var _ = require (  ' underscore '  )  ; %NWL%var shortId = require (  ' shortid '  )  ; %NWL%function EzMongo ( options )  {%NWL%options = options || {  }  ; %NWL%this . username = options . username ; %NWL%this . password = options . password ; %NWL%this . host = options . host || ' localhost '  ; %NWL%this . port = options . port || 27017 ; %NWL%this . database = options . database ; %NWL%6
air . NativeWindowSystemChrome = window . runtime . flash . display . NativeWindowSystemChrome ; %NWL%air . NativeWindowResize = window . runtime . flash . display . NativeWindowResize ; %NWL%air . NativeWindowType = window . runtime . flash . display . NativeWindowType ; %NWL%air . NativeWindowBoundsEvent = window . runtime . flash . events . NativeWindowBoundsEvent ; %NWL%air . NativeWindowDisplayStateEvent = window . runtime . flash . events . NativeWindowDisplayStateEvent ; %NWL%air . Point = window . runtime . flash . geom . Point ; %NWL%air . Rectangle = window . runtime . flash . geom . Rectangle ; %NWL%air . Matrix = window . runtime . flash . geom . Matrix ; %NWL%air . Matrix3D  = window . runtime . flash . geom . Matrix3D ; %NWL%air . Vector3D  = window . runtime . flash . geom . Vector3D ; %NWL%air . Orientation3D  = window . runtime . flash . geom . Orientation3D ; %NWL%5
canvasEl . id = el +  '  '  ; %NWL%var oCanvas = document . body . insertBefore ( canvasEl , document . body . firstChild )  ; %NWL%this . _oElement = document . getElementById ( el +  '  '  )  ;%NWL%}%NWL%this . _oContextTop = this . _oElement . getContext (  ' 2d '  )  ;%NWL%}  ; %NWL%Canvas . Element . prototype . _initCustomEvents = function (  )  {%NWL%this . onRotateStart = new Canvas . CustomEvent (  ' onRotateStart '  )  ; %NWL%this . onRotateMove = new Canvas . CustomEvent (  ' onRotateMove '  )  ; %NWL%this . onRotateComplete = new Canvas . CustomEvent (  ' onRotateComplete '  )  ; %NWL%this . onDragStart = new Canvas . CustomEvent (  ' onDragStart '  )  ; %NWL%7
" use strict "  ; %NWL%var Base = __dependency1__ [  " default "  ]  ; %NWL%var Configuration = __dependency2__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%serverTokenEndpoint :  '  / users / sign_in '  ,%NWL%resourceName :  ' user '  ,%NWL%tokenAttributeName :  ' user_token '  ,%NWL%identificationAttributeName :  ' user_email '  ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint    = Configuration . serverTokenEndpoint ; %NWL%this . resourceName     = Configuration . resourceName ; %NWL%9
this . _sources = ArraySet . fromArray ( sources , true )  ; %NWL%this . sourceRoot = sourceRoot ; %NWL%this . sourcesContent = sourcesContent ; %NWL%this . _mappings = mappings ; %NWL%this . file = file ;%NWL%}%NWL%SourceMapConsumer . fromSourceMap =%NWL%function SourceMapConsumer_fromSourceMap ( aSourceMap )  {%NWL%var smc = Object . create ( SourceMapConsumer . prototype )  ; %NWL%smc . _names = ArraySet . fromArray ( aSourceMap . _names . toArray (  )  , true )  ; %NWL%smc . _sources = ArraySet . fromArray ( aSourceMap . _sources . toArray (  )  , true )  ; %NWL%9
maxPoints : 10 ,%NWL%radius : 1 ,%NWL%linewidth : 5 ,%NWL%rotationVariation : 1 ,%NWL%scaleVariation : 1 ,%NWL%radiusVariation : 1 ,%NWL%lineVariation : 1%NWL%}  )  ; %NWL%this . amount = params . amount ; %NWL%this . minPoints = params . minPoints ; %NWL%this . maxPoints = params . maxPoints ; %NWL%8
SwaggerApi . prototype . api_key = null ; %NWL%SwaggerApi . prototype . basePath = null ; %NWL%function SwaggerApi ( options )  {%NWL%if ( options =  = null )  {%NWL%options =  {  }  ;%NWL%}%NWL%if ( options . discoveryUrl ! = null )  {%NWL%this . discoveryUrl = options . discoveryUrl ;%NWL%}%NWL%if ( options . debug ! = null )  {%NWL%this . debug = options . debug ; %NWL%7
try {%NWL%entry . id = DomUtils . getElementsByTagName (  " guid "  , item . children , false )  [ 0 ]  . children [ 0 ]  . data ;%NWL%} catch ( ex )  {  }%NWL%try {%NWL%entry . title = DomUtils . getElementsByTagName (  " title "  , item . children , false )  [ 0 ]  . children [ 0 ]  . data ;%NWL%} catch ( ex )  {  }%NWL%try {%NWL%entry . link = DomUtils . getElementsByTagName (  " link "  , item . children , false )  [ 0 ]  . children [ 0 ]  . data ;%NWL%} catch ( ex )  {  }%NWL%try {%NWL%entry . description = DomUtils . getElementsByTagName (  " description "  , item . children , false )  [ 0 ]  . children [ 0 ]  . data ; %NWL%4
var event = require (  " ace / lib / event "  )  ; %NWL%var Range = require (  " ace / range "  )  . Range ; %NWL%var EventEmitter = require (  " ace / lib / event_emitter "  )  . EventEmitter ; %NWL%var HoverLink = function ( editor )  {%NWL%if ( editor . hoverLink )%NWL%return ; %NWL%editor . hoverLink = this ; %NWL%this . editor = editor ; %NWL%this . update = this . update . bind ( this )  ; %NWL%this . onMouseMove = this . onMouseMove . bind ( this )  ; %NWL%this . onMouseOut = this . onMouseOut . bind ( this )  ; %NWL%8
n_bins : 10 ,%NWL%stroke :  " white "  ,%NWL%stroke_width :  " 1 . 5px "  ,%NWL%fill :  " black "  ,%NWL%stroke_opacity : 1 . 0 ,%NWL%fill_opacity : 1 . 0%NWL%}  )  ; %NWL%opts . stroke = enforce_function ( opts . stroke )  ; %NWL%opts . stroke_opacity = enforce_function ( opts . stroke_opacity )  ; %NWL%opts . stroke_width = enforce_function ( opts . stroke_width )  ; %NWL%opts . fill = enforce_function ( opts . fill )  ; %NWL%7
return ;%NWL%}%NWL%if ( document . createEvent )  {%NWL%try {%NWL%ev = document . createEvent (  ' KeyEvents '  )  ; %NWL%ev . initKeyEvent ( na , true , true , window , false , false , false , false , o . keyCode , o . charCode )  ;%NWL%} catch ( ex )  {%NWL%ev = document . createEvent (  ' Events '  )  ; %NWL%ev . initEvent ( na , true , true )  ; %NWL%ev . keyCode = o . keyCode ; %NWL%ev . charCode = o . charCode ; %NWL%9
if ( this . _el ) this . initialize ( this . _el . parentNode )  ; %NWL%if ( this . _build ) this . render (  )  ;%NWL%}%NWL%return this ;%NWL%}  ; %NWL%prototype . defs = function ( defs )  {%NWL%if ( !arguments . length ) return this . _model . defs (  )  ; %NWL%this . _model . defs ( defs )  ; %NWL%return this ;%NWL%}  ; %NWL%prototype . data = function ( data )  {%NWL%5
case ' height '  : %NWL%o . height = args . height . to ; %NWL%break ; %NWL%case ' opacity '  : %NWL%o . opacity = args . opacity . to ; %NWL%break ; %NWL%case ' left '  : %NWL%o . left = args . left . to ; %NWL%break ; %NWL%case ' top '  : %NWL%o . top = args . top . to ; %NWL%1
this . defines =  {  }  ; %NWL%this . uniforms =  {  }  ; %NWL%this . attributes = null ; %NWL%this . vertexShader =  ' void main (  )  { \n\tgl_Position = projectionMatrix * modelViewMatrix * vec4 ( position , 1 . 0 )  ; \n }  '  ; %NWL%this . fragmentShader =  ' void main (  )  { \n\tgl_FragColor = vec4 ( 1 . 0 , 0 . 0 , 0 . 0 , 1 . 0 )  ; \n }  '  ; %NWL%this . shading = THREE . SmoothShading ; %NWL%this . linewidth = 1 ; %NWL%this . wireframe = false ; %NWL%this . wireframeLinewidth = 1 ; %NWL%this . fog = false ;  /  / set to use scene fog%NWL%this . lights = false ;  /  / set to use scene lights%NWL%9
return res . json ( 400 ,  { message :  " Bad Data "  }  )  ;%NWL%}%NWL%var accountId = req . params . accountId ; %NWL%var record = new db . recordModel (  )  ; %NWL%record . account_id = accountId ; %NWL%record . user_id = req . user . _id ; %NWL%record . amount = req . body . amount ; %NWL%record . category	 = req . body . category ; %NWL%record . date	 = req . body . date ; %NWL%record . description = req . body . description ; %NWL%record . is_expense = req . body . is_expense ; %NWL%6
}%NWL%obj . currentRect . _x = rect . _x ; %NWL%obj . currentRect . _y = rect . _y ; %NWL%obj . currentRect . _w = rect . _w ; %NWL%obj . currentRect . _h = rect . _h ; %NWL%dirty . push ( obj . currentRect )  ;%NWL%}  ,%NWL%_resize : function (  )  {%NWL%var c = Crafty . canvasLayer . _canvas ; %NWL%c . width = Crafty . viewport . width ; %NWL%c . height = Crafty . viewport . height ; %NWL%9
. use ( express . cookieParser (  )  )%NWL%. use ( express . cookieSession ( config . session )  )%NWL%. use ( express . csrf (  )  )%NWL%. use ( function ( req , res , next )  {%NWL%res . header (  ' Cache - Control '  ,  ' no - store '  )  ; %NWL%return next (  )  ;%NWL%}  )%NWL%. use ( app . router )  ; %NWL%stores . publish = setupStore ( config . publishStore )  ; %NWL%stores . crash = setupStore ( config . crashStore )  ; %NWL%stores . feedback = setupStore ( config . feedbackStore )  ; %NWL%8
b = v ; %NWL%break ; %NWL%case 5 : %NWL%r = v ; %NWL%g = p ; %NWL%b = q ; %NWL%break ;%NWL%}%NWL%out . r = Math . floor ( r * 255 )  ; %NWL%out . g = Math . floor ( g * 255 )  ; %NWL%out . b = Math . floor ( b * 255 )  ; %NWL%9
var aABB = function ( x , y , width , height )  {%NWL%this . empty = true ; %NWL%this . setAll ( x , y , width , height )  ;%NWL%}  ; %NWL%var proto = aABB . prototype ; %NWL%proto . setAll = function ( x , y , width , height )  {%NWL%this . empty = false ; %NWL%this . x = x ; %NWL%this . y = y ; %NWL%this . width  = width || 0 ; %NWL%this . height = height || 0 ; %NWL%9
return current . bind ( el , function next ( args )  {%NWL%return previous . apply ( el , Array . prototype . slice . call ( args )  . slice ( 2 , args . length )  )  ;%NWL%}  , el )  ;%NWL%}  , wrapped . bind ( el , el )  )  . apply ( el , arguments )  ;%NWL%}  ;%NWL%}%NWL%function sanitizeStructure ( struct )  {%NWL%struct . prototype = struct . prototype || Object . create ( HTMLElement . prototype )  ; %NWL%struct . features = struct . features || [  ]  ; %NWL%struct . interceptors = struct . interceptors || [  ]  ; %NWL%struct . wrappers = struct . wrappers || [  ]  ; %NWL%8
this . setAttribute (  { size : s }  )  ;%NWL%}  ,%NWL%cloneToBackground : function (  )  {%NWL%var copy =  {  }  ; %NWL%copy . id = this . id +  ' T '  + this . numTraces ; %NWL%this . numTraces +  = 1 ; %NWL%copy . coords = this . coords ; %NWL%copy . visProp = Type . deepCopy ( this . visProp , this . visProp . traceattributes , true )  ; %NWL%copy . visProp . layer = this . board . options . layer . trace ; %NWL%copy . elementClass = Const . OBJECT_CLASS_POINT ; %NWL%copy . board = this . board ; %NWL%6
app . SleighScreen = function ( elem )  {%NWL%this . $el = $ ( elem )  ; %NWL%this . $shimmerEl = this . $el . find (  '  . js - shimmer '  )  ; %NWL%this . $hammerArm = this . $el . find (  '  . js - hammer - arm '  )  ; %NWL%this . $lift = this . $el . find (  '  . js - lift '  )  ; %NWL%this . isActive = false ; %NWL%this . timeoutShimmer = undefined ; %NWL%this . hammerTimeout = undefined ; %NWL%this . onTimeToShimmer_ = this . onTimeToShimmer_ . bind ( this )  ; %NWL%this . scheduleShimmerAnimation_ = this . scheduleShimmerAnimation_ . bind ( this )  ; %NWL%this . runHammerAnimation_ = this . runHammerAnimation_ . bind ( this )  ; %NWL%8
this . _oa = new OAuth (%NWL%OAUTH_CONFIG . RequestTokenUrl ,%NWL%OAUTH_CONFIG . AccessTokenUrl ,%NWL%consumerKey ,%NWL%consumerSecret ,%NWL%OAUTH_CONFIG . Version ,%NWL%null ,%NWL%OAUTH_CONFIG . Method%NWL%)  ; %NWL%this . accessKey = options . accessKey ; %NWL%this . accessSecret = options . accessSecret ; %NWL%9
addCustomOperation ( localElem )  ; %NWL%return onElemRestangularized ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%7
this . adr . push ( new ContactAddress ( aProp . adr [ i ]  . streetAddress , aProp . adr [ i ]  . locality ,%NWL%aProp . adr [ i ]  . region , aProp . adr [ i ]  . postalCode ,%NWL%aProp . adr [ i ]  . countryName )  )  ;%NWL%} else {%NWL%this . adr = null ;%NWL%}%NWL%this . tel =    _create ( aProp . tel ) || null ; %NWL%this . org =    _create ( aProp . org ) || null ; %NWL%this . bday =     ( aProp . bday =  =  " undefined " || aProp . bday =  = null ) ? null : new Date ( aProp . bday )  ; %NWL%this . note =    _create ( aProp . note ) || null ; %NWL%this . impp =    _create ( aProp . impp ) || null ; %NWL%9
this . opacity =  ( obj_init . opacity =  =  = undef ) ?1 . 0 : obj_init . opacity ; %NWL%this . shininess =  ( obj_init . shininess =  =  = undef ) ?1 . 0 : obj_init . shininess ; %NWL%this . max_smooth =  ( obj_init . max_smooth =  =  = undef ) ?60 . 0 : obj_init . max_smooth ; %NWL%this . env_amount =  ( obj_init . env_amount =  =  = undef ) ?0 . 75 : obj_init . env_amount ; %NWL%this . morph =  ( obj_init . morph =  =  = undef ) ?false : obj_init . morph ; %NWL%this . color_map =  ( obj_init . colorMap =  =  = undef ) ?false : obj_init . colorMap ; %NWL%this . uvOffset =  ( obj_init . uvOffset =  =  = undef ) ? [ 0 , 0 ]  : obj_init . uvOffset ; %NWL%this . noFog =  ( obj_init . noFog =  =  = undef ) ?false : obj_init . noFog ; %NWL%this . pointSprite = obj_init . pointSprite||false ; %NWL%this . pointSize = obj_init . pointSize||0 ; %NWL%this . pointCircle = obj_init . pointCircle||0 ; %NWL%9
lib . empty ( this . _domNode )  ; %NWL%BaseEditor . prototype . uninstall . call ( this )  ;%NWL%}%NWL%}  )  ; %NWL%function PluginEditorView ( options )  {%NWL%this . _parent = options . parent ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . pluginRegistry = options . pluginRegistry ; %NWL%this . contentTypeRegistry = options . contentTypeRegistry ; %NWL%this . commandRegistry = options . commandRegistry ; %NWL%this . statusService = options . statusService ; %NWL%6
this . maxSize = json . maxSize ; %NWL%this . sizeTween . fromJSON ( json . sizeTween )  ; %NWL%this . alphaTween . fromJSON ( json . alphaTween )  ; %NWL%this . colorTween . fromJSON ( json . colorTween )  ; %NWL%this . velocity . fromJSON ( json . velocity )  ; %NWL%this . velocitySpread . fromJSON ( json . velocitySpread )  ; %NWL%this . acceleration . fromJSON ( json . acceleration )  ; %NWL%this . accelerationSpread . fromJSON ( json . accelerationSpread )  ; %NWL%this . angularVelocity = json . angularVelocity ; %NWL%this . angularAcceleration = json . angularAcceleration ; %NWL%this . angularVelocitySpread = json . angularVelocitySpread ; %NWL%0
}%NWL%Stimulus . prototype . init = function ( world , opt_options )  {%NWL%Stimulus . _superClass . init . call ( this , world , opt_options )  ; %NWL%var options = opt_options || {  }  ; %NWL%if ( !options . type || typeof options . type ! =  =  ' string '  )  {%NWL%throw new Error (  ' Stimulus requires \ ' type\ ' parameter as a string .  '  )  ;%NWL%}%NWL%this . type = options . type ; %NWL%this . mass = typeof options . mass ! =  =  ' undefined ' ? options . mass : 50 ; %NWL%this . isStatic = typeof options . isStatic ! =  =  ' undefined ' ? options . isStatic : true ; %NWL%this . width = typeof options . width ! =  =  ' undefined ' ? options . width : 50 ; %NWL%8
}  ; %NWL%editCheckbox . onchange = function ( e )  {%NWL%if ( editCheckbox . checked )  {%NWL%startEditing (  )  ;%NWL%}%NWL%else {%NWL%stopEditing (  )  ;%NWL%}%NWL%}  ; %NWL%context . strokeStyle = strokeStyleSelect . value ; %NWL%context . fillStyle = fillStyleSelect . value ; %NWL%9
for ( var property in this )  {%NWL%var tmp = this [ property ]  ; %NWL%if ( this [ property ] ! =  = Class . create )  {%NWL%proto [ property ]  = tmp ;%NWL%}%NWL%}%NWL%newClass . prototype = proto ; %NWL%newClass . _super =  {  }  ;  /  / proto ; %NWL%newClass . define = this . define ; %NWL%newClass . extend = this . extend ; %NWL%newClass . dump = this . dump ; %NWL%8
}  ; %NWL%OIT . prototype . destroy = function (  )  {%NWL%destroyResources ( this )  ; %NWL%if ( defined ( this . _compositeCommand )  )  {%NWL%this . _compositeCommand . shaderProgram = this . _compositeCommand . shaderProgram && this . _compositeCommand . shaderProgram . destroy (  )  ;%NWL%}%NWL%if ( defined ( this . _adjustTranslucentCommand )  )  {%NWL%this . _adjustTranslucentCommand . shaderProgram = this . _adjustTranslucentCommand . shaderProgram && this . _adjustTranslucentCommand . shaderProgram . destroy (  )  ;%NWL%}%NWL%if ( defined ( this . _adjustAlphaCommand )  )  {%NWL%this . _adjustAlphaCommand . shaderProgram = this . _adjustAlphaCommand . shaderProgram && this . _adjustAlphaCommand . shaderProgram . destroy (  )  ; %NWL%4
RESTSync . _NON_ATTRS_CFG =  [  ' root '  ,  ' url '  ]  ; %NWL%RESTSync . prototype =  {%NWL%root :  '  '  ,%NWL%url :  '  '  ,%NWL%initializer : function ( config )  {%NWL%config || ( config =  {  }  )  ; %NWL%if (  ' root ' in config )  {%NWL%this . root = config . root || '  '  ;%NWL%}%NWL%if (  ' url ' in config )  {%NWL%this . url = config . url || '  '  ; %NWL%7
scope :  {%NWL%corners :  ' @ '  ,%NWL%shadow :  ' @ '  ,%NWL%placement :  ' @ '  ,%NWL%animation :  ' @ '  ,%NWL%overlayTheme :  ' @ '%NWL%}  ,%NWL%compile : function ( elm , attr )  {%NWL%attr . animation = isDef ( attr . animation ) ? attr . animation :  ' fade '  ; %NWL%attr . corners = isDef ( attr . corners ) ? attr . corners =  =  =  ' true '  : true ; %NWL%attr . shadow = isDef ( attr . shadow ) ? attr . shadow =  =  =  ' true '  : true ; %NWL%9
}  )  ; %NWL%Object . defineProperty ( Matrix2x2 ,  " Identity "  ,  {%NWL%get : function (  )  {%NWL%return new Matrix2x2 ( 1 , 0 , 0 , 1 )  ;%NWL%}  ,%NWL%enumerable : true ,%NWL%configurable : true%NWL%}  )  ; %NWL%Matrix2x2 . prototype . Apply = function ( action )  {%NWL%this . Values [ 0 ]  [ 0 ]  = action ( this . Values [ 0 ]  [ 0 ]  )  ; %NWL%this . Values [ 0 ]  [ 1 ]  = action ( this . Values [ 0 ]  [ 1 ]  )  ; %NWL%9
nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%nl . lang . value = dom . getAttrib ( n ,  ' lang '  )  ; %NWL%nl . usemap . value = dom . getAttrib ( n ,  ' usemap '  )  ; %NWL%0
this . artificialScrolling = false ; %NWL%this . formatDate = this . options . formatDate || this . formatDate ; %NWL%this . inputValue = null ; %NWL%this . moment = false ; %NWL%this . momentFormat = null ; %NWL%this . parseDate = this . options . parseDate || this . parseDate ; %NWL%this . preventBlurHide = false ; %NWL%this . restricted = this . options . restricted || [  ]  ; %NWL%this . restrictedParsed =  [  ]  ; %NWL%this . restrictedText = this . options . restrictedText ; %NWL%this . sameYearOnly = this . options . sameYearOnly ; %NWL%9
}  ,%NWL%draw : function ( sheet , left , top )  {%NWL%this . prepare ( sheet )  ; %NWL%this . renderTextBox ( sheet , left , top )  ; %NWL%this . renderText ( sheet , left , top )  ;%NWL%}  ,%NWL%renderTextBox : function renderTextBox ( sheet , left , top )  {%NWL%sheet . fillStyle   = this . config . backgroundColor ; %NWL%sheet . strokeStyle  = this . config . lineColor ; %NWL%sheet . lineWidth   = this . config . lineWidth ; %NWL%sheet . useCrispLines  = this . config . useCrispLines ; %NWL%9
then ,%NWL%response =  {  }  ,%NWL%chain ; %NWL%if ( turing . Promise )  {%NWL%promise = new turing . Promise (  )  ;%NWL%}%NWL%function respondToReadyState ( readyState )  {%NWL%if ( request . readyState =  = 4 )  {%NWL%var contentType = request . mimeType || request . getResponseHeader (  ' content - type '  ) || '  '  ; %NWL%response . status = request . status ; %NWL%response . responseText = request . responseText ; %NWL%9
}%NWL%outerElement . show = function (  )  {%NWL%this . style . display =  ' block '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . show = outerElement . show . bind ( outerElement )  ; %NWL%outerElement . hide = function (  )  {%NWL%this . style . display =  ' none '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . hide = outerElement . hide . bind ( outerElement )  ; %NWL%5
ig . gui . elements [ i ]  . disable = true ;%NWL%}%NWL%if ( collection . length )  {%NWL%if ( collection . length =  = 1 ) collection = collection [ 0 ]  ; %NWL%return collection ;%NWL%}%NWL%}  ,%NWL%add : function ( element )  {%NWL%if ( element . show =  = undefined ) element . show = true ; %NWL%if ( element . disabled =  = undefined ) element . disabled = false ; %NWL%if ( element . active =  = undefined ) element . active = false ; %NWL%9
}%NWL%engine . unBindFramebuffer ( this . _texture )  ; %NWL%if ( this . onAfterUnbind )  {%NWL%this . onAfterUnbind (  )  ;%NWL%}%NWL%}  ; %NWL%RenderTargetTexture . prototype . clone = function (  )  {%NWL%var textureSize = this . getSize (  )  ; %NWL%var newTexture = new RenderTargetTexture ( this . name , textureSize . width , this . getScene (  )  , this . _generateMipMaps )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%9
layout =  {  }  ; %NWL%for ( var k in values )  {%NWL%layout [ k ]  = values [ k ]  . calculate ( z , fakeZoomHistory )  ;%NWL%}%NWL%var BucketClass =%NWL%layer . type =  =  =  ' line ' ? LineBucket : %NWL%layer . type =  =  =  ' fill ' ? FillBucket : %NWL%layer . type =  =  =  ' symbol ' ? SymbolBucket : null ; %NWL%var bucket = new BucketClass ( buffers , new LayoutProperties [ layer . type ]  ( layout )  , collision , overscaling , collisionDebug )  ; %NWL%bucket . id = layer . id ; %NWL%bucket . type = layer . type ; %NWL%9
next ( arguments )  ; %NWL%feature ( el )  . handlers =  ( options . handlers || [  ]  )  . map ( function ( factory )  {%NWL%return factory ( el )  ;%NWL%}  )  ; %NWL%feature ( el )  . listeners =  ( options . listeners || [  ]  )  . map ( function ( factory )  {%NWL%return factory ( el )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%builder . wrap (  ' attachedCallback '  , function ( next , el )  {%NWL%if ( !feature ( el )  . handlers )  {%NWL%feature ( el )  . handlers =  ( options . handlers || [  ]  )  . map ( function ( factory )  {%NWL%4
path :  '  /  / SDCARD / Downloads / archivo . mp3 '  ,%NWL%state :  ' downloading '  ,%NWL%contentType :  ' audio / mpeg '  ,%NWL%startTime : new Date (  )  ,%NWL%error : null%NWL%}  ; %NWL%function MockDownload ( params )  {%NWL%params = params || {  }  ; %NWL%this . id = params . id || ' 0 '  ; %NWL%this . totalBytes = params . totalBytes || DEFAULT_PARAMS . totalBytes ; %NWL%this . currentBytes = params . currentBytes || DEFAULT_PARAMS . currentBytes ; %NWL%9
' click #submit - feedback '  :  ' clickSend '  }  ,%NWL%template : _ . template ( $ (  ' #feedback - template '  )  . html (  )  )  ,%NWL%initialize : function ( args , atts )  {%NWL%this . app = atts . app ; %NWL%this . model . on (  ' change : failure '  , this . fail , this )  ; %NWL%this . model . on (  ' success '  , this . success , this )  ;%NWL%}  ,%NWL%render : function (  )  {%NWL%this . $el . html ( this . template ( this . model . toJSON (  )  )  )  ; %NWL%this . subject = this . $el . find (  ' #feedback - subject '  )  ; %NWL%this . message = this . $el . find (  ' #feedback - message '  )  ; %NWL%9
previous : previous ( history . versions , req . params . version )  ,%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%app . post (  "  / versions /  : pageId /  : version / restore "  ,  [ loadPage , loadVersion ]  , function ( req , res )  {%NWL%var page = req . page ; %NWL%var version = req . version ; %NWL%page . title = version . title ; %NWL%page . content = version . content ; %NWL%page . modifiedBy = version . modifiedBy ; %NWL%page . tags = version . tags ; %NWL%7
return false ;%NWL%}  ; %NWL%isHeight = function ( min , max )  {%NWL%return is ( min , max ,  ' height '  )  ;%NWL%}  ; %NWL%options = function ( opts )  {%NWL%if ( typeof ( opts . isResponsive )  =  =  =  ' boolean '  )  {%NWL%_options . isResponsive = opts . isResponsive ;%NWL%}%NWL%if ( typeof ( opts . baseFontSize )  =  =  =  ' number '  )  {%NWL%_options . baseFontSize = opts . baseFontSize ; %NWL%7
_point2CSS :  " left : 25% ; top : 25% ;  "  ,%NWL%_point3CSS :  " left : 75% ; top : 50% ;  "  ,%NWL%_tipCSS :  " height : 32px ; padding - top : 4px ; padding - bottom : 4px ; padding - left : 8px ; padding - right : 8px ; margin - top :  - 20px ; margin - left : 26px ; border - radius : 5px ; position : fixed ; background - color : rgba ( 0 , 0 , 0 , 0 . 7 )  ; color : #FFFFFF ; font : 14px Helvetica , Sans - Serif ;  "  ,%NWL%_arrowCSS :  " height : 0 ; width : 0 ; border : 6px solid ; border - color : transparent rgba ( 0 , 0 , 0 , 0 . 7 ) transparent transparent ; margin - top :  - 6px ; margin - left : 14px ; position : fixed ;  "  ,%NWL%_calibrate1 : function (  )  {%NWL%var pointables = this . _controller . frame (  )  . pointables (  )  ; %NWL%if ( this . _goodFinger )  {%NWL%this . _points [ 0 ]  = this . _goodFinger . tipPosition (  )  ; %NWL%this . _elem . style . cssText = this . _pointCSS + this . _point2CSS ; %NWL%this . _tip . style . cssText = this . _tipCSS + this . _point2CSS ; %NWL%this . _arrow . style . cssText = this . _arrowCSS + this . _point2CSS ; %NWL%9
return triples ;%NWL%}  ; %NWL%AbstractQueryTree . prototype . _bindFilter = function ( filterExpr , bindings )  {%NWL%if ( filterExpr . expressionType ! = null )  {%NWL%var expressionType = filterExpr . expressionType ; %NWL%if ( expressionType =  =  ' relationalexpression '  )  {%NWL%filterExpr . op1 = this . _bindFilter ( filterExpr . op1 , bindings )  ; %NWL%filterExpr . op2 = this . _bindFilter ( filterExpr . op2 , bindings )  ;%NWL%} else if ( expressionType =  =  ' conditionalor ' || expressionType =  =  ' conditionaland '  )  {%NWL%for ( var i = 0 ; i < filterExpr . operands . length ; i +  +  )  {%NWL%filterExpr . operands [ i ]  = this . _bindFilter ( filterExpr . operands [ i ]  , bindings )  ; %NWL%6
this . internalMaster = false ; %NWL%this . connected = false ; %NWL%this . poolSize = this . options . poolSize =  = null ? 5 : this . options . poolSize ; %NWL%this . disableDriverBSONSizeCheck = this . options . disableDriverBSONSizeCheck ! = null ? this . options . disableDriverBSONSizeCheck : false ; %NWL%this . _used = false ; %NWL%this . replicasetInstance = null ; %NWL%this . ssl = this . options . ssl =  = null ? false : this . options . ssl ; %NWL%this . sslValidate = this . options . sslValidate =  = null ? false : this . options . sslValidate ; %NWL%this . sslCA = Array . isArray ( this . options . sslCA ) ? this . options . sslCA : null ; %NWL%this . sslCert = this . options . sslCert ; %NWL%this . sslKey = this . options . sslKey ; %NWL%9
dojo . empty ( actionsWrapper )  ; %NWL%registry . getService (  " orion . page . command "  )  . renderCommands ( this . actionScopeId , actionsWrapper , node . _item , this . explorer ,  " tool "  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%_init : function ( options )  {%NWL%if ( options )  {%NWL%this . _useCheckboxSelection = options . checkbox =  =  = undefined ? false : options . checkbox ; %NWL%this . _colums = options . colums || [  ]  ; %NWL%this . _cachePrefix = options . cachePrefix ; %NWL%this . getCheckedFunc = options . getCheckedFunc ; %NWL%this . onCheckedFunc = options . onCheckedFunc ; %NWL%9
if ( this . root_ . key =  = key )  {%NWL%return ;%NWL%}%NWL%var node = new SplayTree . Node ( key , value )  ; %NWL%if ( key > this . root_ . key )  {%NWL%node . left = this . root_ ; %NWL%node . right = this . root_ . right ; %NWL%this . root_ . right = null ;%NWL%} else {%NWL%node . right = this . root_ ; %NWL%node . left = this . root_ . left ; %NWL%6
function eventListener ( el , fn , evt )  {%NWL%fn ( el , evt )  ;%NWL%}%NWL%var builtInFeature = emptyFn (  )  ; %NWL%builtInFeature . setup = function ( struct , builder )  {%NWL%listValues ( struct . properties )  . filter ( function ( property )  {%NWL%return property . delegate ;%NWL%}  )  . forEach ( function ( property )  {%NWL%if ( !property . attName )  {%NWL%property . set = property . set || emptyFn (  )  ; %NWL%property . get = property . get || emptyFn (  )  ; %NWL%9
var opts = processGrammar ( dict , tokens )  ; %NWL%var source = generateModuleBody ( opts )  ; %NWL%var lexer = eval ( source )  ; %NWL%lexer . yy =  {  }  ; %NWL%if ( input )  {%NWL%lexer . setInput ( input )  ;%NWL%}%NWL%lexer . generate = function (  )  { return generateFromOpts ( opts )  ;  }  ; %NWL%lexer . generateModule = function (  )  { return generateModule ( opts )  ;  }  ; %NWL%lexer . generateCommonJSModule = function (  )  { return generateCommonJSModule ( opts )  ;  }  ; %NWL%lexer . generateAMDModule = function (  )  { return generateAMDModule ( opts )  ;  }  ; %NWL%8
exports . rightFloor = GameWorldModelIso . prototype . rightFloor ; %NWL%exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%exports . getWorldCellFromVisibleCellPos = GameWorldModelIso . prototype . getWorldCellFromVisibleCellPos ; %NWL%exports . getWorldCellDrawDimensions = GameWorldModelIso . prototype . getWorldCellDrawDimensions ; %NWL%exports . getCellCenter = GameWorldModelIso . prototype . getCellCenter ; %NWL%exports . getWorldCellCenter = GameWorldModelIso . prototype . getWorldCellCenter ; %NWL%exports . placeSpriteInWorldCell = GameWorldModelIso . prototype . placeSpriteInWorldCell ; %NWL%exports . placeSpriteInCenterOfWorldCell = GameWorldModelIso . prototype . placeSpriteInCenterOfWorldCell ; %NWL%exports . getCellBoundaries = GameWorldModelIso . prototype . getCellBoundaries ; %NWL%exports . getScreenCoords = GameWorldModelIso . prototype . getScreenCoords ; %NWL%exports . getDrawCoords = GameWorldModelIso . prototype . getDrawCoords ; %NWL%0
}%NWL%if ( prop . status ! =  = null && prop . status ! =  = undefined )  {%NWL%if ( prop . status =  =  = _TENTATIVE_STATUS ||%NWL%prop . status =  =  = _CONFIRMED_STATUS ||%NWL%prop . status =  =  = _CANCELLED_STATUS )  {%NWL%dst . status = prop . status | 0 ;%NWL%} else {%NWL%return false ;%NWL%}%NWL%}%NWL%if ( prop . alarmType ! =  = null && prop . alarmType ! =  = undefined )  {%NWL%1
. getElementById (  " removeOriginsToDestinations "  )  ; %NWL%this . _addOrigin_originField = document%NWL%. getElementById (  " addOrigin - originField "  )  ; %NWL%this . _addDestination_destinationField = document%NWL%. getElementById (  " addDestination - destinationField "  )  ; %NWL%this . _addOriginToDestination_originField = document%NWL%. getElementById (  " addOriginToDestination - originField "  )  ; %NWL%this . _addOriginToDestination_destinationField = document%NWL%. getElementById (  " addOriginToDestination - destinationField "  )  ; %NWL%this . _originsList . removeButton . listbox = this . _originsList ; %NWL%this . _destinationsList . removeButton . listbox = this . _destinationsList ; %NWL%9
return this . findChild ( start )  . range ( start , end )  ;%NWL%}  ; %NWL%InternalNode . prototype . toString = function ( indent )  {%NWL%return this . data . map ( function ( element )  {%NWL%return [ indent +  "  [ key =  "  + element . key ,  " \n "  + indent +  "  LEFT\n "  + element . left . toString ( indent +  "   "  )  ,  " \n "  + indent +  "  RIGHT\n "  + element . right . toString ( indent +  "   "  )  +  " \n "  + indent +  "  ]  "  ]  ;%NWL%}  )  . join (  "  , \n "  )  ;%NWL%}  ; %NWL%var LeafNode = function ( options )  {%NWL%Node . call ( this , options )  ; %NWL%this . data = options . data ; %NWL%this . leftPeer = options . leftPeer ; %NWL%9
e . setXY ( args . points . from )  ;%NWL%}%NWL%break ; %NWL%case ' width '  : %NWL%o . width = args . width . to ; %NWL%break ; %NWL%case ' height '  : %NWL%o . height = args . height . to ; %NWL%break ; %NWL%case ' opacity '  : %NWL%o . opacity = args . opacity . to ; %NWL%4
if ( !surface . frames )  {%NWL%surface . frames =  [  { normals : surface . normals , vertices : surface . vertices }  ]  ;%NWL%}%NWL%console . log (  " Baking vertices and normals .  .  .  "  )  ; %NWL%surface . frames . forEach ( function ( frame )  {%NWL%var bakedFrame =  {  }  ; %NWL%bakedFrame . vertices = new Float32Array ( frame . vertices )  ; %NWL%bakedFrame . vertexBuffer = gl . createBuffer (  )  ; %NWL%gl . bindBuffer ( gl . ARRAY_BUFFER , bakedFrame . vertexBuffer )  ; %NWL%gl . bufferData ( gl . ARRAY_BUFFER , bakedFrame . vertices , gl . STATIC_DRAW )  ; %NWL%bakedFrame . normals = new Float32Array ( frame . normals )  ; %NWL%6
}%NWL%}%NWL%}%NWL%}  ,%NWL%addTargetLayer : function ( layer )  {%NWL%this . addTarget (  { layer : layer }  )  ;%NWL%}  ,%NWL%addTarget : function ( target )  {%NWL%target = OpenLayers . Util . applyDefaults ( target , this . defaults )  ; %NWL%target . nodeTolerance = target . nodeTolerance || target . tolerance ; %NWL%target . vertexTolerance = target . vertexTolerance || target . tolerance ; %NWL%9
if ( uri . isURL ( tex )  )  {%NWL%TMXLayer . superclass . constructor . call ( this ,  { url : tex }  )%NWL%} else {%NWL%TMXLayer . superclass . constructor . call ( this ,  { file : tex }  )%NWL%}%NWL%this . anchorPoint = ccp ( 0 , 0 )%NWL%this . layerName = layerInfo . name%NWL%this . layerSize = layerInfo . layerSize%NWL%this . tiles = layerInfo . tiles%NWL%this . minGID = layerInfo . minGID%NWL%this . maxGID = layerInfo . maxGID%NWL%7
mouseMoveMode =  ' x '  ;%NWL%}  /  / if%NWL%if ( mouseMoveMode =  =  =  ' x '  )  {%NWL%selectedObject . rotation [ 0 ]  = selectedObject . origins . rotation [ 0 ]  + diff [ 0 ]  * rotFactor ; %NWL%selectedObject . rotation [ 1 ]  = selectedObject . origins . rotation [ 1 ]  ; %NWL%selectedObject . rotation [ 2 ]  = selectedObject . origins . rotation [ 2 ]  ;%NWL%}%NWL%else if ( mouseMoveMode =  =  =  ' y '  )  {%NWL%selectedObject . rotation [ 1 ]  = selectedObject . origins . rotation [ 1 ]  + diff [ 1 ]  * rotFactor ; %NWL%selectedObject . rotation [ 0 ]  = selectedObject . origins . rotation [ 0 ]  ; %NWL%selectedObject . rotation [ 2 ]  = selectedObject . origins . rotation [ 2 ]  ; %NWL%4
obj . booleanAdd ( CubicVR . primitives . cone ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " plane "  )  {%NWL%prim . size = meshKit . getFloatNode ( proc ,  " size "  )  ; %NWL%obj . booleanAdd ( CubicVR . primitives . plane ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " cylinder "  )  {%NWL%prim . radius = meshKit . getFloatNode ( proc ,  " radius "  )  ; %NWL%prim . height = meshKit . getFloatNode ( proc ,  " height "  )  ; %NWL%prim . lon = meshKit . getIntNode ( proc ,  " lon "  )  ; %NWL%obj . booleanAdd ( CubicVR . primitives . cylinder ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " torus "  )  {%NWL%prim . innerRadius = meshKit . getFloatNode ( proc ,  " innerRadius "  )  ; %NWL%2
sourceEvent . shiftKey , sourceEvent . metaKey , sourceEvent . button , null )  ;%NWL%}%NWL%else {%NWL%evObj = document . createEventObject (  )  ; %NWL%evObj . screenX = sourceEvent . screenX ; %NWL%evObj . screenY = sourceEvent . screenY ; %NWL%evObj . clientX = sourceEvent . clientX ; %NWL%evObj . clientY = sourceEvent . clientY ; %NWL%evObj . ctrlKey = sourceEvent . ctrlKey ; %NWL%evObj . altKey = sourceEvent . altKey ; %NWL%evObj . shiftKey = sourceEvent . shiftKey ; %NWL%4
drawGrid (  ' lightgray '  , 10 , 10 )  ; %NWL%saveDrawingSurface (  )  ;%NWL%}  ; %NWL%strokeStyleSelect . onchange = function ( e )  {%NWL%context . strokeStyle = strokeStyleSelect . value ;%NWL%}  ; %NWL%fillStyleSelect . onchange = function ( e )  {%NWL%context . fillStyle = fillStyleSelect . value ;%NWL%}  ; %NWL%context . strokeStyle = strokeStyleSelect . value ; %NWL%context . fillStyle = fillStyleSelect . value ; %NWL%4
var div = document . createElement (  ' div '  )  ,%NWL%divStyle = div . style ; %NWL%$ . cssProps . transform =%NWL%divStyle . MozTransform =  =  =  '  ' ? ' MozTransform '  :%NWL%( divStyle . msTransform =  =  =  '  ' ? ' msTransform '  :%NWL%( divStyle . WebkitTransform =  =  =  '  ' ? ' WebkitTransform '  :%NWL%( divStyle . OTransform =  =  =  '  ' ? ' OTransform '  :%NWL%( divStyle . Transform =  =  =  '  ' ? ' Transform '  : %NWL%false )  )  )  )  ; %NWL%$ . cssProps . transformOrigin =%NWL%divStyle . MozTransformOrigin =  =  =  '  ' ? ' MozTransformOrigin '  : %NWL%3
for ( var i = 0 ; i < this . _dataColors . length ; i +  +  )  {%NWL%this . highlightColors . push ( this . highlightColors )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%function preInit ( target , data , options )  {%NWL%options = options || {  }  ; %NWL%options . axesDefaults = options . axesDefaults || {  }  ; %NWL%options . grid = options . grid || {  }  ; %NWL%options . legend = options . legend || {  }  ; %NWL%options . seriesDefaults = options . seriesDefaults || {  }  ; %NWL%7
if ( t . settings [  ' syntax '  ]  )%NWL%t . allready_used_syntax [ t . settings [  ' syntax '  ]  ]  = true ;%NWL%}  ; %NWL%EditArea . prototype . init = function (  )  {%NWL%var t = this , a , s = t . settings ; %NWL%t . textarea			 = _$ (  " textarea "  )  ; %NWL%t . container			 = _$ (  " container "  )  ; %NWL%t . result			 = _$ (  " result "  )  ; %NWL%t . content_highlight	 = _$ (  " content_highlight "  )  ; %NWL%t . selection_field	 = _$ (  " selection_field "  )  ; %NWL%t . selection_field_text = _$ (  " selection_field_text "  )  ; %NWL%5
import . Line ; %NWL%var Rect = exports = Class ( function (  )  {%NWL%this . init = function ( a , b , c , d )  {%NWL%switch ( arguments . length )  {%NWL%case 0 :  /  / init%NWL%this . width = this . height = this . x = this . y = 0 ; %NWL%break ; %NWL%case 1 :  /  / copy%NWL%this . width = a . width ; %NWL%this . height = a . height ; %NWL%this . x = a . x ; %NWL%8
ball . y = bounds . y1 +  ( bounds . y1 - ball . y )  ; %NWL%ballVelocity . y =  - ballVelocity . y * wallBounce ; %NWL%didBounce = true ;%NWL%}%NWL%if ( ball . y > bounds . y2 )  {%NWL%ball . y = bounds . y2 +  - ball . height ; %NWL%ballVelocity . y =  - ballVelocity . y * wallBounce ; %NWL%didBounce = true ;%NWL%}%NWL%if ( ball . x < bounds . x1 )  {%NWL%ball . x = bounds . x1 +  ( bounds . x1 - ball . x )  ; %NWL%0
}  ; %NWL%var UI =  {%NWL%setButtonSelected : function ( button , selected )  {%NWL%if ( !button . hasClass (  ' selected '  )  )  {%NWL%if ( selected ) button . addClass (  ' selected '  )  ;%NWL%}%NWL%else if ( !selected ) button . removeClass (  ' selected '  )  ;%NWL%}  ,%NWL%init : function (  )  {%NWL%this . cachedQueries = $ (  ' #cachedQueries '  )  ; %NWL%this . scheduledQueries = $ (  ' #scheduledQueries '  )  ; %NWL%9
var Query = module . exports = function Query (  )  {%NWL%Node . call ( this )  ; %NWL%this . nodes =  [  ]  ; %NWL%this . type =  '  '  ; %NWL%this . predicate =  '  '  ;%NWL%}  ; %NWL%Query . prototype . __proto__ = Node . prototype ; %NWL%Query . prototype . clone = function ( parent )  {%NWL%var clone = new Query ; %NWL%clone . predicate = this . predicate ; %NWL%clone . type = this . type ; %NWL%9
sdf [ link . target ]  =  {%NWL%node : targetNode ,%NWL%distance : link . distance%NWL%}  ; %NWL%tdf [ link . source ]  =  {%NWL%node : sourceNode ,%NWL%distance : link . distance%NWL%}  ; %NWL%var line = new kity . Path (  )  . stroke (  ' #AAA '  )  ; %NWL%line . source = sourceNode ; %NWL%line . target = targetNode ; %NWL%9
json . index = this . index ; %NWL%json . joyNum = this . joyNum ; %NWL%json . value = this . value ; %NWL%return json ;%NWL%}  ; %NWL%Axis . prototype . fromJSON = function ( json )  {%NWL%this . name = json . name ; %NWL%this . negButton = json . negButton ; %NWL%this . posButton = json . posButton ; %NWL%this . altNegButton = json . altNegButton ; %NWL%this . altPosButton = json . altPosButton ; %NWL%6
}  ; %NWL%exports . cors = function cors ( options )  {%NWL%options = options || {  }  ; %NWL%var whitelist = parseWhitelist ( options . whitelist )  ; %NWL%return function ( req , res , next )  {%NWL%if ( isExempt ( whitelist , req . url )  )%NWL%res . header (  " Access - Control - Allow - Origin "  ,  "  *  "  )  ; %NWL%return next (  )  ;%NWL%}  ;%NWL%}  ; %NWL%exports . noCache = function noCache ( options )  {%NWL%1
this . eventDoneNamingFile = __bind ( this . eventDoneNamingFile , this )  ; %NWL%this . eventCreateDynamic = __bind ( this . eventCreateDynamic , this )  ; %NWL%this . createFile = __bind ( this . createFile , this )  ; %NWL%this . eventCreateTemplate = __bind ( this . eventCreateTemplate , this )  ; %NWL%this . eventCreateCSS = __bind ( this . eventCreateCSS , this )  ; %NWL%this . eventCreateJS = __bind ( this . eventCreateJS , this )  ; %NWL%this . eventCreateHTML = __bind ( this . eventCreateHTML , this )  ; %NWL%this . handleFileDeleted = __bind ( this . handleFileDeleted , this )  ; %NWL%this . handleRouteNameChange = __bind ( this . handleRouteNameChange , this )  ; %NWL%this . handleFileChanged = __bind ( this . handleFileChanged , this )  ; %NWL%this . handleFile = __bind ( this . handleFile , this )  ; %NWL%0
json . _time = this . _time ; %NWL%json . duration = this . duration ; %NWL%json . loop = this . loop ; %NWL%json . playing = this . playing ; %NWL%json . emitting = this . emitting ; %NWL%return json ;%NWL%}  ; %NWL%Emitter2D . prototype . fromJSON = function ( json )  {%NWL%Class . prototype . fromJSON . call ( this , json )  ; %NWL%this . positionType = json . positionType ; %NWL%this . velocityType = json . velocityType ; %NWL%9
while ( i -  -  ) args [ i ]  = arguments [ i ]  ; %NWL%var AT = function ArgumentTrait (  )%NWL%{%NWL%throw Error (  " Cannot re - configure argument trait "  )  ;%NWL%}  ; %NWL%AT . ___$$mixinargs = args ; %NWL%AT . __trait   =  ' arg '  ; %NWL%AT . __acls   = Trait . __acls ; %NWL%AT . __ccls   = Trait . __ccls ; %NWL%AT . toString   = Trait . toString ; %NWL%AT . __mixinImpl  = Trait . __mixinImpl ; %NWL%7
Y . EventFacade = function ( e , currentTarget )  {%NWL%if ( !e )  {%NWL%e = EMPTY ;%NWL%}%NWL%this . _event = e ; %NWL%this . details = e . details ; %NWL%this . type = e . type ; %NWL%this . _type = e . type ; %NWL%this . target = e . target ; %NWL%this . currentTarget = currentTarget ; %NWL%this . relatedTarget = e . relatedTarget ; %NWL%5
this . currentpopup = function (  )  {%NWL%return this . popups [ this . popups . length - 1 ]  ;%NWL%}  ; %NWL%this . popups =  [  ]  ;%NWL%}  ; %NWL%popupManager = new PopupManager (  )  ; %NWL%function Popup ( data )  {%NWL%this . title = data . title ; %NWL%this . subtitle = data . subtitle ; %NWL%this . img = data . img ; %NWL%this . value = data . value ; %NWL%7
}%NWL%}  ,%NWL%init : function ( options )  {%NWL%var _this = this ; %NWL%this . config = _ . extend (  {  }  , this . defaults , options )  ; %NWL%_ . bindAll ( this ,  ' updateArc '  )  ; %NWL%if ( this . config . cx =  =  = null ) this . config . cx = this . config . width / 2 ; %NWL%if ( this . config . cy =  =  = null ) this . config . cy = this . config . height / 2 ; %NWL%this . $el = this . config . $el ; %NWL%this . currentTimer = 0 ; %NWL%this . graphData = this . config . graphData ; %NWL%8
return _apply . call ( o [ name ]  , o , args . concat ( slice ( arguments , 1 )  )  )  ;%NWL%}  ;%NWL%}%NWL%function Descriptor ( type , valueOrGet , readonlyOrSet , hidden , frozen , name , own )  {%NWL%if ( isObject ( type )  )  {%NWL%if (  ' get ' in type || ' set ' in type )  {%NWL%this . type =  ' accessor '  ; %NWL%this . get = type . get ; %NWL%this . set = type . set ;%NWL%} else if (  ' value ' in type )  {%NWL%this . value = type . value ; %NWL%7
this . attrValue =  '  '  ; %NWL%this . indentOf = Infinity ; %NWL%this . indentToken =  '  '  ; %NWL%this . innerMode = null ; %NWL%this . innerState = null ; %NWL%this . innerModeForLine = false ;%NWL%}%NWL%State . prototype . copy = function (  )  {%NWL%var res = new State (  )  ; %NWL%res . javaScriptLine = this . javaScriptLine ; %NWL%res . javaScriptLineExcludesColon = this . javaScriptLineExcludesColon ; %NWL%9
this . columns = this . containerWidth = this . resizeTimer = null ; %NWL%this . activeItemCount = 0 ; %NWL%this . direction =  ' left '  ; %NWL%this . itemHeightsDirty = true ; %NWL%this . placeholders =  [  ]  ; %NWL%$ . extend ( true , this , defaultOptions , options )  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . onResize = __bind ( this . onResize , this )  ; %NWL%this . onRefresh = __bind ( this . onRefresh , this )  ; %NWL%this . getItemWidth = __bind ( this . getItemWidth , this )  ; %NWL%this . layout = __bind ( this . layout , this )  ; %NWL%6
}  (  )  ; %NWL%Ext . onReady ( Docs . init , Docs , true )  ; %NWL%var NavNode = function ( clickEl , collapseEl )  {%NWL%this . clickEl = Ext . get ( clickEl )  ; %NWL%if ( !collapseEl )  {%NWL%collapseEl = this . clickEl . dom . nextSibling ; %NWL%while ( collapseEl . nodeType ! = 1 )  {%NWL%collapseEl = collapseEl . nextSibling ;%NWL%}%NWL%}%NWL%this . collapseEl = Ext . get ( collapseEl )  ; %NWL%3
return stack . reduce ( function ( previous , current )  {%NWL%return current . bind ( el , function next ( args )  {%NWL%return previous . apply ( el , Array . prototype . slice . call ( args )  . slice ( 2 , args . length )  )  ;%NWL%}  , el )  ;%NWL%}  , wrapped . bind ( el , el )  )  . apply ( el , arguments )  ;%NWL%}  ;%NWL%}%NWL%function sanitizeStructure ( struct )  {%NWL%struct . prototype = struct . prototype || Object . create ( HTMLElement . prototype )  ; %NWL%struct . features = struct . features || [  ]  ; %NWL%struct . interceptors = struct . interceptors || [  ]  ; %NWL%9
var C_EVT_SCALE = 7 ; %NWL%var gCancelDefaultAction = false ; %NWL%function canvasMaxizeIt ( canvas , inlineEdit )  {%NWL%var view = cantkGetViewPort (  )  ; %NWL%canvas . style . position =  " absolute "  ; %NWL%canvas . style . top = 0 ; %NWL%canvas . style . left = 0 ; %NWL%canvas . style . zIndex = 0 ; %NWL%if ( inlineEdit || isMobile (  )  )  {%NWL%canvas . width  = view . width ; %NWL%canvas . height = view . height ; %NWL%9
var c = req . connection ; %NWL%var s = new Stream ; %NWL%s . writable = true ; %NWL%s . write = c . write . bind ( c )  ; %NWL%s . end = function ( buf )  {%NWL%if ( buf ! =  = undefined ) s . write ( buf )  ; %NWL%c . end (  )  ; %NWL%close (  )  ;%NWL%}  ; %NWL%s . destroy = c . destroy . bind ( c )  ; %NWL%s . pause = c . pause . bind ( c )  ; %NWL%3
user . recent_topics = recent_topics . map ( function ( topic )  {%NWL%topic . author = _ . pick ( topic . author ,  [  ' loginname '  ,  ' avatar_url '  ]  )  ; %NWL%topic = _ . pick ( topic ,  [  ' id '  ,  ' author '  ,  ' title '  ,  ' last_reply_at '  ]  )  ; %NWL%return topic ;%NWL%}  )  ; %NWL%user . recent_replies = recent_replies . map ( function ( topic )  {%NWL%topic . author = _ . pick ( topic . author ,  [  ' loginname '  ,  ' avatar_url '  ]  )  ; %NWL%topic = _ . pick ( topic ,  [  ' id '  ,  ' author '  ,  ' title '  ,  ' last_reply_at '  ]  )  ; %NWL%return topic ;%NWL%}  )  ; %NWL%user . collect_topics = collect_topics . map ( function ( topic )  {%NWL%0
if ( this . enableSingleNoteSharing ! =  = null && this . enableSingleNoteSharing ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableSingleNoteSharing '  , Thrift . Type . BOOL , 9 )  ; %NWL%output . writeBool ( this . enableSingleNoteSharing )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableSponsoredAccounts ! =  = null && this . enableSponsoredAccounts ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableSponsoredAccounts '  , Thrift . Type . BOOL , 10 )  ; %NWL%output . writeBool ( this . enableSponsoredAccounts )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableTwitterSharing ! =  = null && this . enableTwitterSharing ! =  = undefined )  {%NWL%0
this . m_vehicle . updateWheelTransform ( i , true )  ; %NWL%var wtrans = this . m_vehicle . getWheelTransformWS ( i )  ;  /  /  . getOpenGLMatrix ( this . wheels [ i ]  . wheelObj . tMatrix )  ; %NWL%var origin = wtrans . getOrigin (  )  ; %NWL%this . wheels [ i ]  . wheelObj . position [ 0 ]  = origin . x (  )  ; %NWL%this . wheels [ i ]  . wheelObj . position [ 1 ]  = origin . y (  )  ; %NWL%this . wheels [ i ]  . wheelObj . position [ 2 ]  = origin . z (  )  ; %NWL%var quat_rotation = wtrans . getRotation (  )  ; %NWL%uquat . x = quat_rotation . x (  )  ; %NWL%uquat . y = quat_rotation . y (  )  ; %NWL%uquat . z = quat_rotation . z (  )  ; %NWL%uquat . w = quat_rotation . w (  )  ; %NWL%7
var ProjectHelper = require (  '  .  .  / lib / project - helper '  )  ; %NWL%var ComponentHelper = require (  '  .  .  / lib / component - helper '  )  ; %NWL%var componentTypes = require (  '  .  .  / lib / component - types '  )  ; %NWL%var questions = require (  '  .  .  / lib / common - questions '  )  ; %NWL%var PageGenerator = yeoman . generators . Base . extend (  {%NWL%init : function ( arg )  {%NWL%this . project = new ProjectHelper (  )  ; %NWL%this . gitConfig = GetGitInfo . getConfig (  )  ; %NWL%if ( this . project . config )  {%NWL%this . name = this . project . config . name ; %NWL%this . email = this . project . config . email ; %NWL%9
this . accumulator . setFillStyle (  " rgb ( 0 , 0 , 0 )  "  )  ; %NWL%this . accumulator . drawFilledRectangle ( renderContext . getViewport (  )  )  ; %NWL%this . accumulator . get2DContext (  )  . globalCompositeOperation =  " source - over "  ;%NWL%} else {%NWL%var vp = R . math . Rectangle2D . create ( renderContext . getViewport (  )  )  ,%NWL%ox = vp . x , oy = vp . y ; %NWL%this . accumulator . get2DContext (  )  . globalAlpha = 0 . 5 ; %NWL%for ( var y =  - this . radius ; y <  = this . radius ; y +  +  )  {%NWL%for ( var x =  - this . radius ; x <  = this . radius ; x +  +  )  {%NWL%vp . y = oy + y ; %NWL%vp . x = ox + x ; %NWL%9
}  ; %NWL%this . getResultStartClause = function getResultStartClause (  )  {%NWL%return " start =  "  + this . StartRow ;%NWL%}  ; %NWL%this . setResultStartRow = function setResultStartRow ( start )  {%NWL%this . StartRow = start ;%NWL%}  ; %NWL%this . getResultStartRow = function getResultStartRow (  )  {%NWL%return this . StartRow ;%NWL%}  ; %NWL%this . getResultCountClause = function getResultCountClause (  )  {%NWL%1
"  .  .  / DefaultPropertiesMixin "%NWL%]  ,%NWL%function ( lang , declare , Color , utils , RectangularGauge , LinearScaler , RectangularScale , RectangularValueIndicator , DefaultPropertiesMixin )  {%NWL%return declare (  " dojox . dgauges . components . green . VerticalLinearGauge "  ,  [ RectangularGauge , DefaultPropertiesMixin ]  ,  {%NWL%borderColor :  [ 50 , 50 , 50 ]  ,%NWL%fillColor :  [ 109 , 183 , 19 ]  ,%NWL%indicatorColor :  [ 0 , 0 , 0 ]  ,%NWL%constructor : function (  )  {%NWL%this . orientation =  " vertical "  ; %NWL%this . borderColor = new Color ( this . borderColor )  ; %NWL%this . fillColor = new Color ( this . fillColor )  ; %NWL%9
this . patternMatcher = patternMatcher ( this . opts . patterns )  ; %NWL%var newPattern = this . patternMatcher . getPattern ( this . val )  ; %NWL%this . mLength  = newPattern . mLength ; %NWL%this . chars  = newPattern . chars ; %NWL%this . inpts  = newPattern . inpts ; %NWL%this . _processKey (  '  '  , false , true )  ;%NWL%}  ; %NWL%Formatter . prototype . _updatePattern = function (  )  {%NWL%var newPattern = this . patternMatcher . getPattern ( this . val )  ; %NWL%if ( newPattern )  {%NWL%this . mLength = newPattern . mLength ; %NWL%3
var mkdirp = require (  ' mkdirp '  )  ; %NWL%module . exports = CoreObject . extend (  {%NWL%init : function ( inputTree , options )  {%NWL%if ( !options )  {%NWL%options =  {  }  ;%NWL%}%NWL%this . inputTree = inputTree ; %NWL%this . root = options . root ; %NWL%this . inFile = options . inFile || ' browserify_stubs . js '  ; %NWL%this . browserifyOptions = options . browserifyOptions ; %NWL%this . enableSourcemap = options . enableSourcemap ; %NWL%7
history . pushState ( null , null , str )  ;%NWL%}%NWL%function setGeoSelection (  )  {%NWL%GEO . radius = radiusValueNode . value || 10 ; %NWL%GEO . units = radiusUnitsNode . value || " km "  ; %NWL%GEO . meters = GEO . radius *  (  ( GEO . units =  =  =  " mi "  ) ? 1609 . 34 : 1000 )  ; %NWL%GEO . miles = GEO . meters / 1609 . 34 ; %NWL%GEO . center [ 0 ]  = map . getCenter (  )  . lat ; %NWL%GEO . center [ 1 ]  = map . getCenter (  )  . lng ; %NWL%GEO . lat = latNode . value ; %NWL%GEO . lng = lngNode . value ; %NWL%9
canvas . replace = wrap ( replace )  ; %NWL%canvas . contents = wrap ( contents )  ; %NWL%canvas . getPixelArray = wrap ( getPixelArray )  ; %NWL%canvas . toDataURL = wrap ( toDataURL )  ; %NWL%canvas . brightnessContrast = wrap ( brightnessContrast )  ; %NWL%canvas . hexagonalPixelate = wrap ( hexagonalPixelate )  ; %NWL%canvas . hueSaturation = wrap ( hueSaturation )  ; %NWL%canvas . colorHalftone = wrap ( colorHalftone )  ; %NWL%canvas . triangleBlur = wrap ( triangleBlur )  ; %NWL%canvas . unsharpMask = wrap ( unsharpMask )  ; %NWL%canvas . perspective = wrap ( perspective )  ; %NWL%0
this . forEach ( function ( item )  {%NWL%offset = item . writeBuffer ( buffer , offset )  ;%NWL%}  )  ; %NWL%return offset ;%NWL%}%NWL%Array . prototype . byteLength = function (  )  {%NWL%return this . reduce ( function ( p , c )  { return p + c . length }  , 0 )  ;%NWL%}%NWL%function Format ( depth , bpp , scanline_pad )  {%NWL%this . depth = depth || 0 ; %NWL%this . bpp = bpp || 0 ; %NWL%9
this . eventDropFiles = __bind ( this . eventDropFiles , this )  ; %NWL%this . eventUploadFiles = __bind ( this . eventUploadFiles , this )  ; %NWL%this . preventDefault = __bind ( this . preventDefault , this )  ; %NWL%this . eventSaveChanges = __bind ( this . eventSaveChanges , this )  ; %NWL%this . eventKeyDown = __bind ( this . eventKeyDown , this )  ; %NWL%this . clearAll = __bind ( this . clearAll , this )  ; %NWL%this . eventDeleteFileConfirmed = __bind ( this . eventDeleteFileConfirmed , this )  ; %NWL%this . eventRenameFile = __bind ( this . eventRenameFile , this )  ; %NWL%this . eventDeleteClicked = __bind ( this . eventDeleteClicked , this )  ; %NWL%this . eventMouseLeaveFile = __bind ( this . eventMouseLeaveFile , this )  ; %NWL%this . eventMouseEnterFile = __bind ( this . eventMouseEnterFile , this )  ; %NWL%0
var len = row [ k ]  . toString (  )  . length ; %NWL%return len > max ? len : max ;%NWL%}  , 0 )  ; %NWL%stat . numNulls = data . reduce ( function ( count , row )  {%NWL%return row [ k ]  =  =  = null ? count + 1 : count ;%NWL%}  , 0 )  ; %NWL%var numbers = util . numbers ( column )  ; %NWL%if ( numbers . length > 0 )  {%NWL%stat . skew = util . skew ( numbers )  ; %NWL%stat . stdev = util . stdev ( numbers )  ; %NWL%stat . mean = util . mean ( numbers )  ; %NWL%8
writeHeaderToLog ( SECTION +  " The equals operator (  =  =  )  "  )  ; %NWL%new TestCase ( SECTION ,   " void 0 = void 0 "  ,   true ,  void 0 =  = void 0 )  ; %NWL%new TestCase ( SECTION ,   " null =  = null "  ,    true ,  null =  = null )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = NaN "  ,    false ,  Number . NaN =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = 0 "  ,     false ,  Number . NaN =  = 0 )  ; %NWL%new TestCase ( SECTION ,   " 0 =  = NaN "  ,     false ,  0 =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = Infinity "  ,   false ,  Number . NaN =  = Number . POSITIVE_INFINITY )  ; %NWL%new TestCase ( SECTION ,   " Infinity =  = NaN "  ,   false ,  Number . POSITIVE_INFINITY =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " Number . MAX_VALUE =  = Number . MAX_VALUE "  ,  true ,  Number . MAX_VALUE =  = Number . MAX_VALUE )  ; %NWL%new TestCase ( SECTION ,   " Number . MIN_VALUE =  = Number . MIN_VALUE "  ,  true ,  Number . MIN_VALUE =  = Number . MIN_VALUE )  ; %NWL%new TestCase ( SECTION ,   " Number . POSITIVE_INFINITY =  = Number . POSITIVE_INFINITY "  ,  true ,  Number . POSITIVE_INFINITY =  = Number . POSITIVE_INFINITY )  ; %NWL%8
module :  '  '  ,%NWL%method :  '  '  ,%NWL%events :  '  '  ,%NWL%args :  '  '%NWL%}%NWL%this . jobName = options . jobName ; %NWL%this . fn = options . fn ; %NWL%this . enabled = options . enabled ; %NWL%this . module = options . module ; %NWL%this . method = options . method ; %NWL%this . args = options . args ; %NWL%5
}  )  ;%NWL%}  ; %NWL%SlotMachine . onAppend = function onAppend (  )%NWL%{%NWL%_type  = 0 ; %NWL%_start = Renderer . tick ; %NWL%if ( _sprite && _action )  {%NWL%Renderer . render ( rendering )  ;%NWL%}%NWL%}  ; %NWL%SlotMachine . onRemove = function onRemove (  )%NWL%2
}%NWL%if ( options . matchBase && - 1 =  =  = pattern . indexOf (  "  /  "  )  )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%7
}%NWL%return false ;%NWL%}%NWL%}%NWL%base . GLCore = GLCore ; %NWL%base . setFullScreen = setFullScreen ; %NWL%base . init = initCubicVR ; %NWL%base . start = startUp ; %NWL%base . addResizeable = GLCore . addResizeable ; %NWL%base . setFixedAspect = GLCore . setFixedAspect ; %NWL%base . setFixedSize = GLCore . setFixedSize ; %NWL%8
labelMod : 1 ,%NWL%legendHorizontal : true ,%NWL%constructor : function ( node , args )  {%NWL%dojo . mixin ( this , args )  ; %NWL%this . domNode = dojo . byId ( node )  ; %NWL%this [ this . type +  " Node "  ]  = this . domNode ; %NWL%if ( typeof this . theme =  =  ' string '  )  {%NWL%this . theme = dojo . getObject ( this . theme )  ;%NWL%}%NWL%this . chartNode = dojo . byId ( this . chartNode )  ; %NWL%this . legendNode = dojo . byId ( this . legendNode )  ; %NWL%9
source . directories . shift (  )  ;%NWL%}%NWL%while ( source . directories . length )  {%NWL%source . directories . shift (  )  ; %NWL%target . directories . unshift (  '  .  .  '  )  ;%NWL%}%NWL%if ( !target . root && !target . directories . length && !target . file && source . file )%NWL%target . directories . push (  '  .  '  )  ; %NWL%if ( source . file =  = target . file )%NWL%delete target . file ; %NWL%if ( source . query =  = target . query )%NWL%8
var readyCb =  [  ]  ; %NWL%var self =  {  }  ; %NWL%var config = require (  ' config '  )  ; %NWL%require (  ' stack . io '  )  . io (  { host : config . host , timeout : 15 }  , function ( err , io )  {%NWL%config . ready ( function ( config )  {%NWL%self . auth = require (  ' auth '  )  ( config , io )  ; %NWL%if ( config . modules . DB_ENABLED )  {%NWL%self . db = require (  ' db '  )  ( config , io )  ;%NWL%}%NWL%if ( config . modules . SYNC_ENABLED )  {%NWL%self . sync = require (  ' sync '  )  ( config , io )  ; %NWL%5
page : this . page ,%NWL%endingCell : this . endingCell ,%NWL%lastColumnWidth : this . lastColumnWidth%NWL%}  )  ;%NWL%}  ; %NWL%DocumentContext . prototype . endDetachedBlock = function (  )  {%NWL%var saved = this . snapshots . pop (  )  ; %NWL%this . x = saved . x ; %NWL%this . y = saved . y ; %NWL%this . availableWidth = saved . availableWidth ; %NWL%this . availableHeight = saved . availableHeight ; %NWL%7
var __bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ,%NWL%__slice =  [  ]  . slice ; %NWL%Todo . ItemView =  ( function ( _super )  {%NWL%__extends ( ItemView , _super )  ; %NWL%function ItemView (  )  {%NWL%this . save = __bind ( this . save , this )  ; %NWL%this . load = __bind ( this . load , this )  ; %NWL%this . isDirty = __bind ( this . isDirty , this )  ; %NWL%this . checkKey = __bind ( this . checkKey , this )  ; %NWL%7
setImmediate ( function (  )  {%NWL%$scope . $apply ( function (  )  {%NWL%$scope . mode =  ' error '  ; %NWL%$scope . loading = false ; %NWL%$scope . editing = false ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%function setEngineStatus ( res , accepted )  {%NWL%$scope . engine_result = res . engine_result ; %NWL%$scope . engine_result_message = res . engine_result_message ; %NWL%9
setText : function ( t )  {%NWL%if ( this . rendered )  {%NWL%this . el . update ( t )  ;%NWL%} else {%NWL%this . text = t ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%Ext . reg (  ' tbtext '  , T . TextItem )  ; %NWL%T . Button = Ext . extend ( Ext . Button ,  {  }  )  ; %NWL%T . SplitButton = Ext . extend ( Ext . SplitButton ,  {  }  )  ; %NWL%9
air . EventDispatcher = window . runtime . flash . events . EventDispatcher ; %NWL%air . FileListEvent = window . runtime . flash . events . FileListEvent ; %NWL%air . HTTPStatusEvent = window . runtime . flash . events . HTTPStatusEvent ; %NWL%air . IOErrorEvent = window . runtime . flash . events . IOErrorEvent ; %NWL%air . InvokeEvent = window . runtime . flash . events . InvokeEvent ; %NWL%air . NetStatusEvent = window . runtime . flash . events . NetStatusEvent ; %NWL%air . OutputProgressEvent = window . runtime . flash . events . OutputProgressEvent ; %NWL%air . ProgressEvent = window . runtime . flash . events . ProgressEvent ; %NWL%air . SecurityErrorEvent = window . runtime . flash . events . SecurityErrorEvent ; %NWL%air . StatusEvent = window . runtime . flash . events . StatusEvent ; %NWL%air . TimerEvent = window . runtime . flash . events . TimerEvent ; %NWL%0
}%NWL%}%NWL%}%NWL%function ensurePrimaryKeyColumn ( model )  {%NWL%if ( model . getIdColumn (  )  )  {%NWL%return ;%NWL%}%NWL%var coldef = model . columns [  ' id '  ] || {  }  ; %NWL%coldef . type = coldef . type || " integer "  ; %NWL%coldef . primaryKey = coldef . primaryKey || true ; %NWL%coldef . autoIncrement = coldef . autoIncrement || true ; %NWL%9
e . offsetX : e . layerX ; %NWL%this . offsetY =  ( goog . userAgent . WEBKIT || e . offsetY ! =  = undefined ) ?%NWL%e . offsetY : e . layerY ; %NWL%this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ; %NWL%this . button = e . button ; %NWL%this . keyCode = e . keyCode || 0 ; %NWL%this . charCode = e . charCode || ( type =  =  ' keypress ' ? e . keyCode : 0 )  ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%7
this . eventPool_ . releaseObject (  ( startEvent )  )  ; %NWL%break ;%NWL%}%NWL%}%NWL%} else {%NWL%stopEvent =  (%NWL%this . eventPool_ . getObject (  )  )  ; %NWL%stopEvent . eventType = goog . debug . Trace_ . EventType . STOP ; %NWL%stopEvent . startTime = startEvent . startTime ; %NWL%stopEvent . comment = startEvent . comment ; %NWL%stopEvent . type = startEvent . type ; %NWL%8
this . monitoringXHREnabled = this . createSetting (  " monitoringXHREnabled "  , false )  ; %NWL%this . preserveConsoleLog = this . createSetting (  " preserveConsoleLog "  , false )  ; %NWL%this . resourcesLargeRows = this . createSetting (  " resourcesLargeRows "  , true )  ; %NWL%this . resourcesSortOptions = this . createSetting (  " resourcesSortOptions "  ,  { timeOption :  " responseTime "  , sizeOption :  " transferSize "  }  )  ; %NWL%this . resourceViewTab = this . createSetting (  " resourceViewTab "  ,  " preview "  )  ; %NWL%this . showInheritedComputedStyleProperties = this . createSetting (  " showInheritedComputedStyleProperties "  , false )  ; %NWL%this . showUserAgentStyles = this . createSetting (  " showUserAgentStyles "  , true )  ; %NWL%this . watchExpressions = this . createSetting (  " watchExpressions "  ,  [  ]  )  ; %NWL%this . breakpoints = this . createSetting (  " breakpoints "  ,  [  ]  )  ; %NWL%this . eventListenerBreakpoints = this . createSetting (  " eventListenerBreakpoints "  ,  [  ]  )  ; %NWL%this . domBreakpoints = this . createSetting (  " domBreakpoints "  ,  [  ]  )  ; %NWL%7
var call , msg , _i , _len , _ref , _results ; %NWL%this . setName ( d . name )  ; %NWL%this . setState ( d . state )  ; %NWL%this . setStatus ( d . status )  ; %NWL%this . setUsername ( d . username )  ; %NWL%this . setExtension ( d . extension )  ; %NWL%this . busy_delay_time = d . busy_delay_time ; %NWL%this . class_answered = d . class_answered ; %NWL%this . contact = d . contact ; %NWL%this . last_call_time = new Date ( Date . parse ( d . last_call_time )  )  ; %NWL%this . last_bridge_end = new Date ( Date . parse ( d . last_bridge_end )  )  ; %NWL%9
templ = new enyo . g11n . Template ( this . rb . $L (  { key :  " dateRangeConsecutiveDays "  , value :  " # { startDate } # { startTime }  - # { endDate } # { endTime }  "  }  )  )  ; %NWL%return templ . evaluate (  {%NWL%startTime : this . _format ( dateStart , timeFmt )  ,%NWL%endTime : this . _format ( dateEnd , timeFmt )  ,%NWL%startDate : this . _format ( dateStart , dateFmt )  ,%NWL%endDate : this . _format ( dateEnd , dateFmt )%NWL%}  )  ;%NWL%} else if ( dateStart . getYear (  )  =  =  = dateEnd . getYear (  )  )  {%NWL%year =  ( formatLength =  =  =  ' short ' || formatLength =  =  =  ' single '  ) ? ( dateStart . getFullYear (  )  +  "  "  )  . substring ( 2 )  : dateStart . getFullYear (  )  ; %NWL%if ( dateStart . getMonth (  )  =  =  = dateEnd . getMonth (  )  )  {%NWL%if ( dateStart . getDate (  )  =  =  = dateEnd . getDate (  )  )  {%NWL%9
element . dispatchEvent ( event )  ;%NWL%}%NWL%}  , array [ 0 ]  , array [ 1 ]  )  ;%NWL%}  ; %NWL%this . doubleclick = function doubleclick (  )  {%NWL%processEvent (  ' doubleclick '  , arguments )  ;%NWL%}  ; %NWL%this . down = function down (  )  {%NWL%processEvent (  ' mousedown '  , arguments )  ;%NWL%}  ; %NWL%this . move = function move (  )  {%NWL%4
}%NWL%if ( typeof ( Flog )  =  =  ' undefined '  ) var Flog =  {  }  ; %NWL%if ( typeof ( Flog . RayTracer )  =  =  ' undefined '  ) Flog . RayTracer =  {  }  ; %NWL%Flog . RayTracer . Vector = Class . create (  )  ; %NWL%Flog . RayTracer . Vector . prototype =  {%NWL%x : 0 . 0 ,%NWL%y : 0 . 0 ,%NWL%z : 0 . 0 ,%NWL%initialize : function ( x , y , z )  {%NWL%this . x =  ( x ? x : 0 )  ; %NWL%this . y =  ( y ? y : 0 )  ; %NWL%9
this . _displacement [ 0 ]  +  = diffX ; %NWL%this . _displacement [ 1 ]  +  = diffY ;%NWL%}%NWL%var payload = this . _payload ; %NWL%payload . delta  = nextDelta ; %NWL%payload . position = this . _position ; %NWL%payload . velocity = nextVel ; %NWL%payload . clientX  = x ; %NWL%payload . clientY  = y ; %NWL%payload . offsetX  = event . offsetX ; %NWL%payload . offsetY  = event . offsetY ; %NWL%9
function JsTrack ( opt )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . _intervalScripts =  [  ]  ; %NWL%this . _momentScripts =  [  ]  ; %NWL%this . _baseH = 21 ; %NWL%this . _isShowingIntervalScrips = false ; %NWL%this . _isHidingSelectedElems = false ; %NWL%this . _isPlaying = false ; %NWL%this . _onSelectClick = this . _onSelectClick . bind ( this )  ; %NWL%this . _onChangeTime = this . _onChangeTime . bind ( this )  ; %NWL%this . _onChangeIntervalScript = this . _onChangeIntervalScript . bind ( this )  ; %NWL%8
addContactInfo : function ( positionX , positionY , positionZ , normalX , normalY , normalZ , overlap , shape1 , shape2 , data1 , data2 , flip )  {%NWL%if ( this . numContactInfos =  = this . maxContactInfos ) return ; %NWL%if ( !this . contactInfos [ this . numContactInfos ]  )  {%NWL%this . contactInfos [ this . numContactInfos ]  = new OIMO . ContactInfo (  )  ;%NWL%}%NWL%var c = this . contactInfos [ this . numContactInfos +  +  ]  ; %NWL%c . position . x = positionX ; %NWL%c . position . y = positionY ; %NWL%c . position . z = positionZ ; %NWL%c . normal . x = normalX ; %NWL%c . normal . y = normalY ; %NWL%7
}%NWL%if ( typeof value . y =  =  =  ' number '  )  {%NWL%tmp . top = value . y ;%NWL%}%NWL%if ( typeof value . width =  =  =  ' number '  )  {%NWL%tmp . width =  ( value . width -  ( item . outerWidth ( true )  - item . width (  )  )  )  ; %NWL%tmp . width =  ( tmp . width >  = 0 ) ? tmp . width : 0 ;%NWL%}%NWL%if ( typeof value . height =  =  =  ' number '  )  {%NWL%tmp . height = value . height -  ( item . outerHeight ( true )  - item . height (  )  )  ; %NWL%tmp . height =  ( tmp . height >  = 0 ) ? tmp . height : 0 ; %NWL%6
axis . fill ( 0 . 0 , 1 . 0 , 0 . 0 )  ; %NWL%axis . cross ( vec1 )  ;%NWL%}%NWL%axis . normalize (  )  ; %NWL%quaternion . rotationAxis ( axis , Math . PI )  ;%NWL%}%NWL%} else {%NWL%var s = Math . sqrt (  ( 1 + a )  * 2 )  , invs = 1 / s ; %NWL%v1 . cross ( v2 )  ; %NWL%quaternion . x = v1 . x * invs ; %NWL%quaternion . y = v1 . y * invs ; %NWL%9
function SystemCtrl ( $scope , $element , $location , $http )  {%NWL%var promise = null ; %NWL%$scope . onRefresh = function (  )  {%NWL%if ( promise )  {%NWL%return ;%NWL%}%NWL%promise = $http . get (  " ws / app / sysinfo "  )  . then ( function ( res )  {%NWL%var info = res . data ; %NWL%_ . each ( info . users , function ( item )  {%NWL%item . loginTime = moment ( item . loginTime )  . format (  ' L LT '  )  ; %NWL%item . accessTime = moment ( item . accessTime )  . format (  ' L LT '  )  ; %NWL%9
}%NWL%if ( trackingList )  {%NWL%tracking = trackingList [ file . id ]  ;%NWL%}%NWL%if ( tracking )  {%NWL%file . currentSpeed = tracking . currentSpeed ; %NWL%file . averageSpeed = tracking . averageSpeed ; %NWL%file . movingAverageSpeed = tracking . movingAverageSpeed ; %NWL%file . timeRemaining = tracking . timeRemaining ; %NWL%file . timeElapsed = tracking . timeElapsed ; %NWL%file . percentUploaded = tracking . percentUploaded ; %NWL%5
if ( self . label =  =  = label )%NWL%return false ; %NWL%self . label = label ; %NWL%return true ;%NWL%}%NWL%self . update = function update ( item )  {%NWL%self . address = item . address || key ; %NWL%json_label = item . label ; %NWL%self . color = item . color ; %NWL%self . avatar = item . avatar || " images / server - small . png "  ; %NWL%self . visible = item . visible ; %NWL%8
this . seqEach ( function ( x , i )  {%NWL%var self = this ; %NWL%var next = function (  )  {%NWL%res [ i ]  = arguments [ 1 ]  ; %NWL%if ( i =  =  = lastIdx )%NWL%context . stack = res ; %NWL%self . apply ( self , arguments )  ;%NWL%}  ; %NWL%next . stack = self . stack ; %NWL%next . stack_ = self . stack_ ; %NWL%next . vars = self . vars ; %NWL%8
this . width = other . width ; %NWL%this . height = other . height ; %NWL%this . invWidth = other . invWidth ; %NWL%this . invHeight = other . invHeight ; %NWL%this . generateMipmap = other . generateMipmap ; %NWL%this . flipY = other . flipY ; %NWL%this . premultiplyAlpha = other . premultiplyAlpha ; %NWL%this . anisotropy = other . anisotropy ; %NWL%this . filter = other . filter ; %NWL%this . format = other . format ; %NWL%this . wrap = other . wrap ; %NWL%0
var result =  {%NWL%settings :  {  }%NWL%}  ; %NWL%var settingsModule = require (  '  .  .  / settings '  )  ; %NWL%for ( var flagName in settingsModule . AccountSetIntFlags )  {%NWL%var flag = settingsModule . AccountSetIntFlags [ flagName ]  ; %NWL%result . settings [ flag . name ]  = settings [ flag . name ]  ;%NWL%}%NWL%for ( var fieldName in settingsModule . AccountRootFields )  {%NWL%var field = settingsModule . AccountRootFields [ fieldName ]  ; %NWL%result . settings [ field . name ]  = settings [ field . name ]  ; %NWL%6
this . createFieldFromSchema ( JSONUpdate )  ; %NWL%this . createFieldsets ( JSONUpdate )  ; %NWL%this . formChannel . trigger (  ' updateFinished '  )  ;%NWL%}  ,%NWL%updateCollectionAttributes : function ( JSONUpdate )  {%NWL%this . name    = JSONUpdate [  " name "  ]  ; %NWL%this . descriptionFr = JSONUpdate [  " descriptionFr "  ]  ; %NWL%this . descriptionEn = JSONUpdate [  " descriptionEn "  ]  ; %NWL%this . keywordsFr  = JSONUpdate [  " keywordsFr "  ]  ; %NWL%this . keywordsEn  = JSONUpdate [  " keywordsEn "  ]  ; %NWL%this . labelFr   = JSONUpdate [  " labelFr "  ]  ; %NWL%5
t . showMark = false ;%NWL%}%NWL%t . setTick ( tt , this . name )  ; %NWL%this . _ticks . push ( t )  ;%NWL%}%NWL%}%NWL%else if ( this . tickDistribution =  =  ' power '  )  {%NWL%rmin = Math . pow ( this . base , Math . ceil ( Math . log ( min *  ( 2 - this . padMin )  )  / Math . log ( this . base )  )  - 1 )  ; %NWL%rmax = Math . pow ( this . base , Math . floor ( Math . log ( max * this . padMax )  / Math . log ( this . base )  )  + 1 )  ; %NWL%this . min = rmin ; %NWL%this . max = rmax ; %NWL%9
var processAccessRequests = function ( processor , securityContext , accessRequests )  {%NWL%var filteredRequests =  [  ]  ; %NWL%for ( var i in accessRequests )  {%NWL%var accessRequest = accessReauests [ i ]  ; %NWL%if ( securityContext )  {%NWL%var access = new NetworkAccess ( securityContext , accessRequest )  ; %NWL%access . getAccess (  )  ; %NWL%if ( access . xhrEffect =  = SecurityContext . EFFECT_DENY && access . domEffect =  = SecurityContext . EFFECT_DENY )%NWL%continue ; %NWL%accessRequest . xhrEffect = access . xhrEffect ; %NWL%accessRequest . domEffect = access . domEffect ; %NWL%9
context = context || document ; %NWL%if ( !seed && context . nodeType =  =  = 9 )  {%NWL%try {%NWL%return makeArray ( context . querySelectorAll ( query )  , extra )  ;%NWL%} catch ( e )  {  }%NWL%}%NWL%return oldSizzle ( query , context , extra , seed )  ;%NWL%}  ; %NWL%Sizzle . find = oldSizzle . find ; %NWL%Sizzle . filter = oldSizzle . filter ; %NWL%Sizzle . selectors = oldSizzle . selectors ; %NWL%8
if ( typeof ( protocolFullCase )  =  =  =  ' undefined '  )  {%NWL%protocolFullCase = acceptedProtocol ;%NWL%}%NWL%}%NWL%else {%NWL%protocolFullCase = acceptedProtocol ;%NWL%}%NWL%this . protocolFullCaseMap = null ; %NWL%var connection = new WebSocketConnection ( this . socket ,  [  ]  , acceptedProtocol , false , this . serverConfig )  ; %NWL%connection . webSocketVersion = this . webSocketVersion ; %NWL%connection . remoteAddress = this . remoteAddress ; %NWL%9
this . width = Math . max ( this . width , this . frames [ block . frame ]  . x + block . w )  ; %NWL%this . height = Math . max ( this . height , this . frames [ block . frame ]  . y + block . h )  ;%NWL%} else {%NWL%this . frames [ block . frame ]  = null ;%NWL%}%NWL%}%NWL%this . width +  = 2 * this . options . padding . border - this . options . padding . shape ; %NWL%this . height +  = 2 * this . options . padding . border - this . options . padding . shape ; %NWL%if ( this . options . powerOfTwo )  {%NWL%this . width = this . powerOfTwo ( this . width ) || 2 ; %NWL%this . height = this . powerOfTwo ( this . height ) || 2 ; %NWL%9
strings = new Strings (  ' en '  )  ,%NWL%createError = require (  '  .  .  / utils / error '  )  ,%NWL%logger = require (  '  .  .  / utils / logger '  )  ,%NWL%mongoose = require (  ' mongoose '  )  ,%NWL%url =  config . db . host ,%NWL%options =  {%NWL%user : config . db . username ,%NWL%pass : config . db . password%NWL%}  ; %NWL%db . tokens = require (  '  .  / mongodb / tokens '  )  ; %NWL%db . users = require (  '  .  / mongodb / users '  )  ; %NWL%9
this . _hookConstructor = __bind ( this . _hookConstructor , this )  ; %NWL%this . _hookPrototype = __bind ( this . _hookPrototype , this )  ; %NWL%this . _hookMethod = __bind ( this . _hookMethod , this )  ; %NWL%this . _onSync = __bind ( this . _onSync , this )  ; %NWL%this . _onEvent = __bind ( this . _onEvent , this )  ; %NWL%this . _onViewBinding = __bind ( this . _onViewBinding , this )  ; %NWL%this . _onNewInstance = __bind ( this . _onNewInstance , this )  ; %NWL%this . _trackViewBinding = __bind ( this . _trackViewBinding , this )  ; %NWL%this . _hookSync = __bind ( this . _hookSync , this )  ; %NWL%this . _hookEvents = __bind ( this . _hookEvents , this )  ; %NWL%this . _trackObjects = __bind ( this . _trackObjects , this )  ; %NWL%0
aqt . filter [ i ]  . value = this . _bindFilter ( aqt . filter [ i ]  . value , bindings )  ; %NWL%acum . push ( aqt . filter [ i ]  )  ;%NWL%}%NWL%aqt . filter = acum ;%NWL%}%NWL%if ( aqt . kind =  =  =  ' select '  )  {%NWL%aqt . pattern = this . bind ( aqt . pattern , bindings )  ;%NWL%} else if ( aqt . kind =  =  =  ' BGP '  )  {%NWL%aqt . value = this . _bindTripleContext ( aqt . value , bindings )  ;%NWL%} else if ( aqt . kind =  =  =  ' ZERO_OR_MORE_PATH '  )  {%NWL%aqt . path = this . _bindTripleContext ( aqt . path , bindings )  ; %NWL%8
}%NWL%}  ,%NWL%initializeBuffer : function (  )  {%NWL%return this . quotedString (  "  "  )  ;%NWL%}  ,%NWL%namespace :  " Handlebars "  ,%NWL%compile : function ( environment , options , context , asObject )  {%NWL%this . environment = environment ; %NWL%this . options = options ; %NWL%this . stringParams = this . options . stringParams ; %NWL%this . trackIds = this . options . trackIds ; %NWL%9
init : function (  )  {%NWL%this . initStructure (  )  ; %NWL%this . attachEvents (  )  ; %NWL%this . refresh (  )  ;%NWL%}  ,%NWL%initStructure : function (  )  {%NWL%this . page = $ (  ' html '  )  ; %NWL%this . realElement = $ ( this . options . element )  . addClass ( this . options . realElementClass )  ; %NWL%this . fakeElement = $ ( this . options . fakeStructure )  . insertBefore ( this . realElement )  . prepend ( this . realElement )  ; %NWL%this . btnDec = this . fakeElement . find ( this . options . btnDecSelector )  ; %NWL%this . btnInc = this . fakeElement . find ( this . options . btnIncSelector )  ; %NWL%9
oembed : function ( data )  {%NWL%var ret ; %NWL%if ( data . type =  =  =  ' photo '  )  {%NWL%ret =  { type :  ' photo '  }  ; %NWL%if ( data . photos [ 0 ]  . original_size . height > 0 )  {%NWL%ret . height = data . photos [ 0 ]  . original_size . height ;%NWL%}%NWL%if ( data . photos [ 0 ]  . original_size . width > 0 )  {%NWL%ret . width = data . photos [ 0 ]  . original_size . width ;%NWL%}%NWL%ret . url = data . photos [ 0 ]  . original_size . url ; %NWL%5
exports . cd = common . wrap (  ' cd '  , _cd )  ; %NWL%var _pwd = require (  '  .  / src / pwd '  )  ; %NWL%exports . pwd = common . wrap (  ' pwd '  , _pwd )  ; %NWL%var _ls = require (  '  .  / src / ls '  )  ; %NWL%exports . ls = common . wrap (  ' ls '  , _ls )  ; %NWL%var _find = require (  '  .  / src / find '  )  ; %NWL%exports . find = common . wrap (  ' find '  , _find )  ; %NWL%var _cp = require (  '  .  / src / cp '  )  ; %NWL%exports . cp = common . wrap (  ' cp '  , _cp )  ; %NWL%var _rm = require (  '  .  / src / rm '  )  ; %NWL%exports . rm = common . wrap (  ' rm '  , _rm )  ; %NWL%0
if ( availableEntry =  =  = undefined )  {%NWL%µb . purgeFilterList ( location )  ; %NWL%continue ;%NWL%}%NWL%availableEntry . off = storedEntry . off || false ; %NWL%µb . assets . setHomeURL ( location , availableEntry . homeURL )  ; %NWL%if ( storedEntry . entryCount ! =  = undefined )  {%NWL%availableEntry . entryCount = storedEntry . entryCount ;%NWL%}%NWL%if ( storedEntry . entryUsedCount ! =  = undefined )  {%NWL%availableEntry . entryUsedCount = storedEntry . entryUsedCount ; %NWL%7
test = Y . guid (  )  ; %NWL%try {%NWL%LS . setItem ( test , test )  ; %NWL%LS . removeItem ( test )  ; %NWL%return true ;%NWL%} catch ( e )  {%NWL%return false ;%NWL%}%NWL%}  )  (  )  ,%NWL%LocalSync . _data = LocalSync . _data || {  }  ; %NWL%LocalSync . _store = LocalSync . _store || {  }  ; %NWL%9
}  )  ; %NWL%return childMap ;%NWL%}  ; %NWL%function getDepField ( fields , dep )  {%NWL%return util . find ( fields , function ( field )  {%NWL%return field . pathName =  =  = dep . path && field . id =  =  = dep . field ;%NWL%}  ) || null ;%NWL%}%NWL%function Field ( props )  {%NWL%this . path = props . path ; %NWL%this . id = props . id ; %NWL%9
this . mouse = new PIXI . InteractionData (  )  ; %NWL%this . touchs =  {  }  ; %NWL%this . tempPoint = new PIXI . Point (  )  ; %NWL%this . mouseoverEnabled = true ; %NWL%this . pool =  [  ]  ; %NWL%this . interactiveItems =  [  ]  ; %NWL%this . interactionDOMElement = null ; %NWL%this . onMouseMove = this . onMouseMove . bind ( this )  ; %NWL%this . onMouseDown = this . onMouseDown . bind ( this )  ; %NWL%this . onMouseOut = this . onMouseOut . bind ( this )  ; %NWL%this . onMouseUp = this . onMouseUp . bind ( this )  ; %NWL%8
function ( err , results )  {%NWL%if ( err )%NWL%throw err ; %NWL%var themeId = results . theme . themeId , oneColLayoutId = results . oneColLayout . layoutId ,%NWL%defaultLayoutId = results . defaultLayout . layoutId , userId = results . user . userId ,%NWL%userName = results . user . userName ; %NWL%var home = data . home , test = data . test ; %NWL%home . themeId = test . themeId = themeId ; %NWL%home . layoutId = defaultLayoutId ; %NWL%test . layoutId = oneColLayoutId ; %NWL%home . userId = test . userId = userId ; %NWL%7
newBadge . name = badge . name ; %NWL%newBadge . status = badge . archived ? ' archived '  :  ' published '  ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%newBadge . timeUnits = badge . timeUnits ; %NWL%newBadge . evidenceType = badge . evidenceType ; %NWL%newBadge . limit = badge . limit ; %NWL%newBadge . unique = badge . unique ; %NWL%newBadge . imageUrl = badge . imageUrl ; %NWL%0
log . info (  " Generating "  + project . options . target )  ; %NWL%project . produceModule ( moduleNode )  ; %NWL%if ( log . error . count ! =  = 0 )  { log . throwControled (  " #log . error . count errors during compilation "  )  }  ; %NWL%return moduleNode ;%NWL%}  ; %NWL%module . exports . compileModule = compileModule ; %NWL%function Project ( filename , options )  {%NWL%this . recurseLevel = 0 ; %NWL%if ( !options ) options =  {  }  ; %NWL%if ( options . verbose =  =  = undefined ) options . verbose = 1 ; %NWL%if ( options . warning =  =  = undefined ) options . warning = 1 ; %NWL%9
if ( queryParam (  ' theme '  ) ! = null )  {%NWL%config . theme = queryParam (  ' theme '  )  ;%NWL%}%NWL%if ( queryParam (  ' width '  ) ! = null )  {%NWL%config . width = queryParam (  ' width '  )  ;%NWL%}%NWL%if ( queryParam (  ' height '  ) ! = null )  {%NWL%config . height = queryParam (  ' height '  )  ;%NWL%}%NWL%if ( queryParam (  ' legend '  ) ! = null )  {%NWL%config . legend = queryParam (  ' legend '  )  ; %NWL%1
assert . equal ( dataUsageTab . dataset . viewport ,  ' right '  )  ; %NWL%assert . isFalse ( dataUsageTab . classList . contains (  ' standalone '  )  )  ;%NWL%}%NWL%function failingRequestDataSIMIccId ( onsuccess , onerror )  {%NWL%setTimeout ( function (  )  {%NWL%( typeof onerror =  =  =  ' function '  ) && onerror (  )  ;%NWL%}  , 0 )  ;%NWL%}%NWL%function setupCardState ( icc )  {%NWL%window . Common = new MockCommon (  )  ; %NWL%window . CostControl = new MockCostControl (  )  ; %NWL%9
var data =  {  }%NWL%, sorter = null ; %NWL%sorter = this . detectSorter ( Ext . valueFrom ( this . viewParams ,  {  }  )  )  ; %NWL%Ext . iterate (%NWL%this . data%NWL%, function ( key , val , o )  {%NWL%data [ key ]  = CB . FacetList . prototype . getFacetData ( key , val . items )  ; %NWL%for ( var i = 0 ; i < data [ key ]  . length ; i +  +  )  {%NWL%if ( Ext . isObject ( data [ key ]  [ i ]  . items )  )  {%NWL%data [ key ]  [ i ]  . name = data [ key ]  [ i ]  . items . name ; %NWL%data [ key ]  [ i ]  . count = data [ key ]  [ i ]  . items . count ; %NWL%9
this . handler = handler ; %NWL%this . columns = this . containerWidth = this . resizeTimer = null ; %NWL%this . activeItemCount = 0 ; %NWL%this . direction =  ' left '  ; %NWL%this . itemHeightsDirty = true ; %NWL%this . placeholders =  [  ]  ; %NWL%$ . extend ( true , this , defaultOptions , options )  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . onResize = __bind ( this . onResize , this )  ; %NWL%this . onRefresh = __bind ( this . onRefresh , this )  ; %NWL%this . getItemWidth = __bind ( this . getItemWidth , this )  ; %NWL%7
var cookieObject  = null ; %NWL%for ( var i = 0 , l = cookies . length ; i < l ; i +  +  )%NWL%{%NWL%cookie   =  {  }  ; %NWL%cookieObject = cookies [ i ]  ; %NWL%cookie . expires  = cookieObject . expirationDate ; %NWL%cookie . host  = cookieObject . domain ; %NWL%cookie . httpOnly = cookieObject . httpOnly ; %NWL%cookie . name  = cookieObject . name ; %NWL%cookie . path  = cookieObject . path ; %NWL%cookie . secure  = cookieObject . secure ; %NWL%7
locQuad . br . colors = tmpColor ; %NWL%locQuad . tl . colors = tmpColor ; %NWL%locQuad . tr . colors = tmpColor ; %NWL%var locTextureLoaded = texture . isLoaded (  )  ; %NWL%_t . _textureLoaded = locTextureLoaded ; %NWL%if ( !locTextureLoaded )  {%NWL%_t . _rectRotated = rotated || false ; %NWL%if ( rect )  {%NWL%var locRect = _t . _rect ; %NWL%locRect . x = rect . x ; %NWL%locRect . y = rect . y ; %NWL%9
context . registerModule (  " request "  , queryObj )  ; %NWL%filters . setQueryObj ( queryObj )  ; %NWL%queryObj . updateDataFromUrl (  )  ;  /  / Load url data after context data%NWL%queryObj . updateQuery (  )  ;  /  / Update query%NWL%}  ; %NWL%queryObj . store = function (  )  {%NWL%var toStore =  {  }  ; %NWL%toStore . simplifiedRequest = queryObj . info . simplifiedRequest ; %NWL%toStore . complexRequest = queryObj . info . complexRequest ; %NWL%toStore . autoRefresh = queryObj . info . autoRefresh ; %NWL%toStore . sort = queryObj . info . sort ; %NWL%7
success : params . success ,%NWL%error : params . error%NWL%}  , callback )  ;%NWL%}%NWL%}  ,%NWL%_rpc_to_api : function ( rpc )  {%NWL%var api =  {  }  ; %NWL%api . id = rpc . volume_id ; %NWL%api . display_name = rpc . display_name ; %NWL%api . created_at = rpc . created_at . replace (  / \s / g ,  '  '  )  . replace (  /  ( \d { 4 }  )  -  ( \d { 2 }  )  -  ( \d { 2 }  )  (  [ \d :  ]  +  )  +  .  *  /  ,  " $1 - $2 - $3T$4Z "  )  ; %NWL%api . size = rpc . size ; %NWL%8
return ch ;%NWL%}  ,%NWL%unput : function ( ch )  {%NWL%var len = ch . length ; %NWL%var lines = ch . split (  /  ( ? : \r\n?|\n )  / g )  ; %NWL%this . _input = ch + this . _input ; %NWL%this . yytext = this . yytext . substr ( 0 , this . yytext . length - len - 1 )  ; %NWL%this . offset -  = len ; %NWL%var oldLines = this . match . split (  /  ( ? : \r\n?|\n )  / g )  ; %NWL%this . match = this . match . substr ( 0 , this . match . length - 1 )  ; %NWL%this . matched = this . matched . substr ( 0 , this . matched . length - 1 )  ; %NWL%9
var p = this . el . translatePoints ( x , y )  ; %NWL%this . setPosition ( p . left , p . top )  ; %NWL%return this ;%NWL%}  ,%NWL%onRender : function ( ct , position )  {%NWL%Ext . BoxComponent . superclass . onRender . call ( this , ct , position )  ; %NWL%if ( this . resizeEl )  {%NWL%this . resizeEl = Ext . get ( this . resizeEl )  ;%NWL%}%NWL%if ( this . positionEl )  {%NWL%this . positionEl = Ext . get ( this . positionEl )  ; %NWL%7
}%NWL%defaultFunc . reset (  )  ;%NWL%} else {%NWL%hasOnePassingSelector = true ;%NWL%}%NWL%var rules = this . rules ? this . rules . slice ( 0 )  : null ,%NWL%ruleset = new ( tree . Ruleset )  ( selectors , rules , this . strictImports )  ,%NWL%rule , subRule ; %NWL%ruleset . originalRuleset = this ; %NWL%ruleset . root = this . root ; %NWL%ruleset . firstRoot = this . firstRoot ; %NWL%9
logEntry . errors = logEntry . errors || [  ]  ; %NWL%unusedMethods . mandatory . forEach ( function ( m )  {%NWL%if ( errors && errors . indexOf ( m )  >  - 1 )  {%NWL%return ;%NWL%}%NWL%log (  "    "  + m +  "  : no data "  )  ; %NWL%logEntry . errors . push ( m +  "  : no data "  )  ;%NWL%}  )  ;%NWL%}%NWL%if ( unusedMethods . skipped . length > 0 )  {%NWL%logEntry . warnings = logEntry . warnings || [  ]  ; %NWL%0
}  ,%NWL%end : function ( e )  {%NWL%clearTimeout ( this . timer )  ; %NWL%if ( !this . initiated ) return ; %NWL%this . initiated = false ; %NWL%utils . removeClass ( this . target ,  ' tapPressed '  )  ; %NWL%if ( !this . moved && !this . dragging )  {%NWL%var ev = document . createEvent (  " Event "  )  ; %NWL%ev . initEvent (  " tap "  , true , true )  ; %NWL%ev . pageX = parms . hasTouch ? e . changedTouches [ 0 ]  . pageX : e . pageX ; %NWL%ev . pageY = parms . hasTouch ? e . changedTouches [ 0 ]  . pageY : e . pageY ; %NWL%9
}  ; %NWL%Plugin . prototype . scalar = function ( x , y )  {%NWL%this . scalarX = x =  =  = undefined ? this . scalarX : x ; %NWL%this . scalarY = y =  =  = undefined ? this . scalarY : y ;%NWL%}  ; %NWL%Plugin . prototype . limit = function ( x , y )  {%NWL%this . limitX = x =  =  = undefined ? this . limitX : x ; %NWL%this . limitY = y =  =  = undefined ? this . limitY : y ;%NWL%}  ; %NWL%Plugin . prototype . origin = function ( x , y )  {%NWL%this . originX = x =  =  = undefined ? this . originX : x ; %NWL%2
for ( var i = 0 ; i < filterExpr . operands . length ; i +  +  )  {%NWL%filterExpr . operands [ i ]  = this . _replaceFilter ( filterExpr . operands [ i ]  , from , to , ns )  ;%NWL%}%NWL%} else if ( expressionType =  =  ' additiveexpression '  )  {%NWL%filterExpr . summand = this . _replaceFilter ( filterExpr . summand , from , to , ns )  ; %NWL%for ( var i = 0 ; i < filterExpr . summands . length ; i +  +  )  {%NWL%filterExpr . summands [ i ]  . expression = this . _replaceFilter ( filterExpr . summands [ i ]  . expression , from , to , ns )  ;%NWL%}%NWL%} else if ( expressionType =  =  ' builtincall '  )  {%NWL%for ( var i = 0 ; i < filterExpr . args . length ; i +  +  )  {%NWL%filterExpr . args [ i ]  = this . _replaceFilter ( filterExpr . args [ i ]  , from , to , ns )  ; %NWL%1
var bb    = this . get ( BOUNDING_BOX )  ,%NWL%maskNode  = this . get (  ' maskNode '  )  ,%NWL%focusOn  = this . get (  ' focusOn '  )  ,%NWL%focus   = Y . bind ( this . _focus , this )  ,%NWL%uiHandles  =  [  ]  ,%NWL%i , len , o ; %NWL%for ( i = 0 , len = focusOn . length ; i < len ; i +  +  )  {%NWL%o =  {  }  ; %NWL%o . node = focusOn [ i ]  . node ; %NWL%o . ev = focusOn [ i ]  . eventName ; %NWL%o . keyCode = focusOn [ i ]  . keyCode ; %NWL%8
tart . Tabs . prototype . getTabsLength = function (  )  {%NWL%return this . tabPanels . length ;%NWL%}  ; %NWL%tart . Tabs . prototype . initOptions = function ( options )  {%NWL%var props = this . props =  {  }  ; %NWL%props . axis = options . axis || ' x '  ; %NWL%this . activeTab = options . activeTab || 0 ; %NWL%props . renderConfig = options . renderConfig || {  }  ; %NWL%props . tabPanelCssClass = options . tabPanelCssClass || '  '  ; %NWL%props . tabContainerCssClass = options . tabContainerCssClass || '  '  ; %NWL%props . panelContainerCssClass = options . panelContainerCssClass || '  '  ; %NWL%8
result . far = array [ startingIndex +  +  ]  ; %NWL%result . farValue = array [ startingIndex ]  ; %NWL%return result ;%NWL%}  ; %NWL%NearFarScalar . equals = function ( left , right )  {%NWL%return ( left =  =  = right ) ||%NWL%(  ( defined ( left )  ) &&%NWL%( defined ( right )  ) &&%NWL%( left . near =  =  = right . near ) &&%NWL%( left . nearValue =  =  = right . nearValue ) &&%NWL%( left . far =  =  = right . far ) &&%NWL%8
sm . remove = function removeShaderLogFn ( path )  {%NWL%log . innerHTML +  =  " ShaderManager . remove : &nbsp ;  '  "  + path +  "  '  < br >  "  ; %NWL%removeShader ( path )  ;%NWL%}  ; %NWL%sm . reload = function reloadShaderLogFn ( path , callback )  {%NWL%log . innerHTML +  =  " ShaderManager . reload : &nbsp ;  '  "  + path +  "  '  < br >  "  ; %NWL%reloadShader ( path , callback )  ;%NWL%}  ;%NWL%} else {%NWL%sm . load = loadShader ; %NWL%sm . map = mapShader ; %NWL%9
fs . readJsonFile = jsonFile . readFile%NWL%fs . readJSONFile = jsonFile . readFile%NWL%fs . readJsonFileSync = jsonFile . readFileSync%NWL%fs . readJSONFileSync = jsonFile . readFileSync%NWL%fs . readJson = jsonFile . readFile%NWL%fs . readJSON = jsonFile . readFile%NWL%fs . readJsonSync = jsonFile . readFileSync%NWL%fs . readJSONSync = jsonFile . readFileSync%NWL%fs . outputJsonSync = json . outputJsonSync%NWL%fs . outputJSONSync = json . outputJsonSync%NWL%fs . outputJson = json . outputJson%NWL%8
}%NWL%}  ; %NWL%_ . mixin (  {%NWL%sync : function ( method , model , options )  {%NWL%if ( !socket ) return ( options . error && options . error ( 503 , model , options )  )  ; %NWL%if ( model . attributes && model . attributes . _id ) delete model . attributes . id ; %NWL%options . type || ( options . type = model . type || model . collection . type )  ; %NWL%options . channel || ( options . channel = model . getChannel (  )  )  ; %NWL%options . method || ( options . method = method )  ; %NWL%options . indexProps = model . indexProps || ( model . model && model . model . prototype . indexProps ? model . model . prototype . indexProps :  [  ]  )  ; %NWL%options . extKeys = model . extKeys || ( model . model && model . model . prototype . extKeys ? model . model . prototype . extKeys :  [  ]  )  ; %NWL%9
keySensitivity : 100 ,%NWL%lastSearch :  '  '  ,%NWL%textarea :  '  '  ,%NWL%init : function (  )  {%NWL%inputs . dialog = $ (  ' #wp - link '  )  ; %NWL%inputs . submit = $ (  ' #wp - link - submit '  )  ; %NWL%inputs . url = $ (  ' #url - field '  )  ; %NWL%inputs . nonce = $ (  ' #_ajax_linking_nonce '  )  ; %NWL%inputs . title = $ (  ' #link - title - field '  )  ; %NWL%inputs . openInNewTab = $ (  ' #link - target - checkbox '  )  ; %NWL%inputs . search = $ (  ' #search - field '  )  ; %NWL%6
}%NWL%}  ;%NWL%}  )  ( Object . freeze )  ;%NWL%}%NWL%if ( !Object . preventExtensions )  {%NWL%Object . preventExtensions = function preventExtensions ( object )  {%NWL%return object ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isSealed )  {%NWL%Object . isSealed = function isSealed ( object )  {%NWL%5
grunt . fail . forever_warncount = 0 ; %NWL%grunt . fail . forever_errorcount = 0 ; %NWL%grunt . warn = grunt . fail . warn = function ( e )  {%NWL%grunt . fail . forever_warncount +  +  ; %NWL%var message = typeof e =  =  =  ' string ' ? e : e . message ; %NWL%grunt . log . writeln (  (  ' Warning :  '  + message )  . yellow )  ; %NWL%if ( !grunt . option (  ' force '  )  )  {%NWL%rerun (  )  ;%NWL%}%NWL%}  ; %NWL%grunt . fatal = grunt . fail . fatal = function ( e )  {%NWL%2
constructor ( leafCount ,  initialLeafValue )  {%NWL%var internalLeafCount = this . getInternalLeafCount ( leafCount )  ; %NWL%this . _leafCount = leafCount ; %NWL%this . _internalLeafCount = internalLeafCount ; %NWL%var nodeCount = 2 * internalLeafCount ; %NWL%var Int32Array = global . Int32Array || Array ; %NWL%this . _value = new Int32Array ( nodeCount )  ; %NWL%this . _initTables ( initialLeafValue || 0 )  ; %NWL%this . get = this . get . bind ( this )  ; %NWL%this . set = this . set . bind ( this )  ; %NWL%this . lowerBound = this . lowerBound . bind ( this )  ; %NWL%8
return function (  )  {%NWL%return oldFn . apply ( null , arguments ) || newFn . apply ( null , arguments )  ;%NWL%}  ;%NWL%} else {%NWL%return newFn ;%NWL%}%NWL%}  ; %NWL%view . hasModifier = append ( view . hasModifier , fns . hasModifier )  ; %NWL%view . removeModifier = append ( view . removeModifier , fns . removeModifier )  ; %NWL%view . addModifier = append ( view . addModifier , fns . addModifier )  ; %NWL%view . setModifier = append ( view . setModifier , fns . setModifier )  ; %NWL%7
function finale (  )  {%NWL%for ( var i = 0 , len = deferreds . length ; i < len ; i +  +  )%NWL%handle ( deferreds [ i ]  )%NWL%deferreds = null%NWL%}%NWL%try { fn ( resolve , reject )  }%NWL%catch ( e )  { reject ( e )  }%NWL%}%NWL%function Handler ( onFulfilled , onRejected , resolve , reject )  {%NWL%this . onFulfilled = typeof onFulfilled =  =  =  ' function ' ? onFulfilled : null%NWL%this . onRejected = typeof onRejected =  =  =  ' function ' ? onRejected : null%NWL%9
var subclass = require (  "  .  .  / utils "  )  . subclass ; %NWL%exports [  " default "  ]  = subclass ( TransitionIntent ,  {%NWL%name : null ,%NWL%pivotHandler : null ,%NWL%contexts : null ,%NWL%queryParams : null ,%NWL%initialize : function ( props )  {%NWL%this . name = props . name ; %NWL%this . pivotHandler = props . pivotHandler ; %NWL%this . contexts = props . contexts || [  ]  ; %NWL%this . queryParams = props . queryParams ; %NWL%7
left : null ,%NWL%bottom : null ,%NWL%right : null ,%NWL%top : null ,%NWL%centerLonLat : null ,%NWL%initialize : function ( left , bottom , right , top )  {%NWL%if ( left ! = null )  {%NWL%this . left = OpenLayers . Util . toFloat ( left )  ;%NWL%}%NWL%if ( bottom ! = null )  {%NWL%this . bottom = OpenLayers . Util . toFloat ( bottom )  ; %NWL%7
this . $onMultiSelect (  )  ; %NWL%else%NWL%this . $onSingleSelect (  )  ;%NWL%}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%if ( editor . $multiselectOnSessionChange )%NWL%return ; %NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%editor . $onMultiSelect = editor . $onMultiSelect . bind ( editor )  ; %NWL%8
this . _tl = tl ? new cc . Vertex2F ( tl . x , tl . y , locArrayBuffer , 0 )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , 0 )  ; %NWL%this . _tr = tr ? new cc . Vertex2F ( tr . x , tr . y , locArrayBuffer , locElementLen )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , locElementLen )  ; %NWL%this . _bl = bl ? new cc . Vertex2F ( bl . x , bl . y , locArrayBuffer , locElementLen * 2 )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , locElementLen * 2 )  ; %NWL%this . _br = br ? new cc . Vertex2F ( br . x , br . y , locArrayBuffer , locElementLen * 3 )  : new cc . Vertex2F ( 0 , 0 , locArrayBuffer , locElementLen * 3 )  ;%NWL%}  ; %NWL%cc . Quad2 . BYTES_PER_ELEMENT = 32 ; %NWL%cc . Quad3 = function ( bl1 , br1 , tl1 , tr1 )  {%NWL%this . bl = bl1 || new cc . Vertex3F ( 0 , 0 , 0 )  ; %NWL%this . br = br1 || new cc . Vertex3F ( 0 , 0 , 0 )  ; %NWL%this . tl = tl1 || new cc . Vertex3F ( 0 , 0 , 0 )  ; %NWL%this . tr = tr1 || new cc . Vertex3F ( 0 , 0 , 0 )  ; %NWL%7
resourceful . use    = require (  '  .  / resourceful / core '  )  . use ; %NWL%resourceful . connect   = require (  '  .  / resourceful / core '  )  . connect ; %NWL%resourceful . connection  = require (  '  .  / resourceful / core '  )  . connection ; %NWL%resourceful . resources   = require (  '  .  / resourceful / core '  )  . resources ; %NWL%resourceful . register   = require (  '  .  / resourceful / core '  )  . register ; %NWL%resourceful . unregister  = require (  '  .  / resourceful / core '  )  . unregister ; %NWL%resourceful . engines   = require (  '  .  / resourceful / engines '  )  ; %NWL%resourceful . instantiate  = require (  '  .  / resourceful / core '  )  . instantiate ; %NWL%resourceful . deferredRelationships = require (  '  .  / resourceful / core '  )  . deferredRelationships ; %NWL%resourceful . typeOf   = require (  '  .  / resourceful / common '  )  . typeOf ; %NWL%resourceful . mixin    = require (  '  .  / resourceful / common '  )  . mixin ; %NWL%9
suite . _setupComplete = true ;%NWL%}  )  ; %NWL%this . builder = builder ;%NWL%}%NWL%}  )  ; %NWL%var exists = fs . existsSync || path . existsSync ; %NWL%suite . add ( new YUITest . TestCase (  {%NWL%name :  ' Builder setup '  ,%NWL%' test : prep '  : function (  )  {%NWL%this . project = suite . project ; %NWL%this . data = suite . data ; %NWL%9
config . folders . files =  '  .  / uploads /  '  ; %NWL%config . folders . sizeupload = 3145728 ;  /  / 3MB%NWL%config . twitter . token = process . env . TWITTER_TOKEN || "  "  ; %NWL%config . twitter . consumerKey = process . env . TWITTER_CLIENT_ID || " JLwpIcMkECEYTFlu17PX7qlBI "  ; %NWL%config . twitter . consumerSecret = process . env . TWITTER_CLIENT_SECRET || " 1IKRALMUvMvo05jsvqVWaKThYyUaATe1pHE0FvIKKHfvC7YHQH "  ; %NWL%config . twitter . callbackURL = config . web . baseUrl +  "  / oauth / callback?type = twitter "  ; %NWL%config . facebook . token = process . env . FB_TOKEN || "  "  ; %NWL%config . instagram . token = process . env . IG_TOKEN || "  "  ; %NWL%config . instagram . clientID = process . env . IG_CLIENT_ID || " 17d8e35463694bb88b31c33f52b26e47 "  ; %NWL%config . instagram . clientSecret = process . env . IG_CLIENT_SECRET || " 8b6c1fb1fa1a4fc2894b6f0316b512c8 "  ; %NWL%config . instagram . callbackURL = config . web . baseUrl +  "  / oauth / callback?type = instagram "  ; %NWL%5
offset +  = 8 ; %NWL%offset = this . visual_types . writeBuffer ( buffer , offset )  ; %NWL%return offset ;%NWL%}%NWL%function Screen ( window , colormap , white , black , current_input_masks , width_px , height_px , width_mm , height_mm , maps_min , maps_max , root_visual , backing_stores , save_unders , root_depth , depths )  {%NWL%this . window = window || 0 ; %NWL%this . colormap = colormap || 0 ; %NWL%this . white = white || 0 ; %NWL%this . black = black || 0 ; %NWL%this . current_input_masks = current_input_masks || 0 ; %NWL%this . height_px = height_px || 0 ; %NWL%5
sensorDefinitions . labQuestMotion . sensorName = i18n . t (  " sensor . names . labQuestMotion "  )  ; %NWL%sensorDefinitions . labQuestTemperature . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . labQuestTemperature . sensorName = i18n . t (  " sensor . names . labQuestTemperature "  )  ; %NWL%sensorDefinitions . labQuestLight . measurementName = i18n . t (  " sensor . measurements . light_intensity "  )  ; %NWL%sensorDefinitions . labQuestLight . sensorName = i18n . t (  " sensor . names . labQuestLight "  )  ; %NWL%sensorDefinitions . labQuestForce . measurementName = i18n . t (  " sensor . measurements . force "  )  ; %NWL%sensorDefinitions . labQuestForce . sensorName = i18n . t (  " sensor . names . labQuestForce "  )  ; %NWL%sensorDefinitions . labQuestPH . measurementName = i18n . t (  " sensor . measurements . acidity "  )  ; %NWL%sensorDefinitions . labQuestPH . sensorName = i18n . t (  " sensor . names . labQuestPH "  )  ; %NWL%sensorDefinitions . labQuestCO2 . measurementName = i18n . t (  " sensor . measurements . CO2_concentration "  )  ; %NWL%sensorDefinitions . labQuestCO2 . sensorName = i18n . t (  " sensor . names . labQuestCO2 "  )  ; %NWL%0
} else if ( typeof key =  =  ' string '  )  {%NWL%return settings [ key ]  ;%NWL%}%NWL%if ( settings . minTime )  {%NWL%settings . minTime = _time2int ( settings . minTime )  ;%NWL%}%NWL%if ( settings . maxTime )  {%NWL%settings . maxTime = _time2int ( settings . maxTime )  ;%NWL%}%NWL%if ( settings . durationTime )  {%NWL%settings . durationTime = _time2int ( settings . durationTime )  ; %NWL%4
{%NWL%this . x1 = this . y1 = this . x2 = this . y2 = 0 ; %NWL%this . proto = null ;%NWL%}%NWL%else if (  " offset " in proto )%NWL%{%NWL%var d = proto . data (  " jquery - collision - coordinates "  )  ; %NWL%if ( d )%NWL%{%NWL%this . x1 = d . x1 ; %NWL%this . y1 = d . y1 ; %NWL%9
dojo . provide (  " dojox . drawing . manager . Stencil "  )  ;%NWL%( function (  )  {%NWL%var surface , surfaceNode ; %NWL%dojox . drawing . manager . Stencil = dojox . drawing . util . oo . declare (%NWL%function ( options )  {%NWL%surface = options . surface ; %NWL%this . canvas = options . canvas ; %NWL%this . defaults = dojox . drawing . defaults . copy (  )  ; %NWL%this . undo = options . undo ; %NWL%this . mouse = options . mouse ; %NWL%this . keys = options . keys ; %NWL%6
clientId : clientId ,%NWL%clientSecret : clientSecret%NWL%}  ; %NWL%if ( parsedBody . scope )  {%NWL%gr . scope = parsedBody . scope ;%NWL%}%NWL%if ( options . tokenLifetime )  {%NWL%gr . tokenLifetime = options . tokenLifetime ;%NWL%}%NWL%if ( options . attributes )  {%NWL%gr . attributes = options . attributes ; %NWL%7
}  )  ;%NWL%}%NWL%ber . endSequence (  )  ; %NWL%return ber ;%NWL%}  ; %NWL%SearchRequest . prototype . _json = function ( j )  {%NWL%assert . ok ( j )  ; %NWL%j . baseObject = this . baseObject ; %NWL%j . scope = this . scope ; %NWL%j . derefAliases = this . derefAliases ; %NWL%j . sizeLimit = this . sizeLimit ; %NWL%7
}  )  ; %NWL%Expression . prototype . __defineGetter__ (  ' hash '  , function (  )  {%NWL%return this . nodes . map ( function ( node )  {%NWL%return node . hash ;%NWL%}  )  . join (  '  :  :  '  )  ;%NWL%}  )  ; %NWL%Expression . prototype . __proto__ = Node . prototype ; %NWL%Expression . prototype . clone = function (  )  {%NWL%var clone = new Expression ( this . isList )  ; %NWL%clone . preserve = this . preserve ; %NWL%clone . lineno = this . lineno ; %NWL%9
scope :  {%NWL%value :  '  =  '  ,%NWL%min :  ' @ '  ,%NWL%max :  ' @ '  ,%NWL%orientation :  ' @ '  ,%NWL%range :  ' @ '%NWL%}  ,%NWL%link : function ( $scope , element , attrs )  {%NWL%$scope . min = attrs . min ; %NWL%$scope . max = attrs . max ; %NWL%$scope . orientation = attrs . orientation ; %NWL%8
set : function ( a )  {%NWL%__trace (  " Deprecated : You should not set a new target for an old tween .  "  ,  " warn "  )  ; %NWL%this . _target = a ;%NWL%}  ,%NWL%enumerable : true ,%NWL%configurable : true%NWL%}  )  ; %NWL%ITween . prototype . clone = function (  )  {%NWL%var clone = new ITween ( this . _target , this . _duration )  ; %NWL%clone . easing = this . easing ; %NWL%clone . step = this . step ; %NWL%9
material . map = this . map ; %NWL%material . lightMap = this . lightMap ; %NWL%material . specularMap = this . specularMap ; %NWL%material . alphaMap = this . alphaMap ; %NWL%material . envMap = this . envMap ; %NWL%material . combine = this . combine ; %NWL%material . reflectivity = this . reflectivity ; %NWL%material . refractionRatio = this . refractionRatio ; %NWL%material . fog = this . fog ; %NWL%material . shading = this . shading ; %NWL%material . wireframe = this . wireframe ; %NWL%0
fns . hogan = fromStringRenderer (  ' hogan '  )  ; %NWL%fns . hogan . render = function ( str , options , fn )  {%NWL%var engine = requires . hogan || ( requires . hogan = require ( sailsAppPath +  '  / hogan . js '  )  )  ; %NWL%try {%NWL%var tmpl = cache ( options ) || cache ( options , engine . compile ( str , options )  )  ; %NWL%fn ( null , tmpl . render ( options , options . partials )  )  ;%NWL%} catch ( err )  {%NWL%fn ( err )  ;%NWL%}%NWL%}  ; %NWL%fns . templayed = fromStringRenderer (  ' templayed '  )  ; %NWL%0
if ( !err && ok )%NWL%res . push (  [ i , x ]  )  ; %NWL%if ( i =  =  = lastIdx )%NWL%context . stack = res . sort (  )  . map ( function ( pair )  { return pair [ 1 ]  ;  }  )  ; %NWL%arguments [ 0 ]  = null ;  /  / discard errors%NWL%self . apply ( self , arguments )  ;%NWL%}  ; %NWL%next . stack = self . stack ; %NWL%next . stack_ = self . stack_ ; %NWL%next . vars = self . vars ; %NWL%next . args = self . args ; %NWL%7
state . asstatus =  [  ]  ;%NWL%}%NWL%state . bugid = allVars [  ' bugid '  ] || "  "  ; %NWL%state . addedversion = allVars [  ' addedversion '  ] || "  "  ; %NWL%if ( allVars [  ' astype '  ]  )  {%NWL%state . astype = allVars [  ' astype '  ]  . split (  '  ,  '  )  ;%NWL%} else {%NWL%state . astype =  [  ]  ;%NWL%}%NWL%state . asfolder = allVars [  ' asfolder '  ] || "  "  ; %NWL%state . asdefaultassignee = allVars [  ' asdefaultassignee '  ] || "  "  ; %NWL%2
}%NWL%chartObject . highlight = options . highlight ? options . highlight : stylesheet . highlight ; %NWL%chartObject . label_size =  " label_size " in options ? options . label_size : stylesheet . label_size ; %NWL%chartObject . label_color = options . label_color ? options . label_color : stylesheet . label_color ; %NWL%chartObject . label_weight = options . label_weight ? options . label_weight . toLowerCase (  )  : stylesheet . label_weight ; %NWL%chartObject . label_family = options . label_family ? options . label_family . toLowerCase (  )  : stylesheet . label_family ; %NWL%chartObject . pointer_thickness =  " pointer_thickness " in options ? options . pointer_thickness : stylesheet . pointer_thickness ; %NWL%chartObject . pointer_size =  " pointer_size " in options ? options . pointer_size : stylesheet . pointer_size ; %NWL%chartObject . pointer_color = options . pointer_color ? options . pointer_color : stylesheet . pointer_color ; %NWL%chartObject . pointer_family = options . pointer_family ? options . pointer_family . toLowerCase (  )  : stylesheet . pointer_family ; %NWL%chartObject . pointer_weight = options . pointer_weight ? options . pointer_weight . toLowerCase (  )  : stylesheet . pointer_weight ; %NWL%4
}  ; %NWL%proto . assertPassedFeature = function assertPassedFeature (  )  {%NWL%this . assertNoPartialOutput (  " failed "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertPassedFeatures = function assertPassedFeatures (  )  {%NWL%this . assertNoPartialOutput (  " failed "  , this . runOutput )  ; %NWL%this . assertPartialOutput (  " 3 scenarios (  "  + this . color . format (  " passed "  ,  " 3 passed "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertPassedScenario = function assertPassedScenario (  )  {%NWL%1
air . FileFilter = window . runtime . flash . net . FileFilter ; %NWL%air . LocalConnection = window . runtime . flash . net . LocalConnection ; %NWL%air . NetConnection = window . runtime . flash . net . NetConnection ; %NWL%air . URLLoader = window . runtime . flash . net . URLLoader ; %NWL%air . URLLoaderDataFormat = window . runtime . flash . net . URLLoaderDataFormat ; %NWL%air . URLRequest = window . runtime . flash . net . URLRequest ; %NWL%air . URLRequestDefaults = window . runtime . flash . net . URLRequestDefaults ; %NWL%air . URLRequestHeader = window . runtime . flash . net . URLRequestHeader ; %NWL%air . URLRequestMethod = window . runtime . flash . net . URLRequestMethod ; %NWL%air . URLStream = window . runtime . flash . net . URLStream ; %NWL%air . URLVariables = window . runtime . flash . net . URLVariables ; %NWL%0
currentTime : createPropertyDescriptor (  ' currentTime '  )  ,%NWL%clockRange : createPropertyDescriptor (  ' clockRange '  )  ,%NWL%clockStep : createPropertyDescriptor (  ' clockStep '  )  ,%NWL%multiplier : createPropertyDescriptor (  ' multiplier '  )%NWL%}  )  ; %NWL%DataSourceClock . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new DataSourceClock (  )  ;%NWL%}%NWL%result . startTime = this . startTime ; %NWL%result . stopTime = this . stopTime ; %NWL%9
style . width = w ; %NWL%style . height = h ; %NWL%style . x = left ; %NWL%style . y = top ; %NWL%if ( fillColors )%NWL%{%NWL%style . fill . color = fillColors [ i % fillColors . length ]  ;%NWL%}%NWL%if ( borderColors )%NWL%{%NWL%style . border . color = borderColors [ i % borderColors . length ]  ; %NWL%6
copystate . astype =  "  "  ; %NWL%for ( var i = 0 ; i < state . astype . length ; i +  +  )  {%NWL%copystate . astype +  = state . astype [ i ]  ; %NWL%copystate . astype +  =  "  ,  "  ;%NWL%}%NWL%if ( copystate . astype . length )  {%NWL%copystate . astype = copystate . astype . slice ( 0 ,  - 1 )  ;%NWL%}%NWL%}%NWL%if ( state . asfolder . length ) copystate . asfolder = state . asfolder ; %NWL%if ( state . asdefaultassignee . length ) copystate . asdefaultassignee = state . asdefaultassignee ; %NWL%9
for ( var i = 0 ; i < args . length ; i +  +  )  {%NWL%args [ i ]  . then ( synchronizer ( true )  , synchronizer ( false )  )%NWL%}%NWL%return deferred . promise%NWL%}%NWL%function identity ( value )  { return value }%NWL%function ajax ( options )  {%NWL%var xhr = window . XDomainRequest ? new window . XDomainRequest : new window . XMLHttpRequest%NWL%xhr . open ( options . method , options . url , true , options . user , options . password )%NWL%xhr . onload = typeof options . onload =  =  " function " ? options . onload : function (  )  {  }%NWL%xhr . onerror = typeof options . onerror =  =  " function " ? options . onerror : function (  )  {  }%NWL%9
close : function (  )  {  }  ,%NWL%}%NWL%function Expression ( delegate )  {%NWL%this . scopeIdent = delegate . scopeIdent ; %NWL%this . indexIdent = delegate . indexIdent ; %NWL%if ( !delegate . expression )%NWL%throw Error (  ' No expression found .  '  )  ; %NWL%this . expression = delegate . expression ; %NWL%getFn ( this . expression )  ;  /  / forces enumeration of path dependencies%NWL%this . filters = delegate . filters ; %NWL%this . dynamicDeps = delegate . dynamicDeps ; %NWL%3
case " link "  : %NWL%update . links = item . links ; %NWL%item . links = null ; %NWL%for ( i in values )  {%NWL%value = values [ i ]  ; %NWL%item . addLink ( value . href , value . rel , value . hrefLang , value . title , value . type )  ;%NWL%}%NWL%item . isDirty = true ; %NWL%return true ; %NWL%case " author "  : %NWL%update . authors = item . authors ; %NWL%1
}  ,%NWL%createThisExpression : notImplemented%NWL%}%NWL%function Expression ( delegate )  {%NWL%this . scopeIdent = delegate . scopeIdent ; %NWL%this . indexIdent = delegate . indexIdent ; %NWL%if ( !delegate . expression )%NWL%throw Error (  ' No expression found .  '  )  ; %NWL%this . expression = delegate . expression ; %NWL%getFn ( this . expression )  ;  /  / forces enumeration of path dependencies%NWL%this . filters = delegate . filters ; %NWL%4
function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%7
invertMatrix ( m )  ; %NWL%m [ 3 ]  = 0 ; m [ 7 ]  = 0 ; m [ 11 ]  = 0 ; %NWL%this . origin = origin ; %NWL%this . directions = new Array ( 4 )  ; %NWL%this . directions [ 0 ]  = normalise (  [  - 0 . 7 ,  0 . 7 , 1 ]  )  ; %NWL%this . directions [ 1 ]  = normalise (  [ 0 . 7 ,  0 . 7 , 1 ]  )  ; %NWL%this . directions [ 2 ]  = normalise (  [ 0 . 7 ,  - 0 . 7 , 1 ]  )  ; %NWL%this . directions [ 3 ]  = normalise (  [  - 0 . 7 ,  - 0 . 7 , 1 ]  )  ; %NWL%this . directions [ 0 ]  = transformMatrix ( m , this . directions [ 0 ]  )  ; %NWL%this . directions [ 1 ]  = transformMatrix ( m , this . directions [ 1 ]  )  ; %NWL%this . directions [ 2 ]  = transformMatrix ( m , this . directions [ 2 ]  )  ; %NWL%8
}%NWL%if ( this . tPropertyName )  {%NWL%this . setTransform = function ( node ,  transform )  {%NWL%return DOMStyle . set ( node , this . tPropertyName , transform )  ;%NWL%}  ; %NWL%this . getTransform = function ( node )  {%NWL%return DOMStyle . get ( node , this . tPropertyName )  ;%NWL%}  ;%NWL%} else if ( has (  " ie "  )  )  {%NWL%this . setTransform = this . _setTransformFilter ; %NWL%this . getTransform = this . _getTransformFilter ; %NWL%9
return this ;%NWL%}  ,%NWL%_clear : function (  )  {%NWL%this . context . clearRect ( 0 , 0 , this . canvas . width , this . canvas . height )  ; %NWL%return this ;%NWL%}  ,%NWL%}  ; %NWL%var Circle = function ( params )  {%NWL%this . id = params . id ; %NWL%this . canvas = params . canvas ; %NWL%this . context = params . context ; %NWL%8
var adjust_lat = require (  '  .  .  / common / adjust_lat '  )  ; %NWL%var mlfn = require (  '  .  .  / common / mlfn '  )  ; %NWL%var EPSLN = 1 . 0e - 10 ; %NWL%var gN = require (  '  .  .  / common / gN '  )  ; %NWL%var MAX_ITER = 20 ; %NWL%exports . init = function (  )  {%NWL%this . temp = this . b / this . a ; %NWL%this . es = 1 - Math . pow ( this . temp , 2 )  ;  /  / devait etre dans tmerc . js mais n y est pas donc je commente sinon retour de valeurs nulles%NWL%this . e = Math . sqrt ( this . es )  ; %NWL%this . e0 = e0fn ( this . es )  ; %NWL%this . e1 = e1fn ( this . es )  ; %NWL%9
if ( isVisible (  ' srcbrowser '  )  )%NWL%document . getElementById (  ' src '  )  . style . width =  ' 180px '  ; %NWL%e = ed . selection . getNode (  )  ; %NWL%this . fillFileList (  ' image_list '  , tinyMCEPopup . getParam (  ' external_image_list '  ,  ' tinyMCEImageList '  )  )  ; %NWL%if ( e . nodeName =  =  ' IMG '  )  {%NWL%f . src . value = ed . dom . getAttrib ( e ,  ' src '  )  ; %NWL%f . alt . value = ed . dom . getAttrib ( e ,  ' alt '  )  ; %NWL%f . border . value = this . getAttrib ( e ,  ' border '  )  ; %NWL%f . vspace . value = this . getAttrib ( e ,  ' vspace '  )  ; %NWL%f . hspace . value = this . getAttrib ( e ,  ' hspace '  )  ; %NWL%f . width . value = ed . dom . getAttrib ( e ,  ' width '  )  ; %NWL%5
testing . after ( fileserver . stop )  ; %NWL%testing . after ( function (  )  {%NWL%if ( seleniumServer )  {%NWL%seleniumServer . stop (  )  ;%NWL%}%NWL%}  )  ; %NWL%exports . suite = suite ; %NWL%exports . after = testing . after ; %NWL%exports . afterEach = testing . afterEach ; %NWL%exports . before = testing . before ; %NWL%exports . beforeEach = testing . beforeEach ; %NWL%7
}  , 200 )  ;%NWL%}%NWL%}  ; %NWL%result . scrollToIndex = originalScrollModel . scrollToIndex ; %NWL%result . scrollToItem = originalScrollModel . scrollToItem ; %NWL%result . scrollIntoView = originalScrollModel . scrollIntoView ; %NWL%result . scrollToBottom = function ( immediately )  {%NWL%var value = inst . getContentHeight (  )  - inst . getViewportHeight (  )  ; %NWL%myScroll . scrollTo ( 0 ,  - value , immediately ? 0 : 200 )  ;%NWL%}  ; %NWL%result . onScrollingStop = originalScrollModel . onScrollingStop ; %NWL%3
lodash . after = functions . after ; %NWL%lodash . assign = objects . assign ; %NWL%lodash . at = collections . at ; %NWL%lodash . bind = functions . bind ; %NWL%lodash . bindAll = functions . bindAll ; %NWL%lodash . bindKey = functions . bindKey ; %NWL%lodash . chain = chaining . chain ; %NWL%lodash . compact = arrays . compact ; %NWL%lodash . compose = functions . compose ; %NWL%lodash . constant = utilities . constant ; %NWL%lodash . countBy = collections . countBy ; %NWL%2
}%NWL%if ( vars [ key ]  =  =  =  ' true '  )  {%NWL%vars [ key ]  = true ;%NWL%}%NWL%if ( vars [ key ]  =  =  =  ' false '  )  {%NWL%vars [ key ]  = false ;%NWL%}%NWL%}  )  ; %NWL%vars . development = vars . NODE_ENV =  =  =  ' development '  ; %NWL%vars . test   = vars . NODE_ENV =  =  =  ' test '  ; %NWL%vars . production  = vars . NODE_ENV =  =  =  ' production '  ; %NWL%8
}%NWL%if ( !HTMLVideoElement && ! ( element instanceof VirtualMediaContainer ) && !options . forceCaptionify )  {%NWL%return false ;%NWL%}%NWL%if (  ( typeof ( document . createElement (  " video "  )  . addTextTrack )  =  =  =  " function " || typeof ( document . createElement (  " video "  )  . addTrack )  =  =  =  " function "  ) && !options . forceCaptionify )  {%NWL%return false ;%NWL%}%NWL%if ( !objectsCreated && options . exportObjects )  {%NWL%window . TextTrack = captionator . TextTrack ; %NWL%window . TextTrackCueList = captionator . TextTrackCueList ; %NWL%window . ActiveTextTrackCueList = captionator . ActiveTextTrackCueList ; %NWL%8
function copyEventProps ( evt )  {%NWL%var props = lang . delegate ( evt ,  {%NWL%bubbles : true%NWL%}  )  ; %NWL%if ( has (  " ios "  )  >  = 6 )  {%NWL%props . touches = evt . touches ; %NWL%props . altKey = evt . altKey ; %NWL%props . changedTouches = evt . changedTouches ; %NWL%props . ctrlKey = evt . ctrlKey ; %NWL%props . metaKey = evt . metaKey ; %NWL%props . shiftKey = evt . shiftKey ; %NWL%5
}%NWL%}  , coverageLog ; %NWL%Y . Object . each ( coverage , function ( info )  {%NWL%cov . lines . total +  = info . coveredLines ; %NWL%cov . lines . hit +  = info . calledLines ; %NWL%cov . lines . miss +  =  ( info . coveredLines - info . calledLines )  ; %NWL%cov . lines . percent = Math . floor (  ( cov . lines . hit / cov . lines . total )  * 100 )  ; %NWL%cov . functions . total +  = info . coveredFunctions ; %NWL%cov . functions . hit +  = info . calledFunctions ; %NWL%cov . functions . miss +  =  ( info . coveredFunctions - info . calledFunctions )  ; %NWL%cov . functions . percent = Math . floor (  ( cov . functions . hit / cov . functions . total )  * 100 )  ; %NWL%6
return proxyResult%NWL%}  ,%NWL%_initNode = function ( setting , level , n , parentNode , isFirstNode , isLastNode , openFlag )  {%NWL%if ( !n ) return ; %NWL%var checkedKey = setting . data . key . checked ; %NWL%if ( typeof n [ checkedKey ]  =  =  " string "  ) n [ checkedKey ]  = tools . eqs ( n [ checkedKey ]  ,  " true "  )  ; %NWL%n [ checkedKey ]  = !!n [ checkedKey ]  ; %NWL%n . checkedOld = n [ checkedKey ]  ; %NWL%if ( typeof n . nocheck =  =  " string "  ) n . nocheck = tools . eqs ( n . nocheck ,  " true "  )  ; %NWL%n . nocheck = !!n . nocheck || ( setting . check . nocheckInherit && parentNode && !!parentNode . nocheck )  ; %NWL%if ( typeof n . chkDisabled =  =  " string "  ) n . chkDisabled = tools . eqs ( n . chkDisabled ,  " true "  )  ; %NWL%8
[  " simple - auth / authorizers / base "  ,  "  .  /  .  .  / configuration "  ,  " exports "  ]  ,%NWL%function ( __dependency1__ , __dependency2__ , __exports__ )  {%NWL%" use strict "  ; %NWL%var Base = __dependency1__ [  " default "  ]  ; %NWL%var Configuration = __dependency2__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%tokenAttributeName :  ' token '  ,%NWL%identificationAttributeName :  ' email '  ,%NWL%init : function (  )  {%NWL%this . tokenAttributeName    = Configuration . tokenAttributeName ; %NWL%this . identificationAttributeName = Configuration . identificationAttributeName ; %NWL%9
EventEmitter . call ( this )  ; %NWL%this . agent = options . agent ; %NWL%this . cert = options . cert ; %NWL%this . connectTimeout = options . connectTimeout || false ; %NWL%this . headers = options . headers || {  }  ; %NWL%this . log = options . log ; %NWL%this . key = options . key ; %NWL%this . name = options . name || ' HttpClient '  ; %NWL%this . retry = cloneRetryOptions ( options . retry )  ; %NWL%this . signRequest = options . signRequest || false ; %NWL%this . socketPath = options . socketPath || false ; %NWL%3
var gmatcher = null%NWL%if ( pattern . slice (  - 3 )  =  =  =  '  "  + pattern%NWL%}%NWL%self . pattern = pattern%NWL%self . strict = options . strict ! =  = false%NWL%self . dot = !!options . dot%NWL%self . mark = !!options . mark%NWL%self . nodir = !!options . nodir%NWL%if ( self . nodir )%NWL%self . mark = true%NWL%self . sync = !!options . sync%NWL%5
var sinon = require (  "  .  .  /  .  .  / lib / sinon "  )  ;%NWL%}%NWL%buster . testCase (  " sinon . test "  ,  {%NWL%setUp : function (  )  {%NWL%this . boundTestCase = function (  )  {%NWL%var properties =  {%NWL%fn : function (  )  {%NWL%properties . self = this ; %NWL%properties . args = arguments ; %NWL%properties . spy = this . spy ; %NWL%properties . stub = this . stub ; %NWL%9
Ray . CLOSEST = 1 ; %NWL%Ray . ANY = 2 ; %NWL%Ray . ALL = 4 ; %NWL%var tmpAABB = new AABB (  )  ; %NWL%var tmpArray =  [  ]  ; %NWL%Ray . prototype . intersectWorld = function ( world , options )  {%NWL%this . mode = options . mode || Ray . ANY ; %NWL%this . result = options . result || new RaycastResult (  )  ; %NWL%this . skipBackfaces = !!options . skipBackfaces ; %NWL%this . collisionFilterMask = typeof ( options . collisionFilterMask ) ! =  =  ' undefined ' ? options . collisionFilterMask :  - 1 ; %NWL%this . collisionFilterGroup = typeof ( options . collisionFilterGroup ) ! =  =  ' undefined ' ? options . collisionFilterGroup :  - 1 ; %NWL%9
current . headerLength = 46 + current . fileNameLength + current . extraFieldLength + current . fileCommentLength ; %NWL%if ( current . fileNameLength > 0 )  {%NWL%current . fileName = buffer . slice ( index , index + current . fileNameLength )  . toString (  )  ; %NWL%index +  = current . fileNameLength ;%NWL%}%NWL%if ( current . extraFieldLength > 0 )  {%NWL%current . extraField = buffer . slice ( index , index + current . extraFieldLength )  . toString (  )  ; %NWL%index +  = current . extraFieldLength ;%NWL%}%NWL%if ( current . fileCommentLength > 0 )  {%NWL%current . fileComment = buffer . slice ( index , index + current . fileCommentLength )  . toString (  )  ; %NWL%2
overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%this . clientY  = e . clientY ; %NWL%4
client . close (  )  ; %NWL%callback (  )  ;%NWL%} else {%NWL%client . close (  )  ; %NWL%callback (  )  ;%NWL%}%NWL%}  ,%NWL%shouldCorrectlyRetrieveErrorMessagesFromServer : function ( test )  {%NWL%var error_client = new Db ( MONGODB , new Server (  " 127 . 0 . 0 . 1 "  , 27017 ,  { auto_reconnect : false , poolSize : 1 }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%error_client . bson_deserializer = client . bson_deserializer ; %NWL%error_client . bson_serializer = client . bson_serializer ; %NWL%9
Cu . import (  ' resource :  /  / gre / modules / FileUtils . jsm '  )  ; %NWL%const GAIA_DIR_PREF_NAME =  ' extensions . gaia . dir '  ; %NWL%const DEFAULT_PAGE = 2 ; %NWL%var utils , variant ; %NWL%var Homescreen =  {%NWL%operators :  {  }  ,%NWL%init : function hs_init (  )  {%NWL%var self = this ; %NWL%this . addPageButton = document . getElementById (  ' add - page '  )  ; %NWL%this . grid = document . getElementById (  ' grid '  )  ; %NWL%this . dock = document . getElementById (  ' dock '  )  ; %NWL%9
assertions =  [  ' ok '  ,  ' equal '  ,  ' notEqual '  ,  ' deepEqual '  ,  ' notDeepEqual '  ,%NWL%' strictEqual '  ,  ' notStrictEqual '  ,  ' raises '  ]  ; %NWL%for ( var i = 0 ; i < assertions . length ; i +  +  )  {%NWL%originalAssertions [ assertions [ i ]  ]  = window [ assertions [ i ]  ]  ;%NWL%}%NWL%window . ok = function (  )  { capturedAssertions . push (  [  ' ok '  , arguments ]  )  }  ; %NWL%window . equal = function (  )  { capturedAssertions . push (  [  ' equal '  , arguments ]  )  }  ; %NWL%window . notEqual = function (  )  { capturedAssertions . push (  [  ' notEqual '  , arguments ]  )  }  ; %NWL%window . deepEqual = function (  )  { capturedAssertions . push (  [  ' deepEqual '  , arguments ]  )  }  ; %NWL%window . notDeepEqual = function (  )  { capturedAssertions . push (  [  ' notDeepEqual '  , arguments ]  )  }  ; %NWL%window . strictEqual = function (  )  { capturedAssertions . push (  [  ' strictEqual '  , arguments ]  )  }  ; %NWL%5
this . setPathPosition ( false , ly )  ; %NWL%this . reverseWinding (  )  ;%NWL%}  ; %NWL%Path . prototype . flipEW = function (  )  {%NWL%var lx = this . maxes . xmin ; %NWL%var mid =  ( this . getWidth (  )  / 2 )  + this . maxes . xmin ; %NWL%for ( var e = 0 ; e < this . pathpoints . length ; e +  +  )  {%NWL%var pp = this . pathpoints [ e ]  ; %NWL%pp . P . x +  =  (  ( mid - pp . P . x )  * 2 )  ; %NWL%pp . H1 . x +  =  (  ( mid - pp . H1 . x )  * 2 )  ; %NWL%pp . H2 . x +  =  (  ( mid - pp . H2 . x )  * 2 )  ; %NWL%8
if ( util . handleError ( error , res )  )  { return ;  }%NWL%res . send (  { orgs : docs }  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . listForCurrentUser = function listForCurrentUser ( req , res )  {%NWL%Org . find (  { users : req . user . _id }  )  . select (  '  + users '  )  . exec ( function ( error , docs )  {%NWL%if ( util . handleError ( error , res )  )  { return ;  }%NWL%res . send (  { orgs : docs }  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . get = function get ( req , res )  {%NWL%4
!function ( $ )  {%NWL%" use strict "  ; %NWL%var Typed = function ( el , options )  {%NWL%this . el = $ ( el )  ; %NWL%this . options = $ . extend (  {  }  , $ . fn . typed . defaults , options )  ; %NWL%this . baseText =  ( this . options . baseText ! =  = undefined ) ? this . options . baseText : this . el . text (  ) || this . el . attr (  ' placeholder '  ) || '  '  ; %NWL%this . replaceBaseText = this . options . replaceBaseText ; %NWL%this . typeSpeed = this . options . typeSpeed ; %NWL%this . startDelay = this . options . startDelay ; %NWL%this . backSpeed = this . options . backSpeed ; %NWL%this . backDelay = this . options . backDelay ; %NWL%6
options . partitions = options . partitions || {  }%NWL%this . name = name || '  '%NWL%this . kafka = kafka%NWL%this . encoding = null%NWL%this . readable = true /  / required Stream property%NWL%this . writable = true /  / required Stream property%NWL%this . compression = options . compression%NWL%this . minFetchDelay = options . minFetchDelay%NWL%this . maxFetchDelay = options . maxFetchDelay%NWL%this . maxFetchSize = options . maxFetchSize%NWL%this . maxMessageSize = options . maxMessageSize%NWL%6
$ (  ' #tbox_prefs_sign_api_base '  )  . attr (  ' disabled '  , true )  ;%NWL%}%NWL%if ( prefs . use_same_sign_oauth_base )  {%NWL%$ (  ' #tbox_prefs_sign_oauth_base '  )  . attr (  ' disabled '  , true )  ;%NWL%}%NWL%}  ,%NWL%save_prefs : %NWL%function save_prefs (  )  {%NWL%var prefs = conf . get_current_profile (  )  . preferences ; %NWL%prefs . lang = $ (  ' #sel_prefs_lang '  )  . val (  )  ; %NWL%prefs . theme = $ (  ' #sel_prefs_theme '  )  . val (  )  ; %NWL%9
[ translate_ . instant (  ' abort '  )  , translate_ . instant (  ' resolve_conflicts '  )  ]  , false )  ; %NWL%myDialog . then ( function ( button )  {%NWL%switch ( button )  {%NWL%case 0 : %NWL%service_ . transaction . abort (  )  ; %NWL%break ; %NWL%case 1 : %NWL%service_ . ourName = translate_ . instant (  ' transaction '  )  ; %NWL%service_ . theirName = translate_ . instant (  ' repository '  )  ; %NWL%service_ . ours = mergeFailure . ours ; %NWL%service_ . theirs = mergeFailure . theirs ; %NWL%9
'  .  .  / Core / defaultValue '  ,%NWL%'  .  .  / Core / freezeObject '%NWL%]  , function (%NWL%Color ,%NWL%defaultValue ,%NWL%freezeObject )  {%NWL%" use strict "  ; %NWL%var ClearCommand = function ( options )  {%NWL%options = defaultValue ( options , defaultValue . EMPTY_OBJECT )  ; %NWL%this . color = options . color ; %NWL%this . depth = options . depth ; %NWL%9
}%NWL%var prop = this . properties [ p ]  ; %NWL%if ( d . isFunction ( prop )  )  {%NWL%prop = prop ( n )  ;%NWL%}%NWL%prop = pm [ p ]  = _mixin (  {  }  ,  ( d . isObject ( prop ) ? prop :  { end : prop }  )  )  ; %NWL%if ( d . isFunction ( prop . start )  )  {%NWL%prop . start = prop . start ( n )  ;%NWL%}%NWL%if ( d . isFunction ( prop . end )  )  {%NWL%prop . end = prop . end ( n )  ; %NWL%7
if ( options . app ! = null )  {%NWL%this . app = this . options . app ;%NWL%} else {%NWL%throw new Error (  " options . app expected when initializing a new view "  )%NWL%}%NWL%if ( options . parentView ! = null )  {%NWL%this . parentView = options . parentView ;%NWL%}%NWL%options = BaseView . parseModelAndCollection ( this . app . modelUtils , _ . extend (  { parse : true }  , options )  )  ; %NWL%this . model = options . model ; %NWL%this . collection = options . collection ; %NWL%6
}%NWL%}  ; %NWL%SceneJS . Lookat . getDefaultMatrix = function (  )  {%NWL%return defaultMat ;%NWL%}  ; %NWL%SceneJS . Lookat . prototype . setEye = function ( eye )  {%NWL%eye = eye || {  }  ; %NWL%if ( eye . x ! = undefined && eye . x ! = null )  {%NWL%this . _core . eyeX = eye . x ;%NWL%}%NWL%if ( eye . y ! = undefined && eye . y ! = null )  {%NWL%7
if ( breakingProcess ! =  = null )  {%NWL%clearInterval ( breakingProcess )  ;%NWL%}%NWL%e . stopPropagation (  )  ;%NWL%}  )  ; %NWL%$this . bind (  " touchmove "  + eventClassName , function ( e )  {%NWL%if ( !inGlobalTouch && e . originalEvent . targetTouches . length =  =  = 1 )  {%NWL%var touch = e . originalEvent . targetTouches [ 0 ]  ; %NWL%var currentCoords =  {  }  ; %NWL%currentCoords . pageX = touch . pageX ; %NWL%currentCoords . pageY = touch . pageY ; %NWL%9
arr . readUInt16LE = BP . readUInt16LE%NWL%arr . readUInt16BE = BP . readUInt16BE%NWL%arr . readUInt32LE = BP . readUInt32LE%NWL%arr . readUInt32BE = BP . readUInt32BE%NWL%arr . readInt8 = BP . readInt8%NWL%arr . readInt16LE = BP . readInt16LE%NWL%arr . readInt16BE = BP . readInt16BE%NWL%arr . readInt32LE = BP . readInt32LE%NWL%arr . readInt32BE = BP . readInt32BE%NWL%arr . readFloatLE = BP . readFloatLE%NWL%arr . readFloatBE = BP . readFloatBE%NWL%0
fieldDef . regexp = p . pattern ;%NWL%}%NWL%}%NWL%if ( !lang . isUndefined ( p . maxLength ) && lang . isUndefined ( fieldDef . maxLength )  )  {%NWL%fieldDef . maxLength = p . maxLength ;%NWL%}%NWL%if ( !lang . isUndefined ( p . minLength ) && lang . isUndefined ( fieldDef . minLength )  )  {%NWL%fieldDef . minLength = p . minLength ;%NWL%}%NWL%if ( !lang . isUndefined ( p . readonly ) && lang . isUndefined ( fieldDef . readonly )  )  {%NWL%fieldDef . readonly = p . readonly ; %NWL%4
return supers_max + 1 ;%NWL%}%NWL%return 0 ;%NWL%}  ; %NWL%return Class ;%NWL%}  )  ( DiagramElement )  ; %NWL%ClassDiagram =  ( function ( _super )  {%NWL%__extends ( ClassDiagram , _super )  ; %NWL%function ClassDiagram (  )  {%NWL%this . find_by_name = __bind ( this . find_by_name , this )  ; %NWL%this . get_classes = __bind ( this . get_classes , this )  ; %NWL%9
style . width = w ; %NWL%style . height = h ; %NWL%style . x = left ; %NWL%style . y = top ; %NWL%if ( fillColors )%NWL%{%NWL%style . fill . color = fillColors [ i % fillColors . length ]  ;%NWL%}%NWL%if ( borderColors )%NWL%{%NWL%style . border . color = borderColors [ i % borderColors . length ]  ; %NWL%6
if ( c )  {%NWL%c = c . wrappedJSObject ; %NWL%return c . data [ key ]  ;%NWL%} else {%NWL%this . log ( INFO ,  " No controller attached to "  + domWin )  ; %NWL%return null ;%NWL%}%NWL%} catch ( e )  {%NWL%this . log ( WARN ,  " exception in getExpando "  )  ; %NWL%this . getExpando = this . getExpando_old ; %NWL%this . setExpando = this . setExpando_old ; %NWL%9
var WebDeveloper = WebDeveloper || {  }  ; %NWL%WebDeveloper . Overlay   = WebDeveloper . Overlay || {  }  ; %NWL%WebDeveloper . Overlay . Images = WebDeveloper . Overlay . Images || {  }  ; %NWL%WebDeveloper . Overlay . Images . getViewImageInformationLocale = function (  )%NWL%{%NWL%var locale = WebDeveloper . Locales . setupGeneratedLocale (  )  ; %NWL%locale . alt   = WebDeveloper . Locales . getString (  " alt "  )  ; %NWL%locale . height  = WebDeveloper . Locales . getString (  " height "  )  ; %NWL%locale . image  = WebDeveloper . Locales . getString (  " image "  )  ; %NWL%locale . images  = WebDeveloper . Locales . getString (  " images "  )  ; %NWL%locale . property = WebDeveloper . Locales . getString (  " property "  )  ; %NWL%6
helpers . net . createServer , options%NWL%)  ,%NWL%client : async . apply (%NWL%helpers . net . createClient , options%NWL%)%NWL%}  , function ( err , results )  {%NWL%if ( err )  {%NWL%return that . callback ( err )  ;%NWL%}%NWL%that . server = results . server ; %NWL%that . client = results . client ; %NWL%9
callCount : 0 ,%NWL%object : false ,%NWL%key : false ,%NWL%indexes : false ,%NWL%context : false ,%NWL%setupVerify : function ( object , key , indexes , context )  {%NWL%this . verify = true ; %NWL%this . object =  ( object =  =  = undefined ) ? false : object ; %NWL%this . key =  ( key =  =  = undefined ) ? false : key ; %NWL%this . indexes =  ( indexes =  =  = undefined ) ? false : indexes ; %NWL%this . context =  ( context =  =  = undefined ) ? false : context ; %NWL%7
points :  [  ]  ,%NWL%draw : dcl . superCall ( function ( sup )  {%NWL%return function ( ctx , scale )  {%NWL%scale = scale || this . scale || 1 ; %NWL%var ogLineWidth = ctx . lineWidth ; %NWL%ctx . lineWidth = this . lineWidth ; %NWL%ctx . save (  )  ; %NWL%ctx . translate ( this . x * scale , this . y * scale )  ; %NWL%ctx . rotate ( this . angle )  ; %NWL%ctx . translate (  -  ( this . x )  * scale ,  -  ( this . y )  * scale )  ; %NWL%ctx . fillStyle = this . fillStyle ; %NWL%5
!relobj . authority &&%NWL%!relobj . query%NWL%)  {%NWL%if ( relobj . fragment ! = n )  {%NWL%uriobj . fragment = relobj . fragment ;%NWL%}%NWL%relobj = uriobj ;%NWL%} else if ( !relobj . scheme )  {%NWL%relobj . scheme = uriobj . scheme ; %NWL%if ( !relobj . authority )  {%NWL%relobj . authority = uriobj . authority ; %NWL%8
}%NWL%if ( tag =  =  =  " i "  )  {%NWL%this . italic = this . italic - 1 ;%NWL%}%NWL%if ( tag =  =  =  " u "  )  {%NWL%this . underline = this . underline - 1 ;%NWL%}%NWL%if ( tag =  =  =  " a "  )  {%NWL%node = createNode (  " a "  )  ; %NWL%node . href = el . href ; %NWL%this . anchor = this . anchor - 1 ; %NWL%2
return out ;%NWL%}  ; %NWL%svgedit . path . getPointFromGrip = function ( pt , path )  {%NWL%var out =  {%NWL%x : pt . x ,%NWL%y : pt . y%NWL%}%NWL%if ( path . matrix )  {%NWL%var pt = svgedit . math . transformPoint ( out . x , out . y , path . imatrix )  ; %NWL%out . x = pt . x ; %NWL%out . y = pt . y ; %NWL%9
else%NWL%{%NWL%actor . x = actor . org_x ; %NWL%actor . y = actor . org_y ;%NWL%}%NWL%actor . rotation = actor . org_rotation ; %NWL%actor . scale_x = actor . org_scale_x ; %NWL%actor . scale_y = actor . org_scale_y ; %NWL%actor . depth = actor . org_depth ; %NWL%actor . opacity = actor . org_opacity ; %NWL%actor . current_frame = actor . org_current_frame ; %NWL%2
sizeChange : function (  )  {%NWL%dojox . grid . jobs . job ( this . id +  ' SizeChange '  , 50 , dojo . hitch ( this ,  " update "  )  )  ;%NWL%}  ,%NWL%renderOnIdle : function (  )  {%NWL%setTimeout ( dojo . hitch ( this ,  " render "  )  , 1 )  ;%NWL%}  ,%NWL%createManagers : function (  )  {%NWL%this . rows = new dojox . grid . rows ( this )  ; %NWL%this . focus = new dojox . grid . focus ( this )  ; %NWL%this . selection = new dojox . grid . selection ( this )  ; %NWL%this . edit = new dojox . grid . edit ( this )  ; %NWL%7
} else {%NWL%this . seriesThemes = null ; %NWL%this . colors =  ( kwArgs . colors || Theme . defaultColors )  . slice ( 0 )  ;%NWL%}%NWL%this . markerThemes = null ; %NWL%if ( kwArgs . markerThemes && kwArgs . markerThemes . length )  {%NWL%this . markerThemes = kwArgs . markerThemes . slice ( 0 )  ;%NWL%}%NWL%this . markers = kwArgs . markers ? lang . clone ( kwArgs . markers )  : lang . delegate ( Theme . defaultMarkers )  ; %NWL%this . noGradConv = kwArgs . noGradConv ; %NWL%this . noRadialConv = kwArgs . noRadialConv ; %NWL%9
pc . setRemoteDescription ( new RTCSessionDescription ( remoteDescription )  , function (  )  {%NWL%if ( pc . remoteDescription . type =  =  =  ' offer '  )%NWL%pc . createAnswer ( localDescCreated , this . onerror )  ;%NWL%}  , this . onerror )  ;%NWL%}  )  ; %NWL%signalConnection . on (  ' PeerConnection : ice '  , function ( ice )  {%NWL%pc . addIceCandidate ( new RTCIceCandidate (  { sdpMLineIndex : ice . label , candidate : ice . candidate }  )  )  ;%NWL%}  )  ; %NWL%pc . onconnecting = function (  )  { self . onconnecting . apply ( self , arguments )  }  ; %NWL%pc . onopen = function (  )  { self . onopen . apply ( self , arguments )  }  ; %NWL%pc . onaddstream = function (  )  { self . onaddstream . apply ( self , arguments )  }  ; %NWL%8
p . useLog = gl . getUniformLocation ( p ,  " u_useLog "  )  ; %NWL%p . histGap = gl . getUniformLocation ( p ,  " u_histGap "  )  ; %NWL%p . exp = gl . getUniformLocation ( p ,  " u_exp "  )  ; %NWL%p . bufferMax = gl . getUniformLocation ( p ,  " u_bufferMax "  )  ; %NWL%p . bufferMin = gl . getUniformLocation ( p ,  " u_bufferMin "  )  ; %NWL%p . avgPix = gl . getUniformLocation ( p ,  " u_avgPix "  )  ; %NWL%p . visWd = gl . getUniformLocation ( p ,  " u_canvasWd "  )  ; %NWL%p . plotsHt = gl . getUniformLocation ( p ,  " u_plotsHt "  )  ; %NWL%p . oneDPlotHt = gl . getUniformLocation ( p ,  " u_1dPlotHt "  )  ; %NWL%p . pixOffsets = gl . getUniformLocation ( p ,  " u_pixOffsets "  )  ; %NWL%p . texIdx = gl . getUniformLocation ( p ,  " u_texIdx "  )  ; %NWL%5
return {%NWL%restrict :  ' E '  ,%NWL%template : require (  ' text!plugins / dashboard / components / panel / panel . html '  )  ,%NWL%requires :  ' ^dashboardGrid '  ,%NWL%link : function ( $scope , $el )  {%NWL%var $state = $scope . state ; %NWL%$scope . $watch (  ' id '  , function ( id )  {%NWL%if ( !$scope . panel . id || !$scope . panel . type ) return ; %NWL%loadPanel ( $scope . panel , $scope )  . then ( function ( panelConfig )  {%NWL%$scope . savedObj = panelConfig . savedObj ; %NWL%$scope . edit = panelConfig . edit ; %NWL%9
air . Sound = window . runtime . flash . media . Sound ; %NWL%air . SoundChannel = window . runtime . flash . media . SoundChannel ; %NWL%air . SoundLoaderContext = window . runtime . flash . media . SoundLoaderContext ; %NWL%air . SoundMixer = window . runtime . flash . media . SoundMixer ; %NWL%air . SoundTransform = window . runtime . flash . media . SoundTransform ; %NWL%air . Microphone = window . runtime . flash . media . Microphone ; %NWL%air . Video = window . runtime . flash . media . Video ; %NWL%air . Camera = window . runtime . flash . media . Camera ; %NWL%air . SoundCodec = window . runtime . flash . media . SoundCodec ; %NWL%air . EncryptedLocalStore = window . runtime . flash . data . EncryptedLocalStore ; %NWL%air . SQLCollationType = window . runtime . flash . data . SQLCollationType ; %NWL%9
ve . isInstanceOfAny = function ( subject , classes )  {%NWL%var i = classes . length ; %NWL%while ( classes [  -  - i ]  )  {%NWL%if ( subject instanceof classes [ i ]  )  {%NWL%return true ;%NWL%}%NWL%}%NWL%return false ;%NWL%}  ; %NWL%ve . cloneObject = OO . cloneObject ; %NWL%ve . getObjectValues = OO . getObjectValues ; %NWL%9
getDOMObjectPosition : function ( obj )  {%NWL%var info =  {%NWL%left : 0 ,%NWL%top : 0 ,%NWL%width : obj . width ? obj . width : obj . offsetWidth ,%NWL%height : obj . height ? obj . height : obj . offsetHeight%NWL%}  ; %NWL%if ( obj . style . width ! =  "  "  )%NWL%info . width = obj . style . width . replace (  " px "  ,  "  "  )  ; %NWL%if ( obj . style . height ! =  "  "  )%NWL%info . height = obj . style . height . replace (  " px "  ,  "  "  )  ; %NWL%8
pointer_top = null ; %NWL%if ( tooltipBox . left < docBox . left )  {%NWL%pointer_left = tooltipBox . left - docBox . left - pointerBox . width / 2 ; %NWL%tooltipBox . left = docBox . left ;%NWL%} else if ( tooltipBox . left + tooltipBox . width > docBox . left + docBox . width )  {%NWL%pointer_left = tooltipBox . left - docBox . left - docBox . width + tooltipBox . width - pointerBox . width / 2 ; %NWL%tooltipBox . left = docBox . left + docBox . width - tooltipBox . width ;%NWL%}%NWL%if ( tooltipBox . top < docBox . top )  {%NWL%pointer_top = tooltipBox . top - docBox . top - pointerBox . height / 2 ; %NWL%tooltipBox . top = docBox . top ; %NWL%3
$content . html ( seUtils . generateHTMLFromModel ( dataModel )  )  ; %NWL%_ph_deactivate (  )  ;%NWL%}  ; %NWL%api . getHTML = function ( dataModel )  {%NWL%if ( !dataModel )  {%NWL%return null ;%NWL%}%NWL%return seUtils . generateHTMLFromModel ( dataModel )  ;%NWL%}  ; %NWL%api . computeDelta = seUtils . computeDelta ; %NWL%api . applyDelta = seUtils . applyDelta ; %NWL%9
feed . type =  " rss "  ; %NWL%feedRoot = feedRoot . children [ 0 ]  ;  /  /  < channel /  >%NWL%feed . id =  "  "  ; %NWL%try {%NWL%feed . title = DomUtils . getElementsByTagName (  " title "  , feedRoot . children , false )  [ 0 ]  . children [ 0 ]  . data ;%NWL%} catch ( ex )  {  }%NWL%try {%NWL%feed . link = DomUtils . getElementsByTagName (  " link "  , feedRoot . children , false )  [ 0 ]  . children [ 0 ]  . data ;%NWL%} catch ( ex )  {  }%NWL%try {%NWL%feed . description = DomUtils . getElementsByTagName (  " description "  , feedRoot . children , false )  [ 0 ]  . children [ 0 ]  . data ; %NWL%4
if ( this . enableGiftSubscriptions ! =  = null && this . enableGiftSubscriptions ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableGiftSubscriptions '  , Thrift . Type . BOOL , 6 )  ; %NWL%output . writeBool ( this . enableGiftSubscriptions )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableSupportTickets ! =  = null && this . enableSupportTickets ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableSupportTickets '  , Thrift . Type . BOOL , 7 )  ; %NWL%output . writeBool ( this . enableSupportTickets )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableSharedNotebooks ! =  = null && this . enableSharedNotebooks ! =  = undefined )  {%NWL%0
if ( options . resetOnFetch )  {%NWL%this . resetOnFetch = options . resetOnFetch ;%NWL%}%NWL%if ( options . uniqueAgainst )  {%NWL%this . uniqueAgainst = options . uniqueAgainst ;%NWL%}%NWL%if ( _ . isUndefined ( options . data ) && _ . isUndefined ( options . url )  )  {%NWL%this . _addIdColumn (  )  ;%NWL%}%NWL%if ( options . deferred )  {%NWL%this . deferred = options . deferred ; %NWL%1
this . cycles . push ( new Cycle ( cyc . rate , cyc . reverse , cyc . low , cyc . high )  )  ;%NWL%}%NWL%this . numColors = this . baseColors . length ; %NWL%this . numCycles = this . cycles . length ;%NWL%}  ,%NWL%copyColors : function ( source , dest )  {%NWL%for ( var idx = 0 , len = source . length ; idx < len ; idx +  +  )  {%NWL%if ( !dest [ idx ]  ) dest [ idx ]  = new Color (  )  ; %NWL%dest [ idx ]  . red = source [ idx ]  . red ; %NWL%dest [ idx ]  . green = source [ idx ]  . green ; %NWL%dest [ idx ]  . blue = source [ idx ]  . blue ; %NWL%8
exports . createWrapService = azureSb . createWrapService ; %NWL%var azureManagement = require (  ' azure - mgmt '  )  ; %NWL%exports . ManagementClient = azureManagement . ManagementClient ; %NWL%exports . createManagementClient = azureManagement . createManagementClient ; %NWL%var azureSqlMgmt = require (  ' azure - mgmt - sql '  )  ; %NWL%var SqlManagementService = azureSqlMgmt . SqlManagementService ; %NWL%exports . SqlManagementService = SqlManagementService ; %NWL%exports . createSqlManagementService = azureSqlMgmt . createSqlManagementService ; %NWL%var SqlService = azureSqlMgmt . SqlService ; %NWL%exports . SqlService = SqlService ; %NWL%exports . createSqlService = azureSqlMgmt . createSqlService ; %NWL%7
lodash . findLastKey = objects . findLastKey ; %NWL%lodash . has = objects . has ; %NWL%lodash . identity = utilities . identity ; %NWL%lodash . indexOf = arrays . indexOf ; %NWL%lodash . isArguments = objects . isArguments ; %NWL%lodash . isArray = isArray ; %NWL%lodash . isBoolean = objects . isBoolean ; %NWL%lodash . isDate = objects . isDate ; %NWL%lodash . isElement = objects . isElement ; %NWL%lodash . isEmpty = objects . isEmpty ; %NWL%lodash . isEqual = objects . isEqual ; %NWL%0
'  .  / appSettings '  ,%NWL%'  .  / effects / Effect '%NWL%]  ,%NWL%function ( _ , Backbone , BackstrappMarionette ,%NWL%BaseCollection , BaseModel , BaseController , BaseRouter ,%NWL%stackRegion , stackManager , appSettings , effect )  {%NWL%var ns = BackstrappMarionette ; %NWL%stackManager . init ( ns )  ; %NWL%appSettings . init ( ns )  ; %NWL%ns . Collection = BaseCollection ; %NWL%ns . Model = BaseModel ; %NWL%9
var defined = require (  ' defined '  )  ; %NWL%var Clip = require (  '  .  / lib / clip . js '  )  ; %NWL%module . exports = WF ; %NWL%inherits ( WF , EventEmitter )  ; %NWL%function WF ( opts )  {%NWL%var self = this ; %NWL%if ( ! ( this instanceof WF )  ) return new WF ( opts )  ; %NWL%if ( !opts ) opts =  {  }  ; %NWL%this . width = defined ( opts . width , 800 )  ; %NWL%this . height = defined ( opts . height , 100 )  ; %NWL%this . samples = defined ( opts . samples , 100 )  ; %NWL%9
}%NWL%var space = fill . space ; %NWL%switch ( fill . type )  {%NWL%case " linear "  : %NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeX " || space =  =  =  " shapeY "  )  {%NWL%fill = dojox . gfx . makeParameters ( dojox . gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeX "  )  {%NWL%var span = bbox . width ; %NWL%fill . x1 = bbox . x + span * fill . x1 / 100 ; %NWL%fill . x2 = bbox . x + span * fill . x2 / 100 ; %NWL%9
QUnit . module = function ( m )  {%NWL%currentModule = m +  '  :  '  ; %NWL%return QUnitModule . apply ( this , arguments )  ;%NWL%}  ; %NWL%global . module = QUnit . module ; %NWL%var QUnitExpect = QUnit . expect ; %NWL%QUnit . expect = function ( a )  {%NWL%expect = a ; %NWL%return QUnitExpect . apply ( this , arguments )  ;%NWL%}  ; %NWL%global . expect = QUnit . expect ; %NWL%4
if ( series . x && series . x . _hasCategories (  )  )  {%NWL%bCats = bCats . concat ( higherLevelData [ j ]  . xField )  ;%NWL%}%NWL%if ( series . y && series . y . _hasCategories (  )  )  {%NWL%bCats = bCats . concat ( higherLevelData [ j ]  . yField )  ;%NWL%}%NWL%bCatString = bCats . join (  " | "  )  ; %NWL%if ( aCatString =  =  = bCatString )  {%NWL%returnData [ i ]  . xField = higherLevelData [ j ]  . xField ; %NWL%returnData [ i ]  . xValue = higherLevelData [ j ]  . xValue ; %NWL%returnData [ i ]  . xCount = higherLevelData [ j ]  . xCount ; %NWL%8
crudOperations = crudOperation ; %NWL%this . clientApi = clientApi ; %NWL%this . crudOperation = crudOperation ; %NWL%this . actionEnd = __bind ( this . actionEnd , this )  ; %NWL%this . actionProcess = __bind ( this . actionProcess , this )  ; %NWL%this . tryAction = __bind ( this . tryAction , this )  ; %NWL%this . getTree = __bind ( this . getTree , this )  ; %NWL%this . removeAll = __bind ( this . removeAll , this )  ; %NWL%this . remove = __bind ( this . remove , this )  ; %NWL%this . updateOne = __bind ( this . updateOne , this )  ; %NWL%this . insert = __bind ( this . insert , this )  ; %NWL%3
this . clockStep = defaultValue ( this . clockStep , source . clockStep )  ; %NWL%this . multiplier = defaultValue ( this . multiplier , source . multiplier )  ;%NWL%}  ; %NWL%DataSourceClock . prototype . getValue = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new Clock (  )  ;%NWL%}%NWL%result . startTime = this . startTime ; %NWL%result . stopTime = this . stopTime ; %NWL%result . clockRange = this . clockRange ; %NWL%result . clockStep = this . clockStep ; %NWL%7
test (  ' stampit (  )  . enclose (  )  '  , function (  )  {%NWL%var obj = stampit (  )  . enclose ( function (  )  {%NWL%var secret =  ' foo '  ; %NWL%this . getSecret = function (  )  {%NWL%return secret ;%NWL%}  ;%NWL%}  )  . enclose ( function (  )  {%NWL%this . a =  ' a '  ;%NWL%}  )  . enclose (  {%NWL%bar : function bar (  )  {%NWL%this . b =  ' b '  ; %NWL%7
this . headers = options . headers || {  }  ; %NWL%this . log = options . log ; %NWL%if ( !this . log . serializers . client_res )  {%NWL%this . log = this . log . child (  {%NWL%serializers :  { client_res : bunyan . serializers . client_res }%NWL%}  )  ;%NWL%}%NWL%this . key = options . key ; %NWL%this . name = options . name || ' HttpClient '  ; %NWL%this . passphrase = options . passphrase ; %NWL%this . pfx = options . pfx ; %NWL%1
function VisualEntity (  )  {%NWL%VisualEntity . parent . constructor . call ( this )  ;%NWL%}  ; %NWL%VisualEntity . inheritsFrom ( Entity )  ; %NWL%VisualEntity . prototype . init = function ( params )  {%NWL%VisualEntity . parent . init . call ( this , params )  ; %NWL%this . x = params [  ' x '  ]  ; %NWL%this . y = params [  ' y '  ]  ; %NWL%this . z = params [  ' z '  ]  ; %NWL%this . width = params [  ' width '  ]  ; %NWL%this . height = params [  ' height '  ]  ; %NWL%6
}  )  ; %NWL%function MarkdownEditorView ( options )  {%NWL%this . _parent = options . parent ; %NWL%this . fileClient = options . fileService ; %NWL%this . metadata = options . metadata ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . contentTypeRegistry = options . contentTypeRegistry ; %NWL%this . commandRegistry = options . commandRegistry ; %NWL%this . progress = options . progressService ; %NWL%this . model = options . model ; %NWL%this . undoStack = options . undoStack ; %NWL%4
if ( settings =  = undefined )  {%NWL%settings =  {  }  ;%NWL%}%NWL%if ( !settings . closeOnDeactivate )  {%NWL%settings . closeOnDeactivate = viewModel . defaults . closeOnDeactivate ;%NWL%}%NWL%if ( !settings . beforeActivate )  {%NWL%settings . beforeActivate = viewModel . defaults . beforeActivate ;%NWL%}%NWL%if ( !settings . afterDeactivate )  {%NWL%settings . afterDeactivate = viewModel . defaults . afterDeactivate ; %NWL%4
Rivets . Binding =  ( function (  )  {%NWL%function Binding ( view , el , type , key , keypath , options )  {%NWL%var identifier , regexp , value , _ref ; %NWL%this . view = view ; %NWL%this . el = el ; %NWL%this . type = type ; %NWL%this . key = key ; %NWL%this . keypath = keypath ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%9
gameWorldObj . Cells  = gameWorld ;  /  / hack because this was written for clientside originally . sorry time is short :  /%NWL%return new GameWorldModelIso ( gameWorldObj , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )  ;%NWL%}%NWL%exports . update = GameWorldModelIso . prototype . update ; %NWL%exports . getAllVisibleCells = GameWorldModelIso . prototype . getAllVisibleCells ; %NWL%exports . getSortCellOfSprite = GameWorldModelIso . prototype . getSortCellOfSprite ; %NWL%exports . getRandomOnScreenCel = GameWorldModelIso . prototype . getRandomOnScreenCel ; %NWL%exports . getRandomOnScreenCellWorldValues = GameWorldModelIso . prototype . getRandomOnScreenCellWorldValues ; %NWL%exports . getVisibleCellFromWorldCell = GameWorldModelIso . prototype . getVisibleCellFromWorldCell ; %NWL%exports . getWorldCellFromVisibleCell = GameWorldModelIso . prototype . getWorldCellFromVisibleCell ; %NWL%exports . getWorldCellFromScreenCoord = GameWorldModelIso . prototype . getWorldCellFromScreenCoord ; %NWL%3
SWFUpload . speed . extendFile = function ( file , trackingList )  {%NWL%var tracking ; %NWL%if ( !file )  {%NWL%return file ;%NWL%}%NWL%if ( trackingList )  {%NWL%tracking = trackingList [ file . id ]  ;%NWL%}%NWL%if ( tracking )  {%NWL%file . currentSpeed = tracking . currentSpeed ; %NWL%file . averageSpeed = tracking . averageSpeed ; %NWL%9
if ( args . marketingUrl ! =  = undefined )  {%NWL%this . marketingUrl = args . marketingUrl ;%NWL%}%NWL%if ( args . supportUrl ! =  = undefined )  {%NWL%this . supportUrl = args . supportUrl ;%NWL%}%NWL%if ( args . accountEmailDomain ! =  = undefined )  {%NWL%this . accountEmailDomain = args . accountEmailDomain ;%NWL%}%NWL%if ( args . enableFacebookSharing ! =  = undefined )  {%NWL%this . enableFacebookSharing = args . enableFacebookSharing ; %NWL%1
}%NWL%}%NWL%var idValue = valueValue [  ' id '  ]  ; %NWL%if ( idValue ! =  = null && idValue ! =  = undefined )  {%NWL%var idInstance = idValue ; %NWL%featureResponseInstance . id = idInstance ;%NWL%}%NWL%var typeValue = valueValue [  ' type '  ]  ; %NWL%if ( typeValue ! =  = null && typeValue ! =  = undefined )  {%NWL%var typeInstance = typeValue ; %NWL%featureResponseInstance . type = typeInstance ; %NWL%5
var c = item . c || item . p ; %NWL%var gridX1 = Math . floor ( c . x / this . options . gridW )  ,%NWL%gridY1 = Math . floor ( c . y / this . options . gridH )  ,%NWL%gridX2 = Math . floor (  ( c . x + c . w )  / this . options . gridW )  ,%NWL%gridY2 = Math . floor (  ( c . y + c . h )  / this . options . gridH )  ,%NWL%grid = item . grid ; %NWL%if ( grid . X1 ! =  = gridX1 || grid . X2 ! =  = gridX2 ||%NWL%grid . Y1 ! =  = gridY1 || grid . Y2 ! =  = gridY2 )  {%NWL%if ( grid . X1 ! =  = void 0 )  { this . delGrid ( item )  ;  }%NWL%grid . X1 = gridX1 ; %NWL%grid . X2 = gridX2 ; %NWL%9
if ( helper . isString ( options . autoWatch )  )  {%NWL%options . autoWatch = options . autoWatch =  =  =  ' true '  ;%NWL%}%NWL%if ( helper . isString ( options . colors )  )  {%NWL%options . colors = options . colors =  =  =  ' true '  ;%NWL%}%NWL%if ( helper . isString ( options . logLevel )  )  {%NWL%options . logLevel = constant [  ' LOG_ '  + options . logLevel . toUpperCase (  )  ] || constant . LOG_DISABLE ;%NWL%}%NWL%if ( helper . isString ( options . singleRun )  )  {%NWL%options . singleRun = options . singleRun =  =  =  ' true '  ; %NWL%1
duration = 0 ;%NWL%}%NWL%if ( typeof settings =  =  ' function '  )%NWL%settings =  { onAfter : settings }  ; %NWL%settings = $ . extend (  {  }  , $scrollTo . defaults , settings )  ; %NWL%duration = duration || settings . speed || settings . duration ; %NWL%settings . queue = settings . queue && settings . axis . length > 1 ; %NWL%if ( settings . queue )%NWL%duration /  = 2 ; %NWL%settings . offset = both ( settings . offset )  ; %NWL%settings . over = both ( settings . over )  ; %NWL%9
}%NWL%}  ; %NWL%var padHex = function ( sNumber )  {%NWL%if ( sNumber . length =  =  = 1 )  {%NWL%sNumber =  " 0 "  + sNumber ;%NWL%}%NWL%return sNumber ;%NWL%}  ; %NWL%var normalizeFontWeight = function ( oCurrentTestData )  {%NWL%oCurrentTestData . sActualValue = replaceFontWeightKeywords ( oCurrentTestData . sActualValue )  ; %NWL%oCurrentTestData . sRule = replaceFontWeightKeywords ( oCurrentTestData . sRule )  ; %NWL%9
fs . readFile (  [ workDir ,  ' ember_runner_config . json '  ]  . join (  '  /  '  )  , function ( err , file )  {%NWL%if ( err ) return callback (  " Error no ember_runner_config . json file found "  )  ; %NWL%devBuildInfo = JSON . parse ( file )  ; %NWL%if ( devBuildInfo . apps )  {%NWL%for ( key in devBuildInfo . apps )  {%NWL%buildInfo . apps [ key ]  = devBuildInfo . apps [ key ]  ;%NWL%}%NWL%}%NWL%if ( devBuildInfo . vendors )  {%NWL%for ( key in devBuildInfo . vendors )  {%NWL%buildInfo . vendors [ key ]  = devBuildInfo . vendors [ key ]  ; %NWL%5
}  ; %NWL%Engine . Request =  {%NWL%parse : function ( req )  {%NWL%var request =  {  }  ,%NWL%matches =  [  ]  ; %NWL%request . scheme = request . scheme ; %NWL%request . version =  ( matches . length ) ? [  ( matches [ 2 ]  * 1 )  ,  ( matches [ 3 ]  * 1 )  ]  :  [ 0 , 0 ]  ; %NWL%request . method = req . method ; %NWL%request . scriptName = req . scriptName ; %NWL%request . pathInfo = req . pathInfo ; %NWL%request . queryString = req . queryString ; %NWL%7
this . handleColor = args . handleColor || ' red '  ; %NWL%this . curveLabels =  ( typeof args . curveLabels =  =  =  ' boolean '  ) ? args . curveLabels : false ; %NWL%this . terminalPointStyle = args . terminalPointStyle || ' rect '  ; %NWL%this . paintTerminalPoints = args . paintTerminalPoints || ' all '  ; %NWL%this . midPointStyle = args . midPointStyle || ' circle '  ; %NWL%this . terminalPointSize = args . terminalPointSize || 16 ; %NWL%this . midPointSize = args . midPointSize || 8 ; %NWL%this . terminalPointColor = args . terminalPointColor || this . handleColor ; %NWL%this . midPointColor = args . midPointColor || this . handleColor ; %NWL%this . terminalPointFill = args . terminalPointFill || null ; %NWL%this . midPointFill = args . midPointFill || null ; %NWL%9
this . tabHost . performLayout ( children )  ;%NWL%}  ; %NWL%dockspawn . FillDockContainer . prototype . destroy = function (  )%NWL%{%NWL%if ( removeNode ( this . element )  )%NWL%delete this . element ;%NWL%}  ; %NWL%dockspawn . FillDockContainer . prototype . saveState = function ( state )%NWL%{%NWL%state . width = this . width ; %NWL%state . height = this . height ; %NWL%9
canShowFPSCounter : false ,%NWL%canContinuouslyPaint : false%NWL%}%NWL%WebInspector . Settings = function (  )%NWL%{%NWL%this . _eventSupport = new WebInspector . Object (  )  ; %NWL%this . colorFormat = this . createSetting (  " colorFormat "  ,  " original "  )  ; %NWL%this . consoleHistory = this . createSetting (  " consoleHistory "  ,  [  ]  )  ; %NWL%this . debuggerEnabled = this . createSetting (  " debuggerEnabled "  , false )  ; %NWL%this . domWordWrap = this . createSetting (  " domWordWrap "  , true )  ; %NWL%this . profilerEnabled = this . createSetting (  " profilerEnabled "  , false )  ; %NWL%8
_yuitest_coverage [  " build / graphics - vml - default / graphics - vml - default . js "  ]  . coveredLines = 8 ; %NWL%_yuitest_coverage [  " build / graphics - vml - default / graphics - vml - default . js "  ]  . coveredFunctions = 1 ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 1 )  ; %NWL%YUI . add (  ' graphics - vml - default '  , function ( Y , NAME )  {%NWL%_yuitest_coverfunc (  " build / graphics - vml - default / graphics - vml - default . js "  ,  "  ( anonymous 1 )  "  , 1 )  ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 3 )  ; %NWL%Y . Graphic = Y . VMLGraphic ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 4 )  ; %NWL%Y . Shape = Y . VMLShape ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 5 )  ; %NWL%Y . Circle = Y . VMLCircle ; %NWL%6
returnData [ i ]  . yCount = higherLevelData [ j ]  . yCount ; %NWL%returnData [ i ]  . zField = higherLevelData [ j ]  . zField ; %NWL%returnData [ i ]  . zValue = higherLevelData [ j ]  . zValue ; %NWL%returnData [ i ]  . zCount = higherLevelData [ j ]  . zCount ; %NWL%returnData [ i ]  . x = higherLevelData [ j ]  . x ; %NWL%returnData [ i ]  . y = higherLevelData [ j ]  . y ; %NWL%returnData [ i ]  . r = higherLevelData [ j ]  . r ; %NWL%returnData [ i ]  . xOffset = higherLevelData [ j ]  . xOffset ; %NWL%returnData [ i ]  . yOffset = higherLevelData [ j ]  . yOffset ; %NWL%returnData [ i ]  . width = higherLevelData [ j ]  . width ; %NWL%returnData [ i ]  . height = higherLevelData [ j ]  . height ; %NWL%0
env . ajaxAsync = false ; %NWL%env . sync = Backbone . sync ; %NWL%env . ajax = Backbone . ajax ; %NWL%env . countEvents = function ( eventEmitter )  {%NWL%var eventCount =  {  }  ; %NWL%eventEmitter . on (  ' all '  , function ( e )  {%NWL%eventCount [ e ]  = eventCount [ e ] ? eventCount [ e ]  + 1 : 1 ;%NWL%}  )  ; %NWL%return eventCount ;%NWL%}  ; %NWL%env . emulateHTTP = Backbone . emulateHTTP ; %NWL%1
}  ,%NWL%triggerEvent : function ( type , evt )  {%NWL%var listeners = this . listeners [ type ]  ; %NWL%if ( !listeners || listeners . length =  = 0 )  {%NWL%return undefined ;%NWL%}%NWL%if ( evt =  = null )  {%NWL%evt =  {  }  ;%NWL%}%NWL%evt . object = this . object ; %NWL%evt . element = this . element ; %NWL%9
_width = width / 2 ; %NWL%_height = height ; %NWL%renderer . setSize ( width , height )  ;%NWL%}  ; %NWL%this . render = function ( scene , camera )  {%NWL%scene . updateMatrixWorld (  )  ; %NWL%if ( camera . parent =  =  = undefined ) camera . updateMatrixWorld (  )  ; %NWL%camera . matrixWorld . decompose ( _position , _quaternion , _scale )  ; %NWL%_cameraL . fov = camera . fov ; %NWL%_cameraL . aspect = 0 . 5 * camera . aspect ; %NWL%_cameraL . near = camera . near ; %NWL%8
if ( !guiderElement . length )  {%NWL%guiderElement = $ ( guiders . _htmlSkeleton )  ;%NWL%}%NWL%myGuider . elem = guiderElement ; %NWL%if ( typeof myGuider . classString ! =  =  " undefined " && myGuider . classString ! =  = null )  {%NWL%myGuider . elem . addClass ( myGuider . classString )  ;%NWL%}%NWL%if ( Number ( myGuider . width )  =  =  = myGuider . width )  {%NWL%myGuider . width = String ( myGuider . width )  +  " px "  ;%NWL%}%NWL%if ( Number ( myGuider . maxWidth )  =  =  = myGuider . maxWidth )  {%NWL%7
this . rawNode . setAttribute (  " rx "  , this . shape . r )  ;%NWL%}%NWL%return this ; 	 /  / self%NWL%}%NWL%}  )  ; %NWL%g . Rect . nodeType =  " rect "  ; %NWL%g . Ellipse = gs . Ellipse ; %NWL%g . Ellipse . nodeType =  " ellipse "  ; %NWL%g . Circle = gs . Circle ; %NWL%g . Circle . nodeType =  " circle "  ; %NWL%g . Line = gs . Line ; %NWL%6
ensure ( wrapper )  ; %NWL%return wrapper ;%NWL%}  ; %NWL%exports . Loader = CustomLoader ; %NWL%function HookedPlainTextConsole ( hook , print , innerID )  {%NWL%this . log = hook . bind ( null ,  " log "  , innerID )  ; %NWL%this . info = hook . bind ( null ,  " info "  , innerID )  ; %NWL%this . warn = hook . bind ( null ,  " warn "  , innerID )  ; %NWL%this . error = hook . bind ( null ,  " error "  , innerID )  ; %NWL%this . debug = hook . bind ( null ,  " debug "  , innerID )  ; %NWL%this . exception = hook . bind ( null ,  " exception "  , innerID )  ; %NWL%5
GuiCanvas . prototype . generateId = function (  )  {%NWL%return this . className + uniqueId (  )  ;%NWL%}  ; %NWL%GuiCanvas . prototype . create = function ( src )  {%NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%this . contex = canvas . getContext (  " 2d "  )  ; %NWL%this . contex . imageSmoothingEnabled = false ; %NWL%this . contex . webkitImageSmoothingEnabled = false ; %NWL%this . contex . mozImageSmoothingEnabled = false ; %NWL%canvas . id = this . id ; %NWL%canvas . width = this . width ; %NWL%9
selfLiteral . filename = media . filename ; %NWL%var selfSelector = new nodes . Selector ( selfLiteral )  ; %NWL%selfSelector . lineno = media . lineno ; %NWL%selfSelector . filename = media . filename ; %NWL%selfSelector . val = selfLiteral . val ; %NWL%var propertyGroup = new nodes . Group ; %NWL%propertyGroup . lineno = media . lineno ; %NWL%propertyGroup . filename = media . filename ; %NWL%var propertyBlock = new nodes . Block ( media . block , propertyGroup )  ; %NWL%propertyBlock . lineno = media . lineno ; %NWL%propertyBlock . filename = media . filename ; %NWL%9
e . appendChild ( table )  ; %NWL%if ( jQuery . browser . msie ) table . onclick = ieLinkBypass ; %NWL%e . style . overflow =  ' hidden '  ;%NWL%}%NWL%function ieLinkBypass (  )  {%NWL%if ( !this . parentNode . onclick ) this . parentNode . click (  )  ;%NWL%}%NWL%function changeInput ( e )  {%NWL%var a1 = document . createElement (  " a "  )  ; %NWL%a1 . id = e . id ; %NWL%a1 . className = e . className ; %NWL%9
initCanvas = function (  )  {%NWL%canvas = document . createElement (  " canvas "  )  ; %NWL%canvas . style . display =  " none "  ; %NWL%var b = document . getElementsByTagName (  " body "  )  [ 0 ]  ; %NWL%b . appendChild ( canvas )  ; %NWL%ctx = canvas . getContext (  " 2d "  )  ;%NWL%}  ,%NWL%loadImageById = function ( id )  {%NWL%var img = document . getElementById ( id )  ; %NWL%canvas . width = img . width ; %NWL%canvas . height = img . height ; %NWL%9
exports . create = function createSession ( req , res , next )  {%NWL%User . authenticate ( req . body . email , req . body . password , function ( err , user )  {%NWL%if ( !user )  {%NWL%res . send ( 404 ,  { message :  ' No such username / password '  }  )  ;%NWL%} else {%NWL%req . session . passport . user = user . id ; %NWL%res . send ( user )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%exports . get = function getSession ( req , res , next )  {%NWL%0
}%NWL%}%NWL%}%NWL%catch ( e )  {  }%NWL%obj . tId = o . tId ; %NWL%obj . status =  ( o . conn . status =  = 1223 ) ?204 : o . conn . status ; %NWL%obj . statusText =  ( o . conn . status =  = 1223 ) ? " No Content "  : o . conn . statusText ; %NWL%obj . getResponseHeader = headerObj ; %NWL%obj . getAllResponseHeaders = headerStr ; %NWL%obj . responseText = o . conn . responseText ; %NWL%obj . responseXML = o . conn . responseXML ; %NWL%9
this . borderColor = options . borderColor || ( Stimulus . palettes [ this . type ] ?%NWL%Stimulus . palettes [ this . type ]  . getColor (  )  :  [ 220 , 220 , 220 ]  )  ; %NWL%this . boxShadowColor = options . boxShadowColor || ( Stimulus . boxShadowColors [ this . type ] ?%NWL%Stimulus . boxShadowColors [ this . type ]  :  [ 200 , 200 , 200 ]  )  ; %NWL%this . borderWidth = typeof options . borderWidth ! =  =  ' undefined ' ?%NWL%options . borderWidth : this . width / Utils . getRandomNumber ( 2 , 8 )  ; %NWL%this . borderStyle = typeof options . borderStyle ! =  =  ' undefined ' ?%NWL%options . borderStyle : Stimulus . borderPalette . getBorder (  )  ; %NWL%this . borderRadius = typeof options . borderRadius ! =  =  ' undefined ' ?%NWL%options . borderRadius : 100 ; %NWL%this . boxShadowSpread = typeof options . boxShadowSpread ! =  =  ' undefined ' ?%NWL%4
dstlo ! =  = next_dstlo || dsthi ! =  = next_dsthi )  {%NWL%var next_x = Math . log ( Math . abs ( srchi / srclo )  )  ; %NWL%var x_slope =  ( next_x - x )  * this . rate . slopeFactor ; %NWL%for ( i = 0 ; i < inNumSamples ;  +  + i )  {%NWL%_in = inIn [ i ] || 0 . 001 ; %NWL%out [ i ]  = Math . log ( Math . abs ( _in / srclo )  )  / x *  ( dsthi - dstlo )  + dstlo ; %NWL%x +  = x_slope ;%NWL%}%NWL%this . _srclo = next_srclo ; %NWL%this . _srchi = next_srchi ; %NWL%this . _dstlo = next_dstlo ; %NWL%8
this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertUndefinedScenario = function assertUndefinedScenario (  )  {%NWL%this . assertPartialOutput (  " 1 scenario (  "  + this . color . format (  " undefined "  ,  " 1 undefined "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertScenarioReportedAsFailing = function assertScenarioReportedAsFailing ( scenarioName )  {%NWL%this . assertPartialOutput (  " # Scenario :  "  + scenarioName , this . runOutput )  ; %NWL%this . assertFailure (  )  ;%NWL%}  ; %NWL%proto . assertScenarioNotReportedAsFailing = function assertScenarioNotReportedAsFailing ( scenarioName )  {%NWL%6
var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%5
_attachments =  [  ]  ; %NWL%_filename_suffix = 0 ;%NWL%}  , false )  ; %NWL%event . on (  " OutsideMessageReceived "  , function ( message )  {%NWL%var numRecipients = 0 ,%NWL%i = 0 ,%NWL%recipients =  [  ]  ,%NWL%recipientsStatus =  {  }  ,%NWL%strRecipients = document . getElementById (  " messaging - recipients "  )  . value ; %NWL%recipientsStatus . id = message . id ; %NWL%recipientsStatus . msg = message . msg ; %NWL%9
}  ; %NWL%_ = require (  ' underscore '  )  ; %NWL%Utils = require (  '  .  .  / utils / utils '  )  . Utils ; %NWL%BaseParams =  ( function (  )  {%NWL%function BaseParams (  )  {%NWL%this . checkReqParamsOk = __bind ( this . checkReqParamsOk , this )  ; %NWL%this . getPostValue = __bind ( this . getPostValue , this )  ; %NWL%this . getTableName = __bind ( this . getTableName , this )  ; %NWL%this . getLimit = __bind ( this . getLimit , this )  ; %NWL%this . getOffset = __bind ( this . getOffset , this )  ; %NWL%this . getGroup = __bind ( this . getGroup , this )  ; %NWL%5
this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchMove = function (  )  { FastClick . prototype . onTouchMove . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchEnd = function (  )  { FastClick . prototype . onTouchEnd . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchCancel = function (  )  { FastClick . prototype . onTouchCancel . apply ( self , arguments )  ;  }  ; %NWL%6
for ( var i = 0 ; i < state . astype . length ; i +  +  )  {%NWL%copystate . astype +  = state . astype [ i ]  ; %NWL%copystate . astype +  =  "  ,  "  ;%NWL%}%NWL%if ( copystate . astype . length )  {%NWL%copystate . astype = copystate . astype . slice ( 0 ,  - 1 )  ;%NWL%}%NWL%}%NWL%if ( state . asfolder . length ) copystate . asfolder = state . asfolder ; %NWL%if ( state . asdefaultassignee . length ) copystate . asdefaultassignee = state . asdefaultassignee ; %NWL%if ( state . asfeature . length ) copystate . asfeature = state . asfeature ; %NWL%8
AnaglyphArcRotateCamera . prototype . _update = function (  )  {%NWL%this . _updateCamera ( this . _leftCamera )  ; %NWL%this . _updateCamera ( this . _rightCamera )  ; %NWL%this . _leftCamera . alpha = this . alpha - this . _eyeSpace ; %NWL%this . _rightCamera . alpha = this . alpha + this . _eyeSpace ; %NWL%_super . prototype . _update . call ( this )  ;%NWL%}  ; %NWL%AnaglyphArcRotateCamera . prototype . _updateCamera = function ( camera )  {%NWL%camera . beta = this . beta ; %NWL%camera . radius = this . radius ; %NWL%camera . minZ = this . minZ ; %NWL%8
function isWebUrl ( url )  {%NWL%return re . exec ( url )  ;%NWL%}%NWL%function log (  )  {%NWL%if ( debug ) console . log . apply ( console , Array . prototype . slice . call ( arguments )  )%NWL%}%NWL%function ShortcutKey ( properties )  {%NWL%this . ctrl = properties . ctrl || false ; %NWL%this . shift = properties . shift || false ; %NWL%this . alt = properties . alt || false ; %NWL%this . meta = properties . meta || false ; %NWL%7
}%NWL%opts . position = opts . position || {  }  ; %NWL%opts . position . adjust = opts . position . adjust || {  }  ; %NWL%if ( opts . position . adjust . mouse =  =  = undefined )  {%NWL%opts . position . adjust . mouse = false ;%NWL%}%NWL%opts . show = opts . show || {  }  ; %NWL%if ( !opts . show . event )  {%NWL%opts . show . event =  ' tap '  ;%NWL%}%NWL%opts . hide = opts . hide || {  }  ; %NWL%1
define (  " dojo / dnd / move "  ,  [  " dojo "  ,  " dojo / dnd / Mover "  ,  " dojo / dnd / Moveable "  ]  , function ( dojo )  {%NWL%dojo . declare (  " dojo . dnd . move . constrainedMoveable "  , dojo . dnd . Moveable ,  {%NWL%constraints : function (  )  {  }  ,%NWL%within : false ,%NWL%markupFactory : function ( params , node )  {%NWL%return new dojo . dnd . move . constrainedMoveable ( node , params )  ;%NWL%}  ,%NWL%constructor : function ( node , params )  {%NWL%if ( !params )  { params =  {  }  ;  }%NWL%this . constraints = params . constraints ; %NWL%this . within = params . within ; %NWL%9
this . _collisionType = collisionType || 0 ; %NWL%this . _group = group || 0 ;%NWL%}  ,%NWL%updateShape : function ( shape )  {%NWL%if ( shape instanceof cp . Shape )  {%NWL%shape . collision_type = this . _collisionType ; %NWL%shape . group = this . _group ;%NWL%} else if ( shape instanceof Box2D . b2FilterData )  {%NWL%var filter = new Box2D . b2FilterData (  )  ; %NWL%filter . categoryBits = this . _categoryBits ; %NWL%filter . groupIndex = this . _groupIndex ; %NWL%9
} else if ( _ . isArray ( value )  )  {%NWL%value = _ . map ( value , function ( v )  {%NWL%return "  '  "  + v +  "  '  "  ;%NWL%}  )  . join (  '  ,  '  )  ;%NWL%} else {%NWL%value =  "  '  "  + value +  "  '  "  ;%NWL%}%NWL%return ' check (  '  + this . formatter . wrap ( this . args [ 0 ]  )  +  ' in (  '  + value +  '  )  )  '  ;%NWL%}  ; %NWL%client . ColumnBuilder = ColumnBuilder_Oracle ; %NWL%client . ColumnCompiler = ColumnCompiler_Oracle ; %NWL%9
} else {%NWL%out [ key ]  = value ;%NWL%}%NWL%}%NWL%}%NWL%return out ;%NWL%}  ; %NWL%exports . TLSSocket = require (  ' _tls_wrap '  )  . TLSSocket ; %NWL%exports . Server = require (  ' _tls_wrap '  )  . Server ; %NWL%exports . createServer = require (  ' _tls_wrap '  )  . createServer ; %NWL%exports . connect = require (  ' _tls_wrap '  )  . connect ; %NWL%7
this . size = Math . floor ( Math . min ( minWidth , minHeight )  ) || 1 ; %NWL%this . updatePatterns (  )  ; %NWL%return this . size ;%NWL%}  ,%NWL%updatePatterns : function (  )  {%NWL%var canvas , backgroundImage ; %NWL%canvas = document . createElement (  ' canvas '  )  ; %NWL%canvas . setAttribute (  ' width '  , String ( this . size )  )  ; %NWL%canvas . setAttribute (  ' height '  , String ( this . size )  )  ; %NWL%this . on = this . _getTileForColor ( canvas , this . colorScheme . on )  ; %NWL%this . off = this . _getTileForColor ( canvas , this . colorScheme . off )  ; %NWL%9
instance . _isFunction = function ( obj )  {%NWL%return !! ( obj && obj . constructor && obj . call && obj . apply )  ;%NWL%}  ; %NWL%var AnimationContext =  ( function ( config )  {%NWL%var animationContextInstance = this ; %NWL%animationContextInstance . initializer = function ( config )  {%NWL%animationContextInstance . behaviorTargetList = config . behaviorTargetList || [  ]  ; %NWL%animationContextInstance . nodeHelper = config . nodeHelper ; %NWL%animationContextInstance . animationEndEvent = config . animationEndEvent ; %NWL%animationContextInstance . behavior = config . behavior ; %NWL%animationContextInstance . after = config . after ; %NWL%7
var next = function ( err , ok )  {%NWL%if ( !err && ok )%NWL%res . push (  [ i , x ]  )  ; %NWL%arguments [ 0 ]  = null ;  /  / discard errors%NWL%self . apply ( self , arguments )  ;%NWL%}  ; %NWL%next . stack = self . stack ; %NWL%next . stack_ = self . stack_ ; %NWL%next . vars = self . vars ; %NWL%next . args = self . args ; %NWL%next . error = self . error ; %NWL%6
exports . CP850  = exports . CP850_GENERAL_CI ; %NWL%exports . CP852  = exports . CP852_GENERAL_CI ; %NWL%exports . CP932  = exports . CP932_JAPANESE_CI ; %NWL%exports . DEC8  = exports . DEC8_SWEDISH_CI ; %NWL%exports . EUCJPMS  = exports . EUCJPMS_JAPANESE_CI ; %NWL%exports . EUCKR  = exports . EUCKR_KOREAN_CI ; %NWL%exports . GB2312  = exports . GB2312_CHINESE_CI ; %NWL%exports . GBK   = exports . GBK_CHINESE_CI ; %NWL%exports . GEOSTD8  = exports . GEOSTD8_GENERAL_CI ; %NWL%exports . GREEK  = exports . GREEK_GENERAL_CI ; %NWL%exports . HEBREW  = exports . HEBREW_GENERAL_CI ; %NWL%0
var client = clients [ i ]  ; %NWL%if ( client . id =  =  = id )  {%NWL%return done ( null , client )  ;%NWL%}%NWL%}%NWL%return done ( null , null )  ;%NWL%}  ; %NWL%exports . findByClientId = function ( clientId , done )  {%NWL%for ( var i = 0 , len = clients . length ; i < len ; i +  +  )  {%NWL%var client = clients [ i ]  ; %NWL%if ( client . clientId =  =  = clientId )  {%NWL%1
}  )  )  ; %NWL%messages . urlRegExp = this . urlRegExp ; %NWL%messages . id = dijit . getUniqueId ( this . editor . id )  ; %NWL%this . _uniqueId = messages . id ; %NWL%this . _setContent ( dropDown . title +%NWL%"  < div style =  ' border - bottom : 1px black solid ; padding - bottom : 2pt ; margin - bottom : 4pt '  >  <  / div >  "  +%NWL%dojo . string . substitute ( this . linkDialogTemplate , messages )  )  ; %NWL%dropDown . startup (  )  ; %NWL%this . _urlInput = dijit . byId ( this . _uniqueId +  " _urlInput "  )  ; %NWL%this . _textInput = dijit . byId ( this . _uniqueId +  " _textInput "  )  ; %NWL%this . _setButton = dijit . byId ( this . _uniqueId +  " _setButton "  )  ; %NWL%8
parameters . body = data . body ; %NWL%break ; %NWL%case " link "  : %NWL%parameters . title = data . title ; %NWL%parameters . url = data . url ; %NWL%if ( data . body )  {%NWL%parameters . body = data . body ;%NWL%}%NWL%break ; %NWL%case " address "  : %NWL%parameters . name = data . name ; %NWL%0
this . bAnd = sOperator ;%NWL%} else if ( jQuery . type ( sOperator )  =  =  =  " function "  )  {%NWL%this . fnTest = sOperator ;%NWL%} else {%NWL%this . sOperator = sOperator ;%NWL%}%NWL%this . oValue1 = oValue1 ; %NWL%this . oValue2 = oValue2 ;%NWL%}%NWL%this . oValue1 = this . _normalizeValue ( this . oValue1 )  ; %NWL%this . oValue2 = this . _normalizeValue ( this . oValue2 )  ; %NWL%9
dojo . require (  " dojo . dnd . Source "  )  ; %NWL%dojo . require (  " dojo . dnd . Manager "  )  ; %NWL%dojo . require (  " dojox . layout . dnd . Avatar "  )  ; %NWL%dojo . declare (  " dojox . layout . dnd . PlottedDnd "  ,  [ dojo . dnd . Source ]  ,  {%NWL%GC_OFFSET_X : dojo . dnd . manager (  )  . OFFSET_X ,%NWL%GC_OFFSET_Y : dojo . dnd . manager (  )  . OFFSET_Y ,%NWL%constructor : function ( node , params )  {%NWL%this . childBoxes 		 = null ; %NWL%this . dropIndicator		 = new dojox . layout . dnd . DropIndicator (  " dndDropIndicator "  ,  " div "  )  ; %NWL%this . withHandles 		 = params . withHandles ; %NWL%this . handleClasses	 	 = params . handleClasses ; %NWL%9
if ( id )  {%NWL%this . id = id ;%NWL%} else {%NWL%if ( props && props . id )  {%NWL%this . id = template ( props . id , options )  ;%NWL%}%NWL%}%NWL%this . info = sensorInfo ; %NWL%this . options =  _ . defaults ( options || {  }  , sensorInfo . options )  ; %NWL%this . model = sensorInfo . model ; %NWL%this . device = sensorInfo . device ; %NWL%9
"  ,  "  +%NWL%util . inspect ( this . lineNumber )  +%NWL%"  )  "  ;%NWL%}%NWL%MarkdownHelpers . mk_block = function ( block , trail , line )  {%NWL%if ( arguments . length =  =  = 1 )%NWL%trail =  " \n\n "  ; %NWL%var s = new String ( block )  ; %NWL%s . trailing = trail ; %NWL%s . inspect = mk_block_inspect ; %NWL%s . toSource = mk_block_toSource ; %NWL%9
var clonedInput = focusInput . cloneNode ( true )  ; %NWL%clonedInput . value = focusInput . value ; %NWL%clonedInput . classList . add (  ' cloned - text - input '  )  ; %NWL%clonedInput . readOnly = true ; %NWL%if ( focusInput . isContentEditable )  {%NWL%clonedInput . contentEditable = focusInput . contentEditable ; %NWL%clonedInput . innerHTML = focusInput . innerHTML ;%NWL%}%NWL%focusInput . parentElement . insertBefore ( clonedInput , focusInput )  ; %NWL%focusInput . classList . add (  ' previous - input - focus '  )  ; %NWL%clonedInput . scrollTop = focusInput . scrollTop ; %NWL%1
if ( !this . emitting && particles . length =  =  = 0 ) this . playing = false ;%NWL%}  ; %NWL%Emitter2D . prototype . toJSON = function ( json )  {%NWL%json = Class . prototype . toJSON . call ( this , json )  ; %NWL%json . type = 1 ; %NWL%json . positionType = this . positionType ; %NWL%json . velocityType = this . velocityType ; %NWL%json . material = this . material ? this . material . name : undefined ; %NWL%json . position = this . position . toJSON ( json . position )  ; %NWL%json . positionSpread = this . positionSpread . toJSON ( json . positionSpread )  ; %NWL%json . positionRadius = this . positionRadius ; %NWL%5
exports . QueueService = QueueService ; %NWL%exports . createQueueService = function ( storageAccountOrConnectionString , storageAccessKey , host , authenticationProvider )  {%NWL%return new QueueService ( storageAccountOrConnectionString , storageAccessKey , host , authenticationProvider )  ;%NWL%}  ; %NWL%var azureSb = require (  ' azure - sb '  )  ; %NWL%var ServiceBusService = azureSb . ServiceBusService ; %NWL%exports . ServiceBusService = ServiceBusService ; %NWL%exports . createServiceBusService = azureSb . createServiceBusService ; %NWL%var NotificationHubService = azureSb . NotificationHubService ; %NWL%exports . NotificationHubService = NotificationHubService ; %NWL%exports . createNotificationHubService = azureSb . createNotificationHubService ; %NWL%7
value :  ' sanitizeModule '  ,%NWL%name :  ' angular - sanitize . js '  ,%NWL%checked : false%NWL%}%NWL%]%NWL%}%NWL%]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%var hasMod = function ( mod )  { return props . modules . indexOf ( mod ) ! =  =  - 1 ;  }  ; %NWL%this . resourceModule = hasMod (  ' resourceModule '  )  ; %NWL%this . cookiesModule = hasMod (  ' cookiesModule '  )  ; %NWL%9
}  )  (  )  ; %NWL%this . promise = deferred . promise ; %NWL%return this ;%NWL%}  ,%NWL%stop : function (  )  {%NWL%$timeout . cancel ( this . timeoutId )  ; %NWL%this . timeoutId = null ;%NWL%}  ,%NWL%update : function ( opts )  {%NWL%opts . intevral = opts . intevral || this . opts . intevral ; %NWL%opts . params = opts . params || this . opts . params ; %NWL%9
var scrollTop = doc . documentElement . scrollTop || doc . body . scrollTop ; %NWL%var scrollLeft = doc . documentElement . scrollLeft || doc . body . scrollLeft ; %NWL%ret . x = box . left + scrollLeft ; %NWL%ret . y = box . top + scrollTop ; %NWL%ret . width = box . right - box . left ; %NWL%ret . height = box . bottom - box . top ;%NWL%} else if ( doc . getBoxObjectFor )  {  /  / gecko%NWL%box = doc . getBoxObjectFor ( el )  ; %NWL%ret . x = box . x ; %NWL%ret . y = box . y ; %NWL%ret . width = box . width ; %NWL%9
this . tbBlue  = this . $getLayoutNode (  " main "  ,  " blue "  , this . $ext )  ; %NWL%this . tbHue   = this . $getLayoutNode (  " main "  ,  " hue "  , this . $ext )  ; %NWL%this . tbSatern  = this . $getLayoutNode (  " main "  ,  " satern "  , this . $ext )  ; %NWL%this . tbLuminance = this . $getLayoutNode (  " main "  ,  " luminance "  , this . $ext )  ; %NWL%this . tbHexColor  = this . $getLayoutNode (  " main "  ,  " hex "  , this . $ext )  ; %NWL%var _self = this ; %NWL%this . tbHexColor . onchange = function (  )  {%NWL%_self . setValue ( this . value ,  " RGBHEX "  )  ;%NWL%}  ; %NWL%this . shower = this . $getLayoutNode (  " main "  ,  " shower "  , this . $ext )  ; %NWL%this . bar1  = this . $getLayoutNode (  " main "  ,  " bar1 "  , this . $ext )  ; %NWL%9
if ( this . options . emptyValue )  {%NWL%if ( address . addressLine1 =  = this . options . emptyValue . addressLine1 )  {%NWL%address . addressLine1 =  '  '  ;%NWL%}%NWL%if ( address . addressLine2 =  = this . options . emptyValue . addressLine2 )  {%NWL%address . addressLine2 =  '  '  ;%NWL%}%NWL%if ( address . city =  = this . options . emptyValue . city )  {%NWL%address . city =  '  '  ;%NWL%}%NWL%if ( address . state =  = this . options . emptyValue . state )  {%NWL%1
}  ; %NWL%params . push ( paramInfo )  ; %NWL%paramInfo . types = getTypes ( param . type . names )  ; %NWL%if ( typeof param . variable =  =  ' boolean '  )  {%NWL%paramInfo . variable = param . variable ;%NWL%}%NWL%if ( typeof param . optional =  =  ' boolean '  )  {%NWL%paramInfo . optional = param . optional ;%NWL%}%NWL%if ( typeof param . nullable =  =  ' boolean '  )  {%NWL%paramInfo . nullable = param . nullable ; %NWL%4
tagName :  ' li '  ,%NWL%className :  ' item clearfix '  ,%NWL%events :  {%NWL%' click a . delete '  :  ' destroy '%NWL%}  ,%NWL%initialize : function ( options )  {%NWL%this . branch = options . branch ; %NWL%this . history = options . history ; %NWL%this . model = options . model ; %NWL%this . repo = options . repo ; %NWL%this . router = options . router ; %NWL%6
this . setProduction = function ( isProduction )  {%NWL%this . _isProduction = isProduction ; %NWL%isProduction && this . setLevel ( logging . NONE )  ;%NWL%}%NWL%this . setLevel = function ( level )  {%NWL%this . _level = level ; %NWL%if ( this . _isProduction )  {%NWL%level = logging . NONE ;%NWL%}%NWL%this . DEBUG = level <  = logging . DEBUG ; %NWL%this . LOG  = level <  = logging . LOG ; %NWL%9
exports . objectToArray = function objectToArray ( obj )  {%NWL%var arr =  [  ]  ; %NWL%for ( var key in obj )  {%NWL%arr . push ( obj [ key ]  )  ;%NWL%}%NWL%return arr ;%NWL%}  ; %NWL%exports . getRandomPort = function getRandomPort (  )  {%NWL%return Math . ceil ( Math . random (  )  * 20000 )  + 10000 ;%NWL%}  ; %NWL%exports . getMeteorToolsPath = function getMeteorToolsPath (  )  {%NWL%7
this . eventKeypressWhileRenaming = __bind ( this . eventKeypressWhileRenaming , this )  ; %NWL%this . eventDoneNamingFile = __bind ( this . eventDoneNamingFile , this )  ; %NWL%this . eventCreateDynamic = __bind ( this . eventCreateDynamic , this )  ; %NWL%this . createFile = __bind ( this . createFile , this )  ; %NWL%this . eventCreateTemplate = __bind ( this . eventCreateTemplate , this )  ; %NWL%this . eventCreateCSS = __bind ( this . eventCreateCSS , this )  ; %NWL%this . eventCreateJS = __bind ( this . eventCreateJS , this )  ; %NWL%this . eventCreateHTML = __bind ( this . eventCreateHTML , this )  ; %NWL%this . handleFileDeleted = __bind ( this . handleFileDeleted , this )  ; %NWL%this . handleRouteNameChange = __bind ( this . handleRouteNameChange , this )  ; %NWL%this . handleFileChanged = __bind ( this . handleFileChanged , this )  ; %NWL%0
removeAll : function (  )  {%NWL%this . _removeAll (  )  ;%NWL%}%NWL%}  ,%NWL%statics :%NWL%{%NWL%remap : function ( members )%NWL%{%NWL%members . getChildren = members . _getChildren ; %NWL%members . hasChildren = members . _hasChildren ; %NWL%members . indexOf = members . _indexOf ; %NWL%8
bottom : bottom ,%NWL%down : bottom%NWL%}  ; %NWL%direction = direction . toLowerCase (  )  ; %NWL%me . moveTo ( hash [ direction ]  [ 0 ]  , hash [ direction ]  [ 1 ]  , animate )  ;%NWL%}  ,%NWL%setLeftTop : function ( left , top )  {%NWL%var me = this ,%NWL%style = me . dom . style ; %NWL%style . left = me . addUnits ( left )  ; %NWL%style . top = me . addUnits ( top )  ; %NWL%9
DatePicker . prototype ,%NWL%{%NWL%init : function ( s )%NWL%{%NWL%this . setStartDate ( s . startDate )  ; %NWL%this . setEndDate ( s . endDate )  ; %NWL%this . setDisplayedMonth ( Number ( s . month )  , Number ( s . year )  )  ; %NWL%this . setRenderCallback ( s . renderCallback )  ; %NWL%this . showYearNavigation = s . showYearNavigation ; %NWL%this . closeOnSelect = s . closeOnSelect ; %NWL%this . displayClose = s . displayClose ; %NWL%8
}  ; %NWL%Position . prototype . clone = function (  )  {%NWL%return new Position ( this . url , this . start_line , this . start_offset , this . end_line , this . end_offset )  ;%NWL%}  ; %NWL%Position . prototype . equals = function ( o )  {%NWL%if ( ! ( o instanceof Position )  )%NWL%return false ; %NWL%return o . url =  =  = this . url &&%NWL%o . start_line =  =  = this . start_line &&%NWL%o . start_offset =  =  = this . start_offset &&%NWL%o . end_line =  =  = this . end_line &&%NWL%8
Math . floor ( result . height )%NWL%)  ; %NWL%_cstracker . initTracker ( _inputcanvas , cRectangle )  ;%NWL%}%NWL%_curtracked = result ; %NWL%if ( result . detection =  =  " CS " && params . sendEvents )  {%NWL%var evt = document . createEvent (  " Event "  )  ; %NWL%evt . initEvent (  " facetrackingEvent "  , true , true )  ; %NWL%evt . height = result . height ; %NWL%evt . width = result . width ; %NWL%evt . angle = result . angle ; %NWL%8
propertyIdentifier = clone ( Identifier )  ,%NWL%argIdentifier = clone ( Identifier )  ,%NWL%idLiteral = clone ( Literal )  ,%NWL%resetLiteral = clone ( Literal )  ; %NWL%idLiteral . value = idLiteral . raw = id ; %NWL%resetLiteral . value = true ; %NWL%resetLiteral . raw =  " true "  ; %NWL%objectIdentifier . name =  " window "  ; %NWL%propertyIdentifier . name =  " __pb "  ; %NWL%memberExp . object = objectIdentifier ; %NWL%memberExp . property = propertyIdentifier ; %NWL%9
Plugin . prototype . scalar = function ( x , y )  {%NWL%this . scalarX = x =  =  = undefined ? this . scalarX : x ; %NWL%this . scalarY = y =  =  = undefined ? this . scalarY : y ;%NWL%}  ; %NWL%Plugin . prototype . limit = function ( x , y )  {%NWL%this . limitX = x =  =  = undefined ? this . limitX : x ; %NWL%this . limitY = y =  =  = undefined ? this . limitY : y ;%NWL%}  ; %NWL%Plugin . prototype . origin = function ( x , y )  {%NWL%this . originX = x =  =  = undefined ? this . originX : x ; %NWL%this . originY = y =  =  = undefined ? this . originY : y ; %NWL%2
this . escaped = !!open ;%NWL%}%NWL%if ( rawParams instanceof AST . SexprNode )  {%NWL%this . sexpr = rawParams ;%NWL%} else {%NWL%this . sexpr = new AST . SexprNode ( rawParams , hash )  ;%NWL%}%NWL%this . id = this . sexpr . id ; %NWL%this . params = this . sexpr . params ; %NWL%this . hash = this . sexpr . hash ; %NWL%this . eligibleHelper = this . sexpr . eligibleHelper ; %NWL%7
return svg ;%NWL%}%NWL%function _StreamReader ( arrayBuffer , offset )  {%NWL%var i = offset || 0 ; %NWL%var view = new window . DataView ( arrayBuffer , i )  ; %NWL%this . getInt8 = function (  )  { return view . getInt8 ( i +  +  )  ;  }  ; %NWL%this . getUint8 = function (  )  { return view . getUint8 ( i +  +  )  ;  }  ; %NWL%this . getInt16 = function (  )  { return i +  = 2 , view . getInt16 ( i - 2 )  ;  }  ; %NWL%this . getUint16 = function (  )  { return i +  = 2 , view . getUint16 ( i - 2 )  ;  }  ; %NWL%this . getInt32 = function (  )  { return i +  = 4 , view . getInt32 ( i - 4 )  ;  }  ; %NWL%this . getUint32 = function (  )  { return i +  = 4 , view . getUint32 ( i - 4 )  ;  }  ; %NWL%9
var dgram = require (  ' dgram '  )  ; %NWL%var net = require (  ' net '  )  ; %NWL%var url = require (  ' url '  )  ; %NWL%module . exports = Client ; %NWL%function Client ( opts )  {%NWL%if ( ! ( this instanceof Client )  ) return new Client ( opts )  ; %NWL%opts = opts || {  }  ; %NWL%this . host = opts . host || ' localhost '  ; %NWL%this . port = opts . port || 8125 ; %NWL%this . tcp = opts . tcp ; %NWL%this . prefix = opts . prefix ; %NWL%9
style [ setSizeKey ]  = setSize ; %NWL%style [ calculatedSizeKey ]  = config . calculatedSize ; %NWL%style . x = left ; %NWL%style . y = top ; %NWL%if ( fillColors )%NWL%{%NWL%style . fill . color = fillColors [ i % fillColors . length ]  ;%NWL%}%NWL%if ( borderColors )%NWL%{%NWL%style . border . color = borderColors [ i % borderColors . length ]  ; %NWL%6
}%NWL%}%NWL%}%NWL%return triples ;%NWL%}  ; %NWL%AbstractQueryTree . prototype . _bindFilter = function ( filterExpr , bindings )  {%NWL%if ( filterExpr . expressionType ! = null )  {%NWL%var expressionType = filterExpr . expressionType ; %NWL%if ( expressionType =  =  ' relationalexpression '  )  {%NWL%filterExpr . op1 = this . _bindFilter ( filterExpr . op1 , bindings )  ; %NWL%filterExpr . op2 = this . _bindFilter ( filterExpr . op2 , bindings )  ; %NWL%9
this . accelerationSpread . copy ( other . accelerationSpread )  ; %NWL%this . angularVelocity = other . angularVelocity ; %NWL%this . angularVelocitySpread = other . angularVelocitySpread ; %NWL%this . angularAcceleration = other . angularAcceleration ; %NWL%this . angularAccelerationSpread = other . angularAccelerationSpread ; %NWL%this . randomAngle = other . randomAngle ; %NWL%this . emissionRate = other . emissionRate ; %NWL%this . color . copy ( other . color )  ; %NWL%this . colorSpread . copy ( other . colorSpread )  ; %NWL%this . time = other . time ; %NWL%this . _time = other . _time ; %NWL%1
if ( typeof ( opts . remote && opts . remote . origin )  =  =  =  ' string '  ) data . remotes . origin =  { url : data . remotes . origin }%NWL%var transformations = normalizeTransformations ( opts )%NWL%data . transformations . get = transformations . get || data . transformations . get%NWL%data . transformations . put = transformations . put || data . transformations . put%NWL%data . hooks . listen = normalizeModule ( data . hooks . listen )%NWL%data . import = normalizeModule ( data . import )%NWL%if ( typeof opts . remote =  =  =  ' string '  ) data . remotes . origin = opts . remote%NWL%if ( opts . remotes ) data . remotes . origin = opts . remotes . origin%NWL%data . port = opts . port || data . port || 6461%NWL%data . hostname = opts . hostname || data . hostname%NWL%data . skim = opts . skim || data . skim%NWL%9
async . each ( r_objects ,%NWL%function ( r_object , _intermediate )  {%NWL%_this . client . _object . save ( _this . name , r_object . key , r_object . data , r_object . metadata , r_object . options , function ( err , obj )  {%NWL%if ( err )  {%NWL%err . data = r_object ; %NWL%compiled_errors . push ( err )  ;%NWL%}%NWL%else {%NWL%if ( !err && obj . metadata . status_code ! = 204 )  {%NWL%r_object . data = obj . data ; %NWL%r_object . metadata = obj . metadata ; %NWL%9
this . name = options . name ;%NWL%} else {%NWL%this . name = this . id ;%NWL%}%NWL%this . implicit = options . implicit || false ; %NWL%this . workplane = options . workplane || {%NWL%origin :  { x : 0 , y : 0 , z : 0 }  ,%NWL%axis  :  { x : 0 , y : 0 , z : 1 }  ,%NWL%angle : 0 ,%NWL%}  ; %NWL%this . transforming = options . transforming || false ; %NWL%4
newBadge . status = badge . archived ? ' archived '  :  ' published '  ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%newBadge . timeUnits = badge . timeUnits ; %NWL%newBadge . evidenceType = badge . evidenceType ; %NWL%newBadge . limit = badge . limit ; %NWL%newBadge . unique = badge . unique ; %NWL%newBadge . imageUrl = badge . imageUrl ; %NWL%newBadge . issuerUrl = badge . issuerUrl ; %NWL%1
for ( var i = 0 ; i < len ; i +  +  )  {%NWL%remove [ i ]  . remove (  )  ; %NWL%self . items . pop (  )  ; %NWL%self . empty . pop (  )  ; %NWL%self . out . pop (  )  ;%NWL%}%NWL%self . column_number = column_number ; %NWL%var columns = container . cls ( self . setup . column )  ; %NWL%columns . attr (  ' style '  ,  ' width :  '  + estimate_obj . cls +  ' % '  )  ; %NWL%self . html = columns_obj . html ; %NWL%self . data = columns_obj . data ; %NWL%9
this . catchall = null ;%NWL%}  ,%NWL%dup : function (  )  {%NWL%var newNode = new Sherpa . Node (  )  ; %NWL%for ( var idx = 0 ; idx ! = this . linear . length ; idx +  +  )  {%NWL%newNode . linear . push ( this . linear [ idx ]  )  ;%NWL%}%NWL%for ( var key in this . lookup )  {%NWL%newNode . lookup [ key ]  = this . lookup [ key ]  ;%NWL%}%NWL%newNode . catchall = this . catchall ; %NWL%8
sortField :  {  }  ,%NWL%exportColumnLabels :  {  }  ,%NWL%initialize : function initializePagiatedCollection ( options )  {%NWL%Collection . prototype . initialize . call ( this , options )  ; %NWL%if ( this . sortField ! =  = undefined && this . sortField . field ! =  = undefined )  {%NWL%this . setSortField ( this . sortField . field , this . sortField . order )  ;%NWL%}%NWL%}  ,%NWL%setPageInfo : function setPageInfo ( pageInfos )  {%NWL%this . totalRecords = pageInfos . totalRecords ; %NWL%this . currentPage = pageInfos . currentPage ; %NWL%9
cb_ . apply ( null , arguments )%NWL%log . resume (  )%NWL%process . nextTick ( dequeue )%NWL%}%NWL%var conf =  { cwd : wd%NWL%, env : env%NWL%, stdio :  [ 0 , 1 , 2 ]%NWL%}%NWL%if ( !unsafe )  {%NWL%conf . uid = uid ^ 0%NWL%conf . gid = gid ^ 0%NWL%9
this . _storeRefPropName =  " _S "  ;  /  / Default name for the store reference to attach to every item .%NWL%this . _itemNumPropName =  " _0 "  ;  /  / Default Item Id for isItem to attach to every item .%NWL%this . _rootItemPropName =  " _RI "  ;  /  / Default Item Id for isItem to attach to every item .%NWL%this . _reverseRefMap =  " _RRM "  ;  /  / Default attribute for constructing a reverse reference map for use with reference integrity%NWL%this . _loadInProgress = false ;  /  / Got to track the initial load to prevent duelling loads of the dataset .%NWL%this . _queuedFetches =  [  ]  ; %NWL%if ( keywordParameters . urlPreventCache ! =  = undefined )  {%NWL%this . urlPreventCache = keywordParameters . urlPreventCache?true : false ;%NWL%}%NWL%if ( keywordParameters . hierarchical ! =  = undefined )  {%NWL%this . hierarchical = keywordParameters . hierarchical?true : false ; %NWL%7
WebDeveloper . Overlay . Images . getViewImageInformationLocale = function (  )%NWL%{%NWL%var locale = WebDeveloper . Locales . setupGeneratedLocale (  )  ; %NWL%locale . alt   = WebDeveloper . Locales . getString (  " alt "  )  ; %NWL%locale . height  = WebDeveloper . Locales . getString (  " height "  )  ; %NWL%locale . image  = WebDeveloper . Locales . getString (  " image "  )  ; %NWL%locale . images  = WebDeveloper . Locales . getString (  " images "  )  ; %NWL%locale . property = WebDeveloper . Locales . getString (  " property "  )  ; %NWL%locale . src   = WebDeveloper . Locales . getString (  " src "  )  ; %NWL%locale . value  = WebDeveloper . Locales . getString (  " value "  )  ; %NWL%locale . width  = WebDeveloper . Locales . getString (  " width "  )  ; %NWL%3
var insidecolor =  { offset : null , color : null }  ; %NWL%var outsidecolor =  { offset : null , color : null }  ; %NWL%this . fillStyle . colors_ . sort ( function ( cs1 , cs2 )  {%NWL%return cs1 . offset - cs2 . offset ;%NWL%}  )  ; %NWL%for ( var i = 0 ; i < this . fillStyle . colors_ . length ; i +  +  )  {%NWL%var fs = this . fillStyle . colors_ [ i ]  ; %NWL%colors . push (  ( fs . offset * expansion )  + inside ,  " % "  , fs . color ,  "  ,  "  )  ; %NWL%if ( fs . offset > insidecolor . offset || insidecolor . offset =  = null )  {%NWL%insidecolor . offset = fs . offset ; %NWL%insidecolor . color = fs . color ; %NWL%9
if ( isDefined ( options . fontSize )  )  {%NWL%this . fontSize = options . fontSize ;%NWL%}%NWL%if ( isDefined ( options . barThickness )  )  {%NWL%this . barThickness = options . barThickness ;%NWL%}%NWL%if ( isDefined ( options . pixelsPerMeter )  )  {%NWL%this . pixelsPerMeter = options . pixelsPerMeter ;%NWL%}%NWL%if ( isDefined ( options . location )  )  {%NWL%this . location = options . location ; %NWL%1
this . name =  " tap "  ; %NWL%this . setSTream = function setStream ( s )  {%NWL%options . stream = s ;%NWL%}  ; %NWL%var __bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ; %NWL%var TapInterface =  ( function (  )  {%NWL%function TapInterface (  )  {%NWL%this . genOutput_ = __bind ( this . genOutput_ , this )  ; %NWL%this . testCount = __bind ( this . testCount , this )  ; %NWL%this . bailOut = __bind ( this . bailOut , this )  ; %NWL%this . skip = __bind ( this . skip , this )  ; %NWL%7
if ( node . type =  =  ' ConditionalExpression '  )  {%NWL%if ( ! ( node . test . type =  =  ' Identifier ' || node . test . type =  =  ' Literal '  )  )  {%NWL%node . test = templateReplace (  "  ( function (  )  { return __REPLACEME__ }  (  )  )  "  , node . test )  . expression%NWL%node . test . skipcall = true%NWL%}%NWL%if ( ! ( node . consequent . type =  =  ' Identifier ' || node . consequent . type =  =  ' Literal '  )  )  {%NWL%node . consequent = templateReplace (  "  ( function (  )  { return __REPLACEME__ }  (  )  )  "  , node . consequent )  . expression%NWL%node . consequent . skipcall = true%NWL%}%NWL%if ( ! ( node . alternate . type =  =  ' Identifier ' || node . alternate . type =  =  ' Literal '  )  )  {%NWL%node . alternate = templateReplace (  "  ( function (  )  { return __REPLACEME__ }  (  )  )  "  , node . alternate )  . expression%NWL%2
var done = this . async (  )  ; %NWL%var self = this ; %NWL%if ( this . aceNeedsInit )  {%NWL%console . log ( chalk . green (  ' You\ ' re using the fantastic Atomic Component Engine '  )  )%NWL%console . log ( chalk . green (  ' more info : https :  /  / atomic - component - engine . github . io / ace /  '  )  )  ; %NWL%this . prompt ( this . initPrompts , function ( response )  {%NWL%self . nameInHeader = response . nameInHeader ; %NWL%if ( self . nameInHeader )  {%NWL%if ( self . gitGlobalConfigFile )  {%NWL%self . name = self . gitGlobalConfigFile [  ' user '  ]  . name ; %NWL%self . email = self . gitGlobalConfigFile [  ' user '  ]  . email ; %NWL%9
this . options = options ! = null ? options :  {  }  ; %NWL%this . close = __bind ( this . close , this )  ; %NWL%this . add = __bind ( this . add , this )  ; %NWL%this . _handle = __bind ( this . _handle , this )  ; %NWL%this . _handleDir = __bind ( this . _handleDir , this )  ; %NWL%this . _handleFile = __bind ( this . _handleFile , this )  ; %NWL%this . _watch = __bind ( this . _watch , this )  ; %NWL%this . _remove = __bind ( this . _remove , this )  ; %NWL%this . _hasReadPermissions = __bind ( this . _hasReadPermissions , this )  ; %NWL%this . _removeFromWatchedDir = __bind ( this . _removeFromWatchedDir , this )  ; %NWL%this . _addToWatchedDir = __bind ( this . _addToWatchedDir , this )  ; %NWL%1
window . onmousewheel = document . onmousewheel = Events . wheel%NWL%Event . observe ( document ,  ' keydown '  , Events . keydown )%NWL%Event . observe ( document ,  ' keypress '  , Events . keypress )%NWL%Event . observe ( document ,  ' keyup '  , Events . keyup )%NWL%if ( Config . key_input )  {%NWL%Keyboard . key_input = true%NWL%}%NWL%element = $ (  ' main '  )%NWL%element . ontouchstart = Events . ontouchstart%NWL%element . ontouchmove = Events . ontouchmove%NWL%element . ontouchend = Events . ontouchend%NWL%8
this . skip = function ( skip , callback )  {%NWL%_cursor . skip ( skip , callback )  ; %NWL%_scope_options . skip = skip ; %NWL%return this ;%NWL%}%NWL%this . hint = function ( hint )  {%NWL%_scope_options . hint = hint ; %NWL%_cursor . hint = _scope_options . hint ; %NWL%return this ;%NWL%}%NWL%this . maxTimeMS = function ( maxTimeMS )  {%NWL%5
Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%7
this . close = __bind ( this . close , this )  ; %NWL%this . add = __bind ( this . add , this )  ; %NWL%this . _handle = __bind ( this . _handle , this )  ; %NWL%this . _handleDir = __bind ( this . _handleDir , this )  ; %NWL%this . _handleFile = __bind ( this . _handleFile , this )  ; %NWL%this . _watch = __bind ( this . _watch , this )  ; %NWL%this . _remove = __bind ( this . _remove , this )  ; %NWL%this . _hasReadPermissions = __bind ( this . _hasReadPermissions , this )  ; %NWL%this . _removeFromWatchedDir = __bind ( this . _removeFromWatchedDir , this )  ; %NWL%this . _addToWatchedDir = __bind ( this . _addToWatchedDir , this )  ; %NWL%this . _getWatchedDir = __bind ( this . _getWatchedDir , this )  ; %NWL%0
fill : 		 {  }  ,%NWL%font : 		 "  "  ,%NWL%fontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = dojo . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%du . updateWithPattern ( this . opt , kwArgs , this . optionalParams )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%9
" use strict "  ; %NWL%var Typed = function ( el , options )  {%NWL%this . el = $ ( el )  ; %NWL%this . options = $ . extend (  {  }  , $ . fn . typed . defaults , options )  ; %NWL%this . baseText =  ( this . options . baseText ! =  = undefined ) ? this . options . baseText : this . el . text (  ) || this . el . attr (  ' placeholder '  ) || '  '  ; %NWL%this . replaceBaseText = this . options . replaceBaseText ; %NWL%this . typeSpeed = this . options . typeSpeed ; %NWL%this . startDelay = this . options . startDelay ; %NWL%this . backSpeed = this . options . backSpeed ; %NWL%this . backDelay = this . options . backDelay ; %NWL%this . strings = this . options . strings ; %NWL%5
json = Class . prototype . toJSON . call ( this , json )  ; %NWL%json . width = this . width ; %NWL%json . height = this . height ; %NWL%json . invWidth = this . invWidth ; %NWL%json . invHeight = this . invHeight ; %NWL%json . generateMipmap = this . generateMipmap ; %NWL%json . flipY = this . flipY ; %NWL%json . premultiplyAlpha = this . premultiplyAlpha ; %NWL%json . anisotropy = this . anisotropy ; %NWL%json . filter = this . filter ; %NWL%json . format = this . format ; %NWL%1
return result ;%NWL%}  ; %NWL%impress . health . cpuTimes = function (  )  {%NWL%var cpus = api . os . cpus (  )  ,%NWL%result =  { user : 0 , nice : 0 , sys : 0 , idle : 0 , irq : 0 }  ; %NWL%if ( typeof ( cpus )  =  =  =  ' object '  )  {%NWL%for ( var i = 0 ; i < cpus . length ; i +  +  )  {%NWL%result . user = cpus [ i ]  . times . user ; %NWL%result . nice = cpus [ i ]  . times . nice ; %NWL%result . sys  = cpus [ i ]  . times . sys ; %NWL%result . idle = cpus [ i ]  . times . idle ; %NWL%7
var bb = this . get ( BOUNDING_BOX )  ,%NWL%hide = Y . bind ( this . hide , this )  ,%NWL%uiHandles =  [  ]  ,%NWL%self = this ,%NWL%hideOn = this . get (  ' hideOn '  )  ,%NWL%i = 0 ,%NWL%o =  { node : undefined , ev : undefined , keyCode : undefined }  ; %NWL%for (  ; i < hideOn . length ; i +  +  )  {%NWL%o . node = hideOn [ i ]  . node ; %NWL%o . ev = hideOn [ i ]  . eventName ; %NWL%o . keyCode = hideOn [ i ]  . keyCode ; %NWL%8
function texture ( gl , url , callback )%NWL%{%NWL%var args = Array . prototype . slice . call ( arguments , 3 )  ; %NWL%Texture . load ( url , function ( success )  {%NWL%if ( !success )  {%NWL%return ;%NWL%}%NWL%var canvas , ctx , texture ; %NWL%canvas   = document . createElement (  ' canvas '  )  ; %NWL%canvas . width  = toPowerOfTwo ( this . width )  ; %NWL%canvas . height = toPowerOfTwo ( this . height )  ; %NWL%9
settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%this . prefix = __bind ( this . prefix , this )  ; %NWL%this . suffix = __bind ( this . suffix , this )  ; %NWL%2
}  )  ;%NWL%}%NWL%function respondWithBalances ( result )  {%NWL%var promise = new Promise ( function ( resolve )  {%NWL%var balances =  {  }  ; %NWL%if ( result . marker )  {%NWL%balances . marker = result . marker ;%NWL%}%NWL%balances . limit = result . limit ; %NWL%balances . ledger = result . ledger_index ; %NWL%balances . validated = result . validated ; %NWL%6
var Norch = module . exports = function ( options )  {%NWL%var that = this ; %NWL%if ( ! ( this instanceof Norch )  )  {%NWL%return new Norch ( options )  ;%NWL%}%NWL%var listToArray = function ( val )  {%NWL%return [  ]  . concat ( val . split (  '  ,  '  )  )  ;%NWL%}  ; %NWL%this . bodyParser = require (  ' body - parser '  )  ; %NWL%this . colors = require (  ' colors '  )  ; %NWL%this . fs = require (  ' fs '  )  ; %NWL%9
scope : config . scope%NWL%}  )  ;%NWL%}%NWL%}  , function (  )  {%NWL%Ext . define (  ' Ext . device . SQLite . SQLResultSet '  ,  {%NWL%insertId : 0 ,%NWL%rowsAffected : 0 ,%NWL%rows : null ,%NWL%constructor : function ( data )  {%NWL%this . insertId = data . insertId ; %NWL%this . rowsAffected = data . rowsAffected ; %NWL%9
return ;%NWL%}%NWL%if ( path =  =  = null || path . match (  / \ . gr2$ / i )  )  {%NWL%path = DB . getBodyPath ( 1002 , this . _sex )  ;%NWL%}%NWL%Client . loadFile ( path +  '  . act '  )  ; %NWL%Client . loadFile ( path +  '  . spr '  , function (  )  {%NWL%this . files . body . spr = path +  '  . spr '  ; %NWL%this . files . body . act = path +  '  . act '  ; %NWL%this . bodypalette = this . _bodypalette ; %NWL%this . weapon   = this . _weapon ; %NWL%9
}  ; %NWL%var parseAcknowledgment = exports . _parseAcknowledgment = function ( aBuffer )  {%NWL%var calculatedChecksum ; %NWL%var expectedPacketLength ; %NWL%var responsePacket ; %NWL%if ( aBuffer . length >  = spheroMinimumPacketSize )  {  /  / Don ' t bother until we get a minimum sized packet%NWL%responsePacket = Object . create ( spheroResponseTemplate )  ; %NWL%responsePacket . SOP1 = aBuffer . readUInt8 ( spheroResponseTemplate . SOP1 )  ; %NWL%responsePacket . SOP2 = aBuffer . readUInt8 ( spheroResponseTemplate . SOP2 )  ; %NWL%responsePacket . MRSP = aBuffer . readUInt8 ( spheroResponseTemplate . MRSP )  ; %NWL%responsePacket . SEQ = aBuffer . readUInt8 ( spheroResponseTemplate . SEQ )  ; %NWL%7
var OpmlStore = declare (  " dojox . data . OpmlStore "  , null ,  {%NWL%constructor : function ( keywordParameters )  {%NWL%this . _xmlData = null ; %NWL%this . _arrayOfTopLevelItems =  [  ]  ; %NWL%this . _arrayOfAllItems =  [  ]  ; %NWL%this . _metadataNodes = null ; %NWL%this . _loadFinished = false ; %NWL%this . url = keywordParameters . url ; %NWL%this . _opmlData = keywordParameters . data ;  /  / XML DOM Document%NWL%if ( keywordParameters . label )  {%NWL%this . label = keywordParameters . label ; %NWL%7
}  ; %NWL%scope . onAdError = function onAdError (  )  {%NWL%if ( adsManager ) adsManager . destroy (  )  ; %NWL%scope . hide (  )  ; %NWL%API . play (  )  ;%NWL%}  ; %NWL%scope . onAllAdsComplete = function onAllAdsComplete (  )  {%NWL%scope . hide (  )  ; %NWL%API . stop (  )  ;%NWL%}  ; %NWL%scope . onAdComplete = function onAdComplete (  )  {%NWL%1
json . orthographic = this . orthographic ; %NWL%json . orthographicSize = this . orthographicSize ; %NWL%json . minOrthographicSize = this . minOrthographicSize ; %NWL%json . maxOrthographicSize = this . maxOrthographicSize ; %NWL%return json ;%NWL%}  ; %NWL%Camera . prototype . fromJSON = function ( json )  {%NWL%Component . prototype . fromJSON . call ( this , json )  ; %NWL%this . width = json . width ; %NWL%this . height = json . height ; %NWL%this . aspect = json . aspect ; %NWL%8
callback  = config . done ,%NWL%processHTML = function ( err , html )  {%NWL%html +  =  '  '  ; %NWL%if ( err )  {%NWL%return callback ( err )  ;%NWL%}%NWL%config . scripts = config . scripts || [  ]  ; %NWL%if ( typeof config . scripts =  =  =  ' string '  )  {%NWL%config . scripts =  [ config . scripts ]  ;%NWL%}%NWL%config . src = config . src || [  ]  ; %NWL%6
g . nextPage = lang . hitch ( this , this . nextPage )  ; %NWL%g . prevPage = lang . hitch ( this , this . prevPage )  ; %NWL%g . firstPage = lang . hitch ( this , this . firstPage )  ; %NWL%g . lastPage = lang . hitch ( this , this . lastPage )  ; %NWL%g . currentPageSize = lang . hitch ( this , this . currentPageSize )  ; %NWL%g . showGotoPageButton = lang . hitch ( this , this . showGotoPageButton )  ; %NWL%g . getTotalRowCount = lang . hitch ( this , this . getTotalRowCount )  ; %NWL%g . getTotalPageNum = lang . hitch ( this , this . getTotalPageNum )  ; %NWL%g . gotoPage = lang . hitch ( this , this . gotoPage )  ; %NWL%g . gotoFirstPage = lang . hitch ( this , this . gotoFirstPage )  ; %NWL%g . gotoLastPage = lang . hitch ( this , this . gotoLastPage )  ; %NWL%0
o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . globalAlpha  = o1 . globalAlpha ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%0
removeDelay : 200 ,%NWL%addHost : function ( modal )  {%NWL%var body = $ (  ' body '  )  ; %NWL%var blockout = $ (  '  < div class =  " modalBlockout "  >  <  / div >  '  )%NWL%. css (  {  ' z - index '  : modalDialog . getNextZIndex (  )  ,  ' opacity '  : this . blockoutOpacity }  )%NWL%. appendTo ( body )  ; %NWL%var host = $ (  '  < div class =  " modalHost "  >  <  / div >  '  )%NWL%. css (  {  ' z - index '  : modalDialog . getNextZIndex (  )  }  )%NWL%. appendTo ( body )  ; %NWL%modal . host = host . get ( 0 )  ; %NWL%modal . blockout = blockout . get ( 0 )  ; %NWL%9
}  ; %NWL%this . globalEnableHtml = function ( enableHtml )  {%NWL%_enableHtml = enableHtml ;%NWL%}  ; %NWL%this . messagesKey = function ( messagesKey )  {%NWL%_messagesKey = messagesKey ;%NWL%}  ; %NWL%this . messageTextKey = function ( messageTextKey )  {%NWL%_messageTextKey = messageTextKey ;%NWL%}  ; %NWL%this . messageSeverityKey = function ( messageSeverityKey )  {%NWL%4
}%NWL%return anim ;  /  / dojo . Animation%NWL%}  ,%NWL%unShear : function ( args )  {%NWL%args . unhide = true ; %NWL%return dojox . fx . shear ( args )  ;%NWL%}  ,%NWL%pinwheel : function ( args )  {%NWL%var node = args . node = dojo . byId ( args . node )  ; %NWL%args . rows = args . rows || 4 ; %NWL%args . columns = args . columns || 4 ; %NWL%9
var i , len = this . interps . length ; %NWL%for ( i = 0 ; i < len ; i +  +  )%NWL%{%NWL%this . interps [ i ]  . interp ( t )  ;%NWL%}%NWL%}%NWL%}%NWL%THREE . glTFInterpolator = function ( param )%NWL%{%NWL%this . keys = param . keys ; %NWL%this . values = param . values ; %NWL%9
var sw = proj . fromLatLngToDivPixel ( this . getMap (  )  . getBounds (  )  . getSouthWest (  )  )  ; %NWL%var ne = proj . fromLatLngToDivPixel ( this . getMap (  )  . getBounds (  )  . getNorthEast (  )  )  ; %NWL%var container = document . createElement (  " div "  )  ; %NWL%container . style . cssText =  " position : absolute ; top : 0 ; left : 0 ; border : 0 "  ; %NWL%container . style . width =  " 100% "  ; %NWL%container . style . height =  " 100% "  ; %NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%canvas . style . width = ne . x - sw . x +  " px "  ; %NWL%canvas . style . height = sw . y - ne . y +  " px "  ; %NWL%canvas . width = parseInt ( canvas . style . width )  ; %NWL%canvas . height = parseInt ( canvas . style . height )  ; %NWL%9
statics :%NWL%{%NWL%remap : function ( members )%NWL%{%NWL%members . getChildren = members . _getChildren ; %NWL%members . hasChildren = members . _hasChildren ; %NWL%members . indexOf = members . _indexOf ; %NWL%members . add = members . _add ; %NWL%members . addAt = members . _addAt ; %NWL%members . addBefore = members . _addBefore ; %NWL%members . addAfter = members . _addAfter ; %NWL%4
}  ; %NWL%bdd . describe . only = function ( name , definition )  {%NWL%bdd . describe ( name , definition , true )  ;%NWL%}  ; %NWL%bdd . describe . skip = function (  )  {%NWL%}  ; %NWL%bdd . it = function ( name , test , options )  {%NWL%var newTask = new Task ( name , test )  ; %NWL%if ( typeof options ! =  =  ' undefined '  )  {%NWL%newTask . only = !!options . only ; %NWL%newTask . async = !!options . async ; %NWL%9
}  ; %NWL%imageRes . src = tempCanvas . toDataURL (  )  ;%NWL%}%NWL%resource . source = tempCanvas ; %NWL%return tempCanvas ;%NWL%}  ,%NWL%colorize : function ( resource , hsv )  {%NWL%var tempCanvas = document . createElement (  " canvas "  )  ,%NWL%tempCtx = tempCanvas . getContext (  " 2d "  )  ; %NWL%tempCanvas . width = resource . source . width ; %NWL%tempCanvas . height = resource . source . height ; %NWL%9
$ ( this )  . on (  ' click . dialogs '  , function ( evt )  {%NWL%that . closeDialog (  )  ; %NWL%var ret = that . changeFile ( evt , that . editor )  ; %NWL%return false ;%NWL%}  )  ;%NWL%}  )  ; %NWL%$ ( row )  . off (  ' click '  )  ; %NWL%$ ( row )  . on (  ' click . dialogs '  , function ( evt )  {%NWL%var click = new $ . Event (  ' click '  )  ; %NWL%click . shiftKey = evt . shiftKey ; %NWL%click . ctrlKey = evt . ctrlKey ; %NWL%9
this . parseColors = function (  )%NWL%{%NWL%if ( this . original_colors . length =  =  = 0 )  {%NWL%this . original_colors [  ' chart . fillstyle '  ]    = RG . array_clone ( prop [  ' chart . fillstyle '  ]  )  ; %NWL%this . original_colors [  ' chart . strokestyle '  ]   = RG . array_clone ( prop [  ' chart . strokestyle '  ]  )  ; %NWL%this . original_colors [  ' chart . highlight . fill '  ]   = RG . array_clone ( prop [  ' chart . highlight . fill '  ]  )  ; %NWL%this . original_colors [  ' chart . highlight . stroke '  ]  = RG . array_clone ( prop [  ' chart . highlight . stroke '  ]  )  ; %NWL%this . original_colors [  ' chart . text . color '  ]    = RG . array_clone ( prop [  ' chart . text . color '  ]  )  ;%NWL%}%NWL%prop [  ' chart . fillstyle '  ]    = this . parseSingleColorForGradient ( prop [  ' chart . fillstyle '  ]  )  ; %NWL%prop [  ' chart . strokestyle '  ]   = this . parseSingleColorForGradient ( prop [  ' chart . strokestyle '  ]  )  ; %NWL%9
relatedTarget = e . fromElement ;%NWL%} else if ( type =  = goog . events . EventType . MOUSEOUT )  {%NWL%relatedTarget = e . toElement ;%NWL%}%NWL%this . relatedTarget = relatedTarget ; %NWL%this . offsetX = e . offsetX ! =  = undefined ? e . offsetX : e . layerX ; %NWL%this . offsetY = e . offsetY ! =  = undefined ? e . offsetY : e . layerY ; %NWL%this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ; %NWL%9
var neededToken = method . token ; %NWL%var requestOptions =  {  }  ; %NWL%if ( method . path )  {%NWL%if ( typeof method . path =  =  =  ' function '  )  {%NWL%requestOptions . path = method . path . call ( this , options )  ;%NWL%} else {%NWL%requestOptions . path = method . path ;%NWL%}%NWL%}%NWL%if ( method . uri )  {%NWL%requestOptions . uri = method . uri ; %NWL%6
var Light =  ( function (  )  {%NWL%function Light (  )  {%NWL%}%NWL%Light . prototype . clone = function (  )  {%NWL%var clone = new Light (  )  ; %NWL%clone . name = this . name ; %NWL%clone . spot = this . spot ; %NWL%clone . ambient = this . ambient ; %NWL%clone . point = this . point ; %NWL%clone . fog = this . fog ; %NWL%clone . global = this . global ; %NWL%5
update : function (  )  {%NWL%if ( this . x + this . width > Game . width )  { this . x = Game . width - this . width ; this . xAdd = this . xAdd *  - 1 ;  }%NWL%else if ( this . x < 0 )  { this . x = 0 ; this . xAdd = this . xAdd *  - 1 ;  }%NWL%if ( this . y + this . height > Game . height )  { this . y = Game . height - this . height ; this . yAdd = Game . random ( 5 )  *  - 1 ;  }%NWL%else if ( this . y < 0 )  { this . y = 0 ; this . yAdd = this . yAdd *  - 1 ;  }%NWL%this . x +  = this . xAdd ; %NWL%this . y +  = this . yAdd ;%NWL%}  ,%NWL%collide : function ( object )  {%NWL%this . xAdd = this . xAdd *  - 1 ; %NWL%this . yAdd = this . yAdd *  - 1 ; %NWL%9
this . dirxml = function (  )  { log ( arguments ,  ' dirxml '  )  ;  }  ; %NWL%this . error = function (  )  { log ( arguments ,  ' error '  )  ;  }  ; %NWL%this . exception = function (  )  { log ( arguments ,  ' exception '  )  ;  }  ; %NWL%this . group = function (  )  { log ( arguments ,  ' group '  )  ;  }  ; %NWL%this . groupCollapsed = function (  )  { log ( arguments ,  ' groupCollapsed '  )  ;  }  ; %NWL%this . groupEnd = function (  )  { log ( arguments ,  ' groupEnd '  )  ;  }  ; %NWL%this . info = function (  )  { log ( arguments ,  ' info '  )  ;  }  ; %NWL%this . log = function (  )  { log ( arguments ,  ' log '  )  ;  }  ; %NWL%this . profile = function (  )  { log ( arguments ,  ' profile '  )  ;  }  ; %NWL%this . profileEnd = function (  )  { log ( arguments ,  ' profileEnd '  )  ;  }  ; %NWL%this . table = function (  )  { log ( arguments ,  ' table '  )  ;  }  ; %NWL%0
' dijit / form / Button '  ,%NWL%' JBrowse / Model / Location '%NWL%]  ,%NWL%function ( declare , dom , focus , NumberSpinner , ActionBarDialog , on , Button , Location )  {%NWL%return declare ( ActionBarDialog ,  {%NWL%title :  ' Set new track height '  ,%NWL%constructor : function ( args )  {%NWL%this . height = args . height || 100 ; %NWL%this . browser = args . browser ; %NWL%this . setCallback  = args . setCallback || function (  )  {  }  ; %NWL%this . cancelCallback = args . cancelCallback || function (  )  {  }  ; %NWL%9
lodash . isArguments = objects . isArguments ; %NWL%lodash . isArray = isArray ; %NWL%lodash . isBoolean = objects . isBoolean ; %NWL%lodash . isDate = objects . isDate ; %NWL%lodash . isElement = objects . isElement ; %NWL%lodash . isEmpty = objects . isEmpty ; %NWL%lodash . isEqual = objects . isEqual ; %NWL%lodash . isFinite = objects . isFinite ; %NWL%lodash . isFunction = objects . isFunction ; %NWL%lodash . isNaN = objects . isNaN ; %NWL%lodash . isNull = objects . isNull ; %NWL%0
case '  [ object String ]  '  : %NWL%return a =  = String ( b )%NWL%case '  [ object Number ]  '  : %NWL%return a ! =  + a ? b ! =  + b :  ( a =  = 0 ? 1 / a =  = 1 / b : a =  =  + b )%NWL%case '  [ object Date ]  '  : %NWL%case '  [ object Boolean ]  '  : %NWL%return + a =  =  + b%NWL%case '  [ object RegExp ]  '  : %NWL%return a . source =  = b . source &&%NWL%a . global =  = b . global &&%NWL%a . multiline =  = b . multiline &&%NWL%9
this . ui . find (  '  . resurection '  )  . click ( function (  )  { Escape . onResurectionReques (  )  ;  }  )  ; %NWL%this . ui . find (  '  . savepoint '  )  . click ( function (  )  { Escape . onReturnSavePointRequest (  )  ;  }  )  ; %NWL%this . ui . find (  '  . charselect '  )  . click ( function (  )  { Escape . onCharSelectionRequest (  )  ;  }  )  ; %NWL%this . ui . find (  '  . exit '  )  . click ( function (  )  { Escape . onExitRequest (  )  ;  }  )  ; %NWL%this . ui . find (  '  . cancel '  )  . click ( function (  )  { Escape . ui . hide (  )  ;  }  )  ;%NWL%}  ; %NWL%Escape . onAppend = function onAppend (  )%NWL%{%NWL%this . ui . hide (  )  ;%NWL%}  ; %NWL%Escape . onRemove = function onRemove (  )%NWL%6
chain_results = chain . results ; %NWL%for ( var i = 0 , keys = _object_keys ( chain_results )  , len = keys . length ; i < len ; i +  +  )  {%NWL%var key = keys [ i ]  ; %NWL%var item = chain_results [ key ]  ; %NWL%array . push ( item )  ;%NWL%}%NWL%return array ;%NWL%}  ; %NWL%chain . original = function (  )  { return funct . apply ( chain , _toArray ( arguments )  )  }  ; %NWL%chain . results =  {  }  ;  /  / chain results%NWL%chain . methods =  {  }  ;  /  / chain methods%NWL%9
var ret =  { code : 0 , msg :  '  < % = optControllerNameCaps % >  . search '  , results : false }  ; %NWL%var defaults =  {%NWL%' limit '  : 20 ,%NWL%' fields '  :  {  ' _id '  : 1 ,  ' title '  : 1 }  , 		 /  / TODO%NWL%' searchFields '  :  [  ' title '  ] 		 /  / TODO%NWL%}  ; %NWL%if ( data . fields =  =  = undefined )  {%NWL%data . fields = defaults . fields ;%NWL%}%NWL%if ( data . limit =  =  = undefined )  {%NWL%data . limit = defaults . limit ; %NWL%7
this . x *  = scale ; %NWL%this . y *  = scale ; %NWL%this . z *  = scale ; %NWL%this . w *  = scale ; %NWL%return this ;%NWL%}  ; %NWL%proto . assignFrom = function ( quaternion )  {   /  /  = cc . kmQuaternionAssign%NWL%this . x = quaternion . x ; %NWL%this . y = quaternion . y ; %NWL%this . z = quaternion . z ; %NWL%this . w = quaternion . w ; %NWL%7
var _p = cc . RenderTexture . prototype ; %NWL%if ( cc . _renderType =  = cc . _RENDER_TYPE_WEBGL )  {%NWL%_p . ctor = _p . _ctorForWebGL ; %NWL%_p . cleanup = _p . _cleanupForWebGL ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForWebGL ; %NWL%_p . begin = _p . _beginForWebGL ; %NWL%_p . _beginWithClear = _p . _beginWithClearForWebGL ; %NWL%_p . end = _p . _endForWebGL ; %NWL%_p . clearRect = _p . _clearRectForWebGL ; %NWL%_p . clearDepth = _p . _clearDepthForWebGL ; %NWL%_p . clearStencil = _p . _clearStencilForWebGL ; %NWL%2
Exhibit . Formatter . _ImageFormatter = function ( uiContext )  {%NWL%this . _uiContext = uiContext ; %NWL%this . _maxWidth = uiContext . getSetting (  " format / image / max - width "  )  ; %NWL%if ( typeof this . _maxWidth =  =  =  " number "  )  {%NWL%this . _maxWidth = Math . max (  - 1 , Math . round ( this . _maxWidth )  )  ;%NWL%} else {%NWL%this . _maxWidth =  - 1 ;  /  /  - 1 means no limit%NWL%}%NWL%this . _maxHeight = uiContext . getSetting (  " format / image / max - height "  )  ; %NWL%if ( typeof this . _maxHeight =  =  =  " number "  )  {%NWL%this . _maxHeight = Math . max (  - 1 , Math . round ( this . _maxHeight )  )  ; %NWL%4
}%NWL%opt . messageStatus =  " SENDING "  ; %NWL%m = new PrivMessage ( msg , opt )  ; %NWL%_messages . msg [ m . priv . id ]  = m ; %NWL%msg_utils . saveMsg ( m )  ;  /  / sync to remote%NWL%shortMsg . msg = m ;   /  / pass by ref%NWL%shortMsg . id = m . priv . id ; %NWL%shortMsg . body = m . body . plainBody ; %NWL%shortMsg . to = m . to . slice ( 0 )  ; %NWL%shortMsg . cc = m . cc . slice ( 0 )  ; %NWL%shortMsg . bcc = m . bcc . slice ( 0 )  ; %NWL%8
ve . getObjectValues = OO . getObjectValues ; %NWL%ve . getObjectKeys = Object . keys ; %NWL%ve . compare = OO . compare ; %NWL%ve . copy = OO . copy ; %NWL%ve . copyDomElements = function ( domElements , doc )  {%NWL%return domElements . map ( function ( domElement )  {%NWL%return doc ? doc . importNode ( domElement , true )  : domElement . cloneNode ( true )  ;%NWL%}  )  ;%NWL%}  ; %NWL%ve . isPlainObject = $ . isPlainObject ; %NWL%ve . isEmptyObject = $ . isEmptyObject ; %NWL%9
function removeTypeFromMessage ( sMessage )  {%NWL%return sMessage . replace ( getTypeFromMessage ( sMessage )  +  "  :  "  ,  "  "  )  ;%NWL%}%NWL%var oDateFormatter ; %NWL%Message = function ( oLevel , sCategory , sMessage , sFilenameUrl , nLineNumber )  {%NWL%this . oLevel = oLevel || Level . ALL ; %NWL%this . sCategory = sCategory || ' GENERAL '  ; %NWL%this . sMessage = sMessage || ' Message Undefined '  ; %NWL%this . dInitialize = new Date (  )  ; %NWL%this . oDateFormatter = oDateFormatter || null ; %NWL%this . sFilenameUrl = sFilenameUrl || null ; %NWL%9
if ( this . pos ) iio . log (  '  - Obj . pos :  '  + this . pos . x +  '  ,  '  + this . pos . y )  ; %NWL%if ( this . color ) iio . log (  '  - Obj . color :  '  + this . color . toString (  )  )  ; %NWL%iio . log (  ' end CONSTRUCTOR : Obj '  )  ;%NWL%}%NWL%iio . Drawable . prototype . _Drawable = iio . Drawable . prototype . Drawable ; %NWL%iio . Drawable . prototype . Drawable = function (  )  {%NWL%iio . log (  ' enter CONSTRUCTOR : Drawable '  )  ; %NWL%this . _Drawable ( arguments [ 0 ]  )  ; %NWL%iio . log (  ' end CONSTRUCTOR : Drawable '  )  ;%NWL%}%NWL%iio . Line . prototype . _Line = iio . Line . prototype . Line ; %NWL%4
function init (  )%NWL%{%NWL%options = urlLib . parse ( params . url )  ; %NWL%options . headers =  {  }  ; %NWL%if ( params . headers )%NWL%{%NWL%options . headers = params . headers ;%NWL%}%NWL%if ( params . cert && params . key )%NWL%{%NWL%options . cert = params . cert ; %NWL%6
}%NWL%return shaderCodeInfos ;%NWL%}%NWL%function processTextureMaps (  )  {%NWL%var textures =  [  ]  ; %NWL%for ( var s = 0 ; s < shaderCodeInfos . length ; s +  +  )  {%NWL%for ( var m = 0 ; m < shaderCodeInfos [ s ]  . originalMaterials . length ; m +  +  )  {%NWL%var material = shaderCodeInfos [ s ]  . originalMaterials [ m ]  ; %NWL%if ( material . map ! =  = undefined && material . map ! =  = null )%NWL%bindTexture ( material . map , shaderCodeInfos [ s ]  ,  " uMap0 "  )  ; %NWL%if ( material . env_map ! =  = undefined && material . env_map ! =  = null )%NWL%8
Uize . Dom . Event . isKeyEscape ( _event ) && m . _inDrag && _cancelDrag ( _event )  ;%NWL%}  ;%NWL%}%NWL%}%NWL%return _false ;%NWL%}  ; %NWL%return _superclass . subclass (  {%NWL%alphastructor : function (  )  {%NWL%var m = this ; %NWL%m . eventStartPos = m . _eventStartPos =  [ 0 , 0 ]  ; %NWL%m . eventPos = m . _eventPos =  [ 0 , 0 ]  ; %NWL%9
dojo . require (  " dojox . charting . scaler . common "  )  ;%NWL%( function (  )  {%NWL%var deltaLimit = 3 , 	 /  / pixels%NWL%dc = dojox . charting , dcs = dc . scaler , dcsc = dcs . common ,%NWL%findString = dcsc . findString ,%NWL%getLabel = dcsc . getNumericLabel ; %NWL%var calcTicks = function ( min , max , kwArgs , majorTick , minorTick , microTick , span )  {%NWL%kwArgs = dojo . clone ( kwArgs )  ; %NWL%if ( !majorTick )  {%NWL%if ( kwArgs . fixUpper =  =  " major "  )  { kwArgs . fixUpper =  " minor "  ;  }%NWL%if ( kwArgs . fixLower =  =  " major "  )  { kwArgs . fixLower =  " minor "  ;  }%NWL%9
c . scrollTop = b - ch ;%NWL%}%NWL%c . scrollTop = c . scrollTop ; %NWL%if ( hscroll ! =  = false )  {%NWL%if ( el . offsetWidth > c . clientWidth || l < cl )  {%NWL%c . scrollLeft = l ;%NWL%}%NWL%else if ( r > cr )  {%NWL%c . scrollLeft = r - c . clientWidth ;%NWL%}%NWL%c . scrollLeft = c . scrollLeft ; %NWL%2
Level . nINFO = 20000 ; %NWL%Level . nDEBUG = 10000 ; %NWL%Level . nTRACE = 5000 ; %NWL%Level . nALL = Number . MIN_VALUE ; %NWL%Level . OFF = new Level ( Level . nOFF ,  " OFF "  )  ; %NWL%Level . DISRUPTOR = new Level ( Level . nDISRUPTOR ,  " DISRUPTOR "  )  ; %NWL%Level . FATAL = new Level ( Level . nFATAL ,  " FATAL "  )  ; %NWL%Level . ERROR = new Level ( Level . nERROR ,  " ERROR "  )  ; %NWL%Level . WARNING = new Level ( Level . nWARNING ,  " WARN "  )  ; %NWL%Level . INFO = new Level ( Level . nINFO ,  " INFO "  )  ; %NWL%Level . DEBUG = new Level ( Level . nDEBUG ,  " DEBUG "  )  ; %NWL%4
!relobj . authority &&%NWL%!relobj . query%NWL%)  {%NWL%if ( relobj . fragment ! = n )  {%NWL%uriobj . fragment = relobj . fragment ;%NWL%}%NWL%relobj = uriobj ;%NWL%} else if ( !relobj . scheme )  {%NWL%relobj . scheme = uriobj . scheme ; %NWL%if ( !relobj . authority )  {%NWL%relobj . authority = uriobj . authority ; %NWL%8
}%NWL%gSite . account    = $ (  ' account '  )  . value ; %NWL%gSite . folder    = $ (  ' folder '  )  . value ; %NWL%gSite . host    = $ (  ' host '  )  . value . trim (  )  ; %NWL%gSite . port    = $ (  ' port '  )  . value ; %NWL%gSite . login    = $ (  ' login '  )  . value . trim (  )  ; %NWL%gSite . password   = $ (  ' password '  )  . value ; %NWL%gSite . anonymous   = $ (  ' anonymous '  )  . checked ; %NWL%gSite . protocol   = $ (  ' security '  )  . value =  =  ' sftp ' ? ' ssh2 '  :  ' ftp '  ; %NWL%gSite . security   = $ (  ' security '  )  . value ; %NWL%gSite . pasvmode   = $ (  ' pasvmode '  )  . checked ; %NWL%7
width : 40 ,%NWL%height : 100%NWL%}  ; %NWL%return DiagramElement ;%NWL%}  )  ( Backbone . Model )  ; %NWL%Class =  ( function ( _super )  {%NWL%__extends ( Class , _super )  ; %NWL%function Class (  )  {%NWL%this . get_inheritance_depth = __bind ( this . get_inheritance_depth , this )  ; %NWL%this . get_super_classes = __bind ( this . get_super_classes , this )  ; %NWL%this . get_all_members = __bind ( this . get_all_members , this )  ; %NWL%8
line : context . line ,%NWL%column : context . column%NWL%}  )  ; %NWL%context . source = context . outer . sourceTracker . nextStart ( escaped )  . filename ; %NWL%context . line = 1 ; %NWL%context . column = 0 ;%NWL%} else if ( isEndSourceMarker )  {%NWL%var oldState = context . state . pop (  )  ; %NWL%context . source = oldState . source ; %NWL%context . line = oldState . line ; %NWL%context . column = oldState . column ; %NWL%8
this . instructions = prevGenerator . instructions || [  ]  ; %NWL%this . instructions_start = prevGenerator . instructions ?%NWL%prevGenerator . instructions . length : 0 ; %NWL%this . data = prevGenerator . data || [  ]  ; %NWL%this . shared = prevGenerator . shared || {  }  ; %NWL%this . labels = prevGenerator . labels || [  ]  ; %NWL%this . labelMap = prevGenerator . labelMap || {  }  ; %NWL%this . loopStack = prevGenerator . loopStack || [  ]  ; %NWL%this . selectStack = prevGenerator . selectStack || [  ]  ; %NWL%this . functionNames = prevGenerator . functionNames || {  }  ; %NWL%this . lineMapping = prevGenerator . lineMapping || [  ]  ; %NWL%0
( function ( define )  {%NWL%' use strict '  ; %NWL%var undef ; %NWL%define ( function ( require )  {%NWL%var msgs = require (  '  .  .  '  )  ; %NWL%msgs . prototype . batchingAggregator = msgs . utils . optionalName ( function batchingAggregator ( name , opts )  {%NWL%var timeout , batch ; %NWL%batch =  [  ]  ; %NWL%opts = opts || {  }  ; %NWL%opts . batch = opts . batch || 0 ; %NWL%opts . timeout = opts . timeout || 0 ; %NWL%9
}%NWL%this . preloadImg = img ;%NWL%}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . getElementById (  " imageform "  )  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%9
}%NWL%}  ,%NWL%listeners :  {%NWL%load :  {%NWL%fn : function ( store , records , options )  {%NWL%var storeRecords = store . getRange (  )  ; %NWL%for ( var i = 0 ; i < storeRecords . length ; i +  +  )  {%NWL%var record = storeRecords [ i ]  . data ; %NWL%record . dependencies = Ext . util . Format . htmlEncode ( record . dependencies )  ; %NWL%record . description = Ext . util . Format . htmlEncode ( record . description )  ; %NWL%record . requirements = Ext . util . Format . htmlEncode ( record . requirements )  ; %NWL%8
if ( error )  {%NWL%return callback ( error )  ;%NWL%}%NWL%var transactions =  [  ]  ; %NWL%account_tx_results . transactions . forEach ( function ( tx_entry )  {%NWL%if ( !tx_entry . validated )  {%NWL%return ;%NWL%}%NWL%var tx = tx_entry . tx ; %NWL%tx . meta = tx_entry . meta ; %NWL%tx . validated = tx_entry . validated ; %NWL%9
this . separator = options . separator ; %NWL%if ( typeof options . startDate =  =  ' string '  )%NWL%this . startDate = Date . parse ( options . startDate , this . format )  ; %NWL%if ( typeof options . endDate =  =  ' string '  )%NWL%this . endDate = Date . parse ( options . endDate , this . format )  ; %NWL%if ( typeof options . minDate =  =  ' string '  )%NWL%this . minDate = Date . parse ( options . minDate , this . format )  ; %NWL%if ( typeof options . maxDate =  =  ' string '  )%NWL%this . maxDate = Date . parse ( options . maxDate , this . format )  ; %NWL%if ( typeof options . startDate =  =  ' object '  )%NWL%this . startDate = options . startDate ; %NWL%0
if ( searchParams . rows ! =  = undefined )  {%NWL%searchParams . rows = parseInt ( searchParams . rows , 10 )  ;%NWL%}%NWL%if ( searchParams . start ! =  = undefined )  {%NWL%searchParams . start = parseInt ( searchParams . start , 10 )  ;%NWL%}%NWL%if ( typeof searchParams . regEx =  =  =  " string "  )  {  /  / $NON - NLS - 0$%NWL%searchParams . regEx =  ( searchParams . regEx . toLowerCase (  )  =  =  =  " true "  )  ;  /  / $NON - NLS - 0$%NWL%}%NWL%if ( typeof searchParams . caseSensitive =  =  =  " string "  )  {  /  / $NON - NLS - 0$%NWL%searchParams . caseSensitive =  ( searchParams . caseSensitive . toLowerCase (  )  =  =  =  " true "  )  ;  /  / $NON - NLS - 0$%NWL%7
}%NWL%return 0 ;%NWL%}  )  ; %NWL%for ( var i = 0 ; i < commits . length ; i +  +  )  {%NWL%for ( var j = 0 ; j < commits [ i ]  . Children . length ; j +  +  )  {%NWL%var range = commits [ i ]  . Children [ j ]  ; %NWL%var c = commits [ i ]  ; %NWL%range . AuthorName = c . AuthorName ; %NWL%range . AuthorEmail = c . AuthorEmail ; %NWL%range . CommitterName = c . CommitterName ; %NWL%range . CommitterEmail = c . CommitterEmail ; %NWL%7
this . createjs = this . createjs|| {  }  ;%NWL%( function (  )  {%NWL%" use strict "  ; %NWL%function EventDispatcher (  )  {%NWL%this . _listeners = null ; %NWL%this . _captureListeners = null ;%NWL%}%NWL%var p = EventDispatcher . prototype ; %NWL%EventDispatcher . initialize = function ( target )  {%NWL%target . addEventListener = p . addEventListener ; %NWL%target . on = p . on ; %NWL%9
air . Screen = window . runtime . flash . display . Screen ; %NWL%air . Loader  = window . runtime . flash . display . Loader ; %NWL%air . Bitmap = window . runtime . flash . display . Bitmap ; %NWL%air . BitmapData = window . runtime . flash . display . BitmapData ; %NWL%air . Keyboard = window . runtime . flash . ui . Keyboard ; %NWL%air . KeyLocation = window . runtime . flash . ui . KeyLocation ; %NWL%air . Mouse = window . runtime . flash . ui . Mouse ; %NWL%air . ReferencesValidationSetting = window . runtime . flash . security . ReferencesValidationSetting ; %NWL%air . RevocationCheckSettings = window . runtime . flash . security . RevocationCheckSettings ; %NWL%air . SignatureStatus = window . runtime . flash . security . SignatureStatus ; %NWL%air . SignerTrustSettings = window . runtime . flash . security . SignerTrustSettings ; %NWL%7
$ (  ' #c - speed '  )  . bind (  ' change '  , function (  )  {%NWL%setGeolocation (  )  ;%NWL%}  )  ; %NWL%$ (  ' #c - heading '  )  . bind (  ' change '  , function (  )  {%NWL%setGeolocation (  )  ;%NWL%}  )  ; %NWL%function getAdressData (  )  {%NWL%var data = new Object (  )  ; %NWL%data . street = $ (  ' #d - street '  )  . val (  )  ; %NWL%data . streetnumber = $ (  ' #d - streetnumber '  )  . val (  )  ; %NWL%data . country = $ (  ' #d - country '  )  . val (  )  ; %NWL%8
}%NWL%function container (  )  {%NWL%if ( applet =  =  = undefined )  {%NWL%appletString = generateAppletString (  )  ; %NWL%node . innerHTML = appletString ; %NWL%applet = document . getElementById ( options . appletID )  ;%NWL%} else {%NWL%applet . style . width  = size . width ; %NWL%applet . style . height = size . height ; %NWL%applet . width  = size . width ; %NWL%applet . height = size . height ; %NWL%9
}%NWL%if ( typeof options . fileIn =  =  =  ' object ' && options . fileIn instanceof Array && options . type ! =  =  ' gcc '  )  {%NWL%var out = options . fileIn . map ( function ( path )  {%NWL%return _fs . readFileSync ( path ,  ' utf8 '  )  ;%NWL%}  )  ; %NWL%_fs . writeFileSync ( this . tempFile , out . join (  ' \n '  )  ,  ' utf8 '  )  ; %NWL%this . fileIn = this . tempFile ;%NWL%} else if ( typeof options . fileIn =  =  =  ' object ' && options . fileIn instanceof Array && options . type =  =  =  ' gcc '  )  {%NWL%this . fileIn = options . fileIn ;%NWL%}%NWL%this . fileOut = options . fileOut ; %NWL%8
if ( !g ) g = 0 . 0 ; %NWL%if ( !b ) b = 0 . 0 ; %NWL%this . red = r ; %NWL%this . green = g ; %NWL%this . blue = b ;%NWL%}  ,%NWL%add : function ( c1 , c2 )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red + c2 . red ; %NWL%result . green = c1 . green + c2 . green ; %NWL%result . blue = c1 . blue + c2 . blue ; %NWL%8
for ( i = 0 ; i < inNumSamples ;  +  + i )  {%NWL%_in = inIn [ i ] || 0 . 001 ; %NWL%out [ i ]  = Math . pow ( x , Math . log ( Math . abs ( _in / srclo )  )  / y )  * dstlo ; %NWL%x +  = x_slope ; %NWL%y +  = y_slope ;%NWL%}%NWL%this . _srclo = next_srclo ; %NWL%this . _srchi = next_srchi ; %NWL%this . _dstlo = next_dstlo ; %NWL%this . _dsthi = next_dsthi ; %NWL%this . _x = next_x ; %NWL%6
LoadBalancer . prototype . _setProperties = function ( details )  {%NWL%var self = this ; %NWL%self . id = details . id ; %NWL%self . name = details . name ; %NWL%self . protocol = details . protocol ; %NWL%self . port = details . port ; %NWL%self . algorithm = details . algorithm ; %NWL%self . cluster = details . cluster ; %NWL%self . status = details . status ; %NWL%self . timeout = details . timeout ; %NWL%self . halfClosed = details . halfClosed ; %NWL%2
}  )  ;%NWL%}  ,%NWL%_getItems : function (  )  {%NWL%var numItems = 0 ; %NWL%var itemMenu = this ; %NWL%for ( var i = 0 ; i < this . _itemList . length ;  +  + i )  {%NWL%var itemId = this . _itemList [ i ]  ; %NWL%var item =  {  }  ; %NWL%item . name = g_itemData . items [ itemId ]  . name ; %NWL%item . type = g_itemData . items [ itemId ]  . type ; %NWL%item . cost = g_itemData . items [ itemId ]  . cost ; %NWL%8
options . resultsClass  = options . resultsClass || options . cssFlavor +  " _results "  ; %NWL%options . selectedClass = options . selectedClass || options . cssFlavor +  " _selected "  ; %NWL%options . finderFunction = options . finderFunction || QuickSelect . finders [ !options . data ? ' ajax '  :  (  ' data '  )  ]  ; %NWL%options . matchMethod  = options . matchMethod || QuickSelect . matchers [  ( typeof (  '  '  . score )  =  =  =  ' function ' && ' l '  . score (  ' l '  )  =  = 1 ? ' quicksilver '  :  ' contains '  )  ]  ; %NWL%if ( options . matchMethod =  =  =  ' quicksilver ' && options . finderFunction =  =  =  ' data '  ) options . finderFunction =  ' data_for_quicksilver '  ; %NWL%if ( options . matchMethod =  =  =  ' quicksilver ' || options . matchMethod =  =  =  ' contains ' || options . matchMethod =  =  =  ' startsWith '  ) options . matchMethod = QuickSelect . matchers [ options . matchMethod ]  ; %NWL%if ( options . finderFunction =  =  =  ' data ' || options . finderFunction =  =  =  ' ajax '  ) options . finderFunction = QuickSelect . finders [ options . finderFunction ]  ; %NWL%if ( options . matchCase =  =  = undefined ) options . matchCase = false ; %NWL%if ( options . exactMatch =  =  = undefined ) options . exactMatch = false ; %NWL%if ( options . autoSelectFirst =  =  = undefined ) options . autoSelectFirst = true ; %NWL%if ( options . selectSingleMatch =  =  = undefined ) options . selectSingleMatch = true ; %NWL%9
VulcanMessage . DEFAULT_APP_VERSION =  " UNKNOWN "  ; %NWL%VulcanMessage . DEFAULT_DATA =  "  < data >  < payload >  <  / payload >  <  / data >  "  ; %NWL%VulcanMessage . dataTemplate =  "  < data >  { 0 }  <  / data >  "  ; %NWL%VulcanMessage . payloadTemplate =  "  < payload >  { 0 }  <  / payload >  "  ; %NWL%VulcanMessage . prototype . initialize = function ( message )%NWL%{%NWL%this . type = message . type ; %NWL%this . scope = message . scope ; %NWL%this . appId = message . appId ; %NWL%this . appVersion = message . appVersion ; %NWL%this . data = message . data ; %NWL%6
type :  ' index - pattern '  ,%NWL%id : pattern . id%NWL%}  )  ;%NWL%}  ; %NWL%self . errors =  {%NWL%MissingIndices : errors . IndexPatternMissingIndices%NWL%}  ; %NWL%self . cache = patternCache ; %NWL%self . getIds = Private ( require (  ' components / index_patterns / _get_ids '  )  )  ; %NWL%self . intervals = Private ( require (  ' components / index_patterns / _intervals '  )  )  ; %NWL%self . mapper = Private ( require (  ' components / index_patterns / _mapper '  )  )  ; %NWL%9
var Atrule = require (  '  .  / atrule '  )  ; %NWL%var Keyframes = module . exports = function Keyframes ( segs , prefix )  {%NWL%Atrule . call ( this ,  ' keyframes '  )  ; %NWL%this . segments = segs ; %NWL%this . prefix = prefix || ' official '  ;%NWL%}  ; %NWL%Keyframes . prototype . __proto__ = Atrule . prototype ; %NWL%Keyframes . prototype . clone = function ( parent )  {%NWL%var clone = new Keyframes ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%9
styleFunc : 	null ,%NWL%font : 		 "  "  ,%NWL%fontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = lang . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%du . updateWithPattern ( this . opt , kwArgs , this . optionalParams )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%9
}  , false , this )  ;%NWL%} else {%NWL%g1 . deselect (  )  ; %NWL%g2 . deselect (  )  ;%NWL%}%NWL%delete this . selectedGem ;%NWL%}  ; %NWL%rb . Board . prototype . swap = function ( g1 , g2 )  {%NWL%var tempc = g1 . c , tempr = g1 . r ; %NWL%g1 . c = g2 . c ; %NWL%g1 . r = g2 . r ; %NWL%9
EditArea . prototype . init = function (  )  {%NWL%var t = this , a , s = t . settings ; %NWL%t . textarea			 = _$ (  " textarea "  )  ; %NWL%t . container			 = _$ (  " container "  )  ; %NWL%t . result			 = _$ (  " result "  )  ; %NWL%t . content_highlight	 = _$ (  " content_highlight "  )  ; %NWL%t . selection_field	 = _$ (  " selection_field "  )  ; %NWL%t . selection_field_text = _$ (  " selection_field_text "  )  ; %NWL%t . processing_screen	 = _$ (  " processing "  )  ; %NWL%t . editor_area		 = _$ (  " editor "  )  ; %NWL%t . tab_browsing_area	 = _$ (  " tab_browsing_area "  )  ; %NWL%2
first = !first%NWL%}%NWL%else {%NWL%$scope . nameIndexToShow = $scope . nameIndexToShow +  ' _ '  + $scope . prop2add [ entry ]  ;%NWL%}%NWL%}%NWL%}%NWL%$scope . saveNewIndex = function (  )  {%NWL%if ( $scope . nameIndexToShow =  = undefined || $scope . nameIndexToShow =  =  "  " || $scope . nameIndexToShow =  = null )%NWL%return ; %NWL%if ( $scope . newIndex [  ' type '  ]  =  = undefined || $scope . newIndex [  ' type '  ]  =  =  "  " || $scope . newIndex [  ' type '  ]  =  = null )%NWL%8
Object . isSealed = function isSealed ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isFrozen )  {%NWL%Object . isFrozen = function isFrozen ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isExtensible )  {%NWL%Object . isExtensible = function isExtensible ( object )  {%NWL%0
sensorDefinitions . goLinkPH . sensorName = i18n . t (  " sensor . names . goLinkPH "  )  ; %NWL%sensorDefinitions . goLinkCO2 . measurementName = i18n . t (  " sensor . measurements . CO2_concentration "  )  ; %NWL%sensorDefinitions . goLinkCO2 . sensorName = i18n . t (  " sensor . names . goLinkCO2 "  )  ; %NWL%sensorDefinitions . goLinkO2 . measurementName = i18n . t (  " sensor . measurements . O2_concentration "  )  ; %NWL%sensorDefinitions . goLinkO2 . sensorName = i18n . t (  " sensor . names . goLinkO2 "  )  ; %NWL%sensorDefinitions . labQuestMotion . measurementName = i18n . t (  " sensor . measurements . distance "  )  ; %NWL%sensorDefinitions . labQuestMotion . sensorName = i18n . t (  " sensor . names . labQuestMotion "  )  ; %NWL%sensorDefinitions . labQuestTemperature . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . labQuestTemperature . sensorName = i18n . t (  " sensor . names . labQuestTemperature "  )  ; %NWL%sensorDefinitions . labQuestLight . measurementName = i18n . t (  " sensor . measurements . light_intensity "  )  ; %NWL%sensorDefinitions . labQuestLight . sensorName = i18n . t (  " sensor . names . labQuestLight "  )  ; %NWL%0
}%NWL%if ( !options . handler )  {%NWL%throw new Error (  ' No handler option passed to Waypoint constructor '  )%NWL%}%NWL%this . key =  ' waypoint -  '  + keyCounter%NWL%this . options = Waypoint . Adapter . extend (  {  }  , Waypoint . defaults , options )%NWL%this . element = this . options . element%NWL%this . adapter = new Waypoint . Adapter ( this . element )%NWL%this . callback = options . handler%NWL%this . axis = this . options . horizontal ? ' horizontal '  :  ' vertical '%NWL%this . enabled = this . options . enabled%NWL%6
utils = require (  "  .  .  / utils "  )  ,%NWL%defineGetter = utils . defineGetter ,%NWL%defineSetter = utils . defineSetter ,%NWL%inheritFrom = utils . inheritFrom ,%NWL%cssom = require (  " cssom "  )  ,%NWL%cssstyle = require (  " cssstyle "  )  ,%NWL%assert = require (  ' assert '  )  ; %NWL%core . StyleSheet = cssom . StyleSheet ; %NWL%core . MediaList = cssom . MediaList ; %NWL%core . CSSStyleSheet = cssom . CSSStyleSheet ; %NWL%core . CSSRule = cssom . CSSRule ; %NWL%7
}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%shouldCorrectlyAddAndRemoveUser : function ( test )  {%NWL%var user_name =  ' spongebob2 '  ; %NWL%var password =  ' password '  ; %NWL%var p_client = new Db ( MONGODB , new Server (  " 127 . 0 . 0 . 1 "  , 27017 ,  { auto_reconnect : true }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%p_client . bson_deserializer = client . bson_deserializer ; %NWL%p_client . bson_serializer = client . bson_serializer ; %NWL%9
__callback1 : function ( hashObject , args )  {%NWL%this . assertJsonEquals ( hashObject , this . hm . getHashObject (  )  )  ; %NWL%this . assertTrue ( args . myarg =  =  " cb1 "  )  ; %NWL%this . __callbackCount [  " __callback1 "  ]  =  ( this . __callbackCount [  " __callback1 "  ]  )%NWL%? this . __callbackCount [  " __callback1 "  ]  + 1%NWL% : 1 ;%NWL%}  ,%NWL%__callback2 : function ( hashObject , args )  {%NWL%this . assertJsonEquals ( hashObject , this . hm . getHashObject (  )  )  ; %NWL%this . assertTrue ( args . myarg =  =  " cb2 "  )  ; %NWL%this . __callbackCount [  " __callback2 "  ]  =  ( this . __callbackCount [  " __callback2 "  ]  )%NWL%3
if ( fireArgs )  {%NWL%fireArgs [ 0 ]  = ef ;%NWL%}%NWL%} else {%NWL%if ( fireArgs )  {%NWL%fireArgs . unshift ( ef )  ;%NWL%}%NWL%}%NWL%ef . details = this . details ; %NWL%ef . target = this . originalTarget || this . target ; %NWL%ef . currentTarget = this . currentTarget ; %NWL%8
this . bz = snabbtjs . option_or_default ( config . bz , 0 )  ; %NWL%this . skew_x = snabbtjs . option_or_default ( config . skew_x , 0 )  ; %NWL%this . skew_y = snabbtjs . option_or_default ( config . skew_y , 0 )  ; %NWL%this . offset_x = snabbtjs . option_or_default ( config . offset_x , 0 )  ; %NWL%this . offset_y = snabbtjs . option_or_default ( config . offset_y , 0 )  ; %NWL%this . offset_z = snabbtjs . option_or_default ( config . offset_z , 0 )  ; %NWL%this . sx = snabbtjs . option_or_default ( config . sx , 1 )  ; %NWL%this . sy = snabbtjs . option_or_default ( config . sy , 1 )  ; %NWL%this . width = config . width ; %NWL%this . height = config . height ; %NWL%this . opacity = snabbtjs . option_or_default ( config . opacity , 1 )  ; %NWL%6
if ( verOpts . name =  = undefined )  {%NWL%throw new Error (  " NAME is a required filed when creating a version "  )  ;%NWL%}%NWL%var ver =  {  }  ; %NWL%ver . name = verOpts . name ; %NWL%ver . desc = verOpts . desc || "  "  ; %NWL%ver . api_name = verOpts . api_name ; %NWL%ver . docsPath = verOpts . docsPath ; %NWL%ver . inDocs = verOpts . inDocs =  =  = false ? false : true ; %NWL%ver . envs = verOpts . envs || [  " dev "  ]  ; %NWL%ver . available = verOpts . available =  =  = false ? false : true ; %NWL%8
mCommandRegistry , mContentTypes , mFileClient , mFileCommands , mEditorCommands , mSelection , mStatus , mProgress , mOperationsClient , mOutliner , mDialogs , mExtensionCommands , ProjectCommands , mSearchClient ,%NWL%EventTarget , URITemplate , i18nUtil , PageUtil , objects , lib , Deferred , mProjectClient , mSplitter , mSplitMenu%NWL%)  {%NWL%var exports =  {  }  ; %NWL%var enableSplitEditor = false ; %NWL%var uriTemplate = new URITemplate (  " # {  , resource , params *  }  "  )  ;  /  / $NON - NLS - 0$%NWL%function MenuBar ( options )  {%NWL%this . parentNode = options . parentNode ; %NWL%this . commandRegistry = options . commandRegistry ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . fileClient = options . fileClient ; %NWL%7
if ( isDefined ( options . color )  )  {%NWL%this . color = options . color ;%NWL%}%NWL%if ( isDefined ( options . fontColor )  )  {%NWL%this . fontColor = options . fontColor ;%NWL%}%NWL%if ( isDefined ( options . backgroundColor )  )  {%NWL%this . backgroundColor = options . backgroundColor ;%NWL%}%NWL%if ( isDefined ( options . fontSize )  )  {%NWL%this . fontSize = options . fontSize ; %NWL%1
this . formatlessPasteOption = this . settings . formatlessPasteOption ;%NWL%}%NWL%if ( typeof this . settings . strippedElements ! =  =  ' undefined '  )  {%NWL%this . strippedElements = this . settings . strippedElements ;%NWL%}%NWL%if ( this . settings . config )  {%NWL%if ( this . settings . config . formatlessPasteOption )  {%NWL%this . formatlessPasteOption = this . settings . config . formatlessPasteOption ;%NWL%}%NWL%if ( this . settings . config . strippedElements )  {%NWL%this . strippedElements = this . settings . config . strippedElements ; %NWL%7
_ . CO_GENERATOR_ALLOWED = 0 ; %NWL%_ . CO_FUTURE_DIVISION = 8192 ; %NWL%_ . CO_FUTURE_ABSOLUTE_IMPORT = 16384 ; %NWL%_ . CO_FUTURE_WITH_STATEMENT = 32768 ; %NWL%_ . CO_FUTURE_PRINT_FUNCTION = 65536 ; %NWL%_ . CO_FUTURE_UNICODE_LITERALS = 131072 ; %NWL%_ . _Feature = Class (  ' _Feature '  ,  [  ]  ,  ( function (  )  {%NWL%var __0 =  {  }  ; %NWL%__0 . __init__ = $def ( function $___init__ ( self , optionalRelease , mandatoryRelease , compiler_flag )  {  /  / 75%NWL%self . optional = optionalRelease ; %NWL%self . mandatory = mandatoryRelease ; %NWL%9
if ( Y_Lang . isArray ( fillColor )  )%NWL%{%NWL%markerStyles . fill . color = fillColor [ i % fillColor . length ]  ;%NWL%}%NWL%else%NWL%{%NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ;%NWL%}%NWL%if ( Y_Lang . isArray ( borderColor )  )%NWL%{%NWL%markerStyles . border . color = borderColor [ i % borderColor . length ]  ; %NWL%2
}  ;%NWL%}  ; %NWL%var parseAcknowledgment = exports . _parseAcknowledgment = function ( aBuffer )  {%NWL%var calculatedChecksum ; %NWL%var expectedPacketLength ; %NWL%var responsePacket ; %NWL%if ( aBuffer . length >  = spheroMinimumPacketSize )  {  /  / Don ' t bother until we get a minimum sized packet%NWL%responsePacket = Object . create ( spheroResponseTemplate )  ; %NWL%responsePacket . SOP1 = aBuffer . readUInt8 ( spheroResponseTemplate . SOP1 )  ; %NWL%responsePacket . SOP2 = aBuffer . readUInt8 ( spheroResponseTemplate . SOP2 )  ; %NWL%responsePacket . MRSP = aBuffer . readUInt8 ( spheroResponseTemplate . MRSP )  ; %NWL%8
myDialog . then ( function ( button )  {%NWL%switch ( button )  {%NWL%case 0 : %NWL%service_ . transaction . abort (  )  ; %NWL%break ; %NWL%case 1 : %NWL%service_ . ourName = translate_ . instant (  ' transaction '  )  ; %NWL%service_ . theirName = translate_ . instant (  ' repository '  )  ; %NWL%service_ . ours = mergeFailure . ours ; %NWL%service_ . theirs = mergeFailure . theirs ; %NWL%service_ . ancestor = mergeFailure . ancestor ; %NWL%8
this . height = opts . height || 1 ; %NWL%this . x = opts . x || 0 ; %NWL%this . y = opts . y || 0 ; %NWL%this . w = opts . w || 1 ; %NWL%this . h = opts . h || 1 ; %NWL%this . _webglInitted = false ;%NWL%}%NWL%Component . extend ( Sprite )  ; %NWL%Sprite . prototype . copy = function ( other )  {%NWL%this . visible = other . visible ; %NWL%this . blending = other . blending ; %NWL%9
} else {%NWL%mouse . baseuprgba2 = eyedropRgba ( mouse . context , mouse . pos . x , mouse . pos . y )  ; %NWL%tool . brushendup =  { x : mouse . pos . x , y : mouse . pos . y }  ; %NWL%$ (  " #colordex2_endup "  )  . css (  {  ' top '  : mouse . pos . y - 8 ,  ' left '  : mouse . pos . x - 8 }  )  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%pcanvas . onmouseover = function ( e )  {%NWL%mouse . canvas = palettecanvas ; %NWL%mouse . context = palettecontext ; %NWL%9
timer : null ,%NWL%setup : function (  )  {%NWL%this . timer = registry . get (  ' timer '  )  ; %NWL%this . level = registry . get (  ' currentLevel '  )  ; %NWL%this . input = registry . get (  ' input '  )  ; %NWL%var camera = this . camera = new THREE . PerspectiveCamera ( 25 , screenUtil . width / screenUtil . height , 50 , 1e7 )  ; %NWL%this . scene . add ( camera )  ; %NWL%var controls = this . controls = new SpaceshipControls ( camera )  ; %NWL%controls . movementSpeed = 0 ; %NWL%controls . rollSpeed = this . shipStats . rollSpeed ; %NWL%controls . maxSpeed = this . shipStats . maxSpeed ; %NWL%9
}%NWL%}  ; %NWL%p . clone = function (  )  {%NWL%return new Ease ( this )  ;%NWL%}  ; %NWL%p . match = function ( ease )  {%NWL%return ease . type =  =  = this . type &&%NWL%ease . points [ 0 ]  =  =  = this . points [ 0 ] &&%NWL%ease . points [ 1 ]  =  =  = this . points [ 1 ] &&%NWL%ease . points [ 2 ]  =  =  = this . points [ 2 ] &&%NWL%ease . points [ 3 ]  =  =  = this . points [ 3 ] &&%NWL%7
self . writable = self . targetsocket . writable ; %NWL%self . emit (  ' error '  , exception )  ;%NWL%}  )  ; %NWL%self . targetsocket . on (  ' timeout '  , function (  )  {%NWL%self . emit (  ' timeout '  )  ;%NWL%}  )  ; %NWL%if ( self . targetsocket . remotePort )  {%NWL%self . remotePort = self . targetsocket . remotePort ;%NWL%}%NWL%if ( self . targetsocket . remoteAddress )  {%NWL%self . remoteAddress = self . targetsocket . remoteAddress ; %NWL%0
var PooledClass = require (  ' PooledClass '  )  ; %NWL%var invariant = require (  ' invariant '  )  ; %NWL%var mixInto = require (  ' mixInto '  )  ; %NWL%function CallbackQueue (  )  {%NWL%this . _callbacks = null ; %NWL%this . _contexts = null ;%NWL%}%NWL%mixInto ( CallbackQueue ,  {%NWL%enqueue : function ( callback , context )  {%NWL%this . _callbacks = this . _callbacks || [  ]  ; %NWL%this . _contexts = this . _contexts || [  ]  ; %NWL%9
}%NWL%}  ; %NWL%if ( typeof exports ! =  =  ' undefined '  )  {%NWL%exports . getIsoModel = function ( gameWorld , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )%NWL%{%NWL%var gameWorldObj =  {  }  ; %NWL%gameWorldObj . Cells  = gameWorld ;  /  / hack because this was written for clientside originally . sorry time is short :  /%NWL%return new GameWorldModelIso ( gameWorldObj , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )  ;%NWL%}%NWL%exports . update = GameWorldModelIso . prototype . update ; %NWL%exports . getAllVisibleCells = GameWorldModelIso . prototype . getAllVisibleCells ; %NWL%9
password :  '  '%NWL%}%NWL%if ( conf . database )  {%NWL%if ( conf . database . host )  {%NWL%mongoDBConfig . host = conf . database . host%NWL%}%NWL%if ( conf . database . port )  {%NWL%mongoDBConfig . port = conf . database . port%NWL%}%NWL%if ( conf . database . name )  {%NWL%mongoDBConfig . name = conf . database . name%NWL%4
Object . keys ( fs )  . forEach ( function ( key )  {%NWL%var func = fs [ key ]%NWL%if ( typeof func =  =  ' function '  )%NWL%fse [ key ]  = func%NWL%}  )%NWL%fs = fse%NWL%var copy = require (  '  .  / copy '  )%NWL%fs . copy = copy . copy%NWL%fs . copySync = copy . copySync%NWL%var remove = require (  '  .  / remove '  )%NWL%fs . remove = remove . remove%NWL%7
this . dbProvider = dbProvider ; %NWL%crudOperations = crudOperation ; %NWL%this . clientApi = clientApi ; %NWL%this . crudOperation = crudOperation ; %NWL%this . actionEnd = __bind ( this . actionEnd , this )  ; %NWL%this . actionProcess = __bind ( this . actionProcess , this )  ; %NWL%this . tryAction = __bind ( this . tryAction , this )  ; %NWL%this . getTree = __bind ( this . getTree , this )  ; %NWL%this . removeAll = __bind ( this . removeAll , this )  ; %NWL%this . remove = __bind ( this . remove , this )  ; %NWL%this . updateOne = __bind ( this . updateOne , this )  ; %NWL%4
t . query = r . query ;%NWL%} else {%NWL%if ( r . authority ! =  = null )  {%NWL%t . authority = r . authority ; %NWL%t . path = removeDotSegments ( r . path )  ; %NWL%t . query = r . query ;%NWL%} else {%NWL%if ( r . path =  =  =  '  '  )  {%NWL%t . path = base . path ; %NWL%if ( r . query ! =  = null )  {%NWL%t . query = r . query ; %NWL%3
var path = require (  ' path '  )  ; %NWL%var crypto = require (  ' crypto '  )  ; %NWL%var Busboy = require (  ' busboy '  )  ; %NWL%var mkdirp = require (  ' mkdirp '  )  ; %NWL%var is = require (  ' type - is '  )  ; %NWL%var qs = require (  ' qs '  )  ; %NWL%module . exports = function ( options )  {%NWL%options = options || {  }  ; %NWL%options . includeEmptyFields = options . includeEmptyFields || false ; %NWL%options . inMemory = options . inMemory || false ; %NWL%options . putSingleFilesInArray = options . putSingleFilesInArray || false ; %NWL%8
default : %NWL%BABYLON . Matrix . IdentityToRef ( this . _cachedTextureMatrix )  ; %NWL%break ;%NWL%}%NWL%return this . _cachedTextureMatrix ;%NWL%}  ; %NWL%Texture . prototype . clone = function (  )  {%NWL%var newTexture = new Texture ( this . _texture . url , this . getScene (  )  , this . _noMipmap , this . _invertY , this . _samplingMode )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%newTexture . wrapU = this . wrapU ; %NWL%8
' true '  : true ,%NWL%' false '  : false%NWL%}  ; %NWL%Backbone . ViewModel =  ( function ( _super )  {%NWL%__extends ( ViewModel , _super )  ; %NWL%function ViewModel ( attributes , options )  {%NWL%this . onVirtual = __bind ( this . onVirtual , this )  ; %NWL%this . createVirtual = __bind ( this . createVirtual , this )  ; %NWL%this . virtual = __bind ( this . virtual , this )  ; %NWL%this . pass = __bind ( this . pass , this )  ; %NWL%this . compute = __bind ( this . compute , this )  ; %NWL%6
exports . https						 = require . resolve (  ' https - browserify '  )  ; %NWL%exports . module						 = null ; %NWL%exports . net							 = null ; %NWL%exports . os							 = require . resolve (  ' os - browserify / browser . js '  )  ; %NWL%exports . path						 = require . resolve (  ' path - browserify '  )  ; %NWL%exports . punycode					 = require . resolve (  ' punycode /  '  )  ; %NWL%exports . process						 = require . resolve (  ' process / browser . js '  )  ; %NWL%exports . querystring					 = require . resolve (  ' querystring - es3 /  '  )  ; %NWL%exports . readline					 = null ; %NWL%exports . repl						 = null ; %NWL%exports . stream						 = require . resolve (  ' stream - browserify '  )  ; %NWL%0
}  ; %NWL%RenderTarget . prototype . setWrap = function ( value )  {%NWL%this . wrap = value ; %NWL%this . needsUpdate = true ;%NWL%}  ; %NWL%RenderTarget . prototype . toJSON = function ( json )  {%NWL%json = Class . prototype . toJSON . call ( this , json )  ; %NWL%json . width = this . width ; %NWL%json . height = this . height ; %NWL%json . invWidth = this . invWidth ; %NWL%json . invHeight = this . invHeight ; %NWL%7
}  ; %NWL%var Module = function ( options )  {%NWL%var self = this ; %NWL%self . name = options . name || null ; %NWL%self . files =  [  ]  ; %NWL%self . declaredExports = options . declaredExports ; %NWL%self . useGlobalNamespace = options . useGlobalNamespace ; %NWL%self . combinedServePath = options . combinedServePath ; %NWL%self . importStubServePath = options . importStubServePath ; %NWL%self . jsAnalyze = options . jsAnalyze ; %NWL%self . noLineNumbers = options . noLineNumbers ; %NWL%5
menu . Unhover (  )  ;%NWL%}%NWL%}%NWL%function WebPartManager (  )  {%NWL%this . overlayContainerElement = null ; %NWL%this . zones = new Array (  )  ; %NWL%this . dragState = null ; %NWL%this . menu = null ; %NWL%this . draggedWebPart = null ; %NWL%this . AddZone = WebPartManager_AddZone ; %NWL%this . IsDragDropEnabled = WebPartManager_IsDragDropEnabled ; %NWL%9
' DescribeTable '  ,  ' GetItem '  ,  ' ListTables '  ,  ' PutItem '  ,  ' Query '  ,  ' Scan '  ,  ' UpdateItem '  ,  ' UpdateTable '  ]  ,%NWL%actions =  {  }  ,%NWL%actionValidations =  {  }%NWL%module . exports = dynalite%NWL%function dynalite ( options )  {%NWL%options = options || {  }%NWL%var requestHandler = httpHandler . bind ( null , db . create ( options )  )%NWL%if ( options . ssl )  {%NWL%options . key = options . key || fs . readFileSync ( __dirname +  '  / key . pem '  )%NWL%options . cert = options . cert || fs . readFileSync ( __dirname +  '  / cert . pem '  )%NWL%options . ca = options . ca || fs . readFileSync ( __dirname +  '  / ca . pem '  )%NWL%8
var PostEffects =  ( function (  )  {%NWL%function PostEffects (  )  {%NWL%}%NWL%PostEffects . prototype . updateShader = function ( sm )  {%NWL%var shader = sm . get (  " shaders / posteffects . cgfx "  )  ; %NWL%if ( shader ! =  = this . shader )  {%NWL%this . shader = shader ; %NWL%this . bicolor . technique = shader . getTechnique (  " bicolor "  )  ; %NWL%this . copy . technique = shader . getTechnique (  " copy "  )  ; %NWL%this . copyFiltered . technique = shader . getTechnique (  " copyFiltered "  )  ; %NWL%this . fadein . technique = shader . getTechnique (  " fadein "  )  ; %NWL%7
}%NWL%}%NWL%GameBoyAdvanceSound . prototype . audioJIT = function (  )  {%NWL%this . generateAudio ( this . audioTicks | 0 )  ; %NWL%this . audioTicks = 0 ;%NWL%}%NWL%GameBoyAdvanceSound . prototype . computeNextPWMInterval = function (  )  {%NWL%for ( var numSamples = this . PWMWidthOld | 0 , clockUpTo = 0 ;  ( numSamples | 0 )  > 0 ; numSamples =  (  ( numSamples | 0 )  - 1 ) | 0 )  {%NWL%clockUpTo = Math . min ( this . audioClocksUntilNextEventCounter | 0 , this . sequencerClocks | 0 , numSamples | 0 ) | 0 ; %NWL%this . audioClocksUntilNextEventCounter =  (  ( this . audioClocksUntilNextEventCounter | 0 )  -  ( clockUpTo | 0 )  ) | 0 ; %NWL%this . sequencerClocks =  (  ( this . sequencerClocks | 0 )  -  ( clockUpTo | 0 )  ) | 0 ; %NWL%9
me . locked = state . locked ;%NWL%}%NWL%if ( defined ( state . sortable )  )  {%NWL%me . sortable = state . sortable ;%NWL%}%NWL%if ( defined ( state . width )  )  {%NWL%delete me . flex ; %NWL%me . width = state . width ;%NWL%} else if ( defined ( state . flex )  )  {%NWL%delete me . width ; %NWL%me . flex = state . flex ; %NWL%0
current . content . text = $ (  " #document - text "  )  . val (  )  ; %NWL%current . update (  )  . execute ( function ( response )  {%NWL%console . log (  " Update response =  "  + JSON . stringify ( response )  )  ; %NWL%loadDocuments (  )  ;%NWL%}  )  ;%NWL%}%NWL%else {%NWL%console . log (  " saveDocument ( new ) started "  )  ; %NWL%showMessage (  " Saving new document .  .  .  "  )  ; %NWL%current . subject = $ (  " #new - document - subject "  )  . val (  )  ; %NWL%current . html = $ (  " #new - document - html "  )  . val (  )  ; %NWL%9
allFiles . push ( new JSDOC . Symbol ( files [ i ]  ,  [  ]  ,  " FILE "  , new JSDOC . DocComment (  "  "  )  )  )  ;%NWL%}%NWL%for ( var i = 0 ; i < documentedFiles . length ; i +  +  )  {%NWL%var offset = files . indexOf ( documentedFiles [ i ]  . alias )  ; %NWL%allFiles [ offset ]  = documentedFiles [ i ]  ;%NWL%}%NWL%allFiles = allFiles . sort ( makeSortby (  " name "  )  )  ; %NWL%if ( defined ( JSDOC . PluginManager )  )  {%NWL%var directories = new Object (  )  ; %NWL%directories . outDir = publish . conf . outDir ; %NWL%directories . templatesDir = publish . conf . templatesDir ; %NWL%9
this . ix = 0 ; %NWL%this . iy = 0 ; %NWL%this . mx = 0 ; %NWL%this . my = 0 ; %NWL%this . vx = 0 ; %NWL%this . vy = 0 ; %NWL%this . onMouseMove = this . onMouseMove . bind ( this )  ; %NWL%this . onDeviceOrientation = this . onDeviceOrientation . bind ( this )  ; %NWL%this . onOrientationTimer = this . onOrientationTimer . bind ( this )  ; %NWL%this . onCalibrationTimer = this . onCalibrationTimer . bind ( this )  ; %NWL%this . onAnimationFrame = this . onAnimationFrame . bind ( this )  ; %NWL%6
this . offsetProperty = this . isVertical ? ' top '  :  ' left '  ; %NWL%this . offsetEventProperty = this . isVertical ? ' pageY '  :  ' pageX '  ; %NWL%this . value = this . options . value || 0 ; %NWL%this . maxValue = this . options . maxValue || 0 ; %NWL%this . currentSliderSize = 0 ; %NWL%this . handleSize = 0 ; %NWL%this . holder = $ ( this . options . holder )  ; %NWL%this . scrollbar = $ ( this . options . scrollbarStructure )  . appendTo ( this . holder )  ; %NWL%this . btnDec = this . scrollbar . find ( this . options . btnDecSelector )  ; %NWL%this . btnInc = this . scrollbar . find ( this . options . btnIncSelector )  ; %NWL%this . slider = this . scrollbar . find ( this . options . sliderSelector )  ; %NWL%8
Model . create   = _ . bind ( table . create , table )  ; %NWL%Model . update   = _ . bind ( table . update , table )  ; %NWL%Model . destroy   = _ . bind ( table . destroy , table )  ; %NWL%Model . query   = _ . bind ( table . query , table )  ; %NWL%Model . scan   = _ . bind ( table . scan , table )  ; %NWL%Model . parallelScan = _ . bind ( table . parallelScan , table )  ; %NWL%Model . getItems = batch ( table , serializer )  . getItems ; %NWL%Model . batchGetItems = batch ( table , serializer )  . getItems ; %NWL%Model . createTable  = _ . bind ( table . createTable , table )  ; %NWL%Model . updateTable  = _ . bind ( table . updateTable , table )  ; %NWL%Model . describeTable = _ . bind ( table . describeTable , table )  ; %NWL%0
binding = params . newBindingParams (  )  ; %NWL%binding . bindByName (  " uuid "  , uuid )  ; %NWL%params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%request . requestUrl = stmt . row . requestUrl ; %NWL%request . requestMethod = stmt . row . requestMethod ; %NWL%6
}%NWL%}%NWL%if ( !reduced )  {%NWL%reduced = JSON . parse ( JSON . stringify ( rows [ key ]  )  )  ; %NWL%continue ;%NWL%}%NWL%row = rows [ key ]  ; %NWL%if ( row . sort_open )  {%NWL%if ( row . sort_open < reduced . sort_open )  {%NWL%reduced . sort_open = row . sort_open ; %NWL%reduced . open_time = row . open_time ; %NWL%9
this . diskVersion =  '  '  ;     /  / version in the plugin ' s metadata%NWL%this . dbVersion =  '  '  ;     /  / version in the instance database%NWL%this . requiredBuilderVersion =  '  '  ;  /  / required version of Adapt - Builder - Core%NWL%this . dependencies =  [  ]  ;     /  / other plugins that are expected to be installed%NWL%}%NWL%PluginInfo . prototype . init = function ( data )  {%NWL%this . version = data . version ; %NWL%this . diskVersion = data . version ; %NWL%this . requiredBuilderVersion = data . requires ; %NWL%this . dependencies = data . dependencies || this . dependencies ; %NWL%this . displayName = data . displayName ; %NWL%6
return ;%NWL%}%NWL%this . _applyUrl ( el )  ; %NWL%if ( this . setVisible )  {%NWL%el . style . visibility =  ' visible '  ;%NWL%}%NWL%if ( this . width )  {%NWL%el . width = this . width ;%NWL%}%NWL%if ( this . height )  {%NWL%el . height = this . height ; %NWL%7
this . _parser . on (  ' body '  ,    HTTPParser . prototype . _onBody . bind ( this )  )  ; %NWL%this . _parser . on (  ' messageComplete '  , HTTPParser . prototype . _onMessageComplete . bind ( this )  )  ;%NWL%}%NWL%HTTPParser . prototype . _onHeadersComplete = function ( result )  {%NWL%this . method    = this . _parser . method ; %NWL%this . url    = this . _parser . url ; %NWL%this . versionMajor  = this . _parser . versionMajor ; %NWL%this . versionMinor  = this . _parser . versionMinor ; %NWL%this . shouldKeepAlive = this . _parser . shouldKeepAlive ; %NWL%this . statusCode   = this . _parser . statusCode ; %NWL%this . statusMessage  = this . _parser . statusMessage ; %NWL%4
} catch ( e )  {%NWL%return InjectedScript . RemoteObject . fromException ( e )  ;%NWL%}%NWL%}%NWL%InjectedScript . CallFrameProxy = function ( ordinal , callFrame )%NWL%{%NWL%this . id =  { ordinal : ordinal , injectedScriptId : injectedScriptId }  ; %NWL%this . type = callFrame . type ; %NWL%this . functionName =  ( this . type =  =  =  " function " ? callFrame . functionName :  "  "  )  ; %NWL%this . sourceID = callFrame . sourceID ; %NWL%this . line = callFrame . line ; %NWL%7
fs . removeSync = remove . removeSync%NWL%fs [  ' delete '  ]  = fs . remove%NWL%fs . deleteSync = fs . removeSync%NWL%var mkdir = require (  '  .  / mkdir '  )%NWL%fs . mkdirs = mkdir . mkdirs%NWL%fs . mkdirsSync = mkdir . mkdirsSync%NWL%fs . mkdirp = fs . mkdirs%NWL%fs . mkdirpSync = fs . mkdirsSync%NWL%var create = require (  '  .  / create '  )%NWL%fs . createFile = create . createFile%NWL%fs . createFileSync = create . createFileSync%NWL%9
var Stat = function ( opts )  {%NWL%this . uid = opts . uid || 0 ; %NWL%this . gid = opts . gid || 0 ; %NWL%this . mode = opts . mode || 0 ; %NWL%this . size = opts . size || 0 ; %NWL%this . mtime = toDate ( opts . mtime )  ; %NWL%this . atime = toDate ( opts . atime )  ; %NWL%this . ctime = toDate ( opts . ctime )  ; %NWL%this . type = opts . type ; %NWL%this . target = opts . target ; %NWL%this . link = opts . link ; %NWL%8
}  ; %NWL%var current_keys =  {%NWL%codes :  {  }  ,%NWL%ctrl : false ,%NWL%alt : false ,%NWL%shift : false%NWL%}  ; %NWL%function update_current_modifiers ( key )  {%NWL%current_keys . ctrl = key . ctrl ; %NWL%current_keys . alt = key . alt ; %NWL%current_keys . shift = key . shift ; %NWL%8
}  ; %NWL%lineparser . upper = this . upper = function (  )  {%NWL%var c ; %NWL%c = self . data [ self . cur ]  ; %NWL%if (  (  ' A '  <  = c && c <  =  ' Z '  )  )  {%NWL%self . cur +  +  ; %NWL%self . row +  +  ; %NWL%return c ;%NWL%}%NWL%}  ; %NWL%lineparser . identifier = this . identifier = function (  )  {%NWL%1
var el = this . elements_ . shift (  )  ; %NWL%this . setPosition ( el ,%NWL%goog . dom . TagWalkType . START_TAG ,%NWL%goog . dom . TagWalkType . START_TAG )  ; %NWL%return el ;%NWL%}%NWL%return goog . dom . ControlRangeIterator . superClass_ . next . call ( this )  ;%NWL%}  ; %NWL%goog . dom . ControlRangeIterator . prototype . copyFrom = function ( other )  {%NWL%this . elements_ = other . elements_ ; %NWL%this . startNode_ = other . startNode_ ; %NWL%9
}%NWL%this . relayout (  )  ; %NWL%var config =  {  }  ; %NWL%for ( var i = 0 ; i < this . children . length ; i +  +  )  {%NWL%var iter = this . children [ i ]  ; %NWL%iter . setVisible ( true )  ; %NWL%iter . save . x = iter . x ; %NWL%iter . save . y = iter . y ; %NWL%if ( iter ! = origin )  {%NWL%iter . x = origin . x ; %NWL%iter . y = origin . y ; %NWL%9
}  )  ; %NWL%if ( preview )  {%NWL%self . update ( preview . drawable )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%function TileCompositor ( tile )  {%NWL%var canvas = document . createElement (  ' canvas '  )  ,%NWL%ctx ; %NWL%canvas . width = tile . width ; %NWL%canvas . height = tile . height ; %NWL%9
nb0 . p1y =  ( nb0 . c1y + nb1 . c0y )  * t ; %NWL%nb1 . p0y = nb0 . p1y ; %NWL%return { b0 : nb0 , b1 : nb1 }  ;%NWL%}%NWL%self . prototype . duplicate = function (  )  {%NWL%var cv = new an . Curve (  )  ; %NWL%cv . p0x = this . p0x ; %NWL%cv . p0y = this . p0y ; %NWL%cv . c0x = this . c0x ; %NWL%cv . c0y = this . c0y ; %NWL%cv . p1x = this . p1x ; %NWL%6
var jwt = require (  ' express - jwt '  )  ; %NWL%var bodyParser = require (  ' body - parser '  )  ;  /  / bodyparser + json + urlencoder%NWL%var morgan  = require (  ' morgan '  )  ;  /  / logger%NWL%var tokenManager = require (  '  .  / config / token_manager '  )  ; %NWL%var secret = require (  '  .  / config / secret '  )  ; %NWL%app . listen ( 3001 )  ; %NWL%app . use ( bodyParser (  )  )  ; %NWL%app . use ( morgan (  )  )  ; %NWL%var routes =  {  }  ; %NWL%routes . posts = require (  '  .  / route / posts . js '  )  ; %NWL%routes . users = require (  '  .  / route / users . js '  )  ; %NWL%9
}%NWL%return element ;%NWL%}  ,%NWL%fixEvent = function ( e )  {%NWL%var result =  {  }  ; %NWL%if ( !e )  {%NWL%return result ;%NWL%}%NWL%var type = e . type , target = e . target || e . srcElement ; %NWL%result . preventDefault = fixEvent . preventDefault ( e )  ; %NWL%result . stopPropagation = fixEvent . stopPropagation ( e )  ; %NWL%9
y2s . push ( ele . y2 )  ; %NWL%_ys . push ( ele . _y )  ; %NWL%_y2s . push ( ele . _y2 )  ;%NWL%}%NWL%this . sampler = new PlotSampler ( xs , ys , _ys )  ; %NWL%this . sampler2 = new PlotSampler ( xs , y2s , _y2s )  ;%NWL%}  ; %NWL%PlotStemLodLoader . prototype . filter = function ( scope )  {%NWL%this . plotter . filter ( scope )  ; %NWL%this . vindexL = this . plotter . vindexL ; %NWL%this . vindexR = this . plotter . vindexR ; %NWL%9
console . log ( markupPath +  '  /  '  + self . name +  '  . jade '  )  ; %NWL%funcs . push ( Q . nfcall ( fs . outputFile , markupPath +  '  /  '  + self . name +  '  . jade '  , self . markup )  )  ;%NWL%}%NWL%return Q . all ( funcs )  ;%NWL%}%NWL%}  ,%NWL%hooks :  {%NWL%beforeValidate : function ( vizType , next )  {%NWL%if ( isPostgres )  {%NWL%vizType . sampleData = JSON . stringify ( vizType . sampleData )  ; %NWL%vizType . sampleOptions = JSON . stringify ( vizType . sampleOptions )  ; %NWL%9
this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . locales = obj . locales ;%NWL%}  ; %NWL%cubes . Measure = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%1
C . lua_pushnumber = F (  " lua_pushnumber "  , void_t ,  [ lua_State , lua_Number ]  )  ; %NWL%C . lua_pushinteger = F (  " lua_pushinteger "  , void_t ,  [ lua_State , lua_Integer ]  )  ; %NWL%C . lua_pushlstring = F (  " lua_pushlstring "  , void_t ,  [ lua_State , const_char_ptr_t , size_t ]  )  ; %NWL%C . lua_pushstring = F (  " lua_pushstring "  , void_t ,  [ lua_State , const_char_ptr_t ]  )  ; %NWL%C . lua_pushcclosure = F (  " lua_pushcclosure "  , void_t ,  [ lua_State , lua_CFunction , int_t ]  )  ; %NWL%C . lua_pushboolean = F (  " lua_pushboolean "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushlightuserdata = F (  " lua_pushlightuserdata "  , void_t ,  [ lua_State , void_ptr_t ]  )  ; %NWL%C . lua_pushthread = F (  " lua_pushthread "  , int_t ,  [ lua_State ]  )  ; %NWL%C . lua_gettable = F (  " lua_gettable "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_getfield = F (  " lua_getfield "  , void_t ,  [ lua_State , int_t , const_char_ptr_t ]  )  ; %NWL%C . lua_rawget = F (  " lua_rawget "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%5
if ( !defined ( result )  )  {%NWL%result = new RectangleGraphics (  )  ;%NWL%}%NWL%result . show = this . show ; %NWL%result . coordinates = this . coordinates ; %NWL%result . material = this . material ; %NWL%result . height = this . height ; %NWL%result . extrudedHeight = this . extrudedHeight ; %NWL%result . granularity = this . granularity ; %NWL%result . stRotation = this . stRotation ; %NWL%result . rotation = this . rotation ; %NWL%3
else if ( this . response )  {%NWL%this . response . abort (  )%NWL%}%NWL%this . emit (  " abort "  )%NWL%}%NWL%Request . prototype . pipeDest = function ( dest )  {%NWL%var response = this . response%NWL%if ( dest . headers )  {%NWL%dest . headers [  ' content - type '  ]  = response . headers [  ' content - type '  ]%NWL%if ( response . headers [  ' content - length '  ]  )  {%NWL%dest . headers [  ' content - length '  ]  = response . headers [  ' content - length '  ]%NWL%8
bb . buffer = buffer ; %NWL%bb . view = new BufferView ( this . buffer )  ; %NWL%var buffer = new ArrayBuffer ( this . buffer . byteLength )  ; %NWL%new Uint8Array ( buffer )  . set ( this . buffer )  ; %NWL%bb . buffer = buffer ; %NWL%bb . view = new DataView ( buffer )  ;%NWL%} else {%NWL%bb . buffer = this . buffer ; %NWL%bb . view = this . view ;%NWL%}%NWL%bb . offset = this . offset ; %NWL%7
menuObject . setAttribute (  " style "  , menuTranslate )  ; %NWL%menuObject . style . width = width +  ' px '  ;%NWL%}%NWL%self . previousWidth = window . innerWidth ;%NWL%}  , 300 )  ;%NWL%}%NWL%JBackbone . prototype . goToPage = function ( nextPage , config )  {%NWL%if ( !config ) config =  {  }  ; %NWL%if ( typeof config . addToHistory =  =  =  ' undefined '  ) config . addToHistory = true ; %NWL%if ( typeof config . resetHistory =  =  =  ' undefined '  ) config . resetHistory = false ; %NWL%if ( typeof config . closeMenu =  =  =  ' undefined '  ) config . closeMenu = true ; %NWL%8
}  ; %NWL%Y . extend ( IEEventFacade , Y . DOM2EventFacade , proto )  ; %NWL%Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%9
closeBottom : createPropertyDescriptor (  ' closeBottom '  )%NWL%}  )  ; %NWL%RectangleGraphics . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new RectangleGraphics (  )  ;%NWL%}%NWL%result . show = this . show ; %NWL%result . coordinates = this . coordinates ; %NWL%result . material = this . material ; %NWL%result . height = this . height ; %NWL%result . extrudedHeight = this . extrudedHeight ; %NWL%6
case 0 :  /  / init%NWL%this . width = this . height = this . x = this . y = 0 ; %NWL%break ; %NWL%case 1 :  /  / copy%NWL%this . width = a . width ; %NWL%this . height = a . height ; %NWL%this . x = a . x ; %NWL%this . y = a . y ; %NWL%break ; %NWL%case 2 :  /  /  ( x , y )  ,  ( width , height )%NWL%this . x = a . x ; %NWL%4
g . currentPage = lang . hitch ( this , this . currentPage )  ; %NWL%g . nextPage = lang . hitch ( this , this . nextPage )  ; %NWL%g . prevPage = lang . hitch ( this , this . prevPage )  ; %NWL%g . firstPage = lang . hitch ( this , this . firstPage )  ; %NWL%g . lastPage = lang . hitch ( this , this . lastPage )  ; %NWL%g . currentPageSize = lang . hitch ( this , this . currentPageSize )  ; %NWL%g . showGotoPageButton = lang . hitch ( this , this . showGotoPageButton )  ; %NWL%g . getTotalRowCount = lang . hitch ( this , this . getTotalRowCount )  ; %NWL%g . getTotalPageNum = lang . hitch ( this , this . getTotalPageNum )  ; %NWL%g . gotoPage = lang . hitch ( this , this . gotoPage )  ; %NWL%g . gotoFirstPage = lang . hitch ( this , this . gotoFirstPage )  ; %NWL%0
"  .  / models / jsnode "  ,%NWL%"  .  / models / buffer_queue "  ]  ,%NWL%function ( chime , dc , noise , probe , mic , spectrum , load_sample , sample , jsnode , buffer_queue )  {%NWL%return function maker ( S , sh )  {%NWL%var models = sh . models || ( sh . models =  {  }  )  ; %NWL%models . chime = chime ( S , sh )  ; %NWL%models . dc = dc ( S , sh )  ; %NWL%models . noise = noise ( S , sh )  ; %NWL%models . probe = probe ( S , sh )  ; %NWL%models . mic = mic ( S , sh )  ; %NWL%models . spectrum = spectrum ( S , sh )  ; %NWL%5
proto . runAScenarioCallingMappingWithParameters = function runAScenarioCallingMappingWithParameters ( callback )  {%NWL%this . expectedMappingArguments =  [ 5 ,  " fresh cucumbers "  ]  ; %NWL%this . addScenario (  "  "  ,  ' Given a mapping with '  + this . expectedMappingArguments [ 0 ]  +  '  "  '  + this . expectedMappingArguments [ 1 ]  +  '  "  '  )  ; %NWL%this . runFeature (  {  }  , callback )  ;%NWL%}  ; %NWL%proto . runAScenarioCallingMappingWithMultipleParameters = function runAScenarioCallingMappingWithMultipleParameters ( callback )  {%NWL%this . expectedMappingArguments =  [ 5 ,  " fresh cucumbers "  , 2 ,  ' pickled gherkins '  ]  ; %NWL%this . addScenario (  "  "  ,  ' Given a mapping with '  + this . expectedMappingArguments [ 0 ]  +  '  '  + this . expectedMappingArguments [ 2 ]  +  '  "  '  + this . expectedMappingArguments [ 1 ]  +  '  "  "  '  + this . expectedMappingArguments [ 3 ]  +  '  "  '  )  ; %NWL%this . runFeature (  {  }  , callback )  ;%NWL%}  ; %NWL%proto . runAScenarioCallingWorldFunction = function runAScenarioCallingWorldFunction ( callback )  {%NWL%0
dir : nl . dir . value ,%NWL%lang : nl . lang . value ,%NWL%usemap : nl . usemap . value ,%NWL%longdesc : nl . longdesc . value%NWL%}  )  ; %NWL%args . onmouseover = args . onmouseout =  '  '  ; %NWL%if ( f . onmousemovecheck . checked )  {%NWL%if ( nl . onmouseoversrc . value )%NWL%args . onmouseover =  " this . src =  '  "  + nl . onmouseoversrc . value +  "  '  ;  "  ; %NWL%if ( nl . onmouseoutsrc . value )%NWL%args . onmouseout =  " this . src =  '  "  + nl . onmouseoutsrc . value +  "  '  ;  "  ; %NWL%8
this . visible = opts . visible ! = undefined ? !! opts . visible : true ; %NWL%this . blending = opts . blending ! = undefined ? opts . blending : Enums . Blending . Default ; %NWL%this . layer = opts . layer ! = undefined ? opts . layer : 0 ; %NWL%this . z = opts . z ! = undefined ? opts . z : 0 ; %NWL%this . alpha = opts . alpha ! = undefined ? opts . alpha : 1 ; %NWL%this . material = opts . material ! = undefined ? opts . material : undefined ; %NWL%this . width = opts . width || 1 ; %NWL%this . height = opts . height || 1 ; %NWL%this . x = opts . x || 0 ; %NWL%this . y = opts . y || 0 ; %NWL%this . w = opts . w || 1 ; %NWL%6
fs . writeString = wrap ( fs . writeString ,  ' fs . write '  , 4 )  ; %NWL%fs . fstat = wrap ( fs . fstat ,  ' fs . fstat '  , 1 )  ; %NWL%fs . fsync = wrap ( fs . fsync ,  ' fs . fsync '  , 1 )  ; %NWL%fs . ftruncate = wrap ( fs . ftruncate ,  ' fs . ftruncate '  , 2 )  ; %NWL%fs . futimes = wrap ( fs . futimes ,  ' fs . futimes '  , 3 )  ; %NWL%fs . stat = wrap ( fs . stat ,  ' fs . stat '  , 1 )  ; %NWL%fs . link = wrap ( fs . link ,  ' fs . link '  , 2 )  ; %NWL%fs . lstat = wrap ( fs . lstat ,  ' fs . lstat '  , 1 )  ; %NWL%fs . chmod = wrap ( fs . chmod ,  ' fs . chmod '  , 2 )  ; %NWL%fs . chown = wrap ( fs . chown ,  ' fs . chown '  , 3 )  ; %NWL%fs . rename = wrap ( fs . rename ,  ' fs . rename '  , 2 )  ; %NWL%3
if ( mapping . source ! = null )  {%NWL%newMapping . source = mapping . source ; %NWL%if ( sourceRoot ! = null )  {%NWL%newMapping . source = util . relative ( sourceRoot , newMapping . source )  ;%NWL%}%NWL%newMapping . original =  {%NWL%line : mapping . originalLine ,%NWL%column : mapping . originalColumn%NWL%}  ; %NWL%if ( mapping . name ! = null )  {%NWL%newMapping . name = mapping . name ; %NWL%1
req ; %NWL%options =  {%NWL%host : this . host ,%NWL%port : this . port ,%NWL%path : this . path ,%NWL%method : this . method ,%NWL%headers :  {  ' Content - Type '  :  ' application / json '  }%NWL%}  ; %NWL%if ( this . ssl )  {%NWL%options . ca = this . ssl . ca ; %NWL%options . key = this . ssl . key ; %NWL%9
return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . registerHandler "  ; %NWL%wrapped . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . unregisterHandler "  ; %NWL%wrapped . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . send "  ; %NWL%wrapped . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . publish "  ; %NWL%wrapped . getConnectionState . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . getConnectionState "  ; %NWL%wrapped . isValidSession . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . isValidSession "  ; %NWL%wrapped . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . login "  ; %NWL%4
}%NWL%}  ;%NWL%}%NWL%outerElement . show = function (  )  {%NWL%this . container . style . display =  '  '  ;%NWL%}  ; %NWL%outerElement . show = outerElement . show . bind ( outerElement )  ; %NWL%outerElement . hide = function (  )  {%NWL%this . container . style . display =  ' none '  ;%NWL%}  ; %NWL%outerElement . hide = outerElement . hide . bind ( outerElement )  ; %NWL%6
this . id = idCounter +  +  ; %NWL%this . data = data ; %NWL%this . display = display ; %NWL%this . displayAttrs = _ . extend (  {%NWL%fill :  ' #CCC '  ,%NWL%stroke :  ' #000 '%NWL%}  , options . displayAttrs )  ; %NWL%this . isSolid = options . solid ; %NWL%this . isHeavy = options . heavy ; %NWL%this . onCollide = options . onCollide ; %NWL%this . onTick = options . onTick ; %NWL%9
}  ;%NWL%( exports . pathjoin = function pathjoin (  )  {%NWL%var paths =  [  ]  . slice . call ( arguments )  . map ( function ( path )  {%NWL%return path . first . string ;%NWL%}  )  ; %NWL%return path . join . apply ( null , paths )  ;%NWL%}  )  . raw = true ; %NWL%exports . red = function red ( color )  {%NWL%return exports . component ( color , new nodes . String (  ' red '  )  )  ;%NWL%}  ; %NWL%exports . green = function green ( color )  {%NWL%7
commands . push ( command )  ;%NWL%}%NWL%return commands ;%NWL%}%NWL%}  ; %NWL%CommandManager = new ( Registry . extend ( CommandManager )  )  (  )  ; %NWL%Aloha . execCommand = CommandManager . execCommand ; %NWL%Aloha . queryCommandEnabled = CommandManager . queryCommandEnabled ; %NWL%Aloha . queryCommandIndeterm = CommandManager . queryCommandIndeterm ; %NWL%Aloha . queryCommandState = CommandManager . queryCommandState ; %NWL%Aloha . queryCommandSupported = CommandManager . queryCommandSupported ; %NWL%6
winlocked : 0 ,  /  / fLockWn from WinProtect%NWL%wtf : false%NWL%}  ; %NWL%if ( options . password ) opts . password = options . password ; %NWL%var mergecells =  [  ]  ; %NWL%var objects =  [  ]  ; %NWL%var supbooks =  [  [  ]  ]  ;  /  / 1 - indexed , will hold extern names%NWL%var sbc = 0 , sbci = 0 , sbcli = 0 ; %NWL%supbooks . SheetNames = opts . snames ; %NWL%supbooks . sharedf = opts . sharedf ; %NWL%supbooks . arrayf = opts . arrayf ; %NWL%9
}  ,%NWL%_initEvents : function (  )  {%NWL%array . forEach ( this . grid . views . views , function ( view )  {%NWL%this . connect ( view ,  " onAfterRow "  , lang . hitch ( this ,  " _onAfterRow "  , view . index )  )  ;%NWL%}  , this )  ;%NWL%}  ,%NWL%_mixinGrid : function (  )  {%NWL%var g = this . grid ; %NWL%g . mergeCells = lang . hitch ( this ,  " mergeCells "  )  ; %NWL%g . unmergeCells = lang . hitch ( this ,  " unmergeCells "  )  ; %NWL%g . getMergedCells = lang . hitch ( this ,  " getMergedCells "  )  ; %NWL%8
this . yAxisLineWidth = 1 ; %NWL%this . startY = 0 ; %NWL%this . barHeight = 10 ; %NWL%this . chartType =  " hbar "  ;%NWL%}  ; %NWL%CanvasCharts . prototype . configure = function ( obj )  {%NWL%if ( obj . hasOwnProperty (  " bgFillStyle "  )  )  {%NWL%this . bgFillStyle = obj . bgFillStyle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " borderStrokeStyle "  )  )  {%NWL%this . borderStrokeStyle = obj . borderStrokeStyle ; %NWL%7
}  ; %NWL%block . bullet =  /  ( ? :  [  *  +  -  ] |\d + \ .  )  /  ; %NWL%block . item =  / ^ (  *  )  ( bull )  [ ^\n ]  *  ( ? : \n ( ?!\1bull )  [ ^\n ]  *  )  *  /  ; %NWL%block . item = replace ( block . item ,  ' gm '  )%NWL%(  / bull / g , block . bullet )%NWL%(  )  ; %NWL%block . list = replace ( block . list )%NWL%(  / bull / g , block . bullet )%NWL%(  ' hr '  ,  / \n +  ( ? =  ( ? :  *  [  -  * _ ]  )  { 3 ,  }  *  ( ? : \n + |$ )  )  /  )%NWL%(  )  ; %NWL%block . html = replace ( block . html )%NWL%6
state = GenStateCompleted ; %NWL%if ( method =  =  =  " next "  )  {%NWL%context . dispatchException ( thrown )  ;%NWL%} else {%NWL%arg = thrown ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%generator . next = invoke . bind ( generator ,  " next "  )  ; %NWL%generator . throw = invoke . bind ( generator ,  " throw "  )  ; %NWL%9
actualMap . names . join (  "  ,  "  )  +  " ! =  "  + expectedMap . names . join (  "  ,  "  )  )  ;%NWL%}%NWL%assert . equal ( actualMap . sources . length ,%NWL%expectedMap . sources . length ,%NWL%" sources length mismatch :  "  +%NWL%actualMap . sources . join (  "  ,  "  )  +  " ! =  "  + expectedMap . sources . join (  "  ,  "  )  )  ; %NWL%for ( var i = 0 ; i < actualMap . sources . length ; i +  +  )  {%NWL%assert . equal ( actualMap . sources [ i ]  ,%NWL%expectedMap . sources [ i ]  ,%NWL%" sources [  "  + i +  "  ] length mismatch :  "  +%NWL%actualMap . sources . join (  "  ,  "  )  +  " ! =  "  + expectedMap . sources . join (  "  ,  "  )  )  ; %NWL%0
if ( ! ( this . printMapPanel instanceof GeoExt . PrintMapPanel )  )  {%NWL%printMapPanelOptions . xtype =  " gx_printmappanel "%NWL%this . printMapPanel = new GeoExt . PrintMapPanel (%NWL%Ext . applyIf ( this . printMapPanel , printMapPanelOptions )  )  ;%NWL%}%NWL%} else {%NWL%this . printMapPanel = new GeoExt . PrintMapPanel (%NWL%printMapPanelOptions )  ;%NWL%}%NWL%this . sourceMap = this . printMapPanel . sourceMap ; %NWL%this . printProvider = this . printMapPanel . printProvider ; %NWL%9
}%NWL%this . hosts = parsed . hosts ; %NWL%this . options = this . parseOptions ( options , parsed && parsed . options )  ; %NWL%this . replica = true ; %NWL%if ( !this . name )  {%NWL%this . error ( new Error (  ' No database name provided for replica set '  )  , callback )  ; %NWL%return this ;%NWL%}%NWL%if ( options && options . user && options . pass )  {%NWL%this . user = options . user ; %NWL%this . pass = options . pass ; %NWL%9
return cb ( err )  ; %NWL%if ( !result )%NWL%return cb ( new error . VerificationError (  " invalid signature "  )  )  ; %NWL%return cb ( null , components . payload )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . addEntropy = function ( entropy )  {%NWL%RNG . addEntropy ( entropy )  ;%NWL%}  ; %NWL%exports . assertion = require (  "  .  / assertion "  )  ; %NWL%exports . cert = require (  "  .  / cert "  )  ; %NWL%9
Modernizr . _prefixes  = prefixes ; %NWL%Modernizr . testStyles  = injectElementWithStyles ; %NWL%return Modernizr ;%NWL%}  )  ( this , this . document )  ;%NWL%;%NWL%( function ( exports )  {%NWL%var MOUSE_ID = 1 ; %NWL%function Pointer ( identifier , type , event )  {%NWL%this . screenX = event . screenX || 0 ; %NWL%this . screenY = event . screenY || 0 ; %NWL%this . pageX = event . pageX || 0 ; %NWL%8
this . m01_ = m01 ; %NWL%this . m11_ = m11 ; %NWL%this . m02_ = m02 ; %NWL%this . m12_ = m12 ; %NWL%return this ;%NWL%}  ; %NWL%goog . graphics . AffineTransform . prototype . copyFrom = function ( tx )  {%NWL%this . m00_ = tx . m00_ ; %NWL%this . m10_ = tx . m10_ ; %NWL%this . m01_ = tx . m01_ ; %NWL%this . m11_ = tx . m11_ ; %NWL%7
createObjectStore ( event . target . result )  ;%NWL%}  ;%NWL%}  ,%NWL%Fetch : function ( callback )  {%NWL%this . callback = callback ; %NWL%this . init (  )  ; %NWL%return this ;%NWL%}  ,%NWL%Store : function ( config )  {%NWL%this . audioBlob = config . audioBlob ; %NWL%this . videoBlob = config . videoBlob ; %NWL%9
$interval (  ( function (  )  {%NWL%return deferred . reject (  )  ;%NWL%}  )  , timeout , 1 )  ; %NWL%return deferred . promise ;%NWL%}%NWL%}  ; %NWL%util . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . registerHandler "  ; %NWL%util . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . unregisterHandler "  ; %NWL%util . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . send "  ; %NWL%util . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . publish "  ; %NWL%util . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . login "  ; %NWL%6
var scratchZ =  {  }  ; %NWL%function complexMult ( a , b )  {%NWL%var newr = a . r * b . r - a . i * b . i ; %NWL%var newi = a . r * b . i + a . i * b . r ; %NWL%scratch . r = newr ; %NWL%scratch . i = newi ; %NWL%return scratch ;%NWL%}%NWL%function complexAdd ( a , b )  {%NWL%scratch . r = a . r + b . r ; %NWL%scratch . i = a . i + b . i ; %NWL%9
this . getTransform = this . _getTransformFilter ;%NWL%}%NWL%if ( this . toPropertyName )  {%NWL%this . setTransformOrigin = function ( node ,  transformOrigin )  {%NWL%return sset ( node , this . toPropertyName , transformOrigin )  ;%NWL%}  ; %NWL%this . getTransformOrigin = function ( node )  {%NWL%return sget ( node , this . toPropertyName )  ;%NWL%}  ;%NWL%} else if ( has (  " ie "  )  )  {%NWL%this . setTransformOrigin = this . _setTransformOriginFilter ; %NWL%0
var context =  { hashKey : config . hashKey }  ; %NWL%var self = this ; %NWL%Joi . validate ( config , internals . configSchema ,  { context : context }  , function ( err , data )  {%NWL%if ( err )  {%NWL%var msg =  ' Invalid table schema , check your config '  ; %NWL%throw new Error ( msg + err . annotate (  )  )  ;%NWL%}%NWL%self . hashKey  = data . hashKey ; %NWL%self . rangeKey  = data . rangeKey ; %NWL%self . tableName  = data . tableName ; %NWL%self . timestamps = data . timestamps ; %NWL%7
}%NWL%this . shoot = function ( dx , dy )  {%NWL%var args =  {%NWL%x : this . self . _x ,%NWL%y : this . self . _y ,%NWL%dx : dx - this . self . _x || this . self . x - this . self . _x ,%NWL%dy : dy - this . self . _y || this . self . y - this . self . _y%NWL%}%NWL%var len = Math . sqrt ( args . dx * args . dx + args . dy + args . dy )  ; %NWL%args . dx = args . dx / len * 400 ; %NWL%args . dy = args . dy / len * 400 ; %NWL%9
fill : toColor ,%NWL%' sweep - flag '  : 0%NWL%}  )%NWL%. add ( series . group )  ;%NWL%}%NWL%}  )  ;%NWL%}  ,%NWL%animate : function ( init )  {%NWL%this . center = this . yAxis . center ; %NWL%this . center [ 3 ]  = 2 * this . radius ; %NWL%this . startAngleRad = this . yAxis . startAngleRad ; %NWL%8
if ( pt . x! =  = undefined && !isNaN ( pt . x )  )  {%NWL%x = Math . min ( x , pt . x )  ; %NWL%y = Math . min ( y , pt . y )  ;%NWL%}%NWL%}  )  ; %NWL%var xmax = 0 ; %NWL%var ymax = 0 ; %NWL%p . forEach ( function ( pt )  {%NWL%if ( pt . x! =  = undefined && !isNaN ( pt . x )  )  {%NWL%pt . x = rnd ( pt . x - x )  ; %NWL%pt . y = rnd ( pt . y - y )  ; %NWL%9
this . context . clearRect ( 0 , 0 , this . canvas . width , this . canvas . height )  ; %NWL%return this ;%NWL%}  ,%NWL%}  ; %NWL%var Circle = function ( params )  {%NWL%this . id = params . id ; %NWL%this . canvas = params . canvas ; %NWL%this . context = params . context ; %NWL%this . centerX = params . centerX ; %NWL%this . centerY = params . centerY ; %NWL%this . arcWidth = params . arcWidth ; %NWL%5
autoDelete : true ,%NWL%enableDelete : true ,%NWL%enableHold : true ,%NWL%formatters : null ,%NWL%_templateLoadCount : 0 ,%NWL%_mouseDownPos : null ,%NWL%baseClass :  " list "  ,%NWL%constructor : function (  )  {%NWL%this . _checkLoadComplete = dojo . hitch ( this , this . _checkLoadComplete )  ; %NWL%this . _replaceToken = dojo . hitch ( this , this . _replaceToken )  ; %NWL%this . _postDeleteAnim = dojo . hitch ( this , this . _postDeleteAnim )  ; %NWL%8
for ( var i = 0 , len = this . nodes . length ; i < len ;  +  + i )  {%NWL%this . nodes [ i ]  . block = block ;%NWL%}%NWL%}  )  ; %NWL%Group . prototype . __defineGetter__ (  ' hasOnlyPlaceholders '  , function (  )  {%NWL%return this . nodes . every ( function ( selector )  { return selector . isPlaceholder ;  }  )  ;%NWL%}  )  ; %NWL%Group . prototype . clone = function ( parent )  {%NWL%var clone = new Group ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%9
c3 = binaryStr . charCodeAt ( i + 2 )  ; %NWL%decoded +  = String . fromCharCode (  (  ( c & 15 )  <  < 12 ) | (  ( c2 & 63 )  <  < 6 ) | ( c3 & 63 )  )  ; %NWL%i +  = 3 ;%NWL%}%NWL%}%NWL%return decoded ;%NWL%}  ; %NWL%BinaryParser . encode_cstring = function encode_cstring ( s )  {%NWL%return unescape ( encodeURIComponent ( s )  )  + BinaryParser . fromByte ( 0 )  ;%NWL%}  ; %NWL%BinaryParser . encode_utf8 = function encode_utf8 ( s )  {%NWL%7
}%NWL%if ( typeof ( window . saveAs ) ! =  ' undefined '  )  {%NWL%_this . cfg . menuItemOutput . output =  ' save '  ;%NWL%}%NWL%if ( AmCharts . isIE && AmCharts . IEversion < 10 )  {%NWL%_this . cfg . menuItemOutput . output =  ' dataurlnewwindow '  ;%NWL%}%NWL%var cfg = _this . userCFG ; %NWL%if ( cfg )  {%NWL%cfg . menuItemOutput = AmCharts . extend ( _this . cfg . menuItemOutput , cfg . menuItemOutput || {  }  )  ; %NWL%cfg . menuItemStyle = AmCharts . extend ( _this . cfg . menuItemStyle , cfg . menuItemStyle || {  }  )  ; %NWL%9
this . lastTime =  ( new Date (  )  )  . getTime (  )  ; %NWL%this . accTime = 0 ; %NWL%this . timeStep = 1 ; %NWL%this . bounds =  { x : 0 , y : 0 , width : this . width , height : this . height }  ; %NWL%this . frameRateLabel =  {  }  ; %NWL%this . resourceManager = new Jest . ResourceManager (  )  ; %NWL%this . hitEntities =  [  ]  ; %NWL%this . particleCount = 0 ; %NWL%Jest . frameRate = this . frameRate ; %NWL%Jest . bounds = this . bounds ; %NWL%Jest . particleCount = this . particleCount ; %NWL%8
return this ;%NWL%}  ; %NWL%proto . _getOnceReturnValue = function _getOnceReturnValue (  )  {%NWL%if ( this . hasOwnProperty (  ' _onceReturnValue '  )  )  {%NWL%return this . _onceReturnValue ;%NWL%}%NWL%else {%NWL%return true ;%NWL%}%NWL%}  ; %NWL%proto . _getEvents = function _getEvents (  )  {%NWL%2
}%NWL%GUIElement . extend ( GUITexture )  ; %NWL%GUITexture . prototype . copy = function ( other )  {%NWL%this . texture = other . texture ; %NWL%this . color . copy ( other . color )  ; %NWL%this . position . copy ( other . position )  ; %NWL%this . x = other . x ; %NWL%this . y = other . y ; %NWL%this . w = other . w ; %NWL%this . h = other . h ; %NWL%this . alpha = other . alpha ; %NWL%3
height : 12 ,%NWL%shape :  " rect "  ,%NWL%padding :  {%NWL%top : 0 ,%NWL%left : 0 ,%NWL%right : 0 ,%NWL%bottom : 0%NWL%}%NWL%}  ; %NWL%defs . fill . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " fill "  )  ; %NWL%defs . border . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " border "  )  ; %NWL%9
throw new Error (  " Unable to load SMD from "  + args )  ;%NWL%}  )  ;%NWL%} else if ( args . smdStr )  {%NWL%this . processSmd ( dojo . eval (  "  (  "  + args . smdStr +  "  )  "  )  )  ;%NWL%} else {%NWL%if ( args . serviceUrl )  {%NWL%this . serviceUrl = args . serviceUrl ;%NWL%}%NWL%this . timeout = args . timeout || 3000 ; %NWL%if (  " strictArgChecks " in args )  {%NWL%this . strictArgChecks = args . strictArgChecks ; %NWL%6
logFile . write ( data . output +  " \n "  )  ;%NWL%} catch ( e )  {%NWL%console . log (  " Error logging "  )  ; %NWL%console . log ( e . message )  ; %NWL%console . trace (  " error logging "  )  ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%exports . info = function ( e )  { logger . info ( e )  ; fileLogger . info ( e )  ;  }  ; %NWL%exports . debug = function ( e )  { logger . debug ( e )  ; fileLogger . debug ( e )  ;  }  ; %NWL%exports . warn = function ( e )  { logger . warn ( e )  ; fileLogger . warn ( e )  ;  }  ; %NWL%8
var spotlight = runInContext (  )  ; %NWL%if ( typeof define =  =  ' function ' && typeof define . amd =  =  ' object ' && define . amd )  {%NWL%define (  [  ' lodash '  ]  , function ( _ )  {%NWL%return runInContext (  {%NWL%' _ '  : _%NWL%}  )  ;%NWL%}  )  ;%NWL%}%NWL%else if ( freeExports && freeModule )  {%NWL%freeExports . byKind = spotlight . byKind ; %NWL%freeExports . byName = spotlight . byName ; %NWL%9
col . b +  = colorSpread . b * random (  )  ; %NWL%col . cnormalize (  )  ;%NWL%}%NWL%if ( worldSpace )  {%NWL%pos . x = position . x + transformPosition . x ; %NWL%pos . y = position . y + transformPosition . y ; %NWL%pos . z = position . z + transformPosition . z ;%NWL%} else {%NWL%pos . x = position . x ; %NWL%pos . y = position . y ; %NWL%pos . z = position . z ; %NWL%8
this . width , this . height , 0 , format ,%NWL%type , data )  ; %NWL%if ( genMipmaps )%NWL%gl . generateMipmap ( this . target )  ;%NWL%}  ,%NWL%uploadImage : function ( domObject , format , type , genMipmaps )  {%NWL%var gl = this . gl ; %NWL%format = format || gl . RGBA ; %NWL%type = type || gl . UNSIGNED_BYTE ; %NWL%this . width = domObject . width ; %NWL%this . height = domObject . height ; %NWL%9
httpRealm . indefinite ? undefined : httpRealm . disabled ? null : %NWL%httpRealm . qvalue ; %NWL%newProps . usernameField =%NWL%usernameField . indefinite ? undefined : usernameField . qvalue ; %NWL%newProps . passwordField =%NWL%passwordField . indefinite ? undefined : passwordField . qvalue ;%NWL%} else if ( type =  = 0 )  {%NWL%newProps . formSubmitURL = formSubmitURL . qvalue ; %NWL%newProps . httpRealm = null ; %NWL%newProps . usernameField = usernameField . qvalue ; %NWL%newProps . passwordField = passwordField . qvalue ; %NWL%7
} else if ( key =  =  =  ' to ' || key =  =  =  ' 100% '  )  {%NWL%finalStyle = style ;%NWL%}%NWL%}  )  ; %NWL%self . getName = getName = function (  )  {%NWL%return name ;%NWL%}  ; %NWL%self . getStartStyle = getStartStyle = function (  )  {%NWL%return startStyle ;%NWL%}  ; %NWL%self . getFinalStyle = getFinalStyle = function (  )  {%NWL%4
var extensible = this . extensible ; %NWL%if ( current =  =  = undefined && !extensible )%NWL%return this . _reject ( throwing ,  " object not extensible "  )  ; %NWL%if ( current =  =  = undefined && extensible )%NWL%{%NWL%var p ; %NWL%if ( IsGenericDescriptor ( desc ) || IsDataDescriptor ( desc )  )%NWL%{%NWL%p = new PropertyDescriptor (  )  ; %NWL%p . value = examine ( desc ,  " value "  , true )  ; %NWL%p . writable = examine ( desc ,  " writable "  , true )  ; %NWL%9
newLimitImpulse =  ( rvn - this . limitVelocity - this . limitImpulse * this . cfm )  * this . invDenom ; %NWL%var oldLimitImpulse = this . limitImpulse ; %NWL%this . limitImpulse +  = newLimitImpulse ; %NWL%if ( this . limitImpulse * this . limitState < 0 ) this . limitImpulse = 0 ; %NWL%newLimitImpulse = this . limitImpulse - oldLimitImpulse ;%NWL%} else newLimitImpulse = 0 ; %NWL%var totalImpulse = newLimitImpulse + newMotorImpulse ; %NWL%this . l1 . x +  = totalImpulse * this . l1x ; %NWL%this . l1 . y +  = totalImpulse * this . l1y ; %NWL%this . l1 . z +  = totalImpulse * this . l1z ; %NWL%this . a1 . x +  = totalImpulse * this . a1x ; %NWL%7
}%NWL%}  )%NWL%mediaApp . controller (  ' SortCtrl '  , function ( $scope , SettingsService , $rootScope )  {%NWL%$scope . filterTerm =  "  "  ; %NWL%if ( SettingsService . get (  ' sortBy '  )  )%NWL%$scope . sortBy = SettingsService . get (  ' sortBy '  )%NWL%else $scope . sortBy =  " artistName "  ; %NWL%$scope . saveSort = function (  )  {%NWL%console . log (  " This filter "  + $scope . filterTerm +  " sort "  + $scope . sortBy )  ; %NWL%$rootScope . sortBy = $scope . sortBy ; %NWL%$rootScope . filterTerm = $scope . filterTerm ; %NWL%9
$scope . isCurrentUser = function ( user )  {%NWL%return this . getCurrentUser (  )  =  = user ;%NWL%}  ; %NWL%$scope . isSelected = function ( user )  {%NWL%return this . listbox . selections [ user . guid ]  ;%NWL%}  ; %NWL%elggDatabase . getUsers (  {%NWL%banned : 0%NWL%}  )  . then ( function ( collection )  {%NWL%$scope . getItems = collection . getItems . bind ( collection )  ; %NWL%$scope . getTotalItems = collection . getTotalItems . bind ( collection )  ; %NWL%9
ctrl . getCount ( scope . options )  . then ( function ( count )  {%NWL%scope . count = count ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%this . link = function ( options )  {%NWL%options = options || {  }  ; %NWL%var urlOptions = options . urlOptions || {  }  ; %NWL%urlOptions . url = getUrl (  )  ; %NWL%urlOptions . title = $scope . title ; %NWL%urlOptions . image = $scope . image ; %NWL%9
if (  ' salt ' in data )  {%NWL%return callback ( null , data )  ;%NWL%}%NWL%var User = this . application . type (  ' user '  )  ; %NWL%var salt = User . salt (  )  ; %NWL%User . hash ( data . password , salt , function ( error , password )  {%NWL%if ( error )  {%NWL%return callback ( error )  ;%NWL%}%NWL%data . password = password . toString (  ' base64 '  )  ; %NWL%data . salt = salt . toString (  ' base64 '  )  ; %NWL%9
out [ 0 ]  =  - a [ 0 ]  ; %NWL%out [ 1 ]  =  - a [ 1 ]  ; %NWL%out [ 2 ]  =  - a [ 2 ]  ; %NWL%out [ 3 ]  = a [ 3 ]  ; %NWL%return out ;%NWL%}  ; %NWL%quat . length = vec4 . length ; %NWL%quat . len = quat . length ; %NWL%quat . squaredLength = vec4 . squaredLength ; %NWL%quat . sqrLen = quat . squaredLength ; %NWL%quat . normalize = vec4 . normalize ; %NWL%6
this . message = options . message ; %NWL%this . errors = options . errors ; %NWL%this . fields = options . fields ;%NWL%}  ; %NWL%util . inherits ( error . UniqueConstraintError , error . ValidationError )  ; %NWL%error . ForeignKeyConstraintError = function ( options )  {%NWL%options = options || {  }  ; %NWL%options . parent = options . parent || { sql :  '  '  }  ; %NWL%error . DatabaseError . call ( this , options . parent )  ; %NWL%this . name =  ' SequelizeForeignKeyConstraintError '  ; %NWL%this . message = options . message ; %NWL%1
this . maxEmission = opts . maxEmission ! = undefined ? opts . maxEmission : 2 ; %NWL%this . minLife = opts . minLife ! = undefined ? opts . minLife : 1 ; %NWL%this . maxLife = opts . maxLife ! = undefined ? opts . maxLife : 2 ; %NWL%this . minSize = opts . minSize ! = undefined ? opts . minSize : 0 . 1 ; %NWL%this . maxSize = opts . maxSize ! = undefined ? opts . maxSize : 0 . 5 ; %NWL%this . sizeTween = new Tween ( opts . sizeTween )  ; %NWL%this . alphaTween = new Tween ( opts . alphaTween )  ; %NWL%this . colorTween = new Tween ( opts . colorTween )  ; %NWL%this . velocity = opts . velocity ! = undefined ? opts . velocity : new Vec3 ; %NWL%this . velocitySpread = opts . velocitySpread ! = undefined ? opts . velocitySpread : new Vec3 ; %NWL%this . acceleration = opts . acceleration ! = undefined ? opts . acceleration : new Vec3 ; %NWL%8
}  ,%NWL%success : function ( data )  {%NWL%var places = new Array (  )  ; %NWL%response ( $ . map ( data . response . docs , function ( item )  {%NWL%if ( item . osm_key =  =  " boundary "  ) return ; %NWL%var latlng = item . coordinate . split (  '  ,  '  )  ; %NWL%var place    =  {  }  ; %NWL%var firstRow   =  [  ]  ; %NWL%var secondRow   =  [  ]  ; %NWL%place . name    = item . name ; %NWL%place . city    = item . city ; %NWL%9
this . watchItem . style . display = cachedDisplay ;%NWL%}%NWL%} else if ( this . watchItem =  =  =  + this . watchItem )  {  /  / number%NWL%if ( this . watchItem > 0 )  {%NWL%this . top = this . bottom = this . watchItem ;%NWL%} else {%NWL%this . top = this . bottom = exports . documentHeight - this . watchItem ;%NWL%}%NWL%} else {  /  / an object with a top and bottom property%NWL%this . top = this . watchItem . top ; %NWL%this . bottom = this . watchItem . bottom ; %NWL%9
}%NWL%if ( okey =  =  =  ' category '  )  {%NWL%categoryAndTags = getCategoryValue ( items [ okey ]  )  ;%NWL%} else {%NWL%newItem [ okey . replace (  ' wp :  '  ,  '  '  )  . replace (  ' dc :  '  ,  '  '  )  ]  = getNodeValue ( items [ okey ]  )  ;%NWL%}%NWL%}%NWL%delete newItem [  ' #text '  ]  ; %NWL%var newPost =  {  }  ; %NWL%newPost . title = convertEmpty ( newItem . title )  ; %NWL%newPost . pubDate = convertEmpty ( newItem . pubDate )  ; %NWL%9
self . query =  '  '  ; %NWL%self . use_notify = false ; %NWL%self . use_notify_sound = false ; %NWL%self . use_auto_update = true ; %NWL%self . init = function init ( id , name , params )  {%NWL%self . _me = $ ( id )  ; %NWL%self . name = name ; %NWL%self . _body = self . _me . find (  '  . listview_body '  )  ; %NWL%self . _header = self . _me . find (  '  . listview_header '  )  ; %NWL%self . _footer = self . _me . find (  '  . listview_footer '  )  ; %NWL%self . _content = self . _me . find (  '  . listview_content '  )  ; %NWL%7
this . pathpoints . reverse (  )  ; %NWL%this . winding = this . findWinding (  )  ;%NWL%}%NWL%}  ; %NWL%Path . prototype . flipNS = function (  )  {%NWL%var ly = this . maxes . ymax ; %NWL%var mid =  ( this . getHeight (  )  / 2 )  + this . maxes . ymin ; %NWL%for ( var e = 0 ; e < this . pathpoints . length ; e +  +  )  {%NWL%var pp = this . pathpoints [ e ]  ; %NWL%pp . P . y +  =  (  ( mid - pp . P . y )  * 2 )  ; %NWL%pp . H1 . y +  =  (  ( mid - pp . H1 . y )  * 2 )  ; %NWL%9
eventDefinitions . push ( eventDefinition )  ;%NWL%}%NWL%if ( target . instantiate ! =  = undefined )  {%NWL%businessObject . instantiate = target . instantiate ;%NWL%}%NWL%if ( target . eventGatewayType ! =  = undefined )  {%NWL%businessObject . eventGatewayType = target . eventGatewayType ;%NWL%}%NWL%if ( oldBusinessObject . $instanceOf (  ' bpmn : Activity '  )  )  {%NWL%newElement . width = element . width ; %NWL%newElement . height = element . height ; %NWL%9
actor . y = actor . org_y ;%NWL%}%NWL%actor . rotation = actor . org_rotation ; %NWL%actor . scale_x = actor . org_scale_x ; %NWL%actor . scale_y = actor . org_scale_y ; %NWL%actor . depth = actor . org_depth ; %NWL%actor . opacity = actor . org_opacity ; %NWL%actor . current_frame = actor . org_current_frame ; %NWL%actor . vr = actor . org_vr ; %NWL%actor . vx = actor . org_vx ; %NWL%actor . vy = actor . org_vy ; %NWL%0
}%NWL%return commands ;%NWL%}%NWL%}  ; %NWL%CommandManager = new ( Registry . extend ( CommandManager )  )  (  )  ; %NWL%Aloha . execCommand = CommandManager . execCommand ; %NWL%Aloha . queryCommandEnabled = CommandManager . queryCommandEnabled ; %NWL%Aloha . queryCommandIndeterm = CommandManager . queryCommandIndeterm ; %NWL%Aloha . queryCommandState = CommandManager . queryCommandState ; %NWL%Aloha . queryCommandSupported = CommandManager . queryCommandSupported ; %NWL%Aloha . queryCommandValue = CommandManager . queryCommandValue ; %NWL%5
this . _super ( params )  ; %NWL%params = pulse . util . checkParams ( params ,  {%NWL%font :  ' sans - serif '  ,%NWL%fontSize : 20 ,%NWL%text :  '  '%NWL%}  )  ; %NWL%this . font = params . font ; %NWL%this . fontPrevious = params . font ; %NWL%this . fontSize = params . fontSize ; %NWL%this . fontSizePrevious = params . fontSize ; %NWL%this . text = params . text ; %NWL%6
util . inherits ( Model , Item )  ; %NWL%Model . get    = _ . bind ( table . get , table )  ; %NWL%Model . create   = _ . bind ( table . create , table )  ; %NWL%Model . update   = _ . bind ( table . update , table )  ; %NWL%Model . destroy   = _ . bind ( table . destroy , table )  ; %NWL%Model . query   = _ . bind ( table . query , table )  ; %NWL%Model . scan   = _ . bind ( table . scan , table )  ; %NWL%Model . parallelScan = _ . bind ( table . parallelScan , table )  ; %NWL%Model . getItems = batch ( table , serializer )  . getItems ; %NWL%Model . batchGetItems = batch ( table , serializer )  . getItems ; %NWL%Model . createTable  = _ . bind ( table . createTable , table )  ; %NWL%1
module . exports = SingleDay ; %NWL%SingleDay . prototype =  {%NWL%_isActive : false ,%NWL%_borderWidth : 0 . 1 ,%NWL%_attached : false ,%NWL%setup : function (  )  {%NWL%this . day = document . createElement (  ' div '  )  ; %NWL%this . day . className =  ' md__day '  ; %NWL%this . day . dataset . date = this . date ; %NWL%this . allday = document . createElement (  ' div '  )  ; %NWL%this . allday . className =  ' md__allday '  ; %NWL%7
level . dimension_name = dimension_name ; %NWL%level . name = desc . name ; %NWL%!desc . label || ( level . label = desc . label )  ; %NWL%!desc . description || ( level . description = desc . description )  ; %NWL%!desc . info || ( level . info = desc . info )  ; %NWL%level . _key = desc . key ; %NWL%level . _label_attribute = desc . label_attribute ; %NWL%level . _order_attribute = desc . order_attribute ; %NWL%!desc . role || ( level . role = desc . role )  ; %NWL%!desc . cardinality || ( level . cardinality = desc . cardinality )  ; %NWL%level . nonadditive = desc . nonadditive ; %NWL%1
function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%7
bank : db ,%NWL%userAgent :  " OpenFarmGame / 0 . 1 . 0 "%NWL%}  )  ; %NWL%Host . dialbackClient = client ; %NWL%log . info (  { name : config . name ,%NWL%description : config . description ,%NWL%hostname : config . hostname }  ,%NWL%" Initializing OpenFarmGame object "  )  ; %NWL%OpenFarmGame . name   = config . name ; %NWL%OpenFarmGame . description = config . description ; %NWL%OpenFarmGame . hostname  = config . hostname ; %NWL%8
this . value [ 1 ]  = v . value [ 1 ]  ; %NWL%return this ;%NWL%}  ; %NWL%vector2 . prototype . addSelf = function ( v )  {%NWL%this . value [ 0 ]  +  = v . value [ 0 ]  ; %NWL%this . value [ 1 ]  +  = v . value [ 1 ]  ; %NWL%return this ;%NWL%}  ; %NWL%vector2 . prototype . add = function ( v1 , v2 )  {%NWL%this . value [ 0 ]  = v1 . value [ 0 ]  + v2 . value [ 0 ]  ; %NWL%this . value [ 1 ]  = v1 . value [ 1 ]  + v2 . value [ 1 ]  ; %NWL%9
if ( !mesh . visible )  {%NWL%$ (  ' #meshvisibility '  )  . removeClass (  ' show - icon '  )  ; %NWL%$ (  ' #meshvisibility '  )  . addClass (  ' hide - icon '  )  ;%NWL%}%NWL%if ( typeof scene . mesh . opacity ! =  ' undefined '  )  {%NWL%mesh . opacity = scene . mesh . opacity ;%NWL%}%NWL%jQuery (  ' #opacity - mesh '  )  . slider (  " option "  ,  " value "  ,%NWL%mesh . opacity * 100 )  ; %NWL%if ( typeof scene . mesh . color ! =  ' undefined '  )  {%NWL%mesh . color = scene . mesh . color ; %NWL%5
inline . text = inline . gfm . text ; %NWL%inline . url = inline . gfm . url ;%NWL%} else {%NWL%block . fences = block . normal . fences ; %NWL%block . paragraph = block . normal . paragraph ; %NWL%inline . text = inline . normal . text ; %NWL%inline . url = inline . normal . url ;%NWL%}%NWL%if ( options . pedantic )  {%NWL%inline . em = inline . pedantic . em ; %NWL%inline . strong = inline . pedantic . strong ; %NWL%9
}%NWL%}%NWL%}%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%9
web3 . setProvider = function ( provider )  {%NWL%RequestManager . getInstance (  )  . setProvider ( provider )  ;%NWL%}  ; %NWL%web3 . reset = function (  )  {%NWL%RequestManager . getInstance (  )  . reset (  )  ;%NWL%}  ; %NWL%web3 . toHex = utils . toHex ; %NWL%web3 . toAscii = utils . toAscii ; %NWL%web3 . fromAscii = utils . fromAscii ; %NWL%web3 . toDecimal = utils . toDecimal ; %NWL%web3 . fromDecimal = utils . fromDecimal ; %NWL%6
session . multiSelect . on (  " singleSelect "  , this . $onSingleSelect )  ; %NWL%if ( this . inMultiSelectMode ! = session . selection . inMultiSelectMode )  {%NWL%if ( session . selection . inMultiSelectMode )%NWL%this . $onMultiSelect (  )  ; %NWL%else%NWL%this . $onSingleSelect (  )  ;%NWL%}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%9
}%NWL%if ( t . settings [  " syntax_selection_allow "  ] && t . settings [  " syntax_selection_allow "  ]  . length > 0 )%NWL%t . syntax_list = t . settings [  " syntax_selection_allow "  ]  . replace (  /  / g ,  "  "  )  . split (  "  ,  "  )  ; %NWL%if ( t . settings [  ' syntax '  ]  )%NWL%t . allready_used_syntax [ t . settings [  ' syntax '  ]  ]  = true ;%NWL%}  ; %NWL%EditArea . prototype . init = function (  )  {%NWL%var t = this , a , s = t . settings ; %NWL%t . textarea			 = _$ (  " textarea "  )  ; %NWL%t . container			 = _$ (  " container "  )  ; %NWL%t . result			 = _$ (  " result "  )  ; %NWL%8
this . id    = GLOW . uniqueId (  )  ; %NWL%this . data    = parameters . data ; %NWL%this . autoUpdate  = parameters . autoUpdate ; %NWL%this . internalFormat = parameters . internalFormat || GL . RGBA ; %NWL%this . format   = parameters . format   || GL . RGBA ; %NWL%this . type    = parameters . type   || GL . UNSIGNED_BYTE ; %NWL%this . wrapS    = parameters . wrapS   || parameters . wrap || GL . REPEAT ; %NWL%this . wrapT    = parameters . wrapT   || parameters . wrap || GL . REPEAT ; %NWL%this . magFilter   = parameters . magFilter  || parameters . filter || GL . LINEAR ; %NWL%this . minFilter   = parameters . minFilter  || parameters . filter || GL . LINEAR_MIPMAP_LINEAR ; %NWL%this . width    = parameters . width ; %NWL%1
color = new Color ( color )  ; %NWL%var hsl   = color . toHsl (  )  ,%NWL%colorFrom = colorX . fromHsl ( hsl . h , hsl . s , lumFrom )  ,%NWL%colorTo  = colorX . fromHsl ( hsl . h , hsl . s , lumTo )  ; %NWL%colorFrom . a = colorTo . a = color . a ; 	 /  / add missing opacity%NWL%return Theme . generateGradient ( fillPattern , colorFrom , colorTo )  ; 	 /  / Object%NWL%}%NWL%}  )  ; %NWL%Theme . defaultMarkers = SimpleTheme . defaultMarkers ; %NWL%Theme . defaultColors = SimpleTheme . defaultColors ; %NWL%Theme . defaultTheme = SimpleTheme . defaultTheme ; %NWL%8
var chick ; %NWL%var car ; %NWL%var mech ; %NWL%var robot ; %NWL%var cop ; %NWL%var text ; %NWL%function create (  )  {%NWL%game . stage . backgroundColor =  ' #404040 '  ; %NWL%chick = game . add . sprite ( 0 , 0 ,  ' atlas '  ,  ' budbrain_chick . png '  )  ; %NWL%chick . x = chick . animations . currentFrame . x ; %NWL%chick . y = chick . animations . currentFrame . y ; %NWL%9
name :  " toggleRegexpMode "  ,%NWL%bindKey :  { win :  " Alt - R|Alt -  /  "  , mac :  " Ctrl - Alt - R|Ctrl - Alt -  /  "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . regExpOption . checked = !sb . regExpOption . checked ; %NWL%sb . $syncOptions (  )  ;%NWL%}%NWL%}  ,  {%NWL%name :  " toggleCaseSensitive "  ,%NWL%bindKey :  { win :  " Alt - C|Alt - I "  , mac :  " Ctrl - Alt - R|Ctrl - Alt - I "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . caseSensitiveOption . checked = !sb . caseSensitiveOption . checked ; %NWL%3
}%NWL%s . syphon = syphon%NWL%s . wait = wait%NWL%s . buffer = buffer%NWL%return s%NWL%}%NWL%barrage . Readable = load (  ' Readable '  )%NWL%barrage . Writable = load (  ' Writable '  )%NWL%barrage . Duplex = load (  ' Duplex '  )%NWL%barrage . Transform = load (  ' Transform '  )%NWL%barrage . PassThrough = load (  ' PassThrough '  )%NWL%6
if ( helper . isString ( options . reporters )  )  {%NWL%options . reporters = options . reporters . split (  '  ,  '  )  ;%NWL%}%NWL%if ( helper . isString ( options . removedFiles )  )  {%NWL%options . removedFiles = options . removedFiles . split (  '  ,  '  )  ;%NWL%}%NWL%if ( helper . isString ( options . addedFiles )  )  {%NWL%options . addedFiles = options . addedFiles . split (  '  ,  '  )  ;%NWL%}%NWL%if ( helper . isString ( options . changedFiles )  )  {%NWL%options . changedFiles = options . changedFiles . split (  '  ,  '  )  ; %NWL%1
}  ,%NWL%saveColumns : function ( grid )  {%NWL%var columns =  [  ]  ; %NWL%grid . columns . forEach ( function ( column )  {%NWL%var savedColumn =  {  }  ; %NWL%savedColumn . name = column . name ; %NWL%if ( grid . options . saveVisible )  {%NWL%savedColumn . visible = column . visible ;%NWL%}%NWL%if ( grid . options . saveWidths )  {%NWL%savedColumn . width = column . width ; %NWL%5
var evObj ; %NWL%if ( document . createEvent )  {%NWL%evObj = document . createEvent (  ' MouseEvents '  )  ; %NWL%evObj . initMouseEvent ( newName , true , true , window , 1 , sourceEvent . screenX , sourceEvent . screenY ,%NWL%sourceEvent . clientX , sourceEvent . clientY , sourceEvent . ctrlKey , sourceEvent . altKey ,%NWL%sourceEvent . shiftKey , sourceEvent . metaKey , sourceEvent . button , null )  ;%NWL%}%NWL%else {%NWL%evObj = document . createEventObject (  )  ; %NWL%evObj . screenX = sourceEvent . screenX ; %NWL%evObj . screenY = sourceEvent . screenY ; %NWL%9
}  ; %NWL%var ret  =  {%NWL%width : !autos . width && $ ( elem )  . width (  )  ,%NWL%height : !autos . height && $ ( elem )  . height (  )%NWL%}  ; %NWL%if ( autos . width || autos . height )  {%NWL%videoDims = getVideoDims ( data )  ; %NWL%ratio = videoDims . width / videoDims . height ; %NWL%if ( autos . width && autos . height )  {%NWL%ret . width = videoDims . width ; %NWL%ret . height = videoDims . height ; %NWL%9
if ( typeof keyfile =  =  =  ' string ' && keyfile . length > 0 )  {%NWL%this . keyvalue = fs . readFileSync ( keyfile ,  ' ascii '  )  ;%NWL%}%NWL%}%NWL%if ( this . certvalue =  =  = null || this . certvalue . length =  =  = 0 )  {%NWL%var certfile = process . env [ ServiceClientConstants . EnvironmentVariables . AZURE_CERTFILE ]  ; %NWL%if ( typeof certfile =  =  =  ' string ' && certfile . length > 0 )  {%NWL%this . certvalue = fs . readFileSync ( certfile ,  ' ascii '  )  ;%NWL%}%NWL%}%NWL%if ( this . keyvalue =  =  = null || this . keyvalue . length =  =  = 0 )  {%NWL%4
ef = new Y . EventFacade ( this , this . currentTarget )  ;%NWL%}%NWL%o = args && args [ 0 ]  ; %NWL%if ( Y . Lang . isObject ( o , true )  )  {%NWL%o2 =  {  }  ; %NWL%Y . mix ( o2 , ef , true , FACADE_KEYS )  ; %NWL%Y . mix ( ef , o , true )  ; %NWL%Y . mix ( ef , o2 , true , FACADE_KEYS )  ;%NWL%}%NWL%ef . details = this . details ; %NWL%ef . target = this . target ; %NWL%9
$ . ui . position =  {%NWL%fit :  {%NWL%left : function ( position , data )  {%NWL%var win = $ ( window )  ,%NWL%over = data . collisionPosition . left + data . collisionWidth - win . width (  )  - win . scrollLeft (  )  ; %NWL%position . left = over > 0 ? position . left - over : Math . max ( position . left - data . collisionPosition . left , position . left )  ;%NWL%}  ,%NWL%top : function ( position , data )  {%NWL%var win = $ ( window )  ,%NWL%over = data . collisionPosition . top + data . collisionHeight - win . height (  )  - win . scrollTop (  )  ; %NWL%position . top = over > 0 ? position . top - over : Math . max ( position . top - data . collisionPosition . top , position . top )  ; %NWL%5
}%NWL%else if ( config . useBasicAuthorizationHeader && config . clientID && !params . client_id )%NWL%options . headers =  {  ' Authorization '  :  ' Basic '  + new Buffer ( config . clientID +  '  :  '  + config . clientSecret )  . toString (  ' base64 '  )  }%NWL%else%NWL%options . headers =  {  }%NWL%if ( config . ca )%NWL%options . ca = config . ca ; %NWL%if ( typeof ( config . rejectUnauthorized ) ! =  " undefined "  )%NWL%options . rejectUnauthorized = config . rejectUnauthorized ; %NWL%if ( config . agent )%NWL%options . agent = config . agent ; %NWL%6
}  , animate )  ;%NWL%}  ,%NWL%setLeft : function ( left )  {%NWL%this . dom . style [ LEFT ]  = this . addUnits ( left )  ; %NWL%return this ;%NWL%}  ,%NWL%setLeftTop : function ( left , top )  {%NWL%var me = this ,%NWL%style = me . dom . style ; %NWL%style . left = me . addUnits ( left )  ; %NWL%style . top = me . addUnits ( top )  ; %NWL%9
}%NWL%return element ;%NWL%}  ,%NWL%fixEvent = function ( e )  {%NWL%var result =  {  }  ; %NWL%if ( !e )  {%NWL%return result ;%NWL%}%NWL%var type = e . type , target = e . target || e . srcElement ; %NWL%result . preventDefault = fixEvent . preventDefault ( e )  ; %NWL%result . stopPropagation = fixEvent . stopPropagation ( e )  ; %NWL%9
me . hidden = state . hidden ;%NWL%}%NWL%if ( defined ( state . locked )  )  {%NWL%me . locked = state . locked ;%NWL%}%NWL%if ( defined ( state . sortable )  )  {%NWL%me . sortable = state . sortable ;%NWL%}%NWL%if ( defined ( state . width )  )  {%NWL%delete me . flex ; %NWL%me . width = state . width ; %NWL%0
w = Math . max ( w - pb . w - mb . w , 0 )  ;%NWL%}%NWL%if ( h >  = 0 )  {%NWL%h = Math . max ( h - pb . h - mb . h , 0 )  ;%NWL%}%NWL%setBox ( node , box . l , box . t , w , h )  ;%NWL%}  ; %NWL%geom . isBodyLtr = function isBodyLtr (  )  {%NWL%return ( win . body (  )  . dir || win . doc . documentElement . dir || " ltr "  )  . toLowerCase (  )  =  =  " ltr "  ;  /  / Boolean%NWL%}  ; %NWL%geom . docScroll = function docScroll (  )  {%NWL%7
}%NWL%if ( api . network && api . network . getAvailableNetworks )  {%NWL%api . network . getAvailableNetworks ( function ( networks )  {%NWL%network . interfaces = networks . length ; %NWL%exports . util . every ( networks , function ( net )  {%NWL%if ( net . isActive (  )  )  {%NWL%network . mac = net . mac ; %NWL%network . ip = net . ip ; %NWL%network . ipMode = net . ipMode ; %NWL%network . dns = net . dns ; %NWL%network . dnsMode = net . dnsMode ; %NWL%6
} else if ( self . threshold < 1 && self . threshold > 0 )  {%NWL%self . isThresholdPercentage = true ;%NWL%}%NWL%self . hasLeaveCallback = $ . isFunction ( self . leave )  ; %NWL%self . $element = $ ( self . element )  ; %NWL%self . update (  )  ;%NWL%}  ; %NWL%ViewportItem . prototype . update = function (  )  {%NWL%var self = this ; %NWL%self . offset = self . $element . offset (  )  ; %NWL%self . height = self . $element . height (  )  ; %NWL%9
return window . Configuration . Roles . reload (  )  ;%NWL%}%NWL%}  ; %NWL%return Permissions ;%NWL%}  )  (  )  ; %NWL%Configuration =  ( function ( _super )  {%NWL%__extends ( Configuration , _super )  ; %NWL%function Configuration (  )  {%NWL%this . Sections = new Sections ; %NWL%this . Roles = new Roles ; %NWL%this . Permissions = new Permissions ; %NWL%8
init : function (  )  {%NWL%this . _super (  )  ; %NWL%this . isMale = _ . sample (  [ false , true ]  )  ; %NWL%this . wanderRange = 20 ; %NWL%this . wanderConfig =  {  }  ;%NWL%}  ,%NWL%enter : function ( unit )  {%NWL%unit . maxSpeed = _ . random ( 2 , 4 )  ; %NWL%if ( this . isMale )  {%NWL%unit . skin = _ . random ( Constants . skinIdMaleStart , Constants . skinIdMaleEnd )  ; %NWL%unit . hair = _ . random ( Constants . hairIdMaleStart , Constants . hairIdMaleEnd )  ; %NWL%9
}%NWL%}%NWL%this . events = events ; %NWL%return matches ;%NWL%}  ,%NWL%Options :  {%NWL%keys :  [  ]  , masks :  [  ]  , prevent : false ,%NWL%init : function (  )  {%NWL%this . patch ( arguments [ 0 ] || {  }  )  ; %NWL%this . keys =  ( this . keys . constructor =  = Array ) ? this . keys :  [ this . keys ]  ; %NWL%this . masks =  ( this . masks . constructor =  = Array ) ? this . masks :  [ this . masks ]  ; %NWL%9
nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%nl . lang . value = dom . getAttrib ( n ,  ' lang '  )  ; %NWL%nl . usemap . value = dom . getAttrib ( n ,  ' usemap '  )  ; %NWL%nl . longdesc . value = dom . getAttrib ( n ,  ' longdesc '  )  ; %NWL%5
return false ;%NWL%}%NWL%}  )  =  =  = true ;%NWL%}  ; %NWL%cls . detail = detail = function ( params )  {%NWL%var%NWL%data = params . data ,%NWL%valid = VALID ( params . validDataSet )  ; %NWL%return valid . check ( data )  . checkHasError (  ) ! =  = true ;%NWL%}  ; %NWL%cls . equal = equal = function ( params )  {%NWL%4
if ( hasOptions )  {%NWL%if ( typeof options . format =  =  ' string '  )%NWL%this . format = options . format ; %NWL%if ( typeof options . separator =  =  ' string '  )%NWL%this . separator = options . separator ; %NWL%if ( typeof options . startDate =  =  ' string '  )%NWL%this . startDate = Date . parse ( options . startDate , this . format )  ; %NWL%if ( typeof options . endDate =  =  ' string '  )%NWL%this . endDate = Date . parse ( options . endDate , this . format )  ; %NWL%if ( typeof options . minDate =  =  ' string '  )%NWL%this . minDate = Date . parse ( options . minDate , this . format )  ; %NWL%6
offset = this . visual_types . writeBuffer ( buffer , offset )  ; %NWL%return offset ;%NWL%}%NWL%function Screen ( window , colormap , white , black , current_input_masks , width_px , height_px , width_mm , height_mm , maps_min , maps_max , root_visual , backing_stores , save_unders , root_depth , depths )  {%NWL%this . window = window || 0 ; %NWL%this . colormap = colormap || 0 ; %NWL%this . white = white || 0 ; %NWL%this . black = black || 0 ; %NWL%this . current_input_masks = current_input_masks || 0 ; %NWL%this . height_px = height_px || 0 ; %NWL%this . width_px = width_px || 0 ; %NWL%4
up :  { date : new Date (  " 2014 - 03 - 05 "  )  , open : 1 , high : 1 . 5 , low : 0 . 5 , close : 1 . 1 , volume : 10 }  ,%NWL%down :  { date : new Date (  " 2014 - 03 - 06 "  )  , open : 1 . 1 , high : 1 . 5 , low : 0 . 5 , close : 1 , volume : 100 }  ,%NWL%even :  { date : new Date (  " 2014 - 03 - 07 "  )  , open : 1 , high : 1 . 5 , low : 0 . 5 , close : 1 , volume : 1 }%NWL%}  ; %NWL%ohlc . alternating . array =  [ ohlc . alternating . up , ohlc . alternating . down , ohlc . alternating . even ]  ; %NWL%ohlc . invalidvolume =  {%NWL%up :  { date : new Date (  " 2014 - 03 - 05 "  )  , open : 1 , high : 1 . 5 , low : 0 . 5 , close : 1 . 1 , volume :  " not valid "  }  ,%NWL%down :  { date : new Date (  " 2014 - 03 - 06 "  )  , open : 1 . 1 , high : 1 . 5 , low : 0 . 5 , close : 1 , volume : undefined }  ,%NWL%even :  { date : new Date (  " 2014 - 03 - 07 "  )  , open : 1 , high : 1 . 5 , low : 0 . 5 , close : 1 , volume : 1 }%NWL%}  ; %NWL%ohlc . invalidvolume . array =  [ ohlc . invalidvolume . up , ohlc . invalidvolume . down , ohlc . invalidvolume . even ]  ; %NWL%4
}  , options )  ; %NWL%if ( node . auth && this . $auth )  {%NWL%if ( auth = this . $auth . $credentials )  {%NWL%o . username = auth . username ; %NWL%o . password = auth . password ;%NWL%}%NWL%else {%NWL%return this . $auth . authRequired ( function (  )  {%NWL%auth = _self . $auth . $credentials%NWL%o . username = auth . username ; %NWL%o . password = auth . password ; %NWL%3
minijn . executeSpecs ( jasmineNodeOpts )  ;%NWL%}  )  ;%NWL%}  ; %NWL%Runner . prototype . runMocha_ = function ( specs , done )  {%NWL%var Mocha = require (  ' mocha '  )  ,%NWL%mocha = new Mocha ( this . config_ . mochaOpts )  ,%NWL%self = this ; %NWL%mocha . suite . on (  ' pre - require '  , function (  )  {%NWL%var mochaAdapters = require (  ' selenium - webdriver / testing '  )  ; %NWL%global . after = mochaAdapters . after ; %NWL%global . afterEach = mochaAdapters . afterEach ; %NWL%9
this . $ =  {  }  ;%NWL%}  ; %NWL%ContextFaker . prototype . _refreshFake = function (  )  {%NWL%this . $ = new ContextFake ( this . _method ,%NWL%this . _url ,%NWL%this . _headers ,%NWL%this . _body ,%NWL%this . expectations ,%NWL%this . done )  ; %NWL%this . req = this . $ . req ; %NWL%this . res = this . $ . res ; %NWL%9
result = this . __processRepeats ( style , repeat , source )  ;%NWL%}%NWL%}%NWL%return result ;%NWL%}  ,%NWL%__normalizeWidthHeight : function ( style , width , height )%NWL%{%NWL%if ( style . width =  = null && width ! = null )  {%NWL%style . width = width +  " px "  ;%NWL%}%NWL%if ( style . height =  = null && height ! = null )  {%NWL%7
enumerable : true%NWL%}  ,%NWL%br :  {%NWL%get : function (  )  {%NWL%return this . _br ;%NWL%}  ,%NWL%set : function ( brValue )  {%NWL%var locBr = this . _br ; %NWL%locBr . vertices = brValue . vertices ; %NWL%locBr . colors = brValue . colors ; %NWL%locBr . texCoords = brValue . texCoords ; %NWL%8
}%NWL%return this . _cachedTextureMatrix ;%NWL%}  ; %NWL%Texture . prototype . clone = function (  )  {%NWL%var newTexture = new Texture ( this . _texture . url , this . getScene (  )  , this . _noMipmap , this . _invertY , this . _samplingMode )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%newTexture . wrapU = this . wrapU ; %NWL%newTexture . wrapV = this . wrapV ; %NWL%newTexture . coordinatesIndex = this . coordinatesIndex ; %NWL%newTexture . coordinatesMode = this . coordinatesMode ; %NWL%5
tx . gas = utils . toDecimal ( tx . gas )  ; %NWL%tx . gasPrice = utils . toBigNumber ( tx . gasPrice )  ; %NWL%tx . value = utils . toBigNumber ( tx . value )  ; %NWL%return tx ;%NWL%}  ; %NWL%var outputBlockFormatter = function ( block )  {%NWL%block . gasLimit = utils . toDecimal ( block . gasLimit )  ; %NWL%block . gasUsed = utils . toDecimal ( block . gasUsed )  ; %NWL%block . size = utils . toDecimal ( block . size )  ; %NWL%block . timestamp = utils . toDecimal ( block . timestamp )  ; %NWL%block . number = utils . toDecimal ( block . number )  ; %NWL%6
" $get_icon "  ,  " $get_value "  )  ; %NWL%function completer (  )  {%NWL%keywords ( arguments ,%NWL%$completions =  [  ]  ,%NWL%$get_string = identity ,%NWL%$get_description = constantly (  "  "  )  ,%NWL%$get_icon = null ,%NWL%$get_value = null )  ; %NWL%this . completions_src = arguments . $completions ; %NWL%this . get_string = arguments . $get_string ; %NWL%this . get_description = arguments . $get_description ; %NWL%9
this . addCssClass = opts . addCssClass ? opts . addCssClass :  "  "  ; %NWL%this . suppressTitle = opts . suppressTitle || this . suppressTitle ; %NWL%this . title = opts . suppressTitle ? "  "  :  ( opts . title || " Alert "  )  ; %NWL%this . message = opts . message || "  "  ; %NWL%this . cancelText = opts . cancelText || " Cancel "  ; %NWL%this . cancelCallback = opts . cancelCallback || function (  )  {  }  ; %NWL%this . cancelClass = opts . cancelClass || " button "  ; %NWL%this . doneText = opts . doneText || " Done "  ; %NWL%this . doneCallback = opts . doneCallback || function (  )  {%NWL%}  ; %NWL%this . doneClass = opts . doneClass || " button "  ; %NWL%6
data = data . replace (  /  [ \u0001 - \u0008\u000B - \u000C\u000E - \u001F\uD800 - \uDFFF\uFFFE - \uFFFF ]  / g ,  '  '  )  ; %NWL%parser = new DOMParser (  )  ; %NWL%xmlDoc = parser . parseFromString ( data ,  " text / xml "  )  ; %NWL%var jsonObj = xmlToJson ( xmlDoc )  ; %NWL%var channel = jsonObj . rss . channel ; %NWL%wordpressData . title = convertEmpty ( getNodeValue ( channel [  ' title '  ]  )  )  ; %NWL%wordpressData . link = convertEmpty ( getNodeValue ( channel [  ' link '  ]  )  )  ; %NWL%wordpressData . pubDate = convertEmpty ( getNodeValue ( channel [  ' pubDate '  ]  )  )  ; %NWL%wordpressData . description = convertEmpty ( getNodeValue ( channel [  ' description '  ]  )  )  ; %NWL%wordpressData . language = convertEmpty ( getNodeValue ( channel [  ' language '  ]  )  )  ; %NWL%wordpressData . image = convertEmpty ( getNodeValue ( channel [  ' image '  ]  )  )  ; %NWL%5
{%NWL%var featureItem = $ ( this )  ; %NWL%WebDeveloper . Overlay . getSelectedTab ( function ( tab )%NWL%{%NWL%if ( WebDeveloper . Overlay . isValidTab ( tab )  )%NWL%{%NWL%var feature = featureItem . attr (  " id "  )  ; %NWL%var display = !chrome . extension . getBackgroundPage (  )  . WebDeveloper . Storage . isFeatureOnTab ( feature , tab )  ; %NWL%var locale  =  {  }  ; %NWL%locale . hoverColor  = WebDeveloper . Locales . getString (  " hoverColor "  )  ; %NWL%locale . selectedColor = WebDeveloper . Locales . getString (  " selectedColor "  )  ; %NWL%9
fill = gfx . makeParameters ( gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeX "  )  {%NWL%var span = bbox . width ; %NWL%fill . x1 = bbox . x + span * fill . x1 / 100 ; %NWL%fill . x2 = bbox . x + span * fill . x2 / 100 ;%NWL%}%NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeY "  )  {%NWL%var span = bbox . height ; %NWL%fill . y1 = bbox . y + span * fill . y1 / 100 ; %NWL%fill . y2 = bbox . y + span * fill . y2 / 100 ; %NWL%9
json || ( json =  {  }  )  ; %NWL%json . name = this . name ; %NWL%json . negButton = this . negButton ; %NWL%json . posButton = this . posButton ; %NWL%json . altNegButton = this . altNegButton ; %NWL%json . altPosButton = this . altPosButton ; %NWL%json . gravity = this . gravity ; %NWL%json . sensitivity = this . sensitivity ; %NWL%json . dead = this . dead ; %NWL%json . type = this . type ; %NWL%json . axis = this . axis ; %NWL%1
if ( ! ( PREVENT_DEFAULT in config )  )  {%NWL%config [ PREVENT_DEFAULT ]  = se . PREVENT_DEFAULT ;%NWL%}%NWL%return config ;%NWL%}  ,%NWL%_getRoot = function ( node , subscriber )  {%NWL%return subscriber . _extra . root || ( node . get ( NODE_TYPE )  =  =  = 9 ) ? node : node . get ( OWNER_DOCUMENT )  ;%NWL%}  ,%NWL%_normTouchFacade = function ( touchFacade , touch , params )  {%NWL%touchFacade . pageX = touch . pageX ; %NWL%touchFacade . pageY = touch . pageY ; %NWL%9
return result ;%NWL%}  ,%NWL%reverseConditions : function ( conditions )  {%NWL%for ( var i = 0 ; i < conditions . length ; i +  +  )  {%NWL%if ( conditions [ i ]  . value && conditions [ i ]  . value . attribute )  {%NWL%var tmp_name_tree = conditions [ i ]  . name_tree ; %NWL%var tmp_attribute = conditions [ i ]  . attribute ; %NWL%var tmp_model  = conditions [ i ]  . model ; %NWL%conditions [ i ]  . name_tree = conditions [ i ]  . value . name_tree ; %NWL%conditions [ i ]  . attribute = conditions [ i ]  . value . attribute ; %NWL%conditions [ i ]  . model  = conditions [ i ]  . value . model ; %NWL%8
Engine . Request =  {%NWL%parse : function ( req )  {%NWL%var request =  {  }  ,%NWL%matches =  [  ]  ; %NWL%request . scheme = request . scheme ; %NWL%request . version =  ( matches . length ) ? [  ( matches [ 2 ]  * 1 )  ,  ( matches [ 3 ]  * 1 )  ]  :  [ 0 , 0 ]  ; %NWL%request . method = req . method ; %NWL%request . scriptName = req . scriptName ; %NWL%request . pathInfo = req . pathInfo ; %NWL%request . queryString = req . queryString ; %NWL%request . host = req . host ; %NWL%6
this . dropCueElements [ i / 2 ]  = webPartTable . rows [ i ]  . cells [ 0 ]  . childNodes [ 0 ]  ;%NWL%}%NWL%}%NWL%else {%NWL%for ( i = 0 ; i < webPartTable . rows [ 0 ]  . cells . length ; i +  = 2 )  {%NWL%this . dropCueElements [ i / 2 ]  = webPartTable . rows [ 0 ]  . cells [ i ]  . childNodes [ 0 ]  ;%NWL%}%NWL%}%NWL%}%NWL%this . AddWebPart = Zone_AddWebPart ; %NWL%this . GetWebPartIndex = Zone_GetWebPartIndex ; %NWL%9
if ( this . enableFacebookSharing ! =  = null && this . enableFacebookSharing ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableFacebookSharing '  , Thrift . Type . BOOL , 5 )  ; %NWL%output . writeBool ( this . enableFacebookSharing )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableGiftSubscriptions ! =  = null && this . enableGiftSubscriptions ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableGiftSubscriptions '  , Thrift . Type . BOOL , 6 )  ; %NWL%output . writeBool ( this . enableGiftSubscriptions )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableSupportTickets ! =  = null && this . enableSupportTickets ! =  = undefined )  {%NWL%0
exports . KOI8U  = exports . KOI8U_GENERAL_CI ; %NWL%exports . LATIN1  = exports . LATIN1_SWEDISH_CI ; %NWL%exports . LATIN2  = exports . LATIN2_GENERAL_CI ; %NWL%exports . LATIN5  = exports . LATIN5_TURKISH_CI ; %NWL%exports . LATIN7  = exports . LATIN7_GENERAL_CI ; %NWL%exports . MACCE  = exports . MACCE_GENERAL_CI ; %NWL%exports . MACROMAN = exports . MACROMAN_GENERAL_CI ; %NWL%exports . SJIS  = exports . SJIS_JAPANESE_CI ; %NWL%exports . SWE7  = exports . SWE7_SWEDISH_CI ; %NWL%exports . TIS620  = exports . TIS620_THAI_CI ; %NWL%exports . UCS2  = exports . UCS2_GENERAL_CI ; %NWL%0
this . $element = $ ( element )  ; %NWL%this . defaultTime = options . defaultTime ; %NWL%this . disableFocus = options . disableFocus ; %NWL%this . isOpen = options . isOpen ; %NWL%this . minuteStep = options . minuteStep ; %NWL%this . modalBackdrop = options . modalBackdrop ; %NWL%this . secondStep = options . secondStep ; %NWL%this . showInputs = options . showInputs ; %NWL%this . showMeridian = options . showMeridian ; %NWL%this . showSeconds = options . showSeconds ; %NWL%this . template = options . template ; %NWL%1
this . scale [ 2 ]  = Number (  ( max / 5 )  * 3 )  . toFixed ( dec )  ; %NWL%this . scale [ 3 ]  = Number (  ( max / 5 )  * 4 )  . toFixed ( dec )  ; %NWL%this . scale [ 4 ]  = Number ( max )  . toFixed ( dec )  ; %NWL%this . max = max ;%NWL%} else {%NWL%this . leftmax  = RGraph . array_max ( this . left )  ; %NWL%this . rightmax = RGraph . array_max ( this . right )  ; %NWL%max = Math . max ( this . leftmax , this . rightmax )  ; %NWL%this . scale  = RGraph . getScale ( max , this )  ; %NWL%this . scale [ 0 ]  = Number ( this . scale [ 0 ]  )  . toFixed ( dec )  ; %NWL%this . scale [ 1 ]  = Number ( this . scale [ 1 ]  )  . toFixed ( dec )  ; %NWL%9
console . log (  " origin is NaN "  )  ;%NWL%} else {%NWL%this . sceneObject . position [ 0 ]  = origin . x (  )  ; %NWL%this . sceneObject . position [ 1 ]  = origin . y (  )  ; %NWL%this . sceneObject . position [ 2 ]  = origin . z (  )  ;%NWL%}%NWL%var quat_rotation = utrans . getRotation (  )  ; %NWL%uquat . x = quat_rotation . x (  )  ; %NWL%uquat . y = quat_rotation . y (  )  ; %NWL%uquat . z = quat_rotation . z (  )  ; %NWL%uquat . w = quat_rotation . w (  )  ; %NWL%7
GameBoyAdvanceBGTEXTRenderer . prototype . writeBGHOFS0 = function ( data )  {%NWL%data = data | 0 ; %NWL%this . BGXCoord =  ( this . BGXCoord & 0x100 ) | data ;%NWL%}%NWL%GameBoyAdvanceBGTEXTRenderer . prototype . writeBGHOFS1 = function ( data )  {%NWL%data = data | 0 ; %NWL%this . BGXCoord =  (  ( data & 0x01 )  <  < 8 ) | ( this . BGXCoord & 0xFF )  ;%NWL%}%NWL%GameBoyAdvanceBGTEXTRenderer . prototype . writeBGVOFS0 = function ( data )  {%NWL%data = data | 0 ; %NWL%this . BGYCoord =  ( this . BGYCoord & 0x100 ) | data ; %NWL%2
}  ;%NWL%}  ,%NWL%askFor : function (  )  {%NWL%var done = this . async (  )  ; %NWL%var prompts =  [%NWL%questions . componentType ,%NWL%questions . componentName%NWL%]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%this . componentType = props . componentType ; %NWL%this . componentName = props . componentName ; %NWL%9
}%NWL%GaugePointer . prototype . setOptions = function ( options )  {%NWL%if ( options =  = null )  {%NWL%options = null ;%NWL%}%NWL%updateObjectValues ( this . options , options )  ; %NWL%this . length = this . canvas . height * this . options . length ; %NWL%this . strokeWidth = this . canvas . height * this . options . strokeWidth ; %NWL%this . maxValue = this . gauge . maxValue ; %NWL%this . minValue = this . gauge . minValue ; %NWL%this . animationSpeed = this . gauge . animationSpeed ; %NWL%8
this . remove ( item )  ;%NWL%}  ,%NWL%updateWithJSON : function ( JSONUpdate )  {%NWL%this . updateCollectionAttributes ( JSONUpdate )  ; %NWL%this . createFieldFromSchema ( JSONUpdate )  ; %NWL%this . createFieldsets ( JSONUpdate )  ; %NWL%this . formChannel . trigger (  ' updateFinished '  )  ;%NWL%}  ,%NWL%updateCollectionAttributes : function ( JSONUpdate )  {%NWL%this . name    = JSONUpdate [  " name "  ]  ; %NWL%this . descriptionFr = JSONUpdate [  " descriptionFr "  ]  ; %NWL%9
lodash . chain = chaining . chain ; %NWL%lodash . compact = arrays . compact ; %NWL%lodash . compose = functions . compose ; %NWL%lodash . constant = utilities . constant ; %NWL%lodash . countBy = collections . countBy ; %NWL%lodash . create = objects . create ; %NWL%lodash . createCallback = functions . createCallback ; %NWL%lodash . curry = functions . curry ; %NWL%lodash . debounce = functions . debounce ; %NWL%lodash . defaults = objects . defaults ; %NWL%lodash . defer = functions . defer ; %NWL%2
ActionsBuilder . LightProperties . push (  { name : thing , type : typeof ( light [ thing ]  )  }  )  ;%NWL%}%NWL%}%NWL%ActionsBuilder . MeshProperties = ActionsBuilder . MeshProperties || new Array (  )  ; %NWL%for ( var thing in mesh )  {%NWL%if ( testInstanceOf ( mesh [ thing ]  , thing )  )  {%NWL%ActionsBuilder . MeshProperties . push (  { name : thing , type : typeof ( mesh [ thing ]  )  }  )  ;%NWL%}%NWL%}%NWL%ActionsBuilder . MeshesList = ActionsBuilder . MeshesList || new Array (  )  ; %NWL%ActionsBuilder . LightsList = ActionsBuilder . LightsList || new Array (  )  ; %NWL%3
" &bounds_lat_min =  "  + instance . bounds_lat_min +%NWL%" &bounds_lat_max =  "  + instance . bounds_lat_max +%NWL%" &bounds_lon_min =  "  + instance . bounds_lon_min +%NWL%" &bounds_lon_max =  "  + instance . bounds_lon_max +%NWL%" &max_select_size =  "  + MAX_STOPS_TO_VIEW ; %NWL%var $dfd = $ . getJSON ( select_set_size_url ,%NWL%function ( data )  {%NWL%eric . select_set_size = data . select_set_size ; %NWL%eric . lat_min = data . lat_min ; %NWL%eric . lat_max = data . lat_max ; %NWL%eric . lon_min = data . lon_min ; %NWL%7
this . sort = other . sort ; %NWL%this . positionType = other . positionType ; %NWL%this . velocityType = other . velocityType ; %NWL%this . material = other . material ; %NWL%this . position . copy ( other . position )  ; %NWL%this . positionSpread . copy ( other . positionSpread )  ; %NWL%this . positionRadius = other . positionRadius ; %NWL%this . speed = other . speed ; %NWL%this . speedSpread = other . speedSpread ; %NWL%this . worldSpace = other . worldSpace ; %NWL%this . minEmission = other . minEmission ; %NWL%0
}%NWL%if ( key . indexOf (  '  ,  ' ! =  =  - 1 || value . indexOf (  '  ,  ' ! =  =  - 1 )  )  )  {%NWL%throw new Error (  ' Cannot have comma in parameter list '  )  ;%NWL%}%NWL%if ( key . indexOf (  ' @ ' ! =  =  - 1 || value . indexOf (  ' @ ' ! =  =  - 1 )  )  )  {%NWL%throw new Error (  ' Cannot have at sign ( @ ) in parameter list '  )  ;%NWL%}%NWL%if ( key . indexOf (  '  ' ! =  =  - 1 || value . indexOf (  '  ' ! =  =  - 1 )  )  )  {%NWL%throw new Error (  ' Cannot have space in parameter list '  )  ;%NWL%}%NWL%if ( key . indexOf (  "  '  " ! =  =  - 1 || value . indexOf (  "  '  " ! =  =  - 1 )  )  )  {%NWL%1
PooledWorker . prototype . workersDir = this . workersDir ;%NWL%}%NWL%if ( data . externalsDir )  {%NWL%this . externalsDir = this . _qualifyURL ( data . externalsDir )  ; %NWL%PooledWorker . prototype . externalsDir = this . externalsDir ;%NWL%}%NWL%if ( data . imagesDir )  {%NWL%this . imagesDir = this . _qualifyURL ( data . imagesDir )  ;%NWL%}%NWL%if ( data . soundsDir )  {%NWL%this . soundsDir = this . _qualifyURL ( data . soundsDir )  ; %NWL%3
conf =  {%NWL%on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%e . pageX = data . pageX ; %NWL%8
}%NWL%statusService . setProgressResult ( error )  ;%NWL%}%NWL%function InputManager ( options )  {%NWL%EventTarget . attach ( this )  ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . statusService = options . statusService ; %NWL%this . fileClient = options . fileClient ; %NWL%this . progressService = options . progressService ; %NWL%this . contentTypeRegistry = options . contentTypeRegistry ; %NWL%this . selection = options . selection ; %NWL%5
air . File = window . runtime . flash . filesystem . File ; %NWL%air . FileStream = window . runtime . flash . filesystem . FileStream ; %NWL%air . FileMode = window . runtime . flash . filesystem . FileMode ; %NWL%air . EncryptedLocalStore = window . runtime . flash . data . EncryptedLocalStore ; %NWL%air . SQLCollationType = window . runtime . flash . data . SQLCollationType ; %NWL%air . SQLColumnNameStyle = window . runtime . flash . data . SQLColumnNameStyle ; %NWL%air . SQLColumnSchema = window . runtime . flash . data . SQLColumnSchema ; %NWL%air . SQLConnection = window . runtime . flash . data . SQLConnection ; %NWL%air . SQLError = window . runtime . flash . errors . SQLError ; %NWL%air . SQLErrorEvent = window . runtime . flash . events . SQLErrorEvent ; %NWL%air . SQLErrorOperation = window . runtime . flash . errors . SQLErrorOperation ; %NWL%8
app . defaultConfiguration = function (  )  {%NWL%this . enable (  ' x - powered - by '  )  ; %NWL%this . set (  ' env '  , process . env . NODE_ENV || ' development '  )  ; %NWL%this . set (  ' subdomain offset '  , 2 )  ; %NWL%debug (  ' booting in %s mode '  , this . get (  ' env '  )  )  ; %NWL%this . use ( connect . query (  )  )  ; %NWL%this . use ( middleware . init ( this )  )  ; %NWL%this . on (  ' mount '  , function ( parent )  {%NWL%this . request . __proto__ = parent . request ; %NWL%this . response . __proto__ = parent . response ; %NWL%this . engines . __proto__ = parent . engines ; %NWL%8
this . id = id ;%NWL%}%NWL%Gator . prototype . on = function ( events , selector , callback )  {%NWL%return _bind . call ( this , events , selector , callback )  ;%NWL%}  ; %NWL%Gator . prototype . off = function ( events , selector , callback )  {%NWL%return _bind . call ( this , events , selector , callback , true )  ;%NWL%}  ; %NWL%Gator . matchesSelector = function (  )  {  }  ; %NWL%Gator . cancel = _cancel ; %NWL%Gator . addEvent = _addEvent ; %NWL%9
this . name     = contentInitDict . name || "  "  ; %NWL%this . description   = contentInitDict . description || null ; %NWL%this . rating    = contentInitDict . rating || 0 ;%NWL%}  ; %NWL%Content = function ( contentInitDict )  {%NWL%var content =  {  }  ; %NWL%content . editableAttributes = contentInitDict . editableAttributes || [  ]  ; %NWL%content . id     = contentInitDict . id || Math . uuid ( null , 16 )  ; %NWL%content . name     = contentInitDict . name || "  "  ; %NWL%content . type     = contentInitDict . type || " IMAGE "  ; %NWL%content . mimeType    = contentInitDict . mimeType || "  "  ; %NWL%8
updateInitialOffset : function ( initialOffset )  {%NWL%if ( typeof initialOffset =  =  ' number '  )  {%NWL%initialOffset =  {%NWL%x : initialOffset ,%NWL%y : initialOffset%NWL%}  ;%NWL%}%NWL%var offset = this . offset ,%NWL%x , y ; %NWL%offset . x = x = initialOffset . x ; %NWL%offset . y = y = initialOffset . y ; %NWL%9
this . _defaultRowHeight = defaultRowHeight ; %NWL%this . _rowHeightGetter = rowHeightGetter ?%NWL%rowHeightGetter :%NWL%(  )  =  > defaultRowHeight ; %NWL%this . _viewportHeight = viewportHeight ; %NWL%this . scrollRowIntoView = this . scrollRowIntoView . bind ( this )  ; %NWL%this . setViewportHeight = this . setViewportHeight . bind ( this )  ; %NWL%this . scrollBy = this . scrollBy . bind ( this )  ; %NWL%this . scrollTo = this . scrollTo . bind ( this )  ; %NWL%this . scrollToRow = this . scrollToRow . bind ( this )  ; %NWL%this . setRowHeightGetter = this . setRowHeightGetter . bind ( this )  ; %NWL%5
var obj = util . getObjectById ( args . uid )  ; %NWL%var recvdObj = args . object ; %NWL%updateProperties ( obj , recvdObj )  ; %NWL%obj . paths [ 0 ]  . width = recvdObj . width ; %NWL%obj . paths [ 0 ]  . height = recvdObj . height ; %NWL%obj . paths [ 1 ]  . width = recvdObj . width / 20 ; %NWL%obj . paths [ 1 ]  . height = recvdObj . height * 3 ; %NWL%obj . paths [ 2 ]  . points = recvdObj . paths [ 2 ]  . points ; %NWL%obj . paths [ 3 ]  . points = recvdObj . paths [ 3 ]  . points ; %NWL%obj . paths [ 4 ]  . points = recvdObj . paths [ 4 ]  . points ; %NWL%obj . paths [ 5 ]  . points = recvdObj . paths [ 5 ]  . points ; %NWL%7
)  {%NWL%res . statusCode = 400 ; %NWL%res . end (  )  ;%NWL%} else {%NWL%Post%NWL%. where (  ' slug '  , req . params . slug )%NWL%. findOne ( function ( err , post )  {%NWL%if ( err || !post )  { res . statusCode = 404 ; res . end (  )  ; return ;  }%NWL%post . md = req . body . md ; %NWL%post . tags = req . body . tags ; %NWL%post . title = req . body . title ; %NWL%8
air . DRMAuthenticateEvent = window . runtime . flash . events . DRMAuthenticateEvent ; %NWL%air . DRMStatusEvent = window . runtime . flash . events . DRMStatusEvent ; %NWL%air . ErrorEvent = window . runtime . flash . events . ErrorEvent ; %NWL%air . Event = window . runtime . flash . events . Event ; %NWL%air . EventDispatcher = window . runtime . flash . events . EventDispatcher ; %NWL%air . FileListEvent = window . runtime . flash . events . FileListEvent ; %NWL%air . HTTPStatusEvent = window . runtime . flash . events . HTTPStatusEvent ; %NWL%air . IOErrorEvent = window . runtime . flash . events . IOErrorEvent ; %NWL%air . InvokeEvent = window . runtime . flash . events . InvokeEvent ; %NWL%air . NetStatusEvent = window . runtime . flash . events . NetStatusEvent ; %NWL%air . OutputProgressEvent = window . runtime . flash . events . OutputProgressEvent ; %NWL%0
lodash . findLastIndex = arrays . findLastIndex ; %NWL%lodash . findLastKey = objects . findLastKey ; %NWL%lodash . has = objects . has ; %NWL%lodash . identity = utilities . identity ; %NWL%lodash . indexOf = arrays . indexOf ; %NWL%lodash . isArguments = objects . isArguments ; %NWL%lodash . isArray = isArray ; %NWL%lodash . isBoolean = objects . isBoolean ; %NWL%lodash . isDate = objects . isDate ; %NWL%lodash . isElement = objects . isElement ; %NWL%lodash . isEmpty = objects . isEmpty ; %NWL%1
sensorDefinitions . goMotion . sensorName = i18n . t (  " sensor . names . goMotion "  )  ; %NWL%sensorDefinitions . goTemp . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . goTemp . sensorName = i18n . t (  " sensor . names . goTemp "  )  ; %NWL%sensorDefinitions . goLinkTemperature . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . goLinkTemperature . sensorName = i18n . t (  " sensor . names . goLinkTemperature "  )  ; %NWL%sensorDefinitions . goLinkLight . measurementName = i18n . t (  " sensor . measurements . light_intensity "  )  ; %NWL%sensorDefinitions . goLinkLight . sensorName = i18n . t (  " sensor . names . goLinkLight "  )  ; %NWL%sensorDefinitions . goLinkForce . measurementName = i18n . t (  " sensor . measurements . force "  )  ; %NWL%sensorDefinitions . goLinkForce . sensorName = i18n . t (  " sensor . names . goLinkForce "  )  ; %NWL%sensorDefinitions . goLinkPH . measurementName = i18n . t (  " sensor . measurements . acidity "  )  ; %NWL%sensorDefinitions . goLinkPH . sensorName = i18n . t (  " sensor . names . goLinkPH "  )  ; %NWL%0
}  )  (  )  ; %NWL%Backbone . Debug =  ( function (  )  {%NWL%function Debug (  )  {%NWL%this . _prettyInstanceName = __bind ( this . _prettyInstanceName , this )  ; %NWL%this . _hookConstructor = __bind ( this . _hookConstructor , this )  ; %NWL%this . _hookPrototype = __bind ( this . _hookPrototype , this )  ; %NWL%this . _hookMethod = __bind ( this . _hookMethod , this )  ; %NWL%this . _onSync = __bind ( this . _onSync , this )  ; %NWL%this . _onEvent = __bind ( this . _onEvent , this )  ; %NWL%this . _onViewBinding = __bind ( this . _onViewBinding , this )  ; %NWL%this . _onNewInstance = __bind ( this . _onNewInstance , this )  ; %NWL%3
extendedFunction [ prop ]  = originalFunction [ prop ]  ;%NWL%}%NWL%}%NWL%extendedFunction . prototype  = originalFunction . prototype ; %NWL%extendedFunction . constructor = originalFunction . constructor ; %NWL%extendedFunction . name   = originalFunction . name || ' httpBitLyDevinsFunctionNamingConvention '  ; %NWL%if ( typeof originalFunction . length ! =  =  ' undefined '  )  {  /  / if 0 , then extendedFunction . length already =  =  = 0%NWL%extendedFunction . length = originalFunction . length ;  /  / extendedFunction doesn ' t list arguments!%NWL%}%NWL%if ( originalFunction . __proto__ )  {%NWL%extendedFunction . __proto__ = originalFunction . __proto__ ; %NWL%3
this . attributes = attributes || [  ]  ; %NWL%this . children = children || [  ]  ; %NWL%if ( typeof cslId =  =  =  " undefined "  )  {%NWL%this . cslId =  - 1 ;%NWL%} else {%NWL%this . cslId = cslId ;%NWL%}%NWL%}  ; %NWL%CSLEDIT_CslNode . prototype . _copy = function ( source )  {%NWL%this . name = source . name ; %NWL%this . attributes = source . attributes ; %NWL%9
if ( typeof timer ! =  " number "  ) timer = 0 ; %NWL%setTimeout ( function (  )  {%NWL%self . set (  ' location '  , newLocation )  ; %NWL%if ( !isFromHistory ) window . history . pushState (  { url : newLocation , customParams : customParams }  ,  '  '  , newLocation )  ; %NWL%changeObj . fromCache = false ; %NWL%var fromCache = self . getCache ( changeObj . to )  ; %NWL%if ( ! ( !fromCache )  )  {%NWL%changeObj . fromCache = true%NWL%changeObj . data = fromCache . data ; %NWL%changeObj . toTitle = fromCache . title ; %NWL%changeObj . bodyClass = fromCache . bodyClass ; %NWL%8
divElement . appendChild ( group )  ; %NWL%this . canvasElement = new goog . graphics . VmlGroupElement ( group , this )  ; %NWL%goog . events . listen ( divElement , goog . events . EventType . RESIZE , goog . bind (%NWL%this . handleContainerResize_ , this )  )  ;%NWL%}  ; %NWL%goog . graphics . VmlGraphics . prototype . handleContainerResize_ = function (  )  {%NWL%var size = goog . style . getSize ( this . getElement (  )  )  ; %NWL%var style = this . canvasElement . getElement (  )  . style ; %NWL%if ( size . width )  {%NWL%style . width = size . width +  ' px '  ; %NWL%style . height = size . height +  ' px '  ; %NWL%9
var requests =  [  ]  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%request . requestUrl = stmt . row . requestUrl ; %NWL%request . requestMethod = stmt . row . requestMethod ; %NWL%request . request = stmt . row . request ; %NWL%request . curl = stmt . row . curl ; %NWL%request . creationTime = stmt . row . creationTime ; %NWL%3
var $doc = $ ( document )  ,%NWL%cmp  = function ( a , b )  { return a < b ? - 1 : a > b ? 1 : 0 ;  }  ,%NWL%rclasses =  / vise -  ( orientation|size|width|height )  - \S *  / g ,%NWL%Vise ; %NWL%Vise = function ( element , options )  {%NWL%this . sizes  = $ . extend ( true ,  {  }  , this . sizes )  ; %NWL%this . options = $ . extend ( true ,  {  }  , this . options , options )  ; %NWL%this . element = element ; %NWL%this . clamp  = $ (  '  < div /  >  '  )  . appendTo ( this . element )  ; %NWL%this . loaded  = $ . proxy ( this . loaded , this )  ; %NWL%this . resizer = $ . proxy ( this . resizer , this )  ; %NWL%9
args . options . rowLength = args . options . rowLength || 0 ; %NWL%args . options . rowLength +  = result . rowLength ; %NWL%args . options . rowLengthArray = args . options . rowLengthArray || [  ]  ; %NWL%args . options . rowLengthArray . push ( result . rowLength )  ; %NWL%if ( result . meta && result . meta . pageState )  {%NWL%args . options . pageState = result . meta . pageState ; %NWL%self . _innerExecute ( args . query , args . params , args . options , pageCallback )  ; %NWL%return ;%NWL%}%NWL%result . rowLength = args . options . rowLength ; %NWL%result . rowLengthArray = args . options . rowLengthArray ; %NWL%9
this . _wrapperFunc = w ;%NWL%}  ; %NWL%Aspect . prototype . _wrapper = function (  )  {%NWL%throw ' Not implemented '  ;%NWL%}  ; %NWL%Aspect . prototype . invoke = function ( params )  {%NWL%var aspectData =  {  }  ; %NWL%aspectData . when = this . when ; %NWL%aspectData . method = params . methodName ; %NWL%aspectData . args = params . args ; %NWL%aspectData . exception = params . exception ; %NWL%9
camera . matrixWorld . decompose ( _position , _quaternion , _scale )  ; %NWL%_cameraL . fov = camera . fov ; %NWL%_cameraL . aspect = 0 . 5 * camera . aspect ; %NWL%_cameraL . near = camera . near ; %NWL%_cameraL . far = camera . far ; %NWL%_cameraL . updateProjectionMatrix (  )  ; %NWL%_cameraL . position . copy ( _position )  ; %NWL%_cameraL . quaternion . copy ( _quaternion )  ; %NWL%_cameraL . translateX (  - this . separation )  ; %NWL%_cameraR . near = camera . near ; %NWL%_cameraR . far = camera . far ; %NWL%9
" change select "  :  " set_department "%NWL%}  ,%NWL%set_department : function ( event )  {%NWL%this . model . set (  ' department '  , event . target . value )%NWL%this . model . set (  { page_number : 1 }  )%NWL%}%NWL%}  )  ; %NWL%var DateFilter = Backbone . View . extend (  {%NWL%initialize : function ( options )  {%NWL%this . title = options . title ; %NWL%this . min_field = options . min_field ; %NWL%9
result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%6
} else {%NWL%createRange = function ( fix )  {%NWL%var clength , edited_element , range , s ; %NWL%range =  {  }  ; %NWL%s = dom_root . getSelection (  )  ; %NWL%clength = textfield . textContent . length ; %NWL%range . left = Math . min ( s . anchorOffset , clength )  ; %NWL%range . right = Math . min ( s . focusOffset , clength )  ; %NWL%if ( fix ! = null )  {%NWL%range . left = fix ( range . left )  ; %NWL%range . right = fix ( range . right )  ; %NWL%9
exports . _stream_readable			 = require . resolve (  ' readable - stream / readable . js '  )  ; %NWL%exports . _stream_transform			 = require . resolve (  ' readable - stream / transform . js '  )  ; %NWL%exports . _stream_writable			 = require . resolve (  ' readable - stream / writable . js '  )  ; %NWL%exports . string_decoder				 = require . resolve (  ' string_decoder /  '  )  ; %NWL%exports . sys							 = require . resolve (  ' util / util . js '  )  ; %NWL%exports . timers						 = require . resolve (  ' timers - browserify '  )  ; %NWL%exports . tls							 = null ; %NWL%exports . tty							 = require . resolve (  ' tty - browserify '  )  ; %NWL%exports . url							 = require . resolve (  ' url /  '  )  ; %NWL%exports . util						 = require . resolve (  ' util / util . js '  )  ; %NWL%exports . vm							 = require . resolve (  ' vm - browserify '  )  ; %NWL%5
return ; %NWL%var newSourceCodeLocation = sourceCode . createSourceCodeLocation ( lineNumber , columnNumber )  ; %NWL%console . assert ( newSourceCodeLocation . sourceCode =  =  = this . _sourceCode )  ; %NWL%this . _makeChangeAndDispatchChangeEventIfNeeded ( function (  )  {%NWL%this . _lineNumber = newSourceCodeLocation . _lineNumber ; %NWL%this . _columnNumber = newSourceCodeLocation . _columnNumber ; %NWL%if ( newSourceCodeLocation . _mappedLocationIsResolved )  {%NWL%this . _mappedLocationIsResolved = true ; %NWL%this . _mappedResource = newSourceCodeLocation . _mappedResource ; %NWL%this . _mappedLineNumber = newSourceCodeLocation . _mappedLineNumber ; %NWL%this . _mappedColumnNumber = newSourceCodeLocation . _mappedColumnNumber ; %NWL%4
;  /  / FALL - THROUGH%NWL%case 47 : %NWL%case 1047 : %NWL%if ( this . normal )  {%NWL%this . lines = this . normal . lines ; %NWL%this . ybase = this . normal . ybase ; %NWL%this . ydisp = this . normal . ydisp ; %NWL%this . x = this . normal . x ; %NWL%this . y = this . normal . y ; %NWL%this . scrollTop = this . normal . scrollTop ; %NWL%this . scrollBottom = this . normal . scrollBottom ; %NWL%4
}%NWL%}  ,%NWL%move : function ( wrappers , event , controller )  {%NWL%if ( this . disabled || this . touchId =  =  = null )  {%NWL%return ;%NWL%}%NWL%for ( var i = 0 ; i < wrappers . length ; i +  +  )  {%NWL%var w = wrappers [ i ]  ; %NWL%if ( this . touchId =  =  = w . id )  {%NWL%this . pageX = w . pageX ; %NWL%this . pageY = w . pageY ; %NWL%9
this . json =  {  }  ; %NWL%this . appPrefix =  ' app :  /  /  '  ; %NWL%this . appURL = this . appPrefix + appDomain +  '  / resources /  '  ;%NWL%}  ; %NWL%Resources . prototype . getResources = function ( conf )  {%NWL%var operatorJSON =  {  }  ; %NWL%operatorJSON . default_contacts = this . addFile ( conf . default_contacts )  ; %NWL%operatorJSON . support_contacts = this . addFile ( conf . support_contacts )  ; %NWL%operatorJSON . network_type = this . addFile ( conf . network_type )  ; %NWL%operatorJSON . known_networks = this . addFile ( conf . known_networks )  ; %NWL%operatorJSON . sms = this . addFile ( conf . sms )  ; %NWL%6
json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%json . num_inputs = this . num_inputs ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%this . out_sy = json . out_sy ; %NWL%this . layer_type = json . layer_type ; %NWL%this . num_inputs = json . num_inputs ; %NWL%6
var childRow = this ; %NWL%var childRowHandler = $ ( childRow )  . data (  ' fieldUIRowHandler '  )  ; %NWL%$ . extend ( refreshRows , childRowHandler . regionChange ( region , false )  )  ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%Drupal . fieldUIDisplayOverview = Drupal . fieldUIDisplayOverview || {  }  ; %NWL%Drupal . fieldUIDisplayOverview . group = function ( row , data )  {%NWL%this . row = row ; %NWL%this . name = data . name ; %NWL%this . region = data . region ; %NWL%9
if ( isNumberA || isNumberB ) return isNumberA && isNumberB && + a =  =  + b ; %NWL%var isBooleanA = _ . isBoolean ( a )  , isBooleanB = _ . isBoolean ( b )  ; %NWL%if ( isBooleanA || isBooleanB ) return isBooleanA && isBooleanB && + a =  =  + b ; %NWL%var isDateA = _ . isDate ( a )  , isDateB = _ . isDate ( b )  ; %NWL%if ( isDateA || isDateB ) return isDateA && isDateB && a . getTime (  )  =  = b . getTime (  )  ; %NWL%var isRegExpA = _ . isRegExp ( a )  , isRegExpB = _ . isRegExp ( b )  ; %NWL%if ( isRegExpA || isRegExpB )  {%NWL%return isRegExpA && isRegExpB &&%NWL%a . source =  = b . source &&%NWL%a . global =  = b . global &&%NWL%a . multiline =  = b . multiline &&%NWL%8
{%NWL%var gl = this . gl ; %NWL%var program = PIXI . compileProgram ( gl , this . vertexSrc , this . fragmentSrc )  ; %NWL%gl . useProgram ( program )  ; %NWL%this . uSampler = gl . getUniformLocation ( program ,  ' uSampler '  )  ; %NWL%this . projectionVector = gl . getUniformLocation ( program ,  ' projectionVector '  )  ; %NWL%this . offsetVector = gl . getUniformLocation ( program ,  ' offsetVector '  )  ; %NWL%this . dimensions = gl . getUniformLocation ( program ,  ' dimensions '  )  ; %NWL%this . uMatrix = gl . getUniformLocation ( program ,  ' uMatrix '  )  ; %NWL%this . aVertexPosition = gl . getAttribLocation ( program ,  ' aVertexPosition '  )  ; %NWL%this . aPositionCoord = gl . getAttribLocation ( program ,  ' aPositionCoord '  )  ; %NWL%9
case 1049 :%NWL%;  /  / FALL - THROUGH%NWL%case 47 : %NWL%case 1047 : %NWL%if ( this . normal )  {%NWL%this . lines = this . normal . lines ; %NWL%this . ybase = this . normal . ybase ; %NWL%this . ydisp = this . normal . ydisp ; %NWL%this . x = this . normal . x ; %NWL%this . y = this . normal . y ; %NWL%this . scrollTop = this . normal . scrollTop ; %NWL%5
}%NWL%DeviceMotionEvent = function ( data )  {%NWL%this . initDeviceMotionEvent ( data )  ;%NWL%}%NWL%DeviceMotionEvent . prototype = new WDomEvent (  )  ; %NWL%DeviceMotionEvent . prototype . constructor = DeviceOrientationEvent ; %NWL%DeviceMotionEvent . parent = WDomEvent . prototype ;  /  / our " super " property%NWL%DeviceMotionEvent . prototype . initDeviceMotionEvent = function ( data )  {%NWL%this . acceleration = data . acceleration ; %NWL%this . accelerationIncludingGravity = null ; %NWL%this . rotationRate = data . rotationRate ; %NWL%8
this . startRow = options . startRow || 0 ; %NWL%this . startCol = options . startCol || 0 ; %NWL%this . endRow =  ( typeof options . endRow =  =  =  ' undefined ' ? this . rows - 1 : options . endRow )  ; %NWL%this . endCol =  ( typeof options . endCol =  =  =  ' undefined ' ? this . cols - 1 : options . endCol )  ; %NWL%this . row = this . startRow ; %NWL%this . col = this . startCol ; %NWL%this . frame = 1 ; %NWL%this . squeeze = options . squeeze || false ; %NWL%this . interval =  ( typeof options . interval =  =  =  ' undefined ' ? 125 : options . interval )  ; %NWL%this . useTimer =  ( typeof options . useTimer =  =  =  ' undefined ' ? true : options . useTimer )  ; %NWL%this . advanceFramesManually = options . advanceFramesManually || false ; %NWL%7
var child = this . ownerDocument . createElementNS (  " http :  /  / www . w3 . org / 2000 / svg "  , childType )  ; %NWL%this . appendChild ( child )  ; %NWL%if ( className )%NWL%child . setAttribute (  " class "  , className )  ; %NWL%return child ;%NWL%}%NWL%function AnchorBox ( x , y , width , height )%NWL%{%NWL%this . x = x || 0 ; %NWL%this . y = y || 0 ; %NWL%this . width = width || 0 ; %NWL%8
state = GenStateCompleted ; %NWL%if ( method =  =  =  " next "  )  {%NWL%context . dispatchException ( thrown )  ;%NWL%} else {%NWL%arg = thrown ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%generator . next = invoke . bind ( generator ,  " next "  )  ; %NWL%generator . throw = invoke . bind ( generator ,  " throw "  )  ; %NWL%9
break ; %NWL%default : break ;%NWL%}%NWL%}%NWL%if ( req . query . genEdFocus ! = null && req . query . genEdFocus ! =  '  ' &&%NWL%req . query . genEdFocus ! =  ' Any '  )  {%NWL%opts . genEdFocus = req . query . genEdFocus ;%NWL%}%NWL%if ( req . query . course ! = null && req . query . course ! =  '  ' &&%NWL%req . query . course ! =  ' Any '  )  {%NWL%opts . course = req . query . course ; %NWL%6
resourceful . unregister  = require (  '  .  / resourceful / core '  )  . unregister ; %NWL%resourceful . engines   = require (  '  .  / resourceful / engines '  )  ; %NWL%resourceful . instantiate  = require (  '  .  / resourceful / core '  )  . instantiate ; %NWL%resourceful . deferredRelationships = require (  '  .  / resourceful / core '  )  . deferredRelationships ; %NWL%resourceful . typeOf   = require (  '  .  / resourceful / common '  )  . typeOf ; %NWL%resourceful . mixin    = require (  '  .  / resourceful / common '  )  . mixin ; %NWL%resourceful . clone    = require (  '  .  / resourceful / common '  )  . clone ; %NWL%resourceful . async    = require (  '  .  / resourceful / common '  )  . async ; %NWL%resourceful . capitalize  = require (  '  .  / resourceful / common '  )  . capitalize ; %NWL%resourceful . pluralize   = require (  '  .  / resourceful / common '  )  . pluralize ; %NWL%resourceful . lowerize   = require (  '  .  / resourceful / common '  )  . lowerize ; %NWL%4
if ( divs [ i ]  . className . match (  / resultMessage /  )  )  {%NWL%return divs [ i ]  ;%NWL%}%NWL%}%NWL%}  ; %NWL%var runner , spec , fakeTimer ; %NWL%beforeEach ( function (  )  {%NWL%fakeTimer = new jasmine . FakeTimer (  )  ; %NWL%env . setTimeout = fakeTimer . setTimeout ; %NWL%env . clearTimeout = fakeTimer . clearTimeout ; %NWL%env . setInterval = fakeTimer . setInterval ; %NWL%8
if ( currentSpeed < 0 )%NWL%{%NWL%currentSpeed +  = 4 ; %NWL%currentSpeed =  ( currentSpeed > 0 ) ? 0 : currentSpeed ;%NWL%}%NWL%}%NWL%game . physics . velocityFromRotation ( tank . rotation , currentSpeed , tank . body . velocity )  ; %NWL%land . tilePosition . x =  - game . camera . x ; %NWL%land . tilePosition . y =  - game . camera . y ; %NWL%shadow . x = tank . x ; %NWL%shadow . y = tank . y ; %NWL%9
exports . gauge = require (  '  .  / lib / widget / gauge . js '  )%NWL%exports . log = require (  '  .  / lib / widget / log . js '  )%NWL%exports . picture = require (  '  .  / lib / widget / picture . js '  )%NWL%exports . sparkline = require (  '  .  / lib / widget / sparkline . js '  )%NWL%exports . table = require (  '  .  / lib / widget / table . js '  )%NWL%exports . tree = require (  '  .  / lib / widget / tree . js '  )%NWL%exports . bar = require (  '  .  / lib / widget / charts / bar '  )%NWL%exports . line = require (  '  .  / lib / widget / charts / line '  )%NWL%exports . OutputBuffer = require (  '  .  / lib / server - utils '  )  . OutputBuffer%NWL%exports . InputBuffer = require (  '  .  / lib / server - utils '  )  . InputBuffer%NWL%exports . createScreen = require (  '  .  / lib / server - utils '  )  . createScreen%NWL%8
if ( hash ) HashP . update ( merged , hash )  ; %NWL%if ( other ) HashP . update ( merged , other )  ; %NWL%return merged ;%NWL%}%NWL%HashP . update = function ( hash , other )  {%NWL%for ( var key in other )%NWL%HashP . set ( hash , key , other [ key ]  )  ; %NWL%return hash ;%NWL%}%NWL%HashP . forEach = Hash . forEach ; %NWL%HashP . map = Hash . map ; %NWL%9
bCats =  [  ]  . concat ( higherLevelData [ j ]  . aggField )  ; %NWL%if ( series . x && series . x . _hasCategories (  )  )  {%NWL%bCats = bCats . concat ( higherLevelData [ j ]  . xField )  ;%NWL%}%NWL%if ( series . y && series . y . _hasCategories (  )  )  {%NWL%bCats = bCats . concat ( higherLevelData [ j ]  . yField )  ;%NWL%}%NWL%bCatString = bCats . join (  " | "  )  ; %NWL%if ( aCatString =  =  = bCatString )  {%NWL%returnData [ i ]  . xField = higherLevelData [ j ]  . xField ; %NWL%returnData [ i ]  . xValue = higherLevelData [ j ]  . xValue ; %NWL%9
return function (  )  {%NWL%if ( arguments . length > 0 ) currentValue = arguments [ 0 ]  ; %NWL%return currentValue ;%NWL%}  ;%NWL%}  ; %NWL%window . NavHistory =  ( function (  )  {%NWL%function NavHistory ( opts )  {%NWL%this . navigateAll = __bind ( this . navigateAll , this )  ; %NWL%this . navigate = __bind ( this . navigate , this )  ; %NWL%this . _entriesArray = __bind ( this . _entriesArray , this )  ; %NWL%this . forward = __bind ( this . forward , this )  ; %NWL%7
this . sendEventTo = __bind ( this . sendEventTo , this )  ; %NWL%this . setUpReceiveEventCallbacks = __bind ( this . setUpReceiveEventCallbacks , this )  ; %NWL%this . channelConnectionOnData = __bind ( this . channelConnectionOnData , this )  ; %NWL%this . channelOnConnectionClose = __bind ( this . channelOnConnectionClose , this )  ; %NWL%this . channelOnConnection = __bind ( this . channelOnConnection , this )  ; %NWL%this . readDesiredServerIDFromURL = __bind ( this . readDesiredServerIDFromURL , this )  ; %NWL%this . channelOnInvalidID = __bind ( this . channelOnInvalidID , this )  ; %NWL%this . channelOnUnavailableID = __bind ( this . channelOnUnavailableID , this )  ; %NWL%this . channelOnReady = __bind ( this . channelOnReady , this )  ; %NWL%this . serverFileCollection = options . serverFileCollection ; %NWL%this . routeCollection = options . routeCollection ; %NWL%9
if ( state . key! =  - 100 ) copystate . key = state . key ; %NWL%if ( state . disabled ) copystate . disabled = true ; %NWL%if ( state . search ) copystate . search = true ; %NWL%if ( state . subfolder ) copystate . subfolder = true ; %NWL%if ( state . page ! = 1 ) copystate . page = state . page ; %NWL%copystate . elems = state . elems ; %NWL%if ( state . nameordesc . length ) copystate . nameordesc = state . nameordesc ; %NWL%if ( state . asname . length ) copystate . asname = state . asname ; %NWL%if ( state . asdescription . length ) copystate . asdescription = state . asdescription ; %NWL%if ( state . aspriority . length ) copystate . aspriority = state . aspriority ; %NWL%if ( state . asauthor . length ) copystate . asauthor = state . asauthor ; %NWL%6
lodash . keys = objects . keys ; %NWL%lodash . map = collections . map ; %NWL%lodash . mapValues = objects . mapValues ; %NWL%lodash . max = collections . max ; %NWL%lodash . memoize = functions . memoize ; %NWL%lodash . merge = objects . merge ; %NWL%lodash . min = collections . min ; %NWL%lodash . omit = objects . omit ; %NWL%lodash . once = functions . once ; %NWL%lodash . pairs = objects . pairs ; %NWL%lodash . partial = functions . partial ; %NWL%4
import Base from ' simple - auth / authenticators / base '  ; %NWL%import Configuration from '  .  /  .  .  / configuration '  ; %NWL%export default Base . extend (  {%NWL%serverTokenEndpoint :  '  / users / sign_in '  ,%NWL%resourceName :  ' user '  ,%NWL%tokenAttributeName :  ' token '  ,%NWL%identificationAttributeName :  ' email '  ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint    = Configuration . serverTokenEndpoint ; %NWL%this . resourceName     = Configuration . resourceName ; %NWL%this . tokenAttributeName    = Configuration . tokenAttributeName ; %NWL%8
return _strftime ( fmt , d , locale )  ;%NWL%}%NWL%namespace . strftimeTZ = strftime . strftimeTZ = strftimeTZ ; %NWL%function strftimeTZ ( fmt , d , locale , timezone )  {%NWL%if (  ( typeof locale =  =  ' number ' || typeof locale =  =  ' string '  ) && timezone =  = null )  {%NWL%timezone = locale ; %NWL%locale = undefined ;%NWL%}%NWL%return _strftime ( fmt , d , locale ,  { timezone : timezone }  )  ;%NWL%}%NWL%namespace . strftimeUTC = strftime . strftimeUTC = strftimeUTC ; %NWL%2
d . x =  ( distance . x > step ) ? step : distance . x ;%NWL%} else if ( distance . x < 0 )  {%NWL%d . x =  ( distance . x <  - step ) ? - step : distance . x ;%NWL%} else {%NWL%d . x = 0 ;%NWL%}%NWL%distance . x -  = d . x ; %NWL%if ( distance . y > 0 )  {%NWL%d . y =  ( distance . y > step ) ? step : distance . y ;%NWL%} else if ( distance . y < 0 )  {%NWL%d . y =  ( distance . y <  - step ) ? - step : distance . y ; %NWL%2
rectManager . mergeSet ( dirty )  ; %NWL%l = dirty . length ; %NWL%for ( i = 0 ; i < l ;  +  + i )  {  /  / loop over every dirty rect%NWL%rect = dirty [ i ]  ; %NWL%dupes . length = 0 ; %NWL%objs . length = 0 ; %NWL%if ( !rect ) continue ; %NWL%rect . _w = rect . _x + rect . _w ; %NWL%rect . _h = rect . _y + rect . _h ; %NWL%rect . _x =  ( rect . _x > 0 ) ? ( rect . _x|0 )  :  ( rect . _x|0 )  - 1 ; %NWL%rect . _y =  ( rect . _y > 0 ) ? ( rect . _y|0 )  :  ( rect . _y|0 )  - 1 ; %NWL%9
]  , function ( dojo , lang , declare , array , connect , event , has , html , keys , dijitA11y , dijitFocus , _FocusManager )  {%NWL%var _FocusArea = declare (  " dojox . grid . enhanced . _FocusArea "  , null ,  {%NWL%constructor : function ( area , focusManager )  {%NWL%this . _fm = focusManager ; %NWL%this . _evtStack =  [ area . name ]  ; %NWL%var dummy = function (  )  { return true ;  }  ; %NWL%area . onFocus = area . onFocus || dummy ; %NWL%area . onBlur = area . onBlur || dummy ; %NWL%area . onMove = area . onMove || dummy ; %NWL%area . onKeyUp = area . onKeyUp || dummy ; %NWL%area . onKeyDown = area . onKeyDown || dummy ; %NWL%6
}  ; %NWL%RenderTarget . prototype . fromJSON = function ( json )  {%NWL%Class . prototype . fromJSON . call ( this , json )  ; %NWL%this . width = json . width ; %NWL%this . height = json . height ; %NWL%this . invWidth = json . invWidth ; %NWL%this . invHeight = json . invHeight ; %NWL%this . generateMipmap = json . generateMipmap ; %NWL%this . flipY = json . flipY ; %NWL%this . premultiplyAlpha = json . premultiplyAlpha ; %NWL%this . anisotropy = json . anisotropy ; %NWL%3
field . checked = true ;%NWL%}%NWL%} else {%NWL%if ( !field )  {%NWL%field = document . createElement (  " input "  )  ;  /  / $NON - NLS - 0$%NWL%field . type = parm . type ; %NWL%field . id = id ; %NWL%parent . appendChild ( field )  ;%NWL%}%NWL%if ( parm . value )  {%NWL%field . value = parm . value ; %NWL%5
var P0_wgs84 =  [ start_pos . longitude , start_pos . latitude , start_pos . elevation ]  ; %NWL%var P3_wgs84 =  [ target_lng , target_lat , target_elv ]  ; %NWL%this . distance = WGS84_a * Math . acos ( Math . sin ( MathUtils . Deg2Rad ( P0_wgs84 [ 1 ]  )  )  * Math . sin ( MathUtils . Deg2Rad ( P3_wgs84 [ 1 ]  )  )  + Math . cos ( MathUtils . Deg2Rad ( P0_wgs84 [ 1 ]  )  )  * Math . cos ( MathUtils . Deg2Rad ( P3_wgs84 [ 1 ]  )  )  * Math . cos ( MathUtils . Deg2Rad ( P3_wgs84 [ 0 ]  - P0_wgs84 [ 0 ]  )  )  )  ; %NWL%if ( isNaN ( this . distance )  )%NWL%{%NWL%this . distance = 0 ;%NWL%}%NWL%var P1_wgs84 =  [ start_pos . longitude , start_pos . latitude , start_pos . elevation + this . distance / 4 ]  ; %NWL%var P2_wgs84 =  [ target_lng , target_lat , target_elv + this . distance / 4 ]  ; %NWL%this . P0 = P0_wgs84 ; %NWL%this . P1 = P1_wgs84 ; %NWL%9
start : function ( event , ui )  {%NWL%$ ( this )  . addClass (  " ui - dialog - resizing "  )  ; %NWL%that . _blockFrames (  )  ; %NWL%that . _trigger (  " resizeStart "  , event , filteredUi ( ui )  )  ;%NWL%}  ,%NWL%resize : function ( event , ui )  {%NWL%that . _trigger (  " resize "  , event , filteredUi ( ui )  )  ;%NWL%}  ,%NWL%stop : function ( event , ui )  {%NWL%options . height = $ ( this )  . height (  )  ; %NWL%options . width = $ ( this )  . width (  )  ; %NWL%9
return this . dom_ . createDom ( goog . dom . TagName . TD ,  {  }  , goog . string . Unicode . NBSP )  ;%NWL%}  ; %NWL%goog . editor . TableRow = function ( trElement , rowIndex )  {%NWL%this . index = rowIndex ; %NWL%this . element = trElement ; %NWL%this . columns =  [  ]  ;%NWL%}  ; %NWL%goog . editor . TableCell = function ( td , startRow , startCol )  {%NWL%this . element = td ; %NWL%this . colSpan = parseInt ( td . colSpan , 10 ) || 1 ; %NWL%this . rowSpan = parseInt ( td . rowSpan , 10 ) || 1 ; %NWL%9
}%NWL%} else if ( Date . now )  {%NWL%getTimestamp = Date . now ;%NWL%}%NWL%Ext . perf . getTimestamp = Ext . perf . Accumulator . getTimestamp = getTimestamp ; %NWL%return getTimestamp (  )  ;%NWL%}  ; %NWL%function adjustSet ( set , time )  {%NWL%set . sum +  = time ; %NWL%set . min = Math . min ( set . min , time )  ; %NWL%set . max = Math . max ( set . max , time )  ; %NWL%9
}%NWL%}  ,%NWL%shouldCreateRecordsWithCustomPKFactory : function ( test )  {%NWL%var CustomPKFactory = function (  )  {  }%NWL%CustomPKFactory . prototype = new Object (  )  ; %NWL%CustomPKFactory . createPk = function (  )  {%NWL%return new client . bson_serializer . ObjectID (  " aaaaaaaaaaaa "  )  ;%NWL%}%NWL%var p_client = new Db ( MONGODB , new Server (  " 127 . 0 . 0 . 1 "  , 27017 )  ,  {  ' pk '  : CustomPKFactory , native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%p_client . bson_deserializer = client . bson_deserializer ; %NWL%p_client . bson_serializer = client . bson_serializer ; %NWL%9
reset : function (  )%NWL%{%NWL%this . _shotCount = 0 ; %NWL%this . _lastEmitTime = 0 ;%NWL%}  ,%NWL%config : function ( options )%NWL%{%NWL%this . _lastEmitTime = 0 ; %NWL%this . _shotCount = 0 ; %NWL%this . active = pc . checked ( options . active , true )  ; %NWL%this . emitting = pc . checked ( options . emitting , true )  ; %NWL%9
module . exports =  ( function (  )  {%NWL%if ( global . __TINT . ProgressBar )  {%NWL%return global . __TINT . ProgressBar ;%NWL%}%NWL%var Container = require (  ' Container '  )  ; %NWL%var $ = process . bridge . objc ; %NWL%function ProgressBar ( options )  {%NWL%options = options || {  }  ; %NWL%options . delegates = options . delegates || [  ]  ; %NWL%this . nativeClass = this . nativeClass || $ . NSProgressIndicator ; %NWL%this . nativeViewClass = this . nativeViewClass || $ . NSProgressIndicator ; %NWL%9
if ( videoMandatoryConstraints . maxHeight )  {%NWL%mandatory . maxHeight = videoMandatoryConstraints . maxHeight ;%NWL%}%NWL%if ( videoMandatoryConstraints . minAspectRatio )  {%NWL%mandatory . minAspectRatio = videoMandatoryConstraints . minAspectRatio ;%NWL%}%NWL%if ( videoMandatoryConstraints . maxFrameRate )  {%NWL%mandatory . maxFrameRate = videoMandatoryConstraints . maxFrameRate ;%NWL%}%NWL%if ( videoMandatoryConstraints . minFrameRate )  {%NWL%mandatory . minFrameRate = videoMandatoryConstraints . minFrameRate ; %NWL%1
jsonProp . id = jsonProp . id . toLowerCase (  )  ; %NWL%if ( !jsonProp . type )  {%NWL%ORYX . Log . info (  " Type is not defined for stencil ' %0 '  , id ' %1 '  . Falling back to ' String '  .  "  , stencil , jsonProp . id )  ; %NWL%jsonProp . type =  " string "  ;%NWL%}%NWL%else {%NWL%jsonProp . type = jsonProp . type . toLowerCase (  )  ;%NWL%}%NWL%jsonProp . prefix = jsonProp . prefix || " oryx "  ; %NWL%jsonProp . title = jsonProp . title || "  "  ; %NWL%jsonProp . value = jsonProp . value || "  "  ; %NWL%9
else {%NWL%this . stack =  '  '  ;%NWL%}%NWL%}%NWL%errors . _Abstract = ErrorAbstract ; %NWL%_ . inherits ( ErrorAbstract , Error )  ; %NWL%errors . ConnectionFault = function ConnectionFault ( msg )  {%NWL%ErrorAbstract . call ( this , msg || ' Connection Failure '  , errors . ConnectionFault )  ;%NWL%}  ; %NWL%_ . inherits ( errors . ConnectionFault , ErrorAbstract )  ; %NWL%errors . NoConnections = function NoConnections ( msg )  {%NWL%6
[  ' splitView : canCollapseSubview :  '  ,  ' B@ : @@ '  , function ( self , selector , splitview , subview )  { return $ . NO ;  }  . bind ( this )  ]  ,%NWL%[  ' splitView : constrainMaxCoordinate : ofSubviewAt :  '  ,  ' d@ : @dl '  , function ( self , selector , splitview , proposedMax , index )  { return proposedMax ;  }  . bind ( this )  ]  ,%NWL%[  ' splitView : constrainMinCoordinate : ofSubviewAt :  '  ,  ' d@ : @dl '  , function ( self , selector , splitview , proposedMin , index )  { return proposedMin ;  }  . bind ( this )  ]  ,%NWL%[  ' splitView : constrainSplitPosition : ofSubviewAt :  '  ,  ' d@ : @dl '  , function ( self , selector , splitview , proposedPosition , index )  { return proposedPosition ;  }  . bind ( this )  ]  ,%NWL%[  ' splitView : shouldAdjustSizeOfSubview :  '  ,  ' B@ : @@ '  , function ( self , selector , splitview , subview )  { return $ . YES ;  }  . bind ( this )  ]  ,%NWL%[  ' splitView : shouldHideDividerAtIndex :  '  ,  ' B@ : @l '  , function ( self , selector , splitview , index )  { return $ . YES ;  }  . bind ( this )  ]  ,%NWL%[  ' splitViewDidResizeSubviews :  '  ,  ' v@ : @ '  , function ( self , selector , notif )  { this . fireEvent (  ' resized '  )  ;  }  . bind ( this )  ]  ,%NWL%[  ' splitViewWillResizeSubviews :  '  ,  ' v@ : @ '  , function ( self , selector , notif )  { this . fireEvent (  ' resize '  )  ;  }  . bind ( this )  ]%NWL%]  )  ; %NWL%this . nativeClass = this . nativeClass || $ . NSSplitView ; %NWL%this . nativeViewClass = this . nativeViewClass || $ . NSSplitView ; %NWL%9
this . current = name ; %NWL%$ . addClass ( handle . tab . el ,  ' tabSelected '  )  ; %NWL%handle . view . appendTo ( this . views )  ;%NWL%}%NWL%}  )  ; %NWL%var ConnectionView = Class ( View , function (  )  {%NWL%this . init = function ( conn )  {%NWL%this . conn = conn ; %NWL%conn . onSubscribed = bind ( this ,  ' onSubscribed '  )  ; %NWL%conn . onMessaged = bind ( this ,  ' onMessaged '  )  ; %NWL%conn . onOpen = bind ( this ,  ' onOpen '  )  ; %NWL%8
Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%7
this . _select . grab ( new Element (  ' option '  ,  {  ' text '  : gettext (  " Loading .  .  .  "  )  ,  ' value '  : 0 }  )  )  ; %NWL%this . showSpinner ( this . spinnerEl )  ; %NWL%this . _view . fireEvent (  ' refreshGadgetList '  , true )  ;%NWL%}%NWL%}  )  ; %NWL%var GadgetElementWidget = new Class (  {%NWL%Extends : Widget ,%NWL%initialize : function ( view , gadgetElement , parentElement , where )  {%NWL%this . _onParticipantsChanged = this . _onParticipantsChanged . bind ( this )  ; %NWL%this . _onStateChange = this . _onStateChange . bind ( this )  ; %NWL%this . _onSetUserPref = this . _onSetUserPref . bind ( this )  ; %NWL%8
this . intervalId =  {  }  ; %NWL%this . lastTime =  ( new Date (  )  )  . getTime (  )  ; %NWL%this . accTime = 0 ; %NWL%this . timeStep = 1 ; %NWL%this . bounds =  { x : 0 , y : 0 , width : this . width , height : this . height }  ; %NWL%this . frameRateLabel =  {  }  ; %NWL%this . resourceManager = new Jest . ResourceManager (  )  ; %NWL%this . hitEntities =  [  ]  ; %NWL%this . particleCount = 0 ; %NWL%Jest . frameRate = this . frameRate ; %NWL%Jest . bounds = this . bounds ; %NWL%9
} else {%NWL%this . escaped = !!open ;%NWL%}%NWL%if ( rawParams instanceof AST . SexprNode )  {%NWL%this . sexpr = rawParams ;%NWL%} else {%NWL%this . sexpr = new AST . SexprNode ( rawParams , hash )  ;%NWL%}%NWL%this . id = this . sexpr . id ; %NWL%this . params = this . sexpr . params ; %NWL%this . hash = this . sexpr . hash ; %NWL%8
var count = 0 ; %NWL%for ( var docName in queues )%NWL%{%NWL%count +  +  ;%NWL%}%NWL%return count +  ' share ( s )  '  + this . clientCount +  ' client ( s )  '  ;%NWL%}  ; %NWL%events = new Events ( this )  ; %NWL%this . listen = events . listen ; %NWL%this . removeListener = events . removeListener ; %NWL%this . hasListeners = events . hasListeners ; %NWL%8
_DC = cc . global . DC ; %NWL%cc . createBinaryOpUGen = function ( ugenSelector , a , b )  {%NWL%return [ ugenSelector , a , b ]  ;%NWL%}  ; %NWL%cc . global . DC = function ( rate , input )  {%NWL%return 1 ;%NWL%}  ;%NWL%}  )  ; %NWL%after ( function (  )  {%NWL%cc . instanceOfUGen = _instanceOfUGen ; %NWL%cc . createBinaryOpUGen = _createBinaryOpUGen ; %NWL%9
ber . endSequence (  )  ; %NWL%return ber ;%NWL%}  ; %NWL%SearchRequest . prototype . _json = function ( j )  {%NWL%assert . ok ( j )  ; %NWL%j . baseObject = this . baseObject ; %NWL%j . scope = this . scope ; %NWL%j . derefAliases = this . derefAliases ; %NWL%j . sizeLimit = this . sizeLimit ; %NWL%j . timeLimit = this . timeLimit ; %NWL%j . typesOnly = this . typesOnly ; %NWL%5
}  ; %NWL%this . getByUserId = function ( userId , callback )  {%NWL%allocationsDB . findOne (  {%NWL%userId : userId%NWL%}  , function ( err , allocations )  {%NWL%if ( err ) return callback ( err , null )  ; %NWL%userDAO . getUserById ( userId , function ( err , user )  {%NWL%if ( err ) return callback ( err , null )  ; %NWL%allocations . userId = userId ; %NWL%allocations . userName = user . userName ; %NWL%allocations . firstName = user . firstName ; %NWL%9
}  ;%NWL%}%NWL%this . dom ( this . $stage . $window )  . bindDomEvent (  ' pointermove '  , this . $moveHandler )  ; %NWL%this . dom ( this . $stage . $window )  . bindDomEvent (  ' pointerup '  , this . $upHandler )  ; %NWL%this . _updateColorAndPaletteCursor ( pos )  ; %NWL%this . _triggerColorChange (  )  ;%NWL%}  ,%NWL%_updateColorAndPaletteCursor : function ( pos )  {%NWL%pos . x = pos . x < 0 ? 0 : pos . x ; %NWL%pos . x = pos . x > this . $ . paletteSize ? this . $ . paletteSize : pos . x ; %NWL%pos . y = pos . y < 0 ? 0 : pos . y ; %NWL%8
networkRequest . statusCode = response . status ; %NWL%networkRequest . statusText = response . statusText ; %NWL%networkRequest . responseHeaders = this . _headersMapToHeadersArray ( response . headers )  ; %NWL%if ( response . headersText )%NWL%networkRequest . responseHeadersText = response . headersText ; %NWL%if ( response . requestHeaders )%NWL%networkRequest . requestHeaders = this . _headersMapToHeadersArray ( response . requestHeaders )  ; %NWL%if ( response . requestHeadersText )%NWL%networkRequest . requestHeadersText = response . requestHeadersText ; %NWL%networkRequest . connectionReused = response . connectionReused ; %NWL%networkRequest . connectionId = response . connectionId ; %NWL%1
}  )  ;%NWL%}  ,%NWL%_getLetter : function ( evt )  {%NWL%if ( !evt . meta && evt . keyCode >  = 65 && evt . keyCode <  = 90 )  {%NWL%return alphabet . charAt ( evt . keyCode - 65 )  ;%NWL%}%NWL%return null ;%NWL%}  ,%NWL%_mixin : function ( evt )  {%NWL%evt . meta = this . meta ; %NWL%evt . shift = this . shift ; %NWL%9
return this . wheelRotation ;%NWL%}  ,%NWL%setWheelPosition : function ( wheelPosition_in )  {%NWL%this . wheelPosition = wheelPosition_in ; %NWL%this . wheelObj . position = wheelPosition ;%NWL%}  ,%NWL%getWheelPosition : function (  )  {%NWL%return this . wheelPosition ;%NWL%}  ,%NWL%setSteering : function ( steering_in )  {%NWL%this . steering = steering_in ; %NWL%3
this . _maxSize = 0 ; %NWL%this . parent = path . dirname ( directoryEntry . fileName )  ; %NWL%this . filename = path . basename ( directoryEntry . fileName )  ; %NWL%this . path = path . normalize ( directoryEntry . fileName )  ; %NWL%this . type = directoryEntry . fileAttributes . type ; %NWL%this . mode = directoryEntry . fileAttributes . mode ; %NWL%this . compressionMethod = directoryEntry . compressionMethod ; %NWL%this . modified = directoryEntry . modifiedTime ; %NWL%this . crc32 = directoryEntry . crc32 ; %NWL%this . compressedSize = directoryEntry . compressedSize ; %NWL%this . uncompressedSize = directoryEntry . uncompressedSize ; %NWL%6
_round : function (  )  {%NWL%this . x = Math . round ( this . x )  ; %NWL%this . y = Math . round ( this . y )  ; %NWL%return this ;%NWL%}  ,%NWL%floor : function (  )  {%NWL%return this . clone (  )  . _floor (  )  ;%NWL%}  ,%NWL%_floor : function (  )  {%NWL%this . x = Math . floor ( this . x )  ; %NWL%this . y = Math . floor ( this . y )  ; %NWL%9
Zotero . Group . prototype . loadObject = function ( ob )  {%NWL%var group = this ; %NWL%group . title = ob . title ; %NWL%group . author = ob . author ; %NWL%group . tagID = ob . tagID ; %NWL%group . published = ob . published ; %NWL%group . updated = ob . updated ; %NWL%group . links = ob . links ; %NWL%group . numItems = ob . numItems ; %NWL%group . items = ob . items ; %NWL%group . tagType = ob . tagType ; %NWL%2
}%NWL%}%NWL%}%NWL%return grownRect ;%NWL%}%NWL%function getCollapsedRectOfTextRange ( range , useRightEdge )  {%NWL%var clientRect = range . getBoundingClientRect (  )  ,%NWL%collapsedRect =  {  }  ; %NWL%collapsedRect . width = 0 ; %NWL%collapsedRect . top = clientRect . top ; %NWL%collapsedRect . bottom = clientRect . bottom ; %NWL%9
description +  =  '  < b > Downloads <  / b >  :  '  + downloads +  '  < br /  >  '  ; %NWL%return new model . Album ( identifier , null , title , album ,  '  '  , coverartthumb , coverartfull , $ . format . date ( new Date ( song . publicdate )  ,  " yyyy - MM - dd h : mm a "  )  , starred , $sce . trustAsHtml ( description )  , url )  ;%NWL%}  ; %NWL%var mapSong = function ( key , song , server , dir , identifier , coverart )  {%NWL%var url , time , track , title , rating , starred , contenttype , suffix ; %NWL%var specs =  '  '  ; %NWL%if ( song . format =  =  ' VBR MP3 '  )  {%NWL%url =  ' http :  /  /  '  + server + dir + key ; %NWL%if ( typeof song . bitrate =  =  ' undefined ' || typeof song . format =  =  ' undefined '  )  { specs =  ' &nbsp ;  '  ;  } else { specs = song . bitrate +  ' kbps ,  '  + song . format . toLowerCase (  )  ;  }%NWL%if ( typeof song . track =  =  ' undefined '  )  { track =  ' &nbsp ;  '  ;  } else { track = song . track ;  }%NWL%if ( typeof song . title =  =  ' undefined '  )  { title =  ' &nbsp ;  '  ;  } else { title = song . title ;  }%NWL%9
exports . EUCJPMS  = exports . EUCJPMS_JAPANESE_CI ; %NWL%exports . EUCKR  = exports . EUCKR_KOREAN_CI ; %NWL%exports . GB2312  = exports . GB2312_CHINESE_CI ; %NWL%exports . GBK   = exports . GBK_CHINESE_CI ; %NWL%exports . GEOSTD8  = exports . GEOSTD8_GENERAL_CI ; %NWL%exports . GREEK  = exports . GREEK_GENERAL_CI ; %NWL%exports . HEBREW  = exports . HEBREW_GENERAL_CI ; %NWL%exports . HP8   = exports . HP8_ENGLISH_CI ; %NWL%exports . KEYBCS2  = exports . KEYBCS2_GENERAL_CI ; %NWL%exports . KOI8R  = exports . KOI8R_GENERAL_CI ; %NWL%exports . KOI8U  = exports . KOI8U_GENERAL_CI ; %NWL%4
}%NWL%return result ;%NWL%}  ; %NWL%impress . health . cpuTimes = function (  )  {%NWL%var cpus = api . os . cpus (  )  ,%NWL%result =  { user : 0 , nice : 0 , sys : 0 , idle : 0 , irq : 0 }  ; %NWL%if ( typeof ( cpus )  =  =  =  ' object '  )  {%NWL%for ( var i = 0 ; i < cpus . length ; i +  +  )  {%NWL%result . user = cpus [ i ]  . times . user ; %NWL%result . nice = cpus [ i ]  . times . nice ; %NWL%result . sys  = cpus [ i ]  . times . sys ; %NWL%8
throw new Error (  " Unable to load SMD from "  + args )  ;%NWL%}  )  ;%NWL%} else if ( args . smdStr )  {%NWL%this . processSmd ( dojo . eval (  "  (  "  + args . smdStr +  "  )  "  )  )  ;%NWL%} else {%NWL%if ( args . serviceUrl )  {%NWL%this . serviceUrl = args . serviceUrl ;%NWL%}%NWL%this . timeout = args . timeout || 3000 ; %NWL%if (  " strictArgChecks " in args )  {%NWL%this . strictArgChecks = args . strictArgChecks ; %NWL%6
$scope . panel . targets . push ( clone )  ;%NWL%}  ; %NWL%function MetricSegment ( options )  {%NWL%if ( options =  =  =  '  *  ' || options . value =  =  =  '  *  '  )  {%NWL%this . value =  '  *  '  ; %NWL%this . html = $sce . trustAsHtml (  '  < i class =  " fa fa - asterisk "  >  < i >  '  )  ; %NWL%this . expandable = true ; %NWL%return ;%NWL%}%NWL%this . fake = options . fake ; %NWL%this . value = options . value ; %NWL%9
gDialog . orientation  = document . getElementById (  " orientation "  )  ; %NWL%gDialog . portrait   = document . getElementById (  " portrait "  )  ; %NWL%gDialog . landscape   = document . getElementById (  " landscape "  )  ; %NWL%gDialog . printBG   = document . getElementById (  " printBG "  )  ; %NWL%gDialog . shrinkToFit  = document . getElementById (  " shrinkToFit "  )  ; %NWL%gDialog . marginGroup  = document . getElementById (  " marginGroup "  )  ; %NWL%gDialog . marginPage   = document . getElementById (  " marginPage "  )  ; %NWL%gDialog . marginTop   = document . getElementById (  " marginTop "  )  ; %NWL%gDialog . marginBottom  = document . getElementById (  " marginBottom "  )  ; %NWL%gDialog . marginLeft   = document . getElementById (  " marginLeft "  )  ; %NWL%gDialog . marginRight  = document . getElementById (  " marginRight "  )  ; %NWL%0
)  ; %NWL%module . exports . toBadgekitBadge = function toBadgekitBadge ( badge )  {%NWL%var newBadge =  {  }  ; %NWL%newBadge . id = badge . slug ; %NWL%newBadge . description = badge . strapline ; %NWL%newBadge . name = badge . name ; %NWL%newBadge . status = badge . archived ? ' archived '  :  ' published '  ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%5
map . paper = Raphael ( map . object )%NWL%map . paper%NWL%. path ( mapVector )%NWL%. attr (  {%NWL%stroke :  " #333 "%NWL%,  ' stroke - width '  : 1 . 05%NWL%}  )%NWL%function Marker ( geo )  {%NWL%this . ip = geo . ip%NWL%this . latlon = geo . ll%NWL%this . date = geo . date%NWL%8
function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%4
Lang = YAHOO . lang ,%NWL%FLASH_CID =  " clsid : d27cdb6e - ae6d - 11cf - 96b8 - 444553540000 "  ,%NWL%FLASH_TYPE =  " application / x - shockwave - flash "  ,%NWL%FLASH_VER =  " 10 . 22 "  ,%NWL%EXPRESS_INSTALL_URL =  " http :  /  / fpdownload . macromedia . com / pub / flashplayer / update / current / swf / autoUpdater . swf? "  + Math . random (  )  ,%NWL%EVENT_HANDLER =  " YAHOO . widget . SWF . eventHandler "  ,%NWL%possibleAttributes =  { align :  "  "  , allowNetworking :  "  "  , allowScriptAccess :  "  "  , base :  "  "  , bgcolor :  "  "  , menu :  "  "  , name :  "  "  , quality :  "  "  , salign :  "  "  , scale :  "  "  , tabindex :  "  "  , wmode :  "  "  }  ; %NWL%YAHOO . widget . SWF = function ( p_oElement , swfURL , p_oAttributes  )  {%NWL%this . _queue = this . _queue || [  ]  ; %NWL%this . _events = this . _events || {  }  ; %NWL%this . _configs = this . _configs || {  }  ; %NWL%9
selectedObject . rotation [ 2 ]  = selectedObject . origins . rotation [ 2 ]  ;%NWL%}%NWL%else if ( mouseMoveMode =  =  =  ' y '  )  {%NWL%selectedObject . rotation [ 1 ]  = selectedObject . origins . rotation [ 1 ]  + diff [ 1 ]  * rotFactor ; %NWL%selectedObject . rotation [ 0 ]  = selectedObject . origins . rotation [ 0 ]  ; %NWL%selectedObject . rotation [ 2 ]  = selectedObject . origins . rotation [ 2 ]  ;%NWL%}%NWL%else if ( mouseMoveMode =  =  =  ' z '  )  {%NWL%selectedObject . rotation [ 2 ]  = selectedObject . origins . rotation [ 2 ]  + diff [ 0 ]  * rotFactor ; %NWL%selectedObject . rotation [ 0 ]  = selectedObject . origins . rotation [ 0 ]  ; %NWL%selectedObject . rotation [ 1 ]  = selectedObject . origins . rotation [ 1 ]  ; %NWL%0
t . path =  '  /  '  + r . path ;%NWL%} else {%NWL%t . path = base . path . replace (  /  [ ^\ /  ]  + $ /  ,  '  '  )  + r . path ;%NWL%}%NWL%t . path = removeDotSegments ( t . path )  ;%NWL%}%NWL%t . query = r . query ;%NWL%}%NWL%t . authority = base . authority ;%NWL%}%NWL%t . scheme = base . scheme ; %NWL%8
this . aceHelp = false ; %NWL%this . project = new ProjectHelper (  )  ; %NWL%var aceConfig =  " ace_config . json "  ; %NWL%this . aceInitFile = false ; %NWL%if ( !this . aceNeedsInit )  {%NWL%try {%NWL%this . aceInitFile = this . readFileAsString ( aceConfig )  ; %NWL%this . aceInitFileJSON = JSON . parse ( this . aceInitFile )  ; %NWL%this . isInit = true ; %NWL%this . identifiedComponents = this . aceInitFileJSON . identifiedComponents ; %NWL%this . name = this . aceInitFileJSON . name ; %NWL%9
this . itemIndex = Utils . valueOr ( template . itemIndex ,  - 1 )  ; %NWL%this . left = template . left || 0 ; %NWL%this . offsetLeft = template . offsetTop || 0 ; %NWL%this . offsetTop = template . offsetTop || 0 ; %NWL%this . outerHeight = template . outerHeight || 0 ; %NWL%this . outerWidth = template . outerWidth || 0 ; %NWL%this . paddingBottom = template . paddingBottom || 0 ; %NWL%this . paddingLeft = template . paddingLeft || 0 ; %NWL%this . paddingRight = template . paddingRight || 0 ; %NWL%this . paddingTop = template . paddingTop || 0 ; %NWL%this . right = template . right || 0 ; %NWL%1
function Attribute (  )  {%NWL%Y . AttributeCore . apply ( this , arguments )  ; %NWL%Y . AttributeObservable . apply ( this , arguments )  ; %NWL%Y . AttributeExtras . apply ( this , arguments )  ;%NWL%}%NWL%Y . mix ( Attribute , Y . AttributeCore , false , null , 1 )  ; %NWL%Y . mix ( Attribute , Y . AttributeExtras , false , null , 1 )  ; %NWL%Y . mix ( Attribute , Y . AttributeObservable , true , null , 1 )  ; %NWL%Attribute . INVALID_VALUE = Y . AttributeCore . INVALID_VALUE ; %NWL%Attribute . _ATTR_CFG = Y . AttributeCore . _ATTR_CFG . concat ( Y . AttributeObservable . _ATTR_CFG )  ; %NWL%Attribute . protectAttrs = Y . AttributeCore . protectAttrs ; %NWL%8
case '  / empty '  : %NWL%$log . info (  " Loading empty dashboard .  "  )  ; %NWL%$scope . dashboardOptions . defaultWidgets = emptyWidgets ; %NWL%break ; %NWL%default : %NWL%$log . info (  " Loading default dashboard .  "  )  ; %NWL%$scope . dashboardOptions . defaultWidgets = defaultWidgets ;%NWL%}%NWL%$scope . updateInterval = DashboardService . updateInterval ; %NWL%$scope . updateHost = DashboardService . updateHost ; %NWL%$scope . updateWindow = DashboardService . updateWindow ; %NWL%8
}%NWL%if ( !opts ) opts =  {  }%NWL%readDatJSON ( paths . package , function ( err , data )  {%NWL%if ( err ) return cb ( err )%NWL%data . adminUser = opts . adminUser || data . adminUser || process . env [  " DAT_ADMIN_USER "  ]%NWL%data . adminPass = opts . adminPass || data . adminPass || process . env [  " DAT_ADMIN_PASS "  ]%NWL%data . blobs = normalizeModule ( opts . blobs || data . blobs ,  ' content - addressable - blob - store '  )%NWL%data . replicator = normalizeModule ( opts . replicator || data . replicator ,  ' dat - replicator '  )%NWL%data . leveldown = normalizeModule ( opts . leveldown || data . leveldown ,  ' leveldown - prebuilt '  )%NWL%data . transformations = opts . transformations || data . transformations || {  }%NWL%data . hooks = opts . hooks || data . hooks || {  }%NWL%9
vec3 . lerp ( this . position , c1 . position , c2 . position , w )  ; %NWL%vec3 . lerp ( this . scale , c1 . scale , c2 . scale , w )  ; %NWL%quat . slerp ( this . rotation , c1 . rotation , c2 . rotation , w )  ;%NWL%}  ; %NWL%TransformClip . prototype . blend2D =  ( function (  )  {%NWL%var q1 = quat . create (  )  ; %NWL%var q2 = quat . create (  )  ; %NWL%return function ( c1 , c2 , c3 , f , g )  {%NWL%var a = 1 - f - g ; %NWL%this . position [ 0 ]  = c1 . position [ 0 ]  * a + c2 . position [ 0 ]  * f + c3 . position [ 0 ]  * g ; %NWL%this . position [ 1 ]  = c1 . position [ 1 ]  * a + c2 . position [ 1 ]  * f + c3 . position [ 1 ]  * g ; %NWL%9
_initNode = function ( setting , level , n , parentNode , isFirstNode , isLastNode , openFlag )  {%NWL%if ( !n ) return ; %NWL%var checkedKey = setting . data . key . checked ; %NWL%if ( typeof n [ checkedKey ]  =  =  " string "  ) n [ checkedKey ]  = tools . eqs ( n [ checkedKey ]  ,  " true "  )  ; %NWL%n [ checkedKey ]  = !!n [ checkedKey ]  ; %NWL%n . checkedOld = n [ checkedKey ]  ; %NWL%if ( typeof n . nocheck =  =  " string "  ) n . nocheck = tools . eqs ( n . nocheck ,  " true "  )  ; %NWL%n . nocheck = !!n . nocheck || ( setting . check . nocheckInherit && parentNode && !!parentNode . nocheck )  ; %NWL%if ( typeof n . chkDisabled =  =  " string "  ) n . chkDisabled = tools . eqs ( n . chkDisabled ,  " true "  )  ; %NWL%n . chkDisabled = !!n . chkDisabled || ( setting . check . chkDisabledInherit && parentNode && !!parentNode . chkDisabled )  ; %NWL%if ( typeof n . halfCheck =  =  " string "  ) n . halfCheck = tools . eqs ( n . halfCheck ,  " true "  )  ; %NWL%6
if ( u && !fn . isOptional )  {%NWL%let tLocation = location ? ` in $ { t ( location )  } ` :  '  '  ; %NWL%const type = getCheckerDisplay ( fn ,  { short : true }  )  ; %NWL%const stringType = typeof type ! =  =  ' object ' ? type : JSON . stringify ( type )  ; %NWL%return new Error ( `Required $ { t ( name )  } not specified$ { tLocation }  . Must be $ { t ( stringType )  } ` )  ;%NWL%} else {%NWL%return fn ( val , name , location , obj )  ;%NWL%}%NWL%}%NWL%specifiedChecker . type = fn . type ; %NWL%specifiedChecker . shortType = fn . shortType ; %NWL%9
return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%3
t . drawn = true ;%NWL%}%NWL%Doek . Rectangle . prototype . _idrawRectangle = function (  )  {%NWL%var t = this . _idrawn [ this . activeStyle . name ]  ; %NWL%t . element = document . createElement (  ' canvas '  )  ; %NWL%t . ctx = t . element . getContext (  ' 2d '  )  ; %NWL%t . element . setAttribute (  ' width '  , this . width )  ; %NWL%t . element . setAttribute (  ' height '  , this . height )  ; %NWL%var ctx = t . ctx ; %NWL%ctx . lineWidth = this . activeStyle . properties . lineWidth ; %NWL%ctx . strokeStyle = this . activeStyle . properties . strokeStyle ; %NWL%9
var util = require (  ' util '  )  ; %NWL%var _ = require (  ' underscore '  )  ; %NWL%_ . str = require (  ' underscore . string '  )  ; %NWL%var $$ = require (  '  .  / const '  )  ; %NWL%var Action = module . exports = function Action ( options )  {%NWL%options = options || {  }  ; %NWL%this . optionStrings = options . optionStrings || [  ]  ; %NWL%this . dest = options . dest ; %NWL%this . nargs = options . nargs ! =  = undefined ? options . nargs : null ; %NWL%this . constant = options . constant ! =  = undefined ? options . constant : null ; %NWL%this . defaultValue = options . defaultValue ; %NWL%7
client . setRequestHeader (  " Content - Type "  ,  " text / plain "  )  ; %NWL%client . send (  )  ; %NWL%request = mockAjax . requests . mostRecent (  )  ; %NWL%response =  { status : 0 , statusText :  " ABORT "  , responseText :  '  {  " foo "  :  " whoops! "  }  '  }  ; %NWL%request . respondWith ( response )  ; %NWL%sharedContext . responseCallback = error ; %NWL%sharedContext . status = 0 ; %NWL%sharedContext . statusText = response . statusText ; %NWL%sharedContext . contentType =  ' application / json '  ; %NWL%sharedContext . responseText = response . responseText ; %NWL%sharedContext . responseType = response . responseType ; %NWL%7
return result ;%NWL%}  ; %NWL%inputElementValues = function ( anInputElement )  {%NWL%var	result ; %NWL%if (  ( anInputElement . tagName . toLowerCase (  )  =  =  " input "  ) && ( anInputElement . getAttribute (  ' name '  ) ! = null )  )  {%NWL%result =  {  }  ; %NWL%result . type = anInputElement . getAttribute (  ' type '  ) || " text "  ; %NWL%result . name = anInputElement . getAttribute (  ' name '  )  ; %NWL%result . value = anInputElement . value ; %NWL%if ( anInputElement . type . toLowerCase (  )  =  =  ' radio '  )  {%NWL%result . checked = anInputElement . checked ; %NWL%8
}  ; %NWL%function _parseSettings ( settings )%NWL%{%NWL%if ( settings . minTime )  {%NWL%settings . minTime = _time2int ( settings . minTime )  ;%NWL%}%NWL%if ( settings . maxTime )  {%NWL%settings . maxTime = _time2int ( settings . maxTime )  ;%NWL%}%NWL%if ( settings . durationTime && typeof settings . durationTime ! =  =  ' function '  )  {%NWL%settings . durationTime = _time2int ( settings . durationTime )  ; %NWL%4
exports . assert = require . resolve (  ' assert /  '  )  ; %NWL%exports . buffer = require . resolve (  ' buffer /  '  )  ; %NWL%exports . child_process = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . cluster = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . console = require . resolve (  ' console - browserify '  )  ; %NWL%exports . constants = require . resolve (  ' constants - browserify '  )  ; %NWL%exports . crypto = require . resolve (  ' crypto - browserify '  )  ; %NWL%exports . dgram = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . dns = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . domain = require . resolve (  ' domain - browser '  )  ; %NWL%exports . events = require . resolve (  ' events /  '  )  ; %NWL%0
}%NWL%}  ; %NWL%If . prototype . __proto__ = Node . prototype ; %NWL%If . prototype . clone = function (  )  {%NWL%var cond = this . cond . clone (  )%NWL%, block = this . block . clone (  )  ; %NWL%var clone = new If ( cond , block )  ; %NWL%clone . elses = this . elses . map ( function ( node )  { return node . clone (  )  ;  }  )  ; %NWL%clone . negate = this . negate ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%8
dataCharset :  ' UTF - 8 '  ,%NWL%parse : function (  )  {%NWL%var result =  {  }  ; %NWL%if ( window . google && google . loader && google . loader . ClientLocation )  {%NWL%if ( google . loader . ClientLocation . address )  {%NWL%if ( google . loader . ClientLocation . address . country_code )%NWL%result . countryCode = google . loader . ClientLocation . address . country_code ; %NWL%if ( google . loader . ClientLocation . address . country && google . loader . ClientLocation . address . country ! =  '  -  ' && google . loader . ClientLocation . address . country ! =  ' NaN '  )%NWL%result . country = google . loader . ClientLocation . address . country ; %NWL%if ( google . loader . ClientLocation . address . city && google . loader . ClientLocation . address . city ! =  '  -  ' && google . loader . ClientLocation . address . city ! =  ' NaN '  )%NWL%result . city = google . loader . ClientLocation . address . city ; %NWL%8
var _server_options =  { poolSize : 1 , socketOptions :  { connectTimeoutMS : 1000 }  , auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%_server_options . sslPass = object . rs_options . sslPass ;%NWL%} else if ( object . server_options . ssl )  {%NWL%_server_options . ssl = object . server_options . ssl ; %NWL%_server_options . sslValidate = object . server_options . sslValidate ; %NWL%9
[  ' mute '  ,  ' hangup '  ,  ' connect '  ]  . forEach ( function ( eventName )  {%NWL%that . call . listen ( eventName , function ( evt )  {%NWL%evt . call = that . call ;  /  / target will be updated to point to this conference object .%NWL%that . fire ( eventName , evt )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%delete that . instanceId ; %NWL%that . className =  ' respoke . Conference '  ; %NWL%var client = respoke . getClient ( instanceId )  ; %NWL%that . hangup = that . call . hangup ; %NWL%that . muteAudio = that . call . muteAudio ; %NWL%9
}%NWL%}%NWL%var idValue = valueValue [  ' id '  ]  ; %NWL%if ( idValue ! =  = null && idValue ! =  = undefined )  {%NWL%var idInstance = idValue ; %NWL%featureResponseInstance . id = idInstance ;%NWL%}%NWL%var typeValue = valueValue [  ' type '  ]  ; %NWL%if ( typeValue ! =  = null && typeValue ! =  = undefined )  {%NWL%var typeInstance = typeValue ; %NWL%featureResponseInstance . type = typeInstance ; %NWL%5
throw new Error (  ' Invalid remote method : ` '  + getterName +  ' ` '  )  ;%NWL%}%NWL%var nestedFn = relation . modelTo . prototype [ method . name ]  ; %NWL%if ( typeof nestedFn ! =  =  ' function '  )  {%NWL%throw new Error (  ' Invalid remote method : ` '  + method . name +  ' ` '  )  ;%NWL%}%NWL%var opts =  {  }  ; %NWL%opts . accepts = acceptArgs . concat ( method . accepts || [  ]  )  ; %NWL%opts . returns =  [  ]  . concat ( method . returns || [  ]  )  ; %NWL%opts . description = method . description ; %NWL%opts . accessType = method . accessType ; %NWL%9
result . y = pixelHeight ; %NWL%return result ;%NWL%}  ; %NWL%PerspectiveOffCenterFrustum . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new PerspectiveOffCenterFrustum (  )  ;%NWL%}%NWL%result . right = this . right ; %NWL%result . left = this . left ; %NWL%result . top = this . top ; %NWL%result . bottom = this . bottom ; %NWL%7
this . angularAcceleration = other . angularAcceleration ; %NWL%this . angularAccelerationSpread = other . angularAccelerationSpread ; %NWL%this . randomAngle = other . randomAngle ; %NWL%this . emissionRate = other . emissionRate ; %NWL%this . color . copy ( other . color )  ; %NWL%this . colorSpread . copy ( other . colorSpread )  ; %NWL%this . time = other . time ; %NWL%this . _time = other . _time ; %NWL%this . duration = other . duration ; %NWL%this . loop = other . loop ; %NWL%this . playing = other . playing ; %NWL%0
redisExec ( callback )  ;%NWL%}%NWL%}  )  ;%NWL%} else {%NWL%redisExec ( callback )  ;%NWL%}%NWL%}  ; %NWL%exports . __link = function __link ( obj , options , cb )  {%NWL%this . __linkProxied (  ' sadd '  , obj , options , cb )  ;%NWL%}  ; %NWL%exports . __unlink = function __unlink ( obj , options , cb )  {%NWL%7
return new InjectedScript . RemoteObject ( objectId , type , description , hasChildren )  ;%NWL%} catch ( e )  {%NWL%return InjectedScript . RemoteObject . fromException ( e )  ;%NWL%}%NWL%}%NWL%InjectedScript . CallFrameProxy = function ( ordinal , callFrame )%NWL%{%NWL%this . id =  { ordinal : ordinal , injectedScriptId : injectedScriptId }  ; %NWL%this . type = callFrame . type ; %NWL%this . functionName =  ( this . type =  =  =  " function " ? callFrame . functionName :  "  "  )  ; %NWL%this . sourceID = callFrame . sourceID ; %NWL%8
this . elem . removeClass (  )  . addClass (  ' platform '  )  ; %NWL%this . dead = false ; %NWL%var platformArray = level > 0 ? Constants . PLATFORMS_TALL : %NWL%Constants . PLATFORMS_SHORT ; %NWL%var index = opt_woodsy ? platformArray . length - 1 : %NWL%Math . floor ( Math . random (  )  *  ( platformArray . length - 1 )  )  ; %NWL%var type = platformArray [ index ]  ; %NWL%this . elem . addClass ( type . css )  ; %NWL%this . x = startX ; %NWL%this . width = type . width ; %NWL%this . height = type . height ; %NWL%9
var index = 1 ; %NWL%var opts =  {%NWL%statusCode : code%NWL%}  ; %NWL%if ( cause && cause instanceof Error )  {%NWL%opts . cause = cause ; %NWL%opts . constructorOpt = arguments . callee ;%NWL%} else if ( typeof ( cause )  =  =  =  ' object '  )  {%NWL%opts . body = cause . body ; %NWL%opts . cause = cause . cause ; %NWL%opts . constructorOpt = cause . constructorOpt ; %NWL%8
return t =  =  = Object ( t ) ? t :  { down : t , up : t }  ;%NWL%}%NWL%function Headroom ( elem , options )  {%NWL%options = extend ( options , Headroom . options )  ; %NWL%this . lastKnownScrollY = 0 ; %NWL%this . elem    = elem ; %NWL%this . debouncer   = new Debouncer ( this . update . bind ( this )  )  ; %NWL%this . tolerance   = normalizeTolerance ( options . tolerance )  ; %NWL%this . classes    = options . classes ; %NWL%this . offset    = options . offset ; %NWL%this . scroller   = options . scroller ; %NWL%8
autoDelete : true ,%NWL%enableDelete : true ,%NWL%enableHold : true ,%NWL%formatters : null ,%NWL%_templateLoadCount : 0 ,%NWL%_mouseDownPos : null ,%NWL%baseClass :  " list "  ,%NWL%constructor : function (  )  {%NWL%this . _checkLoadComplete = dojo . hitch ( this , this . _checkLoadComplete )  ; %NWL%this . _replaceToken = dojo . hitch ( this , this . _replaceToken )  ; %NWL%this . _postDeleteAnim = dojo . hitch ( this , this . _postDeleteAnim )  ; %NWL%8
set_display_mode : function ( mode )  {%NWL%if ( this . display_mode ! =  = mode )  {%NWL%this . display_mode = mode ; %NWL%this . renderElement (  )  ;%NWL%}%NWL%}  ,%NWL%}  )  ; %NWL%module . Orderline = Backbone . Model . extend (  {%NWL%initialize : function ( attr , options )  {%NWL%this . pos = options . pos ; %NWL%this . order = options . order ; %NWL%9
this . range  = this . options . range || $R ( 0 , 1 )  ; %NWL%this . value  = 0 ;  /  / assure backwards compat%NWL%this . values  = this . handles . map ( function (  )  { return 0 }  )  ; %NWL%this . spans  = this . options . spans ? this . options . spans . map ( function ( s )  { return $ ( s )  }  )  : false ; %NWL%this . options . startSpan = $ ( this . options . startSpan || null )  ; %NWL%this . options . endSpan  = $ ( this . options . endSpan || null )  ; %NWL%this . restricted = this . options . restricted || false ; %NWL%this . maximum  = this . options . maximum || this . range . end ; %NWL%this . minimum  = this . options . minimum || this . range . start ; %NWL%this . alignX = parseInt ( this . options . alignX || ' 0 '  )  ; %NWL%this . alignY = parseInt ( this . options . alignY || ' 0 '  )  ; %NWL%9
var pageQuery =  " commits = 0&page = 1&pageSize = 100 "  ;  /  / $NON - NLS - 0$%NWL%function GitBranchListModel ( options )  {%NWL%this . root = options . root ; %NWL%this . showHistory = options . showHistory =  =  = undefined || options . showHistory ; %NWL%this . showTags = options . showTags =  =  = undefined || options . showTags ; %NWL%this . showStashes = options . showStashes =  =  = undefined || options . showStashes ; %NWL%this . registry = options . registry ; %NWL%this . handleError = options . handleError ; %NWL%this . section = options . section ; %NWL%this . progressService = options . progressService ; %NWL%this . parentId = options . parentId ; %NWL%2
wink . setInterval = function ( context , method , delay )%NWL%{%NWL%var args = slice . call ( arguments , 3 )  ; %NWL%var toExecute = function (  )%NWL%{%NWL%context [ method ]  . apply ( context , args )  ;%NWL%}  ; %NWL%return setInterval ( toExecute , delay )  ;%NWL%}  ; %NWL%wink . isString = dojo . isString ; %NWL%wink . isFunction = dojo . isFunction ; %NWL%9
treeChartChannels . texts = svg . append (  ' g '  )%NWL%. attr (  ' class '  ,  ' text - group '  )  ;%NWL%}  ; %NWL%var resize = function ( width )  {%NWL%elemCurrentWidth = width ; %NWL%var height = parseInt ( width / aspectRatio )  ; %NWL%svg%NWL%. attr (  ' height '  , height )%NWL%. attr (  ' width '  , width )  ; %NWL%treeChartSize . height = height - 2 * treeChartSize . margin ; %NWL%treeChartSize . width = width - 2 * treeChartSize . margin ; %NWL%9
conf =  {%NWL%on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%e . pageX = data . pageX ; %NWL%8
User . prototype . scrapeFrom = function ( controller )  {%NWL%this . username = controller . getParam (  " username "  , this . username )  ; %NWL%this . password = controller . getParam (  " password "  ,  "  "  )  ; %NWL%this . name = controller . getParam (  " name "  , this . name )  ; %NWL%this . domain = controller . getParam (  " domain "  , this . domain )  ; %NWL%this . level = controller . getInt (  " level "  , this . level )  ; %NWL%this . email = controller . getParam (  " email "  , this . email )  ; %NWL%this . note = controller . getParam (  " note "  , this . note )  ; %NWL%this . nomail = controller . getParam (  " nomail "  , this . nomail )  ; %NWL%this . badlogins = controller . getParam (  " badlogins "  , this . badlogins )  ; %NWL%this . maxbadlogins = controller . getParam (  " maxbadlogins "  , this . maxbadlogins )  ; %NWL%1
o . opacity = args . opacity . to ; %NWL%if ( args . opacity . from )%NWL%e . setOpacity ( args . opacity . from )  ; %NWL%break ; %NWL%case ' left '  : %NWL%o . left = args . left . to ; %NWL%if ( args . left . from )%NWL%e . setLeft ( args . left . from )  ; %NWL%break ; %NWL%case ' top '  : %NWL%o . top = args . top . to ; %NWL%0
arr . readInt32LE = BP . readInt32LE%NWL%arr . readInt32BE = BP . readInt32BE%NWL%arr . readFloatLE = BP . readFloatLE%NWL%arr . readFloatBE = BP . readFloatBE%NWL%arr . readDoubleLE = BP . readDoubleLE%NWL%arr . readDoubleBE = BP . readDoubleBE%NWL%arr . writeUInt8 = BP . writeUInt8%NWL%arr . writeUInt16LE = BP . writeUInt16LE%NWL%arr . writeUInt16BE = BP . writeUInt16BE%NWL%arr . writeUInt32LE = BP . writeUInt32LE%NWL%arr . writeUInt32BE = BP . writeUInt32BE%NWL%0
}%NWL%if ( !PIXI . defaultRenderer )%NWL%{%NWL%PIXI . sayHello (  ' webGL '  )  ; %NWL%PIXI . defaultRenderer = this ;%NWL%}%NWL%this . type = PIXI . WEBGL_RENDERER ; %NWL%this . resolution = options . resolution ; %NWL%this . transparent = options . transparent ; %NWL%this . autoResize = options . autoResize || false ; %NWL%this . preserveDrawingBuffer = options . preserveDrawingBuffer ; %NWL%7
__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%window . UserDatabase =  ( function ( _super )  {%NWL%__extends ( UserDatabase , _super )  ; %NWL%function UserDatabase (  )  {%NWL%this . onDBChange = __bind ( this . onDBChange , this )  ; %NWL%this . clear = __bind ( this . clear , this )  ; %NWL%this . runQuery = __bind ( this . runQuery , this )  ; %NWL%this . fromJSONArray = __bind ( this . fromJSONArray , this )  ; %NWL%this . toString = __bind ( this . toString , this )  ; %NWL%this . initLocalStorage = __bind ( this . initLocalStorage , this )  ; %NWL%5
this . fullscreen ( !this . isFullScreen (  )  )  ;%NWL%}  ; %NWL%minplayer . display . prototype . isFullScreen = function (  )  {%NWL%return this . fullScreenElement (  )  . hasClass (  ' fullscreen '  )  ;%NWL%}  ; %NWL%minplayer . display . prototype . getScaledRect = function ( ratio , rect )  {%NWL%var scaledRect =  {  }  ; %NWL%scaledRect . x = rect . x ? rect . x : 0 ; %NWL%scaledRect . y = rect . y ? rect . y : 0 ; %NWL%scaledRect . width = rect . width ? rect . width : 0 ; %NWL%scaledRect . height = rect . height ? rect . height : 0 ; %NWL%7
key = ka [ i ]  ; %NWL%if ( !_deepEqual ( a [ key ]  , b [ key ]  )  ) return false ;%NWL%}%NWL%return true ;%NWL%}%NWL%assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%5
this . _leftCamera . alpha = this . alpha - this . _eyeSpace ; %NWL%this . _rightCamera . alpha = this . alpha + this . _eyeSpace ; %NWL%_super . prototype . _update . call ( this )  ;%NWL%}  ; %NWL%AnaglyphArcRotateCamera . prototype . _updateCamera = function ( camera )  {%NWL%camera . beta = this . beta ; %NWL%camera . radius = this . radius ; %NWL%camera . minZ = this . minZ ; %NWL%camera . maxZ = this . maxZ ; %NWL%camera . fov = this . fov ; %NWL%camera . target = this . target ; %NWL%5
JSJaCHttpBindingConnection . prototype = new JSJaCConnection (  )  ; %NWL%JSJaCHttpBindingConnection . prototype . inherit = function ( oArg )  {%NWL%if ( oArg . jid )  {%NWL%var oJid = new JSJaCJID ( oArg . jid )  ; %NWL%this . domain = oJid . getDomain (  )  ; %NWL%this . username = oJid . getNode (  )  ; %NWL%this . resource = oJid . getResource (  )  ;%NWL%} else {%NWL%this . domain = oArg . domain || ' localhost '  ; %NWL%this . username = oArg . username ; %NWL%this . resource = oArg . resource ; %NWL%9
this . _rotationTween . OnComplete . Bind ( tweenReverse )  ; %NWL%this . _opacityTween . OnComplete . Bind ( tweenReverse )  ; %NWL%this . _colorTween . OnComplete . Bind ( tweenReverse )  ; %NWL%this . _positionTween . OnChange . Bind ( function ( newPosition )  {%NWL%target . Position = newPosition ;%NWL%}  )  ; %NWL%this . _sizeTween . OnChange . Bind ( function ( newSize )  {%NWL%target . Size = newSize ;%NWL%}  )  ; %NWL%this . _rotationTween . OnChange . Bind ( function ( newRotation )  {%NWL%target . Rotation = newRotation ; %NWL%4
if ( args . points . from )  {%NWL%e . setXY ( args . points . from )  ;%NWL%}%NWL%break ; %NWL%case ' width '  : %NWL%o . width = args . width . to ; %NWL%if ( args . width . from )%NWL%e . setWidth ( args . width . from )  ; %NWL%break ; %NWL%case ' height '  : %NWL%o . height = args . height . to ; %NWL%5
}%NWL%$scope . blogClick = function ( blog )  {%NWL%var ref = window . open ( blog ,  ' _system '  )  ;%NWL%}%NWL%if ( user . location )  {%NWL%$scope . hideLocation = false ; %NWL%$scope . location = user . location ;%NWL%} else {%NWL%$scope . hideLocation = true ;%NWL%}%NWL%$scope . name = user . name ; %NWL%6
exports . createMenu = function createMenu (  )  {%NWL%}  ; %NWL%exports . createMenuItem = function createMenuItem (  )  {%NWL%}  ; %NWL%exports . createSeperatorMenuItem = function createSeperatorMenuItem (  )  {%NWL%}  ; %NWL%exports . createCheckMenuItem = function createCheckMenuItem (  )  {%NWL%}  ; %NWL%exports . setBadge = function setBadge (  )  {%NWL%}  ; %NWL%exports . setBadgeImage = function setBadgeImage (  )  {%NWL%0
var bb    = this . get ( BOUNDING_BOX )  ,%NWL%maskNode  = this . get (  ' maskNode '  )  ,%NWL%focusOn  = this . get (  ' focusOn '  )  ,%NWL%focus   = Y . bind ( this . _focus , this )  ,%NWL%uiHandles  =  [  ]  ,%NWL%i , len , o ; %NWL%for ( i = 0 , len = focusOn . length ; i < len ; i +  +  )  {%NWL%o =  {  }  ; %NWL%o . node = focusOn [ i ]  . node ; %NWL%o . ev = focusOn [ i ]  . eventName ; %NWL%o . keyCode = focusOn [ i ]  . keyCode ; %NWL%8
delay : 5 ,%NWL%changeVisibilityDelay : 5 ,%NWL%aggressive : false ,%NWL%changeVisibility : false ,%NWL%value : null ,%NWL%inverse : false ,%NWL%constructor : function ( config )  {%NWL%if ( config . layer )  {%NWL%this . layer = this . getLayer ( config . layer )  ; %NWL%this . bindMap (  )  ; %NWL%this . complementaryLayer = this . getLayer ( config . complementaryLayer )  ; %NWL%8
if ( u && u . hostname ) return ' http :  /  / api . tumblr . com / v2 / blog /  '  + u . hostname +  '  / avatar / 512 '  ; %NWL%return undefined ;%NWL%}  ,%NWL%id :  ' name '  ,%NWL%at : function ( data )  {%NWL%return data . updated * 1000 ;%NWL%}  ,%NWL%oembed : function ( data )  {%NWL%var ret =  { type :  ' contact '  }  ; %NWL%ret . url = data . url ; %NWL%ret . title = data . title ; %NWL%9
this . onafterevent  = function ( event , from , to )  { this . called . push (  ' onafter (  '  + event +  '  )  '  )  ;     }  ,%NWL%this . onleavestate  = function ( event , from , to )  { this . called . push (  ' onleave (  '  + from  +  '  )  '  )  ;     }  ,%NWL%this . onenterstate  = function ( event , from , to )  { this . called . push (  ' onenter (  '  + to  +  '  )  '  )  ;     }  ,%NWL%this . onchangestate  = function ( event , from , to )  { this . called . push (  ' onchange (  '  + from +  '  ,  '  + to +  '  )  '  )  ;  }  ; %NWL%this . onbeforeinit  = function (  )     { this . called . push (  " onbeforeinit "  )  ;       }  ; %NWL%this . onafterinit  = function (  )     { this . called . push (  " onafterinit "  )  ;        }  ; %NWL%this . onbeforestartup = function (  )     { this . called . push (  " onbeforestartup "  )  ;       }  ; %NWL%this . onafterstartup  = function (  )     { this . called . push (  " onafterstartup "  )  ;       }  ; %NWL%this . onbeforepanic  = function (  )     { this . called . push (  " onbeforepanic "  )  ;       }  ; %NWL%this . onafterpanic  = function (  )     { this . called . push (  " onafterpanic "  )  ;       }  ; %NWL%this . onbeforecalm  = function (  )     { this . called . push (  " onbeforecalm "  )  ;       }  ; %NWL%4
}  ; %NWL%Field . prototype . addToTotalRow = function (  )  {%NWL%this . totalRowFun =  ' sum '  ; %NWL%return this ;%NWL%}  ; %NWL%Field . prototype . required = function ( isRequired )  {%NWL%this . isRequired = _ . isUndefined ( isRequired ) ? true : isRequired ; %NWL%return this ;%NWL%}  ; %NWL%Field . prototype . readOnly = function ( isReadOnly )  {%NWL%this . isReadOnly = _ . isUndefined ( isReadOnly ) ? true : isReadOnly ; %NWL%6
}  ; %NWL%quat . conjugate = function ( out , a )  {%NWL%out [ 0 ]  =  - a [ 0 ]  ; %NWL%out [ 1 ]  =  - a [ 1 ]  ; %NWL%out [ 2 ]  =  - a [ 2 ]  ; %NWL%out [ 3 ]  = a [ 3 ]  ; %NWL%return out ;%NWL%}  ; %NWL%quat . length = vec4 . length ; %NWL%quat . len = quat . length ; %NWL%quat . squaredLength = vec4 . squaredLength ; %NWL%8
var components = require (  ' ungit - components '  )  ; %NWL%components . register (  ' textdiff '  , function ( args )  {%NWL%return new TextDiffViewModel ( args )  ;%NWL%}  )  ; %NWL%var TextDiffViewModel = function ( args )  {%NWL%var self = this ; %NWL%this . filename = args . filename ; %NWL%this . repoPath = args . repoPath ; %NWL%this . server = args . server ; %NWL%this . diffs = ko . observable (  )  ; %NWL%this . sha1 = args . sha1 ; %NWL%6
var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%5
this . sizeTween . copy ( other . sizeTween )  ; %NWL%this . alphaTween . copy ( other . alphaTween )  ; %NWL%this . colorTween . copy ( other . colorTween )  ; %NWL%this . velocity . copy ( other . velocity )  ; %NWL%this . velocitySpread . copy ( other . velocitySpread )  ; %NWL%this . acceleration . copy ( other . acceleration )  ; %NWL%this . accelerationSpread . copy ( other . accelerationSpread )  ; %NWL%this . angularVelocity = other . angularVelocity ; %NWL%this . angularVelocitySpread = other . angularVelocitySpread ; %NWL%this . angularAcceleration = other . angularAcceleration ; %NWL%this . angularAccelerationSpread = other . angularAccelerationSpread ; %NWL%7
}%NWL%this . car = this . c . entities . create ( Car ,  {%NWL%center :  { x : this . size . x * 0 . 95 , y : this . size . y / 2 - 15 }%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%function Checkpoint ( game , options )  {%NWL%this . game = game ; %NWL%this . center = options . center ; %NWL%this . size = options . size ; %NWL%this . angle = options . angle ; %NWL%8
this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%8
" use strict "  ; %NWL%exports . addMethod = require (  "  .  / addMethod "  )  ; %NWL%exports . extend = require (  "  .  / extend "  )  ; %NWL%exports . inRange = require (  "  .  / inRange "  )  ; %NWL%exports . defaults = require (  "  .  / defaults "  )  ; %NWL%exports . rgb2num = require (  "  .  / rgb2num "  )  ; %NWL%exports . slice = require (  "  .  / slice "  )  ; %NWL%exports . colorize = require (  "  .  / colorize "  )  ; %NWL%exports . inCanvas = require (  "  .  / inCanvas "  )  ; %NWL%exports . inClip = require (  "  .  / inClip "  )  ; %NWL%exports . putPixel = require (  "  .  / putPixel "  )  ; %NWL%1
var settings =  {%NWL%' firebase '  : firebase ,%NWL%' public '  : defaultSettings . public ,%NWL%' ignore '  : defaultSettings . ignore%NWL%}  ; %NWL%if ( supportedTemplates [ results . template ]  . settings )  {%NWL%if ( supportedTemplates [ results . template ]  . settings . public )  {%NWL%settings . public = supportedTemplates [ results . template ]  . settings . public ;%NWL%}%NWL%if ( supportedTemplates [ results . template ]  . settings . rules )  {%NWL%settings . rules = supportedTemplates [ results . template ]  . settings . rules ; %NWL%7
if ( tlength =  =  = 1 )  {%NWL%endTouch . x = event . targetTouches [ 0 ]  . pageX ; %NWL%endTouch . y = event . targetTouches [ 0 ]  . pageY ; %NWL%aniProps [ animCss ]  = startTouch [ animCss ]  +  ( endTouch [ axisPrimary ]  - startTouch [ axisPrimary ]  )  ; %NWL%ul . css ( aniProps )  ; %NWL%if ( o . preventTouchWindowScroll )  {%NWL%event . preventDefault (  )  ;%NWL%}%NWL%} else {%NWL%endTouch . x = startTouch . x ; %NWL%endTouch . y = startTouch . y ; %NWL%9
( function (  )  {%NWL%' use strict '  ; %NWL%Ghost . Models . Post = Ghost . ProgressModel . extend (  {%NWL%defaults :  {%NWL%status :  ' draft '%NWL%}  ,%NWL%blacklist :  [  ' published '  ,  ' draft '  ]  ,%NWL%parse : function ( resp )  {%NWL%if ( resp . status )  {%NWL%resp . published = resp . status =  =  =  ' published '  ; %NWL%resp . draft = resp . status =  =  =  ' draft '  ; %NWL%9
_webviewObj . active = true ; %NWL%_webviewObj . zOrder = 0 ; %NWL%_webviewObj . setGeometry ( 0 , CHROME_HEIGHT , screen . width , screen . height - CHROME_HEIGHT )  ; %NWL%if ( typeof config . backgroundColor ! =  =  ' undefined '  )  {%NWL%_webviewObj . backgroundColor = config . backgroundColor ;%NWL%}%NWL%if ( typeof config . customHeaders ! =  =  ' undefined '  )  {%NWL%_webviewObj . extraHttpHeaders = config . customHeaders ;%NWL%}%NWL%if ( typeof config . userAgent ! =  =  ' undefined '  )  {%NWL%_webviewObj . userAgent = config . userAgent ; %NWL%4
this . drawEdge ( ctx , dx , dy )  ; %NWL%this . drawEndPointsOfPath ( ctx , dx , dy )  ;%NWL%}%NWL%self . prototype . setupContext = function ( ctx )  {%NWL%ctx . lineWidth = this . lineWidth ; %NWL%ctx . lineCap = this . lineCap ; %NWL%ctx . lineJoin = this . lineJoin ; %NWL%ctx . miterLimit = this . miterLimit ; %NWL%ctx . fillStyle = this . fillColor . getColor (  )  ;   /  / no gradation support yet%NWL%ctx . strokeStyle = this . strokeColor . getColor (  )  ;  /  / no gradation support yet%NWL%ctx . shadowColor = this . shadowColor ; %NWL%4
sm . removeArchive = removeArchive ; %NWL%sm . reload = reloadSound ;%NWL%}%NWL%sm . reloadAll = function reloadAllSoundsFn (  )  {%NWL%for ( var t in sounds )  {%NWL%if ( sounds . hasOwnProperty ( t ) && t ! =  = defaultSoundName )  {%NWL%reloadSound ( t )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%sm . getAll = function getAllSoundsFn (  )  {%NWL%3
var childCompiler = new Compiler (  )  ; %NWL%for ( var name in this . _plugins )  {%NWL%if (  [  " make "  ,  " compile "  ,  " emit "  ,  " after - emit "  ,  " invalid "  ,  " done "  ,  " this - compilation "  ]  . indexOf ( name )  < 0 )%NWL%childCompiler . _plugins [ name ]  = this . _plugins [ name ]  . slice (  )  ;%NWL%}%NWL%childCompiler . name = compilerName ; %NWL%childCompiler . outputPath = this . outputPath ; %NWL%childCompiler . inputFileSystem = this . inputFileSystem ; %NWL%childCompiler . outputFileSystem = null ; %NWL%childCompiler . resolvers = this . resolvers ; %NWL%childCompiler . parser = this . parser ; %NWL%6
gSite . folder    = $ (  ' folder '  )  . value ; %NWL%gSite . host    = $ (  ' host '  )  . value . trim (  )  ; %NWL%gSite . port    = $ (  ' port '  )  . value ; %NWL%gSite . login    = $ (  ' login '  )  . value . trim (  )  ; %NWL%gSite . password   = $ (  ' password '  )  . value ; %NWL%gSite . anonymous   = $ (  ' anonymous '  )  . checked ; %NWL%gSite . protocol   = $ (  ' security '  )  . value =  =  ' sftp ' ? ' ssh2 '  :  ' ftp '  ; %NWL%gSite . security   = $ (  ' security '  )  . value ; %NWL%gSite . pasvmode   = $ (  ' pasvmode '  )  . checked ; %NWL%gSite . ipmode    = $ (  ' ipmode '  )  . checked ; %NWL%gSite . webhost    = $ (  ' webhost '  )  . value . trim (  )  ; %NWL%1
fill = gfx . makeParameters ( gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeX "  )  {%NWL%var span = dim . height - offsets . t - offsets . b ; %NWL%fill . y1 = offsets . t + span * fill . y1 / 100 ; %NWL%fill . y2 = offsets . t + span * fill . y2 / 100 ;%NWL%}%NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeY "  )  {%NWL%var span = dim . width - offsets . l - offsets . r ; %NWL%fill . x1 = offsets . l + span * fill . x1 / 100 ; %NWL%fill . x2 = offsets . l + span * fill . x2 / 100 ; %NWL%9
return this ;%NWL%}  ; %NWL%this . useDebug . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useDebug "  ; %NWL%this . usePrefix = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . prefix ;%NWL%}%NWL%options . prefix = value ; %NWL%return this ;%NWL%}  ; %NWL%this . usePrefix . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . usePrefix "  ; %NWL%2
options = options || {  }  ; %NWL%var self = this ,%NWL%handleExceptions = false ; %NWL%this . padLevels = options . padLevels || false ; %NWL%this . setLevels ( options . levels )  ; %NWL%if ( options . colors )  {%NWL%config . addColors ( options . colors )  ;%NWL%}%NWL%this . level   = options . level || ' info '  ; %NWL%this . emitErrs  = options . emitErrs || false ; %NWL%this . stripColors = options . stripColors || false ; %NWL%3
directionalNavHTML :  '  < div class =  " slider - nav hide - for - small "  >  < span class =  " right "  >  <  / span >  < span class =  " left "  >  <  / span >  <  / div >  '  ,%NWL%bulletHTML :  '  < ul class =  " orbit - bullets "  >  <  / ul >  '  ,%NWL%slideNumberHTML :  '  < span class =  " orbit - slide - counter "  >  <  / span >  '  ,%NWL%init : function ( element , options )  {%NWL%var $imageSlides ,%NWL%imagesLoadedCount = 0 ,%NWL%self = this ; %NWL%this . clickTimer = $ . proxy ( this . clickTimer , this )  ; %NWL%this . addBullet = $ . proxy ( this . addBullet , this )  ; %NWL%this . resetAndUnlock = $ . proxy ( this . resetAndUnlock , this )  ; %NWL%this . stopClock = $ . proxy ( this . stopClock , this )  ; %NWL%7
switch ( child . tagName . toLowerCase (  )  )  {%NWL%case " name "  : nameNode = child ; break ; %NWL%case " uri "  : uriNode = child ; break ;%NWL%}%NWL%}  )  ; %NWL%var author =  {  }  ; %NWL%if ( nameNode && nameNode . length =  = 1 )  {%NWL%author . name = getNodeText ( nameNode [ 0 ]  )  ;%NWL%}%NWL%if ( uriNode && uriNode . length =  = 1 )  {%NWL%author . uri = getNodeText ( uriNode [ 0 ]  )  ; %NWL%7
$ . _spritely . instances =  {  }  ;%NWL%}%NWL%if ( !$ . _spritely . instances [ el_id ]  )  {%NWL%$ . _spritely . instances [ el_id ]  =  { current_frame :  - 1 }  ;%NWL%}%NWL%$ . _spritely . instances [ el_id ]  [  ' type '  ]  = options . type ; %NWL%$ . _spritely . instances [ el_id ]  [  ' depth '  ]  = options . depth ; %NWL%$ . _spritely . instances [ el_id ]  [  ' row '  ]  = 1 ; %NWL%options . el = this ; %NWL%options . width = options . width || $ ( this )  . width (  ) || 100 ; %NWL%options . height = options . height || $ ( this )  . height (  ) || 100 ; %NWL%9
this . els = els ; %NWL%this . models = models ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%this . bind = __bind ( this . bind , this )  ; %NWL%this . select = __bind ( this . select , this )  ; %NWL%this . build = __bind ( this . build , this )  ; %NWL%this . bindingRegExp = __bind ( this . bindingRegExp , this )  ; %NWL%3
if ( typeof settings =  =  ' function '  )%NWL%settings =  { onAfter : settings }  ; %NWL%if ( target =  =  ' max '  )%NWL%target = 9e9 ; %NWL%settings = $ . extend (  {  }  , $scrollTo . defaults , settings )  ; %NWL%duration = duration || settings . duration ; %NWL%settings . queue = settings . queue && settings . axis . length > 1 ; %NWL%if ( settings . queue )%NWL%duration /  = 2 ; %NWL%settings . offset = both ( settings . offset )  ; %NWL%settings . over = both ( settings . over )  ; %NWL%9
}  , 1000 )  ;%NWL%}  ; %NWL%Agent . prototype . fillFromAgent = function ( d )  {%NWL%var call , msg , _i , _len , _ref , _results ; %NWL%this . setName ( d . name )  ; %NWL%this . setState ( d . state )  ; %NWL%this . setStatus ( d . status )  ; %NWL%this . setUsername ( d . username )  ; %NWL%this . setExtension ( d . extension )  ; %NWL%this . busy_delay_time = d . busy_delay_time ; %NWL%this . class_answered = d . class_answered ; %NWL%9
this . type = src . type ; %NWL%this . isDefaultPrevented =  ( src . defaultPrevented ) ? returnTrue : returnFalse ;%NWL%} else {%NWL%this . type = src ;%NWL%}%NWL%if ( props )  {%NWL%this . type = props . type ! =  = undefined ? props . type : this . type ; %NWL%this . cy = props . cy ; %NWL%this . cyTarget = props . cyTarget ; %NWL%this . cyPosition = props . cyPosition ; %NWL%this . cyRenderedPosition = props . cyRenderedPosition ; %NWL%7
this . parent . parentNode . replaceChild ( this . swapped , this . parent )  ;%NWL%}%NWL%}  ,%NWL%render : function ( context , buffer )  {%NWL%this . parent = buffer . getParent (  )  ; %NWL%if ( this . options . node )  {%NWL%this . onAddNode = connect . connect ( buffer ,  " onAddNode "  , lang . hitch ( this ,  " _swap "  ,  " node "  )  )  ; %NWL%this . onRemoveNode = connect . connect ( buffer ,  " onRemoveNode "  , lang . hitch ( this ,  " _swap "  ,  " node "  )  )  ;%NWL%}%NWL%if ( this . options . text )  {%NWL%this . onChangeData = connect . connect ( buffer ,  " onChangeData "  , lang . hitch ( this ,  " _swap "  ,  " node "  )  )  ; %NWL%6
return null ;%NWL%}%NWL%return handler ;%NWL%}%NWL%function _xhrSend ( mockHandler , requestSettings , origSettings )  {%NWL%var process =  ( function ( that )  {%NWL%return function (  )  {%NWL%return ( function (  )  {%NWL%var onReady ; %NWL%this . status  = mockHandler . status ; %NWL%this . statusText = mockHandler . statusText ; %NWL%9
return node . parent ;%NWL%}  , r )  ; %NWL%if ( r ! = node . right )  {%NWL%r . parent . left = r . right ; %NWL%if ( r . right ) r . right . parent = r . parent ; %NWL%r . right = node . right ; %NWL%r . right . parent = r ; %NWL%b = r . parent ;%NWL%}%NWL%r . parent = node . parent ; %NWL%r . left = node . left ; %NWL%5
return base . prototype [ prop ]  . apply ( this , args )  ;%NWL%}  ; %NWL%return function (  )  {%NWL%var __super = this . _super ,%NWL%__superApply = this . _superApply ,%NWL%returnValue ; %NWL%this . _super = _super ; %NWL%this . _superApply = _superApply ; %NWL%returnValue = value . apply ( this , arguments )  ; %NWL%this . _super = __super ; %NWL%this . _superApply = __superApply ; %NWL%9
for ( i = 0 , j = scripts . length ; i < j ; i +  +  )  {%NWL%script = scripts [ i ]%NWL%if ( script . hasAttribute (  ' data - no - instant '  )  )  {%NWL%continue%NWL%}%NWL%copy = document . createElement (  ' script '  )%NWL%if ( script . src )  {%NWL%copy . src = script . src%NWL%}%NWL%if ( script . innerHTML )  {%NWL%copy . innerHTML = script . innerHTML%NWL%7
deferred . reject ( err )  ;%NWL%}%NWL%return deferred . promise ;%NWL%}%NWL%Peer . prototype . sendResult = function ( request , payload )  {%NWL%var self = this ; %NWL%var deferred = Q . defer (  )  ; %NWL%try {%NWL%var result = Util . copy ( payload )  ; %NWL%result . $id = request . $id ; %NWL%result . $handler = request . $handler ; %NWL%9
}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%this . prefix = __bind ( this . prefix , this )  ; %NWL%this . suffix = __bind ( this . suffix , this )  ; %NWL%this . date = __bind ( this . date , this )  ; %NWL%1
scope . onClickVolume = function onClickVolume ( event )  {%NWL%event = VG_UTILS . fixEventOffset ( event )  ; %NWL%var volumeHeight = parseInt ( volumeBackElem . prop (  " offsetHeight "  )  )  ; %NWL%var value = event . offsetY * 100 / volumeHeight ; %NWL%var volValue = 1 -  ( value / 100 )  ; %NWL%API . setVolume ( volValue )  ;%NWL%}  ; %NWL%scope . onMouseDownVolume = function onMouseDownVolume (  )  {%NWL%isChangingVolume = true ;%NWL%}  ; %NWL%scope . onMouseUpVolume = function onMouseUpVolume (  )  {%NWL%7
fns . templayed = fromStringRenderer (  ' templayed '  )  ; %NWL%fns . templayed . render = function ( str , options , fn )  {%NWL%var engine = requires . templayed || ( requires . templayed = require ( sailsAppPath +  '  / templayed '  )  )  ; %NWL%try {%NWL%var tmpl = cache ( options ) || cache ( options , engine ( str )  )  ; %NWL%fn ( null , tmpl ( options )  )  ;%NWL%} catch ( err )  {%NWL%fn ( err )  ;%NWL%}%NWL%}  ; %NWL%fns . handlebars = fromStringRenderer (  ' handlebars '  )  ; %NWL%0
{%NWL%type :  ' confirm '  ,%NWL%name :  ' includeAngularResource '  ,%NWL%message :  ' Do you want to include angular - resource , helpful for calling RESTful apis? '  ,%NWL%default : true%NWL%}  ,%NWL%]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%this . projectName = props . projectName ; %NWL%this . author = props . author ; %NWL%this . useCoffeescript = props . useCoffeescript ; %NWL%8
listConfig : null ,%NWL%lastNode : null ,%NWL%lastActiveList : null%NWL%}  ,%NWL%constructor : function ( config )  {%NWL%if ( Ext . isObject ( config )  )  {%NWL%if ( config . getTitleTextTpl )  {%NWL%this . getTitleTextTpl = config . getTitleTextTpl ;%NWL%}%NWL%if ( config . getItemTextTpl )  {%NWL%this . getItemTextTpl = config . getItemTextTpl ; %NWL%7
layer . zPosition = 1 ;%NWL%}  ,%NWL%open : function ( file , contents )  {%NWL%var self = this ; %NWL%self . name = file . name ; %NWL%var map = JSON . parse ( contents )  ; %NWL%var settings = map . settings ; %NWL%delete map . settings ; %NWL%self . width = settings . width ; %NWL%self . height = settings . height ; %NWL%self . columns = settings . columns ; %NWL%8
state = GenStateCompleted ; %NWL%if ( method =  =  =  " next "  )  {%NWL%context . dispatchException ( thrown )  ;%NWL%} else {%NWL%arg = thrown ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%generator . next = invoke . bind ( generator ,  " next "  )  ; %NWL%generator . throw = invoke . bind ( generator ,  " throw "  )  ; %NWL%9
}%NWL%}  ,%NWL%__proto__ : WebInspector . Object . prototype%NWL%}%NWL%WebInspector . ConsoleMessage = function ( source , level , url , line , column , repeatCount )%NWL%{%NWL%this . source = source ; %NWL%this . level = level ; %NWL%this . url = url || null ; %NWL%this . line = line || 0 ; %NWL%this . column = column || 0 ; %NWL%9
this . clockRange =  =  = other . clockRange &&%NWL%this . clockStep =  =  = other . clockStep &&%NWL%this . multiplier =  =  = other . multiplier ;%NWL%}  ; %NWL%DataSourceClock . prototype . merge = function ( source )  {%NWL%if ( !defined ( source )  )  {%NWL%throw new DeveloperError (  ' source is required .  '  )  ;%NWL%}%NWL%this . startTime = defaultValue ( this . startTime , source . startTime )  ; %NWL%this . stopTime = defaultValue ( this . stopTime , source . stopTime )  ; %NWL%this . currentTime = defaultValue ( this . currentTime , source . currentTime )  ; %NWL%8
parseCode : function (  )  {%NWL%var tok = this . expect (  ' code '  )%NWL%, node = new nodes . Code ( tok . val , tok . buffer , tok . escape )%NWL%, block%NWL%, i = 1 ; %NWL%node . line = this . line (  )  ; %NWL%while ( this . lookahead ( i ) && ' newline '  =  = this . lookahead ( i )  . type )  +  + i ; %NWL%block =  ' indent '  =  = this . lookahead ( i )  . type ; %NWL%if ( block )  {%NWL%this . skip ( i - 1 )  ; %NWL%node . block = this . block (  )  ; %NWL%5
return ;%NWL%}%NWL%node . hoverClass = data . hoverClass ; %NWL%WebForm_AppendToClassName ( node , data . hoverClass )  ; %NWL%if ( __nonMSDOMBrowser )  {%NWL%node = node . childNodes [ node . childNodes . length - 1 ]  ;%NWL%}%NWL%else {%NWL%node = node . children [ node . children . length - 1 ]  ;%NWL%}%NWL%node . hoverHyperLinkClass = data . hoverHyperLinkClass ; %NWL%2
j$ . ExceptionFormatter = jRequire . ExceptionFormatter (  )  ; %NWL%j$ . Expectation = jRequire . Expectation (  )  ; %NWL%j$ . buildExpectationResult = jRequire . buildExpectationResult (  )  ; %NWL%j$ . JsApiReporter = jRequire . JsApiReporter (  )  ; %NWL%j$ . matchersUtil = jRequire . matchersUtil ( j$ )  ; %NWL%j$ . ObjectContaining = jRequire . ObjectContaining ( j$ )  ; %NWL%j$ . ArrayContaining = jRequire . ArrayContaining ( j$ )  ; %NWL%j$ . pp = jRequire . pp ( j$ )  ; %NWL%j$ . QueueRunner = jRequire . QueueRunner ( j$ )  ; %NWL%j$ . ReportDispatcher = jRequire . ReportDispatcher (  )  ; %NWL%j$ . Spec = jRequire . Spec ( j$ )  ; %NWL%4
for ( var element = this ; element ; element = element . scrollParent )  {%NWL%curLeft +  = element . scrollLeft ; %NWL%curTop +  = element . scrollTop ;%NWL%}%NWL%return { left : curLeft , top : curTop }  ;%NWL%}%NWL%function AnchorBox ( x , y , width , height )%NWL%{%NWL%this . x = x || 0 ; %NWL%this . y = y || 0 ; %NWL%this . width = width || 0 ; %NWL%8
exports . CSSStyleDeclaration = require (  '  .  / CSSStyleDeclaration '  )  . CSSStyleDeclaration ; %NWL%exports . CSSRule = require (  '  .  / CSSRule '  )  . CSSRule ; %NWL%exports . CSSStyleRule = require (  '  .  / CSSStyleRule '  )  . CSSStyleRule ; %NWL%exports . MediaList = require (  '  .  / MediaList '  )  . MediaList ; %NWL%exports . CSSMediaRule = require (  '  .  / CSSMediaRule '  )  . CSSMediaRule ; %NWL%exports . CSSImportRule = require (  '  .  / CSSImportRule '  )  . CSSImportRule ; %NWL%exports . CSSFontFaceRule = require (  '  .  / CSSFontFaceRule '  )  . CSSFontFaceRule ; %NWL%exports . StyleSheet = require (  '  .  / StyleSheet '  )  . StyleSheet ; %NWL%exports . CSSStyleSheet = require (  '  .  / CSSStyleSheet '  )  . CSSStyleSheet ; %NWL%exports . CSSKeyframesRule = require (  '  .  / CSSKeyframesRule '  )  . CSSKeyframesRule ; %NWL%exports . CSSKeyframeRule = require (  '  .  / CSSKeyframeRule '  )  . CSSKeyframeRule ; %NWL%0
dmData . rotationRate . alpha = $ (  ' #da - ra '  )  . val (  )  ; %NWL%dmData . rotationRate . beta = $ (  ' #da - rb '  )  . val (  )  ;  ; %NWL%dmData . rotationRate . gamma = $ (  ' #da - rg '  )  . val (  )  ;  ; %NWL%dmData . interval = $ (  ' #da - i '  )  . val (  )  ; %NWL%now . setMotion ( dmData )  ;%NWL%}%NWL%function setTripComputer (  )  {%NWL%var tcData = new Object (  )  ; %NWL%tcData . c1 = $ (  ' #tc - c1 '  )  . val (  )  ; %NWL%tcData . c2 = $ (  ' #tc - c2 '  )  . val (  )  ; %NWL%tcData . s1 = $ (  ' #tc - s1 '  )  . val (  )  ; %NWL%8
logger . trace (%NWL%' Tracing MongoDB %s . %s (  )  .  '  ,%NWL%collection ,%NWL%opName%NWL%)%NWL%if ( this . db && this . db . serverConfig )  {%NWL%segment . host = this . db . serverConfig . host%NWL%segment . port = this . db . serverConfig . port%NWL%} else if ( this . s && this . s . topology )  {%NWL%segment . host = this . s . topology . host%NWL%segment . port = this . s . topology . port%NWL%9
if ( data . map ! =  = undefined )  {%NWL%material . map = getTexture ( data . map )  ;%NWL%}%NWL%if ( data . bumpMap ! =  = undefined )  {%NWL%material . bumpMap = getTexture ( data . bumpMap )  ; %NWL%if ( data . bumpScale )  {%NWL%material . bumpScale = new THREE . Vector2 ( data . bumpScale , data . bumpScale )  ;%NWL%}%NWL%}%NWL%if ( data . alphaMap ! =  = undefined )  {%NWL%material . alphaMap = getTexture ( data . alphaMap )  ; %NWL%1
sc . events . tmdbHashGetInfoSuccess		 =  ' tmdbHashGetInfoSuccess '  ; %NWL%sc . events . tmdbHashGetInfoFailure		 =  ' tmdbHashGetInfoFailure '  ; %NWL%function SpazTMDB ( opts )  {%NWL%opts = sch . defaults (  {%NWL%' apikey '  : null ,%NWL%' lang '  :  ' en '  ,%NWL%' format '  :  ' json '  ,%NWL%' eventTarget '  : document%NWL%}  , opts )  ; %NWL%this . apikey = opts . apikey ; %NWL%this . lang  = opts . lang ; %NWL%9
if ( !this . log . serializers . client_res )  {%NWL%this . log = this . log . child (  {%NWL%serializers :  { client_res : bunyan . serializers . client_res }%NWL%}  )  ;%NWL%}%NWL%this . key = options . key ; %NWL%this . name = options . name || ' HttpClient '  ; %NWL%this . passphrase = options . passphrase ; %NWL%this . pfx = options . pfx ; %NWL%if ( options . rejectUnauthorized ! =  = undefined )  {%NWL%this . rejectUnauthorized = options . rejectUnauthorized ; %NWL%5
}  )%NWL%self . ipc . on (  ' data '  , function ( data )  {%NWL%if ( !isCmd ( data )  )  {%NWL%self . writeToConsole ( data )%NWL%}%NWL%}  )%NWL%self . setConnection ( conn )%NWL%console . log = self . writeToConsole . bind ( self )%NWL%console . info = self . writeToConsole . bind ( self ,  ' info '  )%NWL%console . warn = self . writeToConsole . bind ( self ,  ' warn '  )%NWL%console . error = self . writeToConsole . bind ( self ,  ' error '  )%NWL%8
splitWords : function ( words )  {%NWL%if ( words && typeof words =  =  ' string '  )  {%NWL%return words . replace ( basicTrimRe ,  '  '  )  . split ( whitespaceRe )  ;%NWL%}%NWL%return words || [  ]  ;%NWL%}%NWL%}  ;%NWL%}  (  )  )  ; %NWL%Ext . String . resetCharacterEntities (  )  ; %NWL%Ext . htmlEncode = Ext . String . htmlEncode ; %NWL%Ext . htmlDecode = Ext . String . htmlDecode ; %NWL%9
responseTime : parseInt ( stat . responseTime )  ,%NWL%outages : stat . outages || [  ]  ,%NWL%begin : begin . valueOf (  )  ,%NWL%end : end . valueOf (  )%NWL%}  )%NWL%}  )  ;%NWL%}  ; %NWL%Check . methods . populateFromDirtyCheck = function ( dirtyCheck , pollerCollection )  {%NWL%this . url = dirtyCheck . url || this . url ; %NWL%this . maxTime = dirtyCheck . maxTime || this . maxTime ; %NWL%this . isPaused = dirtyCheck . isPaused || this . isPaused ; %NWL%8
return function advice (  )  {%NWL%var i , imax , advices = arguments ; %NWL%for ( i = 0 , imax = advices . length ; i < imax ; i +  = 1 )  {%NWL%adviceCollection . advices . push ( adviceFactory ( advices [ i ]  )  )  ;%NWL%}%NWL%return this ;%NWL%}  ;%NWL%}%NWL%adviceCollection . advice = adviceMetaFactory ( precompiledFactory )  ; %NWL%adviceCollection . around = adviceMetaFactory ( aroundFactory )  ; %NWL%adviceCollection . before = adviceMetaFactory ( beforeFactory )  ; %NWL%9
scroll : options . scroll ,%NWL%scrollSensitivity : options . scrollSensitivity ,%NWL%scrollSpeed : options . scrollSpeed ,%NWL%constraint : options . constraint ,%NWL%handle : options . handle%NWL%}  ; %NWL%if ( options . starteffect )  {%NWL%options_for_draggable . starteffect = options . starteffect ;%NWL%}%NWL%if ( options . reverteffect )  {%NWL%options_for_draggable . reverteffect = options . reverteffect ; %NWL%7
}  ,%NWL%matches : function ( tamperResponse )  {%NWL%if ( this . uri =  = tamperResponse . uri && this . requestMethod =  = tamperResponse . requestMethod )  {%NWL%return true ;%NWL%}%NWL%return false ;%NWL%}  ,%NWL%merge : function ( tamperResponse )  {%NWL%this . elapsedTime = tamperResponse . millis - this . millis ; %NWL%this . status = tamperResponse . status ; %NWL%this . statusText = tamperResponse . statusText ; %NWL%9
plot . getPlaceholder (  )  . append ( elem )  ; %NWL%w = elem . outerWidth ( true )  ; %NWL%h = elem . outerHeight ( true )  ; %NWL%elem . remove (  )  ;%NWL%}%NWL%if ( axisName . charAt ( 0 )  =  =  ' x '  )%NWL%axis . labelHeight +  = h ; %NWL%else%NWL%axis . labelWidth +  = w ; %NWL%opts . labelHeight = axis . labelHeight ; %NWL%opts . labelWidth = axis . labelWidth ; %NWL%9
}%NWL%}  )  ; %NWL%var _p = cc . RenderTexture . prototype ; %NWL%if ( cc . _renderType =  = cc . _RENDER_TYPE_WEBGL )  {%NWL%_p . ctor = _p . _ctorForWebGL ; %NWL%_p . cleanup = _p . _cleanupForWebGL ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForWebGL ; %NWL%_p . begin = _p . _beginForWebGL ; %NWL%_p . _beginWithClear = _p . _beginWithClearForWebGL ; %NWL%_p . end = _p . _endForWebGL ; %NWL%_p . clearRect = _p . _clearRectForWebGL ; %NWL%4
var weakSelf ,%NWL%_this = this ; %NWL%this . el = el ; %NWL%this . prev = __bind ( this . prev , this )  ; %NWL%this . next = __bind ( this . next , this )  ; %NWL%this . stop = __bind ( this . stop , this )  ; %NWL%this . play = __bind ( this . play , this )  ; %NWL%this . to = __bind ( this . to , this )  ; %NWL%this . _createArrows = __bind ( this . _createArrows , this )  ; %NWL%this . _createPagination = __bind ( this . _createPagination , this )  ; %NWL%this . _enableBindKeys = __bind ( this . _enableBindKeys , this )  ; %NWL%3
Object . isSealed = function isSealed ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isFrozen )  {%NWL%Object . isFrozen = function isFrozen ( object )  {%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isExtensible )  {%NWL%Object . isExtensible = function isExtensible ( object )  {%NWL%0
var delta =  {%NWL%action :  " insertText "  ,%NWL%range : Range . fromPoints ( position , end )  ,%NWL%text : text%NWL%}  ; %NWL%this . _dispatchEvent (  " change "  ,  { data : delta }  )  ; %NWL%return end ;%NWL%}  ; %NWL%this . remove = function ( range )  {%NWL%range . start = this . $clipPosition ( range . start )  ; %NWL%range . end = this . $clipPosition ( range . end )  ; %NWL%9
clone . global = this . global ; %NWL%clone . directional = this . directional ; %NWL%clone . color =  ( this . color && this . color . slice (  )  )  ; %NWL%clone . direction =  ( this . direction && this . direction . slice (  )  )  ; %NWL%clone . origin =  ( this . origin && this . origin . slice (  )  )  ; %NWL%clone . frustum =  ( this . frustum && this . frustum . slice (  )  )  ; %NWL%clone . frustumNear = this . frustumNear ; %NWL%clone . center =  ( this . center && this . center . slice (  )  )  ; %NWL%clone . halfExtents =  ( this . halfExtents && this . halfExtents . slice (  )  )  ; %NWL%clone . radius = this . radius ; %NWL%clone . shadows = this . shadows ; %NWL%0
}%NWL%this . server = proto . create (  )  ; %NWL%return this . add ( this . server )  ;%NWL%}  ,%NWL%inject : function ( obj )  {%NWL%sinon . collection . inject . call ( this , obj )  ; %NWL%if ( this . clock )  {%NWL%obj . clock = this . clock ;%NWL%}%NWL%if ( this . server )  {%NWL%obj . server = this . server ; %NWL%7
mExplorer . Explorer . call ( this , options . serviceRegistry , options . selection , renderer , options . commandRegistry )  ; %NWL%this . parentId = options . parentId ; %NWL%this . actionScopeId = options . actionScopeId ; %NWL%this . sectionActionScodeId = options . sectionActionScodeId ; %NWL%this . repositories = options . repositories ; %NWL%this . mode = options . mode ; %NWL%this . showLinks = options . showLinks ; %NWL%this . location = options . location ; %NWL%this . section = options . section ; %NWL%this . selectionPolicy = options . selectionPolicy ; %NWL%this . handleError = options . handleError ; %NWL%1
parameters = Ext . apply ( parameters , parameters . filters )  ; %NWL%delete parameters . filters ;  /  / TODO make map data accept explicit parameters%NWL%OE . data . doAjaxRestricted (  {%NWL%url : OE . util . getUrl (  '  / map / mapData '  )  ,%NWL%method :  ' GET '  ,%NWL%params : parameters ,%NWL%scope : this ,%NWL%onJsonSuccess : function ( response )  {%NWL%this . wmsserver = response . systemMapProperties . wmsserver ; %NWL%this . wfsserver = response . systemMapProperties . wfsserver ; %NWL%this . gwcserver = response . systemMapProperties . gwcserver ; %NWL%8
json . value = this . value ; %NWL%return json ;%NWL%}  ; %NWL%Axis . prototype . fromJSON = function ( json )  {%NWL%this . name = json . name ; %NWL%this . negButton = json . negButton ; %NWL%this . posButton = json . posButton ; %NWL%this . altNegButton = json . altNegButton ; %NWL%this . altPosButton = json . altPosButton ; %NWL%this . gravity = json . gravity ; %NWL%this . sensitivity = json . sensitivity ; %NWL%4
this . bins = null ; %NWL%this . animation = true ; %NWL%this . drawMode = null ; %NWL%this . extents = null ; %NWL%this . hasData = false ; %NWL%var s = arg . constructor . toString (  )  ; %NWL%if ( s . indexOf (  ' WebGLRenderingContext '  )  >  - 1 || s . indexOf (  ' rawgl '  )  >  - 1 )  {%NWL%this . gl = arg ; %NWL%this . canvas = arg . canvas ; %NWL%this . width = this . canvas . width ; %NWL%this . height = this . canvas . height ; %NWL%9
return msg ;%NWL%}  ; %NWL%return RTMPProtocol ;%NWL%}  )  (  )  ; %NWL%RTMPClient =  ( function ( _super )  {%NWL%__extends ( RTMPClient , _super )  ; %NWL%function RTMPClient ( socket )  {%NWL%var _this = this ; %NWL%this . socket = socket ; %NWL%this . parseMessages = __bind ( this . parseMessages , this )  ; %NWL%this . parseFullData = __bind ( this . parseFullData , this )  ; %NWL%9
var WrapIfs =%NWL%{%NWL%enter : function ( node )%NWL%{%NWL%if ( node . type =  =  ' ConditionalExpression '  )  {%NWL%if ( ! ( node . test . type =  =  ' Identifier ' || node . test . type =  =  ' Literal '  )  )  {%NWL%node . test = templateReplace (  "  ( function (  )  { return __REPLACEME__ }  (  )  )  "  , node . test )  . expression%NWL%node . test . skipcall = true%NWL%}%NWL%if ( ! ( node . consequent . type =  =  ' Identifier ' || node . consequent . type =  =  ' Literal '  )  )  {%NWL%node . consequent = templateReplace (  "  ( function (  )  { return __REPLACEME__ }  (  )  )  "  , node . consequent )  . expression%NWL%6
json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%json . group_size = this . group_size ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%this . out_sy = json . out_sy ; %NWL%this . layer_type = json . layer_type ; %NWL%7
var ahah = new Drupal . ahah ( base , element_settings )  ;%NWL%}  )  ; %NWL%$ (  ' # '  + base )  . addClass (  ' ahah - processed '  )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%Drupal . ahah = function ( base , element_settings )  {%NWL%this . element = element_settings . element ; %NWL%this . selector = element_settings . selector ; %NWL%this . event = element_settings . event ; %NWL%this . keypress = element_settings . keypress ; %NWL%8
exports . ServiceBusSettings = azureCommon . ServiceBusSettings ; %NWL%exports . ServiceManagementSettings = azureCommon . ServiceManagementSettings ; %NWL%exports . StorageServiceSettings = azureCommon . StorageServiceSettings ; %NWL%exports . CertificateCloudCredentials = azureCommon . CertificateCloudCredentials ; %NWL%exports . TokenCloudCredentials = azureCommon . TokenCloudCredentials ; %NWL%exports . AnonymousCloudCredentials = azureCommon . AnonymousCloudCredentials ; %NWL%exports . SharedAccessSignature = storage . SharedAccessSignature ; %NWL%exports . SharedKey = storage . SharedKey ; %NWL%exports . SharedKeyLite = storage . SharedKeyLite ; %NWL%exports . SharedKeyTable = storage . SharedKeyTable ; %NWL%exports . SharedKeyLiteTable = storage . SharedKeyLiteTable ; %NWL%6
videoHeight : 480%NWL%}  ; %NWL%sinon . stub ( video ,  " addEventListener "  , function ( event , cb )  {%NWL%cb (  )  ;%NWL%}  )  ; %NWL%sinon . stub ( video ,  " play "  )  ;%NWL%}  )  ; %NWL%afterEach ( function (  )  {%NWL%navigator . getUserMedia = originalUserMedia ; %NWL%window . URL = originalURL ; %NWL%window . MediaStreamTrack = originalMediaStreamTrack ; %NWL%9
}%NWL%}%NWL%this . defaults =  {  }  ; %NWL%_ . merge ( this . defaults , defaults )  ;%NWL%}%NWL%ClientSSLSecurity . prototype . toXML = function ( headers )  {%NWL%return '  '  ;%NWL%}  ; %NWL%ClientSSLSecurity . prototype . addOptions = function ( options )  {%NWL%options . key = this . key ; %NWL%options . cert = this . cert ; %NWL%9
}%NWL%res . jsonp ( poll )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%exports . update = function ( req , res )  {%NWL%console . log (  ' req . body '  , req . body )  ; %NWL%Poll . findById ( req . body . _id )  . populate (  ' choices invitees '  )  . exec ( function ( err , thisPoll )  {%NWL%thisPoll . name = req . body . name ; %NWL%thisPoll . updated = new Date (  )  ; %NWL%thisPoll . eventDate = req . body . eventDate ; %NWL%8
var xp = this . _xaxis . series_u2p ; %NWL%var yp = this . _yaxis . series_u2p ; %NWL%var i , prevColor , ops , b , h , w , a , points ; %NWL%var o ; %NWL%var r = this . renderer ; %NWL%var opts =  ( options ! = undefined ) ? options :  {  }  ; %NWL%var shadow =  ( opts . shadow ! = undefined ) ? opts . shadow : this . shadow ; %NWL%var fill =  ( opts . fill ! = undefined ) ? opts . fill : this . fill ; %NWL%var fillAndStroke =  ( opts . fillAndStroke ! = undefined ) ? opts . fillAndStroke : this . fillAndStroke ; %NWL%r . bodyWidth =  ( opts . bodyWidth ! = undefined ) ? opts . bodyWidth : r . bodyWidth ; %NWL%r . tickLength =  ( opts . tickLength ! = undefined ) ? opts . tickLength : r . tickLength ; %NWL%9
var buffer = new ArrayBuffer ( this . buffer . byteLength )  ; %NWL%new Uint8Array ( buffer )  . set ( this . buffer )  ; %NWL%bb . buffer = buffer ; %NWL%bb . view = new DataView ( buffer )  ;%NWL%} else {%NWL%bb . buffer = this . buffer ; %NWL%bb . view = this . view ;%NWL%}%NWL%bb . offset = this . offset ; %NWL%bb . markedOffset = this . markedOffset ; %NWL%bb . limit = this . limit ; %NWL%5
C . LUA_TTHREAD   = 8 ; %NWL%C . LUA_MINSTACK = 20 ; %NWL%var LUA_NUMBER = lua_Number ; %NWL%var LUA_INTEGER = lua_Integer ; %NWL%C . lua_newstate = F (  " lua_newstate "  , lua_State ,  [ lua_Alloc , void_ptr_t ]  )  ; %NWL%C . lua_close = F (  " lua_close "  , void_t ,  [ lua_State ]  )  ; %NWL%C . lua_newthread = F (  " lua_newthread "  , lua_State ,  [ lua_State ]  )  ; %NWL%C . lua_atpanic = F (  " lua_atpanic "  , lua_CFunction ,  [ lua_State , lua_CFunction ]  )  ; %NWL%C . lua_gettop = F (  " lua_gettop "  , int_t ,  [ lua_State ]  )  ; %NWL%C . lua_settop = F (  " lua_settop "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushvalue = F (  " lua_pushvalue "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%9
function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%3
var close_count = 0 ; %NWL%var pool = poolModule . Pool (  {%NWL%name  :  ' mysql '  ,%NWL%create  : function ( callback )  {%NWL%var Client = require (  ' mysql '  )  . Client ; %NWL%var c = new Client (  )  ; %NWL%c . host = randomChoose ( Cfg . serverlist )  ; %NWL%c . port = Cfg . port ; %NWL%c . user = Cfg . user ; %NWL%c . password = Cfg . password ; %NWL%c . database = Cfg . database ; %NWL%7
]  , function ( messages , mCommandRegistry , mExplorer , URITemplate , i18nUtil , uiUtil , util , Deferred , mGitCommands , objects )  {%NWL%var repoTemplate = new URITemplate (  " git / git - repository . html# {  , resource , params *  }  "  )  ;  /  / $NON - NLS - 0$%NWL%function GitRepoListModel ( options )  {%NWL%this . root = options . root ; %NWL%this . registry = options . registry ; %NWL%this . handleError = options . handleError ; %NWL%this . section = options . section ; %NWL%this . location = options . location ; %NWL%this . repositories = options . repositories ; %NWL%this . progressService = options . progressService ; %NWL%this . parentId = options . parentId ; %NWL%3
function onToggleGraphicUI (  )%NWL%{%NWL%if ( !GraphicsOption . ui || !GraphicsOption . ui [ 0 ]  . parentNode )  {%NWL%GraphicsOption . append (  )  ;%NWL%}%NWL%else {%NWL%GraphicsOption . remove (  )  ;%NWL%}%NWL%}%NWL%Escape . onResurectionRequest = function onResurectionRequest (  )  {  }  ; %NWL%Escape . onExitRequest = function onExitRequest (  )  {  }  ; %NWL%9
if ( node && ' type ' in node && ( node . type =  =  ' select - one ' || node . type =  =  ' select - multiple '  )  )  {%NWL%return new mobwrite . shareSelectObj ( node )  ;%NWL%}%NWL%return null ;%NWL%}  ; %NWL%mobwrite . shareHandlers . push ( mobwrite . shareSelectObj . shareHandler )  ; %NWL%mobwrite . shareRadioObj = function ( node )  {%NWL%mobwrite . shareObj . apply ( this ,  [ node . id ]  )  ; %NWL%this . elements =  [ node ]  ; %NWL%this . form = node . form ; %NWL%this . name = node . name ; %NWL%9
oValue . deltaZ	 = nDeltaZ ; %NWL%oValue . deltaMode	 = nDeltaMode ; %NWL%return oValue ;%NWL%}  ; %NWL%function fWheelEvent_init ( oEvent , sType , oValue )  {%NWL%fMouseEvent_init ( oEvent , sType , oValue )  ; %NWL%if ( oValue )  {%NWL%if (  " deltaX " in oValue )%NWL%oEvent . deltaX	 = oValue . deltaX ; %NWL%if (  " deltaY " in oValue )%NWL%oEvent . deltaY	 = oValue . deltaY ; %NWL%8
res . removeHeader ( field )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%exports . removeContentHeaders = deprecate . function ( exports . removeContentHeaders ,%NWL%' utils . removeContentHeaders : this private api moved with serve - static '  )  ; %NWL%exports . conditionalGET = function ( req )  {%NWL%return req . headers [  ' if - modified - since '  ]%NWL%|| req . headers [  ' if - none - match '  ]  ;%NWL%}  ; %NWL%exports . conditionalGET = deprecate . function ( exports . conditionalGET ,%NWL%4
onUnselect : function ( tagEl )  {%NWL%that . tagger . removeHighlights (  )  ; %NWL%$ ( document )  . unbind (  ' keydown '  )  ; 	 /  / Unbind the keyboard handler%NWL%}%NWL%}  )  ; %NWL%that . imageCanvas = that . locate (  " imageCanvas "  )  ; %NWL%that . cropStarted = false ; %NWL%that . tagStarted = false ; %NWL%that . resizeStarted = false ; %NWL%that . cropper = fluid . cropperUI ( that . container )  ; %NWL%that . tagger = fluid . taggerUI ( that . container )  ; %NWL%9
var file ; %NWL%if ( this . downloadPath )  {%NWL%file = this . downloadPath + data . name%NWL%} else {%NWL%file = data . file ;%NWL%}%NWL%tmpImgNode . src = file ; %NWL%dojo . attr ( tmpImgNode ,  ' _djrealurl '  , file )  ; %NWL%if ( data . width )  {%NWL%tmpImgNode . width = data . width ; %NWL%tmpImgNode . height = data . height ; %NWL%9
createPipe : function (  )  {%NWL%return carena . build (  {  }  ,  [  " composer . Pipe "  ]  )  ;%NWL%}  ,%NWL%createProxy : function (  )  {%NWL%var proxy = safe . proxy = carena . build (  {  }  ,  [%NWL%" carena . Node "  ,%NWL%" carena . Eventable "  ,%NWL%" carena . Draggable "  ,%NWL%]  )  ; %NWL%proxy . x   = obj . x ; %NWL%proxy . y   = obj . y ; %NWL%9
return 0 . 0 + XLK * S ;%NWL%}  ; %NWL%var _bezier = function ( curve , degree , t , left , right )  {%NWL%var temp =  [  [  ]  ]  ; %NWL%for ( var j = 0 ; j <  = degree ; j +  +  ) temp [ 0 ]  [ j ]  = curve [ j ]  ; %NWL%for ( var i = 1 ; i <  = degree ; i +  +  )  {%NWL%for ( var j = 0 ; j <  = degree - i ; j +  +  )  {%NWL%if ( !temp [ i ]  ) temp [ i ]  =  [  ]  ; %NWL%if ( !temp [ i ]  [ j ]  ) temp [ i ]  [ j ]  =  {  }  ; %NWL%temp [ i ]  [ j ]  . x =  ( 1 . 0 - t )  * temp [ i - 1 ]  [ j ]  . x + t * temp [ i - 1 ]  [ j + 1 ]  . x ; %NWL%temp [ i ]  [ j ]  . y =  ( 1 . 0 - t )  * temp [ i - 1 ]  [ j ]  . y + t * temp [ i - 1 ]  [ j + 1 ]  . y ; %NWL%9
this . bindDirection = bindDirection ; %NWL%return this ;%NWL%}  ,%NWL%transform : function ( converter )  {%NWL%this . converter = converter ; %NWL%return this ;%NWL%}%NWL%}  ;%NWL%}  ; %NWL%at . from = sync . from ; %NWL%at . to = sync . to ; %NWL%9
canvas . height = o . height ; %NWL%canvas . getContext (  " 2d "  )  . putImageData ( o , 0 , 0 )  ;%NWL%}%NWL%}%NWL%return canvas ;%NWL%}  ; %NWL%function toImage ( o )  {%NWL%var canvas = toCanvas ( o )  ,%NWL%image = new Image (  )  ; %NWL%image . width = canvas . width ; %NWL%image . height = canvas . height ; %NWL%9
volume . opacity * 100 )  ; %NWL%if ( typeof scene . volume . lowerThreshold ! =  ' undefined '  )  {%NWL%volume . lowerThreshold = scene . volume . lowerThreshold ;%NWL%}%NWL%if ( typeof scene . volume . upperThreshold ! =  ' undefined '  )  {%NWL%volume . upperThreshold = scene . volume . upperThreshold ;%NWL%}%NWL%jQuery (  ' #threshold - volume '  )  . dragslider (  " option "  ,  " values "  ,%NWL%[ volume . lowerThreshold , volume . upperThreshold ]  )  ; %NWL%if ( typeof scene . volume . windowLow ! =  ' undefined '  )  {%NWL%volume . windowLow = scene . volume . windowLow ; %NWL%2
relative . host : result . host ; %NWL%result . hostname =  ( relative . hostname || relative . hostname =  =  =  '  '  ) ?%NWL%relative . hostname : result . hostname ; %NWL%result . search = relative . search ; %NWL%result . query = relative . query ; %NWL%srcPath = relPath ;%NWL%} else if ( relPath . length )  {%NWL%if ( !srcPath ) srcPath =  [  ]  ; %NWL%srcPath . pop (  )  ; %NWL%srcPath = srcPath . concat ( relPath )  ; %NWL%result . search = relative . search ; %NWL%4
if ( thisParams . length =  = 0 )  {  /  / none exist yet , so just bung all these user - defined params straight in%NWL%this . params = params ;%NWL%}%NWL%else {  /  / need to overlay these user - defined params on to existing parser - defined params%NWL%for ( var i = 0 , l = params . length ; i < l ; i +  +  )  {%NWL%if ( thisParams [ i ]  )  {%NWL%if ( params [ i ]  . type ) thisParams [ i ]  . type = params [ i ]  . type ; %NWL%thisParams [ i ]  . name = params [ i ]  . name ; %NWL%thisParams [ i ]  . desc = params [ i ]  . desc ; %NWL%thisParams [ i ]  . isOptional = params [ i ]  . isOptional ; %NWL%thisParams [ i ]  . defaultValue = params [ i ]  . defaultValue ; %NWL%7
localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%addCustomOperation ( localElem )  ; %NWL%return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%9
return pie ;%NWL%}  ; %NWL%pie . value = function ( field )  {%NWL%value = field ? vg . accessor ( field )  : one ; %NWL%return pie ;%NWL%}  ; %NWL%pie . startAngle = function ( startAngle )  {%NWL%start = Math . PI * startAngle / 180 ; %NWL%return pie ;%NWL%}  ; %NWL%pie . endAngle = function ( endAngle )  {%NWL%6
return base . path ;%NWL%}  ; %NWL%exports . dirname = function dirname ( path )  {%NWL%var parent = MozFile ( path )  . parent ; %NWL%return parent ? parent . path :  "  "  ;%NWL%}  ; %NWL%exports . basename = function basename ( path )  {%NWL%var leafName = MozFile ( path )  . leafName ; %NWL%return leafName =  = path ? "  "  : leafName ;%NWL%}  ; %NWL%exports . list = function list ( path )  {%NWL%2
}%NWL%}  ,%NWL%getParamsAndGrads : function (  )  { return [  ]  ;  }  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . k = this . k ; %NWL%json . n = this . n ; %NWL%json . alpha = this . alpha ;  /  / normalize by size%NWL%json . beta = this . beta ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%5
}%NWL%result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%7
}%NWL%}%NWL%}  ; %NWL%Drupal . ahah = function ( base , element_settings )  {%NWL%this . element = element_settings . element ; %NWL%this . selector = element_settings . selector ; %NWL%this . event = element_settings . event ; %NWL%this . keypress = element_settings . keypress ; %NWL%this . url = element_settings . url ; %NWL%this . wrapper =  ' # '  + element_settings . wrapper ; %NWL%this . effect = element_settings . effect ; %NWL%5
this . bottom = this . halfHeight + this . y ;%NWL%}%NWL%return this ;%NWL%}  ; %NWL%proto . set = function ( aabb )  {%NWL%this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%this . width  = aabb . width ; %NWL%this . height = aabb . height ; %NWL%this . halfWidth = aabb . halfWidth ; %NWL%5
return generateFromOpts ( opt )  ;%NWL%}%NWL%function processGrammar ( dict , tokens )  {%NWL%var opts =  {  }  ; %NWL%if ( typeof dict =  =  =  ' string '  )  {%NWL%dict = lexParser . parse ( dict )  ;%NWL%}%NWL%dict = dict || {  }  ; %NWL%opts . options = dict . options || {  }  ; %NWL%opts . moduleType = opts . options . moduleType ; %NWL%opts . moduleName = opts . options . moduleName ; %NWL%9
else {%NWL%self . cwd = options . cwd%NWL%self . changedCwd = path . resolve ( options . cwd ) ! =  = cwd%NWL%}%NWL%self . root = options . root || path . resolve ( self . cwd ,  "  /  "  )%NWL%self . root = path . resolve ( self . root )%NWL%if ( process . platform =  =  =  " win32 "  )%NWL%self . root = self . root . replace (  / \\ / g ,  "  /  "  )%NWL%self . nomount = !!options . nomount%NWL%options . nonegate = options . nonegate =  =  = false ? false : true%NWL%options . nocomment = options . nocomment =  =  = false ? false : true%NWL%9
config . server . webroot = config . server . webroot . replace (  " $config_dir "  , path . dirname ( filepath )  )  ;%NWL%}%NWL%} catch ( ex )  {%NWL%throw new Error (  ' Cannot parse the config file "  '  + filepath +  '  "  :  '  + ex )  ;%NWL%}%NWL%}%NWL%return config ;%NWL%}%NWL%function parseConfig ( contents , config )  {%NWL%contents . server = contents . server || {  }  ; %NWL%contents . proxy = contents . proxy || {  }  ; %NWL%9
markerFont : 			 "  "  ,%NWL%markerFontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = lang . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%du . updateWithPattern ( this . opt , kwArgs , this . optionalParams )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%this . animate = this . opt . animate ; %NWL%8
}%NWL%var layers = map . getElementsByTagName (  ' layer '  )  ; %NWL%if ( layers )  {%NWL%for ( i = 0 ; i < layers . length ; i +  +  )  {%NWL%var selLayer = layers [ i ]  ; %NWL%var data = selLayer . getElementsByTagName (  ' data '  )  [ 0 ]  ; %NWL%var layer = new cc . TMXLayerInfo (  )  ; %NWL%layer . name = selLayer . getAttribute (  ' name '  )  ; %NWL%var layerSize = cc . size ( 0 , 0 )  ; %NWL%layerSize . width = parseFloat ( selLayer . getAttribute (  ' width '  )  )  ; %NWL%layerSize . height = parseFloat ( selLayer . getAttribute (  ' height '  )  )  ; %NWL%9
options = opt ; %NWL%if ( options . gfm )  {%NWL%block . fences = block . gfm . fences ; %NWL%block . paragraph = block . gfm . paragraph ; %NWL%inline . text = inline . gfm . text ; %NWL%inline . url = inline . gfm . url ;%NWL%} else {%NWL%block . fences = block . normal . fences ; %NWL%block . paragraph = block . normal . paragraph ; %NWL%inline . text = inline . normal . text ; %NWL%inline . url = inline . normal . url ; %NWL%9
var options =  {%NWL%xpixels : 514 ,%NWL%ypixels : 514 ,%NWL%range :  [  [  - 1 . 2 , 1 . 2 ]  ,  [  - 1 . 2 , 1 . 2 ]  ]%NWL%}  ; %NWL%options . scale =  [ options . xpixels /  ( options . range [ 0 ]  [ 1 ]  - options . range [ 0 ]  [ 0 ]  )  ,%NWL%options . ypixels /  ( options . range [ 1 ]  [ 1 ]  - options . range [ 1 ]  [ 0 ]  )  ]  ; %NWL%graph . init ( options )  ; %NWL%graph . xpixels = options . xpixels ; %NWL%graph . ypixels = options . ypixels ; %NWL%graph . range = options . range ; %NWL%8
exports . getter = base . getter ; %NWL%exports . setter = base . setter ; %NWL%exports . responds = base . responds ; %NWL%exports . remove = base . remove ; %NWL%exports . unique = base . unique ; %NWL%exports . shallow = base . shallow ; %NWL%exports . clone = base . clone ; %NWL%exports . mkhash = base . mkhash ; %NWL%exports . forEach = base . forEach ; %NWL%exports . cache = cache . cache ; %NWL%exports . lock = lock . lock ; %NWL%9
}%NWL%function normalizeError ( err )  {%NWL%if ( err instanceof Error )  {%NWL%return err ;%NWL%} else if ( err . statusCode )  {%NWL%var e = new Error ( err . statusCode +  '  :  '  + err . data )  ; %NWL%e . statusCode = err . statusCode ; %NWL%try {%NWL%e . data = JSON . parse ( err . data )  ;%NWL%} catch ( er )  {%NWL%e . data = err . data ; %NWL%6
this . rawNode = rawNode ;%NWL%}%NWL%}  )  ; %NWL%dojox . gfx . Group . nodeType =  " Canvas "  ; %NWL%dojo . declare (  " dojox . gfx . Rect "  , dojox . gfx . shape . Rect ,  {%NWL%setShape : function ( newShape )  {%NWL%this . shape = dojox . gfx . makeParameters ( this . shape , newShape )  ; %NWL%this . bbox = null ; %NWL%var r = this . rawNode , n = this . shape ; %NWL%r . width  = n . width ; %NWL%r . height  = n . height ; %NWL%9
}%NWL%function WebPartManager (  )  {%NWL%this . overlayContainerElement = null ; %NWL%this . zones = new Array (  )  ; %NWL%this . dragState = null ; %NWL%this . menu = null ; %NWL%this . draggedWebPart = null ; %NWL%this . AddZone = WebPartManager_AddZone ; %NWL%this . IsDragDropEnabled = WebPartManager_IsDragDropEnabled ; %NWL%this . DragDrop = WebPartManager_DragDrop ; %NWL%this . InitiateWebPartDragDrop = WebPartManager_InitiateWebPartDragDrop ; %NWL%7
var Client = require (  '  .  / driver / client '  )  ,%NWL%Server = require (  '  .  / driver / server '  )  ; %NWL%var Driver =  {%NWL%client : function ( url , options )  {%NWL%options = options || {  }  ; %NWL%if ( options . masking =  =  = undefined ) options . masking = true ; %NWL%return new Client ( url , options )  ;%NWL%}  ,%NWL%server : function ( options )  {%NWL%options = options || {  }  ; %NWL%if ( options . requireMasking =  =  = undefined ) options . requireMasking = true ; %NWL%5
var foundSensors = androidModule . findSensors (  )  ; %NWL%androidModule . log (  ' found '  + foundSensors . length +  ' sensors '  )  ; %NWL%for ( var i = 0 ; i < foundSensors . length ; i +  +  )  {%NWL%var sensor = foundSensors [ i ]  ; %NWL%var regSensorData =  {  }  ; %NWL%regSensorData . type = sensor . type ; %NWL%regSensorData . name = sensor . name ; %NWL%regSensorData . description = sensor . description ; %NWL%regSensorData . maximumRange = sensor . maximumRange ; %NWL%regSensorData . minDelay = sensor . minDelay ; %NWL%regSensorData . power = sensor . power ; %NWL%5
opts = opts || {  }  ; %NWL%if ( !opts . protocol ) opts . protocol = window . location . protocol ; %NWL%validateConfig (  )  ; %NWL%this . file = file ; %NWL%this . type = opts . type || file . type || ' application / octet - stream '  ; %NWL%this . name = opts . name || file . name ; %NWL%this . bucketUrl = opts . protocol +  '  /  /  '  + S3 . bucket +  '  . s3 . amazonaws . com '  ; %NWL%this . url = this . bucketUrl +  '  /  '  + this . name ; %NWL%this . signature = S3 . signature ; %NWL%this . bucket = S3 . bucket ; %NWL%this . policy = S3 . policy ; %NWL%8
}%NWL%function onmessageSetter ( callback )%NWL%{%NWL%var wrappedCallback = bind ( self . _callbackWrapper , self , callback )  ; %NWL%wrappedCallback . originalCallback = callback ; %NWL%self . channel . port2 . onmessage = wrappedCallback ;%NWL%}%NWL%workerFrame . __defineGetter__ (  " onmessage "  , onmessageGetter )  ; %NWL%workerFrame . __defineSetter__ (  " onmessage "  , onmessageSetter )  ; %NWL%workerFrame . addEventListener = bind ( this . _addEventListener , this )  ; %NWL%workerFrame . removeEventListener = bind ( this . _removeEventListener , this )  ; %NWL%9
name = name . substr ( 0 , name . length - 3 )  ;%NWL%}%NWL%var setter = createUniformSetter ( info )  ; %NWL%uniforms [ name ]  = setter ; %NWL%if ( info . type =  = gl . SAMPLER_2D || info . type =  = gl . SAMPLER_CUBE )  {%NWL%textures [ name ]  = setter ;%NWL%}%NWL%}%NWL%that . textures = textures ; %NWL%that . attrib = attribs ; %NWL%that . attribLoc = attribLocs ; %NWL%9
return offset ;%NWL%}%NWL%function Screen ( window , colormap , white , black , current_input_masks , width_px , height_px , width_mm , height_mm , maps_min , maps_max , root_visual , backing_stores , save_unders , root_depth , depths )  {%NWL%this . window = window || 0 ; %NWL%this . colormap = colormap || 0 ; %NWL%this . white = white || 0 ; %NWL%this . black = black || 0 ; %NWL%this . current_input_masks = current_input_masks || 0 ; %NWL%this . height_px = height_px || 0 ; %NWL%this . width_px = width_px || 0 ; %NWL%this . height_mm = height_mm || 0 ; %NWL%3
var previewSize = this . model . get (  ' previewSize '  )  ; %NWL%var size =  [ Math . floor ( previewSize . x )  , Math . floor ( previewSize . y )  ]  ; %NWL%var attrs =  {%NWL%image_requests :  [  { crop :  [ coords . x , coords . y , coords . x2 , coords . y2 ]  , size : size }  ]%NWL%}  ; %NWL%var options =  {%NWL%success : function ( model , res )  {%NWL%view . destroy (  )  ; %NWL%var image = res . images . image%NWL%image . url = image . url +  ' ? '  + new Date (  )  . valueOf (  )  ; %NWL%image . url_local = image . url_local +  ' ? '  + new Date (  )  . valueOf (  )  ; %NWL%9
if ( settings =  = undefined )  {%NWL%settings =  {  }  ;%NWL%}%NWL%if ( !settings . closeOnDeactivate )  {%NWL%settings . closeOnDeactivate = activator . defaults . closeOnDeactivate ;%NWL%}%NWL%if ( !settings . beforeActivate )  {%NWL%settings . beforeActivate = activator . defaults . beforeActivate ;%NWL%}%NWL%if ( !settings . afterDeactivate )  {%NWL%settings . afterDeactivate = activator . defaults . afterDeactivate ; %NWL%4
}%NWL%}  )  ; %NWL%Mesh . POINTS = glenum . POINTS ; %NWL%Mesh . LINES = glenum . LINES ; %NWL%Mesh . LINE_LOOP = glenum . LINE_LOOP ; %NWL%Mesh . LINE_STRIP = glenum . LINE_STRIP ; %NWL%Mesh . TRIANGLES = glenum . TRIANGLES ; %NWL%Mesh . TRIANGLE_STRIP = glenum . TRIANGLE_STRIP ; %NWL%Mesh . TRIANGLE_FAN = glenum . TRIANGLE_FAN ; %NWL%Mesh . BACK = glenum . BACK ; %NWL%Mesh . FRONT = glenum . FRONT ; %NWL%2
this . callback = element . callback||element . getAttribute (  ' callback '  )  ; %NWL%break ; %NWL%case " select - one "  : %NWL%case " select - multiple "  : %NWL%this . values = new Array (  )  ; %NWL%for ( var i = 0 ; i < element . options . length ;  +  + i )  {%NWL%if ( element . options [ i ]  . selected&& ( !this . exclude||element . options [ i ]  . value! = this . exclude )  )  {%NWL%this . values [ this . values . length ]  = element . options [ i ]  . value ;%NWL%}%NWL%}%NWL%this . min = element . min||element . getAttribute (  ' min '  )  ; %NWL%0
if ( typeof adjustments . opacity =  =  ' undefined '  )  {%NWL%adjustments . opacity = 1 ;%NWL%}%NWL%if ( typeof adjustments . hue ! =  =  ' undefined ' ||%NWL%typeof adjustments . saturation ! =  =  ' undefined ' ||%NWL%typeof adjustments . lightness ! =  =  ' undefined '  )  {%NWL%this . toHSL (  )  ;%NWL%}%NWL%adjustments . hue = 1 * adjustments . hue || 0 ; %NWL%adjustments . saturation = 1 * adjustments . saturation || 0 ; %NWL%adjustments . lightness = 1 * adjustments . lightness || 0 ; %NWL%8
var scale = o . options . scale || ' both '  ;  /  / Default scale mode%NWL%var origin = o . options . origin ;  /  / The origin of the sizing%NWL%var original =  { height : el . height (  )  , width : el . width (  )  }  ;  /  / Save original%NWL%el . from = o . options . from || original ;  /  / Default from state%NWL%el . to = o . options . to || original ;  /  / Default to state%NWL%if ( origin )  {  /  / Calculate baseline shifts%NWL%var baseline = $ . effects . getBaseline ( origin , original )  ; %NWL%el . from . top =  ( original . height - el . from . height )  * baseline . y ; %NWL%el . from . left =  ( original . width - el . from . width )  * baseline . x ; %NWL%el . to . top =  ( original . height - el . to . height )  * baseline . y ; %NWL%el . to . left =  ( original . width - el . to . width )  * baseline . x ; %NWL%8
this . OnMove = new eg . EventHandler1 (  )  ;%NWL%}%NWL%ShipMovementController . prototype . LoadPayload = function ( payload , forceMovement )  {%NWL%if ( !forceMovement )  {%NWL%this . _interpolationManager . LoadPayload ( payload )  ;%NWL%} else {%NWL%this . Position = payload . Position ; %NWL%this . Rotation = payload . Rotation ;%NWL%}%NWL%if ( !this . UserControlled || forceMovement )  {%NWL%this . Mass = payload . Mass ; %NWL%6
if ( opt . offset )  {%NWL%if ( typeof opt . offset =  =  =  ' function '  )  {%NWL%opt . offset =  ( function ( org )  {  /  / wrap with setCenter%NWL%return function (  )  {%NWL%var that = this ;  /  / specified by caller .%NWL%return org . call ( that , function (  )  { setCenter . call ( that )  ;  }  )  ;%NWL%}  ;%NWL%}  )  ( opt . offset )  ;%NWL%} else {  /  / static%NWL%cssProp . left = opt . offset . left ; %NWL%cssProp . top = opt . offset . top ; %NWL%9
container . splice ( idx , 1 )  ;%NWL%}%NWL%$scope . removeMainAgg = function ( agg , id )  {%NWL%aggFactory . removeMainAgg ( agg , id )  ;%NWL%}%NWL%$scope . changeAggType = function ( agg , idx )  {%NWL%if ( typeof ( idx ) ! =  " undefined " && idx ! = null && idx >  = 0 )  {%NWL%agg . type = $scope . data . aggList [ idx ]  . type ; %NWL%agg . displayTemplate = $scope . data . aggList [ idx ]  . template ; %NWL%agg . resultTemplate = $scope . data . aggList [ idx ]  . resultTemplate ; %NWL%agg . officialDoc = $scope . data . aggList [ idx ]  . officialDoc ; %NWL%7
Proj4js . Proj . poly =  {%NWL%init : function (  )  {%NWL%var temp ; %NWL%if ( this . lat0 = 0 ) this . lat0 = 90 ;  /  / this . lat0 ca%NWL%this . temp = this . b / this . a ; %NWL%this . es = 1 . 0 - Math . pow ( this . temp , 2 )  ;  /  / devait etre dans tmerc . js mais n y est pas donc je commente sinon retour de valeurs nulles%NWL%this . e = Math . sqrt ( this . es )  ; %NWL%this . e0 = Proj4js . common . e0fn ( this . es )  ; %NWL%this . e1 = Proj4js . common . e1fn ( this . es )  ; %NWL%this . e2 = Proj4js . common . e2fn ( this . es )  ; %NWL%this . e3 = Proj4js . common . e3fn ( this . es )  ; %NWL%7
inx -  -  ; %NWL%var f01 =  {%NWL%x : ct . cvs [ inx ]  [ 0 ]  ,%NWL%y : ct . cvs [ inx ]  [ 1 ]%NWL%}  ; %NWL%var m11 = frct . x * frct . y ,%NWL%m10 = frct . x *  ( 1 - frct . y )  ,%NWL%m00 =  ( 1 - frct . x )  *  ( 1 - frct . y )  ,%NWL%m01 =  ( 1 - frct . x )  * frct . y ; %NWL%val . x =  ( m00 * f00 . x + m10 * f10 . x + m01 * f01 . x + m11 * f11 . x )  ; %NWL%val . y =  ( m00 * f00 . y + m10 * f10 . y + m01 * f01 . y + m11 * f11 . y )  ; %NWL%9
}  ,%NWL%applyState : function ( state )  {%NWL%this . widgetGuid = state . widgetGuid ; %NWL%this . uniqueId = state . uniqueId ; %NWL%this . name = state . name ; %NWL%this . active = state . active ; %NWL%this . width = state . width ; %NWL%this . height = state . height ; %NWL%this . x = state . x ; %NWL%this . y = state . y ; %NWL%this . zIndex = state . zIndex ; %NWL%2
e . preventDefault (  )  ; %NWL%document . getElementById (  ' stop - recording '  )  . disabled = true ; %NWL%document . getElementById (  ' start - recording '  )  . disabled = false ; %NWL%stopRecording (  )  ;%NWL%}%NWL%}  ; %NWL%function startRecording (  )  {%NWL%console . log (  " Begin Recording "  )  ; %NWL%videoElement = document . getElementById (  ' live_video '  )  ; %NWL%videoCanvas . width = videoElement . width ; %NWL%videoCanvas . height = videoElement . height ; %NWL%9
ionic . tap . hasCheckedClone = true ; %NWL%ionic . requestAnimationFrame ( function (  )  {%NWL%var focusInput = container . querySelector (  '  : focus '  )  ; %NWL%if ( ionic . tap . isTextInput ( focusInput )  )  {%NWL%var clonedInput = focusInput . cloneNode ( true )  ; %NWL%clonedInput . value = focusInput . value ; %NWL%clonedInput . classList . add (  ' cloned - text - input '  )  ; %NWL%clonedInput . readOnly = true ; %NWL%if ( focusInput . isContentEditable )  {%NWL%clonedInput . contentEditable = focusInput . contentEditable ; %NWL%clonedInput . innerHTML = focusInput . innerHTML ; %NWL%5
var _sharingTime = function ( data )  {%NWL%_people = data . people ; %NWL%_focus = data . focus ; %NWL%_focusPerson = _findPerson ( _focus )  ; %NWL%_initialize (  )  ; %NWL%var self = this ; %NWL%this . addBlankFather = _addBlankFather ; %NWL%this . addBlankMother = _addBlankMother ; %NWL%this . addBlankParents = _addBlankParents ; %NWL%this . addListener = _addListener ; %NWL%this . findAncestors = _findAncestors ; %NWL%6
Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%proxy . stopImmediatePropagation = proto . stopImmediatePropagation ; %NWL%6
service . e . triggerHandler (  " refresh "  ,  [ constraints ]  )  ; %NWL%return $q . all ( constraints . promises )  . then ( function (  )  {%NWL%service . mediaConstraints ( constraints )  ; %NWL%service . pcConstraints ( constraints )  ;%NWL%}  )  ;%NWL%}  ,%NWL%turn : function ( turnData )  {%NWL%service . turn = turnData ;%NWL%}  ,%NWL%stun : function ( stunData )  {%NWL%service . stun = stunData ; %NWL%7
NAMESPACE :  ' Thoth '  ,%NWL%VERSION :  ' 0 . 1 . 0 '%NWL%}  )  ; %NWL%Thoth . SocketIO = require ( corePath +  '  / SocketIO '  )  . SocketIO ; %NWL%Thoth . UserCache = require ( corePath +  '  / UserCache '  )  . UserCache ; %NWL%Thoth . Auth = require ( corePath +  '  / Auth '  )  . Auth ; %NWL%Thoth . FileAuth = require ( libPath +  '  / FileAuth '  )  . FileAuth ; %NWL%Thoth . Session = require ( corePath +  '  / Session '  )  . Session ; %NWL%Thoth . Store = require ( corePath +  '  / Store '  )  . Store ; %NWL%Thoth . WrapperStore = require ( corePath +  '  / WrapperStore '  )  . WrapperStore ; %NWL%Thoth . ApplicationStore = require ( corePath +  '  / ApplicationStore '  )  . ApplicationStore ; %NWL%3
Value . hack ( require (  '  .  / hacks / flex - values '  )  )  ; %NWL%Value . hack ( require (  '  .  / hacks / display - flex '  )  )  ; %NWL%Value . hack ( require (  '  .  / hacks / filter - value '  )  )  ; %NWL%Value . hack ( require (  '  .  / hacks / fill - available '  )  )  ; %NWL%Value . hack ( require (  '  .  / hacks / transform - value '  )  )  ; %NWL%declsCache =  {  }  ; %NWL%Prefixes =  ( function (  )  {%NWL%function Prefixes ( _at_data , _at_browsers , _at_options )  {%NWL%var _ref ; %NWL%this . data = _at_data ; %NWL%this . browsers = _at_browsers ; %NWL%9
Y . extend ( IEEventFacade , Y . DOM2EventFacade , proto )  ; %NWL%Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%8
callback = type_ ;%NWL%}%NWL%if ( typeof resolver =  =  =  ' function '  )  {%NWL%return resolver ( domain , callback )  ;%NWL%} else {%NWL%throw new Error (  ' Unknown type "  '  + type_ +  '  "  '  )  ;%NWL%}%NWL%}  ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%8
if ( this . _private . styleEnabled )  {%NWL%json . style = cy . style (  )  . json (  )  ;%NWL%}%NWL%json . zoomingEnabled = cy . _private . zoomingEnabled ; %NWL%json . userZoomingEnabled = cy . _private . userZoomingEnabled ; %NWL%json . zoom = cy . _private . zoom ; %NWL%json . minZoom = cy . _private . minZoom ; %NWL%json . maxZoom = cy . _private . maxZoom ; %NWL%json . panningEnabled = cy . _private . panningEnabled ; %NWL%json . userPanningEnabled = cy . _private . userPanningEnabled ; %NWL%json . pan = cy . _private . pan ; %NWL%3
Event . prototype . _update = function (  )  {%NWL%this . _latestTime = this . deadline + this . toleranceLate%NWL%this . _earliestTime = this . deadline - this . toleranceEarly%NWL%this . clock . _removeEvent ( this )%NWL%this . clock . _insertEvent ( this )%NWL%}%NWL%var WAAClock = module . exports = function ( context , opts )  {%NWL%var self = this%NWL%opts = opts || {  }%NWL%this . toleranceEarly = opts . toleranceEarly || CLOCK_DEFAULTS . toleranceEarly%NWL%this . toleranceLate = opts . toleranceLate || CLOCK_DEFAULTS . toleranceLate%NWL%9
var extension = data . substr ( data . lastIndexOf (  '  .  '  )  )  ; %NWL%var size =  { x : value . width , y : value . height }  ; %NWL%if ( value . width =  = 0 )  {%NWL%size . x = window . getComputedStyle ( value , null )  . maxWidth ; %NWL%size . x = size . x . replace (  ' px '  ,  '  '  )  ; %NWL%size . x = Number ( size . x )  ;%NWL%}%NWL%if ( value . height =  = 0 )  {%NWL%size . y = window . getComputedStyle ( value , null )  . maxHeight ; %NWL%size . y = size . y . replace (  ' px '  ,  '  '  )  ; %NWL%size . y = Number ( size . y )  ; %NWL%5
log (  ' Profile updated '  )  ; %NWL%user . load (  ' me '  )  ; %NWL%var self = this ; %NWL%user . once (  ' loaded '  , function (  )  {%NWL%self . find (  ' img '  )  . attr (  ' src '  , user . profilePicture (  )  )  ;%NWL%}  )  ; %NWL%this . messages (  [ t (  ' Your profile was successfuly updated '  )  ]  ,  ' success '  )  ;%NWL%}%NWL%ProfileForm . prototype . postserialize = function ( data )  {%NWL%data . firstName = data . firstName . trim (  )  . replace (  / \s +  / g ,  '  '  )  ; %NWL%data . lastName = data . lastName . trim (  )  . replace (  / \s +  / g ,  '  '  )  ; %NWL%9
sensorDefinitions . goLinkTemperature . sensorName = i18n . t (  " sensor . names . goLinkTemperature "  )  ; %NWL%sensorDefinitions . goLinkLight . measurementName = i18n . t (  " sensor . measurements . light_intensity "  )  ; %NWL%sensorDefinitions . goLinkLight . sensorName = i18n . t (  " sensor . names . goLinkLight "  )  ; %NWL%sensorDefinitions . goLinkForce . measurementName = i18n . t (  " sensor . measurements . force "  )  ; %NWL%sensorDefinitions . goLinkForce . sensorName = i18n . t (  " sensor . names . goLinkForce "  )  ; %NWL%sensorDefinitions . goLinkPH . measurementName = i18n . t (  " sensor . measurements . acidity "  )  ; %NWL%sensorDefinitions . goLinkPH . sensorName = i18n . t (  " sensor . names . goLinkPH "  )  ; %NWL%sensorDefinitions . goLinkCO2 . measurementName = i18n . t (  " sensor . measurements . CO2_concentration "  )  ; %NWL%sensorDefinitions . goLinkCO2 . sensorName = i18n . t (  " sensor . names . goLinkCO2 "  )  ; %NWL%sensorDefinitions . goLinkO2 . measurementName = i18n . t (  " sensor . measurements . O2_concentration "  )  ; %NWL%sensorDefinitions . goLinkO2 . sensorName = i18n . t (  " sensor . names . goLinkO2 "  )  ; %NWL%0
eventData =  {  }  ,%NWL%conf =  {%NWL%on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%9
}  ,%NWL%reposition : function ( elem )  {%NWL%if ( elem )  {%NWL%this . domElement = ZeroClipboard_TableTools . $ ( elem )  ; %NWL%if ( !this . domElement ) this . hide (  )  ;%NWL%}%NWL%if ( this . domElement && this . div )  {%NWL%var box = ZeroClipboard_TableTools . getDOMObjectPosition ( this . domElement )  ; %NWL%var style = this . div . style ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%9
context . Fiber = Fiber ; %NWL%context . fixtures =  {%NWL%registerFileAs : fixtures . registerFileAs . bind ( fixtures )  ,%NWL%}  ; %NWL%var originalIt = context . it ; %NWL%context . it = runInsideFiber ( context . it )  ; %NWL%context . it . skip = runInsideFiber ( originalIt . skip )  ; %NWL%context . it . only = runInsideFiber ( originalIt . only )  ; %NWL%context . specify = context . it ; %NWL%context . xspecify = context . xit = context . it . skip ; %NWL%context . before = runInsideFiber ( context . before )  ; %NWL%5
n_xticks : 10 ,%NWL%n_yticks : 10 ,%NWL%stroke :  " white "  ,%NWL%stroke_width :  " 1 . 5px "  ,%NWL%fill :  " black "  ,%NWL%stroke_opacity : 1 . 0 ,%NWL%fill_opacity : 1 . 0%NWL%}  )  ; %NWL%opts . stroke = enforce_function ( opts . stroke )  ; %NWL%opts . stroke_opacity = enforce_function ( opts . stroke_opacity )  ; %NWL%opts . stroke_width = enforce_function ( opts . stroke_width )  ; %NWL%8
var env ;%NWL%( function (  )  {%NWL%env =  {  }  ; %NWL%env . init = function ( dynamicEnv )  {%NWL%this . nodePath = dynamicEnv . nodePath ; %NWL%this . commandProxyClientPath = dynamicEnv . commandProxyClientPath ; %NWL%this . instrumentsSock = dynamicEnv . instrumentsSock ; %NWL%this . interKeyDelay = dynamicEnv . interKeyDelay ; %NWL%this . justLoopInfinitely = dynamicEnv . justLoopInfinitely ; %NWL%this . autoAcceptAlerts = dynamicEnv . autoAcceptAlerts ; %NWL%this . autoDismissAlerts = dynamicEnv . autoDismissAlerts ; %NWL%4
}  ; %NWL%this . sayErr (  " No member named '  "  +  ( name )  +  "  ' on "  +  ( this . info (  )  )  )  ;%NWL%}  ; %NWL%NameDeclaration . prototype . replaceForward = function ( realNameDecl )  {%NWL%var list__1 = Object . keys ( realNameDecl . members )  ; %NWL%for ( var member__inx = 0 , member = undefined ; member__inx < list__1 . length ; member__inx +  +  )  { member = list__1 [ member__inx ]  ; %NWL%this . addMember ( member ,  { replaceSameName : true }  )  ;%NWL%}  ;  /  / end for each in Object . keys ( realNameDecl . members )%NWL%this . isForward = realNameDecl . isForward ; %NWL%if ( realNameDecl . nodeDeclared )  {%NWL%this . nodeDeclared = realNameDecl . nodeDeclared ; %NWL%8
. then ( function ( result )  {%NWL%if ( result =  =  =  ' ok '  )  {%NWL%snapRemote . open (  ' right '  )  ;%NWL%}%NWL%}  )  ; %NWL%return ;%NWL%}%NWL%vm . invoiceAddress  = result . invoiceAddress ; %NWL%vm . shippingAddress  = result . shippingAddress ; %NWL%vm . paymentMethod  = result . response . paymentMethod ; %NWL%vm . shippingMethod  = result . response . shippingMethod ; %NWL%9
paramObject . jquery = windmill . helpers . replaceAll ( paramObject . jquery ,  "  )  .  "  ,  "  )  <  *  >  "  )  ; %NWL%var jQ = jQuery ( windmill . testWin (  )  . document )  ; %NWL%var chain = paramObject . jquery . split (  '  <  *  >  '  )  ; %NWL%paramObject . jquery = windmill . helpers . replaceAll ( paramObject . jquery ,  "  <  *  >  "  ,  "  .  "  )  ; %NWL%var start = eval (  ' jQ . find '  + chain [ 0 ]  )  ; %NWL%var theRest = paramObject . jquery . replace ( chain [ 0 ]  ,  '  '  )  ; %NWL%element = eval (  ' start '  + theRest )  ;%NWL%}%NWL%else if ( typeof paramObject . jqueryframe ! =  " undefined " && typeof paramObject . frameid ! =  " undefined "  )  {%NWL%s =  ' Looking up jqueryframe selector '  + paramObject . jqueryframe ; %NWL%paramObject . jqueryframe = windmill . helpers . replaceAll ( paramObject . jqueryframe ,  "  )  .  "  ,  "  )  <  *  >  "  )  ; %NWL%0
consume (  ' search '  ,   / ^\? [ ^# ]  *  /  )  ; %NWL%consume (  ' hash '  ,   / ^# .  *  /  )  ; %NWL%uri . protocol = uri . protocol || Faye . ENV . location . protocol ; %NWL%if ( uri . host )  {%NWL%uri . host  = uri . host . substr ( 2 )  ; %NWL%parts   = uri . host . split (  '  :  '  )  ; %NWL%uri . hostname = parts [ 0 ]  ; %NWL%uri . port  = parts [ 1 ] || '  '  ;%NWL%} else {%NWL%uri . host  = Faye . ENV . location . host ; %NWL%uri . hostname = Faye . ENV . location . hostname ; %NWL%9
return this . wheelWidth ;%NWL%}  ,%NWL%setWheelRotation : function ( wheelRotation_in )  {%NWL%this . wheelRotation = wheelRotation_in ; %NWL%this . wheelRef . setRotation ( wheelRotation )  ;%NWL%}  ,%NWL%getWheelRotation : function (  )  {%NWL%return this . wheelRotation ;%NWL%}  ,%NWL%setWheelPosition : function ( wheelPosition_in )  {%NWL%this . wheelPosition = wheelPosition_in ; %NWL%3
for ( i = 0 , l = selfAttrs . length ; i < l ; i +  +  )  {%NWL%selfAttr = selfAttrs [ i ]  ; %NWL%if ( selfAttr . name ! =  =  ' id '  )  {%NWL%cloneAttrs [ cloneAttrs . length ]  =  { name : selfAttr . name , value : selfAttr . value }  ; %NWL%cloneAttrs . map [ selfAttr . name ]  = selfAttr . value ;%NWL%}%NWL%}%NWL%clone . attributes = cloneAttrs ;%NWL%}%NWL%clone . value = self . value ; %NWL%clone . shortEnded = self . shortEnded ; %NWL%9
if ( !pagin )  {%NWL%return paginationForm ;%NWL%}%NWL%if ( pagin . count ! = null )  {%NWL%paginationForm . count = pagin . count ;%NWL%}%NWL%if ( pagin . start ! = null )  {%NWL%paginationForm . start = pagin . start ;%NWL%}%NWL%if ( pagin . paginationLimit ! = null )  {%NWL%paginationForm . paginationLimit = pagin . paginationLimit ; %NWL%4
o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%0
}%NWL%SwaggerApi . prototype . build = function (  )  {%NWL%var _this = this ; %NWL%this . progress (  ' fetching resource list :  '  + this . discoveryUrl )  ; %NWL%return jQuery . getJSON ( this . discoveryUrl , function ( response )  {%NWL%var res , resource , _i , _j , _len , _len1 , _ref , _ref1 ; %NWL%if ( response . apiVersion ! = null )  {%NWL%_this . apiVersion = response . apiVersion ;%NWL%}%NWL%if (  ( response . basePath ! = null ) && jQuery . trim ( response . basePath )  . length > 0 )  {%NWL%_this . basePath = response . basePath ; %NWL%7
var decoded = app . encoding . decode ( encoded )  ; %NWL%var data = decoded . split (  '  '  )  . map ( function ( char )  {%NWL%return encoder . indexOf ( char )  ;%NWL%}  )  ; %NWL%var beardPoints = this . drawInitialCloth (  )  ; %NWL%for ( var i = 0 ; i < beardPoints . length ; i +  +  )  {%NWL%beardPoints [ i ]  . draw = beardPoints [ i ]  . constrain = data [ i ]  > 0 ; %NWL%var spray = Math . floor (  ( data [ i ]  - 1 )  / 5 )  ; %NWL%beardPoints [ i ]  . spray = spray > 0 ? sprays [ spray - 1 ]  : undefined ; %NWL%var decoration =  ( data [ i ]  - 1 ) % 5 ; %NWL%beardPoints [ i ]  . decoration = decoration > 0 ? decorations [ decoration - 1 ]  : undefined ; %NWL%8
var imageFileInfo =  {%NWL%filepath : imageFilePath ,%NWL%classname : ifh . getClassname ( imageFilePath )  ,%NWL%queries : ifh . getMediaQueries ( imageFilePath )%NWL%}  ; %NWL%im ( imageFilePath )  . size ( function ( err , size )  {%NWL%if ( err )  {%NWL%return callback . call ( null , err , null )  ;%NWL%}%NWL%imageFileInfo . width = size . width ; %NWL%imageFileInfo . height = size . height ; %NWL%9
config = _ . merge ( _ . clone ( Inspector . DEFAULT_CONFIG , true )  , config )  ; %NWL%this . entryPoint = config . entryPoint ; %NWL%this . displayName = config . displayName ; %NWL%this . src = config . src ; %NWL%this . forbiddenTokens =  [ config . forbiddenTokens , config . additionalForbiddenTokens ]%NWL%. filter ( function ( token )  {%NWL%return !!token ;%NWL%}  )%NWL%. join (  ' | '  )  ; %NWL%this . dirty = true ; %NWL%this . debug = config . debug ; %NWL%1
this . degraded = true ;%NWL%}%NWL%cfg . mbox = cfg . mbox [ 0 ]  ;%NWL%}%NWL%if ( typeof cfg . mbox_sha1sum =  =  =  " object " && cfg . mbox_sha1sum ! =  = null )  {%NWL%if ( cfg . mbox_sha1sum . length > 1 )  {%NWL%this . degraded = true ;%NWL%}%NWL%cfg . mbox_sha1sum = cfg . mbox_sha1sum [ 0 ]  ;%NWL%}%NWL%if ( typeof cfg . openid =  =  =  " object " && cfg . openid ! =  = null )  {%NWL%4
return {%NWL%templateUrl :  ' portal / list . html '  ,%NWL%restrict :  ' EA '  ,%NWL%transclude : true ,%NWL%scope : true ,%NWL%link : function link ( scope , element , attrs , controller , transclude )  {%NWL%scope . scope = scope . $parent . $eval ( attrs . scope )  ; %NWL%scope . table = scope . $parent . $eval ( attrs . gandhiList )  ; %NWL%scope . limit = scope . $parent . $eval ( attrs . limit )  ; %NWL%scope . srefBase  = scope . $parent . $eval ( attrs . srefBase )  ; %NWL%scope . srefParam = scope . $parent . $eval ( attrs . srefParam )  ; %NWL%8
pointerdown : 1 ,%NWL%pointerup : 1 ,%NWL%pointermove : 1 ,%NWL%pointercancel : 1%NWL%}  )  ;%NWL%}%NWL%if (  ( win && (  " ontouchstart " in win )  ) && ! ( Y . UA . chrome && Y . UA . chrome < 6 )  )  {%NWL%GESTURE_MAP . start =  [  " touchstart "  ,  " mousedown "  ]  ; %NWL%GESTURE_MAP . end =  [  " touchend "  ,  " mouseup "  ]  ; %NWL%GESTURE_MAP . move =  [  " touchmove "  ,  " mousemove "  ]  ; %NWL%GESTURE_MAP . cancel =  [  " touchcancel "  ,  " mousecancel "  ]  ; %NWL%9
input . readStructEnd (  )  ; %NWL%return ;%NWL%}  ; %NWL%EDAMNotFoundException . prototype . write = function ( output )  {%NWL%output . writeStructBegin (  ' EDAMNotFoundException '  )  ; %NWL%if ( this . identifier ! =  = null && this . identifier ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' identifier '  , Thrift . Type . STRING , 1 )  ; %NWL%output . writeString ( this . identifier )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . key ! =  = null && this . key ! =  = undefined )  {%NWL%5
if ( t . settings [  ' syntax '  ]  )%NWL%t . allready_used_syntax [ t . settings [  ' syntax '  ]  ]  = true ;%NWL%}  ; %NWL%EditArea . prototype . init = function (  )  {%NWL%var t = this , a , s = t . settings ; %NWL%t . textarea			 = _$ (  " textarea "  )  ; %NWL%t . container			 = _$ (  " container "  )  ; %NWL%t . result			 = _$ (  " result "  )  ; %NWL%t . content_highlight	 = _$ (  " content_highlight "  )  ; %NWL%t . selection_field	 = _$ (  " selection_field "  )  ; %NWL%t . selection_field_text = _$ (  " selection_field_text "  )  ; %NWL%5
var Range = require (  " ace / range "  )  . Range ; %NWL%var EventEmitter = require (  " ace / lib / event_emitter "  )  . EventEmitter ; %NWL%var HoverLink = function ( editor )  {%NWL%if ( editor . hoverLink )%NWL%return ; %NWL%editor . hoverLink = this ; %NWL%this . editor = editor ; %NWL%this . update = this . update . bind ( this )  ; %NWL%this . onMouseMove = this . onMouseMove . bind ( this )  ; %NWL%this . onMouseOut = this . onMouseOut . bind ( this )  ; %NWL%this . onClick = this . onClick . bind ( this )  ; %NWL%7
THREE . MeshLambertMaterial . prototype . constructor = THREE . MeshLambertMaterial ; %NWL%THREE . MeshLambertMaterial . prototype . clone = function (  )  {%NWL%var material = new THREE . MeshLambertMaterial (  )  ; %NWL%THREE . Material . prototype . clone . call ( this , material )  ; %NWL%material . color . copy ( this . color )  ; %NWL%material . emissive . copy ( this . emissive )  ; %NWL%material . wrapAround = this . wrapAround ; %NWL%material . wrapRGB . copy ( this . wrapRGB )  ; %NWL%material . map = this . map ; %NWL%material . lightMap = this . lightMap ; %NWL%material . specularMap = this . specularMap ; %NWL%6
defaultFunc . reset (  )  ;%NWL%} else {%NWL%hasOnePassingSelector = true ;%NWL%}%NWL%var rules = this . rules ? this . rules . slice ( 0 )  : null ,%NWL%ruleset = new Ruleset ( selectors , rules , this . strictImports )  ,%NWL%rule , subRule ; %NWL%ruleset . originalRuleset = this ; %NWL%ruleset . root = this . root ; %NWL%ruleset . firstRoot = this . firstRoot ; %NWL%ruleset . allowImports = this . allowImports ; %NWL%8
coreHelpers . meta_description = require (  '  .  / meta_description '  )  ; %NWL%coreHelpers . meta_title = require (  '  .  / meta_title '  )  ; %NWL%coreHelpers . navigation = require (  '  .  / navigation '  )  ; %NWL%coreHelpers . page_url = require (  '  .  / page_url '  )  ; %NWL%coreHelpers . pageUrl = require (  '  .  / page_url '  )  . deprecated ; %NWL%coreHelpers . pagination = require (  '  .  / pagination '  )  ; %NWL%coreHelpers . plural = require (  '  .  / plural '  )  ; %NWL%coreHelpers . post_class = require (  '  .  / post_class '  )  ; %NWL%coreHelpers . tags = require (  '  .  / tags '  )  ; %NWL%coreHelpers . title = require (  '  .  / title '  )  ; %NWL%coreHelpers . url = require (  '  .  / url '  )  ; %NWL%0
return merged ;%NWL%}%NWL%if ( !Array . isArray ( err ) && typeof err =  =  =  ' object '  )  {%NWL%Object . keys ( err )  . forEach ( function ( key )  {%NWL%if (  [  ' stack '  ,  ' type '  ,  ' arguments '  ,  ' message '  ]  . indexOf ( key )  =  =  =  - 1 )  {%NWL%merged [ key ]  = err [ key ]  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%merged . name = merged . name || err . name ; %NWL%merged . message = merged . message || err . message ; %NWL%9
return {%NWL%init : function ( data )  {%NWL%this . x = 0 ; %NWL%this . y = data . order * C . ITEM_HEIGHT ; %NWL%this . data = data ; %NWL%this . render (  )  ; %NWL%this . style = this . el [ 0 ]  . style ; %NWL%this . slider = this . el . find (  '  . slider '  )  ; %NWL%this . sliderStyle = this . slider [ 0 ]  . style ; %NWL%this . check = $ (  '  < img class =  " check drag " src =  " img / check . png "  >  '  )  ; %NWL%this . cross = $ (  '  < img class =  " cross drag " src =  " img / cross . png "  >  '  )  ; %NWL%9
route : this . route ,%NWL%error : this . error ,%NWL%globals : this . globals%NWL%}  ;%NWL%}  ,%NWL%dehydrate : function (  )  {%NWL%return this . getState (  )  ;%NWL%}  ,%NWL%rehydrate : function ( state )  {%NWL%this . route = state . route ; %NWL%this . error = state . error ; %NWL%9
context . translate ( dimensions . left , dimensions . top )  ; %NWL%context . beginPath (  )  ; %NWL%context . rect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . clip (  )  ; %NWL%context . save (  )  ; %NWL%context . fillStyle = chartOptions . grid . fillStyle ; %NWL%context . clearRect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . fillRect ( 0 , 0 , dimensions . width , dimensions . height )  ; %NWL%context . restore (  )  ; %NWL%context . save (  )  ; %NWL%context . lineWidth = chartOptions . grid . lineWidth ; %NWL%5
var spritesheetjs =  function ( options )  {%NWL%if ( options . images && options . source_dir )  {%NWL%throw " Pass the source dir OR the image paths array , not both .  "  ;%NWL%}%NWL%if ( !options . selector )  {%NWL%options . selector =  "  "  ;%NWL%}%NWL%this . selector = options . selector ; %NWL%this . source_dir = options . source_dir ; %NWL%this . images = options . images ; %NWL%this . sprite_path = options . sprite_path ; %NWL%7
if ( isDefined ( options . type )  )  {%NWL%this . setDrawScalebarFunction ( options . type )  ;%NWL%}%NWL%if ( isDefined ( options . minWidth )  )  {%NWL%this . setMinWidth ( options . minWidth )  ;%NWL%}%NWL%if ( isDefined ( options . color )  )  {%NWL%this . color = options . color ;%NWL%}%NWL%if ( isDefined ( options . fontColor )  )  {%NWL%this . fontColor = options . fontColor ; %NWL%7
if ( Object . keys ( this . _flags )  . length )  {%NWL%description . flags = this . _flags ;%NWL%}%NWL%if ( this . _description )  {%NWL%description . description = this . _description ;%NWL%}%NWL%if ( this . _notes . length )  {%NWL%description . notes = this . _notes ;%NWL%}%NWL%if ( this . _tags . length )  {%NWL%description . tags = this . _tags ; %NWL%1
if ( !window . opener || !WebInspector . queryParam (  " toolbox "  )  )%NWL%return ; %NWL%WebInspector . zoomManager = new WebInspector . ZoomManager ( window . opener . InspectorFrontendHost )  ; %NWL%WebInspector . overridesSupport = window . opener . WebInspector . overridesSupport ; %NWL%WebInspector . settings = window . opener . WebInspector . settings ; %NWL%WebInspector . experimentsSettings = window . opener . WebInspector . experimentsSettings ; %NWL%WebInspector . targetManager = window . opener . WebInspector . targetManager ; %NWL%WebInspector . workspace = window . opener . WebInspector . workspace ; %NWL%WebInspector . cssWorkspaceBinding = window . opener . WebInspector . cssWorkspaceBinding ; %NWL%WebInspector . Revealer = window . opener . WebInspector . Revealer ; %NWL%WebInspector . ContextMenu = window . opener . WebInspector . ContextMenu ; %NWL%3
$ . jqplot . preInitHooks . push ( $ . jqplot . Highlighter . init )  ; %NWL%$ . jqplot . preParseSeriesOptionsHooks . push ( $ . jqplot . Highlighter . parseOptions )  ; %NWL%$ . jqplot . postDrawHooks . push ( $ . jqplot . Highlighter . postPlotDraw )  ; %NWL%function draw ( plot , neighbor )  {%NWL%var hl = plot . plugins . highlighter ; %NWL%var s = plot . series [ neighbor . seriesIndex ]  ; %NWL%var smr = s . markerRenderer ; %NWL%var mr = hl . markerRenderer ; %NWL%mr . style = smr . style ; %NWL%mr . lineWidth = smr . lineWidth + hl . lineWidthAdjust ; %NWL%mr . size = smr . size + hl . sizeAdjust ; %NWL%9
query . id_app = id_app ; %NWL%if ( req . query . q )  {%NWL%var q = eval (  "  (  "  + req . query . q +  "  )  "  )%NWL%underscore . extend ( query , q )%NWL%} else {%NWL%query . ngay_ct =  { $gte : req . query . tu_ngay , $lte : req . query . den_ngay }  ; %NWL%if ( req . query . dien_giai && req . query . dien_giai! =  '  '  )  {%NWL%query . dien_giai =  { $regex : req . query . dien_giai , $options :  ' i '  }  ;%NWL%}%NWL%if ( req . query . so_ct && req . query . so_ct! =  '  '  )  {%NWL%query . so_ct =  { $regex : req . query . so_ct , $options :  ' i '  }  ; %NWL%7
}%NWL%}%NWL%if ( !data . text . length && data . comment . length )  {%NWL%data . text = data . comment ; %NWL%data . comment =  [  ]  ;%NWL%}%NWL%if ( data . address . length > 1 )  {%NWL%data . text = data . text . concat ( data . address . splice ( 1 )  )  ;%NWL%}%NWL%data . text = data . text . join (  "  "  )  ; %NWL%data . address = data . address . join (  "  "  )  ; %NWL%9
} else {%NWL%opts . protocol =  ' ws '  ;%NWL%}%NWL%}%NWL%if ( !opts . hostname )  {%NWL%opts . hostnme = opts . host ;%NWL%}%NWL%if ( !opts . hostname )  {%NWL%opts . hostname = parsed . hostname ; %NWL%if ( !opts . port )  {%NWL%opts . port = parsed . port ; %NWL%8
}  )  ;%NWL%}  ; %NWL%var loggedUpdateDummyStream = function ( logCollection , tmpCollection , options )  {%NWL%return loggedTransformStream ( logCollection , options , function ( patch , callback )  {%NWL%applyUpdateDummy ( tmpCollection , patch , callback )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . logged =  {  }  ; %NWL%exports . patch = patchStream ; %NWL%exports . progress = progressStream ; %NWL%exports . updateUsingQuery = updateUsingQueryStream ; %NWL%8
var newBadge =  {  }  ; %NWL%newBadge . name = badge . name ; %NWL%newBadge . slug = badge . name . trim (  )  . toLowerCase (  )  . replace (  / \s +  / g ,  '  -  '  )  ; %NWL%newBadge . strapline = badge . description || '  '  ; %NWL%newBadge . imageUrl = config (  ' PERSONA_AUDIENCE '  )  +  '  / images / badge /  '  + badge . id ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . issuerUrl = badge . issuerUrl ; %NWL%newBadge . criteriaUrl = config (  ' PERSONA_AUDIENCE '  )  +  '  / system /  '  + badge . system +  '  / badge /  '  + newBadge . slug +  '  / criteria '  ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%1
datapoints . push ( datapoint )  ;%NWL%}%NWL%if ( maxlen <  = 0 )  {%NWL%datapoints . push (  { index : 0 }  )  ;%NWL%}%NWL%var store = new dojo . data . ItemFileWriteStore (  { data :  { identifier :  ' index '  , items : datapoints }  }  )  ; %NWL%if ( this . data . title )  {%NWL%store . title = this . data . title ;%NWL%}%NWL%if ( this . data . footer )  {%NWL%store . footer = this . data . footer ; %NWL%7
}%NWL%socket . on (  ' run '  , function ( js , fn )  {%NWL%try {%NWL%var rtn =  ( function (  )  { return eval . apply ( this , arguments )  ;  }  )  ( js )  ; %NWL%global . _ = rtn ; %NWL%fn ( null , inspect ( rtn ,  { colors : true }  )  )  ;%NWL%} catch ( e )  {%NWL%var err =  {  }  ; %NWL%for ( var i in e ) err [ i ]  = e [ i ]  ; %NWL%err . message = e . message ; %NWL%err . stack = e . stack ; %NWL%9
throw new Error (  " need at least 2 args "  )  ; %NWL%base = MozFile ( base )  ; %NWL%for ( var i = 1 ; i < arguments . length ; i +  +  )%NWL%base . append ( arguments [ i ]  )  ; %NWL%return base . path ;%NWL%}  ; %NWL%exports . dirname = function dirname ( path )  {%NWL%var parent = MozFile ( path )  . parent ; %NWL%return parent ? parent . path :  "  "  ;%NWL%}  ; %NWL%exports . basename = function basename ( path )  {%NWL%6
}%NWL%if ( h >  = 0 )  {%NWL%h = Math . max ( h - pb . h - mb . h , 0 )  ;%NWL%}%NWL%setBox ( node , box . l , box . t , w , h )  ;%NWL%}  ; %NWL%geom . isBodyLtr = function isBodyLtr ( doc )  {%NWL%doc = doc || win . doc ; %NWL%return ( win . body ( doc )  . dir || doc . documentElement . dir || " ltr "  )  . toLowerCase (  )  =  =  " ltr "  ;  /  / Boolean%NWL%}  ; %NWL%geom . docScroll = function docScroll ( doc )  {%NWL%6
MapRenderer . currentMap =  '  '  ; %NWL%if ( !success )  {%NWL%UIManager . showErrorBox ( DB . getMessage ( 1 )  )  ; %NWL%return ;%NWL%}%NWL%var pkt   = new PACKET . CZ . ENTER (  )  ; %NWL%pkt . AID   = Session . AID ; %NWL%pkt . GID   = Session . GID ; %NWL%pkt . AuthCode  = Session . AuthCode ; %NWL%pkt . clientTime = Date . now (  )  ; %NWL%pkt . Sex   = Session . Sex ; %NWL%6
_getLetter : function ( evt )  {%NWL%if ( !evt . meta && evt . keyCode >  = 65 && evt . keyCode <  = 90 )  {%NWL%return alphabet . charAt ( evt . keyCode - 65 )  ;%NWL%}%NWL%return null ;%NWL%}  ,%NWL%_mixin : function ( evt )  {%NWL%evt . meta = this . meta ; %NWL%evt . shift = this . shift ; %NWL%evt . alt = this . alt ; %NWL%evt . cmmd = this . cmmd ; %NWL%7
}  ; %NWL%return SiteServicesExplorer ;%NWL%}  (  )  )  ; %NWL%SitesRenderer =  ( function (  )  {%NWL%SitesRenderer . prototype = new mExplorer . SelectionRenderer (  )  ; %NWL%function SitesRenderer ( options , explorer )  {%NWL%this . _init ( options )  ; %NWL%this . options = options ; %NWL%this . explorer = explorer ; %NWL%this . registry = options . registry ; %NWL%this . commandService = options . commandService ; %NWL%9
this . tbSatern  = this . $getLayoutNode (  " main "  ,  " satern "  , this . $ext )  ; %NWL%this . tbLuminance = this . $getLayoutNode (  " main "  ,  " luminance "  , this . $ext )  ; %NWL%this . tbHexColor  = this . $getLayoutNode (  " main "  ,  " hex "  , this . $ext )  ; %NWL%var _self = this ; %NWL%this . tbHexColor . onchange = function (  )  {%NWL%_self . setValue ( this . value ,  " RGBHEX "  )  ;%NWL%}  ; %NWL%this . shower = this . $getLayoutNode (  " main "  ,  " shower "  , this . $ext )  ; %NWL%this . bar1  = this . $getLayoutNode (  " main "  ,  " bar1 "  , this . $ext )  ; %NWL%this . bgBar1 = this . $getLayoutNode (  " main "  ,  " bgbar1 "  , this . $ext )  ; %NWL%this . bar2  = this . $getLayoutNode (  " main "  ,  " bar2 "  , this . $ext )  ; %NWL%7
function eventListener ( el , fn , evt )  {%NWL%fn ( el , evt )  ;%NWL%}%NWL%var builtInFeature = emptyFn (  )  ; %NWL%builtInFeature . setup = function ( struct , builder )  {%NWL%listValues ( struct . properties )  . filter ( function ( property )  {%NWL%return property . delegate ;%NWL%}  )  . forEach ( function ( property )  {%NWL%if ( !property . attName )  {%NWL%property . set = property . set || emptyFn (  )  ; %NWL%property . get = property . get || emptyFn (  )  ; %NWL%9
}%NWL%}  )  ;%NWL%}  ,%NWL%truncate : function ( path , length , cb )  {%NWL%}  ,%NWL%stats : function ( path , cb )  {%NWL%traverse ( this . root , path , function ( err , entry )  {%NWL%if ( entry )  {%NWL%entry . getMetadata ( function ( meta )  {%NWL%meta . isFile = function (  )  { return entry . isFile }  ; %NWL%meta . isDirectory = function (  )  { return entry . isDirectory }  ; %NWL%9
var SB = Shadowbox ; %NWL%var SL = SB . lib ; %NWL%var C = SB . getClient (  )  ; %NWL%Shadowbox . qt = function ( id , obj )  {%NWL%this . id = id ; %NWL%this . obj = obj ; %NWL%this . height = this . obj . height ? parseInt ( this . obj . height , 10 )  : 300 ; %NWL%if ( SB . getOptions (  )  . showMovieControls =  = true )  {%NWL%this . height +  = 16 ;  /  / height of QuickTime controller%NWL%}%NWL%this . width = this . obj . width ? parseInt ( this . obj . width , 10 )  : 300 ; %NWL%6
return new Buffer ( encodeDict ( dict )  )  . toString (  ' base64 '  )%NWL%}%NWL%DigestMD5 . prototype . checkResponse = function ( s )  {%NWL%var dict = parseDict ( s )%NWL%this . authcid = this . username = dict . username%NWL%this . digestUri = dict [  ' digest - uri '  ]%NWL%if ( dict . nonce ! =  = this . nonce ) return false%NWL%if ( !dict . cnonce ) return false%NWL%if ( dict . nc )%NWL%this . nc = dict . nc%NWL%this . cnonce = dict . cnonce%NWL%9
return json ;%NWL%}  ; %NWL%Camera . prototype . fromJSON = function ( json )  {%NWL%Component . prototype . fromJSON . call ( this , json )  ; %NWL%this . width = json . width ; %NWL%this . height = json . height ; %NWL%this . aspect = json . aspect ; %NWL%this . autoResize = json . autoResize ; %NWL%this . background . fromJSON ( json . background )  ; %NWL%this . far = json . far ; %NWL%this . near = json . near ; %NWL%4
var tracking ; %NWL%if ( !file )  {%NWL%return file ;%NWL%}%NWL%if ( trackingList )  {%NWL%tracking = trackingList [ file . id ]  ;%NWL%}%NWL%if ( tracking )  {%NWL%file . currentSpeed = tracking . currentSpeed ; %NWL%file . averageSpeed = tracking . averageSpeed ; %NWL%file . movingAverageSpeed = tracking . movingAverageSpeed ; %NWL%8
inline . text = inline . gfm . text ; %NWL%inline . url = inline . gfm . url ;%NWL%} else {%NWL%block . fences = block . normal . fences ; %NWL%block . paragraph = block . normal . paragraph ; %NWL%inline . text = inline . normal . text ; %NWL%inline . url = inline . normal . url ;%NWL%}%NWL%if ( options . pedantic )  {%NWL%inline . em = inline . pedantic . em ; %NWL%inline . strong = inline . pedantic . strong ; %NWL%9
function copyRestangularizedElement ( fromElement )  {%NWL%var copiedElement = angular . copy ( fromElement )  ; %NWL%return restangularizeElem ( copiedElement [ restangularFields . parentResource ]  ,%NWL%copiedElement , copiedElement [ restangularFields . route ]  )  ;%NWL%}%NWL%function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%8
}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%4
return node . parent ;%NWL%}  , r )  ; %NWL%if ( r ! = node . left )  {%NWL%r . parent . right = r . left ; %NWL%if ( r . left ) r . left . parent = r . parent ; %NWL%r . left = node . left ; %NWL%r . left . parent = r ; %NWL%b = r . parent ;%NWL%}%NWL%r . parent = node . parent ; %NWL%r . right = node . right ; %NWL%5
featureResponseInstance . properties = propertiesInstance ; %NWL%var stateValue = propertiesValue [  ' state '  ]  ; %NWL%if ( stateValue ! =  = null && stateValue ! =  = undefined )  {%NWL%var stateInstance = stateValue ; %NWL%propertiesInstance . state = stateInstance ;%NWL%}%NWL%}%NWL%var idValue = valueValue [  ' id '  ]  ; %NWL%if ( idValue ! =  = null && idValue ! =  = undefined )  {%NWL%var idInstance = idValue ; %NWL%featureResponseInstance . id = idInstance ; %NWL%0
}%NWL%else {%NWL%OVERALL . total_PlayOnce = SESSION . total_PlayOnce ;%NWL%}%NWL%}%NWL%function O_Total_Speed (  )  {%NWL%if ( checkNull (  )  )  {%NWL%OVERALL . total_Speed = storage . total_Speed + SESSION . total_Speed ;%NWL%}%NWL%else {%NWL%OVERALL . total_Speed = SESSION . total_Speed ; %NWL%2
var init =  {%NWL%setup : function (  )  {%NWL%var $injector = angular . injector (%NWL%[  ' ng '  ,%NWL%' decipher . tags '  ,%NWL%' ngMock '  ,%NWL%' decipher . tags . templates '  ,%NWL%' template / typeahead / typeahead - popup . html '  ]  )  ; %NWL%this . $rootScope = $injector . get (  ' $rootScope '  )  ; %NWL%this . $log = $injector . get (  ' $log '  )  ; %NWL%this . $compile = $injector . get (  ' $compile '  )  ; %NWL%8
function parse (  )  {%NWL%if ( params . rawMessage )  {%NWL%try {%NWL%that = JSON . parse ( params . rawMessage . body )  ;  /  / Incoming message%NWL%} catch ( e )  {%NWL%that = params . rawMessage . body ;%NWL%}%NWL%that . fromType = params . rawMessage . header . fromType ; %NWL%that . fromEndpoint = params . rawMessage . header . from ; %NWL%that . fromConnection = params . rawMessage . header . fromConnection ; %NWL%that . timestamp = params . rawMessage . header . timestamp ; %NWL%7
obj . hasOwnProperty (  ' dmq1 '  ) &&%NWL%obj . hasOwnProperty (  ' coeff '  )%NWL%)  ;%NWL%}  ; %NWL%RSAKey . prototype . parsePropertiesFrom = function ( obj )  {%NWL%this . n = obj . n ; %NWL%this . e = obj . e ; %NWL%if ( obj . hasOwnProperty (  ' d '  )  )  {%NWL%this . d = obj . d ; %NWL%this . p = obj . p ; %NWL%this . q = obj . q ; %NWL%5
}%NWL%} else if ( type =  = goog . events . EventType . MOUSEOVER )  {%NWL%relatedTarget = e . fromElement ;%NWL%} else if ( type =  = goog . events . EventType . MOUSEOUT )  {%NWL%relatedTarget = e . toElement ;%NWL%}%NWL%this . relatedTarget = relatedTarget ; %NWL%if ( !goog . isNull ( relevantTouch )  )  {%NWL%this . clientX = relevantTouch . clientX ! =  = undefined ?%NWL%relevantTouch . clientX : relevantTouch . pageX ; %NWL%this . clientY = relevantTouch . clientY ! =  = undefined ?%NWL%8
}  )  ; %NWL%return this ;%NWL%}  ,%NWL%_clear : function (  )  {%NWL%this . context . clearRect ( 0 , 0 , this . canvas . width , this . canvas . height )  ; %NWL%return this ;%NWL%}  ,%NWL%}  ; %NWL%var Circle = function ( params )  {%NWL%this . id = params . id ; %NWL%this . canvas = params . canvas ; %NWL%9
exports . getOembed = function ( uri , data )  {%NWL%var oembed =  {%NWL%type :  ' rich '  ,%NWL%version :  ' 1 . 0 '  ,%NWL%title : data . meta . title%NWL%}  ; %NWL%if ( data . meta . author )  {%NWL%oembed . author = data . meta . author ;%NWL%}%NWL%if ( data . meta . author_url )  {%NWL%oembed . author_url = data . meta . author_url ; %NWL%7
function changedStyle (  )  {%NWL%var formObj = document . forms [ 0 ]  ; %NWL%var st = dom . parseStyle ( formObj . style . value )  ; %NWL%if ( st [  ' background - image '  ]  )%NWL%formObj . backgroundimage . value = st [  ' background - image '  ]  . replace ( new RegExp (  " url\\ (  ' ? (  [ ^ '  ]  *  )  ' ?\\ )  "  ,  ' gi '  )  ,  " $1 "  )  ; %NWL%else%NWL%formObj . backgroundimage . value =  '  '  ; %NWL%if ( st [  ' width '  ]  )%NWL%formObj . width . value = trimSize ( st [  ' width '  ]  )  ; %NWL%if ( st [  ' height '  ]  )%NWL%formObj . height . value = trimSize ( st [  ' height '  ]  )  ; %NWL%8
newTexture . wrapU = this . wrapU ; %NWL%newTexture . wrapV = this . wrapV ; %NWL%newTexture . coordinatesIndex = this . coordinatesIndex ; %NWL%newTexture . coordinatesMode = this . coordinatesMode ; %NWL%newTexture . uOffset = this . uOffset ; %NWL%newTexture . vOffset = this . vOffset ; %NWL%newTexture . uScale = this . uScale ; %NWL%newTexture . vScale = this . vScale ; %NWL%newTexture . uAng = this . uAng ; %NWL%newTexture . vAng = this . vAng ; %NWL%newTexture . wAng = this . wAng ; %NWL%0
}  ; %NWL%if ( args && args [ 1 ]  )  {%NWL%var insets = args [ 1 ]  . trim (  )  ; %NWL%insets = insets . split (  / \s +  /  )  ; %NWL%result . insets [ 0 ]  = insets [ 0 ]  ; %NWL%result . insets [ 1 ]  = insets . length > 1 ? insets [ 1 ]  : result . insets [ 0 ]  ; %NWL%result . insets [ 2 ]  = insets . length > 2 ? insets [ 2 ]  : result . insets [ 0 ]  ; %NWL%result . insets [ 3 ]  = insets . length > 3 ? insets [ 3 ]  : result . insets [ 1 ]  ; %NWL%result . insets [ 0 ]  = toPixels ( result . insets [ 0 ]  , box . height , units )  ; %NWL%result . insets [ 1 ]  = toPixels ( result . insets [ 1 ]  , box . width , units )  ; %NWL%result . insets [ 2 ]  = toPixels ( result . insets [ 2 ]  , box . height , units )  ; %NWL%8
callback = params ; %NWL%params =  {  }  ;%NWL%}%NWL%this . APIRequest (  '  / configuration '  ,  ' GET '  , callback , null , null , params )  ;%NWL%}  ,%NWL%APIRequest : function ( path , method , callback , field , body , params )  {%NWL%var url = this . apiUrl + path ; %NWL%if ( this . username && this . password )  {%NWL%params = params || {  }  ; %NWL%params . username = this . username ; %NWL%params . password = this . password ; %NWL%9
character = shift_nums [ character ]  ; %NWL%if ( character =  =  = k )  {%NWL%kp +  +  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( kp =  =  = keys . length &&%NWL%modifiers . ctrl . pressed =  =  = modifiers . ctrl . wanted &&%NWL%modifiers . shift . pressed =  =  = modifiers . shift . wanted &&%NWL%9
var _self = this ; %NWL%this . tbHexColor . onchange = function (  )  {%NWL%_self . setValue ( this . value ,  " RGBHEX "  )  ;%NWL%}  ; %NWL%this . shower = this . $getLayoutNode (  " main "  ,  " shower "  , this . $ext )  ; %NWL%this . bar1  = this . $getLayoutNode (  " main "  ,  " bar1 "  , this . $ext )  ; %NWL%this . bgBar1 = this . $getLayoutNode (  " main "  ,  " bgbar1 "  , this . $ext )  ; %NWL%this . bar2  = this . $getLayoutNode (  " main "  ,  " bar2 "  , this . $ext )  ; %NWL%this . bgBar2 = this . $getLayoutNode (  " main "  ,  " bgbar2 "  , this . $ext )  ; %NWL%this . pHolder  = this . $getLayoutNode (  " main "  ,  " pholder "  , this . $ext )  ; %NWL%this . pointer  = this . $getLayoutNode (  " main "  ,  " pointer "  , this . $ext )  ; %NWL%4
}%NWL%}%NWL%}%NWL%return returnArray ;%NWL%}  ; %NWL%var insertSubtree = function ( node , root )  {%NWL%var bc ;  /  / Best Current node%NWL%if ( root . nodes . length =  =  = 0 )  {%NWL%root . x = node . x ; %NWL%root . y = node . y ; %NWL%root . w = node . w ; %NWL%8
air . NativeWindowInitOptions = window . runtime . flash . display . NativeWindowInitOptions ; %NWL%air . NativeWindowSystemChrome = window . runtime . flash . display . NativeWindowSystemChrome ; %NWL%air . NativeWindowResize = window . runtime . flash . display . NativeWindowResize ; %NWL%air . NativeWindowType = window . runtime . flash . display . NativeWindowType ; %NWL%air . NativeWindowBoundsEvent = window . runtime . flash . events . NativeWindowBoundsEvent ; %NWL%air . NativeWindowDisplayStateEvent = window . runtime . flash . events . NativeWindowDisplayStateEvent ; %NWL%air . Point = window . runtime . flash . geom . Point ; %NWL%air . Rectangle = window . runtime . flash . geom . Rectangle ; %NWL%air . Matrix = window . runtime . flash . geom . Matrix ; %NWL%air . Matrix3D  = window . runtime . flash . geom . Matrix3D ; %NWL%air . Vector3D  = window . runtime . flash . geom . Vector3D ; %NWL%6
this . setOptions (  )  ;%NWL%}%NWL%GaugePointer . prototype . setOptions = function ( options )  {%NWL%if ( options =  = null )  {%NWL%options = null ;%NWL%}%NWL%updateObjectValues ( this . options , options )  ; %NWL%this . length = this . canvas . height * this . options . length ; %NWL%this . strokeWidth = this . canvas . height * this . options . strokeWidth ; %NWL%this . maxValue = this . gauge . maxValue ; %NWL%this . minValue = this . gauge . minValue ; %NWL%9
}%NWL%obj . transaction . type =  ' rippling '  ;%NWL%}%NWL%obj . tx_type = tx . TransactionType ; %NWL%obj . tx_result = meta . TransactionResult ; %NWL%obj . fee = ripple . Amount . from_json ( hasFee ? tx . Fee : 0 )  ; %NWL%obj . date = ripple . utils . toTimestamp ( tx . date )  ; %NWL%obj . dateRaw = tx . date ; %NWL%obj . hash = tx . hash ; %NWL%obj . affectedCurrencies = affectedCurrencies || [  ]  ; %NWL%obj . ledger_index = tx . ledger_index ; %NWL%8
info . deviceType = props . devicetype ; %NWL%info . id = info . device . unit . udn ; %NWL%if ( !!devices . devices [ info . id ]  )  {%NWL%device = devices . devices [ info . id ]  . device ; %NWL%if (  ( !device ) || ( !!device . ws )  )  {%NWL%results . things [ thingID ]  =  { error :  { permanent : false , diagnostic :  ' UDN is already registered '  }  }  ; %NWL%continue ;%NWL%}%NWL%device . ws = info . params . ws ; %NWL%device . clientSerialNo = device . ws . clientInfo . clientSerialNo ; %NWL%device . thingID = info . params . thingID ; %NWL%8
Pixastic . Actions . glow =  {%NWL%process : function ( params )  {%NWL%var amount =  ( parseFloat ( params . options . amount ) ||0 )  ; %NWL%var blurAmount = parseFloat ( params . options . radius ) ||0 ; %NWL%amount = Math . min ( 1 , Math . max ( 0 , amount )  )  ; %NWL%blurAmount = Math . min ( 5 , Math . max ( 0 , blurAmount )  )  ; %NWL%if ( Pixastic . Client . hasCanvasImageData (  )  )  {%NWL%var rect = params . options . rect ; %NWL%var blurCanvas = document . createElement (  " canvas "  )  ; %NWL%blurCanvas . width = params . width ; %NWL%blurCanvas . height = params . height ; %NWL%9
this . clearFlags = clearFlags ;%NWL%}  ,%NWL%getClearColor : function (  )  {%NWL%return this . _clearColor ;%NWL%}  ,%NWL%setClearColor : null ,%NWL%_setClearColorForCanvas : function ( clearColor )  {%NWL%var locClearColor = this . _clearColor ; %NWL%locClearColor . r = clearColor . r ; %NWL%locClearColor . g = clearColor . g ; %NWL%locClearColor . b = clearColor . b ; %NWL%9
lodash . map = collections . map ; %NWL%lodash . mapValues = objects . mapValues ; %NWL%lodash . max = collections . max ; %NWL%lodash . memoize = functions . memoize ; %NWL%lodash . merge = objects . merge ; %NWL%lodash . min = collections . min ; %NWL%lodash . omit = objects . omit ; %NWL%lodash . once = functions . once ; %NWL%lodash . pairs = objects . pairs ; %NWL%lodash . partial = functions . partial ; %NWL%lodash . partialRight = functions . partialRight ; %NWL%3
settings = $ . extend ( settings , key )  ;%NWL%} else if ( typeof key =  =  ' string ' && typeof value ! =  ' undefined '  )  {%NWL%settings [ key ]  = value ;%NWL%} else if ( typeof key =  =  ' string '  )  {%NWL%return settings [ key ]  ;%NWL%}%NWL%if ( settings . minTime )  {%NWL%settings . minTime = _time2int ( settings . minTime )  ;%NWL%}%NWL%if ( settings . maxTime )  {%NWL%settings . maxTime = _time2int ( settings . maxTime )  ; %NWL%7
}%NWL%}  ;%NWL%}  )  ( Object . freeze )  ;%NWL%}%NWL%if ( !Object . preventExtensions )  {%NWL%Object . preventExtensions = function preventExtensions ( object )  {%NWL%return object ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isSealed )  {%NWL%Object . isSealed = function isSealed ( object )  {%NWL%5
var attachFont = function ( object )  {%NWL%var fontStyle = object . fontStyle = lang . clone ( g . defaultFont )  ,%NWL%c = object . rawNode . childNodes , i = 0 ; %NWL%for (  ; i < c . length && c [ i ]  . tagName =  =  " textpath "  ;  +  + i )  ; %NWL%if ( i >  = c . length )  {%NWL%object . fontStyle = null ; %NWL%return ;%NWL%}%NWL%var s = c [ i ]  . style ; %NWL%fontStyle . style = s . fontstyle ; %NWL%fontStyle . variant = s . fontvariant ; %NWL%9
this . maxSize = opts . maxSize ! = undefined ? opts . maxSize : 0 . 5 ; %NWL%this . sizeTween = new Tween ( opts . sizeTween )  ; %NWL%this . alphaTween = new Tween ( opts . alphaTween )  ; %NWL%this . colorTween = new Tween ( opts . colorTween )  ; %NWL%this . velocity = opts . velocity ! = undefined ? opts . velocity : new Vec3 ; %NWL%this . velocitySpread = opts . velocitySpread ! = undefined ? opts . velocitySpread : new Vec3 ; %NWL%this . acceleration = opts . acceleration ! = undefined ? opts . acceleration : new Vec3 ; %NWL%this . accelerationSpread = opts . accelerationSpread ! = undefined ? opts . accelerationSpread : new Vec3 ; %NWL%this . angularVelocity = opts . angularVelocity ! = undefined ? opts . angularVelocity : 0 ; %NWL%this . angularVelocitySpread = opts . angularVelocitySpread ! = undefined ? opts . angularVelocitySpread : 0 ; %NWL%this . angularAcceleration = opts . angularAcceleration ! = undefined ? opts . angularAcceleration : 0 ; %NWL%8
bcrypt = require (  ' bcrypt '  )  ,%NWL%fs = require (  ' fs '  )  ; %NWL%exports . version =  " 0 . 1 . 0 "  ; %NWL%function User ( user_data )  {%NWL%this . uuid = user_data [  " user_uuid "  ]  ; %NWL%this . email_address = user_data [  " email_address "  ]  ; %NWL%this . display_name = user_data [  " display_name "  ]  ; %NWL%this . password = user_data [  " password "  ]  ; %NWL%this . first_seen_date = user_data [  " first_seen_date "  ]  ; %NWL%this . last_modified_date = user_data [  " last_modified_date "  ]  ; %NWL%this . deleted = user_data [  " deleted "  ]  ; %NWL%5
this . fields = options . fields ;%NWL%}  ; %NWL%util . inherits ( error . UniqueConstraintError , error . ValidationError )  ; %NWL%error . ForeignKeyConstraintError = function ( options )  {%NWL%options = options || {  }  ; %NWL%options . parent = options . parent || { sql :  '  '  }  ; %NWL%error . DatabaseError . call ( this , options . parent )  ; %NWL%this . name =  ' SequelizeForeignKeyConstraintError '  ; %NWL%this . message = options . message ; %NWL%this . fields = options . fields ; %NWL%this . table = options . table ; %NWL%0
newItem . left = offset . left ; %NWL%newItem . top = offset . top ; %NWL%newItem . width = elem . width (  )  ; %NWL%newItem . height = elem . height (  )  ; %NWL%newItem . borderLeftWidth = elem . css (  ' borderLeftWidth '  ) || 0 ; %NWL%newItem . borderTopWidth = elem . css (  ' borderTopWidth '  ) || 0 ; %NWL%newItem . borderRightWidth = elem . css (  ' borderRightWidth '  ) || 0 ; %NWL%newItem . borderBottomWidth = elem . css (  ' borderBottomWidth '  ) || 0 ; %NWL%newItem . borderLeftColor = elem . css (  ' borderLeftColor '  )  ; %NWL%newItem . borderTopColor = elem . css (  ' borderTopColor '  )  ; %NWL%newItem . borderRightColor = elem . css (  ' borderRightColor '  )  ; %NWL%8
setScaleY : function ( y )  {%NWL%this . _scaleY = y ; %NWL%this . setNodeDirty (  )  ; %NWL%this . dom . resize ( this . _scaleX , this . _scaleY )  ;%NWL%}  ,%NWL%setAnchorPoint : function ( point , y )  {%NWL%var cmd = this . _renderCmd ; %NWL%var locAnchorPoint = this . _anchorPoint ; %NWL%if ( y =  =  = undefined )  {%NWL%locAnchorPoint . x = point . x ; %NWL%locAnchorPoint . y = point . y ; %NWL%9
if ( navigator . userAgent . match (  / Android 2 /  ) || navigator . userAgent . match (  / Android 3 /  ) || navigator . userAgent . match (  / Android 4\ .  [ 0 - 3 ]  /  )  )  {%NWL%if ( !navigator . userAgent . match (  / Chrome /  )  )  {%NWL%poorIndexedDbSupport = true ;%NWL%}%NWL%}%NWL%if (  ( typeof window . indexedDB =  =  =  " undefined " || !window . indexedDB || poorIndexedDbSupport ) && typeof window . openDatabase ! =  =  " undefined "  )  {%NWL%window . shimIndexedDB . __useShim (  )  ;%NWL%}%NWL%else {%NWL%window . IDBDatabase = window . IDBDatabase || window . webkitIDBDatabase ; %NWL%window . IDBTransaction = window . IDBTransaction || window . webkitIDBTransaction ; %NWL%9
height = cfg . height ;%NWL%}%NWL%me . minWidth = cfg . minWidth || me . defaultMinWidth ; %NWL%me . maxWidth = cfg . maxWidth || me . defaultMaxWidth ; %NWL%me . minHeight = cfg . minHeight || me . defaultMinHeight ; %NWL%me . maxHeight = cfg . maxHeight || me . defaultMaxHeight ; %NWL%if ( resizer )  {%NWL%resizeTracker = resizer . resizeTracker ; %NWL%resizer . minWidth = resizeTracker . minWidth = me . minWidth ; %NWL%resizer . maxWidth = resizeTracker . maxWidth = me . maxWidth ; %NWL%resizer . minHeight = resizeTracker . minHeight = me . minHeight ; %NWL%8
' save '  ,%NWL%' submit '  ,%NWL%' submit_on_enter '  ,%NWL%' update_field_display '  ,%NWL%' validate '  ,%NWL%' validate_all '%NWL%)  ; %NWL%options = options || {  }  ; %NWL%this . is_valid = false ; %NWL%this . prefill = options . prefill || false ; %NWL%this . hide_on_submit = options . hide_on_submit || false ; %NWL%9
if ( secret )  {%NWL%req . signedCookies = parse . signedCookies ( req . cookies , secret )  ; %NWL%req . signedCookies = parse . JSONCookies ( req . signedCookies )  ;%NWL%}%NWL%req . cookies = parse . JSONCookies ( req . cookies )  ; %NWL%next (  )  ;%NWL%}  ;%NWL%}  ; %NWL%exports . JSONCookie = parse . JSONCookie ; %NWL%exports . JSONCookies = parse . JSONCookies ; %NWL%exports . signedCookie = parse . signedCookie ; %NWL%8
return ;%NWL%}%NWL%if ( loaded )  {%NWL%q . url . shift (  )  ; %NWL%if ( q . varName )  {%NWL%q . varName . shift (  )  ;%NWL%}%NWL%} else {%NWL%q . url =  ( L . isString ( q . url )  ) ? [ q . url ]  : q . url ; %NWL%if ( q . varName )  {%NWL%q . varName =  ( L . isString ( q . varName )  ) ? [ q . varName ]  : q . varName ; %NWL%8
module . exports . putTileRetry = putTileRetry ; %NWL%module . exports . retryBackoff = 1000 ; %NWL%function DeserializationError ( msg )  {%NWL%this . message = msg ; %NWL%this . name =  ' DeserializationError '  ;%NWL%}%NWL%util . inherits ( DeserializationError , Error )  ; %NWL%function Tile ( z , x , y , buffer )  {%NWL%this . z = isNaN ( z ) ? undefined : Number ( z )  ; %NWL%this . x = isNaN ( x ) ? undefined : Number ( x )  ; %NWL%this . y = isNaN ( y ) ? undefined : Number ( y )  ; %NWL%8
}%NWL%function cancelAction (  )  {%NWL%tinyMCEPopup . close (  )  ;%NWL%}%NWL%function changeAppearance (  )  {%NWL%var formObj = document . forms [ 0 ]  ; %NWL%var img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%img . align = formObj . align . value ; %NWL%img . border = formObj . border . value ; %NWL%img . hspace = formObj . hspace . value ; %NWL%8
module . exports = Tour ; %NWL%p . init = function (  )  {%NWL%if ( this . _inited ) return ; %NWL%this . _inited = true ; %NWL%this . _callRunningLoop = this . _callRunningLoop . bind ( this )  ; %NWL%this . _steps =  [  ]  ; %NWL%this . _dePointers =  [  ]  ; %NWL%this . _deCheckboxes =  [  ]  ; %NWL%this . _createBase (  )  ; %NWL%am . workspace . fillTab (  ' tour '  , this . domElem )  ; %NWL%this . prev = this . prev . bind ( this )  ; %NWL%4
var Sync = require (  ' backbone - redis '  )  ; %NWL%var Backbone = require (  ' backbone '  )  ; %NWL%Backbone . sync = function ( method , model , options )  {%NWL%if ( typeof redisClient =  =  ' undefined '  )  {%NWL%throw new Error (  " redis client must be configured! "  )  ;%NWL%}%NWL%options || ( options =  {  }  )  ; %NWL%options . channel = model . getChannel (  )  ; %NWL%options . type = model . type ; %NWL%options . indexProps = model . indexProps || ( model . model && model . model . prototype . indexProps ? model . model . prototype . indexProps :  [  ]  )  ; %NWL%options . extKeys = model . extKeys || ( model . model && model . model . prototype . extKeys ? model . model . prototype . extKeys :  [  ]  )  ; %NWL%9
if ( typeof this . settings . delayOut ! =  ' undefined '  )  {%NWL%this . delayOut = parseFloat ( this . settings . delayOut )  ;%NWL%}%NWL%if ( typeof this . settings . fade ! =  ' undefined '  )  {%NWL%this . fade = this . settings . fade ;%NWL%}%NWL%if ( typeof this . settings . fallback ! =  ' undefined '  )  {%NWL%this . fallback = this . settings . fallback ;%NWL%}%NWL%if ( typeof this . settings . gravity ! =  ' undefined '  )  {%NWL%this . gravity = this . settings . gravity ; %NWL%4
} else {%NWL%other . push ( node )  ;%NWL%}%NWL%}  )  ; %NWL%if ( props . length )  {%NWL%var selfLiteral = new nodes . Literal (  ' & '  )  ; %NWL%selfLiteral . lineno = media . lineno ; %NWL%selfLiteral . filename = media . filename ; %NWL%var selfSelector = new nodes . Selector ( selfLiteral )  ; %NWL%selfSelector . lineno = media . lineno ; %NWL%selfSelector . filename = media . filename ; %NWL%9
navframe . CalcNavigationFrame ( target_lng , target_lat )  ; %NWL%var trans = new mat4 (  )  ; %NWL%trans . Translation ( tc [ 0 ]  , tc [ 1 ]  , tc [ 2 ]  )  ; %NWL%var navigationMatrix = new mat4 (  )  ; %NWL%navigationMatrix . Multiply ( trans , navframe )  ; %NWL%var ori =  {  }  ; %NWL%if (  ( opt_yaw! = null ) && ( opt_pitch! = null ) && ( opt_roll! = null )  )%NWL%{%NWL%ori . yaw = MathUtils . Deg2Rad ( opt_yaw )  ; %NWL%ori . pitch = MathUtils . Deg2Rad ( opt_pitch )  ; %NWL%ori . roll = MathUtils . Deg2Rad ( opt_roll )  ; %NWL%8
ctor : function (  )  {%NWL%}  ,%NWL%getColor : function (  )  {%NWL%var locColor = this . _color ; %NWL%return cc . color ( locColor . r , locColor . g , locColor . b , locColor . a )  ;%NWL%}  ,%NWL%setColor : function ( color )  {%NWL%var locColor = this . _color ; %NWL%locColor . r = color . r ; %NWL%locColor . g = color . g ; %NWL%locColor . b = color . b ; %NWL%9
return json ;%NWL%}  ; %NWL%Axis . prototype . fromSYNC = function ( json )  {%NWL%this . name = json . name ; %NWL%this . value = json . value ; %NWL%return this ;%NWL%}  ; %NWL%Axis . prototype . toJSON = function ( json )  {%NWL%json || ( json =  {  }  )  ; %NWL%json . name = this . name ; %NWL%json . negButton = this . negButton ; %NWL%9
}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = formElement (  )  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%img . hspace = f . hspace . value ; %NWL%img . vspace = f . vspace . value ; %NWL%7
this . fireEvent (  ' close '  , this )  ;%NWL%}  ,%NWL%changeText : function ( lang )  {%NWL%this . parent (  )  ; 	 /  / TODO : change this class so that we can access these properties without too much voodoo .  .  .%NWL%if ( this . closeB ! = undefined && this . closeB ! = null )  {%NWL%this . closeB . setTooltip (  { set :  ' Jx '  , key :  ' panel '  , value :  ' closeTooltip '  }  )  ;%NWL%}%NWL%if ( this . closeM ! = undefined && this . closeM ! = null )  {%NWL%this . closeM . setLabel (  { set :  ' Jx '  , key :  ' panel '  , value :  ' closeLabel '  }  )  ;%NWL%}%NWL%if ( this . maxB ! = undefined && this . maxB ! = null )  {%NWL%7
r_out_sum = radiusPlus1 *  ( pr = pixels [ yi ]  )  ; %NWL%g_out_sum = radiusPlus1 *  ( pg = pixels [ yi + 1 ]  )  ; %NWL%b_out_sum = radiusPlus1 *  ( pb = pixels [ yi + 2 ]  )  ; %NWL%r_sum +  = sumFactor * pr ; %NWL%g_sum +  = sumFactor * pg ; %NWL%b_sum +  = sumFactor * pb ; %NWL%stack = stackStart ; %NWL%for ( i = 0 ; i < radiusPlus1 ; i +  +  )%NWL%{%NWL%stack . r = pr ; %NWL%stack . g = pg ; %NWL%9
}  )  ;%NWL%}%NWL%function web2py_component ( action , target )  {%NWL%jQuery ( function (  )  { web2py_ajax_page (  ' get '  , action , null , target )  ;  }  )  ;%NWL%}%NWL%function web2py_comet ( url , onmessage , onopen , onclose )  {%NWL%if (  " WebSocket " in window )  {%NWL%var ws = new WebSocket ( url )  ; %NWL%ws . onopen = onopen?onopen :  ( function (  )  {  }  )  ; %NWL%ws . onmessage = onmessage ; %NWL%ws . onclose = onclose?onclose :  ( function (  )  {  }  )  ; %NWL%8
res +  = String . fromCharCode ( a [ j ]  )  ;%NWL%}%NWL%} else {%NWL%res +  = String . fromCharCode ( a )  ;%NWL%}%NWL%}%NWL%return res ;%NWL%}  ;%NWL%}%NWL%NAMESPACE . lowercase_nomark = create_normalizer ( NAMESPACE . norm_lowercase_nomark_data ,  " normalizer_lowercase_nomark . js "  )  ; %NWL%NAMESPACE . lowercase = create_normalizer ( NAMESPACE . norm_lowercase_data ,  " normalizer_lowercase . js "  )  ; %NWL%9
this . worldSpace = opts . worldSpace ! = undefined ? opts . worldSpace : true ; %NWL%this . position = opts . position ! = undefined ? opts . position : new Vec3 ; %NWL%this . minEmission = opts . minEmission ! = undefined ? opts . minEmission : 1 ; %NWL%this . maxEmission = opts . maxEmission ! = undefined ? opts . maxEmission : 2 ; %NWL%this . minLife = opts . minLife ! = undefined ? opts . minLife : 1 ; %NWL%this . maxLife = opts . maxLife ! = undefined ? opts . maxLife : 2 ; %NWL%this . minSize = opts . minSize ! = undefined ? opts . minSize : 0 . 1 ; %NWL%this . maxSize = opts . maxSize ! = undefined ? opts . maxSize : 0 . 5 ; %NWL%this . sizeTween = new Tween ( opts . sizeTween )  ; %NWL%this . alphaTween = new Tween ( opts . alphaTween )  ; %NWL%this . colorTween = new Tween ( opts . colorTween )  ; %NWL%8
json . panningEnabled = cy . _private . panningEnabled ; %NWL%json . userPanningEnabled = cy . _private . userPanningEnabled ; %NWL%json . pan = cy . _private . pan ; %NWL%json . boxSelectionEnabled = cy . _private . boxSelectionEnabled ; %NWL%json . layout = cy . _private . options . layout ; %NWL%json . renderer = cy . _private . options . renderer ; %NWL%json . hideEdgesOnViewport = cy . _private . options . hideEdgesOnViewport ; %NWL%json . hideLabelsOnViewport = cy . _private . options . hideLabelsOnViewport ; %NWL%json . textureOnViewport = cy . _private . options . textureOnViewport ; %NWL%json . wheelSensitivity = cy . _private . options . wheelSensitivity ; %NWL%json . motionBlur = cy . _private . options . motionBlur ; %NWL%4
message :  ' What is the name of the target application to remove? '  ,%NWL%default : targets && targets . length >  = 1 ? targets [ 0 ]  . value : null%NWL%}  ,  {%NWL%message :  ' Are you sure you want to remove it? There is no turning back .  .  .  '  ,%NWL%name :  ' confirmation '  ,%NWL%type :  ' confirm '  ,%NWL%default : false%NWL%}  ]  ; %NWL%this . prompt ( prompts , function ( answers )  {%NWL%this . component = answers . component ; %NWL%this . targetname = answers . targetname ; %NWL%9
if ( !seed && context . nodeType =  =  = 9 )  {%NWL%try {%NWL%return makeArray ( context . querySelectorAll ( query )  , extra )  ;%NWL%} catch ( e )  {  }%NWL%}%NWL%return oldSizzle ( query , context , extra , seed )  ;%NWL%}  ; %NWL%Sizzle . find = oldSizzle . find ; %NWL%Sizzle . filter = oldSizzle . filter ; %NWL%Sizzle . selectors = oldSizzle . selectors ; %NWL%Sizzle . matches = oldSizzle . matches ; %NWL%7
{%NWL%p = new PropertyDescriptor (  )  ; %NWL%p . value = examine ( desc ,  " value "  , true )  ; %NWL%p . writable = examine ( desc ,  " writable "  , true )  ; %NWL%p . enumerable = examine ( desc ,  " enumerable "  , true )  ; %NWL%p . configurable = examine ( desc ,  " configurable "  , true )  ;%NWL%}%NWL%else%NWL%{%NWL%p = new PropertyDescriptor (  )  ; %NWL%p . get = examine ( desc ,  " get "  , true )  ; %NWL%2
}  ,%NWL%triggerEvent : function ( type , evt )  {%NWL%var listeners = this . listeners [ type ]  ; %NWL%if ( !listeners || listeners . length =  = 0 )  {%NWL%return ;%NWL%}%NWL%if ( evt =  = null )  {%NWL%evt =  {  }  ;%NWL%}%NWL%evt . object = this . object ; %NWL%evt . element = this . element ; %NWL%9
that . delta = offset - that . location ; %NWL%that . _updateLocationData ( location )  ; %NWL%that . initialDelta = offset - that . startLocation ; %NWL%that . velocity = that . delta / timeDelta ; %NWL%that . timeStamp = timeStamp ;%NWL%}  ,%NWL%_updateLocationData : function ( location )  {%NWL%var that = this , axis = that . axis ; %NWL%that . location = location [  " page "  + axis ]  ; %NWL%that . client = location [  " client "  + axis ]  ; %NWL%that . screen = location [  " screen "  + axis ]  ; %NWL%9
sx : this . sx ,%NWL%sy : this . sy ,%NWL%height : this . height ,%NWL%width : this . width ,%NWL%opacity : this . opacity%NWL%}  )  ; %NWL%return p ;%NWL%}  ; %NWL%snabbtjs . State . prototype . assign = function ( p )  {%NWL%this . ax = p . ax ; %NWL%this . ay = p . ay ; %NWL%9
Cartesian3 . add ( position , nearCenter , nearCenter )  ; %NWL%var point = getPlanesPoint ; %NWL%Cartesian3 . multiplyByScalar ( right , l , point )  ; %NWL%Cartesian3 . add ( nearCenter , point , point )  ; %NWL%var plane = planes [ 0 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 0 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x = right . x ; %NWL%plane . y = right . y ; %NWL%plane . z = right . z ; %NWL%8
ask_before_unload : TRUE ,%NWL%interval :  ' 30s '  ,%NWL%retention :  ' 20m '  ,%NWL%minlength : 50%NWL%}  , function ( value , key )  {%NWL%key = PLUGIN_NAME +  ' _ '  + key ; %NWL%if ( settings [ key ]  =  =  = undefined )%NWL%settings [ key ]  = value ;%NWL%}  )  ; %NWL%settings . autosave_interval = parseTime ( settings . autosave_interval )  ; %NWL%settings . autosave_retention = parseTime ( settings . autosave_retention )  ; %NWL%9
IN . StartupMouse = function (  )%NWL%{%NWL%IN . m_filter = Cvar . RegisterVariable (  ' m_filter '  ,  ' 1 '  )  ; %NWL%if ( COM . CheckParm (  '  - nomouse '  ) ! = null )%NWL%return ; %NWL%if ( VID . mainwindow . pointerLockElement ! = null )%NWL%{%NWL%IN . movementX =  ' movementX '  ; %NWL%IN . movementY =  ' movementY '  ; %NWL%IN . pointerLockElement =  ' pointerLockElement '  ; %NWL%IN . requestPointerLock =  ' requestPointerLock '  ; %NWL%7
initialize : function initializePagiatedCollection ( options )  {%NWL%Collection . prototype . initialize . call ( this , options )  ; %NWL%if ( this . sortField ! =  = undefined && this . sortField . field ! =  = undefined )  {%NWL%this . setSortField ( this . sortField . field , this . sortField . order )  ;%NWL%}%NWL%}  ,%NWL%setPageInfo : function setPageInfo ( pageInfos )  {%NWL%this . totalRecords = pageInfos . totalRecords ; %NWL%this . currentPage = pageInfos . currentPage ; %NWL%this . firstPage = pageInfos . firstPage ; %NWL%this . lastPage = pageInfos . lastPage ; %NWL%7
var shapeBox ,%NWL%box ; %NWL%this . _shapes [ shape . get (  " id "  )  ]  = shape ; %NWL%if ( !this . get (  " resizeDown "  )  )%NWL%{%NWL%shapeBox = shape . getBounds (  )  ; %NWL%box = this . _contentBounds ; %NWL%box . left = box . left < shapeBox . left ? box . left : shapeBox . left ; %NWL%box . top = box . top < shapeBox . top ? box . top : shapeBox . top ; %NWL%box . right = box . right > shapeBox . right ? box . right : shapeBox . right ; %NWL%box . bottom = box . bottom > shapeBox . bottom ? box . bottom : shapeBox . bottom ; %NWL%9
json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%7
pa . push (  { x : polygon . points [ pi ]  . x + polygon . pos . x , y : polygon . points [ pi ]  . y + polygon . pos . y }  )%NWL%}%NWL%pa . push ( pa [ 0 ]  )  ;  /  / Create line from last Point to beginning Point%NWL%result . intersects = false ; %NWL%result . intersections =  [  ]  ; %NWL%result . start_inside = false ; %NWL%result . end_inside = false ; %NWL%var n = pa . length - 1 ; %NWL%while ( n >  - 1 )  {%NWL%C . x = pa [ n ]  . x ; %NWL%C . y = pa [ n ]  . y ; %NWL%9
exports . clone = base . clone ; %NWL%exports . mkhash = base . mkhash ; %NWL%exports . forEach = base . forEach ; %NWL%exports . cache = cache . cache ; %NWL%exports . lock = lock . lock ; %NWL%exports . async = async ; %NWL%exports . populateConfig = cfg . populateConfig ; %NWL%exports . baseConfig = cfg . baseConfig ; %NWL%exports . b64encode = b64 . b64encode ; %NWL%exports . b64decode = b64 . b64decode ; %NWL%exports . factory = factory . factory ; %NWL%3
context . restore (  )  ;%NWL%}%NWL%function drawPolygons (  )  {%NWL%polygons . forEach ( function ( polygon )  {%NWL%drawPolygon ( polygon )  ;%NWL%}  )  ;%NWL%}%NWL%function startDragging ( loc )  {%NWL%saveDrawingSurface (  )  ; %NWL%mousedown . x = loc . x ; %NWL%mousedown . y = loc . y ; %NWL%9
function HttpClient ( options )  {%NWL%assert . object ( options ,  ' options '  )  ; %NWL%assert . optionalObject ( options . headers ,  ' options . headers '  )  ; %NWL%assert . object ( options . log ,  ' options . log '  )  ; %NWL%assert . optionalFunc ( options . signRequest ,  ' options . signRequest '  )  ; %NWL%assert . optionalString ( options . socketPath ,  ' options . socketPath '  )  ; %NWL%assert . optionalString ( options . url ,  ' options . url '  )  ; %NWL%EventEmitter . call ( this )  ; %NWL%var self = this ; %NWL%this . agent = options . agent ; %NWL%this . ca = options . ca ; %NWL%9
return {%NWL%dateField : init%NWL%}%NWL%}  )  ; %NWL%$ . extend ( Tapestry ,  {%NWL%DateField :  {%NWL%firstDay : 0 ,%NWL%localized : false ,%NWL%initLocalization : function ( loc )  {%NWL%this . months = loc . months ; %NWL%this . days = loc . days ; %NWL%9
if ( options =  = null ) options =  {  }%NWL%var tokens = self . _tokens = tokenize ( text , options )%NWL%self . _data = tokens . data%NWL%tokens . data = null%NWL%self . _options = options%NWL%var stats = analyze ( text , options )%NWL%if ( options . indent =  = null )  {%NWL%options . indent = stats . indent%NWL%}%NWL%if ( options . quote =  = null )  {%NWL%options . quote = stats . quote%NWL%7
if ( typeof entryEl ! =  ' undefined '  )  {%NWL%this . parseXmlGroup ( entryEl )  ;%NWL%}%NWL%}  ; %NWL%Zotero . Group . prototype = new Zotero . Entry (  )  ; %NWL%Zotero . Group . prototype . loadObject = function ( ob )  {%NWL%var group = this ; %NWL%group . title = ob . title ; %NWL%group . author = ob . author ; %NWL%group . tagID = ob . tagID ; %NWL%group . published = ob . published ; %NWL%7
init : function ( ed )  {%NWL%var f = document . forms [ 0 ]  , nl = f . elements , ed = tinyMCEPopup . editor , dom = ed . dom , n = ed . selection . getNode (  )  ; %NWL%tinyMCEPopup . resizeToInnerSize (  )  ; %NWL%this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%8
bodyA = collision . bodyA ; %NWL%bodyB = collision . bodyB ; %NWL%normal = collision . normal ; %NWL%tangent = collision . tangent ; %NWL%for ( j = 0 ; j < contacts . length ; j +  +  )  {%NWL%contact = contacts [ j ]  ; %NWL%contactVertex = contact . vertex ; %NWL%normalImpulse = contact . normalImpulse ; %NWL%tangentImpulse = contact . tangentImpulse ; %NWL%impulse . x =  ( normal . x * normalImpulse )  +  ( tangent . x * tangentImpulse )  ; %NWL%impulse . y =  ( normal . y * normalImpulse )  +  ( tangent . y * tangentImpulse )  ; %NWL%9
obj . hasOwnProperty (  ' q '  ) &&%NWL%obj . hasOwnProperty (  ' dmp1 '  ) &&%NWL%obj . hasOwnProperty (  ' dmq1 '  ) &&%NWL%obj . hasOwnProperty (  ' coeff '  )%NWL%)  ;%NWL%}  ; %NWL%RSAKey . prototype . parsePropertiesFrom = function ( obj )  {%NWL%this . n = obj . n ; %NWL%this . e = obj . e ; %NWL%if ( obj . hasOwnProperty (  ' d '  )  )  {%NWL%this . d = obj . d ; %NWL%7
var bindings =  [  ' navUp '  ,  ' navRight '  ,  ' navDown '  ,  ' navLeft '  ,  ' navAction '  ,  ' navFocus '  ,  ' navBlur '  ]  ; %NWL%for ( var index in bindings )  {%NWL%if ( options [ bindings [ index ]  ]  )  {%NWL%this . boundNav [ bindings [ index ]  ]  = true ; %NWL%this [ bindings [ index ]  ]  = options [ bindings [ index ]  ]  ;%NWL%}%NWL%}%NWL%this . scroller = options . scroller || false ; %NWL%this . offsetTop = options . offsetTop || 0 ; %NWL%this . offsetBottom = options . offsetBottom || 0 ; %NWL%this . focusSubElements = options . focusSubElements || false ; %NWL%7
self . _then = self . _then || [  ]%NWL%self . _then . push ( fn )%NWL%return self%NWL%}%NWL%, fail : function ( fn )  {%NWL%var self = this%NWL%if ( self . _failed )  {%NWL%fn (  )%NWL%return self%NWL%}%NWL%self . _fail = self . _fail || [  ]%NWL%0
o . height = args . height . to ; %NWL%if ( args . height . from )%NWL%e . setHeight ( args . height . from )  ; %NWL%break ; %NWL%case ' opacity '  : %NWL%o . opacity = args . opacity . to ; %NWL%if ( args . opacity . from )%NWL%e . setOpacity ( args . opacity . from )  ; %NWL%break ; %NWL%case ' left '  : %NWL%o . left = args . left . to ; %NWL%0
noIdCount : 0%NWL%}  ; %NWL%CoolClock . prototype =  {%NWL%init : function ( options )  {%NWL%this . canvasId   = options . canvasId ; %NWL%this . skinId   = options . skinId || CoolClock . config . defaultSkin ; %NWL%this . displayRadius  = options . displayRadius || CoolClock . config . defaultRadius ; %NWL%this . showSecondHand = typeof options . showSecondHand =  =  " boolean " ? options . showSecondHand : true ; %NWL%this . gmtOffset   =  ( options . gmtOffset ! = null && options . gmtOffset ! =  '  '  ) ? parseFloat ( options . gmtOffset )  : null ; %NWL%this . showDigital  = typeof options . showDigital =  =  " boolean " ? options . showDigital : false ; %NWL%this . logClock   = typeof options . logClock =  =  " boolean " ? options . logClock : false ; %NWL%9
drawGrid (  ' lightgray '  , 10 , 10 )  ; %NWL%saveDrawingSurface (  )  ;%NWL%}  ; %NWL%strokeStyleSelect . onchange = function ( e )  {%NWL%context . strokeStyle = strokeStyleSelect . value ;%NWL%}  ; %NWL%fillStyleSelect . onchange = function ( e )  {%NWL%context . fillStyle = fillStyleSelect . value ;%NWL%}  ; %NWL%lineWidthSelect . onchange = function ( e )  {%NWL%context . lineWidth = lineWidthSelect . value ; %NWL%4
editorHelpers . documentHasChanged (  )  ;%NWL%}  ; %NWL%editorHelpers . updateEditorPage = function ( aDocument )  {%NWL%console . log (  ' updating editor '  )  ; %NWL%clearInterval ( diffHelpers . diffTimer )  ; %NWL%jQuery (  '  . toolbarundoredo button '  )  . addClass (  ' disabled '  )  ; %NWL%theDocumentValues . changed = false ; %NWL%theDocumentValues . touched = false ; %NWL%theDocument . settings = jQuery . parseJSON ( aDocument . settings )  ; %NWL%theDocument . metadata = jQuery . parseJSON ( aDocument . metadata )  ; %NWL%theDocument . contents = jQuery . parseJSON ( aDocument . contents )  ; %NWL%8
this . source = options . source ;%NWL%}%NWL%}%NWL%if ( options . repeat )  {%NWL%this . repeat = options . repeat ;%NWL%}%NWL%if ( options . offsetX )  {%NWL%this . offsetX = options . offsetX ;%NWL%}%NWL%if ( options . offsetY )  {%NWL%this . offsetY = options . offsetY ; %NWL%0
require (  "  .  / def / mozilla "  )  ; %NWL%require (  "  .  / def / e4x "  )  ; %NWL%require (  "  .  / def / fb - harmony "  )  ; %NWL%types . finalize (  )  ; %NWL%exports . Type = types . Type ; %NWL%exports . builtInTypes = types . builtInTypes ; %NWL%exports . namedTypes = types . namedTypes ; %NWL%exports . builders = types . builders ; %NWL%exports . defineMethod = types . defineMethod ; %NWL%exports . getFieldNames = types . getFieldNames ; %NWL%exports . getFieldValue = types . getFieldValue ; %NWL%4
getResponseData : function ( response )  {%NWL%Ext . Error . raise (  " getResponseData must be implemented in the Ext . data . reader . Reader subclass "  )  ;%NWL%}  ,%NWL%onMetaChange : function ( meta )  {%NWL%var me = this ,%NWL%fields = meta . fields || me . getFields (  )  ,%NWL%newModel ,%NWL%clientIdProperty ; %NWL%me . metaData = meta ; %NWL%me . root = meta . root || me . root ; %NWL%me . idProperty = meta . idProperty || me . idProperty ; %NWL%9
5 :  '  =  = 2 . 0 . 0 - alpha . x '  ,%NWL%6 :  '  >  = 2 . 0 . 0 - beta . 1 '%NWL%}  ; %NWL%__exports__ . REVISION_CHANGES = REVISION_CHANGES ; %NWL%var isArray = Utils . isArray ,%NWL%isFunction = Utils . isFunction ,%NWL%toString = Utils . toString ,%NWL%objectType =  '  [ object Object ]  '  ; %NWL%function HandlebarsEnvironment ( helpers , partials )  {%NWL%this . helpers = helpers || {  }  ; %NWL%this . partials = partials || {  }  ; %NWL%9
particle . h = 72 ; %NWL%particle . vy =  - 200 ; %NWL%particle . vo =  - 2 ; %NWL%particle . vsx =  - 2 ; %NWL%particle . vsy =  - 2 ; %NWL%particles . addParticle ( particle , 1 , 1 , t * 0 . 1 )  ;%NWL%}%NWL%if ( a )%NWL%{%NWL%particles . x = actorA . x ; %NWL%particles . y = actorA . y ; %NWL%9
one :   ' GET '  ,%NWL%create :  ' POST '  ,%NWL%update :  ' PUT '  ,%NWL%delete :  ' DELETE '  ,%NWL%}  ; %NWL%RequestBuilder . prototype . build = function (  )  {%NWL%var options =  {  }%NWL%, qs = null ; %NWL%options . url  = this . url (  )  ; %NWL%options . method = this . method (  )  ; %NWL%options . json  = this . json (  )  ; %NWL%8
this . paddingTop = template . paddingTop || 0 ; %NWL%this . right = template . right || 0 ; %NWL%this . scales = template . scales || {%NWL%default : 1 ,%NWL%width : 1 ,%NWL%height : 1 ,%NWL%auto : 1%NWL%}  ; %NWL%this . scaleToFit = template . scaleToFit || 1 ; %NWL%this . top = template . top || 0 ; %NWL%this . width = template . width || 0 ; %NWL%0
if ( this . windowId )  {%NWL%result . windowId = this . windowId ;%NWL%}%NWL%if ( this . obManualURL )  {%NWL%result . obManualURL = this . obManualURL ;%NWL%}%NWL%if ( this . command )  {%NWL%result . command = this . command ;%NWL%}%NWL%if ( this . tabId )  {%NWL%result . tabId = this . tabId ; %NWL%1
this . acceleration . fromJSON ( json . acceleration )  ; %NWL%this . accelerationSpread . fromJSON ( json . accelerationSpread )  ; %NWL%this . angularVelocity = json . angularVelocity ; %NWL%this . angularAcceleration = json . angularAcceleration ; %NWL%this . angularVelocitySpread = json . angularVelocitySpread ; %NWL%this . randomAngle = json . randomAngle ; %NWL%this . emissionRate = json . emissionRate ; %NWL%this . color . fromJSON ( json . color )  ; %NWL%this . colorSpread . fromJSON ( json . colorSpread )  ; %NWL%this . time = json . time ; %NWL%this . _time = json . _time ; %NWL%2
this . urlPreventCache = args . urlPreventCache?true : false ;%NWL%}%NWL%if ( args && " trimWhitespace " in args )  {%NWL%this . trimWhitespace = args . trimWhitespace?true : false ;%NWL%}%NWL%if ( args . url )  {%NWL%if ( !args . dataId )  {%NWL%throw new Error (  " dojo . data . HtmlStore : Cannot instantiate using url without an id! "  )  ;%NWL%}%NWL%this . url = args . url ; %NWL%this . dataId = args . dataId ; %NWL%9
{%NWL%props . datalistRef = json . get (  " datalistRef "  )  ; %NWL%props . valueColumn = json . get (  " valueColumn "  )  ; %NWL%props . labelColumn = json . get (  " labelColumn "  )  ;%NWL%}%NWL%if ( props . type =  =  " restJSON "  )%NWL%{%NWL%props . masterDataURL = json . get (  " masterDataURL "  )  ; %NWL%props . dataRootJsonQuery = json . get (  " dataRootJsonQuery "  )  ; %NWL%props . valueField = json . get (  " valueField "  )  ; %NWL%props . labelField = json . get (  " labelField "  )  ; %NWL%1
directives . directive (  ' areaStackedTimeSeries '  , function ( $rootScope , D3Service )  {%NWL%return {%NWL%restrict :  ' A '  ,%NWL%replace : true ,%NWL%templateUrl :  ' partials / area - stacked - timeseries . html '  ,%NWL%scope :  {%NWL%data :  '  =  '%NWL%}  ,%NWL%link : function ( scope )  {%NWL%scope . yAxisTickFormat = D3Service . yAxisTickFormat ; %NWL%scope . xAxisTickFormat = D3Service . xAxisTickFormat ; %NWL%9
method :  ' POST '  ,%NWL%success : function ( response )  {%NWL%$scope . isReply = true ; %NWL%value = JSON . parse ( response [  ' value '  ]  )  ; %NWL%$scope . id = value [  ' id '  ]  ; %NWL%$scope . name = value [  ' name '  ]  ; %NWL%$scope . screenName = value [  ' screenName '  ]  ; %NWL%$scope . location = value [  ' location '  ]  ; %NWL%$scope . description = value [  ' description '  ]  ; %NWL%$scope . followersCount = value [  ' followersCount '  ]  ; %NWL%$scope . friendsCount = value [  ' friendsCount '  ]  ; %NWL%4
delete this . points [ identifier ]  ;%NWL%}%NWL%}  ,%NWL%resample : function ( options )  {%NWL%if ( typeof options =  =  =  ' number '  )  {%NWL%options =  {%NWL%width : options%NWL%}  ;%NWL%}%NWL%options . input_index = typeof options . input_index =  =  =  ' number ' ? options . input_index : null ; %NWL%options . output_index = typeof options . output_index =  =  =  ' number ' ? options . output_index : null ; %NWL%9
BABYLON . Matrix . IdentityToRef ( this . _cachedTextureMatrix )  ; %NWL%break ;%NWL%}%NWL%return this . _cachedTextureMatrix ;%NWL%}  ; %NWL%Texture . prototype . clone = function (  )  {%NWL%var newTexture = new Texture ( this . _texture . url , this . getScene (  )  , this . _noMipmap , this . _invertY , this . _samplingMode )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%newTexture . wrapU = this . wrapU ; %NWL%newTexture . wrapV = this . wrapV ; %NWL%7
}  ,%NWL%createPlayer : function (  )  {%NWL%var self = this ; %NWL%var vc = document . createElement (  " div "  )  ; %NWL%vc . className =  " videoplayer_video_container "  ; %NWL%this . videoContainer = vc ; %NWL%var obj = document . createElement (  " object "  )  ; %NWL%obj . className =  " videoplayer_video "  ; %NWL%obj . type =  " video / quicktime "  ; %NWL%obj . width = this . options . width ; %NWL%obj . height = this . options . height ; %NWL%9
]  ,%NWL%function ( angular , _ , kbn )  {%NWL%' use strict '  ; %NWL%var module = angular . module (  ' kibana . services '  )  ; %NWL%module . factory (  ' InfluxDatasource '  , function ( $q , $http )  {%NWL%function InfluxDatasource ( datasource )  {%NWL%this . type =  ' influxDB '  ; %NWL%this . editorSrc =  ' app / partials / influxdb / editor . html '  ; %NWL%this . urls = datasource . urls ; %NWL%this . username = datasource . username ; %NWL%this . password = datasource . password ; %NWL%8
if ( Math . abs ( length )  <  = cc . math . EPSILON )%NWL%throw " current quaternion is an invalid value "  ; %NWL%this . scale ( 1 . 0 / length )  ; %NWL%return this ;%NWL%}  ; %NWL%proto . rotationAxis = function ( axis , angle )  {    /  / cc . kmQuaternionRotationAxis%NWL%var rad = angle * 0 . 5 , scale = Math . sin ( rad )  ; %NWL%this . w = Math . cos ( rad )  ; %NWL%this . x = axis . x * scale ; %NWL%this . y = axis . y * scale ; %NWL%this . z = axis . z * scale ; %NWL%9
}  )  ;%NWL%}  )  ;%NWL%}%NWL%$ (  ' a . geocode . button '  )  . live (  ' click '  , function (  )  {%NWL%var address = new Object (  )  ; %NWL%var $this = $ ( this )  ; %NWL%var lat ; %NWL%var lng ; %NWL%var uid = $this . attr (  ' data - uid '  )  ; %NWL%address . line_1 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_1\\ ]  ]  '  )  . val (  )  ; %NWL%address . line_2 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_2\\ ]  ]  '  )  . val (  )  ; %NWL%9
orientation :  " clockwise "  ,%NWL%_defaultIndicator : AnalogLineIndicator ,%NWL%startup : function (  )  {%NWL%if ( this . getChildren )  {%NWL%arr . forEach ( this . getChildren (  )  , function ( child )  { child . startup (  )  ;  }  )  ;%NWL%}%NWL%this . startAngle = Number ( this . startAngle )  ; %NWL%this . endAngle = Number ( this . endAngle )  ; %NWL%this . cx = Number ( this . cx )  ; %NWL%if ( !this . cx )  { this . cx = this . width / 2 ;  }%NWL%this . cy = Number ( this . cy )  ; %NWL%6
lodash . unique = arrays . uniq ; %NWL%lodash . unzip = arrays . zip ; %NWL%mixin ( lodash )  ; %NWL%lodash . clone = objects . clone ; %NWL%lodash . cloneDeep = objects . cloneDeep ; %NWL%lodash . contains = collections . contains ; %NWL%lodash . escape = utilities . escape ; %NWL%lodash . every = collections . every ; %NWL%lodash . find = collections . find ; %NWL%lodash . findIndex = arrays . findIndex ; %NWL%lodash . findKey = objects . findKey ; %NWL%3
}  ; %NWL%headtrackr . camshift . Rectangle = function ( x , y , w , h )  {%NWL%this . x = x ; %NWL%this . y = y ; %NWL%this . width = w ; %NWL%this . height = h ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . camshift . Rectangle (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%c . x = this . x ; %NWL%8
dojo . require (  " dojo . data . util . filter "  )  ; %NWL%dojo . require (  " dojo . date . stamp "  )  ; %NWL%dojo . experimental (  " dojox . data . AtomReadStore "  )  ; %NWL%dojo . declare (  " dojox . data . AtomReadStore "  , null ,  {%NWL%constructor : function ( args )  {%NWL%if ( args )  {%NWL%this . url = args . url ; %NWL%this . rewriteUrl = args . rewriteUrl ; %NWL%this . label = args . label || this . label ; %NWL%this . sendQuery =  ( args . sendQuery || args . sendquery || this . sendQuery )  ; %NWL%this . unescapeHTML = args . unescapeHTML ; %NWL%6
retrievers : ps%NWL%}  ; %NWL%cb ( err , result )  ;%NWL%}  )  ;%NWL%}%NWL%}  , function ( err , result )  {%NWL%if ( err )  {%NWL%return buildSets ( cb )  ;%NWL%}%NWL%result . ratingPlayers = result . retrievers . ratingPlayers ; %NWL%result . bots = result . retrievers . bots ; %NWL%9
sizes . forEach ( function ( size )  {%NWL%var ratio =  ( sourceSize . height / size . height )  ; %NWL%if ( size . width > sourceSize . width && size . height > sourceSize . height )  {%NWL%ratio = 1 ;%NWL%} else if ( sourceSize . width > size . width && sourceSize . height < size . height )  {%NWL%ratio =  ( sourceSize . width / size . width )  ;%NWL%} else if ( sourceSize . width < size . width && sourceSize . height > size . height )  {%NWL%ratio =  ( sourceSize . height / size . height )  ;%NWL%}%NWL%size . width = Math . floor ( sourceSize . width / ratio )  ; %NWL%size . height = Math . floor ( sourceSize . height / ratio )  ; %NWL%9
return path . first . string ;%NWL%}  )  ; %NWL%return path . join . apply ( null , paths )  ;%NWL%}  )  . raw = true ; %NWL%exports . red = function red ( color )  {%NWL%return exports . component ( color , new nodes . String (  ' red '  )  )  ;%NWL%}  ; %NWL%exports . green = function green ( color )  {%NWL%return exports . component ( color , new nodes . String (  ' green '  )  )  ;%NWL%}  ; %NWL%exports . blue = function blue ( color )  {%NWL%4
json = Component . prototype . toJSON . call ( this , json )  ; %NWL%json . width = this . width ; %NWL%json . height = this . height ; %NWL%json . aspect = this . aspect ; %NWL%json . autoResize = this . autoResize ; %NWL%json . background = this . background . toJSON ( json . background )  ; %NWL%json . far = this . far ; %NWL%json . near = this . near ; %NWL%json . fov = this . fov ; %NWL%json . orthographic = this . orthographic ; %NWL%json . orthographicSize = this . orthographicSize ; %NWL%1
var pluginNode = dom . byId ( pluginName )  ; %NWL%if ( pluginNode . content && pluginNode . content . root )  {%NWL%s . rawNode = pluginNode . content . root ; %NWL%surfaces [ s . _nodeName ]  = parentNode ;%NWL%} else {%NWL%s . rawNode = null ; %NWL%s . isLoaded = false ;%NWL%}%NWL%s . _nodes . push ( pluginNode )  ; %NWL%s . width  = g . normalizedLength ( width )  ; 	 /  / in pixels%NWL%s . height = g . normalizedLength ( height )  ; 	 /  / in pixels%NWL%9
this . preloadImg = img ;%NWL%}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . forms [ 0 ]  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%img . hspace = f . hspace . value ; %NWL%8
popup . style . top = max_top +  " px "  ; %NWL%if ( popup . offsetLeft > max_left )%NWL%popup . style . left = max_left +  " px "  ;%NWL%}%NWL%}%NWL%}  ; %NWL%EditArea . prototype . init = function (  )  {%NWL%this . textarea = document . getElementById (  " textarea "  )  ; %NWL%this . container = document . getElementById (  " container "  )  ; %NWL%this . result = document . getElementById (  " result "  )  ; %NWL%this . content_highlight = document . getElementById (  " content_highlight "  )  ; %NWL%7
this . promise = deferred . promise ; %NWL%return this ;%NWL%}  ,%NWL%stop : function (  )  {%NWL%$timeout . cancel ( this . timeoutId )  ; %NWL%this . timeoutId = null ;%NWL%}  ,%NWL%update : function ( opts )  {%NWL%opts . intevral = opts . intevral || this . opts . intevral ; %NWL%opts . params = opts . params || this . opts . params ; %NWL%opts . intevral = opts . intevral || this . opts . intevral ; %NWL%9
$ ( this )  . unbind (  ' mouseup '  )  ; %NWL%if ( evt . button =  = 2 )  {%NWL%$ (  "  . contextMenu "  )  . hide (  )  ; %NWL%var menu = $ (  ' # '  + o . menu )  ; %NWL%if ( $ ( el )  . hasClass (  ' disabled '  )  ) return false ; %NWL%var d =  {  }  , x , y ; %NWL%if ( self . innerHeight )  {%NWL%d . pageYOffset = self . pageYOffset ; %NWL%d . pageXOffset = self . pageXOffset ; %NWL%d . innerHeight = self . innerHeight ; %NWL%d . innerWidth = self . innerWidth ; %NWL%7
if ( !dojo . _hasResource [  " dojox . drawing . manager . StencilUI "  ]  )  {  /  / _hasResource checks added by build . Do not use _hasResource directly in your code .%NWL%dojo . _hasResource [  " dojox . drawing . manager . StencilUI "  ]  = true ; %NWL%dojo . provide (  " dojox . drawing . manager . StencilUI "  )  ;%NWL%( function (  )  {%NWL%var surface , surfaceNode ; %NWL%dojox . drawing . manager . StencilUI = dojox . drawing . util . oo . declare (%NWL%function ( options )  {%NWL%surface = options . surface ; %NWL%this . canvas = options . canvas ; %NWL%this . defaults = dojox . drawing . defaults . copy (  )  ; %NWL%this . mouse = options . mouse ; %NWL%8
dir : nl . dir . value ,%NWL%lang : nl . lang . value ,%NWL%usemap : nl . usemap . value ,%NWL%longdesc : nl . longdesc . value%NWL%}  )  ; %NWL%args . onmouseover = args . onmouseout =  '  '  ; %NWL%if ( f . onmousemovecheck . checked )  {%NWL%if ( nl . onmouseoversrc . value )%NWL%args . onmouseover =  " this . src =  '  "  + nl . onmouseoversrc . value +  "  '  ;  "  ; %NWL%if ( nl . onmouseoutsrc . value )%NWL%args . onmouseout =  " this . src =  '  "  + nl . onmouseoutsrc . value +  "  '  ;  "  ; %NWL%8
textBaseline :  ' bottom '  ,%NWL%weight : 1 ,%NWL%angle : 0%NWL%}  , style )  ; %NWL%ctx . save (  )  ; %NWL%ctx . translate ( x , y )  ; %NWL%ctx . rotate ( style . angle )  ; %NWL%ctx . fillStyle = style . color ; %NWL%ctx . font =  ( style . weight > 1 ? " bold "  :  "  "  )  +  ( style . size * 1 . 3 )  +  " px sans - serif "  ; %NWL%ctx . textAlign = style . textAlign ; %NWL%ctx . textBaseline = style . textBaseline ; %NWL%9
exports . amazon   = require (  "  .  / amazon "  )  ; %NWL%exports . bandcamp  = require (  "  .  / bandcamp "  )  ; %NWL%exports . beats   = require (  "  .  / beats "  )  ; %NWL%exports . earbits   = require (  "  .  / earbits "  )  ; %NWL%exports . focusatwill  = require (  "  .  / focusatwill "  )  ; %NWL%exports . google   = require (  "  .  / google "  )  ; %NWL%exports . hoopla   = require (  "  .  / hoopla "  )  ; %NWL%exports . jango   = require (  "  .  / jango "  )  ; %NWL%exports . pandora   = require (  "  .  / pandora "  )  ; %NWL%exports . playerfm  = require (  "  .  / playerfm "  )  ; %NWL%exports . plugdj   = require (  "  .  / plugdj "  )  ; %NWL%0
for ( var k in obj )  {%NWL%if ( obj . hasOwnProperty ( k )  ) keys . push ( k )  ;%NWL%}%NWL%return keys ;%NWL%}  ; %NWL%var pSlice = Array . prototype . slice ; %NWL%var assert = exports ; %NWL%assert . AssertionError = function AssertionError ( options )  {%NWL%this . name =  " AssertionError "  ; %NWL%this . message = options . message ; %NWL%this . actual = options . actual ; %NWL%9
var result = new this . _class ( this . attributes (  )  )  ; %NWL%result . newRecord = this . newRecord ; %NWL%return result ;%NWL%}  ,%NWL%attributes : function (  )  {%NWL%var result =  {  }  ; %NWL%for ( var i in this . _class . attributes )  {%NWL%var attr = this . _class . attributes [ i ]  ; %NWL%result [ attr ]  = this [ attr ]  ;%NWL%}%NWL%result . id = this . id ; %NWL%1
for ( key in defaults )  {%NWL%if ( key in opts ) continue ; %NWL%opts [ key ]  = defaults [ key ]  ;%NWL%}%NWL%this . host = host ; %NWL%this . admin = opts . admin ; %NWL%this . serial = opts . serial ; %NWL%this . refresh = opts . refresh ; %NWL%this . retry = opts . retry ; %NWL%this . expire = opts . expire ; %NWL%this . ttl = opts . ttl ; %NWL%5
iter . save . y = iter . y ; %NWL%iter . save . opacity = iter . opacity ;%NWL%}%NWL%}%NWL%return ;%NWL%}%NWL%UIFanMenu . prototype . expand = function (  )  {%NWL%this . getWindow (  )  . grab ( this )  ; %NWL%if ( this . save )  {%NWL%this . x = this . save . x ; %NWL%this . y = this . save . y ; %NWL%9
dojo . require (  " dojo . widget . HtmlWidget "  )  ; %NWL%dojo . widget . defineWidget (%NWL%" dojo . widget . TreeExpandToNodeOnSelect "  ,%NWL%dojo . widget . HtmlWidget ,%NWL%{%NWL%selector :  "  "  ,%NWL%controller :  "  "  ,%NWL%withSelected : false ,%NWL%initialize : function (  )  {%NWL%this . selector = dojo . widget . byId ( this . selector )  ; %NWL%this . controller = dojo . widget . byId ( this . controller )  ; %NWL%9
onValueChange : function ( cmp , evt , helper )  {%NWL%cmp . _log || ( cmp . _log =  [  ]  )  ; %NWL%cmp . _log . push ( evt . getParams (  )  )  ;%NWL%}  ,%NWL%onTriggerChange : function ( cmp , evt , helper )  {%NWL%var triggerCount = cmp . get (  " v . triggers . triggerCount "  )  ; %NWL%cmp . set (  " v . triggers . triggerCount "  ,  ( triggerCount || 0 )  + 1 )  ; %NWL%cmp . _lastTriggerCount =  ( cmp . _lastTriggerCount || 0 )  + 1 ;%NWL%}  ,%NWL%onTrigger2Change : function ( cmp , evt , helper )  {%NWL%cmp . _lastTrigger2Count =  ( cmp . _lastTrigger2Count || 0 )  + 1 ; %NWL%7
if ( query_raw . indices )  {%NWL%query_parameters . indices = query_raw . indices ;%NWL%}%NWL%if ( query_raw . maxmatches )  {%NWL%query_parameters . maxmatches = query_raw . maxmatches ;%NWL%}%NWL%if ( query_raw . selectlist )  {%NWL%query_parameters . selectlist = query_raw . selectlist ;%NWL%}%NWL%if ( query_raw . weights )  {%NWL%query_parameters . weights = query_raw . weights ; %NWL%1
this . sourcesContent = sourcesContent ; %NWL%this . file = file ; %NWL%this . _generatedMappings =  [  ]  ; %NWL%this . _originalMappings =  [  ]  ; %NWL%this . _parseMappings ( mappings , sourceRoot )  ;%NWL%}%NWL%SourceMapConsumer . fromSourceMap =%NWL%function SourceMapConsumer_fromSourceMap ( aSourceMap )  {%NWL%var smc = Object . create ( SourceMapConsumer . prototype )  ; %NWL%smc . _names = ArraySet . fromArray ( aSourceMap . _names . toArray (  )  , true )  ; %NWL%smc . _sources = ArraySet . fromArray ( aSourceMap . _sources . toArray (  )  , true )  ; %NWL%9
}  )  ;%NWL%}  )  ;%NWL%} else {%NWL%if ( onStart )  {%NWL%console . warn (  ' onStart will not work with noAutoStart option set to true '  )  ;%NWL%}%NWL%}%NWL%if ( options . flavor =  =  " fiber "  )  {%NWL%var proxy = wrapPromisesForFiber ( meteor , meteor . methods )  ; %NWL%proxy . getDDPSetup = meteor . getDDPSetup ; %NWL%proxy . useFixtures = meteor . useFixtures ; %NWL%9
gamification . proxy_url =  "  / proxy /  "  ;  /  / Replace this with your local proxy that the JSON will be requested through%NWL%gamification . no_badges_message =  " No badges yet "  ; %NWL%gamification . badges_to_show_max = 8 ; %NWL%gamification . tag_size_max = 18 ; %NWL%gamification . tag_size_min = 8 ; %NWL%gamification . tag_max_shown = 20 ; %NWL%gamification . $badge_container = null ; %NWL%gamification . init = function ( options )  {%NWL%gamification . server_url = options . server_url ; %NWL%if ( options . project_names ) gamification . project_names = options . project_names ; %NWL%gamification . user_name = options . user_name ; %NWL%8
return _updateChildrenFromSpec ( false , true )  ;%NWL%}  ; %NWL%xfClusterInstance . restoreVisualState = function ( state )  {%NWL%this . cleanState (  )  ; %NWL%_UIObjectState . xfId = state . xfId ; %NWL%_UIObjectState . UIType = state . UIType ; %NWL%_UIObjectState . isExpanded = state . isExpanded ; %NWL%_UIObjectState . isSelected = state . isSelected ; %NWL%_UIObjectState . isHighlighted = state . isHighlighted ; %NWL%_UIObjectState . showToolbar = state . showToolbar ; %NWL%_UIObjectState . showDetails = state . showDetails ; %NWL%4
}%NWL%if (  ' direction ' in element )  {%NWL%obj . trend = directionToTrend ( element . direction )  ; %NWL%obj . direction = element . direction ;%NWL%}%NWL%obj . datetime = element . date ; %NWL%if ( req . rawbg )  {%NWL%obj . filtered = element . filtered ; %NWL%obj . unfiltered = element . unfiltered ; %NWL%obj . noise = element . noise ; %NWL%obj . rssi = element . rssi ; %NWL%3
alert ( gStrbundle . getString (  " dupAccount "  )  )  ; %NWL%return false ;%NWL%}%NWL%}%NWL%}%NWL%gSite . account    = $ (  ' account '  )  . value ; %NWL%gSite . folder    = $ (  ' folder '  )  . value ; %NWL%gSite . host    = $ (  ' host '  )  . value . trim (  )  ; %NWL%gSite . port    = $ (  ' port '  )  . value ; %NWL%gSite . login    = $ (  ' login '  )  . value . trim (  )  ; %NWL%gSite . password   = $ (  ' password '  )  . value ; %NWL%5
this . cache = new Cache (  )  ; %NWL%var cacheOptions =  {%NWL%key : function ( type )  { return type ? " describe .  "  + type :  " describe "  ;  }%NWL%}  ; %NWL%this . describe$ = this . cache . makeCacheable ( this . describe , this , cacheOptions )  ; %NWL%this . describe = this . cache . makeResponseCacheable ( this . describe , this , cacheOptions )  ; %NWL%this . describeSObject$ = this . describe$ ; %NWL%this . describeSObject = this . describe ; %NWL%cacheOptions =  { key :  ' describeGlobal '  }  ; %NWL%this . describeGlobal$ = this . cache . makeCacheable ( this . describeGlobal , this , cacheOptions )  ; %NWL%this . describeGlobal = this . cache . makeResponseCacheable ( this . describeGlobal , this , cacheOptions )  ; %NWL%5
this . el = el . find (  '  . Button -  '  + name )  ; %NWL%return this . el ;%NWL%}  ; %NWL%app . Tool = function ( game , name , mouseOffset )  {%NWL%this . game = game ; %NWL%this . el = this . elem . find (  '  . Tool -  '  + name )  ; %NWL%this . container = this . el . closest (  '  . Tool - container '  )  ; %NWL%this . isSelected = false ; %NWL%this . color = this . el . data (  ' color '  )  ; %NWL%this . height = this . el . height (  )  ; %NWL%this . width = this . el . width (  )  ; %NWL%9
json . worldSpace = this . worldSpace ; %NWL%json . minEmission = this . minEmission ; %NWL%json . maxEmission = this . maxEmission ; %NWL%json . minLife = this . minLife ; %NWL%json . maxLife = this . maxLife ; %NWL%json . minSize = this . minSize ; %NWL%json . maxSize = this . maxSize ; %NWL%json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%7
if ( moveUp )  {%NWL%var rule = rules . output . members [ moveUp ]  ; %NWL%delete rules . output . members [ moveUp ]  ; %NWL%update ( rules . output . members , rule . members )  ;%NWL%}%NWL%}%NWL%rules = copy ( rules )  ; %NWL%rules . input = new InputShape ( rules . input , options )  . rules ; %NWL%rules . output = new OutputShape ( rules . output , options )  . rules ; %NWL%rules . input . members = rules . input . members || {  }  ; %NWL%rules . output . members = rules . output . members || {  }  ; %NWL%9
if ( typeof settings =  =  ' function '  )%NWL%settings =  { onAfter : settings }  ; %NWL%if ( target =  =  ' max '  )%NWL%target = 9e9 ; %NWL%settings = $ . extend (  {  }  , $scrollTo . defaults , settings )  ; %NWL%duration = duration || settings . speed || settings . duration ; %NWL%settings . queue = settings . queue && settings . axis . length > 1 ; %NWL%if ( settings . queue )%NWL%duration /  = 2 ; %NWL%settings . offset = both ( settings . offset )  ; %NWL%settings . over = both ( settings . over )  ; %NWL%9
exports . update = GameWorldModelIso . prototype . update ; %NWL%exports . getAllVisibleCells = GameWorldModelIso . prototype . getAllVisibleCells ; %NWL%exports . getSortCellOfSprite = GameWorldModelIso . prototype . getSortCellOfSprite ; %NWL%exports . getRandomOnScreenCel = GameWorldModelIso . prototype . getRandomOnScreenCel ; %NWL%exports . getRandomOnScreenCellWorldValues = GameWorldModelIso . prototype . getRandomOnScreenCellWorldValues ; %NWL%exports . getVisibleCellFromWorldCell = GameWorldModelIso . prototype . getVisibleCellFromWorldCell ; %NWL%exports . getWorldCellFromVisibleCell = GameWorldModelIso . prototype . getWorldCellFromVisibleCell ; %NWL%exports . getWorldCellFromScreenCoord = GameWorldModelIso . prototype . getWorldCellFromScreenCoord ; %NWL%exports . getCell = GameWorldModelIso . prototype . getCell ; %NWL%exports . rightFloor = GameWorldModelIso . prototype . rightFloor ; %NWL%exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%0
var azureScheduler = require (  ' azure - scheduler '  )  ; %NWL%exports . SchedulerClient = azureScheduler . SchedulerClient ; %NWL%exports . createSchedulerClient = azureScheduler . createSchedulerClient ; %NWL%var azureMonitoring = require (  ' azure - monitoring '  )  ; %NWL%exports . EventsClient = azureMonitoring . EventsClient ; %NWL%exports . createEventsClient = azureMonitoring . createEventsClient ; %NWL%exports . AlertsClient = azureMonitoring . AlertsClient ; %NWL%exports . AutoScaleClient = azureMonitoring . AutoScaleClient ; %NWL%exports . createAutoScaleClient = azureMonitoring . createAutoScaleClient ; %NWL%exports . MetricsClient = azureMonitoring . MetricsClient ; %NWL%exports . createMetricsClient = azureMonitoring . createMetricsClient ; %NWL%4
if ( aqt . x && aqt . x . token =  =  =  ' var ' && bindings [ aqt . x . value ] ! = null )  {%NWL%aqt . x = bindings [ aqt . x . value ]  ;%NWL%}%NWL%if ( aqt . y && aqt . y . token =  =  =  ' var ' && bindings [ aqt . y . value ] ! = null )  {%NWL%aqt . y = bindings [ aqt . y . value ]  ;%NWL%}%NWL%} else if ( aqt . kind =  =  =  ' UNION '  )  {%NWL%aqt . value [ 0 ]  = this . bind ( aqt . value [ 0 ]  , bindings )  ; %NWL%aqt . value [ 1 ]  = this . bind ( aqt . value [ 1 ]  , bindings )  ;%NWL%} else if ( aqt . kind =  =  =  ' GRAPH '  )  {%NWL%aqt . value = this . bind ( aqt . value , bindings )  ; %NWL%7
return " crop "  ;%NWL%}%NWL%init (  )  {%NWL%this . _availableRatios =  {  }  ; %NWL%this . _ratios =  {  }  ; %NWL%let controlsTemplate = fs . readFileSync ( __dirname +  "  /  .  .  /  .  .  /  .  .  / templates / night / operations / crop_controls . jst "  ,  " utf - 8 "  )  ; %NWL%this . _controlsTemplate = controlsTemplate ; %NWL%let canvasControlsTemplate = fs . readFileSync ( __dirname +  "  /  .  .  /  .  .  /  .  .  / templates / night / operations / crop_canvas . jst "  ,  " utf - 8 "  )  ; %NWL%this . _canvasControlsTemplate = canvasControlsTemplate ; %NWL%this . _onKnobDown = this . _onKnobDown . bind ( this )  ; %NWL%this . _onKnobDrag = this . _onKnobDrag . bind ( this )  ; %NWL%9
else%NWL%{%NWL%form . ftp_root_path . value =  "  /  "  ;%NWL%}%NWL%}%NWL%var params =  [  ]  ; %NWL%params . ftp_user = jQuery (  " #ftp_user "  )  . val (  )  ; %NWL%params . ftp_password = jQuery (  " #ftp_password "  )  . val (  )  ; %NWL%params . ftp_host = jQuery (  " #ftp_host "  )  . val (  )  ; %NWL%params . ftp_port = jQuery (  " #ftp_port "  )  . val (  )  ; %NWL%params . ftp_root_path = jQuery (  " #ftp_root_path "  )  . val (  )  ; %NWL%6
if ( c . oauth_token_secret ) token (  ' oauth_token_secret '  , c . oauth_token_secret )  ; %NWL%return oauth ;%NWL%}  ; %NWL%oauth . options = function ( _ )  {%NWL%if ( !arguments . length ) return o ; %NWL%o = _ ; %NWL%o . url = o . url || ' http :  /  / www . openstreetmap . org '  ; %NWL%o . landing = o . landing || ' land . html '  ; %NWL%o . singlepage = o . singlepage || false ; %NWL%o . loading = o . loading || function (  )  {  }  ; %NWL%o . done = o . done || function (  )  {  }  ; %NWL%9
}%NWL%if ( !questions )  {%NWL%throw new Error (  ' No question was specified '  )  ;%NWL%}%NWL%var self   = this ; %NWL%this . console  = new Console (  )  ; %NWL%this . options  = options ; %NWL%this . id    = options . id ; %NWL%this . description = options . description ; %NWL%this . repeat   = options . repeat || false ; %NWL%this . preAsk   = options . preAsk || false ; %NWL%9
Object . defineProperties ( image_sprite , image_sprite_static_properties )  ; %NWL%Object . defineProperties ( image_sprite ,  ( function (  )  {%NWL%var img_element = null ; %NWL%function add_image_element ( img )  {%NWL%img_element = img ; %NWL%if ( img_element . id ! =  =  '  '  )  {%NWL%console . assert ( typeof img_element . id =  =  =  ' string '  ,  " img_element . id is a string "  , img_element . id )  ; %NWL%image_sprite . id = img_element . id ;%NWL%}%NWL%image_sprite . width = img_element . width ; %NWL%image_sprite . height = img_element . height ; %NWL%7
Format . prototype . writeBuffer = function ( buffer , offset )  {%NWL%buffer . writeUInt8 ( this . depth   , offset )  ; %NWL%buffer . writeUInt8 ( this . bpp    , offset + 1 )  ; %NWL%buffer . writeUInt8 ( this . scanline_pad , offset + 2 )  ; %NWL%return offset + this . length ;%NWL%}%NWL%function VisualType ( visualid , _class , bits_per_rgb , colormap_entries , red_mask , green_mask , blue_mask )  {%NWL%this . visualid = visualid || 0 ; %NWL%this . class = _class || 0 ; %NWL%this . bits_per_rgb = bits_per_rgb || 0 ; %NWL%this . colormap_entries = colormap_entries || 0 ; %NWL%7
{%NWL%this . _super (  ' scale '  )  ; %NWL%if ( pc . valid ( options )  )%NWL%this . config ( options )  ;%NWL%}  ,%NWL%config : function ( options )%NWL%{%NWL%this . x = pc . checked ( options . x , 1 )  ; %NWL%this . y = pc . checked ( options . y , 1 )  ; %NWL%this . growX = pc . checked ( options . growX , 0 )  ; %NWL%this . growY = pc . checked ( options . growY , 0 )  ; %NWL%9
} else {%NWL%res . send (  ' ratelimit forbidden . limit is '  + limitCount +  ' per day .  '  )  ;%NWL%}%NWL%}  )  ;%NWL%}  ;%NWL%}  ;%NWL%}  ; %NWL%exports . peruserperday = makePerDayLimiter (  ' peruserperday '  , function ( req )  {%NWL%return ( req . user || req . session . user )  . loginname ;%NWL%}  )  ; %NWL%exports . peripperday = makePerDayLimiter (  ' peripperday '  , function ( req )  {%NWL%7
scope . showAM = !!formats [ 3 ]  ; %NWL%scope . isAM =  ( $timepicker . $date || hours [ midIndex ]  . date )  . getHours (  )  < 12 ; %NWL%scope . timeSeparator = formats [ 1 ]  ; %NWL%$timepicker . $isBuilt = true ;%NWL%}  ; %NWL%$timepicker . $isSelected = function ( date , index )  {%NWL%if ( !$timepicker . $date ) return false ; %NWL%else if ( index =  =  = 0 )  {%NWL%return date . getHours (  )  =  =  = $timepicker . $date . getHours (  )  ;%NWL%} else if ( index =  =  = 1 )  {%NWL%return date . getMinutes (  )  =  =  = $timepicker . $date . getMinutes (  )  ; %NWL%8
return {%NWL%log  : prepareLogFn ( $log . log ,  className , colorCSS )  ,%NWL%info  : prepareLogFn ( $log . info ,  className , colorCSS )  ,%NWL%warn  : prepareLogFn ( $log . warn ,  className , colorCSS )  ,%NWL%debug : prepareLogFn ( $log . debug ,  className , colorCSS )  ,%NWL%error : prepareLogFn ( $log . error ,  className )  /  / NO styling of ERROR messages%NWL%}  ;%NWL%}  ; %NWL%$log . log  = prepareLogFn ( $log . log )  ; %NWL%$log . info  = prepareLogFn ( $log . info )  ; %NWL%$log . warn  = prepareLogFn ( $log . warn )  ; %NWL%9
var vx = v . x , vy = v . y , vz = v . z , vw = v . w ? v . w : 1 . 0 ; %NWL%v . x = this . n11 * vx + this . n12 * vy + this . n13 * vz + this . n14 * vw ; %NWL%v . y = this . n21 * vx + this . n22 * vy + this . n23 * vz + this . n24 * vw ; %NWL%v . z = this . n31 * vx + this . n32 * vy + this . n33 * vz + this . n34 * vw ; %NWL%vw = this . n41 * vx + this . n42 * vy + this . n43 * vz + this . n44 * vw ; %NWL%if ( v . w )  {%NWL%v . w = vw ;%NWL%} else {%NWL%v . x = v . x / vw ; %NWL%v . y = v . y / vw ; %NWL%v . z = v . z / vw ; %NWL%8
}  ; %NWL%self . getWrapperDom = getWrapperDom = function (  )  {%NWL%return wrapperDom ;%NWL%}  ; %NWL%self . getContentDom = getContentDom = function (  )  {%NWL%return contentDom ;%NWL%}  ; %NWL%self . getWrapperEl = getWrapperEl = function (  )  {%NWL%return wrapperEl ;%NWL%}  ; %NWL%self . getContentEl = getContentEl = function (  )  {%NWL%1
air . BitmapData = window . runtime . flash . display . BitmapData ; %NWL%air . Keyboard = window . runtime . flash . ui . Keyboard ; %NWL%air . KeyLocation = window . runtime . flash . ui . KeyLocation ; %NWL%air . Mouse = window . runtime . flash . ui . Mouse ; %NWL%air . ReferencesValidationSetting = window . runtime . flash . security . ReferencesValidationSetting ; %NWL%air . RevocationCheckSettings = window . runtime . flash . security . RevocationCheckSettings ; %NWL%air . SignatureStatus = window . runtime . flash . security . SignatureStatus ; %NWL%air . SignerTrustSettings = window . runtime . flash . security . SignerTrustSettings ; %NWL%air . XMLSignatureValidator = window . runtime . flash . security . XMLSignatureValidator ; %NWL%air . ByteArray = window . runtime . flash . utils . ByteArray ; %NWL%air . CompressionAlgorithm = window . runtime . flash . utils . CompressionAlgorithm ; %NWL%9
scope . showAM = !!formats [ 3 ]  ; %NWL%scope . isAM =  ( $timepicker . $date || hours [ midIndex ]  . date )  . getHours (  )  < 12 ; %NWL%scope . timeSeparator = formats [ 1 ]  ; %NWL%$timepicker . $isBuilt = true ;%NWL%}  ; %NWL%$timepicker . $isSelected = function ( date , index )  {%NWL%if ( !$timepicker . $date ) return false ; %NWL%else if ( index =  =  = 0 )  {%NWL%return date . getHours (  )  =  =  = $timepicker . $date . getHours (  )  ;%NWL%} else if ( index =  =  = 1 )  {%NWL%return date . getMinutes (  )  =  =  = $timepicker . $date . getMinutes (  )  ; %NWL%8
datapoints . points [ k + 2 ]  = pointsBottom [ j + 1 ]  ; %NWL%j +  = ps ;%NWL%}%NWL%k +  = 3 ;%NWL%}%NWL%if ( series . lines . lineWidth > 0 )  {  /  / Let ' s draw line in separate series%NWL%var newSerie = $ . extend (  {  }  , series )  ; %NWL%newSerie . lines = $ . extend (  {  }  , series . lines )  ; %NWL%newSerie . lines . fill = undefined ; %NWL%newSerie . label = undefined ; %NWL%newSerie . datapoints = $ . extend (  {  }  , series . datapoints )  ; %NWL%7
var console =  ( window . console )  ; %NWL%if ( !console [  " log "  ]  )%NWL%{%NWL%if ( window [  " log4javascript "  ]  )%NWL%{%NWL%var log = log4javascript . getDefaultLogger (  )  ; %NWL%console . log = bind ( log . info , log )  ; %NWL%console . debug = bind ( log . debug , log )  ; %NWL%console . info = bind ( log . info , log )  ; %NWL%console . warn = bind ( log . warn , log )  ; %NWL%console . error = bind ( log . error , log )  ; %NWL%7
DataSourceCacheExtension . prototype =  {%NWL%initializer : function ( config )  {%NWL%this . doBefore (  " _defRequestFn "  , this . _beforeDefRequestFn )  ; %NWL%this . doBefore (  " _defResponseFn "  , this . _beforeDefResponseFn )  ;%NWL%}  ,%NWL%_beforeDefRequestFn : function ( e )  {%NWL%var entry =  ( this . retrieve ( e . request )  ) || null ,%NWL%payload = e . details [ 0 ]  ; %NWL%if ( entry && entry . response )  {%NWL%payload . cached  = entry . cached ; %NWL%payload . response = entry . response ; %NWL%9
El . fly = function ( el , named )  {%NWL%var ret = null ; %NWL%named = named || ' _global '  ; %NWL%if ( el = Ext . getDom ( el )  )  {%NWL%( El . _flyweights [ named ]  = El . _flyweights [ named ] || new El . Flyweight (  )  )  . dom = el ; %NWL%ret = El . _flyweights [ named ]  ;%NWL%}%NWL%return ret ;%NWL%}  ; %NWL%Ext . get = El . get ; %NWL%Ext . fly = El . fly ; %NWL%9
return new Tabletop ( options )  ;%NWL%}%NWL%if ( typeof ( options )  =  =  =  ' string '  )  {%NWL%options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%8
doc . params . forEach ( function ( param )  {%NWL%var paramInfo =  {%NWL%name : param . name%NWL%}  ; %NWL%params . push ( paramInfo )  ; %NWL%paramInfo . types = getTypes ( param . type . names )  ; %NWL%if ( typeof param . variable =  =  ' boolean '  )  {%NWL%paramInfo . variable = param . variable ;%NWL%}%NWL%if ( typeof param . optional =  =  ' boolean '  )  {%NWL%paramInfo . optional = param . optional ; %NWL%7
serverCommunications . send (  { type :  ' get_document_update '  }  )  ;%NWL%}%NWL%}%NWL%editorHelpers . saveDocument = function ( callback )  {%NWL%var documentData =  {  }  ; %NWL%theDocument . title = jQuery (  ' #document - title '  )  . text (  )  . trim (  )  ; %NWL%if ( theDocumentValues . control )  {%NWL%documentData . settings = JSON . stringify ( theDocument . settings )  ; %NWL%documentData . metadata = JSON . stringify ( theDocument . metadata )  ; %NWL%documentData . title = theDocument . title . substring ( 0 , 255 )  ; %NWL%documentData . contents = JSON . stringify ( theDocument . contents )  ; %NWL%7
var map =  {%NWL%version : this . _version ,%NWL%sources : this . _sources . toArray (  )  ,%NWL%names : this . _names . toArray (  )  ,%NWL%mappings : this . _serializeMappings (  )%NWL%}  ; %NWL%if ( this . _file ! = null )  {%NWL%map . file = this . _file ;%NWL%}%NWL%if ( this . _sourceRoot ! = null )  {%NWL%map . sourceRoot = this . _sourceRoot ; %NWL%7
this . displayed = true ; %NWL%if ( this . dirty )  {%NWL%this . _updateContents ( this . dom . content )  ; %NWL%this . _updateTitle ( this . dom . box )  ; %NWL%this . _updateDataAttributes ( this . dom . box )  ; %NWL%this . _updateStyle ( this . dom . box )  ; %NWL%var className =  ( this . data . className? '  '  + this . data . className :  '  '  )  +%NWL%( this . selected ? ' selected '  :  '  '  )  ; %NWL%dom . box . className =  ' item box '  + className ; %NWL%dom . line . className =  ' item line '  + className ; %NWL%dom . dot . className  =  ' item dot '  + className ; %NWL%8
contextMenu = document . getElementById (  ' contentAreaContextMenu '  )  ; %NWL%if ( !contextMenu ) contextMenu = document . getElementById (  ' msgComposeContext '  )  ; %NWL%contextMenu . addEventListener (  ' popupshowing '  , function ( e )  {%NWL%markdown_here . contextMenuShowing ( e )  ;%NWL%}  , false )  ; %NWL%this . setupButton (  )  ; %NWL%markdown_here . imports . OptionsStore . get ( function ( prefs )  {%NWL%function hotkeyHandler ( event )  {%NWL%if ( event . shiftKey =  =  = prefs . hotkey . shiftKey &&%NWL%event . ctrlKey =  =  = prefs . hotkey . ctrlKey &&%NWL%event . altKey =  =  = prefs . hotkey . altKey &&%NWL%9
}  ; %NWL%rank ( step , $ ( macros )  )  ;%NWL%}  ; %NWL%module . exports = Competition ;%NWL%}  ,  {  "  .  / LevenshteinDistanceScore "  : 18 ,  "  .  / Array "  : 11 }  ]  , 11 :  [ function ( require , module , exports )  {%NWL%var fn = require (  '  .  / fn '  )  ; %NWL%module . exports = function ( obj )  {%NWL%function ensure_array ( obj )  {%NWL%var array = obj ? [  ]  . concat ( obj )  :  [  ]  ; %NWL%array . in_array = fn . curry ( array , in_array , array )  ; %NWL%array . each = fn . curry ( array , each , array )  ; %NWL%9
}  ,%NWL%border :  {%NWL%weight : 1 ,%NWL%alpha : 1%NWL%}  ,%NWL%width : 10 ,%NWL%height : 10 ,%NWL%shape :  " circle "%NWL%}  ; %NWL%defs . fill . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " fill "  )  ; %NWL%defs . border . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " border "  )  ; %NWL%9
this . emitter . setMaxListeners ( Infinity )  ; %NWL%this . initialize ( options )  ; %NWL%this . suite = this . loadTestsuite ( options . file )  ;%NWL%}  ; %NWL%Suite . prototype =  {%NWL%initialize : function ( options )  {%NWL%this . driverEmitter = options . driverEmitter ; %NWL%this . reporterEmitter = options . reporterEmitter ; %NWL%this . driver = options . driver ; %NWL%this . name = options . file ; %NWL%this . numberOfSuites = options . numberOfSuites ; %NWL%6
self . filterText =  "  "  ; %NWL%self . initialize = _initialize ; %NWL%self . toggleAddMode = _toggleAddMode ; %NWL%self . toggleEditMode = _toggleEditMode ; %NWL%self . createItem = _createItem ; %NWL%self . readItem = _readItem ; %NWL%self . updateItem = _updateItem ; %NWL%self . deleteItemWithConfirmation = _deleteItemWithConfirmation ; %NWL%self . deleteItem = _deleteItem ; %NWL%self . getAllItems = _getAllItems ; %NWL%self . updateModeKeyUp = _updateModeKeyUp ; %NWL%1
this . elem = $ (  '  < div class =  " iceberg hidden "  >  <  / div >  '  )  ; %NWL%this . game . icebergsElem . append ( this . elem )  ;%NWL%}%NWL%pools . mixin ( Iceberg )  ; %NWL%Iceberg . prototype . onInit = function ( type , x )  {%NWL%var classes =  ' hidden hit iceberg -  - 1 iceberg -  - 2 iceberg -  - 3 '  +%NWL%' iceberg -  - 4 iceberg -  - 5 iceberg -  - 6 '  ; %NWL%this . elem . removeClass ( classes )  . addClass ( type . css )  ; %NWL%this . dead = false ; %NWL%this . height = type . height ; %NWL%this . width = type . width ; %NWL%9
Model . first = persistUtil . bind (  ' first '  , Model . first , Model )  ; %NWL%Model . last = function ( connection , callback )  {%NWL%var query = this . using ( connection )  ; %NWL%return query . last . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . last = persistUtil . bind (  ' last '  , Model . last , Model )  ; %NWL%Model . deleteAll = function ( connection , callback )  {%NWL%var query = this . using ( connection )  ; %NWL%return query . deleteAll . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . deleteAll = persistUtil . bind (  ' deleteAll '  , Model . deleteAll , Model )  ; %NWL%0
}%NWL%var media = new ( tree . Media )  (  [  ]  ,  [  ]  )  ; %NWL%if ( this . debugInfo )  {%NWL%this . ruleset . debugInfo = this . debugInfo ; %NWL%media . debugInfo = this . debugInfo ;%NWL%}%NWL%media . features = this . features . eval ( env )  ; %NWL%env . mediaPath . push ( media )  ; %NWL%env . mediaBlocks . push ( media )  ; %NWL%env . frames . unshift ( this . ruleset )  ; %NWL%media . ruleset = this . ruleset . eval ( env )  ; %NWL%6
this . velocityType = other . velocityType ; %NWL%this . material = other . material ; %NWL%this . position . copy ( other . position )  ; %NWL%this . positionSpread . copy ( other . positionSpread )  ; %NWL%this . positionRadius = other . positionRadius ; %NWL%this . speed = other . speed ; %NWL%this . speedSpread = other . speedSpread ; %NWL%this . worldSpace = other . worldSpace ; %NWL%this . minEmission = other . minEmission ; %NWL%this . maxEmission = other . maxEmission ; %NWL%this . minLife = other . minLife ; %NWL%0
var split = url . split (  ' ? '  )  ; %NWL%this . url = split [ 0 ]  ; %NWL%this . query = split . length > 1 ? normalizeQuery ( split [ 1 ]  )  : undefined ;%NWL%}%NWL%this . data = normalizeQuery ( stubData )  ; %NWL%this . method = method ; %NWL%this . andReturn = function ( options )  {%NWL%this . status = options . status || 200 ; %NWL%this . contentType = options . contentType ; %NWL%this . response = options . response ; %NWL%this . responseText = options . responseText ; %NWL%8
_ref2 =  [  ' top '  ,  ' left '  ,  ' bottom '  ,  ' right '  ]  ; %NWL%for ( _j = 0 , _len1 = _ref2 . length ; _j < _len1 ; _j +  +  )  {%NWL%side = _ref2 [ _j ]  ; %NWL%offset [ side ]  -  = parseFloat ( $offsetParent . css (  " border -  "  + side +  "  - width "  )  , 10 )  ;%NWL%}%NWL%transcribe ( same . offset , offset )  ; %NWL%moved = true ;%NWL%} else {%NWL%css . position =  ' absolute '  ; %NWL%css . top =  "  "  + position . page . top +  " px "  ; %NWL%css . left =  "  "  + position . page . left +  " px "  ; %NWL%9
return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%3
_p . clearStencil = _p . _clearStencilForWebGL ; %NWL%_p . visit = _p . _visitForWebGL ; %NWL%_p . draw = _p . _drawForWebGL ; %NWL%_p . setClearColor = _p . _setClearColorForWebGL ;%NWL%} else {%NWL%_p . ctor = _p . _ctorForCanvas ; %NWL%_p . cleanup = _p . _cleanupForCanvas ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForCanvas ; %NWL%_p . begin = _p . _beginForCanvas ; %NWL%_p . _beginWithClear = _p . _beginWithClearForCanvas ; %NWL%_p . end = _p . _endForCanvas ; %NWL%5
this . onSuiteStarting = _status . onSuiteStarting ; %NWL%this . onSuiteCompleted = _status . onSuiteCompleted ; %NWL%this . onSuiteSetupStarting = _status . onSuiteSetupStarting ; %NWL%this . onSuiteSetupCompleted = _status . onSuiteSetupCompleted ; %NWL%this . onSuiteTeardownStarting = _status . onSuiteTeardownStarting ; %NWL%this . onSuiteTeardownCompleted = _status . onSuiteTeardownCompleted ; %NWL%this . onTestGroupStarting = _status . onTestGroupStarting ; %NWL%this . onTestGroupCompleted = _status . onTestGroupCompleted ; %NWL%this . onTestSetupStarting = _status . onTestSetupStarting ; %NWL%this . onTestSetupCompleted = _status . onTestSetupCompleted ; %NWL%this . onTestTeardownStarting = _status . onTestTeardownStarting ; %NWL%0
if ( params . options [ i ]  =  =  = undefined ) params . options [ i ]  = options [ i ]%NWL%}%NWL%return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . post = def ( request . post )%NWL%de . put = def ( request . put )%NWL%de . head = def ( request . head )%NWL%7
crawler (  )  ; %NWL%function crawler ( done )  {%NWL%done = done || noop ; %NWL%if ( loaded ) return done (  )  ; %NWL%if ( loading ) return queue . push ( done )  ; %NWL%loading = true ; %NWL%request%NWL%. get (  ' http :  /  / component - crawler . herokuapp . com /  . json '  )%NWL%. end ( function ( err , res )  {%NWL%crawler . users = res . body . users ; %NWL%crawler . components = res . body . components ; %NWL%9
exports . createMenuItem = function createMenuItem (  )  {%NWL%}  ; %NWL%exports . createSeperatorMenuItem = function createSeperatorMenuItem (  )  {%NWL%}  ; %NWL%exports . createCheckMenuItem = function createCheckMenuItem (  )  {%NWL%}  ; %NWL%exports . setBadge = function setBadge (  )  {%NWL%}  ; %NWL%exports . setBadgeImage = function setBadgeImage (  )  {%NWL%}  ; %NWL%exports . setDockIcon = function setDockIcon (  )  {%NWL%0
beforeEach ( function (  )  {%NWL%spies . plot . groupSelect = jasmine . createSpy (  ' groupSelect '  )  ; %NWL%spies . plot . groupSelect . and . returnValue (  { entry : selectSpies , selection : selectSpies }  )  ; %NWL%spies . g . selectAll = jasmine . createSpy (  ' selectAll '  )  ; %NWL%spies . g . selectAll . and . returnValue ( selectSpies )  ; %NWL%spies . g . select = jasmine . createSpy (  ' select '  )  ; %NWL%spies . g . select . and . returnValue ( selectSpies )  ; %NWL%selectSpies . selectAll = spies . g . selectAll ; %NWL%selectSpies . append = jasmine . createSpy (  ' append '  )  ; %NWL%selectSpies . append . and . returnValue ( selectSpies )  ; %NWL%selectSpies . attr = jasmine . createSpy (  ' attr '  )  ; %NWL%8
function createHelper ( settings )  {%NWL%if ( helper . parent )%NWL%return ; %NWL%helper . parent = $ (  '  < div id =  "  '  + settings . id +  '  "  >  < h3 >  <  / h3 >  < div class =  " body "  >  <  / div >  < div class =  " url "  >  <  / div >  <  / div >  '  )%NWL%. appendTo ( document . body )%NWL%. hide (  )  ; %NWL%if ( $ . fn . bgiframe )%NWL%helper . parent . bgiframe (  )  ; %NWL%helper . title = $ (  ' h3 '  , helper . parent )  ; %NWL%helper . body = $ (  ' div . body '  , helper . parent )  ; %NWL%helper . url = $ (  ' div . url '  , helper . parent )  ; %NWL%9
} else if ( navigator . appVersion . indexOf (  " Mac "  )  =  =  - 1 && window . execScript )  {%NWL%var version =  - 1 ; %NWL%for ( var i = 0 ; i < activeXDetectRules . length && version =  =  - 1 ; i +  +  )  {%NWL%var obj = getActiveXObject ( activeXDetectRules [ i ]  . name )  ; %NWL%if ( !obj . activeXError )  {%NWL%self . installed = true ; %NWL%version = activeXDetectRules [ i ]  . version ( obj )  ; %NWL%if ( version! =  - 1 )  {%NWL%var versionObj = parseActiveXVersion ( version )  ; %NWL%self . raw = versionObj . raw ; %NWL%self . major = versionObj . major ; %NWL%9
this . horizontal . contains = this . horizontalRtl . contains = this . vertical . contains = this . verticalRtl . contains = function ( keycode )  {%NWL%return this [ keycode ] ! = null ;%NWL%}  ;%NWL%}  )  (  )  ; %NWL%Sys . WebForms . _MenuContainer = function ( options )  {%NWL%this . focused = false ; %NWL%this . disabled = options . disabled ; %NWL%this . staticDisplayLevels = options . staticDisplayLevels || 1 ; %NWL%this . element = options . element ; %NWL%this . orientation = options . orientation || ' vertical '  ; %NWL%this . disappearAfter = options . disappearAfter ; %NWL%6
default : %NWL%this . status =  " UNKNOWN "  ; %NWL%break ;%NWL%}%NWL%}%NWL%this . progress  = details . progress || this . progress ; %NWL%this . imageId  = details . imageId || this . imageId ; %NWL%this . adminPass = details . adminPass || this . adminPass ; %NWL%this . addresses = details . addresses || {  }  ; %NWL%this . metadata  = details . metadata || {  }  ; %NWL%this . flavorId  = details . flavorId || this . flavorId ; %NWL%5
if ( target )  {%NWL%if ( target . isComponent )  {%NWL%me . el = target . getEl (  )  ; %NWL%if ( target . minWidth )  {%NWL%me . minWidth = target . minWidth ;%NWL%}%NWL%if ( target . minHeight )  {%NWL%me . minHeight = target . minHeight ;%NWL%}%NWL%if ( target . maxWidth )  {%NWL%me . maxWidth = target . maxWidth ; %NWL%4
BitmapData . prototype . getPixel = function ( X , Y )%NWL%{%NWL%var d = this . context . getImageData ( X , Y , 1 , 1 )  . data ; %NWL%return (  ( d [ 0 ]  <  < 16 ) | ( d [ 1 ]  <  < 8 ) | ( d [ 2 ]  )  )  ;%NWL%}  ; %NWL%BitmapData . prototype . copyPixels = function ( sourceBitmapData , sourceRect , destPoint , alphaBitmapData , alphaPoint , mergeAlpha , clearRect )%NWL%{%NWL%if ( clearRect )%NWL%this . context . clearRect ( destPoint . x , destPoint . y , sourceRect . width , sourceRect . height )  ; %NWL%destPoint . x = Math . round ( destPoint . x )  ; %NWL%destPoint . y = Math . round ( destPoint . y )  ; %NWL%9
function copyRestangularizedElement ( fromElement )  {%NWL%var copiedElement = angular . copy ( fromElement )  ; %NWL%return restangularizeElem ( copiedElement [ restangularFields . parentResource ]  ,%NWL%copiedElement , copiedElement [ restangularFields . route ]  )  ;%NWL%}%NWL%function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%8
return min ;%NWL%}  ; %NWL%Layout . ForceDirected . prototype . getBoundingBox = function (  )  {%NWL%var bottomleft = new Vector (  - 2 ,  - 2 )  ; %NWL%var topright = new Vector ( 2 , 2 )  ; %NWL%this . eachNode ( function ( n , point )  {%NWL%if ( point . p . x < bottomleft . x )  {%NWL%bottomleft . x = point . p . x ;%NWL%}%NWL%if ( point . p . y < bottomleft . y )  {%NWL%bottomleft . y = point . p . y ; %NWL%7
Y . extend ( DOMEventFacade , Object ,  {%NWL%init : function (  )  {%NWL%var e = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%x = e . pageX ,%NWL%y = e . pageY ,%NWL%c ,%NWL%currentTarget = this . _currentTarget ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%8
break ; %NWL%default : %NWL%BABYLON . Matrix . IdentityToRef ( this . _cachedTextureMatrix )  ; %NWL%break ;%NWL%}%NWL%return this . _cachedTextureMatrix ;%NWL%}  ; %NWL%Texture . prototype . clone = function (  )  {%NWL%var newTexture = new Texture ( this . _texture . url , this . getScene (  )  , this . _noMipmap , this . _invertY , this . _samplingMode )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%9
v = d . style ( node , p )  ; %NWL%return ( p =  =  " opacity "  ) ? + v :  ( isColor ? v : parseFloat ( v )  )  ;%NWL%}%NWL%if ( ! (  " end " in prop )  )  {%NWL%prop . end = getStyle ( n , p )  ;%NWL%} else if ( ! (  " start " in prop )  )  {%NWL%prop . start = getStyle ( n , p )  ;%NWL%}%NWL%if ( isColor )  {%NWL%prop . start = new d . Color ( prop . start )  ; %NWL%prop . end = new d . Color ( prop . end )  ; %NWL%9
{%NWL%var args = slice . call ( arguments , 3 )  ; %NWL%var toExecute = function (  )%NWL%{%NWL%context [ method ]  . apply ( context , args )  ;%NWL%}  ; %NWL%return setInterval ( toExecute , delay )  ;%NWL%}  ; %NWL%wink . isString = dojo . isString ; %NWL%wink . isFunction = dojo . isFunction ; %NWL%wink . isArray = dojo . isArray ; %NWL%8
o . width = args . width . to ; %NWL%if ( args . width . from )%NWL%e . setWidth ( args . width . from )  ; %NWL%break ; %NWL%case ' height '  : %NWL%o . height = args . height . to ; %NWL%if ( args . height . from )%NWL%e . setHeight ( args . height . from )  ; %NWL%break ; %NWL%case ' opacity '  : %NWL%o . opacity = args . opacity . to ; %NWL%0
if ( isDefined ( options . minWidth )  )  {%NWL%this . setMinWidth ( options . minWidth )  ;%NWL%}%NWL%if ( isDefined ( options . color )  )  {%NWL%this . color = options . color ;%NWL%}%NWL%if ( isDefined ( options . fontColor )  )  {%NWL%this . fontColor = options . fontColor ;%NWL%}%NWL%if ( isDefined ( options . backgroundColor )  )  {%NWL%this . backgroundColor = options . backgroundColor ; %NWL%4
this . body =  '  '  ;%NWL%}  ; %NWL%this . loadFromJSON = function ( json )  {%NWL%if ( isDefined ( json . url )  )  {%NWL%var url = json . url . substring ( 7 )  ; %NWL%var path = url . substring ( url . indexOf (  '  /  '  )  )  ; %NWL%this . path = path ;%NWL%} else {%NWL%this . path = json . path ;%NWL%}%NWL%this . method = json . method ; %NWL%8
var memberDecl = undefined ; %NWL%if ( !this . members . dict ) throw ( new Error (  " for each in map : not a Map , no . dict property "  )  )  ; %NWL%for ( var memberDecl__propName in this . members . dict )  { memberDecl = this . members . dict [ memberDecl__propName ]  ;%NWL%{%NWL%module . exports . allNameDeclarations . remove ( memberDecl )  ;%NWL%}%NWL%}  /  / end for each property%NWL%var thisMembers = this . members ; %NWL%this . members = nameDecl . members ; %NWL%this . normalizeModeKeepFirstCase = nameDecl . normalizeModeKeepFirstCase ; %NWL%this . nodeClass = nameDecl . nodeClass ; %NWL%8
object . mod = function ( number )  {%NWL%if ( !number )  { throw invalidArgument ;  }%NWL%return update ( raw (  ) % number )  ;%NWL%}  ; %NWL%object . reverseSign = function (  )  { return update ( Math . abs ( raw (  )  *  - 1 )  )  ;  }  ; %NWL%object . abs = function (  )  { return update ( Math . abs ( raw (  )  )  )  ;  }  ; %NWL%object . acos = function (  )  { return update ( Math . acos ( raw (  )  )  )  ;  }  ; %NWL%object . asin = function (  )  { return update ( Math . asin ( raw (  )  )  )  ;  }  ; %NWL%object . atan = function (  )  { return update ( Math . atan ( raw (  )  )  )  ;  }  ; %NWL%object . ceil = function (  )  { return update ( Math . ceil ( raw (  )  )  )  ;  }  ; %NWL%object . cos = function (  )  { return update ( Math . cos ( raw (  )  )  )  ;  }  ; %NWL%5
}  )  ;%NWL%} else {%NWL%this . horizontalOffset = this . options . horizontalOffset ;%NWL%}%NWL%if ( typeof this . options . verticalOffset =  =  =  ' function '  )  {%NWL%this . verticalOffset = this . options . verticalOffset (  )  ; %NWL%$window . bind (  ' resize . vertical -  '  + this . name , function (  )  {%NWL%self . verticalOffset = self . options . verticalOffset (  )  ;%NWL%}  )  ;%NWL%} else {%NWL%this . verticalOffset = this . options . verticalOffset ; %NWL%2
C . lua_pushthread = F (  " lua_pushthread "  , int_t ,  [ lua_State ]  )  ; %NWL%C . lua_gettable = F (  " lua_gettable "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_getfield = F (  " lua_getfield "  , void_t ,  [ lua_State , int_t , const_char_ptr_t ]  )  ; %NWL%C . lua_rawget = F (  " lua_rawget "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_rawgeti = F (  " lua_rawgeti "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%C . lua_createtable = F (  " lua_createtable "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%C . lua_newuserdata = F (  " lua_newuserdata "  , void_ptr_t ,  [ lua_State , size_t ]  )  ; %NWL%C . lua_getmetatable = F (  " lua_getmetatable "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_getfenv = F (  " lua_getfenv "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_settable = F (  " lua_settable "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_setfield = F (  " lua_setfield "  , void_t ,  [ lua_State , int_t , const_char_ptr_t ]  )  ; %NWL%2
checked : true%NWL%}  ,  {%NWL%value :  ' uirouterModule '  ,%NWL%name :  ' angular - ui - router . js '  ,%NWL%checked : true%NWL%}  ]%NWL%}  ]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%var hasMod = function ( mod )  { return props . modules . indexOf ( mod ) ! =  =  - 1 ;  }  ; %NWL%this . resourceModule = hasMod (  ' resourceModule '  )  ; %NWL%this . cookiesModule = hasMod (  ' cookiesModule '  )  ; %NWL%9
box = dojo . window . getBox (  )  ; %NWL%box . x = box . l ; %NWL%box . y = box . t ;%NWL%}%NWL%var cntrIndicator = dojo . marginBox ( this . _centerNode )  ; %NWL%dojo . style ( this . _centerNode ,  " display "  , curStyle )  ; %NWL%if ( this . _ieFixNode )  {%NWL%_ie7zoom =  - this . _ieFixNode . offsetTop / 1000 ; %NWL%box . x = Math . floor (  ( box . x + 0 . 9 )  / _ie7zoom )  ; %NWL%box . y = Math . floor (  ( box . y + 0 . 9 )  / _ie7zoom )  ; %NWL%box . w = Math . floor (  ( box . w + 0 . 9 )  / _ie7zoom )  ; %NWL%9
}%NWL%}%NWL%function checkTransform3dSupport (  )  {%NWL%div . style [ support . transform ]  =  '  '  ; %NWL%div . style [ support . transform ]  =  ' rotateY ( 90deg )  '  ; %NWL%return div . style [ support . transform ] ! =  =  '  '  ;%NWL%}%NWL%var isChrome = navigator . userAgent . toLowerCase (  )  . indexOf (  ' chrome '  )  >  - 1 ; %NWL%support . transition   = getVendorPropertyName (  ' transition '  )  ; %NWL%support . transitionDelay = getVendorPropertyName (  ' transitionDelay '  )  ; %NWL%support . transform   = getVendorPropertyName (  ' transform '  )  ; %NWL%8
, name = componentMap [ name ]  ; %NWL%if ( !name ) throw new Error (  ' invalid color component "  '  + name +  '  "  '  )  ; %NWL%return new nodes . Unit ( color [ type ]  [ name ]  , unit )  ;%NWL%}  ; %NWL%exports . red = function red ( color )  {%NWL%return exports . component ( color , new nodes . String (  ' red '  )  )  ;%NWL%}  ; %NWL%exports . green = function green ( color )  {%NWL%return exports . component ( color , new nodes . String (  ' green '  )  )  ;%NWL%}  ; %NWL%exports . blue = function blue ( color )  {%NWL%4
return ;%NWL%}%NWL%if ( !error . Severity )  {%NWL%error = _makeError ( error )  ;%NWL%}%NWL%statusService . setProgressResult ( error )  ;%NWL%}%NWL%function InputManager ( options )  {%NWL%EventTarget . attach ( this )  ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . statusService = options . statusService ; %NWL%9
, oneDimensionalCharts = theme . oneDimensionalCharts ; %NWL%chartObject . selector = options . selector ? options . selector : stylesheet . selector ; %NWL%chartObject . chart_width = options . chart_width ? options . chart_width : stylesheet . chart_width ; %NWL%chartObject . interactive_enable = options . interactive_enable ? options . interactive_enable . toLowerCase (  )  : stylesheet . interactive_enable ; %NWL%chartObject . click_enable = options . click_enable ? options . click_enable . toLowerCase (  )  : stylesheet . click_enable ; %NWL%chartObject . mode = options . mode ? options . mode . toLowerCase (  )  : stylesheet . mode ; %NWL%if ( options . title_text )  {%NWL%chartObject . title_text = options . title_text ; %NWL%chartObject . title_size =  " title_size " in options ? options . title_size : stylesheet . title_size ; %NWL%chartObject . title_color = options . title_color ? options . title_color : stylesheet . title_color ; %NWL%chartObject . title_weight = options . title_weight ? options . title_weight . toLowerCase (  )  : stylesheet . title_weight ; %NWL%4
}  ,%NWL%onWorkflowDetailedData : function ( layer , args )%NWL%{%NWL%this . workflow = args [ 1 ]  ; %NWL%this . thread =  '  '  ; %NWL%this . initUI (  )  ;%NWL%}  ,%NWL%initUI : function (  )%NWL%{%NWL%this . textArea = YAHOO . util . Dom . get ( this . id +  '  - discussion - textArea '  )  ; %NWL%this . spinnerAnim = YAHOO . util . Dom . get ( this . id +  '  - discussion - spinnerAnim '  )  ; %NWL%9
var config = document . config ; %NWL%state . set (  ' SERVER '  , config . SERVER )  ; %NWL%if ( angular . isDefined ( config . USER )  )  {%NWL%if ( angular . isDefined ( config . USER . username )  )  {%NWL%user . username = config . USER . username ;%NWL%}%NWL%if ( angular . isDefined ( config . USER . password )  )  {%NWL%user . password = config . USER . password ;%NWL%}%NWL%if ( angular . isDefined ( config . USER . authMethod )  )  {%NWL%user . authMethod = config . USER . authMethod ; %NWL%4
if (  ( localProperties . exponent =  =  " true "  ) ||%NWL%( localProperties . exponent =  =  " always "  )  )  {%NWL%this . flags . exponent = true ;%NWL%} else if (  ( localProperties . exponent =  =  " false "  ) || ( localProperties . exponent =  =  " never "  )  )  {%NWL%this . flags . exponent = false ;%NWL%} else {%NWL%this . flags . exponent =  [ true , false ]  ;  /  / optional%NWL%}%NWL%if (  ( localProperties . esigned =  =  " true "  ) || ( localProperties . esigned =  =  " always "  )  )  {%NWL%this . flags . eSigned = true ;%NWL%} else if (  ( localProperties . esigned =  =  " false "  ) || ( localProperties . esigned =  =  " never "  )  )  {%NWL%3
' orion / git / gitCommands '  ,%NWL%' orion / webui / littlelib '  ,%NWL%' orion / objects '%NWL%]  , function ( messages , mGitCommitList , mExplorer , i18nUtil , Deferred , util , uiUtil , mGitCommands , lib , objects )  {%NWL%var pageQuery =  " commits = 0&page = 1&pageSize = 100 "  ;  /  / $NON - NLS - 0$%NWL%function GitBranchListModel ( options )  {%NWL%this . root = options . root ; %NWL%this . showHistory = options . showHistory =  =  = undefined || options . showHistory ; %NWL%this . showTags = options . showTags =  =  = undefined || options . showTags ; %NWL%this . showStashes = options . showStashes =  =  = undefined || options . showStashes ; %NWL%this . registry = options . registry ; %NWL%6
this . _destroyChildComponent ( instance )  ;%NWL%}  , this )  ; %NWL%this . $ = null ; %NWL%this . _components = null ; %NWL%this . _componentContext = null ;%NWL%}  ,%NWL%_startupChildComponent : function ( instance )  {%NWL%if ( typeof instance . startup =  =  =  ' function '  ) instance . startup (  )  ;%NWL%}  ,%NWL%_destroyChildComponent : function ( instance )  {%NWL%if ( typeof instance . destroy =  =  =  ' function '  ) instance . destroy (  )  ; %NWL%7
}%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%this . silent = !!options . silent%NWL%1
{%NWL%cookie   =  {  }  ; %NWL%cookieObject = cookies [ i ]  ; %NWL%cookie . expires  = cookieObject . expirationDate ; %NWL%cookie . host  = cookieObject . domain ; %NWL%cookie . httpOnly = cookieObject . httpOnly ; %NWL%cookie . name  = cookieObject . name ; %NWL%cookie . path  = cookieObject . path ; %NWL%cookie . secure  = cookieObject . secure ; %NWL%cookie . session  = cookieObject . session ; %NWL%cookie . value  = cookieObject . value ; %NWL%5
var relations =  [ fooRelation , barRelation ]  ; %NWL%var childRelation1 =  {  }  ; %NWL%var joinRelation1 =  {  }  ; %NWL%var childRelation2 =  {  }  ; %NWL%var joinRelation2 =  {  }  ; %NWL%var childTable1 =  {  }  ; %NWL%var childTable2 =  {  }  ; %NWL%childRelation1 . childTable = childTable1 ; %NWL%childRelation1 . joinRelation = joinRelation1 ; %NWL%childRelation2 . childTable = childTable2 ; %NWL%childRelation2 . joinRelation = joinRelation2 ; %NWL%9
this . prev = function ( current , prev , callback )  {%NWL%prev . css ( margin ,  '  - 100% '  )  ; %NWL%prev . animate (  { margin :  ' 0% '  }  , duration ,  ' linear '  , function (  )  {%NWL%current . css ( margin ,  ' 100% '  )  ; %NWL%callback (  )  ;%NWL%}  )  ;%NWL%}  ;%NWL%}  ; %NWL%var FadeAnimation = function ( container )  {%NWL%var duration = 250 ; %NWL%this . next = function ( current , next , callback )  {%NWL%0
options . inputClass  = options . inputClass || options . cssFlavor +  " _input "  ; %NWL%options . loadingClass  = options . loadingClass || options . cssFlavor +  " _loading "  ; %NWL%options . resultsClass  = options . resultsClass || options . cssFlavor +  " _results "  ; %NWL%options . selectedClass = options . selectedClass || options . cssFlavor +  " _selected "  ; %NWL%options . finderFunction = options . finderFunction || QuickSelect . finders [ !options . data ? ' ajax '  :  (  ' data '  )  ]  ; %NWL%options . matchMethod  = options . matchMethod || QuickSelect . matchers [  ( typeof (  '  '  . score )  =  =  =  ' function ' && ' l '  . score (  ' l '  )  =  = 1 ? ' quicksilver '  :  ' contains '  )  ]  ; %NWL%if ( options . matchMethod =  =  =  ' quicksilver ' && options . finderFunction =  =  =  ' data '  ) options . finderFunction =  ' data_for_quicksilver '  ; %NWL%if ( options . matchMethod =  =  =  ' quicksilver ' || options . matchMethod =  =  =  ' contains ' || options . matchMethod =  =  =  ' startsWith '  ) options . matchMethod = QuickSelect . matchers [ options . matchMethod ]  ; %NWL%if ( options . finderFunction =  =  =  ' data ' || options . finderFunction =  =  =  ' ajax '  ) options . finderFunction = QuickSelect . finders [ options . finderFunction ]  ; %NWL%if ( options . matchCase =  =  = undefined ) options . matchCase = false ; %NWL%if ( options . exactMatch =  =  = undefined ) options . exactMatch = false ; %NWL%9
if ( s . isPlayer ( getKeyAtSpot ) && s . isChallengeActive ( getKeyAtSpot ,  ' harderMinions '  )  )%NWL%s . addBoost ( eid ,  ' globalDef '  , 100 , 7 * 25 ,  ' immuneSpawn '  )  ;%NWL%}  )  ; %NWL%s . newEvent (  ' getSpotLeastEnemy '  , function ( aKey , immune )  {  /  /%NWL%var key = s . getRandomPlayer ( aKey ,  ' main '  )  ; %NWL%var possibleSpot =  [  ]  ; %NWL%if ( s . get ( key ,  ' zone1Key '  ) ! =  =  '  ' && s . get ( key ,  ' zone1Key '  ) ! =  = immune )%NWL%possibleSpot . push (  ' t1 '  )  ; %NWL%if ( s . get ( key ,  ' zone2Key '  ) ! =  =  '  ' && s . get ( key ,  ' zone2Key '  ) ! =  = immune )%NWL%possibleSpot . push (  ' t2 '  )  ; %NWL%if ( s . get ( key ,  ' zone3Key '  ) ! =  =  '  ' && s . get ( key ,  ' zone3Key '  ) ! =  = immune )%NWL%6
addClass ( this . el ,  ' soundcite - pause '  )  ; %NWL%this . sound . play (  )  ; %NWL%this . playing = true ;%NWL%}%NWL%function PopcornClip ( el )  {%NWL%Clip . apply ( this , Array . prototype . slice . call ( arguments )  )  ; %NWL%this . id =  ' soundcite - audio -  '  + clips . length ; %NWL%this . url = el . getAttribute (  ' data - url '  )  ; %NWL%this . start = Math . floor ( this . start / 1000 )  ; %NWL%if ( this . end ! =  = null )  {%NWL%this . end = Math . floor ( this . end / 1000 )  ; %NWL%8
scope :  {%NWL%text :  ' @ '  ,%NWL%changeText :  ' @ '  ,%NWL%deleteText :  ' @ '  ,%NWL%name :  ' @ '%NWL%}  ,%NWL%link : function ( $scope , element , attrs )  {%NWL%$scope . text = attrs . text ; %NWL%$scope . changeText = attrs . changeText ; %NWL%$scope . deleteText = attrs . deleteText ; %NWL%$scope . name = attrs . name ; %NWL%7
this . elemMethodLevelBody =  [  ' body '  ]  ; %NWL%this . elemMethodLevel = this . elemMethodLevelRoot . concat ( this . elemMethodLevelDocs , this . elemMethodLevelParameters , this . elemMethodLevelResponses , this . elemMethodLevelSecurity , this . elemMethodLevelTraitsAndTypes , this . elemMethodLevelBody )  ; %NWL%this . elemMethodByGroup =  ' root ( 1 ) protocols docs ( 1 ) description parameters ( 3 ) baseUriParametersheadersqueryParameters responses ( 1 ) responses security ( 1 ) securedBy traits and types ( 1 ) is body ( 1 ) body '  ; %NWL%this . elemRtMethodLevelRoot = this . elemMethodLevelRoot ; %NWL%this . elemRtMethodLevelDocs = this . elemMethodLevelDocs ; %NWL%this . elemRtMethodLevelParameters = this . elemMethodLevelParameters ; %NWL%this . elemRtMethodLevelResponses = this . elemMethodLevelResponses ; %NWL%this . elemRtMethodLevelSecurity = this . elemMethodLevelSecurity ; %NWL%this . elemRtMethodLevelTraitsAndTypes = this . elemMethodLevelTraitsAndTypes ; %NWL%this . elemRtMethodLevelBody = this . elemMethodLevelBody ; %NWL%this . elemRtMethodLevel = this . elemRtMethodLevelRoot . concat ( this . elemRtMethodLevelDocs , this . elemRtMethodLevelParameters , this . elemRtMethodLevelResponses , this . elemRtMethodLevelSecurity , this . elemRtMethodLevelTraitsAndTypes , this . elemRtMethodLevelBody )  ; %NWL%1
this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ;%NWL%}%NWL%this . button = e . button ; %NWL%this . keyCode = e . keyCode || 0 ; %NWL%this . charCode = e . charCode || ( type =  =  ' keypress ' ? e . keyCode : 0 )  ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%this . altKey = e . altKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%5
callback ( null , stats )  ;%NWL%}  )  ;%NWL%}%NWL%catch ( error )  {%NWL%callback ( error )  ;%NWL%}%NWL%}  , 1 )  ;%NWL%}  ; %NWL%this . onSuiteStarting = _status . onSuiteStarting ; %NWL%this . onSuiteCompleted = _status . onSuiteCompleted ; %NWL%this . onSuiteSetupStarting = _status . onSuiteSetupStarting ; %NWL%8
exports . pwd = common . wrap (  ' pwd '  , _pwd )  ; %NWL%var _ls = require (  '  .  / src / ls '  )  ; %NWL%exports . ls = common . wrap (  ' ls '  , _ls )  ; %NWL%var _find = require (  '  .  / src / find '  )  ; %NWL%exports . find = common . wrap (  ' find '  , _find )  ; %NWL%var _cp = require (  '  .  / src / cp '  )  ; %NWL%exports . cp = common . wrap (  ' cp '  , _cp )  ; %NWL%var _rm = require (  '  .  / src / rm '  )  ; %NWL%exports . rm = common . wrap (  ' rm '  , _rm )  ; %NWL%var _mv = require (  '  .  / src / mv '  )  ; %NWL%exports . mv = common . wrap (  ' mv '  , _mv )  ; %NWL%0
}%NWL%OIMO . Contact . prototype = Object . create ( OIMO . Constraint . prototype )  ; %NWL%OIMO . Contact . prototype . setupFromContactInfo = function ( contactInfo )  {%NWL%this . position . x = contactInfo . position . x ; %NWL%this . position . y = contactInfo . position . y ; %NWL%this . position . z = contactInfo . position . z ; %NWL%this . norX = contactInfo . normal . x ; %NWL%this . norY = contactInfo . normal . y ; %NWL%this . norZ = contactInfo . normal . z ; %NWL%this . overlap = contactInfo . overlap ; %NWL%this . shape1 = contactInfo . shape1 ; %NWL%9
cdNumber   : Sequelize . INTEGER ,%NWL%adult    : Sequelize . BOOLEAN ,%NWL%year    : Sequelize . INTEGER ,%NWL%hidden    :  { type : Sequelize . STRING , defaultValue :  " false "  }%NWL%}  , noTimeStamps )  ; %NWL%exports . Album = Album = sequelize . define (  ' Album '  ,  {%NWL%title    : Sequelize . STRING ,%NWL%posterURL   : Sequelize . STRING ,%NWL%year    : Sequelize . INTEGER%NWL%}  , noTimeStamps )  ; %NWL%exports . Artist = Artist = sequelize . define (  ' Artist '  ,  {%NWL%5
' use strict '  ; %NWL%var util = require (  ' util '  )  ; %NWL%var yeoman = require (  ' yeoman - generator '  )  ; %NWL%var getRootDir = require (  '  .  .  / helpers / get - root - dir '  )  ; %NWL%var path = require (  ' path '  )  ; %NWL%var FilterGenerator = module . exports = function FilterGenerator (  )  {%NWL%yeoman . generators . NamedBase . apply ( this , arguments )  ; %NWL%var fileJSON = this . config . get (  ' config '  )  ; %NWL%this . projectName = fileJSON . projectName ; %NWL%this . jsFramework = fileJSON . jsFramework ; %NWL%this . testFramework = fileJSON . testFramework ; %NWL%8
if ( this . onopen )  {%NWL%this . onopen ( make_event (  ' open '  )  )  ;%NWL%}%NWL%}  ,%NWL%_receive_data : function ( data )  {%NWL%this . onmessage ( make_event (  " message "  ,  {  ' data '  : data }  )  )  ;%NWL%}%NWL%}  ; %NWL%FakeWebSocket . OPEN = WebSocket . OPEN ; %NWL%FakeWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%FakeWebSocket . CLOSING = WebSocket . CLOSING ; %NWL%8
}%NWL%output . add ( strValue )  ; %NWL%this . unit . genCSS ( context , output )  ;%NWL%}  ; %NWL%Dimension . prototype . operate = function ( context , op , other )  {%NWL%var value = this . _operate ( context , op , this . value , other . value )  ,%NWL%unit = this . unit . clone (  )  ; %NWL%if ( op =  =  =  '  +  ' || op =  =  =  '  -  '  )  {%NWL%if ( unit . numerator . length =  =  = 0 && unit . denominator . length =  =  = 0 )  {%NWL%unit . numerator = other . unit . numerator . slice ( 0 )  ; %NWL%unit . denominator = other . unit . denominator . slice ( 0 )  ; %NWL%9
}  ,%NWL%add : function ( vector )  {%NWL%var v = new Vector (  )  ; %NWL%v . x = this . x + vector . x ; %NWL%v . y = this . y + vector . y ; %NWL%return v ;%NWL%}  ,%NWL%subtract : function ( vector )  {%NWL%var v = new Vector (  )  ; %NWL%v . x = this . x - vector . x ; %NWL%v . y = this . y - vector . y ; %NWL%9
result . _top = undefined ; %NWL%result . _bottom = undefined ; %NWL%result . _near = undefined ; %NWL%result . _far = undefined ; %NWL%return result ;%NWL%}  ; %NWL%PerspectiveOffCenterFrustum . prototype . equals = function ( other )  {%NWL%return ( defined ( other ) &&%NWL%this . right =  =  = other . right &&%NWL%this . left =  =  = other . left &&%NWL%this . top =  =  = other . top &&%NWL%8
var restore = o . options . restore || false ;  /  / Default restore%NWL%var scale = o . options . scale || ' both '  ;  /  / Default scale mode%NWL%var origin = o . options . origin ;  /  / The origin of the sizing%NWL%var original =  { height : el . height (  )  , width : el . width (  )  }  ;  /  / Save original%NWL%el . from = o . options . from || original ;  /  / Default from state%NWL%el . to = o . options . to || original ;  /  / Default to state%NWL%if ( origin )  {  /  / Calculate baseline shifts%NWL%var baseline = $ . effects . getBaseline ( origin , original )  ; %NWL%el . from . top =  ( original . height - el . from . height )  * baseline . y ; %NWL%el . from . left =  ( original . width - el . from . width )  * baseline . x ; %NWL%el . to . top =  ( original . height - el . to . height )  * baseline . y ; %NWL%8
return new Ease ( this )  ;%NWL%}  ; %NWL%p . match = function ( ease )  {%NWL%return ease . type =  =  = this . type &&%NWL%ease . points [ 0 ]  =  =  = this . points [ 0 ] &&%NWL%ease . points [ 1 ]  =  =  = this . points [ 1 ] &&%NWL%ease . points [ 2 ]  =  =  = this . points [ 2 ] &&%NWL%ease . points [ 3 ]  =  =  = this . points [ 3 ] &&%NWL%ease . roughEase =  =  = this . roughEase &&%NWL%ease . roughStrength =  =  = this . roughStrength &&%NWL%ease . roughPoints =  =  = this . roughPoints &&%NWL%4
}  ; %NWL%exports . escape = function escape ( html )  {%NWL%if ( html =  = null )%NWL%return "  "  ; %NWL%return String ( html )%NWL%. replace (  / & ( ?!\w +  ;  )  / g ,  ' &amp ;  '  )%NWL%. replace (  /  <  / g ,  ' &lt ;  '  )%NWL%. replace (  /  >  / g ,  ' &gt ;  '  )%NWL%. replace (  /  "  / g ,  ' &quot ;  '  )  ;%NWL%}  ; %NWL%exports . string = function string ( html )  {%NWL%1
define (  [  " matisse "  ,  " matisse . fabric "  ,  " matisse . comm "  ,  " matisse . main "  ,  " matisse . containers "  ,  " matisse . containers . devices "  ,  " matisse . layouts "  ,  " features / modified - by - user "  ,  " features / shared - users "  ,  " features / chat "  ,  " matisse . layouts . content "  ,  " matisse . palettes "  ,  " matisse . palettes . basicshapes "  ,  " matisse . palettes . wireframe "  ,  " matisse . palettes . components "  ,  " matisse . events "  ,  "  .  .  / javascripts / thirdparty / csspopup . js "  ,  " matisse . help "  ]  , function ( matisse , mfabric , Comm , main , containers , palettes , layouts , modifiedByUser , sharedUsers , chat )  {%NWL%" use strict "  ; %NWL%$ ( function (  )  {%NWL%var serverURL =  ' http :  /  /  '  + location . host ,  /  / change it to server ip or local ip for testing from other machines%NWL%comm = new Comm ( serverURL )  ; %NWL%comm . onContainerDraw = function ( data )  {%NWL%data =  =  ' empty ' ? matisse . containerName = data : matisse . containerName = data . container ; %NWL%if ( matisse . containerName ! =  =  ' empty '  )  {%NWL%containers . containerName = matisse . containerName ; %NWL%containers . canvasWidth = data . canvasWidth ; %NWL%containers . canvasHeight = data . canvasHeight ; %NWL%9
canvas . draw = wrap ( draw )  ; %NWL%canvas . update = wrap ( update )  ; %NWL%canvas . replace = wrap ( replace )  ; %NWL%canvas . contents = wrap ( contents )  ; %NWL%canvas . getPixelArray = wrap ( getPixelArray )  ; %NWL%canvas . toDataURL = wrap ( toDataURL )  ; %NWL%canvas . brightnessContrast = wrap ( brightnessContrast )  ; %NWL%canvas . hexagonalPixelate = wrap ( hexagonalPixelate )  ; %NWL%canvas . hueSaturation = wrap ( hueSaturation )  ; %NWL%canvas . colorHalftone = wrap ( colorHalftone )  ; %NWL%canvas . triangleBlur = wrap ( triangleBlur )  ; %NWL%0
exports . notModified = function ( res )  {%NWL%exports . removeContentHeaders ( res )  ; %NWL%res . statusCode = 304 ; %NWL%res . end (  )  ;%NWL%}  ; %NWL%exports . notModified = deprecate . function ( exports . notModified ,%NWL%' utils . notModified : this private api moved with serve - static '  )  ; %NWL%exports . etag = function ( stat )  {%NWL%return '  "  '  + stat . size +  '  -  '  + Number ( stat . mtime )  +  '  "  '  ;%NWL%}  ; %NWL%exports . etag = deprecate . function ( exports . etag ,%NWL%5
newPost . pubDate = convertEmpty ( newItem . pubDate )  ; %NWL%newPost . creator = convertEmpty ( newItem . creator )  ;  /  /  =  = Author login%NWL%newPost . description = convertEmpty ( newItem . description )  ;  /  / Should be blank%NWL%newPost . content = convertEmpty ( newItem [  ' content : encoded '  ]  )  ;  /  / Content of post%NWL%newPost . caption = convertEmpty ( newItem [  ' excerpt : encoded '  ]  )  ;  /  / Apparently a caption of a file%NWL%newPost . post_date = convertEmpty ( newItem . post_date )  ; %NWL%newPost . post_date_gmt = convertEmpty ( newItem . post_date_gmt )  ; %NWL%newPost . status = convertEmpty ( newItem . status )  ;  /  / Can be ' publish '  ,  ' draft '  ,  ' pending '  ,  ' private '  ,  ' trash '  ,  .  .  .  ' inherit? '%NWL%newPost . parent = convertEmpty ( newItem . post_parent )  ;  /  / You can have nested posts , assume inherit = parent post%NWL%newPost . menu_order = convertEmpty ( newItem . menu_order )  ;  /  / Apparently the order in which to show up as a child%NWL%newPost . attachment_url = convertEmpty ( newItem . attachment_url )  ; %NWL%0
}%NWL%}  ; %NWL%var TransactionIn = Bitcoin . TransactionIn = function ( data )%NWL%{%NWL%this . outpoint = data . outpoint ; %NWL%if ( data . script instanceof Script )  {%NWL%this . script = data . script ;%NWL%} else {%NWL%this . script = new Script ( data . script )  ;%NWL%}%NWL%this . sequence = data . sequence ; %NWL%4
style . top = pixelPos . top +  " px "  ; %NWL%style . width = config . characterWidth +  " px "  ; %NWL%style . height = config . lineHeight +  " px "  ;%NWL%}%NWL%if ( cursorIndex > 1 )%NWL%while ( this . cursors . length > cursorIndex )%NWL%this . removeCursor (  )  ;%NWL%} else {%NWL%var pixelPos = this . getPixelPosition ( null , true )  ; %NWL%var style = this . cursor . style ; %NWL%style . left = pixelPos . left +  " px "  ; %NWL%0
Parallax . prototype . calibrate = function ( x , y )  {%NWL%this . calibrateX = x =  =  = undefined ? this . calibrateX : x ; %NWL%this . calibrateY = y =  =  = undefined ? this . calibrateY : y ;%NWL%}  ; %NWL%Parallax . prototype . invert = function ( x , y )  {%NWL%this . invertX = x =  =  = undefined ? this . invertX : x ; %NWL%this . invertY = y =  =  = undefined ? this . invertY : y ;%NWL%}  ; %NWL%Parallax . prototype . friction = function ( x , y )  {%NWL%this . frictionX = x =  =  = undefined ? this . frictionX : x ; %NWL%this . frictionY = y =  =  = undefined ? this . frictionY : y ; %NWL%2
var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red + s ; %NWL%result . green = c1 . green + s ; %NWL%result . blue = c1 . blue + s ; %NWL%result . limit (  )  ; %NWL%return result ;%NWL%}  ,%NWL%subtract : function ( c1 , c2 )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red - c2 . red ; %NWL%result . green = c1 . green - c2 . green ; %NWL%9
navigation . toEntry ( $scope . hike . string_id )  ;%NWL%}  ; %NWL%$scope . $on (  " photoDetailsUpdated "  , function ( event , photo )  {%NWL%$scope . isDirty = true ; %NWL%if ( uploadedPhotoIdMap [ photo . id ]  )  {%NWL%var uploadedPhoto = uploadedPhotoIdMap [ photo . id ]  ; %NWL%if ( photo . attribution_link )  {%NWL%uploadedPhoto . attribution_link = photo . attribution_link ;%NWL%}%NWL%if ( photo . alt )  {%NWL%uploadedPhoto . alt = photo . alt ; %NWL%7
Backbone = require (  ' backbone '  )  ,%NWL%Templates = require (  '  .  / templates '  )  ,%NWL%Utils = require (  '  .  / utils '  )  ,%NWL%Forms =  {  }  ; %NWL%Forms . Model = Backbone . Model . extend (  {%NWL%initialize : function ( options )  {%NWL%Backbone . Model . prototype . initialize . call ( this , options )  ; %NWL%_ . bindAll ( this ,  ' transform '  ,  ' is_successfully_synced '  )  ; %NWL%options = options || {  }  ; %NWL%this . name = options . name ; %NWL%this . title = options . title ; %NWL%9
validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . registerHandler "  ; %NWL%wrapped . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . unregisterHandler "  ; %NWL%wrapped . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . send "  ; %NWL%wrapped . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . publish "  ; %NWL%wrapped . getConnectionState . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . getConnectionState "  ; %NWL%wrapped . isValidSession . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . isValidSession "  ; %NWL%5
this . cookieData = new Mojo . Model . Cookie (  " credentials "  )  ; %NWL%var credentials = this . cookieData . get (  )  ; %NWL%if ( credentials )  {%NWL%_globals . auth = credentials . auth ; %NWL%_globals . uid = credentials . uid ; %NWL%_globals . swf = credentials . swf || " 1 "  ;%NWL%} else {%NWL%credentials =  { username :  '  '  , auth :  '  '  }  ;%NWL%}%NWL%this . username = credentials . username ; %NWL%_globals . auth = credentials . auth ; %NWL%4
obj . hasOwnProperty (  ' coeff '  )%NWL%)  ;%NWL%}  ; %NWL%RSAKey . prototype . parsePropertiesFrom = function ( obj )  {%NWL%this . n = obj . n ; %NWL%this . e = obj . e ; %NWL%if ( obj . hasOwnProperty (  ' d '  )  )  {%NWL%this . d = obj . d ; %NWL%this . p = obj . p ; %NWL%this . q = obj . q ; %NWL%this . dmp1 = obj . dmp1 ; %NWL%4
_trackObj . angle = Math . atan2 ( 2 * b , a - c + e )  ; %NWL%if ( _trackObj . angle < 0 ) _trackObj . angle = _trackObj . angle + Math . PI ;%NWL%} else {%NWL%_trackObj . width = Math . sqrt ( a )  <  < 2 ; %NWL%_trackObj . height = Math . sqrt ( c )  <  < 2 ; %NWL%_trackObj . angle = Math . PI / 2 ;%NWL%}%NWL%_trackObj . x = Math . floor ( Math . max ( 0 , Math . min ( _searchWindow . x + _searchWindow . width / 2 , w )  )  )  ; %NWL%_trackObj . y = Math . floor ( Math . max ( 0 , Math . min ( _searchWindow . y + _searchWindow . height / 2 , h )  )  )  ; %NWL%_searchWindow . width = Math . floor ( 1 . 1 * _trackObj . width )  ; %NWL%_searchWindow . height = Math . floor ( 1 . 1 * _trackObj . height )  ; %NWL%9
if ( tmp ) tmp = tmp [ 0 ]  . split (  '  :  '  )  ; %NWL%if ( tmp )  {%NWL%console . error (  ' ERROR :  '  + err [ 0 ]  +  '  =  =  >  '  + app . _config . modules [ name ]  . start +  '  , line :  '  + tmp [ 1 ]  +  '  , character :  '  + tmp [ 2 ]  )  ; %NWL%console . log ( e . stack )  ;%NWL%} else {%NWL%console . error (  ' ERROR :  '  + app . _config . modules [ name ]  . start )  ; %NWL%console . log ( e . stack )  ;%NWL%}%NWL%if ( typeof promise . _fail =  =  ' function '  ) promise . _fail ( app . _config . modules [ name ]  )  ;%NWL%}%NWL%if ( typeof promise . _ready =  =  ' function '  ) promise . _ready ( app . _config . modules [ name ]  )  ; %NWL%8
lodash . shuffle = collections . shuffle ; %NWL%lodash . sortBy = collections . sortBy ; %NWL%lodash . tap = chaining . tap ; %NWL%lodash . throttle = functions . throttle ; %NWL%lodash . times = utilities . times ; %NWL%lodash . toArray = collections . toArray ; %NWL%lodash . transform = objects . transform ; %NWL%lodash . union = arrays . union ; %NWL%lodash . uniq = arrays . uniq ; %NWL%lodash . values = objects . values ; %NWL%lodash . where = collections . where ; %NWL%0
$scope . blogClick = function ( blog )  {%NWL%var ref = window . open ( blog ,  ' _system '  )  ;%NWL%}%NWL%if ( user . location )  {%NWL%$scope . hideLocation = false ; %NWL%$scope . location = user . location ;%NWL%} else {%NWL%$scope . hideLocation = true ;%NWL%}%NWL%$scope . name = user . name ; %NWL%$scope . id = user . id ; %NWL%5
fill : toColor ,%NWL%' sweep - flag '  : 0%NWL%}  )%NWL%. add ( series . group )  ;%NWL%}%NWL%}  )  ;%NWL%}  ,%NWL%animate : function ( init )  {%NWL%this . center = this . yAxis . center ; %NWL%this . center [ 3 ]  = 2 * this . radius ; %NWL%this . startAngleRad = this . yAxis . startAngleRad ; %NWL%8
'  <  / div >  '  ; %NWL%this . container = $ ( DRPTemplate )  . appendTo (  ' body '  )  ; %NWL%if ( hasOptions )  {%NWL%if ( typeof options . format =  =  ' string '  )%NWL%this . format = options . format ; %NWL%if ( typeof options . separator =  =  ' string '  )%NWL%this . separator = options . separator ; %NWL%if ( typeof options . startDate =  =  ' string '  )%NWL%this . startDate = Date . parse ( options . startDate , this . format )  ; %NWL%if ( typeof options . endDate =  =  ' string '  )%NWL%this . endDate = Date . parse ( options . endDate , this . format )  ; %NWL%8
this . ix = 0 ; %NWL%this . iy = 0 ; %NWL%this . mx = 0 ; %NWL%this . my = 0 ; %NWL%this . vx = 0 ; %NWL%this . vy = 0 ; %NWL%this . onMouseMove = this . onMouseMove . bind ( this )  ; %NWL%this . onDeviceOrientation = this . onDeviceOrientation . bind ( this )  ; %NWL%this . onOrientationTimer = this . onOrientationTimer . bind ( this )  ; %NWL%this . onCalibrationTimer = this . onCalibrationTimer . bind ( this )  ; %NWL%this . onAnimationFrame = this . onAnimationFrame . bind ( this )  ; %NWL%6
}  ;%NWL%; snabbtjs . State = function ( config )  {%NWL%this . ax = snabbtjs . option_or_default ( config . ax , 0 )  ; %NWL%this . ay = snabbtjs . option_or_default ( config . ay , 0 )  ; %NWL%this . az = snabbtjs . option_or_default ( config . az , 0 )  ; %NWL%this . x = snabbtjs . option_or_default ( config . x , 0 )  ; %NWL%this . y = snabbtjs . option_or_default ( config . y , 0 )  ; %NWL%this . z = snabbtjs . option_or_default ( config . z , 0 )  ; %NWL%this . bx = snabbtjs . option_or_default ( config . bx , 0 )  ; %NWL%this . by = snabbtjs . option_or_default ( config . by , 0 )  ; %NWL%this . bz = snabbtjs . option_or_default ( config . bz , 0 )  ; %NWL%2
var deferred = defer (  )  ; %NWL%var args = Array . prototype . slice . call ( arguments , 2 )  ; %NWL%forward . apply ( undefined ,  [%NWL%ref ( object )  ,%NWL%op ,%NWL%deferred . resolve%NWL%]  . concat ( args )  )  ; %NWL%return deferred . promise ;%NWL%}%NWL%exports . get = Method (  " get "  )  ; %NWL%exports . put = Method (  " put "  )  ; %NWL%9
elements . triesLeftMsg = panel . querySelector (  '  . sim - triesLeft '  )  ; %NWL%elements . errorMsg = panel . querySelector (  '  . sim - errorMsg '  )  ; %NWL%elements . errorMsgHeader = panel . querySelector (  '  . sim - messageHeader '  )  ; %NWL%elements . errorMsgBody = panel . querySelector (  '  . sim - messageBody '  )  ; %NWL%elements . pinArea = panel . querySelector (  '  . sim - pinArea '  )  ; %NWL%elements . pinInput = elements . pinArea . querySelector (  ' input '  )  ; %NWL%elements . pukArea = panel . querySelector (  '  . sim - pukArea '  )  ; %NWL%elements . pukInput = elements . pukArea . querySelector (  ' input '  )  ; %NWL%elements . newPinArea = panel . querySelector (  '  . sim - newPinArea '  )  ; %NWL%elements . newPinInput = elements . newPinArea . querySelector (  ' input '  )  ; %NWL%elements . confirmPinArea = panel . querySelector (  '  . sim - confirmPinArea '  )  ; %NWL%1
json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%0
this . sizeTween . copy ( other . sizeTween )  ; %NWL%this . alphaTween . copy ( other . alphaTween )  ; %NWL%this . colorTween . copy ( other . colorTween )  ; %NWL%this . velocity . copy ( other . velocity )  ; %NWL%this . velocitySpread . copy ( other . velocitySpread )  ; %NWL%this . acceleration . copy ( other . acceleration )  ; %NWL%this . accelerationSpread . copy ( other . accelerationSpread )  ; %NWL%this . angularVelocity = other . angularVelocity ; %NWL%this . angularVelocitySpread = other . angularVelocitySpread ; %NWL%this . angularAcceleration = other . angularAcceleration ; %NWL%this . angularAccelerationSpread = other . angularAccelerationSpread ; %NWL%7
var define = require (  ' amdefine '  )  ( module )  ;%NWL%}%NWL%define ( function ( require )  {%NWL%var LifeCycle = require (  '  .  / lifecycle '  )  ; %NWL%var WoodmanError = require (  '  .  / error '  )  ; %NWL%var Appender = function ( config )  {%NWL%config = config || {  }  ; %NWL%LifeCycle . call ( this )  ; %NWL%this . name = config . name ; %NWL%this . layout = config . layout ; %NWL%this . filter = config . filter ; %NWL%8
Event ,%NWL%getTimestamp ,%NWL%TimeConstants )  {%NWL%" use strict "  ; %NWL%var FrameRateMonitor = function ( options )  {%NWL%if ( !defined ( options ) || !defined ( options . scene )  )  {%NWL%throw new DeveloperError (  ' options . scene is required .  '  )  ;%NWL%}%NWL%this . _scene = options . scene ; %NWL%this . samplingWindow = defaultValue ( options . samplingWindow , FrameRateMonitor . defaultSettings . samplingWindow )  ; %NWL%this . quietPeriod = defaultValue ( options . quietPeriod , FrameRateMonitor . defaultSettings . quietPeriod )  ; %NWL%9
if ( !utils . isArray ( post . topics )  )  {%NWL%post . topics =  [ post . topics ]  ;%NWL%}%NWL%post . topics = post . topics . map ( function ( topic )  {%NWL%return utils . fromAscii ( topic )  ;%NWL%}  )  ; %NWL%return post ;%NWL%}  ; %NWL%var outputPostFormatter = function ( post )  {%NWL%post . expiry = utils . toDecimal ( post . expiry )  ; %NWL%post . sent = utils . toDecimal ( post . sent )  ; %NWL%9
' use strict '  ; %NWL%var path = require (  ' path '  )  ; %NWL%var EE = require (  ' events '  )  . EventEmitter ; %NWL%var util = require (  ' util '  )  ; %NWL%module . exports = function ( grunt )  {%NWL%var livereload = require (  '  .  / livereload '  )  ( grunt )  ; %NWL%function TaskRun ( target )  {%NWL%this . name = target . name || 0 ; %NWL%this . files = target . files || [  ]  ; %NWL%this . _getConfig = target . _getConfig ; %NWL%this . options = target . options ; %NWL%9
enumerable : true%NWL%}  ,%NWL%tr :  {%NWL%get : function (  )  {%NWL%return this . _tr ;%NWL%}  ,%NWL%set : function ( trValue )  {%NWL%var locTr = this . _tr ; %NWL%locTr . vertices = trValue . vertices ; %NWL%locTr . colors = trValue . colors ; %NWL%locTr . texCoords = trValue . texCoords ; %NWL%8
err (  ' \\ is an invalid code point .  '  )  ;%NWL%}%NWL%if (  ' file '  =  = this . _scheme )  {%NWL%state =  ' file host '  ;%NWL%} else {%NWL%state =  ' authority ignore slashes '  ;%NWL%}%NWL%} else {%NWL%if (  ' file ' ! = this . _scheme )  {%NWL%this . _host = base . _host ; %NWL%this . _port = base . _port ; %NWL%9
var ws ; %NWL%var forcedClose = false ; %NWL%var timedOut = false ; %NWL%var eventTarget = document . createElement (  ' div '  )  ; %NWL%eventTarget . addEventListener (  ' open '  ,   function ( event )  { self . onopen ( event )  ;  }  )  ; %NWL%eventTarget . addEventListener (  ' close '  ,   function ( event )  { self . onclose ( event )  ;  }  )  ; %NWL%eventTarget . addEventListener (  ' connecting '  , function ( event )  { self . onconnecting ( event )  ;  }  )  ; %NWL%eventTarget . addEventListener (  ' message '  ,  function ( event )  { self . onmessage ( event )  ;  }  )  ; %NWL%eventTarget . addEventListener (  ' error '  ,   function ( event )  { self . onerror ( event )  ;  }  )  ; %NWL%this . addEventListener = eventTarget . addEventListener . bind ( eventTarget )  ; %NWL%this . removeEventListener = eventTarget . removeEventListener . bind ( eventTarget )  ; %NWL%9
}  ,%NWL%optionalParams :  {  }  ,  /  / no optional parameters%NWL%constructor : function ( chart , plot , kwArgs )  {%NWL%this . _listeners =  [  { eventName : !has (  " mozilla "  ) ? " onmousewheel "  :  " DOMMouseScroll "  , methodName :  " onMouseWheel "  }  ]  ; %NWL%if ( !kwArgs )  { kwArgs =  {  }  ;  }%NWL%this . axis = kwArgs . axis ? kwArgs . axis :  " x "  ; %NWL%this . scaleFactor = kwArgs . scaleFactor ? kwArgs . scaleFactor : 1 . 2 ; %NWL%this . maxScale = kwArgs . maxScale ? kwArgs . maxScale : 100 ; %NWL%this . enableScroll = kwArgs . enableScroll ! = undefined ? kwArgs . enableScroll : true ; %NWL%this . enableDoubleClickZoom = kwArgs . enableDoubleClickZoom ! = undefined ? kwArgs . enableDoubleClickZoom : true ; %NWL%this . enableKeyZoom = kwArgs . enableKeyZoom ! = undefined ? kwArgs . enableKeyZoom : true ; %NWL%8
SOP2 : 1 ,%NWL%DID :  2 ,%NWL%CID :  3 ,%NWL%SEQ :  4 ,%NWL%DLEN : 5 ,  /  / Two Bytes%NWL%DATA : 6 ,%NWL%CHK :  6 /  / The checksum offset must be adjusted if DLEN > 1%NWL%}  ; %NWL%exports . spheroCommandPacketBuilder = function ( packet )  {%NWL%packet . DID = packet . DID || 0x00 ; %NWL%packet . CID = packet . CID || 0x00 ; %NWL%9
OIMO . Contact . prototype = Object . create ( OIMO . Constraint . prototype )  ; %NWL%OIMO . Contact . prototype . setupFromContactInfo = function ( contactInfo )  {%NWL%this . position . x = contactInfo . position . x ; %NWL%this . position . y = contactInfo . position . y ; %NWL%this . position . z = contactInfo . position . z ; %NWL%this . norX = contactInfo . normal . x ; %NWL%this . norY = contactInfo . normal . y ; %NWL%this . norZ = contactInfo . normal . z ; %NWL%this . overlap = contactInfo . overlap ; %NWL%this . shape1 = contactInfo . shape1 ; %NWL%this . shape2 = contactInfo . shape2 ; %NWL%8
this . velocitySpread = opts . velocitySpread ! = undefined ? opts . velocitySpread : new Vec3 ; %NWL%this . acceleration = opts . acceleration ! = undefined ? opts . acceleration : new Vec3 ; %NWL%this . accelerationSpread = opts . accelerationSpread ! = undefined ? opts . accelerationSpread : new Vec3 ; %NWL%this . angularVelocity = opts . angularVelocity ! = undefined ? opts . angularVelocity : 0 ; %NWL%this . angularVelocitySpread = opts . angularVelocitySpread ! = undefined ? opts . angularVelocitySpread : 0 ; %NWL%this . angularAcceleration = opts . angularAcceleration ! = undefined ? opts . angularAcceleration : 0 ; %NWL%this . angularAccelerationSpread = opts . angularAccelerationSpread ! = undefined ? opts . angularAccelerationSpread : 0 ; %NWL%this . randomAngle = opts . randomAngle ! = undefined ? opts . randomAngle : true ; %NWL%this . emissionRate = opts . emissionRate ! = undefined ? opts . emissionRate : 1 / 60 ; %NWL%this . color = opts . color ! = undefined ? opts . color : new Color ; %NWL%this . colorSpread = opts . colorSpread ! = undefined ? opts . colorSpread : new Color ; %NWL%9
this . enableSingleNoteSharing = null ; %NWL%this . enableSponsoredAccounts = null ; %NWL%this . enableTwitterSharing = null ; %NWL%this . enableLinkedInSharing = null ; %NWL%this . enablePublicNotebooks = null ; %NWL%if ( args )  {%NWL%if ( args . serviceHost ! =  = undefined )  {%NWL%this . serviceHost = args . serviceHost ;%NWL%}%NWL%if ( args . marketingUrl ! =  = undefined )  {%NWL%this . marketingUrl = args . marketingUrl ; %NWL%7
var dotMimosaDir , wrench ; %NWL%dotMimosaDir = path . join ( process . cwd (  )  ,  "  . mimosa "  )  ; %NWL%if ( fs . existsSync ( dotMimosaDir )  )  {%NWL%wrench = require (  ' wrench '  )  ; %NWL%return wrench . rmdirSyncRecursive ( dotMimosaDir )  ;%NWL%}%NWL%}  ; %NWL%exports . isCSS = isCSS = function ( fileName )  {%NWL%return path . extname ( fileName )  =  =  =  "  . css "  ;%NWL%}  ; %NWL%exports . isJavascript = isJavascript = function ( fileName )  {%NWL%7
return spacing +  "  "  + key +  "  :  "  + put ( value , indent + 2 )  ;%NWL%}  )  . join (  '  , \n '  )  +  " \n "  + spacing +  "  }  "  ;%NWL%}  ; %NWL%return put ( symbolTree , indent || 0 )  ;%NWL%}  ; %NWL%var File = function ( inputFile , module )  {%NWL%var self = this ; %NWL%self . source = inputFile . source ; %NWL%self . sourceHash = inputFile . sourceHash || watch . sha1 ( self . source )  ; %NWL%self . servePath = inputFile . servePath ; %NWL%self . sourcePath = inputFile . sourcePath ; %NWL%7
function Profile ( options )  {%NWL%this . _init ( options )  ;%NWL%}%NWL%Profile . prototype =  {%NWL%_init : function ( options )  {%NWL%this . registry = options . registry ; %NWL%this . pluginRegistry = options . pluginRegistry ; %NWL%this . profilePlaceholder = options . profilePlaceholder ; %NWL%this . commandService = options . commandService ; %NWL%this . pageActionsPlaceholder = options . pageActionsPlaceholder ; %NWL%this . usersClient = options . usersClient ; %NWL%5
goog . dom . TextRangeIterator . superClass_ . skipTag . apply ( this )  ; %NWL%if ( goog . dom . contains ( this . node , this . endNode_ )  )  {%NWL%throw goog . iter . StopIteration ;%NWL%}%NWL%}  ; %NWL%goog . dom . TextRangeIterator . prototype . copyFrom = function ( other )  {%NWL%this . startNode_ = other . startNode_ ; %NWL%this . endNode_ = other . endNode_ ; %NWL%this . startOffset_ = other . startOffset_ ; %NWL%this . endOffset_ = other . endOffset_ ; %NWL%this . isReversed_ = other . isReversed_ ; %NWL%6
this . host					 = aCookie . host ; %NWL%this . rawHost			 = aCookie . rawHost ? aCookie . rawHost :  ( aCookie . host . charAt ( 0 )  =  =  "  .  " ? aCookie . host . substring ( 1 , aCookie . host . length )  : aCookie . host )  ; %NWL%this . simpleHost		 = this . rawHost . charAt ( 0 )  =  =  "  .  " ? this . rawHost . substring ( 1 , this . rawHost . length )  : this . rawHost . match (  / ^www\ .  /  ) ? this . rawHost . replace (  / ^www\ .  /  ,  "  "  )  : this . rawHost ; %NWL%this . rootHost			 = this . rawHost . replace (  / ^ .  * \ .  (  [ ^ .  ]  + \ .  [ ^ .  ]  +  ) $ /  ,  " $1 "  )  ; %NWL%this . path					 = aCookie . path ; %NWL%this . isSecure			 = aCookie . isSecure ; %NWL%this . expires			 = aCookie . expires ; %NWL%this . policy				 = aCookie . policy ; %NWL%this . status				 = typeof ( aCookie . status )  =  =  " undefined " ? null : aCookie . status ; %NWL%this . isSession		 = typeof ( aCookie . isSession )  =  =  " undefined " ? null : aCookie . isSession ; %NWL%this . expiry				 = typeof ( aCookie . expiry )  =  =  " undefined " ? null : aCookie . expiry ; %NWL%8
styles = wrapperEl . style ; %NWL%if ( styles ! =  = undefined )  {%NWL%style = styles [ name ]  ; %NWL%return style =  =  =  '  ' ? undefined :  ( style . substring ( style . length - 2 )  =  =  =  ' px ' ? REAL ( style )  : style )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%self . getWidth = getWidth = function (  )  {%NWL%return wrapperEl . offsetWidth ;%NWL%}  ; %NWL%self . getInnerWidth = getInnerWidth = function (  )  {%NWL%7
t1 = nodes . splice ( lowestHighY , 1 )  [ 0 ]  ;%NWL%}%NWL%}%NWL%return [%NWL%{ x : t1 . x , y : t1 . y , w : t1 . w , h : t1 . h , nodes :  [ t1 ]  }  ,%NWL%{ x : t2 . x , y : t2 . y , w : t2 . w , h : t2 . h , nodes :  [ t2 ]  }%NWL%]  ;%NWL%}  ; %NWL%var attachData = function ( node , moreTree )  {%NWL%node . nodes = moreTree . nodes ; %NWL%node . x = moreTree . x ; %NWL%9
node [ property ] 	 = properties [ property ]  ;%NWL%}%NWL%return this ;%NWL%}  ; %NWL%WebAudio . NodeChainBuilder . prototype . cloneBufferSource	 = function (  )  {%NWL%console . assert ( this . _nodes . bufferSource ,  " no buffersource presents . Add one .  "  )  ; %NWL%var orig	 = this . _nodes . bufferSource ; %NWL%var clone	 = this . _context . createBufferSource (  )%NWL%clone . buffer		 = orig . buffer ; %NWL%clone . playbackRate	 = orig . playbackRate ; %NWL%clone . loop		 = orig . loop ; %NWL%8
Lang = YAHOO . lang ,%NWL%FLASH_CID =  " clsid : d27cdb6e - ae6d - 11cf - 96b8 - 444553540000 "  ,%NWL%FLASH_TYPE =  " application / x - shockwave - flash "  ,%NWL%FLASH_VER =  " 10 . 22 "  ,%NWL%EXPRESS_INSTALL_URL =  " http :  /  / fpdownload . macromedia . com / pub / flashplayer / update / current / swf / autoUpdater . swf? "  + Math . random (  )  ,%NWL%EVENT_HANDLER =  " YAHOO . widget . SWF . eventHandler "  ,%NWL%possibleAttributes =  { align :  "  "  , allowNetworking :  "  "  , allowScriptAccess :  "  "  , base :  "  "  , bgcolor :  "  "  , menu :  "  "  , name :  "  "  , quality :  "  "  , salign :  "  "  , scale :  "  "  , tabindex :  "  "  , wmode :  "  "  }  ; %NWL%YAHOO . widget . SWF = function ( p_oElement , swfURL , p_oAttributes  )  {%NWL%this . _queue = this . _queue || [  ]  ; %NWL%this . _events = this . _events || {  }  ; %NWL%this . _configs = this . _configs || {  }  ; %NWL%9
NormalModule . prototype . createTemplate = function ( keepModules , roots )  {%NWL%roots . sort ( function ( a , b )  {%NWL%var ia = a . identifier (  )  ; %NWL%var ib = b . identifier (  )  ; %NWL%if ( ia < ib ) return - 1 ; %NWL%if ( ib < ia ) return 1 ; %NWL%return 0 ;%NWL%}  )  ; %NWL%var template = new NormalModule (  "  "  ,  "  "  ,  "  "  ,  [  ]  ,  "  "  , null )  ; %NWL%template . _source = this . _source ; %NWL%template . built = this . built ; %NWL%9
function ( declare , WidgetBase , TemplatedMixin , template , domConstruct , topic , JSON ,%NWL%domClass , on , servicesService , ExplorerContainer , Evented )  {%NWL%return declare (  ' CreationOAuth2ItemWidget '  ,  [ WidgetBase , TemplatedMixin ]  ,  {%NWL%templateString : template ,%NWL%constructor : function ( obj )  {%NWL%this . name = obj . name ; %NWL%this . clientId = obj . clientId ; %NWL%this . clientSecret = obj . clientSecret ; %NWL%this . authUrl = obj . authUrl ; %NWL%this . tokenUrl = obj . tokenUrl ; %NWL%this . type = obj . type ; %NWL%5
}  ; %NWL%CubeMap . prototype . isDestroyed = function (  )  {%NWL%return false ;%NWL%}  ; %NWL%CubeMap . prototype . destroy = function (  )  {%NWL%this . _gl . deleteTexture ( this . _texture )  ; %NWL%this . _positiveX = destroyObject ( this . _positiveX )  ; %NWL%this . _negativeX = destroyObject ( this . _negativeX )  ; %NWL%this . _positiveY = destroyObject ( this . _positiveY )  ; %NWL%this . _negativeY = destroyObject ( this . _negativeY )  ; %NWL%this . _positiveZ = destroyObject ( this . _positiveZ )  ; %NWL%6
}%NWL%out . top +  = top ; %NWL%out . left +  = left ;%NWL%}%NWL%return out ;%NWL%}  ; %NWL%offsetToPx = function ( offset , size )  {%NWL%if ( typeof offset . left =  =  =  ' string ' && offset . left . indexOf (  ' % '  ) ! =  =  - 1 )  {%NWL%offset . left = parseFloat ( offset . left , 10 )  / 100 * size . width ;%NWL%}%NWL%if ( typeof offset . top =  =  =  ' string ' && offset . top . indexOf (  ' % '  ) ! =  =  - 1 )  {%NWL%7
this . value = familyValue ;%NWL%}%NWL%var familyName ; %NWL%var familyValue ; %NWL%Family . prototype . name = familyName ; %NWL%Family . prototype . value = familyValue ; %NWL%function ThemeBuilder ( args )  {%NWL%this . settings =  {  }  ; %NWL%this . themeData = args . themeData ; %NWL%this . toolbarId = args . toolbarId ; %NWL%this . serviceRegistry = args . serviceRegistry ; %NWL%8
' change . checkboxField input '  :  ' checkboxChange '%NWL%}  ,%NWL%template : function (  )  {%NWL%return _ . template ( SettingPanelViewTemplate )  (  )  ;%NWL%}  ,%NWL%initialize : function ( options )  {%NWL%this . fieldsList    = options . fieldsList ; %NWL%this . URLOptions    = options . URLOptions ; %NWL%this . modelToEdit    = options . modelToEdit ; %NWL%this . linkedFieldsList   = options . linkedFieldsList ; %NWL%this . preConfiguredFieldList = options . preConfiguredFieldList ; %NWL%6
require (  '  .  / mobile_env '  )  ; %NWL%env . EXPRESS_PORT = _ ( process . env . EXPRESS_PORT || 3000 )  . toNumber (  )  . value (  )  ; %NWL%env . PROXY_PORT = _ ( process . env . PROXY_PORT || 5050 )  . toNumber (  )  . value (  )  ; %NWL%if ( env . ANDROID )  {%NWL%env . TIMEOUT = 300000 ;%NWL%}%NWL%env . SAUCE_CONNECT = toBoolean ( process . env . SAUCE_CONNECT )  ; %NWL%env . SAUCE = toBoolean ( process . env . SAUCE ) || env . SAUCE_CONNECT ; %NWL%env . TRAVIS_JOB_ID = process . env . TRAVIS_JOB_ID ; %NWL%env . TRAVIS_JOB_NUMBER = process . env . TRAVIS_JOB_NUMBER ; %NWL%env . TRAVIS_BUILD_NUMBER = process . env . TRAVIS_BUILD_NUMBER ; %NWL%8
$ (  ' account '  )  . setAttribute (  ' missing '  , true )  ; %NWL%$ (  ' account '  )  . select (  )  ; %NWL%alert ( gStrbundle . getString (  " dupAccount "  )  )  ; %NWL%return false ;%NWL%}%NWL%}%NWL%}%NWL%gSite . account    = $ (  ' account '  )  . value ; %NWL%gSite . folder    = $ (  ' folder '  )  . value ; %NWL%gSite . host    = $ (  ' host '  )  . value . trim (  )  ; %NWL%gSite . port    = $ (  ' port '  )  . value ; %NWL%7
0 ,%NWL%0 ,%NWL%crop . width ,%NWL%crop . height )  ;%NWL%}  ; %NWL%PIXI . CanvasTinter . tintWithOverlay = function ( texture , color , canvas )%NWL%{%NWL%var context = canvas . getContext (  " 2d "  )  ; %NWL%var crop = texture . crop ; %NWL%canvas . width = crop . width ; %NWL%canvas . height = crop . height ; %NWL%9
View =  ( function (  )  {%NWL%function View ( fragment , behaviors , bindings , children , systemControlled , contentSelectors )  {%NWL%_classCallCheck ( this , View )  ; %NWL%this . fragment = fragment ; %NWL%this . behaviors = behaviors ; %NWL%this . bindings = bindings ; %NWL%this . children = children ; %NWL%this . systemControlled = systemControlled ; %NWL%this . contentSelectors = contentSelectors ; %NWL%this . firstChild = fragment . firstChild ; %NWL%this . lastChild = fragment . lastChild ; %NWL%9
var src = column . src ; %NWL%if ( column . id =  =  ' deleteButton ' && obj . noDelete )  {%NWL%dojo . create (  ' div '  ,  {  }  , td )  ; %NWL%break ;%NWL%}%NWL%var imgProps =  { src : src , onclick : dojo . hitch ( this ,  ' rowPropChanged '  , obj , column . id , tr )  }  ; %NWL%if ( column . width )  {%NWL%imgProps . width = column . width ;%NWL%}%NWL%if ( column . height )%NWL%imgProps . height = column . height ; %NWL%7
var state = this . _state [ stateId ]  ; %NWL%var facade = state . facade ; %NWL%facade . _setResponseHeaders ( response . responseHeaders )  ; %NWL%if ( response . status =  = 0 || response . status )  {%NWL%facade . status = parseInt ( response . status , 10 )  ;%NWL%}%NWL%if ( response . statusText )  {%NWL%facade . statusText = response . statusText ;%NWL%}%NWL%if ( response . responseText )  {%NWL%facade . responseText = response . responseText ; %NWL%7
res . isIncludeFiltered = this . isIncludeFiltered ; %NWL%res . isEach = this . isEach ; %NWL%res . lastTag = this . lastTag ; %NWL%res . scriptType = this . scriptType ; %NWL%res . isAttrs = this . isAttrs ; %NWL%res . attrsNest = this . attrsNest . slice (  )  ; %NWL%res . inAttributeName = this . inAttributeName ; %NWL%res . attributeIsType = this . attributeIsType ; %NWL%res . attrValue = this . attrValue ; %NWL%res . indentOf = this . indentOf ; %NWL%res . indentToken = this . indentToken ; %NWL%0
item . isDirty = true ; %NWL%return true ; %NWL%case " contributor "  : %NWL%update . contributors = item . contributors ; %NWL%this . _addUpdate ( update )  ; %NWL%item . contributors = null ; %NWL%item . addContributor ( value . name , value . email , value . uri )  ; %NWL%item . isDirty = true ; %NWL%return true ; %NWL%case " category "  : %NWL%update . categories = item . categories ; %NWL%3
)  . cyan +  '  -  '  + taskrun . waiting )  ; %NWL%taskrun . startedAt = false ;%NWL%}  ; %NWL%taskrun . triggered = function triggered (  )  {%NWL%grunt . log . ok (  )  ; %NWL%Object . keys ( taskrun . changedFiles )  . forEach ( function ( filepath )  {%NWL%grunt . log . ok (  ' File "  '  + filepath +  '  "  '  + taskrun . changedFiles [ filepath ]  +  '  .  '  )  ;%NWL%}  )  ; %NWL%taskrun . changedFiles = Object . create ( null )  ;%NWL%}  ; %NWL%taskrun . interrupt = function interrupt (  )  {%NWL%3
base . init = initCubicVR ; %NWL%base . start = startUp ; %NWL%base . addResizeable = GLCore . addResizeable ; %NWL%base . setFixedAspect = GLCore . setFixedAspect ; %NWL%base . setFixedSize = GLCore . setFixedSize ; %NWL%base . setCanvasSizeFactor = GLCore . setCanvasSizeFactor ; %NWL%base . getCanvas = GLCore . getCanvas ; %NWL%base . enums = enums ; %NWL%base . IdentityMatrix = cubicvr_identity ; %NWL%base . Textures = base . Textures ; %NWL%base . Textures_obj = base . Textures_obj ; %NWL%9
json . y = this . y ; %NWL%json . w = this . w ; %NWL%json . h = this . h ; %NWL%return json ;%NWL%}  ; %NWL%Sprite . prototype . fromJSON = function ( json )  {%NWL%Component . prototype . fromJSON . call ( this , json )  ; %NWL%this . visible = json . visible ; %NWL%this . blending = json . blending ; %NWL%this . layer = json . layer ; %NWL%this . z = json . z ; %NWL%7
}  )  ;%NWL%}  ; %NWL%return Step ;%NWL%}  )  ( Evented )  ; %NWL%Shepherd =  ( function ( _super )  {%NWL%__extends ( Shepherd , _super )  ; %NWL%function Shepherd ( options )  {%NWL%var _ref1 ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . hide = __bind ( this . hide , this )  ; %NWL%this . cancel = __bind ( this . cancel , this )  ; %NWL%9
return _self ;%NWL%}%NWL%function _massage ( property , name )  {%NWL%if ( name =  =  =  " recurrence " && property )  {%NWL%if ( property . end )  {%NWL%property . end = new Date ( property . end )  ;%NWL%}%NWL%}%NWL%if ( name =  =  =  " reminder " && property )  {%NWL%if ( property . date )  {%NWL%property . date = new Date ( property . date )  ; %NWL%5
if ( breakingProcess ! =  = null )  {%NWL%clearInterval ( breakingProcess )  ;%NWL%}%NWL%e . stopPropagation (  )  ;%NWL%}  )  ; %NWL%$this . bind (  " touchmove "  + eventClassName , function ( e )  {%NWL%if ( !inGlobalTouch && e . originalEvent . targetTouches . length =  =  = 1 )  {%NWL%var touch = e . originalEvent . targetTouches [ 0 ]  ; %NWL%var currentCoords =  {  }  ; %NWL%currentCoords . pageX = touch . pageX ; %NWL%currentCoords . pageY = touch . pageY ; %NWL%9
ip . isPrivate = function isPrivate ( addr )  {%NWL%return addr . match (  / ^10\ .  (  [ 0 - 9 ]  { 1 , 3 }  ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  )  /  ) ! = null ||%NWL%addr . match (  / ^192\ . 168\ .  (  [ 0 - 9 ]  { 1 , 3 }  ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  )  /  ) ! = null ||%NWL%addr . match (%NWL%/ ^172\ .  ( 1 [ 6 - 9 ] |2\d|30|31 ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  )  /  ) ! = null ||%NWL%addr . match (  / ^127\ .  (  [ 0 - 9 ]  { 1 , 3 }  ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  )  /  ) ! = null ||%NWL%addr . match (  / ^169\ . 254\ .  (  [ 0 - 9 ]  { 1 , 3 }  ) \ .  (  [ 0 - 9 ]  { 1 , 3 }  )  /  ) ! = null ||%NWL%addr . match (  / ^fc00 :  /  ) ! = null || addr . match (  / ^fe80 :  /  ) ! = null ||%NWL%addr . match (  / ^ :  : 1$ /  ) ! = null || addr . match (  / ^ :  : $ /  ) ! = null ;%NWL%}  ; %NWL%ip . isPublic = function isPublic ( addr )  {%NWL%0
dep . type = fileTypes ; %NWL%dep . name = componentConfigFile . name ; %NWL%var depIsExcluded = $ . _ . find ( config . get (  ' exclude '  )  , function ( pattern )  {%NWL%return $ . path . join ( config . get (  ' bower - directory '  )  , component )  . match ( pattern )  ;%NWL%}  )  ; %NWL%if ( dep . main . length =  =  = 0 && !depIsExcluded )  {%NWL%config . get (  ' on - main - not - found '  )  ( component )  ; %NWL%return ;%NWL%}%NWL%if ( componentConfigFile . dependencies )  {%NWL%dep . dependencies = componentConfigFile . dependencies ; %NWL%1
if ( obj . hasOwnProperty (  " borderStrokeStyle "  )  )  {%NWL%this . borderStrokeStyle = obj . borderStrokeStyle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " rotate "  )  )  {%NWL%this . rotate = obj . rotate ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " angle "  )  )  {%NWL%this . angle = obj . angle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " textFillStyle "  )  )  {%NWL%this . textFillStyle = obj . textFillStyle ; %NWL%1
oValue . view			 = oView ; %NWL%oValue . detail		 = nDetail ; %NWL%return oValue ;%NWL%}  ; %NWL%function fUIEvent_init ( oEvent , sType , oValue )  {%NWL%fEvent_init ( oEvent , sType , oValue )  ; %NWL%if ( oValue )  {%NWL%if (  " view " in oValue )%NWL%oEvent . view		 = oValue . view ; %NWL%if (  " detail " in oValue )%NWL%oEvent . detail	 = oValue . detail ; %NWL%8
}%NWL%httpPlug . OutgoingMessage . prototype . gjsSetHeader = function ( name , value )  {%NWL%return ( setHeader . apply ( this , arguments )  )  ;%NWL%}%NWL%httpPlug . OutgoingMessage . prototype . gjsRemoveHeader = function ( name )  {%NWL%return ( removeHeader . apply ( this , arguments )  )  ;%NWL%}%NWL%var http = function (  )  {  }  ; %NWL%http . agent = require ( __dirname +  '  / js / agent '  )  ; %NWL%http . log = require ( __dirname +  '  / js / log '  )  ; %NWL%http . littleFs = require ( __dirname +  '  / js / littleFs '  )  ; %NWL%8
exports . UTF8MB4_SINHALA_CI    = 243 ; %NWL%exports . UTF8MB4_GERMAN2_CI    = 244 ; %NWL%exports . UTF8MB4_CROATIAN_MYSQL561_CI = 245 ; %NWL%exports . UTF8MB4_UNICODE_520_CI   = 246 ; %NWL%exports . UTF8MB4_VIETNAMESE_CI   = 247 ; %NWL%exports . UTF8_GENERAL50_CI    = 253 ; %NWL%exports . ARMSCII8 = exports . ARMSCII8_GENERAL_CI ; %NWL%exports . ASCII  = exports . ASCII_GENERAL_CI ; %NWL%exports . BIG5  = exports . BIG5_CHINESE_CI ; %NWL%exports . BINARY  = exports . BINARY ; %NWL%exports . CP1250  = exports . CP1250_GENERAL_CI ; %NWL%6
Stars . prototype . setStars = function ( stars )  {%NWL%var img = renderer . cache [  ' static '  ]  [ stars +  ' stars . png '  ]  ; %NWL%this . resize ( img . getSize (  )  )%NWL%this . setImage ( img )  ;%NWL%}  ; %NWL%var KeyExplanation = exports . KeyExplanation = function ( pars )  {%NWL%pars . size =  [ 400 , 52 ]  ; %NWL%KeyExplanation . superConstructor . apply ( this ,  [ pars ]  )  ; %NWL%var font = getFont (  ' 25_66 '  )  ; %NWL%this . key = pars . key ; %NWL%this . text = pars . text ; %NWL%9
var callback , speed = settings . transition =  =  =  " none " ? 0 : settings . speed ; %NWL%$loaded . remove (  )  ; %NWL%$loaded = $tag ( div ,  ' LoadedContent '  )  . append ( object )  ; %NWL%function getWidth (  )  {%NWL%settings . w = settings . w || $loaded . width (  )  ; %NWL%settings . w = settings . mw && settings . mw < settings . w ? settings . mw : settings . w ; %NWL%return settings . w ;%NWL%}%NWL%function getHeight (  )  {%NWL%settings . h = settings . h || $loaded . height (  )  ; %NWL%settings . h = settings . mh && settings . mh < settings . h ? settings . mh : settings . h ; %NWL%5
result . semiMinorAxis = this . semiMinorAxis ; %NWL%result . show = this . show ; %NWL%result . material = this . material ; %NWL%result . height = this . height ; %NWL%result . extrudedHeight = this . extrudedHeight ; %NWL%result . granularity = this . granularity ; %NWL%result . stRotation = this . stRotation ; %NWL%result . fill = this . fill ; %NWL%result . outline = this . outline ; %NWL%result . outlineColor = this . outlineColor ; %NWL%result . outlineWidth = this . outlineWidth ; %NWL%0
if ( result . styleClass && style . styleClass && result . styleClass ! =  = style . styleClass )  {%NWL%result . styleClass +  =  "  "  + style . styleClass ;  /  / $NON - NLS - 0$%NWL%} else {%NWL%result . styleClass = style . styleClass ;%NWL%}%NWL%var prop ; %NWL%if ( style . style )  {%NWL%if ( !result . style )  { result . style  =  {  }  ;  }%NWL%for ( prop in style . style )  {%NWL%if ( result . style [ prop ]  =  =  = undefined )  {%NWL%result . style [ prop ]  = style . style [ prop ]  ; %NWL%3
return this ;%NWL%}  ; %NWL%proto . _getOnceReturnValue = function _getOnceReturnValue (  )  {%NWL%if ( this . hasOwnProperty (  ' _onceReturnValue '  )  )  {%NWL%return this . _onceReturnValue ;%NWL%}%NWL%else {%NWL%return true ;%NWL%}%NWL%}  ; %NWL%proto . _getEvents = function _getEvents (  )  {%NWL%2
if ( templateSpec . useDepths )  {%NWL%depths = options . depths ? [ context ]  . concat ( options . depths )  :  [ context ]  ;%NWL%}%NWL%return templateSpec . main . call ( container , context , container . helpers , container . partials , data , depths )  ;%NWL%}  ; %NWL%ret . isTop = true ; %NWL%ret . _setup = function ( options )  {%NWL%if ( !options . partial )  {%NWL%container . helpers = container . merge ( options . helpers , env . helpers )  ; %NWL%if ( templateSpec . usePartial )  {%NWL%container . partials = container . merge ( options . partials , env . partials )  ; %NWL%8
var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red * c2 . red ; %NWL%result . green = c1 . green * c2 . green ; %NWL%result . blue = c1 . blue * c2 . blue ; %NWL%return result ;%NWL%}  ,%NWL%multiplyScalar : function ( c1 , f )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red * f ; %NWL%result . green = c1 . green * f ; %NWL%result . blue = c1 . blue * f ; %NWL%8
}%NWL%function BottomController ( $scope , DemoService )  {%NWL%$scope . topValue = 0 ; %NWL%$scope . middleValue = 0 ; %NWL%$scope . bottomValue = 0 ; %NWL%$scope . $watch (  ' bottomValue '  , function (  )  {%NWL%DemoService . updateBottomValue ( $scope . bottomValue )  ;%NWL%}  )  ; %NWL%$scope . $on (  ' valuesUpdated '  , function (  )  {%NWL%$scope . topValue = DemoService . topValue ; %NWL%$scope . middleValue = DemoService . middleValue ; %NWL%9
}%NWL%}  ; %NWL%var current_keys =  {%NWL%codes :  {  }  ,%NWL%ctrl : false ,%NWL%alt : false ,%NWL%shift : false%NWL%}  ; %NWL%function update_current_modifiers ( key )  {%NWL%current_keys . ctrl = key . ctrl ; %NWL%current_keys . alt = key . alt ; %NWL%9
return _results ;%NWL%}  ; %NWL%exports . _makeAppend = makeAppend = function ( op )  {%NWL%return function ( component )  {%NWL%if ( component =  =  = 0 || component . i =  =  =  '  ' || component . d =  =  =  '  '  )  {  } else if ( op . length =  =  = 0 )  {%NWL%return op . push ( component )  ;%NWL%} else if ( typeof component =  =  =  ' number ' && typeof op [ op . length - 1 ]  =  =  =  ' number '  )  {%NWL%return op [ op . length - 1 ]  +  = component ;%NWL%} else if (  ( component . i ! = null ) && ( op [ op . length - 1 ]  . i ! = null )  )  {%NWL%return op [ op . length - 1 ]  . i +  = component . i ;%NWL%} else if (  ( component . d ! = null ) && ( op [ op . length - 1 ]  . d ! = null )  )  {%NWL%8
var offset = elem . offset (  )  ; %NWL%newItem . left = offset . left ; %NWL%newItem . top = offset . top ; %NWL%newItem . width = elem . width (  )  ; %NWL%newItem . height = elem . height (  )  ; %NWL%newItem . borderLeftWidth = elem . css (  ' borderLeftWidth '  ) || 0 ; %NWL%newItem . borderTopWidth = elem . css (  ' borderTopWidth '  ) || 0 ; %NWL%newItem . borderRightWidth = elem . css (  ' borderRightWidth '  ) || 0 ; %NWL%newItem . borderBottomWidth = elem . css (  ' borderBottomWidth '  ) || 0 ; %NWL%newItem . borderLeftColor = elem . css (  ' borderLeftColor '  )  ; %NWL%newItem . borderTopColor = elem . css (  ' borderTopColor '  )  ; %NWL%9
Emitter2D . prototype . copy = function ( other )  {%NWL%this . positionType = other . positionType ; %NWL%this . velocityType = other . velocityType ; %NWL%this . material = other . material ; %NWL%this . position . copy ( other . position )  ; %NWL%this . positionSpread . copy ( other . positionSpread )  ; %NWL%this . positionRadius = other . positionRadius ; %NWL%this . speed = other . speed ; %NWL%this . speedSpread = other . speedSpread ; %NWL%this . worldSpace = other . worldSpace ; %NWL%this . minEmission = other . minEmission ; %NWL%1
self . mark = true%NWL%self . sync = !!options . sync%NWL%self . nounique = !!options . nounique%NWL%self . nonull = !!options . nonull%NWL%self . nosort = !!options . nosort%NWL%self . nocase = !!options . nocase%NWL%self . stat = !!options . stat%NWL%self . noprocess = !!options . noprocess%NWL%self . maxLength = options . maxLength || Infinity%NWL%self . cache = options . cache || Object . create ( null )%NWL%self . statCache = options . statCache || Object . create ( null )%NWL%9
exports . linuxOsInfo = linuxOsInfo ; %NWL%exports . run = function ( callback )  {%NWL%var installFunction = framework . getInstall ( process . platform )  ; %NWL%installFunction ( callback )  ;%NWL%}  ; %NWL%exports . getSteps = function (  )  {%NWL%return framework . getSteps ( process . platform )  ;%NWL%}  ; %NWL%exports . events = framework . events ; %NWL%exports . stepCount = framework . count ; %NWL%exports . registerStep = framework . registerStep ; %NWL%8
}%NWL%return element ;%NWL%}  ,%NWL%fixEvent = function ( e )  {%NWL%var result =  {  }  ; %NWL%if ( !e )  {%NWL%return result ;%NWL%}%NWL%var type = e . type , target = e . target || e . srcElement ; %NWL%result . preventDefault = fixEvent . preventDefault ( e )  ; %NWL%result . stopPropagation = fixEvent . stopPropagation ( e )  ; %NWL%9
sensorDefinitions . goLinkO2 . sensorName = i18n . t (  " sensor . names . goLinkO2 "  )  ; %NWL%sensorDefinitions . labQuestMotion . measurementName = i18n . t (  " sensor . measurements . distance "  )  ; %NWL%sensorDefinitions . labQuestMotion . sensorName = i18n . t (  " sensor . names . labQuestMotion "  )  ; %NWL%sensorDefinitions . labQuestTemperature . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . labQuestTemperature . sensorName = i18n . t (  " sensor . names . labQuestTemperature "  )  ; %NWL%sensorDefinitions . labQuestLight . measurementName = i18n . t (  " sensor . measurements . light_intensity "  )  ; %NWL%sensorDefinitions . labQuestLight . sensorName = i18n . t (  " sensor . names . labQuestLight "  )  ; %NWL%sensorDefinitions . labQuestForce . measurementName = i18n . t (  " sensor . measurements . force "  )  ; %NWL%sensorDefinitions . labQuestForce . sensorName = i18n . t (  " sensor . names . labQuestForce "  )  ; %NWL%sensorDefinitions . labQuestPH . measurementName = i18n . t (  " sensor . measurements . acidity "  )  ; %NWL%sensorDefinitions . labQuestPH . sensorName = i18n . t (  " sensor . names . labQuestPH "  )  ; %NWL%0
height : 24 ,%NWL%shape :  " rect "  ,%NWL%padding :  {%NWL%top : 0 ,%NWL%left : 0 ,%NWL%right : 0 ,%NWL%bottom : 0%NWL%}%NWL%}  ; %NWL%defs . fill . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " fill "  )  ; %NWL%defs . border . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " border "  )  ; %NWL%9
return result ;%NWL%}%NWL%}  ; %NWL%fs . fchmod = wrap ( fs . fchmod ,  ' fs . fchmod '  , 2 )  ; %NWL%fs . fchown = wrap ( fs . fchown ,  ' fs . fchown '  , 3 )  ; %NWL%fs . fdatasync = wrap ( fs . fdatasync ,  ' fs . fdatasync '  , 1 )  ; %NWL%fs . read = wrap ( fs . read ,  ' fs . read '  , 5 )  ; %NWL%fs . writeBuffer = wrap ( fs . writeBuffer ,  ' fs . write '  , 5 )  ; %NWL%fs . writeString = wrap ( fs . writeString ,  ' fs . write '  , 4 )  ; %NWL%fs . fstat = wrap ( fs . fstat ,  ' fs . fstat '  , 1 )  ; %NWL%fs . fsync = wrap ( fs . fsync ,  ' fs . fsync '  , 1 )  ; %NWL%5
this . CreateVertices ( inNoise , geometry , inDepth , inWidth , inHeight )  ; %NWL%this . CreateFaces ( geometry , inWidthSegments , inHeightSegments )  ; %NWL%return geometry ;%NWL%}  ,%NWL%Get : function ( inParameters )%NWL%{%NWL%inParameters = inParameters || {  }  ; %NWL%inParameters . type = inParameters . type || 0 ; %NWL%inParameters . depth = inParameters . depth || 10 ; %NWL%inParameters . width = inParameters . width || 100 ; %NWL%inParameters . height = inParameters . height || 100 ; %NWL%9
title :  " Version for "  + version . title ,%NWL%next : next ( history . versions , req . params . version )  ,%NWL%previous : previous ( history . versions , req . params . version )  ,%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%app . post (  "  / versions /  : pageId /  : version / restore "  ,  [ loadPage , loadVersion ]  , function ( req , res )  {%NWL%var page = req . page ; %NWL%var version = req . version ; %NWL%page . title = version . title ; %NWL%page . content = version . content ; %NWL%9
self . getLeft = getLeft = function (  )  {%NWL%var%NWL%left = 0 ,%NWL%parentEl = wrapperEl ; %NWL%do {%NWL%left +  = parentEl . offsetLeft -  ( parentEl =  =  = document . body ? 0 : parentEl . scrollLeft )  ; %NWL%parentEl = parentEl . offsetParent ;%NWL%} while ( parentEl ! =  = TO_DELETE )  ; %NWL%return left ;%NWL%}  ; %NWL%self . getTop = getTop = function (  )  {%NWL%0
this . angularVelocity = json . angularVelocity ; %NWL%this . angularAcceleration = json . angularAcceleration ; %NWL%this . angularVelocitySpread = json . angularVelocitySpread ; %NWL%this . randomAngle = json . randomAngle ; %NWL%this . emissionRate = json . emissionRate ; %NWL%this . color . fromJSON ( json . color )  ; %NWL%this . colorSpread . fromJSON ( json . colorSpread )  ; %NWL%this . time = json . time ; %NWL%this . _time = json . _time ; %NWL%this . duration = json . duration ; %NWL%this . loop = json . loop ; %NWL%0
this . max = max ;%NWL%} else {%NWL%this . leftmax  = RGraph . array_max ( this . left )  ; %NWL%this . rightmax = RGraph . array_max ( this . right )  ; %NWL%max = Math . max ( this . leftmax , this . rightmax )  ; %NWL%this . scale  = RGraph . getScale ( max , this )  ; %NWL%this . scale [ 0 ]  = Number ( this . scale [ 0 ]  )  . toFixed ( dec )  ; %NWL%this . scale [ 1 ]  = Number ( this . scale [ 1 ]  )  . toFixed ( dec )  ; %NWL%this . scale [ 2 ]  = Number ( this . scale [ 2 ]  )  . toFixed ( dec )  ; %NWL%this . scale [ 3 ]  = Number ( this . scale [ 3 ]  )  . toFixed ( dec )  ; %NWL%this . scale [ 4 ]  = Number ( this . scale [ 4 ]  )  . toFixed ( dec )  ; %NWL%6
_naturalWidth : data ( 0 , true , true )  ,%NWL%_naturalHeight : data ( 0 , true , true )  ,%NWL%source : accessor ( getSource , setSource , true )  ,%NWL%_source : data (  '  '  , true , true )  ,%NWL%_absoluteUrl : data (  '  '  , true , true )%NWL%}  )  ; %NWL%var rendererAttributes = this . _renderAttributes ; %NWL%rendererAttributes . height =  ' height '  ; %NWL%rendererAttributes . width =  ' width '  ; %NWL%rendererAttributes . naturalHeight =  ' _naturalHeight '  ; %NWL%rendererAttributes . naturalWidth =  ' _naturalWidth '  ; %NWL%9
plane . y = direction . y ; %NWL%plane . z = direction . z ; %NWL%plane . w =  - Cartesian3 . dot ( direction , nearCenter )  ; %NWL%Cartesian3 . multiplyByScalar ( direction , f , point )  ; %NWL%Cartesian3 . add ( position , point , point )  ; %NWL%plane = planes [ 5 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 5 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x =  - direction . x ; %NWL%plane . y =  - direction . y ; %NWL%9
Decryptor =  ( function ( _super )  {%NWL%__extends ( Decryptor , _super )  ; %NWL%function Decryptor ( _arg )  {%NWL%var enc , key ; %NWL%key = _arg . key , enc = _arg . enc ; %NWL%Decryptor . __super__ . constructor . call ( this ,  {%NWL%key : key%NWL%}  )  ; %NWL%if ( enc ! = null )  {%NWL%this . key = enc . key ; %NWL%this . derived_keys = enc . derived_keys ; %NWL%9
return true ;%NWL%}%NWL%runQueue (  )  ; %NWL%setTimeout ( arguments . callee , 500 )  ;%NWL%}%NWL%}  , 1000 )%NWL%}%NWL%for ( var i = 0 ; i < digests . length ; i +  +  )  {%NWL%item = digests [ i ]  ; %NWL%item . title = item . title . replace (  / \ <  / g ,  ' &lt ;  '  )  . replace (  / \ >  / g ,  ' &gt ;  '  )  ; %NWL%item . snippet = item . snippet . replace (  / \ <  / g ,  ' &lt ;  '  )  . replace (  / \ >  / g ,  ' &gt ;  '  )  ; %NWL%9
if ( this . sortField ! =  = undefined && this . sortField . field ! =  = undefined )  {%NWL%this . setSortField ( this . sortField . field , this . sortField . order )  ;%NWL%}%NWL%}  ,%NWL%setPageInfo : function setPageInfo ( pageInfos )  {%NWL%this . totalRecords = pageInfos . totalRecords ; %NWL%this . currentPage = pageInfos . currentPage ; %NWL%this . firstPage = pageInfos . firstPage ; %NWL%this . lastPage = pageInfos . lastPage ; %NWL%this . perPage = pageInfos . perPage ; %NWL%this . sortField = pageInfos . sortField ; %NWL%5
lodash . bindKey = functions . bindKey ; %NWL%lodash . chain = chaining . chain ; %NWL%lodash . compact = arrays . compact ; %NWL%lodash . compose = functions . compose ; %NWL%lodash . constant = utilities . constant ; %NWL%lodash . countBy = collections . countBy ; %NWL%lodash . create = objects . create ; %NWL%lodash . createCallback = functions . createCallback ; %NWL%lodash . curry = functions . curry ; %NWL%lodash . debounce = functions . debounce ; %NWL%lodash . defaults = objects . defaults ; %NWL%6
$scope . hideLink = false ; %NWL%$scope . blog = user . blog ;%NWL%} else {%NWL%$scope . hideLink = true ;%NWL%}%NWL%$scope . blogClick = function ( blog )  {%NWL%var ref = window . open ( blog ,  ' _system '  )  ;%NWL%}%NWL%if ( user . location )  {%NWL%$scope . hideLocation = false ; %NWL%$scope . location = user . location ; %NWL%1
if ( this . domElement . style . zIndex )  {%NWL%zIndex = parseInt ( this . domElement . style . zIndex )  + 1 ;%NWL%}%NWL%var box = ZeroClipboard . getDOMObjectPosition ( this . domElement )  ; %NWL%this . div = document . createElement (  ' div '  )  ; %NWL%var style = this . div . style ; %NWL%style . position =  ' absolute '  ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%style . width =  '  '  + box . width +  ' px '  ; %NWL%style . height =  '  '  + box . height +  ' px '  ; %NWL%7
}  ;%NWL%}%NWL%var restoreConsole ; %NWL%function captureConsole (  )  {%NWL%var logMethod = console . log%NWL%, logDebug = console . debug%NWL%, logInfo = console . info%NWL%, logWarn = console . warn%NWL%, logError = console . error ; %NWL%console . log = function (  )  { jstestdriver . console . log . apply ( jstestdriver . console , arguments )  ;  }  ; %NWL%console . debug = function (  )  { jstestdriver . console . debug . apply ( jstestdriver . console , arguments )  ;  }  ; %NWL%9
}  ,%NWL%resizeAction : function ( resizedObj )  {%NWL%var obj = util . getObjectById ( resizedObj . uid )  ; %NWL%obj . left = resizedObj . left ; %NWL%obj . top = resizedObj . top ; %NWL%obj . width = resizedObj . width ; %NWL%obj . height = resizedObj . height ; %NWL%obj . scaleX = resizedObj . scaleX ; %NWL%obj . scaleY = resizedObj . scaleY ; %NWL%obj . angle = resizedObj . angle ; %NWL%obj . stroke = resizedObj . stroke ; %NWL%3
inherits ( Torrent , EventEmitter )%NWL%function Torrent ( uri , opts )  {%NWL%var self = this%NWL%if ( ! ( self instanceof Torrent )  ) return new Torrent ( uri , opts )%NWL%EventEmitter . call ( self )%NWL%if ( typeof uri =  =  =  ' string '  )  {%NWL%var info = parseMagnetUri ( uri )%NWL%if ( !info . infoHash )%NWL%throw new Error (  ' invalid torrent uri '  )%NWL%self . infoHash = info . infoHash%NWL%self . name = info . name%NWL%9
exports . header = function ( artifacts , options )  {%NWL%options = options || {  }  ; %NWL%if ( !artifacts ||%NWL%typeof artifacts ! =  =  ' object ' ||%NWL%typeof options ! =  =  ' object '  )  {%NWL%return '  '  ;%NWL%}%NWL%artifacts = Hoek . clone ( artifacts )  ; %NWL%delete artifacts . mac ; %NWL%artifacts . hash = options . hash ; %NWL%artifacts . ext = options . ext ; %NWL%9
}  ; %NWL%Y . extend ( IEEventFacade , Y . DOM2EventFacade , proto )  ; %NWL%Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%9
" name "  :  " dummy "  ,%NWL%" require "  :  "  .  .  / spec / dummy "  ,%NWL%" xpath "  :  "  / @ / dummy "%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}  )  ; %NWL%require (  [  ' require '  ,  ' chai '  ,  ' mocha '  ,  ' zepto '  ]  , function ( require , chai , mocha , $ )  {%NWL%global . assert = chai . assert ; %NWL%global . expect = chai . expect ; %NWL%9
}%NWL%if ( typeof scene . volume . upperThreshold ! =  ' undefined '  )  {%NWL%volume . upperThreshold = scene . volume . upperThreshold ;%NWL%}%NWL%jQuery (  ' #threshold - volume '  )  . dragslider (  " option "  ,  " values "  ,%NWL%[ volume . lowerThreshold , volume . upperThreshold ]  )  ; %NWL%if ( typeof scene . volume . windowLow ! =  ' undefined '  )  {%NWL%volume . windowLow = scene . volume . windowLow ;%NWL%}%NWL%if ( typeof scene . volume . windowHigh ! =  ' undefined '  )  {%NWL%volume . windowHigh = scene . volume . windowHigh ; %NWL%2
}%NWL%sum = 0 ; %NWL%count = 0 ; %NWL%for ( j = 0 ; j < 10 ; j +  +  )  {%NWL%sum +  =  ( j + 1 )  * level . ratings [ date ]  [ j ]  ; %NWL%count +  = level . ratings [ date ]  [ j ]  ;%NWL%}%NWL%averages [ date ]  = count > 0 ? sum / count : 0 ;%NWL%}%NWL%ratingaverages . today = averages [ dtoday ] || 0 ; %NWL%ratingaverages . yesterday = averages [ dyesterday ] || 0 ; %NWL%9
if ( proc . extrude )  {%NWL%var ext = proc . extrude ; %NWL%prim . front = meshKit . getFloatNode ( ext ,  " front "  , 0 )  ; %NWL%prim . back = meshKit . getFloatNode ( ext ,  " back "  , 0 )  ; %NWL%prim . frontShift = meshKit . getFloatNode ( ext ,  " frontBevelShift "  , 0 )  ; %NWL%prim . backShift = meshKit . getFloatNode ( ext ,  " backBevelShift "  , 0 )  ; %NWL%prim . frontDepth = meshKit . getFloatNode ( ext ,  " frontBevelDepth "  , 0 )  ; %NWL%prim . backDepth = meshKit . getFloatNode ( ext ,  " backBevelDepth "  , 0 )  ; %NWL%prim . depth = meshKit . getFloatNode ( ext ,  " depth "  , 0 )  ; %NWL%prim . shift = meshKit . getFloatNode ( ext ,  " shift "  , 0 )  ; %NWL%prim . bevel = meshKit . getFloatNode ( ext ,  " bevel "  , 0 )  ; %NWL%2
this . material = other . material ; %NWL%this . position . copy ( other . position )  ; %NWL%this . positionSpread . copy ( other . positionSpread )  ; %NWL%this . positionRadius = other . positionRadius ; %NWL%this . speed = other . speed ; %NWL%this . speedSpread = other . speedSpread ; %NWL%this . worldSpace = other . worldSpace ; %NWL%this . minEmission = other . minEmission ; %NWL%this . maxEmission = other . maxEmission ; %NWL%this . minLife = other . minLife ; %NWL%this . maxLife = other . maxLife ; %NWL%0
rmin = Math . pow ( this . base , Math . floor ( Math . log ( min )  / Math . log ( this . base )  )  )  ; %NWL%rmax = Math . pow ( this . base , Math . ceil ( Math . log ( max )  / Math . log ( this . base )  )  )  ; %NWL%if ( rmin =  =  = 0 )  {%NWL%rmin = 1 ;%NWL%}%NWL%var order = Math . round ( Math . log ( rmin )  / Math . LN10 )  ; %NWL%if ( this . tickOptions =  = null || !this . tickOptions . formatString )  {%NWL%this . _overrideFormatString = true ;%NWL%}%NWL%this . min = rmin ; %NWL%this . max = rmax ; %NWL%9
if ( conf . database . host )  {%NWL%mongoDBConfig . host = conf . database . host%NWL%}%NWL%if ( conf . database . port )  {%NWL%mongoDBConfig . port = conf . database . port%NWL%}%NWL%if ( conf . database . name )  {%NWL%mongoDBConfig . name = conf . database . name%NWL%}%NWL%if ( conf . database . user )  {%NWL%mongoDBConfig . user = conf . database . user%NWL%1
this . Height = height ; %NWL%if ( collisionEvent ! = null )  {%NWL%this . CollisionEvent = collisionEvent ;%NWL%} else {%NWL%this . CollisionEvent = function (  )  {  }%NWL%}%NWL%}  ; %NWL%Enjine . Collideable . prototype =  {%NWL%Update : function (  )  {%NWL%this . X = this . Base . X ; %NWL%this . Y = this . Base . Y ; %NWL%9
this . staticContext . drawImage ( stroke . canvas , stroke . x , stroke . y , stroke . width , stroke . height , stroke . x , stroke . y , stroke . width , stroke . height )  ; %NWL%stroke . trash (  )  ; %NWL%this . history . push ( stroke )  ; %NWL%this . needsRender = true ;%NWL%}%NWL%delete this . progress [ id ]  ;%NWL%}  ,%NWL%addCache : function (  )  {%NWL%var cache = document . createElement (  " canvas "  )  ; %NWL%cache . width = this . width ; %NWL%cache . height = this . height ; %NWL%9
}%NWL%}%NWL%var idValue = valueValue [  ' id '  ]  ; %NWL%if ( idValue ! =  = null && idValue ! =  = undefined )  {%NWL%var idInstance = idValue ; %NWL%featureResponseInstance . id = idInstance ;%NWL%}%NWL%var typeValue = valueValue [  ' type '  ]  ; %NWL%if ( typeValue ! =  = null && typeValue ! =  = undefined )  {%NWL%var typeInstance = typeValue ; %NWL%featureResponseInstance . type = typeInstance ; %NWL%5
var node = place ; %NWL%place = function ( n )  { node . appendChild ( n )  ;  }  ;%NWL%}%NWL%if ( options . lineNumbers ) place = wrapLineNumberDiv ( place )  ; %NWL%place ( frame )  ; %NWL%frame . CodeMirror = this ; %NWL%this . win = frame . contentWindow ; %NWL%if ( typeof options . parserfile =  =  " string "  )%NWL%options . parserfile =  [ options . parserfile ]  ; %NWL%if ( typeof options . stylesheet =  =  " string "  )%NWL%options . stylesheet =  [ options . stylesheet ]  ; %NWL%8
if ( this . chars =  = 0 )  {%NWL%this . opcode =  '  '  ;%NWL%}%NWL%}  ; %NWL%OpComponent . prototype . skip = function (  )  {%NWL%this . opcode =  '  '  ;%NWL%}  ; %NWL%OpComponent . prototype . equals = function ( otherCmp , optDoNotCheckOpcode )  {%NWL%return ( optDoNotCheckOpcode || ( this . opcode =  = otherCmp . opcode )  )%NWL%&& this . chars =  = otherCmp . chars%NWL%&& this . lines =  = otherCmp . lines%NWL%9
this . startDate = startDate|| - Infinity ; %NWL%if ( this . startDate ! =  =  - Infinity )  {%NWL%this . startDate = DPGlobal . parseDate ( this . startDate , this . format , this . language )  ;%NWL%}%NWL%this . update (  )  ; %NWL%this . updateNavArrows (  )  ;%NWL%}  ,%NWL%setEndDate : function ( endDate )  {%NWL%this . endDate = endDate||Infinity ; %NWL%if ( this . endDate ! =  = Infinity )  {%NWL%this . endDate = DPGlobal . parseDate ( this . endDate , this . format , this . language )  ; %NWL%2
marker = this . _markers [ i ]  ,%NWL%offset = 0 ,%NWL%fillColor ,%NWL%borderColor ; %NWL%styles = this . get (  " styles "  )  . marker ; %NWL%offset = styles . width * 0 . 5 ; %NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? this . _copyObject ( styles )  : this . _copyObject ( styles [ state ]  )  ; %NWL%markerStyles . height = marker . get (  " height "  )  ; %NWL%markerStyles . x =  ( xcoords [ i ]  - offset )  ; %NWL%markerStyles . y = marker . get (  " y "  )  ; %NWL%markerStyles . id = marker . get (  " id "  )  ; %NWL%7
exports . repl = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . stream = require . resolve (  ' stream - browserify '  )  ; %NWL%exports . _stream_duplex = require . resolve (  ' stream - browserify / duplex . js '  )  ; %NWL%exports . _stream_passthrough = require . resolve (  ' stream - browserify / passthrough . js '  )  ; %NWL%exports . _stream_readable = require . resolve (  ' stream - browserify / readable . js '  )  ; %NWL%exports . _stream_transform = require . resolve (  ' stream - browserify / transform . js '  )  ; %NWL%exports . _stream_writable = require . resolve (  ' stream - browserify / writable . js '  )  ; %NWL%exports . string_decoder = require . resolve (  ' string_decoder /  '  )  ; %NWL%exports . sys = require . resolve (  ' util / util . js '  )  ; %NWL%exports . timers = require . resolve (  ' timers - browserify '  )  ; %NWL%exports . tty = require . resolve (  ' tty - browserify '  )  ; %NWL%1
this . format = options . format ; %NWL%if ( typeof options . separator =  =  ' string '  )%NWL%this . separator = options . separator ; %NWL%if ( typeof options . startDate =  =  ' string '  )%NWL%this . startDate = Date . parse ( options . startDate , this . format )  ; %NWL%if ( typeof options . endDate =  =  ' string '  )%NWL%this . endDate = Date . parse ( options . endDate , this . format )  ; %NWL%if ( typeof options . minDate =  =  ' string '  )%NWL%this . minDate = Date . parse ( options . minDate , this . format )  ; %NWL%if ( typeof options . maxDate =  =  ' string '  )%NWL%this . maxDate = Date . parse ( options . maxDate , this . format )  ; %NWL%4
C . lua_settop = F (  " lua_settop "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushvalue = F (  " lua_pushvalue "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_remove = F (  " lua_remove "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_insert = F (  " lua_insert "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_replace = F (  " lua_replace "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_checkstack = F (  " lua_checkstack "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_xmove = F (  " lua_xmove "  , void_t ,  [ lua_State , lua_State , int_t ]  )  ; %NWL%C . lua_isnumber = F (  " lua_isnumber "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_isstring = F (  " lua_isstring "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_iscfunction = F (  " lua_iscfunction "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_isuserdata = F (  " lua_isuserdata "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%5
for ( var up in newdata . _uplinks )  {%NWL%var need_change = !Utils . is_object ( data . _uplinks [ up ]  )%NWL%|| newdata . _uplinks [ up ]  . etag ! =  = data . _uplinks [ up ]  . etag%NWL%|| newdata . _uplinks [ up ]  . fetched ! =  = data . _uplinks [ up ]  . fetched%NWL%if ( need_change )  {%NWL%change = true%NWL%data . _uplinks [ up ]  = newdata . _uplinks [ up ]%NWL%}%NWL%}%NWL%if ( newdata . readme ! =  = data . readme )  {%NWL%data . readme = newdata . readme%NWL%6
if ( config . modules . DB_ENABLED )  {%NWL%self . db = require (  ' db '  )  ( config , io )  ;%NWL%}%NWL%if ( config . modules . SYNC_ENABLED )  {%NWL%self . sync = require (  ' sync '  )  ( config , io )  ;%NWL%}%NWL%if ( config . modules . TWITTER_ENABLED )  {%NWL%self . twitter = require (  ' twitter '  )  ( config , io )  ;%NWL%}%NWL%if ( config . modules . TWILIO_ENABLED )  {%NWL%self . twilio = require (  ' twilio '  )  ( config , io )  ; %NWL%1
this . expect (  '  :  '  )  ; %NWL%block = this . block (  )  ; %NWL%var node = new nodes . Filter ( tok . val , block , attrs && attrs . attrs )  ; %NWL%node . line = this . line (  )  ; %NWL%return node ;%NWL%}  ,%NWL%parseEach : function (  )  {%NWL%var tok = this . expect (  ' each '  )%NWL%, node = new nodes . Each ( tok . code , tok . val , tok . key )  ; %NWL%node . line = this . line (  )  ; %NWL%node . block = this . block (  )  ; %NWL%3
var me = this ,%NWL%bindings = me . bindings ,%NWL%name = me . name ,%NWL%i ; %NWL%me . parent = me . bindings = null ; %NWL%me . destroy (  )  ;  /  / we may be scheduled%NWL%replacement . depth = me . depth ; %NWL%replacement . bindings = bindings ; %NWL%replacement . generation = me . generation + 1 ; %NWL%replacement . name = name ; %NWL%replacement . id = me . id ; %NWL%6
defaults :  {%NWL%storageType :  " local "  ,%NWL%sitemapDb :  " scraper - sitemaps "  ,%NWL%dataDb :  "  "%NWL%}  ,%NWL%loadConfiguration : function ( callback )  {%NWL%chrome . storage . sync . get (  [  ' sitemapDb '  ,  ' dataDb '  ,  ' storageType '  ]  , function ( items )  {%NWL%this . storageType = items . storageType || this . defaults . storageType ; %NWL%if ( this . storageType =  =  =  ' local '  )  {%NWL%this . sitemapDb = this . defaults . sitemapDb ; %NWL%this . dataDb = this . defaults . dataDb ; %NWL%9
import Configuration from '  .  /  .  .  / configuration '  ; %NWL%export default Base . extend (  {%NWL%serverTokenEndpoint :  '  / users / sign_in '  ,%NWL%resourceName :  ' user '  ,%NWL%tokenAttributeName :  ' token '  ,%NWL%identificationAttributeName :  ' email '  ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint    = Configuration . serverTokenEndpoint ; %NWL%this . resourceName     = Configuration . resourceName ; %NWL%this . tokenAttributeName    = Configuration . tokenAttributeName ; %NWL%this . identificationAttributeName  = Configuration . identificationAttributeName ; %NWL%7
var proto = new this (  )  ; %NWL%for ( var property in this )  {%NWL%var tmp = this [ property ]  ; %NWL%if ( this [ property ] ! =  = Class . create )  {%NWL%proto [ property ]  = tmp ;%NWL%}%NWL%}%NWL%newClass . prototype = proto ; %NWL%newClass . _super =  {  }  ;  /  / proto ; %NWL%newClass . define = this . define ; %NWL%newClass . extend = this . extend ; %NWL%9
var point =  ( points . length - 1 )  * t ; %NWL%var intPoint = Math . floor ( point )  ; %NWL%var weight = point - intPoint ; %NWL%var point0 = points [ intPoint =  = 0 ? intPoint : intPoint - 1 ]  ; %NWL%var point1 = points [ intPoint ]  ; %NWL%var point2 = points [ intPoint > points . length - 2 ? points . length - 1 : intPoint + 1 ]  ; %NWL%var point3 = points [ intPoint > points . length - 3 ? points . length - 1 : intPoint + 2 ]  ; %NWL%var vector = new THREE . Vector3 (  )  ; %NWL%vector . x = THREE . Curve . Utils . interpolate ( point0 . x , point1 . x , point2 . x , point3 . x , weight )  ; %NWL%vector . y = THREE . Curve . Utils . interpolate ( point0 . y , point1 . y , point2 . y , point3 . y , weight )  ; %NWL%vector . z = THREE . Curve . Utils . interpolate ( point0 . z , point1 . z , point2 . z , point3 . z , weight )  ; %NWL%8
listeners [ key ]  . splice ( index , 1 )  ;%NWL%}%NWL%}%NWL%}%NWL%return this ;%NWL%}  ; %NWL%proto . off = alias (  ' removeListener '  )  ; %NWL%proto . addListeners = function addListeners ( evt , listeners )  {%NWL%return this . manipulateListeners ( false , evt , listeners )  ;%NWL%}  ; %NWL%proto . removeListeners = function removeListeners ( evt , listeners )  {%NWL%7
return packet ;%NWL%}  ; %NWL%Packet . _decodeHeader = function _decodeHeader ( buffer )  {%NWL%var header =  {  }  ; %NWL%header . method  = buffer . readUInt16BE ( 0 ) & Packet . METHOD_MASK ; %NWL%header . length  = buffer . readUInt16BE ( 2 )  ; %NWL%header . magick_key = buffer . readUInt32BE ( 4 )  ; %NWL%header . tid   = buffer . readUInt32BE ( 16 )  ; %NWL%return header ;%NWL%}  ; %NWL%Packet . _decodeAttributes = function _decodeAttributes ( buffer )  {%NWL%2
}  ;%NWL%}  )  (  )  ; %NWL%session . Session = function ( controller , callback )  {%NWL%var self = this%NWL%, cookies = controller . cookies%NWL%, keyName = session . config . sessions . key%NWL%, sid = cookies . get ( keyName )  ; %NWL%this . id = null ; %NWL%this . expiry = null ; %NWL%this . cookies = controller . cookies ; %NWL%this . accessTime = controller . accessTime ; %NWL%9
d3_scale_nice ( domain , d3_scale_linearNice )  ; %NWL%return rescale (  )  ;%NWL%}  ; %NWL%scale . copy = function (  )  {%NWL%return d3_scale_linear ( domain , range , interpolate , clamp )  ;%NWL%}  ; %NWL%return rescale (  )  ;%NWL%}  ; %NWL%function d3_scale_linearRebind ( scale , linear )  {%NWL%scale . range = d3 . rebind ( scale , linear . range )  ; %NWL%scale . rangeRound = d3 . rebind ( scale , linear . rangeRound )  ; %NWL%9
context . lineWidth = 0 . 5 ; %NWL%drawVerticalLine ( x )  ; %NWL%drawHorizontalLine ( y )  ; %NWL%context . restore (  )  ;%NWL%}%NWL%canvas . onmousedown = function ( e )  {%NWL%var loc = windowToCanvas ( e . clientX , e . clientY )  ; %NWL%e . preventDefault (  )  ;  /  / prevent cursor change%NWL%saveDrawingSurface (  )  ; %NWL%mousedown . x = loc . x ; %NWL%mousedown . y = loc . y ; %NWL%9
}%NWL%return range . join (  '  '  )  ;%NWL%}  )  )  ;%NWL%}%NWL%function RegexSyntaxError ( e )  {%NWL%this . name =  " RegexSyntaxError "  ; %NWL%this . type = e . type ; %NWL%this . lastIndex = e . lastIndex ; %NWL%this . lastState = e . lastState ; %NWL%this . astStack = e . astStack ; %NWL%this . message = e . message ; %NWL%6
}  ; %NWL%proto . makeNumberedStepName = function makeNumberedStepName ( index )  {%NWL%var index = index || (  +  + this . stepCount )  ; %NWL%var stepName =  " step "  + index ; %NWL%return stepName ;%NWL%}  ; %NWL%proto . assertPassedFeature = function assertPassedFeature (  )  {%NWL%this . assertNoPartialOutput (  " failed "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertPassedFeatures = function assertPassedFeatures (  )  {%NWL%6
request . matches = matches ; %NWL%fn ( request , a , b )  ; %NWL%return true ;%NWL%}%NWL%return false ;%NWL%}  )  ;%NWL%}  ;%NWL%}  ; %NWL%that . request = router ( methods . request )  ; %NWL%that . upgrade = router ( methods . upgrade )  ; %NWL%that . get = router ( methods . get )  ; %NWL%8
todayText :  ' Today '  ,%NWL%ddCreateEventText :  ' Create event for { 0 }  '  ,%NWL%ddMoveEventText :  ' Move event to { 0 }  '  ,%NWL%dayCount : 1 ,%NWL%initComponent : function (  )  {%NWL%this . dayCount = this . dayCount > 7 ? 7 : this . dayCount ; %NWL%var cfg = Ext . apply (  {  }  , this . initialConfig )  ; %NWL%cfg . showTime = this . showTime ; %NWL%cfg . showTodatText = this . showTodayText ; %NWL%cfg . todayText = this . todayText ; %NWL%cfg . dayCount = this . dayCount ; %NWL%7
exports . number =  " number "%NWL%exports . string =  " string "%NWL%exports . hash =  " hash "%NWL%exports . array =  " array "%NWL%exports . block =  " block "%NWL%exports . expression =  " expression "%NWL%exports . property =  " property "%NWL%exports . index =  " index "%NWL%exports . boolean =  " boolean "%NWL%exports . delegate =  " delegate "%NWL%exports . composite_hash =  " composite_hash "%NWL%0
eventData =  {  }  ,%NWL%conf =  {%NWL%on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%9
var Cfg = require (  "  .  .  /  .  .  / config / mysql "  )  ; %NWL%var MCSkin =  require (  " mcskin "  )  ; %NWL%var close_count = 0 ; %NWL%var pool = poolModule . Pool (  {%NWL%name  :  ' mysql '  ,%NWL%create  : function ( callback )  {%NWL%var Client = require (  ' mysql '  )  . Client ; %NWL%var c = new Client (  )  ; %NWL%c . host = randomChoose ( Cfg . serverlist )  ; %NWL%c . port = Cfg . port ; %NWL%c . user = Cfg . user ; %NWL%9
return descr ;%NWL%}  ,%NWL%file : function ( path )  {%NWL%var descr =  {%NWL%name : null ,%NWL%nativePath : null ,%NWL%extension : null%NWL%}  ; %NWL%var rootFile = Ti . Filesystem . getFile ( path )  ; %NWL%descr . name = rootFile . name ; %NWL%descr . nativePath = rootFile . nativePath ; %NWL%9
var summaries =  [  ]  ; %NWL%for ( var prop in deps . refs )  {%NWL%if ( deps . refs . hasOwnProperty ( prop )  )  {%NWL%var ref = deps . refs [ prop ]  ; %NWL%if ( ref . kind =  =  =  " global "  )  {%NWL%var depPath = ref . path ; %NWL%var summary = retrieveFn ( depPath +  "  - summary "  )  ; %NWL%if ( summary )  {%NWL%summary = JSON . parse ( summary )  ; %NWL%summary . name = ref . name ; %NWL%summary . kind = ref . kind ; %NWL%9
adjustments = adjustments || {  }  ; %NWL%if ( typeof adjustments . opacity =  =  ' undefined '  )  {%NWL%adjustments . opacity = 1 ;%NWL%}%NWL%if ( typeof adjustments . hue ! =  =  ' undefined ' ||%NWL%typeof adjustments . saturation ! =  =  ' undefined ' ||%NWL%typeof adjustments . lightness ! =  =  ' undefined '  )  {%NWL%this . toHSL (  )  ;%NWL%}%NWL%adjustments . hue = 1 * adjustments . hue || 0 ; %NWL%adjustments . saturation = 1 * adjustments . saturation || 0 ; %NWL%9
}%NWL%}  ,%NWL%toString : function (  )  {%NWL%return "  [ iCalendar . Component ;  "  + this . name +  "  ,  "  + this . properties . length +%NWL%" properties ,  "  + this . components . length +  " components ]  "  ;%NWL%}%NWL%}  )  ; %NWL%dojo . cal . iCalendar . Property = function ( prop )  {%NWL%this . name = prop . name ; %NWL%this . group = prop . group ; %NWL%this . params = prop . params ; %NWL%8
}%NWL%if ( user . timezone )  {%NWL%userItems . timezone = user . timezone ;%NWL%} else {%NWL%userItems . timezone =  '  '  ;%NWL%}%NWL%if ( user . description )  {%NWL%try {%NWL%userItems . description = markdownToEntities . stringify ( user . description )  ;%NWL%} catch ( e )  {%NWL%userItems . description = user . description ; %NWL%2
if ( autos . width && autos . height )  {%NWL%data . shadowElem . css ( ret )  ; %NWL%ret . height = data . shadowElem . width (  )  / ratio ; %NWL%ret . width = ret . height * ratio ; %NWL%data . shadowElem . css ( ret )  ; %NWL%ret . width = data . shadowElem . height (  )  * ratio ; %NWL%ret . height = ret . width / ratio ;%NWL%}%NWL%if ( !Modernizr . video )  {%NWL%ret . width = data . shadowElem . width (  )  ; %NWL%ret . height = data . shadowElem . height (  )  ; %NWL%9
actual = testshared . hasOwnProperty (  ' name '  )  ; %NWL%reportCompare ( expect , actual , summary +  '  : name no longer shared '  )  ; %NWL%expect = true ; %NWL%actual = testshared . hasOwnProperty (  ' length '  )  ; %NWL%reportCompare ( expect , actual , summary +  '  : length still shared '  )  ; %NWL%printStatus (  ' test overrides '  )  ; %NWL%function Parent (  )%NWL%{%NWL%this . arguments =  ' oarguments '  ; %NWL%this . caller =  ' ocaller '  ; %NWL%this . arity =  ' oarity '  ; %NWL%8
}  ; %NWL%var pSlice = Array . prototype . slice ; %NWL%var assert = ok ; %NWL%global [  ' assert '  ]  = assert ; %NWL%if ( typeof module =  =  =  ' object ' && typeof module . exports =  =  =  ' object '  )  {%NWL%module . exports = assert ;%NWL%}  ; %NWL%assert . AssertionError = function AssertionError ( options )  {%NWL%this . name =  ' AssertionError '  ; %NWL%this . message = options . message ; %NWL%this . actual = options . actual ; %NWL%9
bottom : bottom ,%NWL%down : bottom%NWL%}  ; %NWL%direction = direction . toLowerCase (  )  ; %NWL%me . moveTo ( hash [ direction ]  [ 0 ]  , hash [ direction ]  [ 1 ]  , animate )  ;%NWL%}  ,%NWL%setLeftTop : function ( left , top )  {%NWL%var me = this ,%NWL%style = me . dom . style ; %NWL%style . left = me . addUnits ( left )  ; %NWL%style . top = me . addUnits ( top )  ; %NWL%9
position . left -  = elemWidth ;%NWL%} else if ( options . my [ 0 ]  =  =  = center )  {%NWL%position . left -  = elemWidth / 2 ;%NWL%}%NWL%if ( options . my [ 1 ]  =  =  =  " bottom "  )  {%NWL%position . top -  = elemHeight ;%NWL%} else if ( options . my [ 1 ]  =  =  = center )  {%NWL%position . top -  = elemHeight / 2 ;%NWL%}%NWL%position . left = parseInt ( position . left )  ; %NWL%position . top = parseInt ( position . top )  ; %NWL%9
result . outlineWidth = this . outlineWidth ; %NWL%result . closeTop = this . closeTop ; %NWL%result . closeBottom = this . closeBottom ; %NWL%return result ;%NWL%}  ; %NWL%RectangleGraphics . prototype . merge = function ( source )  {%NWL%if ( !defined ( source )  )  {%NWL%throw new DeveloperError (  ' source is required .  '  )  ;%NWL%}%NWL%this . show = defaultValue ( this . show , source . show )  ; %NWL%this . coordinates = defaultValue ( this . coordinates , source . coordinates )  ; %NWL%9
this . uuid = window . DroidGap . getUuid (  )  ; %NWL%this . version = window . DroidGap . getOSVersion (  )  ; %NWL%this . gapVersion = window . DroidGap . getVersion (  )  ; %NWL%this . platform = window . DroidGap . getPlatform (  )  ; %NWL%this . name = window . DroidGap . getProductName (  )  ;%NWL%} else {%NWL%this . platform = DeviceInfo . platform ; %NWL%this . version  = DeviceInfo . version ; %NWL%this . name  = DeviceInfo . name ; %NWL%this . gap   = DeviceInfo . gap ; %NWL%this . uuid  = DeviceInfo . uuid ; %NWL%6
}%NWL%for ( j = 0 , jmax = adviceCollection . length ; j < jmax ; j +  = 1 )  {%NWL%target = adviceFactory ( adviceCollection [ j ]  )  ( target )  ;%NWL%}%NWL%}%NWL%return this ;%NWL%}  ;%NWL%}%NWL%proceedingJoinPoint . advice = adviceMetaFactory ( precompiledFactory )  ; %NWL%proceedingJoinPoint . around = adviceMetaFactory ( aroundFactory )  ; %NWL%proceedingJoinPoint . before = adviceMetaFactory ( beforeFactory )  ; %NWL%9
{%NWL%var items = this . _items ;%NWL%}%NWL%var iqresult = this . _buildIQResult ( stanza , query_attrs )  ; %NWL%for ( var i = 0 ; i < items . length ; i +  +  )%NWL%{%NWL%var attrs =  { jid :  items [ i ]  . jid }  ; %NWL%if ( items [ i ]  . name )%NWL%attrs . name = items [ i ]  . name ; %NWL%if ( items [ i ]  . node )%NWL%attrs . node = items [ i ]  . node ; %NWL%8
el . style . webkitTransform = snabbtjs . mat_to_css ( matrix )  ; %NWL%el . style . transform = snabbtjs . mat_to_css ( matrix )  ;%NWL%}%NWL%}  ;%NWL%; snabbtjs . State = function ( config )  {%NWL%this . ax = snabbtjs . option_or_default ( config . ax , 0 )  ; %NWL%this . ay = snabbtjs . option_or_default ( config . ay , 0 )  ; %NWL%this . az = snabbtjs . option_or_default ( config . az , 0 )  ; %NWL%this . x = snabbtjs . option_or_default ( config . x , 0 )  ; %NWL%this . y = snabbtjs . option_or_default ( config . y , 0 )  ; %NWL%this . z = snabbtjs . option_or_default ( config . z , 0 )  ; %NWL%5
value :  ' @ '  ,%NWL%id :  ' @ '  ,%NWL%name :  ' @ '  ,%NWL%text :  ' @ '  ,%NWL%checked :  '  =  '%NWL%}  ,%NWL%link : function ( $scope , element , attrs )  {%NWL%$scope . value = attrs . value ; %NWL%$scope . id = attrs . id ; %NWL%$scope . text = attrs . text ; %NWL%$scope . name = attrs . name ; %NWL%7
result . az = start . az + tween_value * daz ; %NWL%result . x = start . x + tween_value * dx ; %NWL%result . y = start . y + tween_value * dy ; %NWL%result . z = start . z + tween_value * dz ; %NWL%result . bx = start . bx + tween_value * dbx ; %NWL%result . by = start . by + tween_value * dby ; %NWL%result . bz = start . bz + tween_value * dbz ; %NWL%result . skew_x = start . skew_x + tween_value * dskewx ; %NWL%result . skew_y = start . skew_y + tween_value * dskewy ; %NWL%result . sx = start . sx + tween_value * dsx ; %NWL%result . sy = start . sy + tween_value * dsy ; %NWL%0
var programEvents = require (  ' ungit - program - events '  )  ; %NWL%var md5 = require (  ' blueimp - md5 '  )  . md5 ; %NWL%var moment = require (  ' moment '  )  ; %NWL%components . register (  ' commit '  , function ( args )  {%NWL%return new CommitViewModel ( args )  ;%NWL%}  )  ; %NWL%function CommitViewModel ( args )  {%NWL%var self = this ; %NWL%this . repoPath = args . repoPath ; %NWL%this . sha1 = args . sha1 ; %NWL%this . server = args . server ; %NWL%8
Socky . AUTHENTICATING = 1 ; %NWL%Socky . OPEN = 2 ; %NWL%Socky . CLOSED = 3 ; %NWL%Socky . UNAUTHENTICATED = 4 ; %NWL%Socky . prototype . connect = function (  )  {%NWL%var instance = this ; %NWL%instance . state = Socky . CONNECTING ; %NWL%var ws = new WebSocket ( this . host +  '  :  '  + this . port +  '  / ? '  + this . params )  ; %NWL%ws . onopen  = function (  )   { instance . onopen (  )  ;  }  ; %NWL%ws . onmessage = function ( evt )  { instance . onmessage ( evt )  ;  }  ; %NWL%ws . onclose  = function (  )   { instance . onclose (  )  ;  }  ; %NWL%8
DataSourceCacheExtension . prototype =  {%NWL%initializer : function ( config )  {%NWL%this . doBefore (  " _defRequestFn "  , this . _beforeDefRequestFn )  ; %NWL%this . doBefore (  " _defResponseFn "  , this . _beforeDefResponseFn )  ;%NWL%}  ,%NWL%_beforeDefRequestFn : function ( e )  {%NWL%var entry =  ( this . retrieve ( e . request )  ) || null ,%NWL%payload = e . details [ 0 ]  ; %NWL%if ( entry && entry . response )  {%NWL%payload . cached  = entry . cached ; %NWL%payload . response = entry . response ; %NWL%9
this . idPool_ . releaseObject ( startEvent . id )  ; %NWL%this . eventPool_ . releaseObject (  ( startEvent )  )  ; %NWL%break ;%NWL%}%NWL%}%NWL%} else {%NWL%stopEvent =  (%NWL%this . eventPool_ . getObject (  )  )  ; %NWL%stopEvent . eventType = goog . debug . Trace_ . EventType . STOP ; %NWL%stopEvent . startTime = startEvent . startTime ; %NWL%stopEvent . comment = startEvent . comment ; %NWL%9
$scope . fullName =  ' Rahul Doshi '  ; %NWL%$scope . setLocale = function ( loc )  {%NWL%locale . setLocale ( loc )  ;%NWL%}  ; %NWL%locale . ready (  ' common '  )  . then ( function (  )  {%NWL%$scope . flagClass = $scope . localeData [ locale . getLocale (  )  ]  . flagClass ; %NWL%$scope . langDisplayText = $scope . localeData [ locale . getLocale (  )  ]  . langDisplayText ;%NWL%}  )  ; %NWL%$scope . $on ( localeEvents . localeChanges , function ( event , data )  {%NWL%$scope . flagClass = $scope . localeData [ data ]  . flagClass ; %NWL%$scope . langDisplayText = $scope . localeData [ data ]  . langDisplayText ; %NWL%9
return - Math . log ( this . es [ y ]  )  ;%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%7
this . touchStartX = 0 ; %NWL%this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchMove = function (  )  { FastClick . prototype . onTouchMove . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchEnd = function (  )  { FastClick . prototype . onTouchEnd . apply ( self , arguments )  ;  }  ; %NWL%7
x : undefined ,%NWL%y : undefined%NWL%}  ; %NWL%var lowerRight =  {%NWL%x : undefined ,%NWL%y : undefined%NWL%}  ; %NWL%var me = this ; %NWL%this . _svgShapes . each ( function ( svgShape )  {%NWL%upperLeft . x =  ( upperLeft . x ! =  = undefined ) ? Math . min ( upperLeft . x , svgShape . x )  : svgShape . x ; %NWL%upperLeft . y =  ( upperLeft . y ! =  = undefined ) ? Math . min ( upperLeft . y , svgShape . y )  : svgShape . y ; %NWL%9
this . angularAcceleration = other . angularAcceleration ; %NWL%this . angularAccelerationSpread = other . angularAccelerationSpread ; %NWL%this . randomAngle = other . randomAngle ; %NWL%this . emissionRate = other . emissionRate ; %NWL%this . color . copy ( other . color )  ; %NWL%this . colorSpread . copy ( other . colorSpread )  ; %NWL%this . time = other . time ; %NWL%this . _time = other . _time ; %NWL%this . duration = other . duration ; %NWL%this . loop = other . loop ; %NWL%this . playing = other . playing ; %NWL%0
if (  (  ( scale >  - cc . math . EPSILON ) && scale < cc . math . EPSILON )%NWL%|| ( scale < 2 * Math . PI + cc . math . EPSILON && scale > 2 * Math . PI - cc . math . EPSILON )  )  {    /  / angle is 0 or 360 so just simply set axis to 0 , 0 , 1 with angle 0%NWL%retAngle = 0 . 0 ; %NWL%retAxis . x = 0 . 0 ; %NWL%retAxis . y = 0 . 0 ; %NWL%retAxis . z = 1 . 0 ;%NWL%} else {%NWL%retAngle = tempAngle * 2 . 0 ;    /  / angle in radians%NWL%retAxis . x = this . x / scale ; %NWL%retAxis . y = this . y / scale ; %NWL%retAxis . z = this . z / scale ; %NWL%8
for ( var i = 0 , ii = valuesy . length ; i < ii ; i +  +  )  {%NWL%for ( var j = 0 , jj = valuesy [ i ]  . length ; j < jj ; j +  +  )  {%NWL%var X = x + gutter +  (  ( valuesx [ i ] || valuesx [ 0 ]  )  [ j ]  - minx )  * kx ,%NWL%nearX = x + gutter +  (  ( valuesx [ i ] || valuesx [ 0 ]  )  [ j ? j - 1 : 1 ]  - minx )  * kx ,%NWL%Y = y + height - gutter -  ( valuesy [ i ]  [ j ]  - miny )  * ky ; %NWL%f ? ( C =  {  }  )  : cvrs . push ( C = paper . circle ( X , Y , Math . abs ( nearX - X )  / 2 )  . attr (  { stroke :  " #000 "  , fill :  " #000 "  , opacity : 1 }  )  )  ; %NWL%C . x = X ; %NWL%C . y = Y ; %NWL%C . value = valuesy [ i ]  [ j ]  ; %NWL%C . line = chart . lines [ i ]  ; %NWL%C . shade = chart . shades [ i ]  ; %NWL%9
options [ i ]  = this . agentOptions [ i ]%NWL%}%NWL%}%NWL%if ( this . ca ) options . ca = this . ca%NWL%var poolKey =  '  '%NWL%if ( Agent ! =  = this . httpModule . Agent )  {%NWL%poolKey +  = Agent . name%NWL%}%NWL%if ( !this . httpModule . globalAgent )  {%NWL%options . host = this . host%NWL%options . port = this . port%NWL%9
_lineCount +  +  ;%NWL%}%NWL%}%NWL%} else if ( object instanceof THREE . Particle )  {%NWL%_vector4 . set ( object . position . x , object . position . y , object . position . z , 1 )  ; %NWL%_projScreenMatrix . multiplyVector4 ( _vector4 )  ; %NWL%_vector4 . z /  = _vector4 . w ; %NWL%if ( _vector4 . z > 0 && _vector4 . z < 1 )  {%NWL%_particle = _particlePool [ _particleCount ]  = _particlePool [ _particleCount ] || new THREE . RenderableParticle (  )  ; %NWL%_particle . x = _vector4 . x / _vector4 . w ; %NWL%_particle . y = _vector4 . y / _vector4 . w ; %NWL%9
}%NWL%var sinces = this . comment . getTag (  " since "  )  ; %NWL%if ( sinces . length )  {%NWL%this . since = sinces . map ( function ( $ )  { return $ . desc ;  }  )  . join (  "  ,  "  )  ;%NWL%}%NWL%if ( this . comment . getTag (  " constant "  )  . length )  {%NWL%this . isConstant = true ;%NWL%}%NWL%var versions = this . comment . getTag (  " version "  )  ; %NWL%if ( versions . length )  {%NWL%this . version = versions . map ( function ( $ )  { return $ . desc ;  }  )  . join (  "  ,  "  )  ; %NWL%3
}%NWL%var ret = fcn . apply ( this , arguments )  ; %NWL%for ( var i = 0 ; i < after . length ; i +  +  )  {%NWL%after [ i ]  . call ( this , fullName , fcn , type , arguments , ret )  ;%NWL%}%NWL%return ret ;%NWL%}%NWL%if ( type ! =  =  " static "  )%NWL%{%NWL%wrapper . self = fcn . self ; %NWL%wrapper . base = fcn . base ; %NWL%9
}  ; %NWL%function destroyTextures ( oit )  {%NWL%oit . _opaqueTexture = oit . _opaqueTexture && !oit . _opaqueTexture . isDestroyed (  ) && oit . _opaqueTexture . destroy (  )  ; %NWL%oit . _accumulationTexture = oit . _accumulationTexture && !oit . _accumulationTexture . isDestroyed (  ) && oit . _accumulationTexture . destroy (  )  ; %NWL%oit . _revealageTexture = oit . _revealageTexture && !oit . _revealageTexture . isDestroyed (  ) && oit . _revealageTexture . destroy (  )  ; %NWL%oit . _depthTexture = oit . _depthTexture && !oit . _depthTexture . isDestroyed (  ) && oit . _depthTexture . destroy (  )  ;%NWL%}%NWL%function destroyFramebuffers ( oit )  {%NWL%oit . _opaqueFBO = oit . _opaqueFBO && !oit . _opaqueFBO . isDestroyed (  ) && oit . _opaqueFBO . destroy (  )  ; %NWL%oit . _translucentFBO = oit . _translucentFBO && !oit . _translucentFBO . isDestroyed (  ) && oit . _translucentFBO . destroy (  )  ; %NWL%oit . _alphaFBO = oit . _alphaFBO && !oit . _alphaFBO . isDestroyed (  ) && oit . _alphaFBO . destroy (  )  ; %NWL%2
, socketOptions :  {%NWL%connectTimeoutMS : 30000%NWL%, socketTimeoutMS : 30000%NWL%}%NWL%, auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%6
mapping . source = original . source ; %NWL%if ( aSourceMapPath ! = null )  {%NWL%mapping . source = util . join ( aSourceMapPath , mapping . source )  ;%NWL%}%NWL%if ( sourceRoot ! = null )  {%NWL%mapping . source = util . relative ( sourceRoot , mapping . source )  ;%NWL%}%NWL%mapping . originalLine = original . line ; %NWL%mapping . originalColumn = original . column ; %NWL%if ( original . name ! = null )  {%NWL%mapping . name = original . name ; %NWL%0
this . add ( loginButton )  ; %NWL%this . loadForm (  )  ;%NWL%}  ,%NWL%loadForm : function (  )  {%NWL%var url_preference = Ext . Registry . getString (  ' url_preference '  )  ; %NWL%if ( Ext . isDefined ( url_preference ) && url_preference ! = null )  {%NWL%this . url . value = url_preference ;%NWL%}%NWL%var username_preference = Ext . Registry . getString (  ' username_preference '  )  ; %NWL%if ( Ext . isDefined ( username_preference ) && username_preference ! = null )  {%NWL%this . username . value = username_preference ; %NWL%6
this . updateCallbacks . push ( callback )  ;%NWL%}  ; %NWL%this . onConfigure = function ( callback )  {%NWL%this . configureCallbacks . push ( callback )  ;%NWL%}  ; %NWL%this . registerRenderer = function ( renderer )  {%NWL%this . _renderers = this . _renderers || {  }  ; %NWL%this . _renderers [ renderer . name ]  = renderer ;%NWL%}  ; %NWL%this . configure = function ( args )  {%NWL%this . config = this . config || {  }  ; %NWL%6
this . missing_value = obj . missing_value ; %NWL%this . nonadditive = obj . nonadditive ; %NWL%if ( obj . aggregates )  {%NWL%this . aggregates = obj . aggregates ;%NWL%}%NWL%}  ; %NWL%cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%0
return this ;%NWL%}  ,%NWL%copyFrom : function ( source )  {%NWL%this . setTo ( source . x , source . y , source . z , source . widthX , source . widthY , source . height )  ;%NWL%}  ,%NWL%copyTo : function ( dest )  {%NWL%dest . x = this . x ; %NWL%dest . y = this . y ; %NWL%dest . z = this . z ; %NWL%dest . widthX = this . widthX ; %NWL%dest . widthY = this . widthY ; %NWL%6
}  ,%NWL%onMetaChange : function ( meta )  {%NWL%var me = this ,%NWL%fields = meta . fields || me . getFields (  )  ,%NWL%newModel ,%NWL%clientIdProperty ; %NWL%me . metaData = meta ; %NWL%me . root = meta . root || me . root ; %NWL%me . idProperty = meta . idProperty || me . idProperty ; %NWL%me . totalProperty = meta . totalProperty || me . totalProperty ; %NWL%me . successProperty = meta . successProperty || me . successProperty ; %NWL%7
_yuitest_coverfunc (  " build / graphics - vml - default / graphics - vml - default . js "  ,  "  ( anonymous 1 )  "  , 1 )  ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 3 )  ; %NWL%Y . Graphic = Y . VMLGraphic ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 4 )  ; %NWL%Y . Shape = Y . VMLShape ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 5 )  ; %NWL%Y . Circle = Y . VMLCircle ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 6 )  ; %NWL%Y . Rect = Y . VMLRect ; %NWL%_yuitest_coverline (  " build / graphics - vml - default / graphics - vml - default . js "  , 7 )  ; %NWL%Y . Ellipse = Y . VMLEllipse ; %NWL%2
json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%json . group_size = this . group_size ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%this . out_sy = json . out_sy ; %NWL%8
}  ; %NWL%var QueueService = require (  '  .  / queue / queueservice '  )  ; %NWL%exports . QueueService = QueueService ; %NWL%exports . createQueueService = function ( storageAccountOrConnectionString , storageAccessKey , host , authenticationProvider )  {%NWL%return new QueueService ( storageAccountOrConnectionString , storageAccessKey , host , authenticationProvider )  ;%NWL%}  ; %NWL%exports . date = common . date ; %NWL%exports . Constants =  {%NWL%BlobConstants : common . Constants . BlobConstants%NWL%}  ; %NWL%exports . StorageServiceSettings = common . StorageServiceSettings ; %NWL%6
" dijit / a11y "  ,%NWL%" dijit / focus "  ,%NWL%"  .  .  / _FocusManager "%NWL%]  , function ( dojo , lang , declare , array , connect , event , has , html , keys , dijitA11y , dijitFocus , _FocusManager )  {%NWL%var _FocusArea = declare (  " dojox . grid . enhanced . _FocusArea "  , null ,  {%NWL%constructor : function ( area , focusManager )  {%NWL%this . _fm = focusManager ; %NWL%this . _evtStack =  [ area . name ]  ; %NWL%var dummy = function (  )  { return true ;  }  ; %NWL%area . onFocus = area . onFocus || dummy ; %NWL%area . onBlur = area . onBlur || dummy ; %NWL%9
}%NWL%o . name = o . name || props . name || props . tileprops . name || '  '  ; %NWL%o . type = o . type || props . type || props . tileprops . type || '  '  ; %NWL%if ( typeof props . texture =  =  =  ' string '  )  {%NWL%props . texture = PIXI . TextureCache [ props . texture ]  ;%NWL%}%NWL%if ( !props . texture )  {%NWL%obj = this . game . add . group ( this . container , o . name )  ; %NWL%obj . width = o . width ; %NWL%obj . height = o . height ; %NWL%obj . rotation = o . rotation ; %NWL%8
service . getParent = function getParent ( target )  {%NWL%var path = target . path . slice ( 0 , target . path . lastIndexOf (  '  /  '  )  )  ; %NWL%if ( path . length =  =  = 0 )  {%NWL%path =  '  /  '  ;%NWL%}%NWL%return service . getByPath ( path )  ;%NWL%}  ; %NWL%service . canExport = function canExport (  )  {%NWL%return fileSystem . hasOwnProperty (  ' exportFiles '  )  ;%NWL%}  ; %NWL%service . exportFiles = function exportFiles (  )  {%NWL%7
UIFanMenu . prototype . restoreState = function (  )  {%NWL%if ( this . save )  {%NWL%this . x = this . save . x ; %NWL%this . y = this . save . y ; %NWL%this . w = this . save . w ; %NWL%this . h = this . save . h ; %NWL%for ( var i = 0 ; i < this . children . length ; i +  +  )  {%NWL%var iter = this . children [ i ]  ; %NWL%if ( iter . save )  {%NWL%iter . x = iter . save . x ; %NWL%iter . y = iter . save . y ; %NWL%9
this . idCount = ID_COUNT +  +  ; %NWL%this . _parent = options . parent ; %NWL%this . _metadata = options . metadata ; %NWL%this . menuBar = options . menuBar ; %NWL%this . fileClient = options . fileService ; %NWL%this . progress = options . progressService ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . commandRegistry = options . commandRegistry ; %NWL%this . contentTypeRegistry = options . contentTypeRegistry ; %NWL%this . editorInputManager = options . inputManager ; %NWL%this . preferences = options . preferences ; %NWL%3
function initWidgets ( collection )  {%NWL%collection . each ( function (  )  {%NWL%kendo . initWidget ( $ ( this )  ,  {  }  , ui . roles )  ;%NWL%}  )  ;%NWL%}%NWL%var Layout = Widget . extend (  {%NWL%init : function ( element , options )  {%NWL%Widget . fn . init . call ( this , element , options )  ; %NWL%element = this . element ; %NWL%this . header = element . children ( this . _locate (  " header "  )  )  . addClass (  " km - header "  )  ; %NWL%this . footer = element . children ( this . _locate (  " footer "  )  )  . addClass (  " km - footer "  )  ; %NWL%9
var plan =  {  }  ; %NWL%plan . tasks =  [  ]  ; %NWL%plan . workers =  [  ]  ; %NWL%plan . statuses =  [  ' todo '  ,  ' inprogress '  ,  ' done '  ]  ; %NWL%var Task = function ( task_name , task_id )  {%NWL%var that =  {  }  ; %NWL%that . name = task_name ; %NWL%if ( typeof task_id =  =  =  ' undefined '  )  {%NWL%that . id = guidGenerator (  )  ;%NWL%} else {%NWL%that . id = task_id ; %NWL%6
onSuccess : null ,%NWL%onFailure : null%NWL%}  , opts )  ; %NWL%var data =  {%NWL%event_id : opts . talk_id ,%NWL%comment : opts . comment%NWL%}  ; %NWL%if ( opts . rating )%NWL%data . rating = opts . rating ; %NWL%if ( opts . private )%NWL%data . private = opts . private ; %NWL%8
}%NWL%if ( typeof json . clickEvent =  =  =  ' object '  )  {%NWL%this . clickEvent = json . clickEvent ; %NWL%if ( typeof this . clickEvent . action ! =  =  ' string '  )  {%NWL%throw new Error (  ' ClickEvent action missing in ChatMessage '  )  ;%NWL%} else if ( Array . prototype . indexOf && supportedClick . indexOf ( this . clickEvent . action )  =  =  =  - 1 )  {%NWL%console . warn (  ' ChatMessage parsed with unsupported clickEvent '  , this . clickEvent . action )  ;%NWL%}%NWL%}%NWL%if ( typeof json . hoverEvent =  =  =  ' object '  )  {%NWL%this . hoverEvent = json . hoverEvent ; %NWL%2
json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%json . colorSpread = this . colorSpread . toJSON ( json . colorSpread )  ; %NWL%json . time = this . time ; %NWL%json . _time = this . _time ; %NWL%json . duration = this . duration ; %NWL%json . loop = this . loop ; %NWL%json . playing = this . playing ; %NWL%0
}  ; %NWL%function HostbasedAuthContext ( stream , username , service , method , pkInfo , cb )  {%NWL%AuthContext . call ( this , stream , username , service , method , cb )  ; %NWL%this . key =  { algo : pkInfo . keyAlgo , data : pkInfo . key }  ; %NWL%this . signature = pkInfo . signature ; %NWL%if ( this . signature )%NWL%this . sigAlgo =  ( pkInfo . keyAlgo =  =  =  ' ssh - rsa ' ? ' RSA - SHA1 '  :  ' DSA - SHA1 '  )  ; %NWL%else%NWL%this . sigAlgo = undefined ; %NWL%this . blob = pkInfo . blob ; %NWL%this . localHostname = pkInfo . localHostname ; %NWL%4
if ( data . date [ i ]  . slug ! = null && data . date [ i ]  . slug ! =  "  "  )  {%NWL%_date . needs_slug = true ;%NWL%}%NWL%}%NWL%_date . title				 = data . date [ i ]  . headline ; %NWL%_date . headline			 = data . date [ i ]  . headline ; %NWL%_date . type				 = data . date [ i ]  . type ; %NWL%_date . date				 = VMM . Date . prettyDate ( _date . startdate , false , _date . precisiondate )  ; %NWL%_date . asset				 = data . date [ i ]  . asset ; %NWL%_date . fulldate			 = _date . startdate . getTime (  )  ; %NWL%_date . text				 = data . date [ i ]  . text ; %NWL%5
var item = this . members [ prop ]  ; %NWL%var membersArr = item . toExportArray (  )  ;  /  / #recursive%NWL%var arrItem =  { name : item . name }  ; %NWL%if ( membersArr . length )  {%NWL%arrItem . members = membersArr ;%NWL%}  ; %NWL%if ( item . hasOwnProperty (  ' type '  ) && item . type )  {%NWL%arrItem . type = item . type . toString (  )  ;%NWL%}  ; %NWL%if ( item . hasOwnProperty (  ' itemType '  ) && item . itemType )  {%NWL%arrItem . itemType = item . itemType . toString (  )  ; %NWL%7
facade [ p ]  = payload [ p ]  ;%NWL%}%NWL%}%NWL%}  ; %NWL%Y . EventFacade = function ( e , currentTarget )  {%NWL%if ( !e )  {%NWL%e = EMPTY ;%NWL%}%NWL%this . _event = e ; %NWL%this . details = e . details ; %NWL%this . type = e . type ; %NWL%9
if ( c1 =  =  =  ' \n ' || c1 =  =  =  ' \r '  )  {%NWL%self . error (  ' new line is forbidden in single line string .  '  )  ;%NWL%} else if ( !c1 )  {%NWL%self . error (  ' unexpect end of input , string is not closed '  )  ;%NWL%} else {%NWL%cur +  = 2 ; %NWL%row +  = 2 ;%NWL%}%NWL%} else if ( c =  =  = quote )  {%NWL%self . cur = cur + 1 ; %NWL%self . row = row + 1 ; %NWL%9
return paymentMethod ;%NWL%}  ,%NWL%transform : function ( jsonResult )  {%NWL%var paymentMethods =  [  ]  ; %NWL%if ( angular . isArray ( jsonResult )  )  {%NWL%for ( var i = 0 ; i < jsonResult . length ; i +  +  )  {%NWL%var paymentMethod = genericModelBuilder . transform ( jsonResult [ i ]  , Constructor )  ; %NWL%paymentMethod . dialogEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . dialogEditorView )  ; %NWL%paymentMethod . authorizeCapturePaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . authorizeCapturePaymentEditorView )  ; %NWL%paymentMethod . voidPaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . voidPaymentEditorView )  ; %NWL%paymentMethod . refundPaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . refundPaymentEditorView )  ; %NWL%8
} else {%NWL%var split = url . split (  ' ? '  )  ; %NWL%this . url = split [ 0 ]  ; %NWL%this . query = split . length > 1 ? normalizeQuery ( split [ 1 ]  )  : undefined ;%NWL%}%NWL%this . data = normalizeQuery ( stubData )  ; %NWL%this . method = method ; %NWL%this . andReturn = function ( options )  {%NWL%this . status = options . status || 200 ; %NWL%this . contentType = options . contentType ; %NWL%this . response = options . response ; %NWL%9
field . id = json . props . id ; %NWL%field . name = json . props . name ; %NWL%label . appendChild ( field )  ; %NWL%node . appendChild ( label )  ; %NWL%break ; %NWL%case " Text "  :  /  / $NON - NLS - 0$%NWL%label = document . createElement (  " label "  )  ;  /  / $NON - NLS - 0$%NWL%label . appendChild ( document . createTextNode ( json . label || "  "  )  )  ; %NWL%field = document . createElement (  " span "  )  ;  /  / $NON - NLS - 0$%NWL%field . className =  " userprofile userInput "  ;  /  / $NON - NLS - 0$%NWL%field . id = json . props . id ; %NWL%1
}  ; %NWL%goog . fx . Animation . prototype . dispatchAnimationEvent = function ( type )  {%NWL%this . dispatchEvent ( new goog . fx . AnimationEvent ( type , this )  )  ;%NWL%}  ; %NWL%goog . fx . AnimationEvent = function ( type , anim )  {%NWL%goog . fx . AnimationEvent . base ( this ,  ' constructor '  , type )  ; %NWL%this . coords = anim . coords ; %NWL%this . x = anim . coords [ 0 ]  ; %NWL%this . y = anim . coords [ 1 ]  ; %NWL%this . z = anim . coords [ 2 ]  ; %NWL%this . duration = anim . duration ; %NWL%6
if ( me . matchManagerID =  =  = args [ 0 ]  )  {%NWL%sourceListener ( me , args [ 1 ]  )  ;%NWL%}%NWL%}  )  ; %NWL%this . onMatchPlayerAdditionSucceeded = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onMatchPlayerAdditionSucceeded "  , function ( sourceListener , args )%NWL%{%NWL%if ( me . matchManagerID =  =  = args [ 0 ]  )  {%NWL%sourceListener ( me , args [ 1 ]  )  ;%NWL%}%NWL%}  )  ; %NWL%this . onMatchPlayerAdditionFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onMatchPlayerAdditionFailed "  , function ( sourceListener , args )%NWL%4
width = arguments [ 2 ]  ; %NWL%height = arguments [ 3 ]  ;%NWL%} else {%NWL%throw new Error (  ' not a valid rectangle specification '  )  ;%NWL%}%NWL%return { left : left || 0 , top : top || 0 , width : width || 0 , height : height || 0 }  ;%NWL%}  ; %NWL%var Rect = exports . Rect = function (  )  {%NWL%var args = normalizeRectArguments . apply ( this , arguments )  ; %NWL%this . left = args . left ; %NWL%this . top = args . top ; %NWL%9
var Map = new Class (  {  /  / Defines map - rendering logic%NWL%constructor : function (  )  {%NWL%var _this = this%NWL%this . x = 0%NWL%this . y = 0%NWL%this . layer = new lime . Layer (  )%NWL%this . background = new lime . Layer (  )%NWL%this . foreground = new lime . Layer (  )%NWL%var tmx = new lime . parser . TMX (  ' assets / display / maps / desert / desert . tmx '  )%NWL%this . width = tmx . width * tmx . tilewidth%NWL%this . height = tmx . height * tmx . tileheight%NWL%9
$scope . mode =  ' error '  ; %NWL%var notification = res . result =  =  =  ' tejMaxFeeExceeded ' ? ' max_fee '  :  ' error '  ; %NWL%$scope . load_notification ( notification )  ; %NWL%$scope . trust . loading = false ; %NWL%$scope . editing = false ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%function setEngineStatus ( res , accepted )  {%NWL%$scope . engine_result = res . engine_result ; %NWL%$scope . engine_result_message = res . engine_result_message ; %NWL%9
Axis . prototype . fromSYNC = function ( json )  {%NWL%this . name = json . name ; %NWL%this . value = json . value ; %NWL%return this ;%NWL%}  ; %NWL%Axis . prototype . toJSON = function ( json )  {%NWL%json || ( json =  {  }  )  ; %NWL%json . name = this . name ; %NWL%json . negButton = this . negButton ; %NWL%json . posButton = this . posButton ; %NWL%json . altNegButton = this . altNegButton ; %NWL%7
tinymce . trim ( c )  ;%NWL%}%NWL%DD = ed . dom . select (  ' dd . wp - caption - dd '  , DL )  ; %NWL%if ( DD && DD [ 0 ]  )%NWL%caption = ed . serializer . serialize ( DD [ 0 ]  )  . replace (  / ^ < p >  /  ,  '  '  )  . replace (  /  < \ / p > $ /  ,  '  '  )  ;%NWL%}%NWL%f . img_cap_text . value = caption ; %NWL%f . img_title . value = ed . dom . getAttrib ( el ,  ' title '  )  ; %NWL%f . img_alt . value = ed . dom . getAttrib ( el ,  ' alt '  )  ; %NWL%f . border . value = ed . dom . getAttrib ( el ,  ' border '  )  ; %NWL%f . vspace . value = ed . dom . getAttrib ( el ,  ' vspace '  )  ; %NWL%9
}%NWL%}  ,%NWL%restoreScrollPositions : function (  )%NWL%{%NWL%var elements = this . elementsToRestoreScrollPositionsFor (  )  ; %NWL%for ( var i = 0 ; i < elements . length ;  +  + i )  {%NWL%var container = elements [ i ]  ; %NWL%if ( container . _scrollTop )%NWL%container . scrollTop = container . _scrollTop ; %NWL%if ( container . _scrollLeft )%NWL%container . scrollLeft = container . _scrollLeft ; %NWL%8
validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . registerHandler '  ; %NWL%wrapped . unregisterHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . unregisterHandler '  ; %NWL%wrapped . send . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . send '  ; %NWL%wrapped . publish . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . publish '  ; %NWL%wrapped . getConnectionState . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . getConnectionState '  ; %NWL%wrapped . isValidSession . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . isValidSession '  ; %NWL%5
} else {%NWL%params . options . _requester = requester%NWL%}%NWL%}%NWL%return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . patch = def ( request . patch )%NWL%9
}%NWL%break ; %NWL%case ' relative '  : %NWL%this . _isRelative = true ; %NWL%if (  ' file ' ! = this . _scheme )%NWL%this . _scheme = base . _scheme ; %NWL%if ( EOF =  = c )  {%NWL%this . _host = base . _host ; %NWL%this . _port = base . _port ; %NWL%this . _path = base . _path . slice (  )  ; %NWL%this . _query = base . _query ; %NWL%5
}  , true )  ; %NWL%function copyEventProps ( evt )  {%NWL%var props = lang . delegate ( evt ,  {%NWL%bubbles : true%NWL%}  )  ; %NWL%if ( has (  " ios "  )  >  = 6 )  {%NWL%props . touches = evt . touches ; %NWL%props . altKey = evt . altKey ; %NWL%props . changedTouches = evt . changedTouches ; %NWL%props . ctrlKey = evt . ctrlKey ; %NWL%props . metaKey = evt . metaKey ; %NWL%6
}%NWL%EC . readHashFromURL = function (  )  {%NWL%var results = new RegExp (  ' # (  [ ^ |^?|^&|^ =  ]  *  )  '  )  . exec ( window . location . href )  ; %NWL%return ( results ) ? ( decodeURIComponent ( results [ 0 ]  )  )  : null ;%NWL%}%NWL%EC . Core = C ; %NWL%EC . Log = Log ; %NWL%EC . debug = Log . debug ; %NWL%EC . info = Log . info ; %NWL%EC . warn = Log . warn ; %NWL%EC . error = Log . error ; %NWL%7
}%NWL%}%NWL%}  ,%NWL%function inheritHeaders ( source )  {%NWL%if ( source instanceof Headers )  {%NWL%if ( !this . names || !this . listHeaders (  )  . length )  {%NWL%this . names = Object . create ( source . names )  ; %NWL%this . headers = Object . create ( source . headers )  ;%NWL%} else {%NWL%this . names . __proto__ = source . names ; %NWL%this . headers . __proto__ = source . headers ; %NWL%9
this . attrs =  [  ]  ; %NWL%this . attributeBlocks =  [  ]  ; %NWL%this . block = block || new Block ;%NWL%}  ; %NWL%Tag . prototype = Object . create ( Attrs . prototype )  ; %NWL%Tag . prototype . constructor = Tag ; %NWL%Tag . prototype . type =  ' Tag '  ; %NWL%Tag . prototype . clone = function (  )  {%NWL%var clone = new Tag ( this . name , this . block . clone (  )  )  ; %NWL%clone . line = this . line ; %NWL%clone . attrs = this . attrs ; %NWL%9
var Ternary = module . exports = function Ternary ( cond , trueExpr , falseExpr )  {%NWL%Node . call ( this )  ; %NWL%this . cond = cond ; %NWL%this . trueExpr = trueExpr ; %NWL%this . falseExpr = falseExpr ;%NWL%}  ; %NWL%Ternary . prototype . __proto__ = Node . prototype ; %NWL%Ternary . prototype . clone = function ( parent )  {%NWL%var clone = new Ternary (  )  ; %NWL%clone . cond = this . cond . clone ( parent , clone )  ; %NWL%clone . trueExpr = this . trueExpr . clone ( parent , clone )  ; %NWL%9
this . degraded = true ;%NWL%}%NWL%}%NWL%}%NWL%if ( typeof cfg . name =  =  =  " object " && cfg . name ! =  = null )  {%NWL%if ( cfg . name . length > 1 )  {%NWL%this . degraded = true ;%NWL%}%NWL%cfg . name = cfg . name [ 0 ]  ;%NWL%}%NWL%if ( typeof cfg . mbox =  =  =  " object " && cfg . mbox ! =  = null )  {%NWL%4
this . name =    _create ( aProp . name ) || null ; %NWL%this . honorificPrefix = _create ( aProp . honorificPrefix ) || null ; %NWL%this . givenName =   _create ( aProp . givenName ) || null ; %NWL%this . additionalName =  _create ( aProp . additionalName ) || null ; %NWL%this . familyName =   _create ( aProp . familyName ) || null ; %NWL%this . honorificSuffix = _create ( aProp . honorificSuffix ) || null ; %NWL%this . nickname =   _create ( aProp . nickname ) || null ; %NWL%this . email =    _create ( aProp . email ) || null ; %NWL%this . photo =    _create ( aProp . photo ) || null ; %NWL%this . url =    _create ( aProp . url ) || null ; %NWL%this . category =   _create ( aProp . category ) || null ; %NWL%6
}  )  ;%NWL%}%NWL%mergedContact . email =  [  ]  ; %NWL%emailsHash =  {  }  ; %NWL%populateEmails ( masterContact . email , emailsHash , mergedContact . email )  ; %NWL%mergedContact . org = masterContact . org || [  ]  ; %NWL%mergedContact . category =  [  ]  ; %NWL%categoriesHash =  {  }  ; %NWL%populateNoDuplicates ( masterContact . category , categoriesHash ,%NWL%mergedContact . category )  ; %NWL%mergedContact . url = masterContact . url || [  ]  ; %NWL%5
var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%json . group_size = this . group_size ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%9
fs . stat = wrap ( fs . stat ,  ' fs . stat '  , 1 )  ; %NWL%fs . link = wrap ( fs . link ,  ' fs . link '  , 2 )  ; %NWL%fs . lstat = wrap ( fs . lstat ,  ' fs . lstat '  , 1 )  ; %NWL%fs . chmod = wrap ( fs . chmod ,  ' fs . chmod '  , 2 )  ; %NWL%fs . chown = wrap ( fs . chown ,  ' fs . chown '  , 3 )  ; %NWL%fs . rename = wrap ( fs . rename ,  ' fs . rename '  , 2 )  ; %NWL%fs . readlink = wrap ( fs . readlink ,  ' fs . readlink '  , 1 )  ; %NWL%fs . readdir = wrap ( fs . readdir ,  ' fs . readdir '  , 1 )  ; %NWL%fs . unlink = wrap ( fs . unlink ,  ' fs . unlink '  , 1 )  ; %NWL%fs . symlink = wrap ( fs . symlink ,  ' fs . symlink '  , 3 )  ; %NWL%fs . utimes = wrap ( fs . utimes ,  ' fs . utimes '  , 3 )  ; %NWL%4
var pic = game . add . sprite ( 0 , 50 ,  ' pic '  )  ; %NWL%pic . scale . set ( 2 )  ; %NWL%bmd = game . add . bitmapData ( game . width , game . height )  ; %NWL%bmd . context . fillStyle =  ' rgba ( 255 , 0 , 0 , 1 )  '  ; %NWL%bmd . addToWorld (  )  ; %NWL%ball = game . add . sprite ( 0 , 0 ,  ' ball '  )  ;%NWL%}%NWL%function update (  )  {%NWL%bmd . context . fillRect ( game . input . x , game . input . y , 8 , 8 )  ; %NWL%ball . x = game . input . x ; %NWL%ball . y = game . input . y ; %NWL%9
var callback , speed = settings . transition =  =  =  " none " ? 0 : settings . speed ; %NWL%$loaded . remove (  )  ; %NWL%$loaded = $div (  ' LoadedContent '  )  . append ( object )  ; %NWL%function getWidth (  )  {%NWL%settings . w = settings . w || $loaded . width (  )  ; %NWL%settings . w = settings . mw && settings . mw < settings . w ? settings . mw : settings . w ; %NWL%return settings . w ;%NWL%}%NWL%function getHeight (  )  {%NWL%settings . h = settings . h || $loaded . height (  )  ; %NWL%settings . h = settings . mh && settings . mh < settings . h ? settings . mh : settings . h ; %NWL%5
scaledRect . y = rect . y ? rect . y : 0 ; %NWL%scaledRect . width = rect . width ? rect . width : 0 ; %NWL%scaledRect . height = rect . height ? rect . height : 0 ; %NWL%if ( ratio )  {%NWL%if (  ( rect . width / rect . height )  > ratio )  {%NWL%scaledRect . height = rect . height ; %NWL%scaledRect . width = Math . floor ( rect . height * ratio )  ;%NWL%}%NWL%else {%NWL%scaledRect . height = Math . floor ( rect . width / ratio )  ; %NWL%scaledRect . width = rect . width ; %NWL%5
scope :  {%NWL%model :  '  = model '%NWL%}  ,%NWL%controller : function ( $scope )  {%NWL%$scope . content =  [  ]  ; %NWL%$scope . theid = Math . random (  )  . toString ( 36 )  . substring ( 7 )  ; %NWL%$scope . wrapCol = function ( r )  {%NWL%var ret =  {  }  ; %NWL%ret . payload =  [  ]  ; %NWL%ret . theclass = r . theclass ; %NWL%ret . thestyle = r . thestyle ; %NWL%9
if ( event . altKey || event . shiftKey )  {%NWL%return ;%NWL%}%NWL%g . resetZoom (  )  ;%NWL%}%NWL%}  ; %NWL%Dygraph . DEFAULT_ATTRS . interactionModel = Dygraph . Interaction . defaultModel ; %NWL%Dygraph . defaultInteractionModel = Dygraph . Interaction . defaultModel ; %NWL%Dygraph . endZoom = Dygraph . Interaction . endZoom ; %NWL%Dygraph . moveZoom = Dygraph . Interaction . moveZoom ; %NWL%Dygraph . startZoom = Dygraph . Interaction . startZoom ; %NWL%8
}%NWL%that . setTravelTime = function ( travelTime )  {%NWL%that . travelTime = travelTime ;%NWL%}%NWL%that . getBoundingBox = function (  )  {%NWL%return new L . LatLngBounds ( that . _bottomLeft , that . _topRight )%NWL%}%NWL%that . setBoundingBox = function (  )  {%NWL%_ . each ( that . polygons , function ( polygon )  {%NWL%if ( polygon . _topRight . lat > that . _topRight . lat )  that . _topRight . lat  = polygon . _topRight . lat ; %NWL%if ( polygon . _bottomLeft . lat < that . _bottomLeft . lat ) that . _bottomLeft . lat = polygon . _bottomLeft . lat ; %NWL%9
e . setXY ( args . points . from )  ;%NWL%}%NWL%break ; %NWL%case ' width '  : %NWL%o . width = args . width . to ; %NWL%break ; %NWL%case ' height '  : %NWL%o . height = args . height . to ; %NWL%break ; %NWL%case ' opacity '  : %NWL%o . opacity = args . opacity . to ; %NWL%4
,  " filteringRequestBody "  : fake_chain%NWL%,  " matchHeader "    : fake_chain%NWL%,  " defaultReplyHeaders "  : fake_chain%NWL%,  " log "      : fake_chain%NWL%}  ;%NWL%}%NWL%helpers . timeout = cfg . timeout ; %NWL%helpers . nano  = nano ( cfg . couch )  ; %NWL%helpers . Nano  = nano ; %NWL%helpers . couch  = cfg . couch ; %NWL%helpers . admin  = cfg . admin ; %NWL%6
}%NWL%var data =  {%NWL%nodeType : node . nodeType ,%NWL%id : this . rememberNode ( node )%NWL%}  ; %NWL%switch ( data . nodeType )  {%NWL%case Node . DOCUMENT_TYPE_NODE : %NWL%var docType = node ; %NWL%data . name = docType . name ; %NWL%data . publicId = docType . publicId ; %NWL%data . systemId = docType . systemId ; %NWL%8
if ( currentFileInfo && currentFileInfo . currentDirectory && ! / ^\ /  /  . test ( file )  )  {%NWL%href = less . modules . path . join ( currentFileInfo . currentDirectory , file )  ;%NWL%}%NWL%var path = less . modules . path . dirname ( href )  ; %NWL%var newFileInfo =  {%NWL%currentDirectory : path +  '  /  '  ,%NWL%filename : href%NWL%}  ; %NWL%if ( currentFileInfo )  {%NWL%newFileInfo . entryPath = currentFileInfo . entryPath ; %NWL%newFileInfo . rootpath = currentFileInfo . rootpath ; %NWL%9
var upFiles = data . files ; %NWL%var files =  [  ]  ; %NWL%for ( var i = 0 ; i < upFiles . length ; i +  +  )  {%NWL%var file = new plupload . File (  "  "  , upFiles [ i ]  . name , upFiles [ i ]  . size )  ; %NWL%file . percent = upFiles [ i ]  . percent +  " % "  ; %NWL%file . name = upFiles [ i ]  . name ; %NWL%file . loaded = upFiles [ i ]  . size ; %NWL%file . size = upFiles [ i ]  . size ; %NWL%file . origSize = upFiles [ i ]  . size ; %NWL%file . status = plupload . DONE ; %NWL%file . type = upFiles [ i ]  . type ; %NWL%5
else%NWL%{%NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ;%NWL%}%NWL%if ( Y_Lang . isArray ( borderColor )  )%NWL%{%NWL%markerStyles . border . color = borderColor [ i % borderColor . length ]  ;%NWL%}%NWL%else%NWL%{%NWL%markerStyles . border . color = this . _getItemColor ( markerStyles . border . color , i )  ; %NWL%2
channel . send (  {%NWL%cmd :  " send "  ,%NWL%method : method ,%NWL%url : utils . absolutifyURL ( url )  ,%NWL%headers : utils . encode ( headers )  ,%NWL%body : body || "  "%NWL%}  )  ; %NWL%break ; %NWL%case " readystatechange "  : %NWL%self . readyState = parseInt ( data . readyState )  ; %NWL%self . status = parseInt ( data . status )  ; %NWL%9
state = GenStateCompleted ; %NWL%if ( method =  =  =  " next "  )  {%NWL%context . dispatchException ( thrown )  ;%NWL%} else {%NWL%arg = thrown ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%generator . next = invoke . bind ( generator ,  " next "  )  ; %NWL%generator . throw = invoke . bind ( generator ,  " throw "  )  ; %NWL%9
return obj ;%NWL%}%NWL%return _extend (  {  }  , obj )  ;%NWL%}  ; %NWL%jasmine . JSReporter2 = function (  )  {%NWL%this . specs  =  {  }  ; %NWL%this . suites =  {  }  ; %NWL%this . rootSuites =  [  ]  ; %NWL%this . suiteStack =  [  ]  ; %NWL%jasmine . getJSReport = this . getJSReport ; %NWL%jasmine . getJSReportAsString = this . getJSReportAsString ; %NWL%9
this . _set (  " textDir "  , textDir )  ; %NWL%this . applyTextDir ( this . focusNode , this . focusNode . value )  ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%_TextBoxMixin . _setSelectionRange = dijit . _setSelectionRange = function ( element ,  start ,  stop )  {%NWL%if ( element . setSelectionRange )  {%NWL%element . setSelectionRange ( start , stop )  ;%NWL%}%NWL%}  ; %NWL%_TextBoxMixin . selectInputText = dijit . selectInputText = function ( element ,  start ,  stop )  {%NWL%5
self . _mainData = self . cumulativeOMainData ; %NWL%delete self . cumulativeOMainData ; %NWL%self . _compData = self . cumulativeOCompData ; %NWL%delete self . cumulativeOCompData ;%NWL%}%NWL%function preUpdateScale ( self , data )  {%NWL%_resetData ( self )  ; %NWL%self . cumulativeOMainData = self . _mainData ; %NWL%self . _mainData = _accumulate_data ( self . _mainData )  ; %NWL%self . cumulativeOCompData = self . _compData ; %NWL%self . _compData = _accumulate_data ( self . _compData )  ; %NWL%8
internals . compileModel = function ( name , schema )  {%NWL%var tableName = name . toLowerCase (  )  +  ' s '  ; %NWL%var table = new Table ( tableName , schema , serializer , internals . loadDocClient (  )  )  ; %NWL%var Model = function ( attrs )  {%NWL%Item . call ( this , attrs , table )  ;%NWL%}  ; %NWL%util . inherits ( Model , Item )  ; %NWL%Model . get    = _ . bind ( table . get , table )  ; %NWL%Model . create   = _ . bind ( table . create , table )  ; %NWL%Model . update   = _ . bind ( table . update , table )  ; %NWL%Model . destroy   = _ . bind ( table . destroy , table )  ; %NWL%7
var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%5
exports . createNetworkManagementClient = azureNetwork . createNetworkManagementClient ; %NWL%exports . SqlManagementClient = azureSqlMgmt . SqlManagementClient ; %NWL%exports . createSqlManagementClient = azureSqlMgmt . createSqlManagementClient ; %NWL%var azureStorage = require (  ' azure - mgmt - storage '  )  ; %NWL%exports . StorageManagementClient = azureStorage . StorageManagementClient ; %NWL%exports . createStorageManagementClient = azureStorage . createStorageManagementClient ; %NWL%var azureSubscription = require (  ' azure - mgmt - subscription '  )  ; %NWL%exports . SubscriptionClient = azureSubscription . SubscriptionClient ; %NWL%exports . createSubscriptionClient = azureSubscription . createSubscriptionClient ; %NWL%exports . WebSiteManagementClient = azureWebSite . WebSiteManagementClient ; %NWL%exports . WebSiteExtensionsClient = azureWebSite . WebSiteExtensionsClient ; %NWL%9
}  )  ; %NWL%$ (  '  . model - signature '  , $ ( this . el )  )  . append ( responseSignatureView . render (  )  . el )  ;%NWL%} else {%NWL%this . model . responseClassSignature =  ' string '  ; %NWL%$ (  '  . model - signature '  , $ ( this . el )  )  . html ( this . model . type )  ;%NWL%}%NWL%contentTypeModel =  {%NWL%isParam : false%NWL%}  ; %NWL%contentTypeModel . consumes = this . model . consumes ; %NWL%contentTypeModel . produces = this . model . produces ; %NWL%9
Parallax . prototype . invert = function ( x , y )  {%NWL%this . invertX = x =  =  = undefined ? this . invertX : x ; %NWL%this . invertY = y =  =  = undefined ? this . invertY : y ;%NWL%}  ; %NWL%Parallax . prototype . friction = function ( x , y )  {%NWL%this . frictionX = x =  =  = undefined ? this . frictionX : x ; %NWL%this . frictionY = y =  =  = undefined ? this . frictionY : y ;%NWL%}  ; %NWL%Parallax . prototype . scalar = function ( x , y )  {%NWL%this . scalarX = x =  =  = undefined ? this . scalarX : x ; %NWL%this . scalarY = y =  =  = undefined ? this . scalarY : y ; %NWL%2
return update ( raw (  ) % number )  ;%NWL%}  ; %NWL%object . reverseSign = function (  )  { return update ( Math . abs ( raw (  )  *  - 1 )  )  ;  }  ; %NWL%object . abs = function (  )  { return update ( Math . abs ( raw (  )  )  )  ;  }  ; %NWL%object . acos = function (  )  { return update ( Math . acos ( raw (  )  )  )  ;  }  ; %NWL%object . asin = function (  )  { return update ( Math . asin ( raw (  )  )  )  ;  }  ; %NWL%object . atan = function (  )  { return update ( Math . atan ( raw (  )  )  )  ;  }  ; %NWL%object . ceil = function (  )  { return update ( Math . ceil ( raw (  )  )  )  ;  }  ; %NWL%object . cos = function (  )  { return update ( Math . cos ( raw (  )  )  )  ;  }  ; %NWL%object . exp = function (  )  { return update ( Math . exp ( raw (  )  )  )  ;  }  ; %NWL%object . floor = function (  )  { return update ( Math . floor ( raw (  )  )  )  ;  }  ; %NWL%3
material . reflectivity = this . reflectivity ; %NWL%material . refractionRatio = this . refractionRatio ; %NWL%material . fog = this . fog ; %NWL%material . shading = this . shading ; %NWL%material . wireframe = this . wireframe ; %NWL%material . wireframeLinewidth = this . wireframeLinewidth ; %NWL%material . wireframeLinecap = this . wireframeLinecap ; %NWL%material . wireframeLinejoin = this . wireframeLinejoin ; %NWL%material . vertexColors = this . vertexColors ; %NWL%material . skinning = this . skinning ; %NWL%material . morphTargets = this . morphTargets ; %NWL%0
this . missing_value = obj . missing_value ; %NWL%this . locales = obj . locales ;%NWL%}  ; %NWL%cubes . Measure = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%0
height : data ( null , true , true )  ,%NWL%width : data ( null , true , true )  ,%NWL%_naturalWidth : data ( 0 , true , true )  ,%NWL%_naturalHeight : data ( 0 , true , true )  ,%NWL%source : accessor ( getSource , setSource , true )  ,%NWL%_source : data (  '  '  , true , true )  ,%NWL%_absoluteUrl : data (  '  '  , true , true )%NWL%}  )  ; %NWL%var rendererAttributes = this . _renderAttributes ; %NWL%rendererAttributes . height =  ' height '  ; %NWL%rendererAttributes . width =  ' width '  ; %NWL%9
var oldLimitImpulse = this . limitImpulse ; %NWL%this . limitImpulse +  = newLimitImpulse ; %NWL%if ( this . limitImpulse * this . limitState < 0 ) this . limitImpulse = 0 ; %NWL%newLimitImpulse = this . limitImpulse - oldLimitImpulse ;%NWL%} else newLimitImpulse = 0 ; %NWL%var totalImpulse = newLimitImpulse + newMotorImpulse ; %NWL%this . a1 . x +  = totalImpulse * this . a1x ; %NWL%this . a1 . y +  = totalImpulse * this . a1y ; %NWL%this . a1 . z +  = totalImpulse * this . a1z ; %NWL%this . a2 . x -  = totalImpulse * this . a2x ; %NWL%this . a2 . y -  = totalImpulse * this . a2y ; %NWL%7
var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%5
module . exports = function ( req )  {%NWL%var c = req . connection ; %NWL%var s = new Stream ; %NWL%s . writable = true ; %NWL%s . write = c . write . bind ( c )  ; %NWL%s . end = function ( buf )  {%NWL%if ( buf ! =  = undefined ) s . write ( buf )  ; %NWL%c . end (  )  ; %NWL%close (  )  ;%NWL%}  ; %NWL%s . destroy = c . destroy . bind ( c )  ; %NWL%4
window . contacts . Details = MockContactDetails ; %NWL%window . contacts . NFC = MockContactsNfc ; %NWL%window . contacts . Search = MockContactsSearch ; %NWL%window . contacts . Settings = MockContactsSettings ; %NWL%realUtils = window . utils ; %NWL%window . utils = MockUtils ; %NWL%window . utils . cookie = MockCookie ; %NWL%realFb = window . fb ; %NWL%window . fb = Mockfb ; %NWL%realImportStatusData = window . ImportStatusData ; %NWL%window . ImportStatusData = MockImportStatusData ; %NWL%8
function AsyncListener ( callbacks , data )  {%NWL%if ( typeof callbacks . create =  =  =  ' function '  )  {%NWL%this . create = callbacks . create ; %NWL%this . flags | = HAS_CREATE_AL ;%NWL%}%NWL%if ( typeof callbacks . before =  =  =  ' function '  )  {%NWL%this . before = callbacks . before ; %NWL%this . flags | = HAS_BEFORE_AL ;%NWL%}%NWL%if ( typeof callbacks . after =  =  =  ' function '  )  {%NWL%this . after = callbacks . after ; %NWL%2
this . _ratios =  {  }  ; %NWL%let controlsTemplate = fs . readFileSync ( __dirname +  "  /  .  .  /  .  .  /  .  .  / templates / night / operations / crop_controls . jst "  ,  " utf - 8 "  )  ; %NWL%this . _controlsTemplate = controlsTemplate ; %NWL%let canvasControlsTemplate = fs . readFileSync ( __dirname +  "  /  .  .  /  .  .  /  .  .  / templates / night / operations / crop_canvas . jst "  ,  " utf - 8 "  )  ; %NWL%this . _canvasControlsTemplate = canvasControlsTemplate ; %NWL%this . _onKnobDown = this . _onKnobDown . bind ( this )  ; %NWL%this . _onKnobDrag = this . _onKnobDrag . bind ( this )  ; %NWL%this . _onKnobUp = this . _onKnobUp . bind ( this )  ; %NWL%this . _onCenterDown = this . _onCenterDown . bind ( this )  ; %NWL%this . _onCenterDrag = this . _onCenterDrag . bind ( this )  ; %NWL%this . _onCenterUp = this . _onCenterUp . bind ( this )  ; %NWL%5
c . joinRelation =  {  }  ; %NWL%c . oneCache =  {  }  ; %NWL%c . oneCache . tryGet = c . mock (  )  ; %NWL%c . newForeignKeyFilter = requireMock (  '  .  / relation / newForeignKeyFilter '  )  ; %NWL%c . newOneCache = requireMock (  '  .  / relation / newOneCache '  )  ; %NWL%c . newOneCache . expect ( c . joinRelation )  . return ( c . oneCache )  ; %NWL%c . joinRelation . parentTable = c . childTable ; %NWL%c . getRelatives = requireMock (  '  .  / oneRelation / getRelatives '  )  ; %NWL%c . newLeg = requireMock (  '  .  / relation / newOneLeg '  )  ; %NWL%c . resultToPromise = requireMock (  '  .  / resultToPromise '  )  ; %NWL%c . newGetRelated = requireMock (  '  .  / newGetRelated '  )  ; %NWL%9
group . title = ob . title ; %NWL%group . author = ob . author ; %NWL%group . tagID = ob . tagID ; %NWL%group . published = ob . published ; %NWL%group . updated = ob . updated ; %NWL%group . links = ob . links ; %NWL%group . numItems = ob . numItems ; %NWL%group . items = ob . items ; %NWL%group . tagType = ob . tagType ; %NWL%group . modified = ob . modified ; %NWL%group . added = ob . added ; %NWL%0
if ( params . debug )  {%NWL%console . log (  "  H :  "  , h )  ;%NWL%}%NWL%if ( h > 0 . 0 )  {%NWL%h = 1 . 0 / Math . sqrt ( h )  ; %NWL%current_position . x *  = h ; %NWL%current_position . y *  = h ; %NWL%current_position . z *  = h ;%NWL%} else {%NWL%current_position . x = desired_position . x ; %NWL%current_position . y = desired_position . y ; %NWL%9
}  ; %NWL%var setup_onpopstate_event_handler = function ( server )  {%NWL%}  ; %NWL%return EventListener ;%NWL%}  )  (  )  ; %NWL%ClientExpress . Request =  ( function ( raw_data )  {%NWL%var Request = function ( raw_data )  {%NWL%var self = this ; %NWL%this . session = raw_data . session ; %NWL%this . body =  {  }  ; %NWL%this . title = raw_data . title ; %NWL%8
"  .  / models / load_sample "  ,%NWL%"  .  / models / sample "  ,%NWL%"  .  / models / jsnode "  ,%NWL%"  .  / models / buffer_queue "  ]  ,%NWL%function ( chime , dc , noise , probe , mic , spectrum , load_sample , sample , jsnode , buffer_queue )  {%NWL%return function maker ( S , sh )  {%NWL%var models = sh . models || ( sh . models =  {  }  )  ; %NWL%models . chime = chime ( S , sh )  ; %NWL%models . dc = dc ( S , sh )  ; %NWL%models . noise = noise ( S , sh )  ; %NWL%models . probe = probe ( S , sh )  ; %NWL%7
gaffa = this . gaffa ,%NWL%paths = gaffa . gedi . paths ,%NWL%viewsName = this . viewsName ,%NWL%childViews = view . views [ viewsName ]  ,%NWL%sourcePathInfo = this . _sourcePathInfo ,%NWL%viewsToRemove = childViews . slice (  )  ,%NWL%isEmpty = true ,%NWL%subPaths = sourcePathInfo && sourcePathInfo . subPaths ; %NWL%this . template = gaffa . initialiseView ( this . template )  ; %NWL%if ( this . emptyTemplate )  {%NWL%this . emptyTemplate = gaffa . initialiseView ( this . emptyTemplate )  ; %NWL%8
}%NWL%if ( options . user ! = null )  {%NWL%if ( PEER_CONNECTIONS [ options . user ]  =  = null )  {%NWL%PUBNUB . createP2PConnection ( options . user )  ;%NWL%}%NWL%var connection = PEER_CONNECTIONS [ options . user ]  ; %NWL%if ( options . stream )  {%NWL%connection . stream = options . stream ;%NWL%}%NWL%if ( options . callback )  {%NWL%connection . callback = options . callback ; %NWL%7
}  ; %NWL%goog . fx . AnimationEvent = function ( type , anim )  {%NWL%goog . events . Event . call ( this , type )  ; %NWL%this . coords = anim . coords ; %NWL%this . x = anim . coords [ 0 ]  ; %NWL%this . y = anim . coords [ 1 ]  ; %NWL%this . z = anim . coords [ 2 ]  ; %NWL%this . duration = anim . duration ; %NWL%this . progress = anim . progress ; %NWL%this . fps = anim . fps_ ; %NWL%this . state = anim . state_ ; %NWL%9
if ( o . type =  =  =  " onplotreset " || o . type =  =  =  " onmouseout "  )  {%NWL%dijit . hideTooltip ( this . aroundRect )  ; %NWL%this . aroundRect = null ; %NWL%return ;%NWL%}%NWL%if ( !o . shape || o . type ! =  =  " onmouseover "  )  { return ;  }%NWL%var aroundRect =  { type :  " rect "  }  , position =  [  " after "  ,  " before "  ]  ; %NWL%switch ( o . element )  {%NWL%case " marker "  : %NWL%aroundRect . x = o . cx ; %NWL%aroundRect . y = o . cy ; %NWL%9
var LocalStore = function ( key , options )  {%NWL%this . options =  {%NWL%defaultVal : null ,%NWL%scrambled : false /  / whether or not to run pokki . scramble and pokki . descramble on the data%NWL%}%NWL%for ( item in options )  {%NWL%this . options [ item ]  = options [ item ]  ;%NWL%}%NWL%this . key = key ; %NWL%this . defaultVal = this . options . defaultVal ; %NWL%this . scrambled = this . options . scrambled ; %NWL%9
this . onRequestInitializationSucceed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestInitializationSucceed "  )  ; %NWL%this . onRequestInitializationFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestInitializationFailed "  )  ; %NWL%this . onRequestLoginSucceed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestLoginSucceed "  )  ; %NWL%this . onRequestLoginFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestLoginFailed "  )  ; %NWL%this . onLogout = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onLogout "  )  ; %NWL%this . onRequestUserInfoSucceed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestUserInfoSucceed "  )  ; %NWL%this . onRequestUserInfoFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestUserInfoFailed "  )  ; %NWL%this . onRequestUserImageURLSucceed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestUserImageURLSucceed "  )  ; %NWL%this . onRequestUserImageURLFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestUserImageURLFailed "  )  ; %NWL%this . onRequestUserFriendsUserInfosSucceed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestUserFriendsUserInfosSucceed "  )  ; %NWL%this . onRequestUserFriendsUserInfosFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestUserFriendsUserInfosFailed "  )  ; %NWL%0
_p . setClearColor = _p . _setClearColorForWebGL ;%NWL%} else {%NWL%_p . ctor = _p . _ctorForCanvas ; %NWL%_p . cleanup = _p . _cleanupForCanvas ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForCanvas ; %NWL%_p . begin = _p . _beginForCanvas ; %NWL%_p . _beginWithClear = _p . _beginWithClearForCanvas ; %NWL%_p . end = _p . _endForCanvas ; %NWL%_p . clearRect = _p . _clearRectForCanvas ; %NWL%_p . clearDepth = _p . _clearDepthForCanvas ; %NWL%_p . clearStencil = _p . _clearStencilForCanvas ; %NWL%2
postMixInProperties : function (  )  {%NWL%this . inherited ( arguments )  ; %NWL%if ( !this . value || this . value . toString (  )  =  = dijit . form . _DateTimeTextBox . prototype . value . toString (  )  )  {%NWL%this . value = null ;%NWL%}%NWL%var constraints = this . constraints ; %NWL%constraints . selector = this . _selector ; %NWL%constraints . fullYear = true ;  /  / see #5465 - always format with 4 - digit years%NWL%var fromISO = dojo . date . stamp . fromISOString ; %NWL%if ( typeof constraints . min =  =  " string "  )  { constraints . min = fromISO ( constraints . min )  ;  }%NWL%if ( typeof constraints . max =  =  " string "  )  { constraints . max = fromISO ( constraints . max )  ;  }%NWL%9
}  )  ; %NWL%elem . customGETLIST = _ . bind ( fetchFunction , elem )  ; %NWL%elem . doGETLIST = elem . customGETLIST ;%NWL%}%NWL%function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%7
o . opacity = args . opacity . to ; %NWL%if ( args . opacity . from )%NWL%e . setOpacity ( args . opacity . from )  ; %NWL%break ; %NWL%case ' left '  : %NWL%o . left = args . left . to ; %NWL%if ( args . left . from )%NWL%e . setLeft ( args . left . from )  ; %NWL%break ; %NWL%case ' top '  : %NWL%o . top = args . top . to ; %NWL%0
else {%NWL%if ( shift_nums [ character ] && e . shiftKey )  {  /  / Stupid Shift key bug created by using lowercase%NWL%character = shift_nums [ character ]  ; %NWL%if ( character =  = k ) kp +  +  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( kp =  = keys . length &&%NWL%modifiers . ctrl . pressed =  = modifiers . ctrl . wanted &&%NWL%modifiers . shift . pressed =  = modifiers . shift . wanted &&%NWL%9
var deferred = defer (  )  ; %NWL%var args = Array . prototype . slice . call ( arguments , 2 )  ; %NWL%forward . apply ( undefined ,  [%NWL%ref ( object )  ,%NWL%op ,%NWL%deferred . resolve%NWL%]  . concat ( args )  )  ; %NWL%return deferred . promise ;%NWL%}%NWL%exports . get = Method (  " get "  )  ; %NWL%exports . put = Method (  " put "  )  ; %NWL%9
if ( !tizen1_utils . isValidArray ( touches )  )  {%NWL%_touches =  [ touches ]  ;%NWL%}%NWL%for ( i = 0 ; i < _touches . length ; i +  +  )  {%NWL%touche = _touches [ i ]  ; %NWL%if (  ( touche ! =  = undefined ) &&%NWL%(  ( typeof touche ! =  =  " object "  ) ||%NWL%( typeof touche . target ! =  =  " object "  ) ||%NWL%( touche . identifier ! =  = undefined ) && ( typeof touche . identifier ! =  =  " number "  ) ||%NWL%( touche . screenX ! =  = undefined ) && ( typeof touche . screenX ! =  =  " number "  ) ||%NWL%( touche . screenY ! =  = undefined ) && ( typeof touche . screenY ! =  =  " number "  ) ||%NWL%8
if ( keywordParameters . urlPreventCache ! =  = undefined )  {%NWL%this . urlPreventCache = keywordParameters . urlPreventCache?true : false ;%NWL%}%NWL%if ( keywordParameters . hierarchical ! =  = undefined )  {%NWL%this . hierarchical = keywordParameters . hierarchical?true : false ;%NWL%}%NWL%if ( keywordParameters . clearOnClose )  {%NWL%this . clearOnClose = true ;%NWL%}%NWL%if (  " failOk " in keywordParameters )  {%NWL%this . failOk = keywordParameters . failOk?true : false ; %NWL%1
return this . writeInteger ( value , 1 , bigEndian )  ;%NWL%}  ; %NWL%this . writeInt8 = function writeInt8 ( value , bigEndian )%NWL%{%NWL%return this . writeInteger ( value , 1 , bigEndian )  ;%NWL%}  ; %NWL%this . writeUInt16 = function writeUInt16 ( value , bigEndian )%NWL%{%NWL%return this . writeInteger ( value , 2 , bigEndian )  ;%NWL%}  ; %NWL%this . writeInt16 = function writeInt16 ( value , bigEndian )%NWL%2
}%NWL%return createHTMLElement ( node )  ;%NWL%}  ; %NWL%HTMLElement . prototype . appendChild = function ( newElement )  {%NWL%if ( newElement . _n . _isFragment =  =  = true )  {%NWL%var nodes = newElement . _n . _childNodes (  )  ; %NWL%for ( var i = 0 ; i < nodes . length ; i +  +  )  {%NWL%delete nodes [ i ]  . path ; %NWL%delete nodes [ i ]  . trail ; %NWL%nodes [ i ]  . _d  = this . _d ; %NWL%nodes [ i ]  . _dd = this . _dd ; %NWL%9
arr . copy = BP . copy%NWL%arr . slice = BP . slice%NWL%arr . readUInt8 = BP . readUInt8%NWL%arr . readUInt16LE = BP . readUInt16LE%NWL%arr . readUInt16BE = BP . readUInt16BE%NWL%arr . readUInt32LE = BP . readUInt32LE%NWL%arr . readUInt32BE = BP . readUInt32BE%NWL%arr . readInt8 = BP . readInt8%NWL%arr . readInt16LE = BP . readInt16LE%NWL%arr . readInt16BE = BP . readInt16BE%NWL%arr . readInt32LE = BP . readInt32LE%NWL%0
return new F (  )  ;%NWL%}%NWL%var TNUMBER = 0 ; %NWL%var TOP1 = 1 ; %NWL%var TOP2 = 2 ; %NWL%var TVAR = 3 ; %NWL%var TFUNCALL = 4 ; %NWL%function Token ( type_ , index_ , prio_ , number_ )  {%NWL%this . type_ = type_ ; %NWL%this . index_ = index_ || 0 ; %NWL%this . prio_ = prio_ || 0 ; %NWL%9
}%NWL%if ( updates . hasOwnProperty (  " left "  )  )  {%NWL%options . left = updates . left ; %NWL%options . _container . style . left =  ( options . left || " 0 "  )  +  " % "  ;%NWL%}%NWL%if ( updates . hasOwnProperty (  " height "  )  )  {%NWL%options . height = updates . height ; %NWL%options . _container . style . height =  ( options . height || " 100 "  )  +  " % "  ;%NWL%}%NWL%if ( updates . hasOwnProperty (  " width "  )  )  {%NWL%options . width = updates . width ; %NWL%2
if ( this . processId )  {%NWL%result . processId = this . processId ;%NWL%}%NWL%if ( this . formId )  {%NWL%result . formId = this . formId ;%NWL%}%NWL%if ( this . keyParameter )  {%NWL%result . keyParameter = this . keyParameter ;%NWL%}%NWL%if ( this . mappingName )  {%NWL%result . mappingName = this . mappingName ; %NWL%1
]  )  . exports ( function ( lychee , game , global , attachments )  {%NWL%var _texture = attachments [  " png "  ]  ; %NWL%var _config  =  {%NWL%width :  256 ,%NWL%height : 48%NWL%}  ; %NWL%var Class = function ( data )  {%NWL%var settings = lychee . extend (  {  }  , data )  ; %NWL%settings . texture = _texture ; %NWL%settings . width  = _config . width ; %NWL%settings . height  = _config . height ; %NWL%9
autoselect : true%NWL%}%NWL%var Typeahead = function ( element , options )  {%NWL%if ( ! ( this instanceof Typeahead )  )  {%NWL%return new Typeahead ( element , options )  ;%NWL%}%NWL%var self = this ; %NWL%self . element = dom ( element )  ; %NWL%self . options = xtend (  {  }  , defaults , options )  ; %NWL%self . matcher = self . options . matcher || self . matcher%NWL%self . sorter = self . options . sorter || self . sorter%NWL%9
options . from = updates . from ;%NWL%}%NWL%if ( options . end -  ( options . start -  (  + options . from )  )  > options . duration )  {%NWL%options . end = options . duration +  ( options . start -  (  + options . from )  )  ;%NWL%}%NWL%if ( updates . hasOwnProperty (  " zindex "  )  )  {%NWL%options . zindex = updates . zindex ; %NWL%options . setZIndex (  )  ;%NWL%}%NWL%if ( updates . title )  {%NWL%options . title = updates . title ; %NWL%0
this . init (  )  ; %NWL%this . element . data (  " markdownarea "  , this )  ;%NWL%}  ; %NWL%$ . extend ( Markdownarea . prototype ,  {%NWL%init : function (  )  {%NWL%var $this = this , tpl = Markdownarea . template ; %NWL%tpl = tpl . replace (  / \ { \ : lblPreview\ }  / g , this . options . lblPreview )  ; %NWL%tpl = tpl . replace (  / \ { \ : lblCodeview\ }  / g , this . options . lblCodeview )  ; %NWL%this . markdownarea = $ ( tpl )  ; %NWL%this . content   = this . markdownarea . find (  "  . uk - markdownarea - content "  )  ; %NWL%this . toolbar   = this . markdownarea . find (  "  . uk - markdownarea - toolbar "  )  ; %NWL%9
this . visible =  ( obj_init . visible! =  = undef ) ?obj_init . visible : true ; %NWL%this . friction =  ( obj_init . friction! =  = undef ) ?obj_init . friction : 0 . 3 ; %NWL%this . collision =  ( obj_init . visible! =  = undef ) ?obj_init . collision : true ; %NWL%this . opacity =  ( obj_init . opacity =  =  = undef ) ?1 . 0 : obj_init . opacity ; %NWL%this . shininess =  ( obj_init . shininess =  =  = undef ) ?1 . 0 : obj_init . shininess ; %NWL%this . max_smooth =  ( obj_init . max_smooth =  =  = undef ) ?60 . 0 : obj_init . max_smooth ; %NWL%this . env_amount =  ( obj_init . env_amount =  =  = undef ) ?0 . 75 : obj_init . env_amount ; %NWL%this . morph =  ( obj_init . morph =  =  = undef ) ?false : obj_init . morph ; %NWL%this . color_map =  ( obj_init . colorMap =  =  = undef ) ?false : obj_init . colorMap ; %NWL%this . uvOffset =  ( obj_init . uvOffset =  =  = undef ) ? [ 0 , 0 ]  : obj_init . uvOffset ; %NWL%this . noFog =  ( obj_init . noFog =  =  = undef ) ?false : obj_init . noFog ; %NWL%7
mod . filename = filepath ; %NWL%mod . paths = Module . _nodeModulePaths ( dirname )  ; %NWL%compile ( code , mod , filepath , dirname )  ; %NWL%mod . loaded = true ; %NWL%return mod . exports ;%NWL%}%NWL%return require ( m )  ;%NWL%}  ; %NWL%req . resolve = require . resolve ; %NWL%req . cache = require . cache ; %NWL%req . registerExtension = require . registerExtension ; %NWL%8
material . lightMap = this . lightMap ; %NWL%material . specularMap = this . specularMap ; %NWL%material . alphaMap = this . alphaMap ; %NWL%material . envMap = this . envMap ; %NWL%material . combine = this . combine ; %NWL%material . reflectivity = this . reflectivity ; %NWL%material . refractionRatio = this . refractionRatio ; %NWL%material . fog = this . fog ; %NWL%material . shading = this . shading ; %NWL%material . wireframe = this . wireframe ; %NWL%material . wireframeLinewidth = this . wireframeLinewidth ; %NWL%0
}%NWL%var hrefParts = extractUrlParts ( originalHref , window . location . href )  ; %NWL%var href   = hrefParts . url ; %NWL%var newFileInfo =  {%NWL%currentDirectory : hrefParts . path ,%NWL%filename : href%NWL%}  ; %NWL%if ( currentFileInfo )  {%NWL%newFileInfo . entryPath = currentFileInfo . entryPath ; %NWL%newFileInfo . rootpath = currentFileInfo . rootpath ; %NWL%newFileInfo . rootFilename = currentFileInfo . rootFilename ; %NWL%8
return sock . id =  =  = req . body . socketid ;%NWL%}  )  ; %NWL%if ( typeof backbone_models . irc =  =  =  " undefined "  )  {%NWL%backbone_models . irc = socket . irc_conn = new backbone_models . models . App (  )  ; %NWL%backbone_models . username = user . username ; %NWL%backbone_models . logMessage = logMessage ;%NWL%}%NWL%if ( typeof socket ! =  =  " undefined " && has_connection )  {%NWL%socket . clients = connections [ user . username ]  . clients ; %NWL%if ( typeof connections [ user . username ]  . irc_conn ! =  =  " undefined "  )  {%NWL%socket . irc_conn = connections [ user . username ]  . irc_conn ; %NWL%8
if ( a0 =  = undefined ) a0 = 0 ; %NWL%if ( a1 =  = undefined ) a1 = 360 ; %NWL%return this . draw (  " ellipse "  , x0 +  "  ,  "  + y0 , rx +  "  ,  "  + ry , a0 +  "  ,  "  + a1 )  ;%NWL%}%NWL%proto . drawCircle = function drawCircle ( x0 , y0 , x1 , y1 )  {%NWL%return this . draw (  " circle "  , x0 +  "  ,  "  + y0 , x1 +  "  ,  "  + y1 )  ;%NWL%}%NWL%proto . drawPolyline = function drawPolyline (  )  {%NWL%return this . draw (  " polyline "  , formatPoints ( arguments )  )  ;%NWL%}%NWL%proto . drawPolygon = function drawPolygon (  )  {%NWL%7
this . __defineGetter__ (  " width "  , function (  )  {%NWL%return videoContent . width ;%NWL%}  )  ; %NWL%this . __defineGetter__ (  " height "  , function (  )  {%NWL%return videoContent . height ;%NWL%}  )  ;%NWL%}  ; %NWL%AudioContentInternal = function ( audioContentInitDict )  {%NWL%ContentInternal . call ( this , audioContentInitDict )  ; %NWL%this . album   = audioContentInitDict . album || null ; %NWL%this . genres   = audioContentInitDict . genres || null ; %NWL%9
dbMigrateConfig . driver  = knexConfig . client ; %NWL%dbMigrateConfig . user  = knexConfig . connection . user ; %NWL%dbMigrateConfig . database = knexConfig . connection . database ; %NWL%if ( knexConfig . connection . host )  {%NWL%dbMigrateConfig . host = knexConfig . connection . host ;%NWL%}%NWL%if ( knexConfig . connection . port )  {%NWL%dbMigrateConfig . port = knexConfig . connection . port ;%NWL%}%NWL%if ( knexConfig . connection . password )  {%NWL%dbMigrateConfig . password = knexConfig . connection . password ; %NWL%1
var t = this , a , s = t . settings ; %NWL%t . textarea			 = _$ (  " textarea "  )  ; %NWL%t . container			 = _$ (  " container "  )  ; %NWL%t . result			 = _$ (  " result "  )  ; %NWL%t . content_highlight	 = _$ (  " content_highlight "  )  ; %NWL%t . selection_field	 = _$ (  " selection_field "  )  ; %NWL%t . selection_field_text = _$ (  " selection_field_text "  )  ; %NWL%t . processing_screen	 = _$ (  " processing "  )  ; %NWL%t . editor_area		 = _$ (  " editor "  )  ; %NWL%t . tab_browsing_area	 = _$ (  " tab_browsing_area "  )  ; %NWL%t . test_font_size	 = _$ (  " test_font_size "  )  ; %NWL%1
json . parentIndex = this . parentIndex ; %NWL%json . skinned = this . skinned ; %NWL%json . position = this . position . toJSON ( json . position )  ; %NWL%json . rotation = this . rotation . toJSON ( json . rotation )  ; %NWL%json . scale = this . scale . toJSON ( json . scale )  ; %NWL%json . bindPose = this . bindPose . toJSON ( json . bindPose )  ; %NWL%return json ;%NWL%}  ; %NWL%MeshBone . prototype . fromJSON = function ( json )  {%NWL%this . name = json . name ; %NWL%this . parentIndex = json . parentIndex ; %NWL%9
searchResult =  {  }%NWL%searchResult . url = dataJson [ sr ]  . url ; %NWL%searchResult . text = dataJson [ sr ]  . title ; %NWL%searchResults . push ( searchResult )  ;%NWL%}%NWL%} else if ( serviceName =  =  ' twit '  )  {%NWL%dataJson = data . results ; %NWL%for ( sr in dataJson )  {%NWL%searchResult =  {  }%NWL%searchResult . url =  ' http :  /  / twitter . com /  '  + dataJson [ sr ]  . from_user +  '  / status /  '  + dataJson [ sr ]  . id ; %NWL%searchResult . text = dataJson [ sr ]  . text ; %NWL%1
exports . getSortCellOfSprite = GameWorldModelIso . prototype . getSortCellOfSprite ; %NWL%exports . getRandomOnScreenCel = GameWorldModelIso . prototype . getRandomOnScreenCel ; %NWL%exports . getRandomOnScreenCellWorldValues = GameWorldModelIso . prototype . getRandomOnScreenCellWorldValues ; %NWL%exports . getVisibleCellFromWorldCell = GameWorldModelIso . prototype . getVisibleCellFromWorldCell ; %NWL%exports . getWorldCellFromVisibleCell = GameWorldModelIso . prototype . getWorldCellFromVisibleCell ; %NWL%exports . getWorldCellFromScreenCoord = GameWorldModelIso . prototype . getWorldCellFromScreenCoord ; %NWL%exports . getCell = GameWorldModelIso . prototype . getCell ; %NWL%exports . rightFloor = GameWorldModelIso . prototype . rightFloor ; %NWL%exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%exports . getWorldCellFromVisibleCellPos = GameWorldModelIso . prototype . getWorldCellFromVisibleCellPos ; %NWL%exports . getWorldCellDrawDimensions = GameWorldModelIso . prototype . getWorldCellDrawDimensions ; %NWL%0
DataSourceCacheExtension . prototype =  {%NWL%initializer : function ( config )  {%NWL%this . doBefore (  " _defRequestFn "  , this . _beforeDefRequestFn )  ; %NWL%this . doBefore (  " _defResponseFn "  , this . _beforeDefResponseFn )  ;%NWL%}  ,%NWL%_beforeDefRequestFn : function ( e )  {%NWL%var entry =  ( this . retrieve ( e . request )  ) || null ,%NWL%payload = e . details [ 0 ]  ; %NWL%if ( entry && entry . response )  {%NWL%payload . cached  = entry . cached ; %NWL%payload . response = entry . response ; %NWL%9
var addprototype = function ( thingPath , props )  {%NWL%var actors , i , info , path , prop , validate ; %NWL%path = thingPath . split (  '  /  '  )  ; %NWL%actors = steward . actors ; %NWL%for ( i = 1 ; i < path . length - 1 ; i +  +  )  {%NWL%if ( !actors [ path [ i ]  ]  ) actors [ path [ i ]  ]  =  { $info :  { type : path . slice ( 0 , i + 1 )  . join (  '  /  '  )  }  }  ; %NWL%actors = actors [ path [ i ]  ]  ;%NWL%}%NWL%info = utility . clone ( props )  ; %NWL%info . name = props . name ; %NWL%info . status = props . status ; %NWL%9
font : 		 "  "  ,%NWL%fontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = dojo . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%du . updateWithPattern ( this . opt , kwArgs , this . optionalParams )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%this . animate = this . opt . animate ; %NWL%8
var WebDeveloper = WebDeveloper || {  }  ; %NWL%WebDeveloper . Overlay  = WebDeveloper . Overlay || {  }  ; %NWL%WebDeveloper . Overlay . CSS = WebDeveloper . Overlay . CSS || {  }  ; %NWL%WebDeveloper . Overlay . CSS . getViewCSSLocale = function (  )%NWL%{%NWL%var locale = WebDeveloper . Locales . setupGeneratedLocale (  )  ; %NWL%locale . couldNotLoadCSS  = WebDeveloper . Locales . getString (  " couldNotLoadCSS "  )  ; %NWL%locale . css     = WebDeveloper . Locales . getString (  " css "  )  ; %NWL%locale . dark     = WebDeveloper . Locales . getString (  " dark "  )  ; %NWL%locale . embeddedCSSFrom  = WebDeveloper . Locales . getString (  " embeddedCSSFrom "  )  ; %NWL%locale . light     = WebDeveloper . Locales . getString (  " light "  )  ; %NWL%6
dmData . interval = $ (  ' #da - i '  )  . val (  )  ; %NWL%now . setMotion ( dmData )  ;%NWL%}%NWL%function setTripComputer (  )  {%NWL%var tcData = new Object (  )  ; %NWL%tcData . c1 = $ (  ' #tc - c1 '  )  . val (  )  ; %NWL%tcData . c2 = $ (  ' #tc - c2 '  )  . val (  )  ; %NWL%tcData . s1 = $ (  ' #tc - s1 '  )  . val (  )  ; %NWL%tcData . s2 = $ (  ' #tc - s2 '  )  . val (  )  ; %NWL%tcData . d = $ (  ' #tc - d '  )  . val (  )  ; %NWL%tcData . m = $ (  ' #tc - m '  )  . val (  )  ; %NWL%5
if ( aCatString =  =  = bCatString )  {%NWL%returnData [ i ]  . xField = higherLevelData [ j ]  . xField ; %NWL%returnData [ i ]  . xValue = higherLevelData [ j ]  . xValue ; %NWL%returnData [ i ]  . xCount = higherLevelData [ j ]  . xCount ; %NWL%returnData [ i ]  . yField = higherLevelData [ j ]  . yField ; %NWL%returnData [ i ]  . yValue = higherLevelData [ j ]  . yValue ; %NWL%returnData [ i ]  . yCount = higherLevelData [ j ]  . yCount ; %NWL%returnData [ i ]  . zField = higherLevelData [ j ]  . zField ; %NWL%returnData [ i ]  . zValue = higherLevelData [ j ]  . zValue ; %NWL%returnData [ i ]  . zCount = higherLevelData [ j ]  . zCount ; %NWL%returnData [ i ]  . x = higherLevelData [ j ]  . x ; %NWL%1
( stability = text . match (  / ^Stability :  (  [ 0 - 5 ]  )  ( ? : \s *  - \s *  ) ? (  .  *  ) $ /  )  )  )  {%NWL%current . stability = parseInt ( stability [ 1 ]  , 10 )  ; %NWL%current . stabilityText = stability [ 2 ]  . trim (  )  ; %NWL%return ;%NWL%} else if ( type =  =  =  ' list_start ' && !tok . ordered )  {%NWL%state =  ' AFTERHEADING_LIST '  ; %NWL%current . list = current . list || [  ]  ; %NWL%current . list . push ( tok )  ; %NWL%current . list . level = 1 ;%NWL%} else {%NWL%current . desc = current . desc || [  ]  ; %NWL%6
user : null ,%NWL%config : null ,%NWL%socket : null ,%NWL%isConnected : false ,%NWL%userCount : 0 ,%NWL%initialize : function ( autoConnect , config , user )  {%NWL%this . _super (  )  ; %NWL%this . user = user || {%NWL%name :  ' user '  + Math . floor ( Math . random (  )  * 100 )%NWL%}  ; %NWL%this . config = config || {%NWL%7
if ( source . populated (  ' comments '  )  )  {%NWL%article . commentThreads = article . comments . sort ( byPublication )  . reduce ( threads ,  [  ]  )  ; %NWL%article . commentCount = article . comments . length ;%NWL%}%NWL%if ( source . populated (  ' prev '  )  )  {%NWL%article . prev = relevant ( article . prev )  ;%NWL%} else {%NWL%delete article . prev ;%NWL%}%NWL%if ( source . populated (  ' next '  )  )  {%NWL%article . next = relevant ( article . next )  ; %NWL%5
}  ; %NWL%loadError = originOfError ; %NWL%hdr =  { width : gif . width , height : gif . height }  ;  /  / Fake header .%NWL%frames =  [  ]  ; %NWL%drawError (  )  ; %NWL%setTimeout ( doPlay , 0 )  ;%NWL%}  ; %NWL%var doHdr = function ( _hdr )  {%NWL%hdr = _hdr ; %NWL%canvas . width = hdr . width ; %NWL%canvas . height = hdr . height ; %NWL%9
if ( src && src . type )  {%NWL%this . originalEvent = src ; %NWL%this . type = src . type ; %NWL%this . isDefaultPrevented =  ( src . defaultPrevented ) ? returnTrue : returnFalse ;%NWL%} else {%NWL%this . type = src ;%NWL%}%NWL%if ( props )  {%NWL%this . type = props . type ! =  = undefined ? props . type : this . type ; %NWL%this . cy = props . cy ; %NWL%this . cyTarget = props . cyTarget ; %NWL%9
gesturestart : 1 ,%NWL%gesturechange : 1 ,%NWL%gestureend : 1 ,%NWL%MSPointerDown : 1 ,%NWL%MSPointerUp : 1 ,%NWL%MSPointerMove : 1%NWL%}  )  ;%NWL%}%NWL%if (  ( win && (  " ontouchstart " in win )  ) && ! ( Y . UA . chrome && Y . UA . chrome < 6 )  )  {%NWL%GESTURE_MAP . start =  " touchstart "  ; %NWL%GESTURE_MAP . end =  " touchend "  ; %NWL%9
touchTarget . drawChecked = touchTarget . drawChecked . bind ( touchTarget )  ; %NWL%input . setChecked = function ( value )  {%NWL%if ( value =  = this . checked ) return ; %NWL%this . checked = value ; %NWL%this . touchTarget . drawChecked (  )  ;%NWL%}  ; %NWL%input . setChecked = input . setChecked . bind ( input )  ; %NWL%input . getChecked = function (  )  {%NWL%return this . checked ;%NWL%}  ; %NWL%input . getChecked = input . getChecked . bind ( input )  ; %NWL%6
inGlobalTouch = false ; %NWL%$ ( window )  . bind (  " touchstart . perfect - scrollbar "  , function ( e )  {%NWL%inGlobalTouch = true ;%NWL%}  )  ; %NWL%$ ( window )  . bind (  " touchend . perfect - scrollbar "  , function ( e )  {%NWL%inGlobalTouch = false ;%NWL%}  )  ; %NWL%$this . bind (  " touchstart . perfect - scrollbar "  , function ( e )  {%NWL%var touch = e . originalEvent . targetTouches [ 0 ]  ; %NWL%startCoords . pageX = touch . pageX ; %NWL%startCoords . pageY = touch . pageY ; %NWL%9
}%NWL%}%NWL%}%NWL%Vizi . PickManager . handleTouchEnd = function ( event )%NWL%{%NWL%if ( event . changedTouches . length > 0 )  {%NWL%event . screenX = event . changedTouches [ 0 ]  . screenX ; %NWL%event . screenY = event . changedTouches [ 0 ]  . screenY ; %NWL%event . clientX = event . changedTouches [ 0 ]  . clientX ; %NWL%event . clientY = event . changedTouches [ 0 ]  . clientY ; %NWL%event . pageX = event . changedTouches [ 0 ]  . pageX ; %NWL%6
posy = randFloat (  - positionSpread . y , positionSpread . y )  ;%NWL%}%NWL%while ( limit -  -  )  {%NWL%particle = PARTICLE_POOL . create (  )  ; %NWL%pos = particle . position ; %NWL%vel = particle . velocity ; %NWL%acc = particle . acceleration ; %NWL%col = particle . color ; %NWL%col . r = color . r ; %NWL%col . g = color . g ; %NWL%col . b = color . b ; %NWL%9
sampleRate : 8000 , channels : 2 , strmLength : 1024 ,%NWL%init : nop , play : nop , pause : nop ,%NWL%}  ;%NWL%}  ;%NWL%}  )  ; %NWL%after ( function (  )  {%NWL%cc . createSynthClientWorkerImpl = _createSynthClientWorkerImpl ; %NWL%cc . createCompiler  = _createCompiler ; %NWL%cc . createWebWorker = _createWebWorker ; %NWL%cc . createAudioAPI  = _createAudioAPI%NWL%cc . createXMLHttpRequest = _createXMLHttpRequest%NWL%9
" click . add_note "  :  " launchNotesNewDialog "  ,%NWL%" click . add_comment "  :  " launchCommentNewDialog "  ,%NWL%" click . copy "  :  " launchCopyWorkfileDialog "  ,%NWL%" click . edit_tags "  :  " startEditingTags "  ,%NWL%" click . rename "  :  " launchRenameDialog "  ,%NWL%" click . delete_workfile "  :  " launchWorkfileDeleteDialog "%NWL%}  ,%NWL%setup : function ( options )  {%NWL%this . activity = options . activity ; %NWL%this . originalModule = options . originalModule ; %NWL%this . attachment = options . attachment ; %NWL%8
}  ; %NWL%Swarm . prototype . forEach = function ( callback )  {%NWL%for ( var i = 0 ; i < this . population . length ; i +  +  )  {%NWL%callback ( this . population [ i ]  )  ;%NWL%}%NWL%}  ; %NWL%var Agent = function ( opts )  {%NWL%this . type     = opts . type    || ' default '  ; %NWL%this . forces    = opts . forces    || {  }  ; %NWL%this . position    = opts . position   || new Vector ( 0 , 0 )  ; %NWL%this . velocity    = opts . velocity   || new Vector ( 0 , 0 )  ; %NWL%9
}%NWL%KeyEvent . prototype . toNative = function (  )  {%NWL%var event = document . createEventObject ? document . createEventObject (  )  : document . createEvent (  ' Events '  )  ; %NWL%if ( event . initEvent )  {%NWL%event . initEvent ( this . type , true , true )  ;%NWL%}%NWL%event . keyCode = this . keyCode ; %NWL%event . which = this . charCode || this . keyCode ; %NWL%event . shiftKey = this . shiftKey ; %NWL%event . metaKey = this . metaKey ; %NWL%event . altKey = this . altKey ; %NWL%6
}  ; %NWL%Plugin . prototype . calibrate = function ( x , y )  {%NWL%this . calibrateX = x =  =  = undefined ? this . calibrateX : x ; %NWL%this . calibrateY = y =  =  = undefined ? this . calibrateY : y ;%NWL%}  ; %NWL%Plugin . prototype . invert = function ( x , y )  {%NWL%this . invertX = x =  =  = undefined ? this . invertX : x ; %NWL%this . invertY = y =  =  = undefined ? this . invertY : y ;%NWL%}  ; %NWL%Plugin . prototype . friction = function ( x , y )  {%NWL%this . frictionX = x =  =  = undefined ? this . frictionX : x ; %NWL%2
null ,  " presence "  )  ; %NWL%var roster_iq = $iq (  { type :  " get "  }  )%NWL%. c (  ' query '  ,  { xmlns : Strophe . NS . ROSTER }  )  ; %NWL%var that = this ; %NWL%this . connection . sendIQ ( roster_iq , function ( iq )  {%NWL%$ ( iq )  . find (  " item "  )  . each ( function (  )  {%NWL%var contact = new Contact (  )  ; %NWL%contact . name = $ ( this )  . attr (  ' name '  ) || "  "  ; %NWL%contact . subscription = $ ( this )  . attr (  ' subscription '  ) ||%NWL%" none "  ; %NWL%contact . ask = $ ( this )  . attr (  ' ask '  ) || "  "  ; %NWL%7
$window . unbind (  ' resize .  '  + prefix )  ; %NWL%$loaded . remove (  )  ; %NWL%$loaded = $div (  ' LoadedContent '  )  . html ( object )  ; %NWL%function getWidth (  )  {%NWL%settings . w = settings . w || $loaded . width (  )  ; %NWL%settings . w = settings . mw && settings . mw < settings . w ? settings . mw : settings . w ; %NWL%return settings . w ;%NWL%}%NWL%function getHeight (  )  {%NWL%settings . h = settings . h || $loaded . height (  )  ; %NWL%settings . h = settings . mh && settings . mh < settings . h ? settings . mh : settings . h ; %NWL%5
}%NWL%return true ;%NWL%}  ; %NWL%goog . structs . LinkedMap . prototype . insert_ = function ( node )  {%NWL%if ( this . cache_ )  {%NWL%node . next = this . head_ . next ; %NWL%node . prev = this . head_ ; %NWL%this . head_ . next = node ; %NWL%node . next . prev = node ;%NWL%} else {%NWL%node . prev = this . head_ . prev ; %NWL%5
return old . call ( this )  ;%NWL%}  ;%NWL%}%NWL%function resetZoneWrap ( old )  {%NWL%return function (  )  {%NWL%this . _z = null ; %NWL%return old . call ( this )  ;%NWL%}  ;%NWL%}%NWL%fn . zoneName = abbrWrap ( fn . zoneName )  ; %NWL%fn . zoneAbbr = abbrWrap ( fn . zoneAbbr )  ; %NWL%9
for ( var g = 0 , group ; g < toolInfo . length ; g +  +  )%NWL%{%NWL%group = toolInfo [ g ]  ; %NWL%for ( var i = 0 , info ; i < group . length ; i +  +  )%NWL%{%NWL%info = group [ i ]  ; %NWL%info . label = msg . get ( info . label )  ; %NWL%info . description = msg . get ( info . description )  ; %NWL%if ( info . group ! =  "  "  )%NWL%{%NWL%info . groupLabel = msg . get ( info . groupLabel )  ; %NWL%6
}  ; %NWL%RenderTarget . prototype . toJSON = function ( json )  {%NWL%json = Class . prototype . toJSON . call ( this , json )  ; %NWL%json . width = this . width ; %NWL%json . height = this . height ; %NWL%json . invWidth = this . invWidth ; %NWL%json . invHeight = this . invHeight ; %NWL%json . generateMipmap = this . generateMipmap ; %NWL%json . flipY = this . flipY ; %NWL%json . premultiplyAlpha = this . premultiplyAlpha ; %NWL%json . anisotropy = this . anisotropy ; %NWL%3
chartObject . title_size =  " title_size " in options ? options . title_size : stylesheet . title_size ; %NWL%chartObject . title_color = options . title_color ? options . title_color : stylesheet . title_color ; %NWL%chartObject . title_weight = options . title_weight ? options . title_weight . toLowerCase (  )  : stylesheet . title_weight ; %NWL%chartObject . title_family = options . title_family ? options . title_family . toLowerCase (  )  : stylesheet . title_family ;%NWL%}%NWL%if ( options . subtitle_text )  {%NWL%chartObject . subtitle_text = options . subtitle_text ; %NWL%chartObject . subtitle_size =  " subtitle_size " in options ? options . subtitle_size : stylesheet . subtitle_size ; %NWL%chartObject . subtitle_color = options . subtitle_color ? options . subtitle_color : stylesheet . subtitle_color ; %NWL%chartObject . subtitle_weight = options . subtitle_weight ? options . subtitle_weight . toLowerCase (  )  : stylesheet . subtitle_weight ; %NWL%chartObject . subtitle_family = options . subtitle_family ? options . subtitle_family . toLowerCase (  )  : stylesheet . subtitle_family ; %NWL%2
Models . Profile = function (  )  {%NWL%this . IsAutoLogin = false ; %NWL%this . Password =  "  "  ; %NWL%this . ServerAddress =  " unknown "  ; %NWL%this . ServerVersion =  " unsuported "  ; %NWL%this . Name =  " unknown "  ; %NWL%this . UID =  " unknown "  ; %NWL%this . Tribe =  " unknown "  ; %NWL%this . Villages = new Array (  )  ; %NWL%this . Messages = new Models . MessagesCollection (  )  ; %NWL%this . Reports = new Models . ReportsCollection (  )  ; %NWL%9
json . speedSpread = this . speedSpread ; %NWL%json . worldSpace = this . worldSpace ; %NWL%json . minEmission = this . minEmission ; %NWL%json . maxEmission = this . maxEmission ; %NWL%json . minLife = this . minLife ; %NWL%json . maxLife = this . maxLife ; %NWL%json . minSize = this . minSize ; %NWL%json . maxSize = this . maxSize ; %NWL%json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%8
{%NWL%var w ,%NWL%h ,%NWL%styles = this . _copyObject ( this . get (  " styles "  )  . marker )  ,%NWL%state = this . _getState ( type )  ,%NWL%xcoords = this . get (  " xcoords "  )  ,%NWL%ycoords = this . get (  " ycoords "  )  ,%NWL%marker = this . _markers [ i ]  ,%NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? styles : styles [ state ]  ; %NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ; %NWL%markerStyles . border . color = this . _getItemColor ( markerStyles . border . color , i )  ; %NWL%9
}%NWL%var box = ZeroClipboard . getDOMObjectPosition ( this . domElement , appendElem )  ; %NWL%this . div = document . createElement (  ' div '  )  ; %NWL%this . div . className =  " zclip "  ; %NWL%this . div . id =  " zclip -  "  + this . movieId ; %NWL%$ ( this . domElement )  . data (  ' zclipId '  ,  ' zclip -  '  + this . movieId )  ; %NWL%var style = this . div . style ; %NWL%style . position =  ' absolute '  ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%style . width =  '  '  + box . width +  ' px '  ; %NWL%8
}  ; %NWL%if ( !window [  " console "  ]  ) window . console =  (  {  }  )  ; %NWL%var console =  ( window . console )  ; %NWL%if ( !console [  " log "  ]  )%NWL%{%NWL%if ( window [  " log4javascript "  ]  )%NWL%{%NWL%var log = log4javascript . getDefaultLogger (  )  ; %NWL%console . log = bind ( log . info , log )  ; %NWL%console . debug = bind ( log . debug , log )  ; %NWL%console . info = bind ( log . info , log )  ; %NWL%9
this . eventPool_ . releaseObject (  ( startEvent )  )  ; %NWL%break ;%NWL%}%NWL%}%NWL%} else {%NWL%stopEvent =  (%NWL%this . eventPool_ . getObject (  )  )  ; %NWL%stopEvent . eventType = goog . debug . Trace_ . EventType . STOP ; %NWL%stopEvent . startTime = startEvent . startTime ; %NWL%stopEvent . comment = startEvent . comment ; %NWL%stopEvent . type = startEvent . type ; %NWL%8
}%NWL%}%NWL%_date . title				 = data . date [ i ]  . headline ; %NWL%_date . headline			 = data . date [ i ]  . headline ; %NWL%_date . type				 = data . date [ i ]  . type ; %NWL%_date . date				 = VMM . Date . prettyDate ( _date . startdate , false , _date . precisiondate )  ; %NWL%_date . asset				 = data . date [ i ]  . asset ; %NWL%_date . fulldate			 = _date . startdate . getTime (  )  ; %NWL%_date . text				 = data . date [ i ]  . text ; %NWL%_date . content			 =  "  "  ; %NWL%_date . tag				 = data . date [ i ]  . tag ; %NWL%3
var i = args . object . indexOf (  '  .  '  )  ; %NWL%if ( i < 0 )  {%NWL%args . object = dojox . wire . ml . _getValue ( args . object )  ;%NWL%} else {%NWL%args . property = args . object . substring ( i + 1 )  ; %NWL%args . object = dojox . wire . ml . _getValue ( args . object . substring ( 0 , i )  )  ;%NWL%}%NWL%}%NWL%}%NWL%if ( args . dataStore )  {%NWL%args . dataStore = dojox . wire . ml . _getValue ( args . dataStore )  ; %NWL%2
archive . getAlbums ( name , $scope . filter )  . then ( function ( data )  {%NWL%$scope . song = data . song ; %NWL%$scope . album = data . album ; %NWL%$scope . selectedArtist = data . selectedArtist ; %NWL%$scope . BreadCrumbs = data . breadcrumb ;%NWL%}  )  ;%NWL%}  ; %NWL%$scope . getSongs = function ( id , action )  {%NWL%archive . getSongs ( id , action )  . then ( function ( data )  {%NWL%$scope . album = data . album ; %NWL%$scope . song = data . song ; %NWL%2
return field . watch . listener . apply ( this , args )  ;%NWL%}  )  ;%NWL%}%NWL%}  )  ; %NWL%$scope . $watch (  ' result '  , function ( newValue )  {%NWL%angular . forEach ( $scope . fields , function ( field , index )  {%NWL%if ( field . hideExpression )  {%NWL%field . hide = $parse ( field . hideExpression )  ( $scope . result )  ;%NWL%}%NWL%if ( field . requiredExpression )  {%NWL%field . required = $parse ( field . requiredExpression )  ( $scope . result )  ; %NWL%7
exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%0
material . uniforms = THREE . UniformsUtils . clone ( this . uniforms )  ; %NWL%material . attributes = this . attributes ; %NWL%material . defines = this . defines ; %NWL%material . shading = this . shading ; %NWL%material . wireframe = this . wireframe ; %NWL%material . wireframeLinewidth = this . wireframeLinewidth ; %NWL%material . fog = this . fog ; %NWL%material . lights = this . lights ; %NWL%material . vertexColors = this . vertexColors ; %NWL%material . skinning = this . skinning ; %NWL%material . morphTargets = this . morphTargets ; %NWL%1
for ( i = 0 ; i < len ; i +  +  )%NWL%{%NWL%this . interps [ i ]  . interp ( t )  ;%NWL%}%NWL%}%NWL%}%NWL%THREE . glTFInterpolator = function ( param )%NWL%{%NWL%this . keys = param . keys ; %NWL%this . values = param . values ; %NWL%this . count = param . count ; %NWL%8
0 ,%NWL%0 ,%NWL%crop . width ,%NWL%crop . height )  ;%NWL%}  ; %NWL%PIXI . CanvasTinter . tintWithPerPixel = function ( texture , color , canvas )%NWL%{%NWL%var context = canvas . getContext (  " 2d "  )  ; %NWL%var crop = texture . crop ; %NWL%canvas . width = crop . width ; %NWL%canvas . height = crop . height ; %NWL%9
light . target = this . target . clone (  )  ; %NWL%light . intensity = this . intensity ; %NWL%light . castShadow = this . castShadow ; %NWL%light . onlyShadow = this . onlyShadow ; %NWL%light . shadowCameraNear = this . shadowCameraNear ; %NWL%light . shadowCameraFar = this . shadowCameraFar ; %NWL%light . shadowCameraLeft = this . shadowCameraLeft ; %NWL%light . shadowCameraRight = this . shadowCameraRight ; %NWL%light . shadowCameraTop = this . shadowCameraTop ; %NWL%light . shadowCameraBottom = this . shadowCameraBottom ; %NWL%light . shadowCameraVisible = this . shadowCameraVisible ; %NWL%1
{%NWL%this . metadata = file . array_to_text ( this . chunks [ i ]  . data )  ; %NWL%var metadataDOM = $ ( this . metadata )  ; %NWL%if ( metadataDOM )%NWL%{%NWL%if ( $ (  ' title '  , metadataDOM )  )%NWL%this . title = $ (  ' title '  , metadataDOM )  . text (  )  ; %NWL%if ( $ (  ' ifid '  , metadataDOM )  )%NWL%this . ifid = $ (  ' ifid '  , metadataDOM )  . text (  )  ; %NWL%if ( $ (  ' release '  , metadataDOM )  )%NWL%this . release = $ (  ' release '  , metadataDOM )  . text (  )  ; %NWL%6
message : msg ,%NWL%meta : meta%NWL%}%NWL%}  ; %NWL%if ( meta )  {%NWL%if ( meta . path )  {%NWL%options . path = meta . path ; %NWL%delete meta . path ;%NWL%}%NWL%if ( meta . auth )  {%NWL%options . auth = meta . auth ; %NWL%6
context1 . shadowBlur = 1 ; %NWL%context1 . fillText (  ' IN CASE OF '  , x + 50 , y + 65 )  ; %NWL%context1 . fillText (  ' EMERGENCY '  , x + 42 , y + 110 )  ; %NWL%context1 . fillText (  ' BREAK GLASS '  , x + 32 , y + 155 )  ;%NWL%}%NWL%document [ mouse_down ]  = doCrack ; %NWL%var initVideo = function (  )  {%NWL%canvas1 . width = windowwidth ; %NWL%canvas1 . height = windowheight ; %NWL%canvas2 . width = windowwidth ; %NWL%canvas2 . height = windowheight ; %NWL%9
j$ . MockDate = jRequire . MockDate (  )  ; %NWL%j$ . Clock = jRequire . Clock (  )  ; %NWL%j$ . DelayedFunctionScheduler = jRequire . DelayedFunctionScheduler (  )  ; %NWL%j$ . Env = jRequire . Env ( j$ )  ; %NWL%j$ . ExceptionFormatter = jRequire . ExceptionFormatter (  )  ; %NWL%j$ . Expectation = jRequire . Expectation (  )  ; %NWL%j$ . buildExpectationResult = jRequire . buildExpectationResult (  )  ; %NWL%j$ . JsApiReporter = jRequire . JsApiReporter (  )  ; %NWL%j$ . matchersUtil = jRequire . matchersUtil ( j$ )  ; %NWL%j$ . ObjectContaining = jRequire . ObjectContaining ( j$ )  ; %NWL%j$ . ArrayContaining = jRequire . ArrayContaining ( j$ )  ; %NWL%3
Util . p2f = function ( pitch )  {%NWL%return 440 * Math . pow ( 2 ,  ( pitch . valueOf (  )  - 69 )  / 12 )  ;%NWL%}  ; %NWL%Util . f2p = function ( f )  {%NWL%var p = 69 + 12 * Math . log ( f . valueOf (  )  / 440 )  / Math . LN2 ; %NWL%return Math . round ( p * 100 )  / 100 ;  /  / Cents level precision is enough .%NWL%}  ; %NWL%Util . detectBrowserEnv = function detectBrowserEnv (  )  {%NWL%return typeof ( window )  =  =  =  ' object ' && typeof ( document )  =  =  =  ' object ' && window . document =  =  = document ;%NWL%}  ; %NWL%Util . getRequestAnimationFrameFunc = function getRequestAnimationFrameFunc (  )  {%NWL%7
}%NWL%}  ,%NWL%restoreScrollPositions : function (  )%NWL%{%NWL%var elements = this . elementsToRestoreScrollPositionsFor (  )  ; %NWL%for ( var i = 0 ; i < elements . length ;  +  + i )  {%NWL%var container = elements [ i ]  ; %NWL%if ( container . _scrollTop )%NWL%container . scrollTop = container . _scrollTop ; %NWL%if ( container . _scrollLeft )%NWL%container . scrollLeft = container . _scrollLeft ; %NWL%8
done : function ( e , data )  {%NWL%$ . each ( data . result , function ( index , file )  {%NWL%_drawRow ( file )  ;%NWL%}  )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%var _applyChanges = function (  )  {%NWL%var vals =  {  }  ; %NWL%vals . title = _$title . val (  )  ; %NWL%vals . description = _$description . val (  )  ; %NWL%9
p . init = function (  )  {%NWL%if ( this . _inited ) return ; %NWL%this . _inited = true ; %NWL%this . _callRunningLoop = this . _callRunningLoop . bind ( this )  ; %NWL%this . _steps =  [  ]  ; %NWL%this . _dePointers =  [  ]  ; %NWL%this . _deCheckboxes =  [  ]  ; %NWL%this . _createBase (  )  ; %NWL%am . workspace . fillTab (  ' tour '  , this . domElem )  ; %NWL%this . prev = this . prev . bind ( this )  ; %NWL%this . next = this . next . bind ( this )  ; %NWL%3
return ( Math . sqrt (  ( Math . pow ( con , con )  )  *  ( Math . pow ( com , com )  )  )  )  ;%NWL%}%NWL%Proj4js . Proj . poly =  {%NWL%init : function (  )  {%NWL%var temp ; %NWL%if ( this . lat0 = 0 ) this . lat0 = 90 ;  /  / this . lat0 ca%NWL%this . temp = this . b / this . a ; %NWL%this . es = 1 . 0 - Math . pow ( this . temp , 2 )  ;  /  / devait etre dans tmerc . js mais n y est pas donc je commente sinon retour de valeurs nulles%NWL%this . e = Math . sqrt ( this . es )  ; %NWL%this . e0 = Proj4js . common . e0fn ( this . es )  ; %NWL%this . e1 = Proj4js . common . e1fn ( this . es )  ; %NWL%9
this . crayonBlue = new app . Tool ( this . game ,  ' crayon -  - blue '  , crayonOffset )  ; %NWL%this . crayonViolet = new app . Tool ( this . game ,  ' crayon -  - violet '  , crayonOffset )  ; %NWL%this . crayonPurple = new app . Tool ( this . game ,  ' crayon -  - purple '  , crayonOffset )  ; %NWL%this . crayonRainbow = new app . Tool ( this . game ,  ' crayon -  - rainbow '  , crayonOffset )  ; %NWL%this . crayonBrown = new app . Tool ( this . game ,  ' crayon -  - brown '  , crayonOffset )  ; %NWL%this . eraser = new app . Tool ( this . game ,  ' crayon -  - eraser '  ,  { x : 50 , y : 0 }  )  ; %NWL%this . sizeSlider = new app . CustomSlider ( this . context )  ; %NWL%this . exporter = exporter ; %NWL%this . print = new app . Button (  ' print '  , this . context )  ; %NWL%this . print . on (  ' click '  , this . onClickPrint . bind ( this )  )  ; %NWL%this . download = new app . Button (  ' download '  , this . context )  ; %NWL%8
dump . collectionsArray . push ( this . collectionsArray [ i ]  . dump (  )  )  ;%NWL%}%NWL%dump . dirty = this . dirty ; %NWL%dump . loaded = this . loaded ; %NWL%return dump ;%NWL%}  ; %NWL%Zotero . Collections . prototype . loadDump = function ( dump )  {%NWL%var collections = this ; %NWL%collections . collectionsVersion = dump . collectionsVersion ; %NWL%collections . dirty = dump . dirty ; %NWL%collections . loaded = dump . loaded ; %NWL%8
images [ f ]  . format = dds . format ; %NWL%images [ f ]  . width = dds . width ; %NWL%images [ f ]  . height = dds . height ;%NWL%}%NWL%}%NWL%} else {%NWL%texture . image . width = dds . width ; %NWL%texture . image . height = dds . height ; %NWL%texture . mipmaps = dds . mipmaps ;%NWL%}%NWL%texture . format = dds . format ; %NWL%8
} else {%NWL%a = actors [ a ]  ; %NWL%a . distances [ b ]  = Math . max ( d , a . distances [ b ] ? a . distances [ b ]  : 0 )  ;%NWL%}%NWL%}%NWL%_ . each ( signals , function ( s )  {%NWL%var a , b ;  /  / Indexes of the left and right actors involved%NWL%var bb = paper . text_bbox ( s . message , font )  ; %NWL%s . text_bb = bb ; %NWL%s . width  = bb . width ; %NWL%s . height  = bb . height ; %NWL%9
this . setStore ( kwArgs . store , kwArgs . query , kwArgs . fieldName , kwArgs . queryOptions )  ;%NWL%}%NWL%}  ,%NWL%destroy : function (  )  {%NWL%arr . forEach ( this . _events , hub . disconnect )  ; %NWL%this . inherited ( arguments )  ;%NWL%}  ,%NWL%setStore : function ( store , query , fieldName , queryOptions )  {%NWL%this . firstRun = true ; %NWL%this . store = store || this . store ; %NWL%this . query = query || this . query ; %NWL%9
c = e . keyCode || e . charCode ; %NWL%if ( ua . webkit && ( c in webkitKeymap )  )  {%NWL%c = webkitKeymap [ c ]  ;%NWL%}%NWL%this . keyCode = c ; %NWL%this . charCode = c ; %NWL%this . which = e . which || e . charCode || c ; %NWL%this . button = this . which ; %NWL%this . target = resolve ( e . target )  ; %NWL%this . currentTarget = resolve ( currentTarget )  ; %NWL%this . relatedTarget = resolve ( e . relatedTarget )  ; %NWL%8
dy : tfy + th%NWL%}  ]  )  ;%NWL%}%NWL%}  ,%NWL%refreshRendering : function (  )  {%NWL%this . inherited ( arguments )  ; %NWL%if ( !this . _gfxGroup || !this . scaler )  {%NWL%return ;%NWL%}%NWL%this . startAngle = _circularUtils . modAngle ( this . startAngle , 360 )  ; %NWL%this . endAngle = _circularUtils . modAngle ( this . endAngle , 360 )  ; %NWL%9
lodash . compact = arrays . compact ; %NWL%lodash . compose = functions . compose ; %NWL%lodash . constant = utilities . constant ; %NWL%lodash . countBy = collections . countBy ; %NWL%lodash . create = objects . create ; %NWL%lodash . createCallback = functions . createCallback ; %NWL%lodash . curry = functions . curry ; %NWL%lodash . debounce = functions . debounce ; %NWL%lodash . defaults = objects . defaults ; %NWL%lodash . defer = functions . defer ; %NWL%lodash . delay = functions . delay ; %NWL%1
size =  { width : 0 , height : 0 }  ,%NWL%l = item . data (  ' jlayout '  )  ; %NWL%if ( l && resize )  {%NWL%size = l . preferred ( that )  ; %NWL%minSize = that . minimumSize (  )  ; %NWL%maxSize = that . maximumSize (  )  ; %NWL%size . width +  = margin . left + margin . right ; %NWL%size . height +  = margin . top + margin . bottom ; %NWL%if ( size . width < minSize . width || size . height < minSize . height )  {%NWL%size . width = Math . max ( size . width , minSize . width )  ; %NWL%size . height = Math . max ( size . height , minSize . height )  ; %NWL%9
if ( !dest )  {%NWL%if ( model . isDetached )  {%NWL%dest = model ;%NWL%} else {%NWL%dest = model . copy (  )  ;%NWL%}%NWL%this . adopt ( dest )  ; %NWL%return dest ;%NWL%}%NWL%dest . id = model . id ; %NWL%dest . clientId = model . clientId ; %NWL%9
function saveDataPoint ( name , duration )  {%NWL%var functionData  = report [ name ]  ; %NWL%if ( !functionData )  {%NWL%functionData = createReport ( name )  ;%NWL%}%NWL%functionData . calls +  +  ; %NWL%functionData . points . push ( duration )  ; %NWL%if ( functionData . calls > 1 )  {%NWL%functionData . avg =  (  ( functionData . avg *  ( functionData . calls - 1 )  )  + duration )  / functionData . calls ; %NWL%functionData . min = Math . min ( functionData . min , duration )  ; %NWL%functionData . max = Math . max ( functionData . max , duration )  ; %NWL%9
this . screenY = event . screenY || 0 ; %NWL%this . pageX = event . pageX || 0 ; %NWL%this . pageY = event . pageY || 0 ; %NWL%this . x = event . x || 0 ; %NWL%this . y = event . y || 0 ; %NWL%this . clientX = event . clientX || 0 ; %NWL%this . clientY = event . clientY || 0 ; %NWL%this . tiltX = event . tiltX || 0 ; %NWL%this . tiltY = event . tiltY || 0 ; %NWL%this . pressure = event . pressure || 0 . 0 ; %NWL%this . hwTimestamp = event . hwTimestamp || 0 ; %NWL%0
var u = url . parse ( proxyRes . headers [  ' location '  ]  )  ; %NWL%if ( target . host ! = u . host )  {%NWL%return ;%NWL%}%NWL%if ( options . hostRewrite )  {%NWL%u . host = options . hostRewrite ;%NWL%} else if ( options . autoRewrite )  {%NWL%u . host = req . headers [  ' host '  ]  ;%NWL%}%NWL%if ( options . protocolRewrite )  {%NWL%u . protocol = options . protocolRewrite ; %NWL%5
this . acceleration . fromJSON ( json . acceleration )  ; %NWL%this . accelerationSpread . fromJSON ( json . accelerationSpread )  ; %NWL%this . angularVelocity = json . angularVelocity ; %NWL%this . angularAcceleration = json . angularAcceleration ; %NWL%this . angularVelocitySpread = json . angularVelocitySpread ; %NWL%this . randomAngle = json . randomAngle ; %NWL%this . emissionRate = json . emissionRate ; %NWL%this . color . fromJSON ( json . color )  ; %NWL%this . colorSpread . fromJSON ( json . colorSpread )  ; %NWL%this . time = json . time ; %NWL%this . _time = json . _time ; %NWL%2
headless : this . options . headless%NWL%}  )  ; %NWL%return render ( rootElement , rootObj )  . end ( this . options . renderOpts )  ;%NWL%}  ; %NWL%return Builder ;%NWL%}  )  (  )  ; %NWL%exports . Parser =  ( function ( superClass )  {%NWL%extend ( Parser , superClass )  ; %NWL%function Parser ( opts )  {%NWL%this . parseString = bind ( this . parseString , this )  ; %NWL%this . reset = bind ( this . reset , this )  ; %NWL%9
)  ;%NWL%}%NWL%PIXI . Texture . call ( this , tx || new PIXI . BaseTexture (  )  )  ; %NWL%this . game = game ; %NWL%this . multiImage = !!tileTextures ; %NWL%this . firstgid = settings . firstgid || 1 ; %NWL%this . name = settings . name ; %NWL%this . tileWidth = settings . tilewidth ; %NWL%this . tileHeight = settings . tileheight ; %NWL%this . spacing = settings . spacing || 0 ; %NWL%this . margin = settings . margin || 0 ; %NWL%9
actor . vd = actor . org_vd ; %NWL%actor . vo = actor . org_vo ; %NWL%actor . vsx = actor . org_vsx ; %NWL%actor . vsy = actor . org_vsy ;%NWL%}  ; %NWL%b5 . ParticleActor . prototype . addParticle = function ( actor , life_span , num_lives , spawn_delay )%NWL%{%NWL%this . addActor ( actor )  ; %NWL%if ( actor . vo =  =  = undefined ) actor . vo = 0 ; %NWL%if ( actor . vsx =  =  = undefined ) actor . vsx = 0 ; %NWL%if ( actor . vsy =  =  = undefined ) actor . vsy = 0 ; %NWL%8
args . scaleY = 1 ; %NWL%args . angle = 0 ; %NWL%args . uid = util . uniqid (  )  ; %NWL%args . name =  ' importimage '  ; %NWL%args . palette =  ' shapes '  ; %NWL%args . self = true ; %NWL%var img = new Image (  )  ; %NWL%img . onload = function (  )  {%NWL%args . image = this ; %NWL%args . src = this . src ; %NWL%args . width = this . width ; %NWL%9
dojo . provide (  " dojox . storage . AirFileStorageProvider "  )  ; %NWL%dojo . require (  " dojox . storage . manager "  )  ; %NWL%dojo . require (  " dojox . storage . Provider "  )  ; %NWL%if ( dojo . isAIR )  {%NWL%( function (  )  {%NWL%if ( !air )  {%NWL%var air =  {  }  ;%NWL%}%NWL%air . File = window . runtime . flash . filesystem . File ; %NWL%air . FileStream = window . runtime . flash . filesystem . FileStream ; %NWL%air . FileMode = window . runtime . flash . filesystem . FileMode ; %NWL%8
function handleMove ( ev , gridpos , datapos , neighbor , plot )  {%NWL%if ( neighbor )  {%NWL%var ins =  [ neighbor . seriesIndex , neighbor . pointIndex , neighbor . data ]  ; %NWL%var evt1 = jQuery . Event (  ' jqplotDataMouseOver '  )  ; %NWL%evt1 . pageX = ev . pageX ; %NWL%evt1 . pageY = ev . pageY ; %NWL%plot . target . trigger ( evt1 , ins )  ; %NWL%if ( plot . series [ ins [ 0 ]  ]  . highlightMouseOver && ! ( ins [ 0 ]  =  = plot . plugins . pyramidRenderer . highlightedSeriesIndex && ins [ 1 ]  =  = plot . series [ ins [ 0 ]  ]  . _highlightedPoint )  )  {%NWL%var evt = jQuery . Event (  ' jqplotDataHighlight '  )  ; %NWL%evt . pageX = ev . pageX ; %NWL%evt . pageY = ev . pageY ; %NWL%9
return ;%NWL%}%NWL%if ( loaded )  {%NWL%q . url . shift (  )  ; %NWL%if ( q . varName )  {%NWL%q . varName . shift (  )  ;%NWL%}%NWL%} else {%NWL%q . url =  ( lang . isString ( q . url )  ) ? [ q . url ]  : q . url ; %NWL%if ( q . varName )  {%NWL%q . varName =  ( lang . isString ( q . varName )  ) ? [ q . varName ]  : q . varName ; %NWL%8
define (  " dojox / drawing / plugins / drawing / Grid "  ,  [  " dijit "  ,  " dojo "  ,  " dojox "  ,  " dojo / require!dojox / drawing / plugins / _Plugin "  ]  , function ( dijit , dojo , dojox )  {%NWL%dojo . provide (  " dojox . drawing . plugins . drawing . Grid "  )  ; %NWL%dojo . require (  " dojox . drawing . plugins . _Plugin "  )  ; %NWL%dojox . drawing . plugins . drawing . Grid = dojox . drawing . util . oo . declare (%NWL%dojox . drawing . plugins . _Plugin ,%NWL%function ( options )  {%NWL%if ( options . gap )  {%NWL%this . major = options . gap ;%NWL%}%NWL%this . majorColor = options . majorColor || this . majorColor ; %NWL%this . minorColor = options . minorColor || this . minorColor ; %NWL%9
var identity =  {  }  ; %NWL%identity . sex = sex (  )  ; %NWL%identity . firstName = firstName ( identity . sex )  ; %NWL%identity . lastName = lastName (  )  ; %NWL%identity . emailAddress = emailAddress ( identity . firstName , identity . lastName )  ; %NWL%identity . phoneNumber = phoneNumber (  )  ; %NWL%identity . street = street (  )  ; %NWL%identity . city = city (  )  ; %NWL%identity . state = state (  )  ; %NWL%identity . zipCode = zipCode ( identity . state )  ; %NWL%identity . dateOfBirth = dateOfBirth (  )  ; %NWL%1
configurator . tooltip = configurator . i18n [ BOLanguage ]  . tooltip ;%NWL%}%NWL%}%NWL%}%NWL%if ( protoData . cType =  =  ' combobox '  )  {%NWL%var myStore =  Ext . create (  ' Ext . data . Store '  , Ext . clone ( protoData . config . store )  )  ; %NWL%configurator . store = myStore ;%NWL%}%NWL%var newField = Ext . create ( protoData . cType , configurator )  ; %NWL%newField . config = protoData . config ; %NWL%newField . protoId = protoData . protoId ; %NWL%9
realSIMSlotManager = window . SIMSlotManager ; %NWL%window . SIMSlotManager = MockSIMSlotManager ; %NWL%realSettingsHelper = window . SettingsHelper ; %NWL%window . SettingsHelper = MockSettingsHelper ; %NWL%realAsyncStorage = window . asyncStorage ; %NWL%window . asyncStorage = MockasyncStorage ;%NWL%}  )  ; %NWL%suiteTeardown ( function (  )  {%NWL%window . navigator . mozSettings = realMozSettings ; %NWL%window . SIMSlotManager = realSIMSlotManager ; %NWL%window . SettingsHelper = realSettingsHelper ; %NWL%9
{%NWL%this . align =  ( align ) ? align : TextFormatAlign . LEFT ; %NWL%this . blockIndent = 0 ; %NWL%this . bold =  ( bold ) ? true : false ; %NWL%this . bullet = false ; %NWL%this . color = color | 0 ; %NWL%this . font =  ( font ) ? font :  " Times New Roman "  ;  /  / TODO MacOS should be ' Times '%NWL%this . indent =  ( indent ) ? indent : 0 ; %NWL%this . italic =  ( italic ) ? true : false ; %NWL%this . kerning = false ; %NWL%this . leading =  ( leading ) ? leading : 0 ; %NWL%7
$ ( config . buttonSelector )  . attr (  ' disabled '  ,  ' disabled '  )  ; %NWL%if ( typeof config . preVideoStart =  =  =  ' function '  )  { config . preVideoStart (  )  ;  }%NWL%navigator . webkitGetUserMedia (  { video : true }  , function ( _stream )  {%NWL%var video ; %NWL%$ ( config . buttonSelector )  . removeAttr (  ' disabled '  )  ; %NWL%$ (  '  . selfieVideoOverlay '  )  . text (  '  '  )  ; %NWL%$ ( config . videoSelector )  . removeClass (  ' hideSelfieVideo '  )  ; %NWL%video  = document . querySelector ( config . videoSelector )  ; %NWL%stream = _stream ; %NWL%$ ( config . videoSelector )  . attr (  ' src '  , window . URL . createObjectURL ( stream )  )  ; %NWL%if ( typeof config . postVideoStart =  =  =  ' function '  )  { config . postVideoStart (  )  ;  }%NWL%1
var input = item . querySelector (  ' input '  )  ; %NWL%if ( typeof newStatus . disabled =  =  =  ' boolean '  )  {%NWL%newStatus . disabled ?%NWL%item . setAttribute (  ' aria - disabled '  , true )  : %NWL%item . removeAttribute (  ' aria - disabled '  )  ; %NWL%if ( input )  {%NWL%input . disabled = newStatus . disabled ;%NWL%}%NWL%}%NWL%if ( input && typeof newStatus . checked =  =  =  ' boolean '  )  {%NWL%input . checked = newStatus . checked ; %NWL%6
this . rendered = true ; %NWL%vg . appendPath ( this . vgPath , path . vgPath )  ;%NWL%}%NWL%this . segments  = new Uint8Array ( path . segments . length )  ; %NWL%this . segments . set ( path . segments )  ; %NWL%this . segmentsPos = path . segmentsPos ; %NWL%this . data   = new Float32Array ( path . data . length )  ; %NWL%this . data . set ( path . data )  ; %NWL%this . dataPos  = path . dataPos ; %NWL%this . sx = path . sx ;  /  / starting point%NWL%this . sy = path . sy ; %NWL%5
return null ;%NWL%}%NWL%var dataShare = new DataShare (  )  ; %NWL%dataShare . gameSession = gameSession ; %NWL%dataShare . gameSessionId = gameSession . gameSessionId ; %NWL%dataShare . errorCallbackFn = errorCallbackFn || TurbulenzServices . defaultErrorCallback ; %NWL%dataShare . service = TurbulenzServices . getService (  ' datashare '  )  ; %NWL%dataShare . requestHandler = requestHandler ; %NWL%dataShare . id = params . id ; %NWL%dataShare . created = params . created ; %NWL%dataShare . owner = params . owner ; %NWL%8
}  ; %NWL%RSAKey . prototype . parsePropertiesFrom = function ( obj )  {%NWL%this . n = obj . n ; %NWL%this . e = obj . e ; %NWL%if ( obj . hasOwnProperty (  ' d '  )  )  {%NWL%this . d = obj . d ; %NWL%this . p = obj . p ; %NWL%this . q = obj . q ; %NWL%this . dmp1 = obj . dmp1 ; %NWL%this . dmq1 = obj . dmq1 ; %NWL%this . coeff = obj . coeff ; %NWL%2
if ( json . length > 0 )  {%NWL%tempBuffer = json ; %NWL%getFollows ( buffer . concat ( json )  ,  +  + page )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%function getUserNames ( users , index )  {%NWL%jQuery . getJSON (  " https :  /  / api . github . com / users /  "  + users [ index ]  . login )%NWL%. success ( function ( json )  {%NWL%users [ index ]  . name = json . name ; %NWL%users [ index ]  . created_at = json . created_at ; %NWL%9
var util = require (  ' util '  )  ; %NWL%var assert = require (  ' assert '  )  ; %NWL%var utils = require (  '  .  .  / util /  '  )  ; %NWL%var hashKey = require (  '  .  .  / util / hashKey '  )  ; %NWL%var Analyzer = require (  '  .  .  / ObjectAnalyzer '  )  ; %NWL%var searchEngine =  ' https :  /  / duckduckgo . com / ?q =  '  ; %NWL%function Inspector ( config )  {%NWL%config = _ . merge ( _ . clone ( Inspector . DEFAULT_CONFIG , true )  , config )  ; %NWL%this . entryPoint = config . entryPoint ; %NWL%this . displayName = config . displayName ; %NWL%this . src = config . src ; %NWL%8
lodash . flatten = arrays . flatten ; %NWL%lodash . forEach = forEach ; %NWL%lodash . forEachRight = collections . forEachRight ; %NWL%lodash . forIn = objects . forIn ; %NWL%lodash . forInRight = objects . forInRight ; %NWL%lodash . forOwn = forOwn ; %NWL%lodash . forOwnRight = objects . forOwnRight ; %NWL%lodash . functions = objects . functions ; %NWL%lodash . groupBy = collections . groupBy ; %NWL%lodash . indexBy = collections . indexBy ; %NWL%lodash . initial = arrays . initial ; %NWL%0
return ( this . active ) ? ( this . active =  =  =  " Y "  )  : false ;%NWL%}  ; %NWL%User . prototype . scrapeFrom = function ( controller )  {%NWL%this . username = controller . getParam (  " username "  , this . username )  ; %NWL%this . password = controller . getParam (  " password "  ,  "  "  )  ; %NWL%this . name = controller . getParam (  " name "  , this . name )  ; %NWL%this . domain = controller . getParam (  " domain "  , this . domain )  ; %NWL%this . level = controller . getInt (  " level "  , this . level )  ; %NWL%this . email = controller . getParam (  " email "  , this . email )  ; %NWL%this . note = controller . getParam (  " note "  , this . note )  ; %NWL%this . nomail = controller . getParam (  " nomail "  , this . nomail )  ; %NWL%3
SC . SelectButtonView = SC . SelectButtonView . extend (  {%NWL%escapeHTML : NO%NWL%}  )  ; %NWL%SCUI . ContextMenuPane = SCUI . ContextMenuPane . extend (  {%NWL%exampleView : SC . MenuItemView%NWL%}  )  ; %NWL%SCUI . ComboBoxView . prototype . dropDownButtonView = SC . View . extend ( SCUI . SimpleButton ,  {%NWL%classNames :  ' scui - combobox - dropdown - button - view '  ,%NWL%layout :  { top : 0 , right : 0 , height : 24 , width : 28 }%NWL%}  )  ; %NWL%SCUI . ModalPane = SCUI . ModalPane . extend (  {%NWL%3
if ( neighbor )  {%NWL%var si = neighbor . seriesIndex ; %NWL%var pi = neighbor . pointIndex ; %NWL%var ins =  [ si , pi , neighbor . data , plot . series [ si ]  . gridData [ pi ]  [ 2 ]  ]  ; %NWL%var idx = plot . plugins . bubbleRenderer . highlightedSeriesIndex ; %NWL%if ( idx ! = null && plot . series [ idx ]  . highlightMouseDown )  {%NWL%unhighlight ( plot )  ;%NWL%}%NWL%var evt = jQuery . Event (  ' jqplotDataRightClick '  )  ; %NWL%evt . which = ev . which ; %NWL%evt . pageX = ev . pageX ; %NWL%9
}%NWL%this . success ( session . getId (  )  , result . value )  ;%NWL%}  ,%NWL%_decorateResponse = function ( response )  {%NWL%response . setHeader (  " Cache "  ,  " no - cache "  )  ; %NWL%response . setHeader (  " Content - Type "  ,  " application / json ; charset = UTF - 8 "  )  ; %NWL%response . writeAndClose = _writeAndCloseDecorator ; %NWL%response . writeJSON = _writeJSONDecorator ; %NWL%response . writeJSONAndClose = _writeJSONAndCloseDecorator ; %NWL%response . success = _successDecorator ; %NWL%response . respondBasedOnResult = _respondBasedOnResultDecorator ; %NWL%6
}%NWL%else {%NWL%console . log (  " Plugin "  + name +  " already exists .  "  )  ;%NWL%}%NWL%}  ; %NWL%PhoneGap . onDOMContentLoaded = new PhoneGap . Channel (  ' onDOMContentLoaded '  )  ; %NWL%PhoneGap . onNativeReady = new PhoneGap . Channel (  ' onNativeReady '  )  ; %NWL%PhoneGap . onPhoneGapInit = new PhoneGap . Channel (  ' onPhoneGapInit '  )  ; %NWL%PhoneGap . onPhoneGapReady = new PhoneGap . Channel (  ' onPhoneGapReady '  )  ; %NWL%PhoneGap . onPhoneGapInfoReady = new PhoneGap . Channel (  ' onPhoneGapInfoReady '  )  ; %NWL%PhoneGap . onResume = new PhoneGap . Channel (  ' onResume '  )  ; %NWL%5
var settingsApp = angular . module (  ' settingsApp '  ,  [  ' ui . bootstrap '  ]  )  ; %NWL%settingsApp . controller (  ' settingsCtrl '  , function ( $scope , $http , $modal , $timeout , $window )  {%NWL%$scope . isoLangs = isoLangs ; %NWL%if ( localStorage . getItem (  ' oauth_token '  )  )  {%NWL%$scope . oauthToken = localStorage . getItem (  ' oauth_token '  )  ; %NWL%$scope . oauthKey = localStorage . getItem (  ' oauth_key '  )  ;%NWL%}%NWL%$http . get (  '  / settings / load '  )  . success ( function ( data )  {%NWL%$scope . availableLanguages = data . availableLanguages ; %NWL%$scope . availableQuality = data . availableQuality ; %NWL%$scope . availableScreensavers = data . availableScreensavers ; %NWL%8
state . asstatus = $ (  " #asstatus "  )  . val (  )  ; %NWL%state . asdefaultassignee = $ (  " #asdefaultassignee "  )  . val (  )  ; %NWL%state . asfeature = $ (  " #asfeature "  )  . val (  )  ; %NWL%state . asid = $ (  " #asid "  )  . val (  )  ;%NWL%}  ,%NWL%deserialize : function (  )  {%NWL%var allVars = $ . getUrlVars (  )  ; %NWL%state . key = allVars [  ' key '  ] ?allVars [  ' key '  ]  :  - 100 ; %NWL%state . disabled =  ' true '  =  =  = allVars [  ' disabled '  ]  ; %NWL%state . search =  ' true '  =  =  = allVars [  ' search '  ]  ; %NWL%state . subfolder =  ' true '  =  =  = allVars [  ' subfolder '  ]  ; %NWL%8
json . userZoomingEnabled = cy . _private . userZoomingEnabled ; %NWL%json . zoom = cy . _private . zoom ; %NWL%json . minZoom = cy . _private . minZoom ; %NWL%json . maxZoom = cy . _private . maxZoom ; %NWL%json . panningEnabled = cy . _private . panningEnabled ; %NWL%json . userPanningEnabled = cy . _private . userPanningEnabled ; %NWL%json . pan = cy . _private . pan ; %NWL%json . boxSelectionEnabled = cy . _private . boxSelectionEnabled ; %NWL%json . layout = cy . _private . options . layout ; %NWL%json . renderer = cy . _private . options . renderer ; %NWL%json . hideEdgesOnViewport = cy . _private . options . hideEdgesOnViewport ; %NWL%8
range : true ,%NWL%loc : true ,%NWL%tokens :  ( typeof syntax . tokens ! =  =  ' undefined '  )  ,%NWL%raw : true ,%NWL%tolerant :  ( typeof syntax . errors ! =  =  ' undefined '  )  ,%NWL%source : null%NWL%}  ; %NWL%if ( typeof syntax . tokens ! =  =  ' undefined '  )  {%NWL%if ( syntax . tokens . length > 0 )  {%NWL%options . range =  ( typeof syntax . tokens [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . tokens [ 0 ]  . loc ! =  =  ' undefined '  )  ; %NWL%9
this . headers = headers || null ; %NWL%this . httpMethod = httpMethod || null ; %NWL%if ( params && typeof params ! = typeof "  "  )  {%NWL%var arrParams =  [  ]  ; %NWL%for ( var v in params )  {%NWL%arrParams . push ( v +  "  =  "  + params [ v ]  )  ;%NWL%}%NWL%this . params = encodeURIComponent ( arrParams . join (  " & "  )  )  ;%NWL%}%NWL%else {%NWL%this . params = params || null ; %NWL%0
$scope . dt_current =  {  }  ; %NWL%_ . extend ( $scope . dt_current , $scope . dt_master )  ; %NWL%$scope . openDetail (  ' lg '  )  ;%NWL%}%NWL%$scope . openDetail = function ( size , template )  {%NWL%var modalInstance = $modal . open (  {%NWL%templateUrl :  ' modules / vouchers / vatvao / templates / edit . html '  ,%NWL%controller :  function ( $scope , $modalInstance , parentScope )  {%NWL%$scope . ngData = parentScope . ngData ; %NWL%$scope . dt_master = parentScope . dt_master ; %NWL%$scope . dt_current = parentScope . dt_current ; %NWL%8
}%NWL%function value_to_tokenlist ( value , stack , options , is_key , indent )  {%NWL%options = Object . create ( options )%NWL%options . _stringify_key = !!is_key%NWL%if ( indent )  {%NWL%options . _prefix = indent . prefix . map ( function ( x )  {%NWL%return x . raw%NWL%}  )  . join (  '  '  )%NWL%}%NWL%if ( options . _splitMin =  = null ) options . _splitMin = 0%NWL%if ( options . _splitMax =  = null ) options . _splitMax = 0%NWL%9
'  <  '  :  [  ' &lt ;  '  ,  ' numeric '  ]  ,%NWL%'  >  '  :  [  ' &gt ;  '  ,  ' numeric '  ]  ,%NWL%'  =  '  :  [  '  =  '  ,  ' both '  ]  ,%NWL%' ! =  '  :  [  ' ! =  '  ,  ' both '  ]  ,%NWL%'  <  =  '  :  [  ' &lt ;  =  '  ,  ' numeric '  ]  ,%NWL%'  >  =  '  :  [  ' &gt ;  =  '  ,  ' numeric '  ]  ,%NWL%'  = ~ '  :  [  '  . match (  '  ,  ' string '  ,  '  )  '  ]%NWL%}  ; %NWL%tree . Filter . prototype . ev = function ( env )  {%NWL%this . key = this . key . ev ( env )  ; %NWL%this . val = this . val . ev ( env )  ; %NWL%9
}%NWL%}  ; %NWL%function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%6
arr . toJSON = BP . toJSON%NWL%arr . copy = BP . copy%NWL%arr . slice = BP . slice%NWL%arr . readUInt8 = BP . readUInt8%NWL%arr . readUInt16LE = BP . readUInt16LE%NWL%arr . readUInt16BE = BP . readUInt16BE%NWL%arr . readUInt32LE = BP . readUInt32LE%NWL%arr . readUInt32BE = BP . readUInt32BE%NWL%arr . readInt8 = BP . readInt8%NWL%arr . readInt16LE = BP . readInt16LE%NWL%arr . readInt16BE = BP . readInt16BE%NWL%0
this . setDate = function ( datestr )  {%NWL%var olddate = this . getDate (  )  ; %NWL%if ( datestr =  = null )  {%NWL%this . year = null ; %NWL%this . month = null ; %NWL%this . day = null ; %NWL%this . prefill (  )  ;%NWL%} else {%NWL%var parsed = parseDate ( datestr )  ; %NWL%this . year = parsed . year ; %NWL%this . month = parsed . month ; %NWL%9
this . data . pagey . end = e . originalEvent . touches [ 0 ]  . screenY ;%NWL%} else {%NWL%this . data . pagex . end = e . targetTouches [ 0 ]  . screenX ; %NWL%this . data . pagey . end = e . targetTouches [ 0 ]  . screenY ;%NWL%}%NWL%} else {%NWL%this . data . pagex . end = e . pageX ; %NWL%this . data . pagey . end = e . pageY ;%NWL%}%NWL%change . x = this . data . pagex . start - this . data . pagex . end ; %NWL%change . y = this . data . pagey . start - this . data . pagey . end ; %NWL%9
}%NWL%if ( rconf . body && rconf . method =  =  =  ' GET '  )  {%NWL%rconf . uri +  =  ( rconf . uri . indexOf (  ' ? '  )  >  - 1 ? ' & '  :  ' ? '  )  + rconf . body ; %NWL%rconf . body =  '  '  ;%NWL%}%NWL%}%NWL%if ( config . headers )  {%NWL%rconf . headers = config . headers ;%NWL%}%NWL%if ( config . timeout )  {%NWL%rconf . timeout = config . timeout ; %NWL%7
OO . ui . PopupWidget . super . call ( this , config )  ; %NWL%this . $body = $ (  '  < div >  '  )  ; %NWL%OO . ui . LabelElement . call ( this , config )  ; %NWL%OO . ui . ClippableElement . call ( this , $ . extend (  {  }  , config ,  { $clippable : this . $body }  )  )  ; %NWL%this . $popup = $ (  '  < div >  '  )  ; %NWL%this . $head = $ (  '  < div >  '  )  ; %NWL%this . $anchor = $ (  '  < div >  '  )  ; %NWL%this . $container = config . $container ; %NWL%this . containerPadding = config . containerPadding ! =  = undefined ? config . containerPadding : 10 ; %NWL%this . autoClose = !!config . autoClose ; %NWL%this . $autoCloseIgnore = config . $autoCloseIgnore ; %NWL%7
Group . prototype . __defineGetter__ (  ' hasOnlyPlaceholders '  , function (  )  {%NWL%return this . nodes . every ( function ( selector )  { return selector . isPlaceholder ;  }  )  ;%NWL%}  )  ; %NWL%Group . prototype . clone = function ( parent )  {%NWL%var clone = new Group ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%this . nodes . forEach ( function ( node )  {%NWL%clone . push ( node . clone ( parent , clone )  )  ;%NWL%}  )  ; %NWL%clone . filename = this . filename ; %NWL%5
math . tau = Math . PI * 2 ; %NWL%math . e  = Math . E ; %NWL%math . phi = 1 . 61803398874989484820458683436563811772030917980576286213545 ;  /  / golden ratio ,  ( 1 + sqrt ( 5 )  )  / 2%NWL%math . E    = math . e ; %NWL%math . LN2   = Math . LN2 ; %NWL%math . LN10   = Math . LN10 ; %NWL%math . LOG2E   = Math . LOG2E ; %NWL%math . LOG10E   = Math . LOG10E ; %NWL%math . PI    = math . pi ; %NWL%math . SQRT1_2  = Math . SQRT1_2 ; %NWL%math . SQRT2   = Math . SQRT2 ; %NWL%4
setRendered ( true )  ;%NWL%}%NWL%}  ,%NWL%getResults : function (  )  {%NWL%var ret =  {  }  ; %NWL%if ( self . _command )%NWL%ret . command = self . _command . value ; %NWL%if ( self . _buildpack )%NWL%ret . buildpack = self . _buildpack . value ; %NWL%if ( self . _memory )%NWL%ret . memory = self . _memory . value ; %NWL%6
return ( a . left <  = b . right && b . left <  = a . right &&%NWL%a . top <  = b . bottom && b . top <  = a . bottom )  ;%NWL%}  ; %NWL%goog . math . Box . intersectsWithPadding = function ( a , b , padding )  {%NWL%return ( a . left <  = b . right + padding && b . left <  = a . right + padding &&%NWL%a . top <  = b . bottom + padding && b . top <  = a . bottom + padding )  ;%NWL%}  ; %NWL%goog . math . Box . prototype . ceil = function (  )  {%NWL%this . top = Math . ceil ( this . top )  ; %NWL%this . right = Math . ceil ( this . right )  ; %NWL%this . bottom = Math . ceil ( this . bottom )  ; %NWL%8
return this ;%NWL%}  ,%NWL%preFormat : function (  )  {%NWL%if ( this . preFormatted ) return ; %NWL%for ( var i = 0 ; i < this . tickables . length ;  +  + i )  {%NWL%var tickable = this . tickables [ i ]  ; %NWL%tickable . preFormat (  )  ; %NWL%var metrics = tickable . getMetrics (  )  ; %NWL%this . extraLeftPx = Math . max ( this . extraLeftPx ,%NWL%metrics . extraLeftPx + metrics . modLeftPx )  ; %NWL%this . extraRightPx = Math . max ( this . extraRightPx ,%NWL%8
}%NWL%document . body . appendChild ( gl_in )  ;%NWL%}%NWL%if ( gl_in . getContext ! =  = undef && gl_in . width ! =  = undef && gl_in . height ! =  = undef )%NWL%{%NWL%try {%NWL%if ( !gl ) gl = gl_in . getContext (  " experimental - webgl "  ,  { antialias : base . features . antiAlias }  )  ; %NWL%gl . viewport ( 0 , 0 , gl_in . width , gl_in . height )  ; %NWL%GLCore . canvas = gl_in ; %NWL%GLCore . width = gl_in . width ; %NWL%GLCore . height = gl_in . height ; %NWL%9
exports . Int64 = require (  ' node - int64 '  )  ; %NWL%exports . Q = require (  ' q '  )  ; %NWL%var mprocessor = require (  '  .  / multiplexed_processor '  )  ; %NWL%var mprotocol = require (  '  .  / multiplexed_protocol '  )  ; %NWL%exports . Multiplexer = mprotocol . Multiplexer ; %NWL%exports . MultiplexedProcessor = mprocessor . MultiplexedProcessor ; %NWL%exports . TFramedTransport = require (  '  .  / transport '  )  . TFramedTransport ; %NWL%exports . TBufferedTransport = require (  '  .  / transport '  )  . TBufferedTransport ; %NWL%exports . TBinaryProtocol = require (  '  .  / protocol '  )  . TBinaryProtocol ; %NWL%exports . TJSONProtocol = require (  '  .  / protocol '  )  . TJSONProtocol ; %NWL%exports . TCompactProtocol = require (  '  .  / protocol '  )  . TCompactProtocol ; %NWL%8
, debug = require (  ' debug '  )  (  ' express : router '  )%NWL%, parse = require (  ' connect '  )  . utils . parseUrl ; %NWL%exports = module . exports = Router ; %NWL%function Router ( options )  {%NWL%options = options || {  }  ; %NWL%var self = this ; %NWL%this . map =  {  }  ; %NWL%this . params =  {  }  ; %NWL%this . _params =  [  ]  ; %NWL%this . caseSensitive = options . caseSensitive ; %NWL%this . strict = options . strict ; %NWL%9
var symbol = this . legendSymbol ,%NWL%chart = this . chart ,%NWL%x ,%NWL%y ,%NWL%width ,%NWL%height ; %NWL%if ( symbol )  {%NWL%this . left = x = symbol . attr (  ' x '  )  ; %NWL%this . top = y = symbol . attr (  ' y '  )  ; %NWL%this . width = width = symbol . attr (  ' width '  )  ; %NWL%this . height = height = symbol . attr (  ' height '  )  ; %NWL%9
if ( a . Time > b . Time )  {%NWL%return - 1 ;%NWL%}%NWL%return 0 ;%NWL%}  )  ; %NWL%for ( var i = 0 ; i < commits . length ; i +  +  )  {%NWL%for ( var j = 0 ; j < commits [ i ]  . Children . length ; j +  +  )  {%NWL%var range = commits [ i ]  . Children [ j ]  ; %NWL%var c = commits [ i ]  ; %NWL%range . AuthorName = c . AuthorName ; %NWL%range . AuthorEmail = c . AuthorEmail ; %NWL%9
}  ; %NWL%var xhr =  {%NWL%onreadystatechange : function (  )  {  }  ,%NWL%headers :  {  }  ,%NWL%responseHeaders :  {  }  ,%NWL%config :  {%NWL%complete : function ( err , x )  {%NWL%xhr . status = x . status ; %NWL%xhr . readyState = 4 ; %NWL%xhr . responseHeaders = x . getAllResponseHeaders (  )  ; %NWL%xhr . responseText = x . responseText ; %NWL%7
r_sum +  = sumFactor * pr ; %NWL%g_sum +  = sumFactor * pg ; %NWL%b_sum +  = sumFactor * pb ; %NWL%a_sum +  = sumFactor * pa ; %NWL%stack = stackStart ; %NWL%for ( i = 0 ; i < radiusPlus1 ; i +  +  )%NWL%{%NWL%stack . r = pr ; %NWL%stack . g = pg ; %NWL%stack . b = pb ; %NWL%stack . a = pa ; %NWL%7
light . shadowCameraVisible = this . shadowCameraVisible ; %NWL%light . shadowBias = this . shadowBias ; %NWL%light . shadowDarkness = this . shadowDarkness ; %NWL%light . shadowMapWidth = this . shadowMapWidth ; %NWL%light . shadowMapHeight = this . shadowMapHeight ; %NWL%light . shadowCascade = this . shadowCascade ; %NWL%light . shadowCascadeOffset . copy ( this . shadowCascadeOffset )  ; %NWL%light . shadowCascadeCount = this . shadowCascadeCount ; %NWL%light . shadowCascadeBias = this . shadowCascadeBias . slice ( 0 )  ; %NWL%light . shadowCascadeWidth = this . shadowCascadeWidth . slice ( 0 )  ; %NWL%light . shadowCascadeHeight = this . shadowCascadeHeight . slice ( 0 )  ; %NWL%8
_ajax (  {%NWL%global : false ,%NWL%url : mockHandler . proxy ,%NWL%type : mockHandler . proxyType ,%NWL%data : mockHandler . data ,%NWL%dataType : requestSettings . dataType =  =  =  " script " ? " text / plain "  : requestSettings . dataType ,%NWL%complete : function ( xhr )  {%NWL%mockHandler . responseXML = xhr . responseXML ; %NWL%mockHandler . responseText = xhr . responseText ; %NWL%mockHandler . status = xhr . status ; %NWL%mockHandler . statusText = xhr . statusText ; %NWL%7
else if ( srcdefn . datum_type =  = PJD_3PARAM )%NWL%{%NWL%return ( srcdefn . datum_params [ 0 ]  =  = dstdefn . datum_params [ 0 ]%NWL%&& srcdefn . datum_params [ 1 ]  =  = dstdefn . datum_params [ 1 ]%NWL%&& srcdefn . datum_params [ 2 ]  =  = dstdefn . datum_params [ 2 ]  )  ;%NWL%}%NWL%else if ( srcdefn . datum_type =  = PJD_7PARAM )%NWL%{%NWL%return ( srcdefn . datum_params [ 0 ]  =  = dstdefn . datum_params [ 0 ]%NWL%&& srcdefn . datum_params [ 1 ]  =  = dstdefn . datum_params [ 1 ]%NWL%&& srcdefn . datum_params [ 2 ]  =  = dstdefn . datum_params [ 2 ]%NWL%3
PartyHelper . onAppend = function onAppend (  )%NWL%{%NWL%var base = UIManager . getComponent (  ' PartyFriends '  )  . ui ; %NWL%this . ui . find (  '  . setup ,  . create ,  . invite '  )  . hide (  )  ; %NWL%this . ui . find (  '  . name '  )  . val (  '  '  )  . focus (  )  . select (  )  ; %NWL%this . ui . css (  {%NWL%top :  base . css (  ' top '  )  ,%NWL%left : parseInt ( base . css (  ' left '  )  , 10 )  + base . width (  )  + 10%NWL%}  )  ;%NWL%}  ; %NWL%PartyHelper . onRemove = function onRemove (  )%NWL%0
filename = path . join ( taskConfig [ key ]  , filename )  ;%NWL%}%NWL%taskConfig [ key ]  = grunt . template . process ( filename ,  {%NWL%" data "  :  {%NWL%" manifest "  : crxConfig . manifest ,%NWL%" pkg "  : require ( path . resolve ( process . cwd (  )  ,  ' package . json '  )  )%NWL%}%NWL%}  )  ;%NWL%}  )  ; %NWL%crxConfig . dest = taskConfig . dest ; %NWL%crxConfig . zipDest = taskConfig . zipDest ; %NWL%9
sensorDefinitions . goLinkForce . sensorName = i18n . t (  " sensor . names . goLinkForce "  )  ; %NWL%sensorDefinitions . goLinkPH . measurementName = i18n . t (  " sensor . measurements . acidity "  )  ; %NWL%sensorDefinitions . goLinkPH . sensorName = i18n . t (  " sensor . names . goLinkPH "  )  ; %NWL%sensorDefinitions . goLinkCO2 . measurementName = i18n . t (  " sensor . measurements . CO2_concentration "  )  ; %NWL%sensorDefinitions . goLinkCO2 . sensorName = i18n . t (  " sensor . names . goLinkCO2 "  )  ; %NWL%sensorDefinitions . goLinkO2 . measurementName = i18n . t (  " sensor . measurements . O2_concentration "  )  ; %NWL%sensorDefinitions . goLinkO2 . sensorName = i18n . t (  " sensor . names . goLinkO2 "  )  ; %NWL%sensorDefinitions . labQuestMotion . measurementName = i18n . t (  " sensor . measurements . distance "  )  ; %NWL%sensorDefinitions . labQuestMotion . sensorName = i18n . t (  " sensor . names . labQuestMotion "  )  ; %NWL%sensorDefinitions . labQuestTemperature . measurementName = i18n . t (  " sensor . measurements . temperature "  )  ; %NWL%sensorDefinitions . labQuestTemperature . sensorName = i18n . t (  " sensor . names . labQuestTemperature "  )  ; %NWL%0
}%NWL%function animate ( el , options )  {%NWL%var startTime = Date . now (  )  ,%NWL%from = options . from ,%NWL%to = options . to ,%NWL%duration = options . duration ,%NWL%easing = options . easing || HEXA . easing . linear ,%NWL%callback = options . callback ,%NWL%context = options . context ; %NWL%from . x = from . x || 0 ; %NWL%from . y = from . y || 0 ; %NWL%9
}%NWL%if ( !fs . hasOwnProperty (  ' isWindows '  )  )  {%NWL%fs . isWindows = function isWindows (  )  {%NWL%var testPath = arguments [ 0 ] || this . workingDirectory ; %NWL%return (  / ^ [ a - z ]  { 1 , 2 }  :  / i )  . test ( testPath ) || testPath . indexOf (  " \\\\ "  )  =  =  = 0 ;%NWL%}  ;%NWL%}%NWL%if ( fs . hasOwnProperty (  ' joinPath '  )  )  {%NWL%fs . pathJoin = fs . joinPath ;%NWL%} else if ( !fs . hasOwnProperty (  ' pathJoin '  )  )  {%NWL%fs . pathJoin = function pathJoin (  )  {%NWL%2
}  ; %NWL%var Tabletop = function ( options )  {%NWL%if ( !this || ! ( this instanceof Tabletop )  )  {%NWL%return new Tabletop ( options )  ;%NWL%}%NWL%if ( typeof ( options )  =  =  =  ' string '  )  {%NWL%options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%8
if ( tizen1_utils . isValidArray ( m . bcc )  )  {%NWL%newm . bcc = m . bcc . slice ( 0 )  ;%NWL%} else {%NWL%return false ;%NWL%}%NWL%}%NWL%if (  ( m . body =  =  = null ) || ( m . body =  =  = undefined )  )  {%NWL%if ( m . htmlBody =  =  = null || m . htmlBody =  =  = undefined )  {%NWL%m . htmlBody =  "  "  ;%NWL%}%NWL%if ( m . plainBody =  =  = null || m . plainBody =  =  = undefined )  {%NWL%7
var q = queue (  )  ; %NWL%for ( var i = 0 ; i < query . length ; i +  +  ) q . defer ( function ( token , done )  {%NWL%options . cache . getall ( options . getter ,  ' degen '  ,  [ token ]  , done )  ;%NWL%}  , query [ i ]  )  ; %NWL%q . awaitAll ( function ( err , queryDegens )  {%NWL%if ( err ) return callback ( err )  ; %NWL%options . cache . phrasematchDegens ( queryDegens , function ( err , ret )  {%NWL%if ( err ) return callback ( err )  ; %NWL%options . queryidx = ret . queryidx ; %NWL%options . querymask = ret . querymask ; %NWL%options . querydist = ret . querydist ; %NWL%8
break ; %NWL%case " dashed "  : chartObject . border_between_chart_elements_style =  " 5 , 5 "  ; %NWL%break ; %NWL%default : chartObject . border_between_chart_elements_style =  " 0 "  ; %NWL%break ;%NWL%}%NWL%chartObject . highlight = options . highlight ? options . highlight : stylesheet . highlight ; %NWL%chartObject . label_size =  " label_size " in options ? options . label_size : stylesheet . label_size ; %NWL%chartObject . label_color = options . label_color ? options . label_color : stylesheet . label_color ; %NWL%chartObject . label_weight = options . label_weight ? options . label_weight . toLowerCase (  )  : stylesheet . label_weight ; %NWL%chartObject . label_family = options . label_family ? options . label_family . toLowerCase (  )  : stylesheet . label_family ; %NWL%9
var z2 = this . z . square (  )  , z4 = z2 . square (  )  , z6 = z4 . mul ( z2 )  ; %NWL%return this . y . square (  )  . equals (%NWL%this . curve . b . mul ( z6 )  . add ( this . x . mul (%NWL%this . curve . a . mul ( z4 )  . add ( this . x . square (  )  )  )  )  )  ;%NWL%}%NWL%}  ; %NWL%sjcl . ecc . curve = function ( Field , r , a , b , x , y )  {%NWL%this . field = Field ; %NWL%this . r = new sjcl . bn ( r )  ; %NWL%this . a = new Field ( a )  ; %NWL%this . b = new Field ( b )  ; %NWL%9
if ( !defined ( this . _va )  )  {%NWL%this . _va = getVertexArray ( context )  ;%NWL%}%NWL%var boundingSphereDirty = false ; %NWL%var radii = this . radii ; %NWL%if ( !Cartesian3 . equals ( this . _radii , radii )  )  {%NWL%Cartesian3 . clone ( radii , this . _radii )  ; %NWL%var r = this . _oneOverEllipsoidRadiiSquared ; %NWL%r . x = 1 . 0 /  ( radii . x * radii . x )  ; %NWL%r . y = 1 . 0 /  ( radii . y * radii . y )  ; %NWL%r . z = 1 . 0 /  ( radii . z * radii . z )  ; %NWL%8
if ( tizen1_utils . isValidArray ( m . cc )  )  {%NWL%newm . cc = m . cc . slice ( 0 )  ;%NWL%} else {%NWL%return false ;%NWL%}%NWL%}%NWL%if (  ( m . bcc =  =  = null ) || ( m . bcc =  =  = undefined )  )  {%NWL%newm . bcc =  [  ]  ;%NWL%} else {%NWL%if ( tizen1_utils . isValidArray ( m . bcc )  )  {%NWL%newm . bcc = m . bcc . slice ( 0 )  ; %NWL%1
node = this . visit ( node )  ; %NWL%if (  ' property '  =  = node . nodeName )  {%NWL%props . push ( node )  ;%NWL%} else {%NWL%other . push ( node )  ;%NWL%}%NWL%}  , this )  ; %NWL%if ( props . length )  {%NWL%var selfLiteral = new nodes . Literal (  ' & '  )  ; %NWL%selfLiteral . lineno = media . lineno ; %NWL%selfLiteral . filename = media . filename ; %NWL%9
var session = this . session ; %NWL%var sel = session . multiSelect ; %NWL%var all = sel . ranges ; %NWL%for ( var i = all . length ; i -  -  ;  )  {%NWL%var range = all [ i ]  ; %NWL%if ( range . isEmpty (  )  )  {%NWL%var tmp = session . getWordRange ( range . start . row , range . start . column )  ; %NWL%range . start . row = tmp . start . row ; %NWL%range . start . column = tmp . start . column ; %NWL%range . end . row = tmp . end . row ; %NWL%range . end . column = tmp . end . column ; %NWL%8
}  ; %NWL%Y . extend ( IEEventFacade , Y . DOM2EventFacade , proto )  ; %NWL%Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%9
c . x = x ; %NWL%c . y = y ; %NWL%this . emit (  ' cursormove '  , x , y )  ;%NWL%}%NWL%return this ;%NWL%}  ; %NWL%TermState . prototype . resize = function ( size )  {%NWL%var line ; %NWL%this . _removeLine ( 0 , Math . max ( 0 , this . rows - size . rows )  )  ; %NWL%this . rows = size . rows ; %NWL%this . columns = size . columns ; %NWL%9
return modify ( value , parameters )  ;%NWL%}  ;%NWL%}%NWL%}%NWL%}%NWL%}  )  ; %NWL%for ( var operator in Semantics . operators )  {%NWL%PropertyValidationSemantics . operators [ operator ]  = Semantics . operators [ operator ]  ;%NWL%}%NWL%for ( var evaluator in Semantics . evaluators )  {%NWL%PropertyValidationSemantics . evaluators [ evaluator ]  = Semantics . evaluators [ evaluator ]  ; %NWL%7
function saveOptions (  )%NWL%{%NWL%console . log (  " saving options "  )  ; %NWL%localStorage . broker = document . getElementById (  " broker "  )  . value ; %NWL%localStorage . port = document . getElementById (  " port "  )  . value ; %NWL%localStorage . username = document . getElementById (  " username "  )  . value ; %NWL%localStorage . password = document . getElementById (  " password "  )  . value ; %NWL%localStorage . reconnectTimeout = document . getElementById (  " reconnectTimeout "  )  . value ; %NWL%localStorage . subtopic = document . getElementById (  " subtopic "  )  . value ; %NWL%localStorage . clearNotifications = document . getElementById (  " clearNotifications "  )  . checked ; %NWL%localStorage . notificationTimeout = document . getElementById (  " notificationTimeout "  )  . value ; %NWL%3
includes . push ( inc )  ;%NWL%} else {%NWL%if ( include . where =  = null )  {%NWL%include . where = inc . where ;%NWL%} else if ( inc . where ! = null )  {%NWL%var where =  {  }  ; %NWL%where [ that . op . key ]  =  [ include . where , inc . where ]  ; %NWL%include . where = where ;%NWL%}%NWL%if ( include . attributes =  = null || include . attributes . length =  = 0 )  {%NWL%include . attributes = inc . attributes ; %NWL%3
return true ;%NWL%}%NWL%if ( !a || !b )  {%NWL%return false ;%NWL%}%NWL%return a . start =  = b . start && a . end =  = b . end ;%NWL%}  ; %NWL%Range . hasIntersection = function Range$hasIntersection ( a , b )  {%NWL%return Math . max ( a . start , b . start )  <  = Math . min ( a . end , b . end )  ;%NWL%}  ; %NWL%Range . intersection = function Range$intersection ( a , b )  {%NWL%7
this . _super = _super ; %NWL%this . _superApply = _superApply ; %NWL%if ( _continue )%NWL%this . _superStop = _superStop ; %NWL%var _ret = _call . apply ( this , arguments )  ; %NWL%if ( _continue )  {%NWL%__ret = _super . apply ( this , arguments )  ; %NWL%if ( typeof ( _ret )  =  =  ' undefined '  ) _ret = __ret ;%NWL%}%NWL%this . _super = __super ; %NWL%this . _superApply = __superApply ; %NWL%9
this . context . save (  )  ; %NWL%this . context . scale (  - 1 , 1 )  ; %NWL%this . context . drawImage ( copy ,  ( copy . width *  - 1 )  , 0 , copy . width , copy . height )  ; %NWL%this . context . restore (  )  ; %NWL%copy = null ;%NWL%}  ; %NWL%Layer . prototype . flipY = function (  )  {%NWL%if ( !this . context )  { return ;  }%NWL%var copy = document . createElement (  " canvas "  )  ; %NWL%copy . width = this . canvas . width ; %NWL%copy . height = this . canvas . height ; %NWL%9
resourceful . Resource   = require (  '  .  / resourceful / resource '  )  . Resource ; %NWL%resourceful . define   = require (  '  .  / resourceful / core '  )  . define ; %NWL%resourceful . defineProperty = require (  '  .  / resourceful / core '  )  . defineProperty ; %NWL%resourceful . init    = require (  '  .  / resourceful / init '  )  ; %NWL%resourceful . use    = require (  '  .  / resourceful / core '  )  . use ; %NWL%resourceful . connect   = require (  '  .  / resourceful / core '  )  . connect ; %NWL%resourceful . connection  = require (  '  .  / resourceful / core '  )  . connection ; %NWL%resourceful . resources   = require (  '  .  / resourceful / core '  )  . resources ; %NWL%resourceful . register   = require (  '  .  / resourceful / core '  )  . register ; %NWL%resourceful . unregister  = require (  '  .  / resourceful / core '  )  . unregister ; %NWL%resourceful . engines   = require (  '  .  / resourceful / engines '  )  ; %NWL%3
if ( required )  {%NWL%this . required = true ;%NWL%}  ; %NWL%if ( !this . err )  {%NWL%this . err = element . getAttribute (  ' err '  )  ;%NWL%}  ; %NWL%if ( !this . equals )  {%NWL%this . equals = element . getAttribute (  ' equals '  )  ;%NWL%}  ; %NWL%if ( !this . callback )  {%NWL%this . callback = element . getAttribute (  ' callback '  )  ; %NWL%4
pack . dependencies [ key ]  = frameworkDeps [ key ]  ;%NWL%}%NWL%pack . name = config . machineName ; %NWL%if ( config . author )  {%NWL%pack . author = config . author ;%NWL%} else {%NWL%delete pack . author ;%NWL%}%NWL%pack . dependencies = sortObjectKeysAlphabetically ( pack . dependencies )  ; %NWL%pack . devDependencies = sortObjectKeysAlphabetically ( pack . devDependencies )  ; %NWL%pack . jshintConfig = sortObjectKeysAlphabetically ( pack . jshintConfig )  ; %NWL%8
return function ( config )  {%NWL%this . highDPISupport = config . highDPISupport || true ; %NWL%this . shadows = config . shadows || false ; %NWL%this . shadowDistance = config . shadowDistance || 20 ; %NWL%this . shadowNearMultiplier = config . shadowNearMultiplier || 2 . 0 ; %NWL%this . shadowMapQuality = config . shadowMapQuality || 1 . 0 ; %NWL%this . maxNumerOfLights = typeof ( config . maxNumerOfLights )  =  =  =  ' number ' ? config . maxNumerOfLights : 1 ; %NWL%this . enableDebugContext = typeof ( config . enableDebugContext )  =  =  =  ' boolean ' ? config . enableDebugContext  : false ; %NWL%this . preserveDrawingBuffer = config . preserveDrawingBuffer || false ; %NWL%this . alpha = typeof ( config . alpha )  =  =  =  ' boolean ' ? config . alpha : true ; %NWL%this . depth = typeof ( config . depth )  =  =  =  ' boolean ' ? config . depth : true ; %NWL%9
}  )  ;%NWL%}  ; %NWL%var Thing = function ( deviceID , deviceUID , info )  {%NWL%var self = this ; %NWL%self . whatami = info . deviceType ; %NWL%self . deviceID = deviceID . toString (  )  ; %NWL%self . deviceUID = deviceUID ; %NWL%self . name = info . params . name ; %NWL%self . ws = info . params . ws ; %NWL%self . clientSerialNo = self . ws . clientInfo . clientSerialNo ; %NWL%self . thingID = info . params . thingID ; %NWL%7
var dates =  {  ' min '  : 0 ,  ' max '  : 0 }  ; %NWL%dates [  ' max '  ]  = data [  ' max_date_data_received '  ]  * 1000 ; %NWL%dates [  ' min '  ]  = data [  ' start '  ]  * 1000 ; %NWL%return dates ;%NWL%}  ,%NWL%getSliderValues : function ( project , projectData )  {%NWL%var values =  {  ' min '  : 0 ,  ' max '  : 0 }  ; %NWL%if ( this . sliders [ project ]  . el ! = undefined )  {%NWL%var dates = this . sliders [ project ]  . el . dateRangeSlider (  ' values '  )  ; %NWL%values . min = parseInt ( dates . min . getTime (  )  )  ; %NWL%values . max = parseInt ( dates . max . getTime (  )  )  ; %NWL%9
href = less . modules . path . join ( currentFileInfo . currentDirectory , file )  ;%NWL%}%NWL%var path = less . modules . path . dirname ( href )  ; %NWL%var newFileInfo =  {%NWL%currentDirectory : path +  '  /  '  ,%NWL%filename : href%NWL%}  ; %NWL%if ( currentFileInfo )  {%NWL%newFileInfo . entryPath = currentFileInfo . entryPath ; %NWL%newFileInfo . rootpath = currentFileInfo . rootpath ; %NWL%newFileInfo . rootFilename = currentFileInfo . rootFilename ; %NWL%8
MutationObserver . name =  ' MutationObserver '  ; %NWL%MutationRecord . prototype . constructor = MutationRecord ; %NWL%MutationRecord . name =  ' MutationRecord '  ; %NWL%function copyMutationRecord ( original )  {%NWL%var record = new MutationRecord ( original . type , original . target )  ; %NWL%record . addedNodes = original . addedNodes . slice (  )  ; %NWL%record . removedNodes = original . removedNodes . slice (  )  ; %NWL%record . previousSibling = original . previousSibling ; %NWL%record . nextSibling = original . nextSibling ; %NWL%record . attributeName = original . attributeName ; %NWL%record . attributeNamespace = original . attributeNamespace ; %NWL%7
proto . parseError = function ( token , value )  {%NWL%this . onError ( new Error (  " Unexpected "  + toknam ( token )  +  ( value ? (  "  (  "  + JSON . stringify ( value )  +  "  )  "  )  :  "  "  )  +  " in state "  + toknam ( this . state )  )  )  ;%NWL%}  ; %NWL%proto . push = function (  )  {%NWL%this . stack . push (  { value : this . value , key : this . key , mode : this . mode }  )  ;%NWL%}  ; %NWL%proto . pop = function (  )  {%NWL%var value = this . value ; %NWL%var parent = this . stack . pop (  )  ; %NWL%this . value = parent . value ; %NWL%this . key = parent . key ; %NWL%9
obj . _type = this . _type ; %NWL%obj . _settings = internals . concatSettings ( this . _settings )  ; %NWL%obj . _valids = Hoek . clone ( this . _valids )  ; %NWL%obj . _invalids = Hoek . clone ( this . _invalids )  ; %NWL%obj . _tests = this . _tests . slice (  )  ; %NWL%obj . _refs = this . _refs . slice (  )  ; %NWL%obj . _flags = Hoek . clone ( this . _flags )  ; %NWL%obj . _description = this . _description ; %NWL%obj . _unit = this . _unit ; %NWL%obj . _notes = this . _notes . slice (  )  ; %NWL%obj . _tags = this . _tags . slice (  )  ; %NWL%4
module . exports = Competition ;%NWL%}  ,  {  "  .  / LevenshteinDistanceScore "  : 18 ,  "  .  / Array "  : 11 }  ]  , 11 :  [ function ( require , module , exports )  {%NWL%var fn = require (  '  .  / fn '  )  ; %NWL%module . exports = function ( obj )  {%NWL%function ensure_array ( obj )  {%NWL%var array = obj ? [  ]  . concat ( obj )  :  [  ]  ; %NWL%array . in_array = fn . curry ( array , in_array , array )  ; %NWL%array . each = fn . curry ( array , each , array )  ; %NWL%array . eachAsync = fn . curry ( array , eachAsync , array )  ; %NWL%array . collect = fn . curry ( array , collect , array )  ; %NWL%array . flatten = fn . curry ( array , flatten , array )  ; %NWL%6
}%NWL%return config ;%NWL%}  ,%NWL%_getRoot = function ( node , subscriber )  {%NWL%return subscriber . _extra . root || ( node . get ( NODE_TYPE )  =  =  = 9 ) ? node : node . get ( OWNER_DOCUMENT )  ;%NWL%}  ,%NWL%_normTouchFacade = function ( touchFacade , touch , params )  {%NWL%touchFacade . pageX = touch . pageX ; %NWL%touchFacade . pageY = touch . pageY ; %NWL%touchFacade . screenX = touch . screenX ; %NWL%touchFacade . screenY = touch . screenY ; %NWL%7
sensorDefinitions . goLinkLight . sensorName = i18n . t (  " sensor . names . goLinkLight "  )  ; %NWL%sensorDefinitions . goLinkForce . measurementName = i18n . t (  " sensor . measurements . force "  )  ; %NWL%sensorDefinitions . goLinkForce . sensorName = i18n . t (  " sensor . names . goLinkForce "  )  ; %NWL%sensorDefinitions . goLinkPH . measurementName = i18n . t (  " sensor . measurements . acidity "  )  ; %NWL%sensorDefinitions . goLinkPH . sensorName = i18n . t (  " sensor . names . goLinkPH "  )  ; %NWL%sensorDefinitions . goLinkCO2 . measurementName = i18n . t (  " sensor . measurements . CO2_concentration "  )  ; %NWL%sensorDefinitions . goLinkCO2 . sensorName = i18n . t (  " sensor . names . goLinkCO2 "  )  ; %NWL%sensorDefinitions . goLinkO2 . measurementName = i18n . t (  " sensor . measurements . O2_concentration "  )  ; %NWL%sensorDefinitions . goLinkO2 . sensorName = i18n . t (  " sensor . names . goLinkO2 "  )  ; %NWL%sensorDefinitions . labQuestMotion . measurementName = i18n . t (  " sensor . measurements . distance "  )  ; %NWL%sensorDefinitions . labQuestMotion . sensorName = i18n . t (  " sensor . names . labQuestMotion "  )  ; %NWL%0
air . SharedObjectFlushStatus = window . runtime . flash . net . SharedObjectFlushStatus ; %NWL%air . Capabilities = window . runtime . flash . system . Capabilities ; %NWL%air . System = window . runtime . flash . system . System ; %NWL%air . Security = window . runtime . flash . system . Security ; %NWL%air . Updater = window . runtime . flash . desktop . Updater ; %NWL%air . Clipboard = window . runtime . flash . desktop . Clipboard ; %NWL%air . ClipboardFormats = window . runtime . flash . desktop . ClipboardFormats ; %NWL%air . ClipboardTransferMode = window . runtime . flash . desktop . ClipboardTransferMode ; %NWL%air . NativeDragManager = window . runtime . flash . desktop . NativeDragManager ; %NWL%air . NativeDragOptions = window . runtime . flash . desktop . NativeDragOptions ; %NWL%air . NativeDragActions = window . runtime . flash . desktop . NativeDragActions ; %NWL%4
mn =  { x : Infinity , y : Infinity }  ,%NWL%mx =  { x :  - Infinity , y :  - Infinity }  ,%NWL%total = g . nodes (  )  . length ; %NWL%layout . eachNode ( function ( k , layoutInfo )  {%NWL%var x = layoutInfo . x ; %NWL%var y = layoutInfo . y ; %NWL%node = g . node ( k )  ; %NWL%node . x = x ; %NWL%node . y = y ; %NWL%node . predecessors = g . predecessors ( k )  ; %NWL%node . successors = g . successors ( k )  ; %NWL%9
clone . origin =  ( this . origin && this . origin . slice (  )  )  ; %NWL%clone . frustum =  ( this . frustum && this . frustum . slice (  )  )  ; %NWL%clone . frustumNear = this . frustumNear ; %NWL%clone . center =  ( this . center && this . center . slice (  )  )  ; %NWL%clone . halfExtents =  ( this . halfExtents && this . halfExtents . slice (  )  )  ; %NWL%clone . radius = this . radius ; %NWL%clone . shadows = this . shadows ; %NWL%clone . dynamicshadows = this . dynamicshadows ; %NWL%clone . disabled = this . disabled ; %NWL%clone . dynamic = this . dynamic ; %NWL%clone . techniqueParameters = this . techniqueParameters ; %NWL%2
result . nearValue = array [ startingIndex +  +  ]  ; %NWL%result . far = array [ startingIndex +  +  ]  ; %NWL%result . farValue = array [ startingIndex ]  ; %NWL%return result ;%NWL%}  ; %NWL%NearFarScalar . equals = function ( left , right )  {%NWL%return ( left =  =  = right ) ||%NWL%(  ( defined ( left )  ) &&%NWL%( defined ( right )  ) &&%NWL%( left . near =  =  = right . near ) &&%NWL%( left . nearValue =  =  = right . nearValue ) &&%NWL%9
220 : 92 ,%NWL%221 : 93 ,%NWL%222 : 39 ,%NWL%229 : 113%NWL%}  ; %NWL%var evtCopyKey = has (  " mac "  ) ? " metaKey "  :  " ctrlKey "  ; %NWL%var _synthesizeEvent = function ( evt , props )  {%NWL%var faux = lang . mixin (  {  }  , evt , props )  ; %NWL%setKeyChar ( faux )  ; %NWL%faux . preventDefault = function (  )  { evt . preventDefault (  )  ;  }  ; %NWL%faux . stopPropagation = function (  )  { evt . stopPropagation (  )  ;  }  ; %NWL%9
this . callout = $ (  '  < div id =  " BetterZoom - callout "  >  <  / div >  '  )  ; %NWL%this . header = $ (  '  < div id =  " BetterZoom - header "  >  <  / div >  '  )  ; %NWL%this . title = $ (  '  < span id =  " BetterZoom - title "  > BetterZoom <  / div >  '  )  ; %NWL%this . toolbar = $ (  '  < div id =  " BetterZoom - toolbar "  >  <  / div >  '  )  ; %NWL%this . albumInfo = $ (  '  < span id =  " BetterZoom - albumInfo "  >  <  / div >  '  )  ; %NWL%this . closeButton =%NWL%$ (  '  < div id =  " BetterZoom - close "  > &times ;  <  / div >  '  )%NWL%. click ( BZ . hideMedia )  ; %NWL%this . header . append ( this . title , this . toolbar , this . albumInfo , this . closeButton )  ; %NWL%this . mediaContainer = $ (  '  < div id =  " BetterZoom - media "  >  '  )  ; %NWL%this . loader = $ (  '  < div id =  " BetterZoom - loader "  >  <  / div >  '  )  ; %NWL%0
_cstracker . initTracker ( _inputcanvas , cRectangle )  ;%NWL%}%NWL%_curtracked = result ; %NWL%if ( result . detection =  =  " CS " && params . sendEvents )  {%NWL%var evt = document . createEvent (  " Event "  )  ; %NWL%evt . initEvent (  " facetrackingEvent "  , true , true )  ; %NWL%evt . height = result . height ; %NWL%evt . width = result . width ; %NWL%evt . angle = result . angle ; %NWL%evt . x = result . x ; %NWL%evt . y = result . y ; %NWL%6
if (  ( typeof locale =  =  ' number ' || typeof locale =  =  ' string '  ) && timezone =  = null )  {%NWL%timezone = locale ; %NWL%locale = undefined ;%NWL%}%NWL%return _strftime ( fmt , d , locale ,  { timezone : timezone }  )  ;%NWL%}%NWL%namespace . strftimeUTC = strftime . strftimeUTC = strftimeUTC ; %NWL%function strftimeUTC ( fmt , d , locale )  {%NWL%return _strftime ( fmt , d , locale ,  { utc : true }  )  ;%NWL%}%NWL%namespace . localizedstrftime = strftime . localizedstrftime = localizedstrftime ; %NWL%6
}  ; %NWL%proto . scale = function ( scale )  {   /  / cc . kmQuaternionScale%NWL%this . x *  = scale ; %NWL%this . y *  = scale ; %NWL%this . z *  = scale ; %NWL%this . w *  = scale ; %NWL%return this ;%NWL%}  ; %NWL%proto . assignFrom = function ( quaternion )  {   /  /  = cc . kmQuaternionAssign%NWL%this . x = quaternion . x ; %NWL%this . y = quaternion . y ; %NWL%9
self . headers [  ' content - type '  ]  = mimetypes . lookup ( src . path . slice ( src . path . lastIndexOf (  '  .  '  )  + 1 )  )%NWL%} else {%NWL%if ( src . headers )  {%NWL%for ( var i in src . headers )  {%NWL%if ( !self . headers [ i ]  )  {%NWL%self . headers [ i ]  = src . headers [ i ]%NWL%}%NWL%}%NWL%}%NWL%if ( src . method && !self . method )  {%NWL%self . method = src . method%NWL%5
}%NWL%return method ( opts , callback )  ;%NWL%}%NWL%return d ;%NWL%}%NWL%de = def ( request )  ; %NWL%de . get = def ( request . get )  ; %NWL%de . post = def ( request . post )  ; %NWL%de . put = def ( request . put )  ; %NWL%de . head = def ( request . head )  ; %NWL%de . del = def ( request . del )  ; %NWL%6
this . lastColumnWidth = 0 ;%NWL%}  ; %NWL%DocumentContext . prototype . beginColumn = function ( width , offset , endingCell )  {%NWL%var saved = this . snapshots [ this . snapshots . length - 1 ]  ; %NWL%this . calculateBottomMost ( saved )  ; %NWL%this . endingCell = endingCell ; %NWL%this . page = saved . page ; %NWL%this . x = this . x + this . lastColumnWidth +  ( offset || 0 )  ; %NWL%this . y = saved . y ; %NWL%this . availableWidth = width ; 	 /  / saved . availableWidth - offset ; %NWL%this . availableHeight = saved . availableHeight ; %NWL%6
return childMap ;%NWL%}  ; %NWL%function getDepField ( fields , dep )  {%NWL%return util . find ( fields , function ( field )  {%NWL%return field . pathName =  =  = dep . path && field . id =  =  = dep . field ;%NWL%}  ) || null ;%NWL%}%NWL%function Field ( props )  {%NWL%this . path = props . path ; %NWL%this . id = props . id ; %NWL%this . key = props . key ; %NWL%8
_preferences . y   =  parseInt ( this . ui . css (  ' top '  )  , 10 )  ; %NWL%_preferences . x   =  parseInt ( this . ui . css (  ' left '  )  , 10 )  ; %NWL%_preferences . save (  )  ;%NWL%}  ; %NWL%ChatRoomCreate . show = function showSetup (  )%NWL%{%NWL%this . ui . show (  )  ; %NWL%this . ui . find (  '  . title '  )  . focus (  )  ; %NWL%_preferences . show = true ;%NWL%}  ; %NWL%ChatRoomCreate . hide = function hideSetup (  )%NWL%4
cHelpers . log =  {%NWL%warn : function ( msg )  { localGrunt . log . warn ( msg )  ;  }  ,%NWL%info : function ( msg )  { localGrunt . log . writeln ( msg )  ;  }  ,%NWL%error : function ( msg )  { localGrunt . log . error ( msg )  ;  }  ,%NWL%debug : function ( debug , msg )  {%NWL%if ( !debug ) return ; %NWL%localGrunt . log . writeln (  ' debug :  :  '  . blue + msg )  ;%NWL%}%NWL%}  ; %NWL%cTools . helpers = taskLib . helpers ; %NWL%cTools . builder = taskLib . builder ; %NWL%9
style . width = w ; %NWL%style . height = h ; %NWL%style . x = left ; %NWL%style . y = top ; %NWL%if ( fillColors )%NWL%{%NWL%style . fill . color = fillColors [ i % fillColors . length ]  ;%NWL%}%NWL%if ( borderColors )%NWL%{%NWL%style . border . color = borderColors [ i % borderColors . length ]  ; %NWL%6
}  )  ; %NWL%return filter [ 0 ]  ;%NWL%}%NWL%function _fnFilterComplete ( oSettings , oInput , iForce )%NWL%{%NWL%var oPrevSearch = oSettings . oPreviousSearch ; %NWL%var aoPrevSearch = oSettings . aoPreSearchCols ; %NWL%var fnSaveFilter = function ( oFilter )  {%NWL%oPrevSearch . sSearch = oFilter . sSearch ; %NWL%oPrevSearch . bRegex = oFilter . bRegex ; %NWL%oPrevSearch . bSmart = oFilter . bSmart ; %NWL%8
shape ,%NWL%queue = this . _shapes ,%NWL%box =  {  }  ; %NWL%for ( i in queue )%NWL%{%NWL%if ( queue . hasOwnProperty ( i )  )%NWL%{%NWL%shape = queue [ i ]  ; %NWL%bounds = shape . getBounds (  )  ; %NWL%box . left = Y_LANG . isNumber ( box . left ) ? Math . min ( box . left , bounds . left )  : bounds . left ; %NWL%box . top = Y_LANG . isNumber ( box . top ) ? Math . min ( box . top , bounds . top )  : bounds . top ; %NWL%9
this . _storeRefPropName =  " _S "  ;  /  / Default name for the store reference to attach to every item .%NWL%this . _itemNumPropName =  " _0 "  ;  /  / Default Item Id for isItem to attach to every item .%NWL%this . _rootItemPropName =  " _RI "  ;  /  / Default Item Id for isItem to attach to every item .%NWL%this . _reverseRefMap =  " _RRM "  ;  /  / Default attribute for constructing a reverse reference map for use with reference integrity%NWL%this . _loadInProgress = false ;  /  / Got to track the initial load to prevent duelling loads of the dataset .%NWL%this . _queuedFetches =  [  ]  ; %NWL%if ( keywordParameters . urlPreventCache ! =  = undefined )  {%NWL%this . urlPreventCache = keywordParameters . urlPreventCache?true : false ;%NWL%}%NWL%if ( keywordParameters . hierarchical ! =  = undefined )  {%NWL%this . hierarchical = keywordParameters . hierarchical?true : false ; %NWL%7
this . feature_list = new App . FeatureList (  {%NWL%el : $ (  ' #features '  )%NWL%}  )  ;%NWL%}%NWL%return App ;%NWL%}  )  ( Spine . Controller )  ; %NWL%App . FeatureList =  ( function ( _super )  {%NWL%__extends ( FeatureList , _super )  ; %NWL%function FeatureList (  )  {%NWL%this . reload = __bind ( this . reload , this )  ; %NWL%this . addAll = __bind ( this . addAll , this )  ; %NWL%9
}%NWL%}  )%NWL%}  ,%NWL%update : function ( req , res )  {%NWL%User . findOne (  { _id : req . body . user . id }  , function ( error , user )  {%NWL%if ( error )  {%NWL%var user = new User (  )  ; %NWL%user . firstName 	 = req . body . user . firstName ; %NWL%user . lastName 	 = req . body . user . lastName ; %NWL%user . username 	 = req . body . user . username ; %NWL%user . email 		 = req . body . user . email ; %NWL%7
this . distance =  ( distance ! =  = undefined ) ? distance : 0 ; %NWL%this . decay =  ( decay ! =  = undefined ) ? decay : 1 ; 	 /  / for physically correct lights , should be 2 .%NWL%}  ; %NWL%THREE . PointLight . prototype = Object . create ( THREE . Light . prototype )  ; %NWL%THREE . PointLight . prototype . constructor = THREE . PointLight ; %NWL%THREE . PointLight . prototype . clone = function (  )  {%NWL%var light = new THREE . PointLight (  )  ; %NWL%THREE . Light . prototype . clone . call ( this , light )  ; %NWL%light . intensity = this . intensity ; %NWL%light . distance = this . distance ; %NWL%light . decay = this . decay ; %NWL%8
settings . nodeMaster = nodeInfo . nodes [ nodeId ]  . settings [  ' node '  ]  . master ; %NWL%settings . nodeData = nodeInfo . nodes [ nodeId ]  . settings [  ' node '  ]  . data ;%NWL%}%NWL%if ( settings . nodeMaster =  =  = undefined && settings . nodeData =  =  = undefined )  {%NWL%settings . nodeMaster = true ; %NWL%settings . nodeData = true ;%NWL%}%NWL%settings . clusterName = nodeInfo . nodes [ nodeId ]  . settings [  ' cluster '  ]  . name ; %NWL%settings . logPath = nodeInfo . nodes [ nodeId ]  . settings [  ' path '  ]  . logs ; %NWL%settings . http_address = nodeInfo . nodes [ nodeId ]  . http_address ; %NWL%settings . host = nodeInfo . nodes [ nodeId ]  . host ; %NWL%9
=  = this . options . currentMasterData [ c ]  . clRef )%NWL%{%NWL%val = a ; %NWL%column = this . options . currentMasterData [ c ]  . clField ;%NWL%}%NWL%} else if ( this . options . currentMasterData [ c ]  . type =  =  " external "  )  {%NWL%val =  ' __external '  ; %NWL%extData . url = this . options . currentMasterData [ c ]  . url ; %NWL%extData . root = this . options . currentMasterData [ c ]  . root ; %NWL%extData . label = this . options . currentMasterData [ c ]  . label ; %NWL%extData . value = this . options . currentMasterData [ c ]  . value ; %NWL%7
returnValue . expiresAt = options . expiresAt ;%NWL%}%NWL%else if ( typeof options . hoursToLive =  =  =  ' number ' && options . hoursToLive ! =  = 0 )%NWL%{%NWL%expireDate = new Date (  )  ; %NWL%expireDate . setTime ( expireDate . getTime (  )  +  ( options . hoursToLive * 60 * 60 * 1000 )  )  ; %NWL%returnValue . expiresAt = expireDate ;%NWL%}%NWL%if ( typeof options . path =  =  =  ' string ' && options . path ! =  =  '  '  )%NWL%{%NWL%returnValue . path = options . path ; %NWL%0
return - 1 ;%NWL%}  ; %NWL%__protocol . PROTOCOL_6 = PROTOCOL_6 =  ' http :  /  / livereload . com / protocols / official - 6 '  ; %NWL%__protocol . PROTOCOL_7 = PROTOCOL_7 =  ' http :  /  / livereload . com / protocols / official - 7 '  ; %NWL%__protocol . ProtocolError = ProtocolError =  ( function (  )  {%NWL%function ProtocolError ( reason , data )  {%NWL%this . message =  " LiveReload protocol error (  "  + reason +  "  ) after receiving data : \ "  "  + data +  " \ "  .  "  ;%NWL%}%NWL%return ProtocolError ;%NWL%}  )  (  )  ; %NWL%__protocol . Parser = Parser =  ( function (  )  {%NWL%4
function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%3
if ( google . loader . ClientLocation . address . country && google . loader . ClientLocation . address . country ! =  '  -  ' && google . loader . ClientLocation . address . country ! =  ' NaN '  )%NWL%result . country = google . loader . ClientLocation . address . country ; %NWL%if ( google . loader . ClientLocation . address . city && google . loader . ClientLocation . address . city ! =  '  -  ' && google . loader . ClientLocation . address . city ! =  ' NaN '  )%NWL%result . city = google . loader . ClientLocation . address . city ; %NWL%if ( google . loader . ClientLocation . address . region && google . loader . ClientLocation . address . region ! =  '  -  ' && google . loader . ClientLocation . address . region ! =  ' NaN '  )%NWL%result . region = google . loader . ClientLocation . address . region ;%NWL%}%NWL%if ( google . loader . ClientLocation . latitude )%NWL%result . latitude = google . loader . ClientLocation . latitude ; %NWL%if ( google . loader . ClientLocation . latitude )%NWL%result . longitude = google . loader . ClientLocation . longitude ; %NWL%8
position =  [  " before "  ,  " after "  ]  ;%NWL%} else if ( angle < 2 * Math . PI - pi4 )  {%NWL%position =  [  " above "  ,  " below "  ]  ;%NWL%}%NWL%break ;%NWL%}%NWL%var lt = dojo . coords ( this . chart . node , true )  ; %NWL%aroundRect . x +  = lt . x ; %NWL%aroundRect . y +  = lt . y ; %NWL%aroundRect . x = Math . round ( aroundRect . x )  ; %NWL%aroundRect . y = Math . round ( aroundRect . y )  ; %NWL%9
define_keywords (  " $alternative "  ,  " $completer "  ,  " $doc "  ,  " $post_data "  ,%NWL%" $require_match "  )  ; %NWL%function webjump ( name , handler )  {%NWL%keywords ( arguments ,%NWL%$alternative = null ,%NWL%$require_match = false )  ; %NWL%this . name = name ; %NWL%this . alternative = arguments . $alternative ; %NWL%this . completer = arguments . $completer ; %NWL%this . doc = arguments . $doc ; %NWL%this . post_data = arguments . $post_data ; %NWL%7
}%NWL%if ( typeof syntax . tokens ! =  =  ' undefined '  )  {%NWL%if ( syntax . tokens . length > 0 )  {%NWL%options . range =  ( typeof syntax . tokens [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . tokens [ 0 ]  . loc ! =  =  ' undefined '  )  ;%NWL%}%NWL%}%NWL%if ( typeof syntax . comments ! =  =  ' undefined '  )  {%NWL%if ( syntax . comments . length > 0 )  {%NWL%options . range =  ( typeof syntax . comments [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . comments [ 0 ]  . loc ! =  =  ' undefined '  )  ; %NWL%9
if ( settings . debugInfo )  {%NWL%options . dumpLineNumbers =  " mediaquery "  ;%NWL%}%NWL%if ( settings . lineComments && settings . debugInfo )  {%NWL%options . dumpLineNumbers =  " all "  ;%NWL%}%NWL%if (  / compress /  . test ( settings . outputStyle )  )  {%NWL%options [ settings . outputStyle ]  = true ;%NWL%}%NWL%options . strictMath = settings . strictMath ; %NWL%options . strictUnits = settings . strictUnits ; %NWL%9
var deltax = Math . round ( Math . max ( deltax1 , deltax2 )  / snap )  * snap ; %NWL%props . width = Math . max ( 50 , dd . width - deltax )  ; %NWL%props . height = Math . max ( 50 * dd . height / dd . width , dd . height - deltax * dd . height / dd . width )  ; %NWL%props . left = dd . originalX + dd . width - props . width ; %NWL%props . top = dd . originalY +  ( dd . width - props . width )  * dd . height / dd . width ;%NWL%}%NWL%if ( dd . attr . indexOf (  " related - layout - box "  )  >  - 1 )  {%NWL%props . top = Math . min ( dd . limit . bottom , Math . max ( dd . limit . top , dd . offsetY )  )  ; %NWL%props . left = Math . min ( dd . limit . right , Math . max ( dd . limit . left , dd . offsetX )  )  ; %NWL%props . top = Math . round ( props . top / snap )  * snap ; %NWL%props . left = Math . round ( props . left / snap )  * snap ; %NWL%9
}%NWL%el . appendChild ( defs )  ; %NWL%if ( Ext . isSafari3 )  {%NWL%el . appendChild ( webkitRect )  ;%NWL%}%NWL%el . appendChild ( bgRect )  ; %NWL%container . appendChild ( el )  ; %NWL%me . el = Ext . get ( el )  ; %NWL%me . bgRect = Ext . get ( bgRect )  ; %NWL%if ( Ext . isSafari3 )  {%NWL%me . webkitRect = Ext . get ( webkitRect )  ; %NWL%7
domBuilder (  [  "  . editor$el "  ]  , this )  ; %NWL%this . editor = new Editor ( new Renderer ( this . el )  )  ; %NWL%var self = this ; %NWL%this . editor . on (  " focus "  , function (  )  {%NWL%self . leaf . select ( self )  ;%NWL%}  )  ; %NWL%new MultiSelect ( this . editor )  ; %NWL%this . editor . setTheme (  " ace / theme / ambiance "  )  ; %NWL%this . onload = this . onload . bind ( this )  ; %NWL%this . onchange = this . onchange . bind ( this )  ; %NWL%this . onsave = this . onsave . bind ( this )  ; %NWL%8
}  ; %NWL%exports . noCache = function noCache ( options )  {%NWL%options = options || {  }  ; %NWL%var whitelist = parseWhitelist ( options . whitelist )  ; %NWL%return function ( req , res , next )  {%NWL%if ( !isExempt ( whitelist , req . url )  )%NWL%res . header (  " Cache - Control "  ,  " no - cache "  )  ; %NWL%return next (  )  ;%NWL%}  ;%NWL%}  ; %NWL%exports . csrf = function csrf ( options )  {%NWL%1
doc . addEventListener (  ' dragenter '  , dragEnter , false )  ;   /  / entering the drop area , with a file%NWL%doc . addEventListener (  ' dragover '  , dragOver , false )  ;   /  / over the drop area , with a file%NWL%doc . addEventListener (  ' drop '  , drop , false )  ;     /  / dropping the file%NWL%eh . addEventListener (  ' click '  , ehClick , false )  ;     /  / clicking to select the color%NWL%arrow . addEventListener (  ' click '  , arrowClick , false )  ;   /  / clicking the information box%NWL%mGlass . className =  ' mGlass '  ; %NWL%if ( dbg ) console . log (  ' initialized .  '  )  ;%NWL%}%NWL%img . addEventListener (  ' load '  , function (  )  {%NWL%cnv . width    = img . width ; %NWL%cnv . height    = img . height ; %NWL%9
if ( fireArgs )  {%NWL%fireArgs [ 0 ]  = ef ;%NWL%}%NWL%} else {%NWL%if ( fireArgs )  {%NWL%fireArgs . unshift ( ef )  ;%NWL%}%NWL%}%NWL%ef . details = this . details ; %NWL%ef . target = this . originalTarget || this . target ; %NWL%ef . currentTarget = this . currentTarget ; %NWL%8
this . type = type || ' keypress '  ;%NWL%}%NWL%KeyEvent . prototype . toNative = function (  )  {%NWL%var event = document . createEventObject ? document . createEventObject (  )  : document . createEvent (  ' Events '  )  ; %NWL%if ( event . initEvent )  {%NWL%event . initEvent ( this . type , true , true )  ;%NWL%}%NWL%event . keyCode = this . keyCode ; %NWL%event . which = this . charCode || this . keyCode ; %NWL%event . shiftKey = this . shiftKey ; %NWL%event . metaKey = this . metaKey ; %NWL%7
throw new Error (  " Unable to load SMD from "  + args )  ;%NWL%}  )  ;%NWL%} else if ( args . smdStr )  {%NWL%this . processSmd ( dojo . eval (  "  (  "  + args . smdStr +  "  )  "  )  )  ;%NWL%} else {%NWL%if ( args . serviceUrl )  {%NWL%this . serviceUrl = args . serviceUrl ;%NWL%}%NWL%this . timeout = args . timeout || 3000 ; %NWL%if (  " strictArgChecks " in args )  {%NWL%this . strictArgChecks = args . strictArgChecks ; %NWL%6
var obj = getActiveXObject ( activeXDetectRules [ i ]  . name )  ; %NWL%if ( !obj . activeXError )  {%NWL%self . installed = true ; %NWL%version = activeXDetectRules [ i ]  . version ( obj )  ; %NWL%if ( version! =  - 1 )  {%NWL%var versionObj = parseActiveXVersion ( version )  ; %NWL%self . raw = versionObj . raw ; %NWL%self . major = versionObj . major ; %NWL%self . minor = versionObj . minor ; %NWL%self . revision = versionObj . revision ; %NWL%self . revisionStr = versionObj . revisionStr ; %NWL%6
exports . LinearRetryPolicyFilter = azureCommon . LinearRetryPolicyFilter ; %NWL%exports . ExponentialRetryPolicyFilter = azureCommon . ExponentialRetryPolicyFilter ; %NWL%exports . UserAgentFilter = azureCommon . UserAgentFilter ; %NWL%exports . ProxyFilter = azureCommon . ProxyFilter ; %NWL%exports . LogFilter = azureCommon . LogFilter ; %NWL%exports . isEmulated = function ( host )  {%NWL%return azureCommon . ServiceClient . isEmulated ( host )  ;%NWL%}  ; %NWL%var sdkconfig = azureCommon . SdkConfig ; %NWL%exports . config = sdkconfig ; %NWL%exports . configure = azureCommon . configure ; %NWL%0
break ;%NWL%}%NWL%return this . _cachedTextureMatrix ;%NWL%}  ; %NWL%Texture . prototype . clone = function (  )  {%NWL%var newTexture = new Texture ( this . _texture . url , this . getScene (  )  , this . _noMipmap , this . _invertY , this . _samplingMode )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%newTexture . wrapU = this . wrapU ; %NWL%newTexture . wrapV = this . wrapV ; %NWL%newTexture . coordinatesIndex = this . coordinatesIndex ; %NWL%6
orientation_changed (  )  ; %NWL%init_sprites (  )  ;%NWL%}%NWL%function setup_window_size (  )%NWL%{%NWL%var winWidth = $ ( window )  . width (  )  ; %NWL%var winHeight = $ ( window )  . height (  )  ; %NWL%mapview_canvas . width = winWidth - width_offset ; %NWL%mapview_canvas . height = winHeight - height_offset ; %NWL%buffer_canvas . width = Math . floor ( mapview_canvas . width * 1 . 5 )  ; %NWL%buffer_canvas . height = Math . floor ( mapview_canvas . height * 1 . 5 )  ; %NWL%9
module . exports = Node . define (  {%NWL%type :  ' COLUMN '  ,%NWL%constructor : function ( config )  {%NWL%Node . call ( this )  ; %NWL%this . name = config . name ; %NWL%this . property = config . property || config . name ; %NWL%this . alias = config . alias ; %NWL%this . star = config . star ; %NWL%this . asArray = config . asArray ; %NWL%this . aggregator = config . aggregator ; %NWL%this . table = config . table ; %NWL%4
}  ; %NWL%proto . load = function load (  )%NWL%{%NWL%this . request = platform . createRequest (  )  ; %NWL%this . request . addEventListener (  ' load '  , this )  ; %NWL%this . request . addEventListener (  ' error '  , this )  ; %NWL%this . request . open (  ' GET '  , this . url , true )  ; %NWL%if ( this . request . overrideMimeType ) this . request . overrideMimeType (  ' application / xml '  )  ; %NWL%this . request . send ( null )  ;%NWL%}  ; %NWL%proto . onXMLLoaded = function onXMLLoaded (  )%NWL%1
exports . readline = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . repl = require . resolve (  '  .  / _empty . js '  )  ; %NWL%exports . stream = require . resolve (  ' stream - browserify '  )  ; %NWL%exports . _stream_duplex = require . resolve (  ' stream - browserify / duplex . js '  )  ; %NWL%exports . _stream_passthrough = require . resolve (  ' stream - browserify / passthrough . js '  )  ; %NWL%exports . _stream_readable = require . resolve (  ' stream - browserify / readable . js '  )  ; %NWL%exports . _stream_transform = require . resolve (  ' stream - browserify / transform . js '  )  ; %NWL%exports . _stream_writable = require . resolve (  ' stream - browserify / writable . js '  )  ; %NWL%exports . string_decoder = require . resolve (  ' string_decoder /  '  )  ; %NWL%exports . sys = require . resolve (  ' util / util . js '  )  ; %NWL%exports . timers = require . resolve (  ' timers - browserify '  )  ; %NWL%2
mixin ( lodash )  ; %NWL%lodash . clone = objects . clone ; %NWL%lodash . cloneDeep = objects . cloneDeep ; %NWL%lodash . contains = collections . contains ; %NWL%lodash . escape = utilities . escape ; %NWL%lodash . every = collections . every ; %NWL%lodash . find = collections . find ; %NWL%lodash . findIndex = arrays . findIndex ; %NWL%lodash . findKey = objects . findKey ; %NWL%lodash . findLast = collections . findLast ; %NWL%lodash . findLastIndex = arrays . findLastIndex ; %NWL%7
this . bind ( label , callback , options )  ;%NWL%}  ; %NWL%this . pop = function pop ( label )  {%NWL%this . unbind ( label )  ; %NWL%var index = _ . findLastIndex ( stack ,  { label : label . toLowerCase (  )  }  )  ; %NWL%if ( index ! =  =  - 1 )  {%NWL%this . bind ( label , stack [ index ]  . _callback , stack [ index ]  . opt )  ; %NWL%stack . splice ( index , 0 )  ;%NWL%}%NWL%}  ; %NWL%this . unbind = function unbind ( label )  {%NWL%2
}%NWL%RGraph . VProgress . prototype . Get = function ( name )%NWL%{%NWL%return this . properties [ name . toLowerCase (  )  ]  ;%NWL%}%NWL%RGraph . VProgress . prototype . Draw = function (  )%NWL%{%NWL%RGraph . FireCustomEvent ( this ,  ' onbeforedraw '  )  ; %NWL%RGraph . ClearEventListeners ( this . id )  ; %NWL%this . width  = this . canvas . width -  ( 2 * this . Get (  ' chart . gutter '  )  )  ; %NWL%this . height = this . canvas . height -  ( 2 * this . Get (  ' chart . gutter '  )  )  ; %NWL%9
" ReqHand "  )  ; %NWL%return ;%NWL%}%NWL%this . success ( session . getId (  )  , result . value )  ;%NWL%}  ,%NWL%_decorateResponse = function ( response )  {%NWL%response . setHeader (  " Cache "  ,  " no - cache "  )  ; %NWL%response . setHeader (  " Content - Type "  ,  " application / json ; charset = UTF - 8 "  )  ; %NWL%response . writeAndClose = _writeAndCloseDecorator ; %NWL%response . writeJSON = _writeJSONDecorator ; %NWL%response . writeJSONAndClose = _writeJSONAndCloseDecorator ; %NWL%8
json = Class . prototype . toJSON . call ( this , json )  ; %NWL%json . type = 1 ; %NWL%json . positionType = this . positionType ; %NWL%json . velocityType = this . velocityType ; %NWL%json . material = this . material ? this . material . name : undefined ; %NWL%json . position = this . position . toJSON ( json . position )  ; %NWL%json . positionSpread = this . positionSpread . toJSON ( json . positionSpread )  ; %NWL%json . positionRadius = this . positionRadius ; %NWL%json . speed = this . speed ; %NWL%json . speedSpread = this . speedSpread ; %NWL%json . worldSpace = this . worldSpace ; %NWL%2
prop = definition . passOnProperties [ x ]  ; %NWL%if ( this . owner [ prop ]  )  {%NWL%this . spawneeProperties [ prop ]  = this . owner [ prop ]  ;%NWL%}%NWL%}%NWL%}%NWL%this . propertiesContainer =  {%NWL%properties : this . spawneeProperties%NWL%}  ; %NWL%this . offsetX = this . owner . offsetX || definition . offsetX || 0 ; %NWL%this . offsetY = this . owner . offsetY || definition . offsetY || 0 ; %NWL%9
Node . call ( this )  ; %NWL%this . name = config . name ; %NWL%this . property = config . property || config . name ; %NWL%this . alias = config . alias ; %NWL%this . star = config . star ; %NWL%this . asArray = config . asArray ; %NWL%this . aggregator = config . aggregator ; %NWL%this . table = config . table ; %NWL%this . value = config . getValue (  )  ; %NWL%this . dataType = config . dataType ; %NWL%this . distinct = config . distinct ; %NWL%1
this . material = opts . material ! = undefined ? opts . material : undefined ; %NWL%this . positionSpread = opts . positionSpread ! = undefined ? opts . positionSpread : new Vec2 ( 0 . 5 , 0 . 5 )  ; %NWL%this . positionRadius = opts . positionRadius ! = undefined ? opts . positionRadius : 0 . 5 ; %NWL%this . speed = opts . speed ! = undefined ? opts . speed : 0 ; %NWL%this . speedSpread = opts . speedSpread ! = undefined ? opts . speedSpread : 0 ; %NWL%this . particleSystem = undefined ; %NWL%this . worldSpace = opts . worldSpace ! = undefined ? opts . worldSpace : true ; %NWL%this . position = opts . position ! = undefined ? opts . position : new Vec2 ; %NWL%this . minEmission = opts . minEmission ! = undefined ? opts . minEmission : 1 ; %NWL%this . maxEmission = opts . maxEmission ! = undefined ? opts . maxEmission : 2 ; %NWL%this . minLife = opts . minLife ! = undefined ? opts . minLife : 1 ; %NWL%8
return current . bind ( el , function next ( args )  {%NWL%return previous . apply ( el , Array . prototype . slice . call ( args )  . slice ( 2 , args . length )  )  ;%NWL%}  , el )  ;%NWL%}  , wrapped . bind ( el , el )  )  . apply ( el , arguments )  ;%NWL%}  ;%NWL%}%NWL%function sanitizeStructure ( struct )  {%NWL%struct . prototype = struct . prototype || Object . create ( HTMLElement . prototype )  ; %NWL%struct . features = struct . features || [  ]  ; %NWL%struct . interceptors = struct . interceptors || [  ]  ; %NWL%struct . wrappers = struct . wrappers || [  ]  ; %NWL%8
var scale = o . options . scale || ' both '  ;  /  / Default scale mode%NWL%var origin = o . options . origin ;  /  / The origin of the sizing%NWL%var original =  { height : el . height (  )  , width : el . width (  )  }  ;  /  / Save original%NWL%el . from = o . options . from || original ;  /  / Default from state%NWL%el . to = o . options . to || original ;  /  / Default to state%NWL%if ( origin )  {  /  / Calculate baseline shifts%NWL%var baseline = $ . effects . getBaseline ( origin , original )  ; %NWL%el . from . top =  ( original . height - el . from . height )  * baseline . y ; %NWL%el . from . left =  ( original . width - el . from . width )  * baseline . x ; %NWL%el . to . top =  ( original . height - el . to . height )  * baseline . y ; %NWL%el . to . left =  ( original . width - el . to . width )  * baseline . x ; %NWL%8
' use strict '  ; %NWL%angular . module (  ' prismic . io '  ,  [  ]  )%NWL%. provider (  ' Prismic '  , function (  )  {%NWL%var Configurer =  {  }  ; %NWL%Configurer . init = function ( object , config )  {%NWL%object . configuration = config ; %NWL%config . apiEndpoint = angular . isUndefined ( config . apiEndpoint ) ? '  '  : config . apiEndpoint ; %NWL%object . setApiEndpoint = function ( apiEndpoint )  {%NWL%config . apiEndpoint = apiEndpoint ;%NWL%}  ; %NWL%config . accessToken = angular . isUndefined ( config . accessToken ) ? '  '  : config . accessToken ; %NWL%6
createError = require (  '  .  .  / utils / error '  )  ,%NWL%logger = require (  '  .  .  / utils / logger '  )  ,%NWL%mongoose = require (  ' mongoose '  )  ,%NWL%url =  config . db . host ,%NWL%options =  {%NWL%user : config . db . username ,%NWL%pass : config . db . password%NWL%}  ; %NWL%db . tokens = require (  '  .  / mongodb / tokens '  )  ; %NWL%db . users = require (  '  .  / mongodb / users '  )  ; %NWL%db . contentTypes = require (  '  .  / mongodb / contentTypes '  )  ; %NWL%8
if ( activity . isInsight (  )  )  {%NWL%this . setInsight (  )  ;%NWL%} else {%NWL%this . setNote (  )  ;%NWL%}%NWL%}%NWL%}  ,%NWL%setComment : function (  )  {%NWL%this . text = t (  " comments . delete . alert . text "  )  ; %NWL%this . title = t (  " comments . delete . alert . title "  )  ; %NWL%this . ok = t (  " comments . delete . alert . ok "  )  ; %NWL%8
function deleteCookie ( name , errback )  {%NWL%setTimeout ( function (  )  {%NWL%document . cookie = name +  "  =  ; expires =  "  +  ( new Date ( 0 )  . toGMTString (  )  )  +  "  ; path =  /  "  ; %NWL%var foundCookie = parseCookies ( name )  ; %NWL%if ( foundCookie )  {%NWL%errback (  " Cookie not deleted "  )  ;%NWL%}%NWL%}  , 0 )  ;%NWL%}%NWL%document . getCookie = document . getCookie || getCookie ; %NWL%document . getAllCookies = document . getAllCookies || getAllCookies ; %NWL%9
if ( seleniumServer )  {%NWL%seleniumServer . stop (  )  ;%NWL%}%NWL%}  )  ; %NWL%exports . suite = suite ; %NWL%exports . after = testing . after ; %NWL%exports . afterEach = testing . afterEach ; %NWL%exports . before = testing . before ; %NWL%exports . beforeEach = testing . beforeEach ; %NWL%exports . it = testing . it ; %NWL%exports . ignore = testing . ignore ; %NWL%5
}%NWL%return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . patch = def ( request . patch )%NWL%de . post = def ( request . post )%NWL%de . put = def ( request . put )%NWL%de . head = def ( request . head )%NWL%6
var LUA_NUMBER = lua_Number ; %NWL%var LUA_INTEGER = lua_Integer ; %NWL%C . lua_newstate = F (  " lua_newstate "  , lua_State ,  [ lua_Alloc , void_ptr_t ]  )  ; %NWL%C . lua_close = F (  " lua_close "  , void_t ,  [ lua_State ]  )  ; %NWL%C . lua_newthread = F (  " lua_newthread "  , lua_State ,  [ lua_State ]  )  ; %NWL%C . lua_atpanic = F (  " lua_atpanic "  , lua_CFunction ,  [ lua_State , lua_CFunction ]  )  ; %NWL%C . lua_gettop = F (  " lua_gettop "  , int_t ,  [ lua_State ]  )  ; %NWL%C . lua_settop = F (  " lua_settop "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushvalue = F (  " lua_pushvalue "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_remove = F (  " lua_remove "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_insert = F (  " lua_insert "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%7
var capturedAssertions =  [  ]  ,%NWL%originalAssertions =  [  ]  ,%NWL%assertions =  [  ' ok '  ,  ' equal '  ,  ' notEqual '  ,  ' deepEqual '  ,  ' notDeepEqual '  ,%NWL%' strictEqual '  ,  ' notStrictEqual '  ,  ' raises '  ]  ; %NWL%for ( var i = 0 ; i < assertions . length ; i +  +  )  {%NWL%originalAssertions [ assertions [ i ]  ]  = window [ assertions [ i ]  ]  ;%NWL%}%NWL%window . ok = function (  )  { capturedAssertions . push (  [  ' ok '  , arguments ]  )  }  ; %NWL%window . equal = function (  )  { capturedAssertions . push (  [  ' equal '  , arguments ]  )  }  ; %NWL%window . notEqual = function (  )  { capturedAssertions . push (  [  ' notEqual '  , arguments ]  )  }  ; %NWL%window . deepEqual = function (  )  { capturedAssertions . push (  [  ' deepEqual '  , arguments ]  )  }  ; %NWL%7
return triples ;%NWL%}  ; %NWL%AbstractQueryTree . prototype . _replaceFilter = function ( filterExpr , from , to , ns )  {%NWL%if ( filterExpr . expressionType ! = null )  {%NWL%var expressionType = filterExpr . expressionType ; %NWL%if ( expressionType =  =  ' relationalexpression '  )  {%NWL%filterExpr . op1 = this . _replaceFilter ( filterExpr . op1 , from , to , ns )  ; %NWL%filterExpr . op2 = this . _replaceFilter ( filterExpr . op2 , from , to , ns )  ;%NWL%} else if ( expressionType =  =  ' conditionalor ' || expressionType =  =  ' conditionaland '  )  {%NWL%for ( var i = 0 ; i < filterExpr . operands . length ; i +  +  )  {%NWL%filterExpr . operands [ i ]  = this . _replaceFilter ( filterExpr . operands [ i ]  , from , to , ns )  ; %NWL%6
key = ka [ i ]  ; %NWL%if ( !_deepEqual ( a [ key ]  , b [ key ]  )  ) return false ;%NWL%}%NWL%return true ;%NWL%}%NWL%assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%5
errors :  [ ev . data . error ]%NWL%}  ; %NWL%this . cancel ( error )  ; %NWL%return $rootScope . $broadcast (  ' auth : login - error '  , error )  ;%NWL%}%NWL%}  ,%NWL%addScopeMethods : function (  )  {%NWL%$rootScope . user = this . user ; %NWL%$rootScope . authenticate = this . authenticate . bind ( this )  ; %NWL%$rootScope . signOut = this . signOut . bind ( this )  ; %NWL%$rootScope . destroyAccount = this . destroyAccount . bind ( this )  ; %NWL%8
$scope . startup (  )  ;%NWL%}%NWL%}%NWL%$scope . setBackground = function ( forceChange )  {%NWL%var canvas = document . getElementById (  ' background '  )  ; %NWL%canvas . width = window . innerWidth ; %NWL%canvas . height = window . innerHeight ; %NWL%var ctx = canvas . getContext (  ' 2d '  )  ; %NWL%var img = new Image ; %NWL%ctx . width = img . width ; %NWL%ctx . height = img . height ; %NWL%9
enumerable : true%NWL%}  ,%NWL%b :  {%NWL%get : function (  )  {%NWL%return this . _b ;%NWL%}  ,%NWL%set : function ( bValue )  {%NWL%var locB = this . _b ; %NWL%locB . vertices = bValue . vertices ; %NWL%locB . colors = bValue . colors ; %NWL%locB . texCoords = bValue . texCoords ; %NWL%8
this . keyvalue = null ; %NWL%this . certvalue = null ; %NWL%if ( authentication )  {%NWL%if ( typeof authentication . keyvalue =  =  =  ' string ' && authentication . keyvalue . length > 0 )  {%NWL%this . keyvalue = authentication . keyvalue ;%NWL%} else if ( typeof authentication . keyfile =  =  =  ' string ' && authentication . keyfile . length > 0 )  {%NWL%this . keyvalue = fs . readFileSync ( authentication . keyfile ,  ' ascii '  )  ;%NWL%}%NWL%if ( typeof authentication . certvalue =  =  =  ' string ' && authentication . certvalue . length > 0 )  {%NWL%this . certvalue = authentication . certvalue ;%NWL%} else if ( typeof authentication . certfile =  =  =  ' string ' && authentication . certfile . length > 0 )  {%NWL%5
htmlText :  ' 50% '  ,%NWL%items :  [  ]  ,%NWL%paneType : targetCmp . initialConfig . paneType || "  "%NWL%}%NWL%]%NWL%}  ; %NWL%if ( targetCmp . initialConfig . flex )  {%NWL%layoutConfig . flex = targetCmp . initialConfig . flex ;%NWL%}%NWL%else if ( targetCmp . initialConfig . width )  {%NWL%layoutConfig . width = targetCmp . initialConfig . width ; %NWL%7
passwordPrefix :  '  '%NWL%}%NWL%if ( conf . encryption )  {%NWL%if ( conf . encryption . enabled )  {%NWL%encryptionConfig . enabled = conf . encryption . enabled%NWL%}%NWL%if ( conf . encryption . cypher )  {%NWL%encryptionConfig . cypher = conf . encryption . cypher%NWL%}%NWL%if ( conf . encryption . passwordPrefix )  {%NWL%encryptionConfig . passwordPrefix = conf . encryption . passwordPrefix%NWL%4
object = lodash ;%NWL%}%NWL%return fn ( object , source , options )  ;%NWL%}  ;%NWL%}  ( mixin )  )  ; %NWL%lodash . after = functions . after ; %NWL%lodash . assign = objects . assign ; %NWL%lodash . at = collections . at ; %NWL%lodash . bind = functions . bind ; %NWL%lodash . bindAll = functions . bindAll ; %NWL%lodash . bindKey = functions . bindKey ; %NWL%5
YUI . add (  ' event - base - ie '  , function ( Y , NAME )  {%NWL%function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%8
json . minEmission = this . minEmission ; %NWL%json . maxEmission = this . maxEmission ; %NWL%json . minLife = this . minLife ; %NWL%json . maxLife = this . maxLife ; %NWL%json . minSize = this . minSize ; %NWL%json . maxSize = this . maxSize ; %NWL%json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%6
poolSize : 1%NWL%, socketOptions :  {%NWL%connectTimeoutMS : 30000%NWL%, socketTimeoutMS : 30000%NWL%}%NWL%, auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%7
bubbles : true%NWL%}  )  ; %NWL%doClicks ( evt ,  " touchmove "  ,  " touchend "  )  ;  /  / init click generation%NWL%}  , true )  ; %NWL%function copyEventProps ( evt )  {%NWL%var props = lang . delegate ( evt ,  {%NWL%bubbles : true%NWL%}  )  ; %NWL%if ( has (  " ios "  )  >  = 6 )  {%NWL%props . touches = evt . touches ; %NWL%props . altKey = evt . altKey ; %NWL%9
this . _logger = goog . debug . Logger . getLogger (  ' lanyard . Level '  )  ; %NWL%if ( !params )  {%NWL%this . _logger . severe (  ' Attempted to create a level with invalid params .  '  )  ;%NWL%}%NWL%this . params = params ; %NWL%this . levelName = this . params . levelName ? this . params . levelName :  '  '  ; %NWL%this . levelNumber = this . params . levelNumber ; %NWL%this . tileDelta = this . params . tileDelta ; %NWL%this . tileWidth = this . params . tileWidth ; %NWL%this . tileHeight = this . params . tileHeight ; %NWL%this . service = this . params . service ; %NWL%6
point = Tweenable . interpolate (%NWL%from , to ,  ( 1 / PRERENDER_GRANULARITY )  * i , easing )  ; %NWL%points . push ( point )  ;%NWL%}%NWL%return points ;%NWL%}%NWL%var prerenderedPath ; %NWL%function generatePathPrerender ( x1 , y1 , x2 , y2 , easeX , easeY )  {%NWL%prerenderedPath = document . createElement (  ' canvas '  )  ; %NWL%prerenderedPath . width = rekapi . renderer . width (  )  ; %NWL%prerenderedPath . height = rekapi . renderer . height (  )  ; %NWL%9
var UI =  {%NWL%setButtonSelected : function ( button , selected )  {%NWL%if ( !button . hasClass (  ' selected '  )  )  {%NWL%if ( selected ) button . addClass (  ' selected '  )  ;%NWL%}%NWL%else if ( !selected ) button . removeClass (  ' selected '  )  ;%NWL%}  ,%NWL%init : function (  )  {%NWL%this . cachedQueries = $ (  ' #cachedQueries '  )  ; %NWL%this . scheduledQueries = $ (  ' #scheduledQueries '  )  ; %NWL%this . cacheButton = $ (  ' #cacheButton '  )  ; %NWL%8
air . ActivityEvent = window . runtime . flash . events . ActivityEvent ; %NWL%air . AsyncErrorEvent = window . runtime . flash . events . AsyncErrorEvent ; %NWL%air . BrowserInvokeEvent = window . runtime . flash . events . BrowserInvokeEvent ; %NWL%air . DataEvent = window . runtime . flash . events . DataEvent ; %NWL%air . DRMAuthenticateEvent = window . runtime . flash . events . DRMAuthenticateEvent ; %NWL%air . DRMStatusEvent = window . runtime . flash . events . DRMStatusEvent ; %NWL%air . ErrorEvent = window . runtime . flash . events . ErrorEvent ; %NWL%air . Event = window . runtime . flash . events . Event ; %NWL%air . EventDispatcher = window . runtime . flash . events . EventDispatcher ; %NWL%air . FileListEvent = window . runtime . flash . events . FileListEvent ; %NWL%air . HTTPStatusEvent = window . runtime . flash . events . HTTPStatusEvent ; %NWL%0
href = less . modules . path . join ( currentFileInfo . currentDirectory , file )  ;%NWL%}%NWL%var path = less . modules . path . dirname ( href )  ; %NWL%var newFileInfo =  {%NWL%currentDirectory : path +  '  /  '  ,%NWL%filename : href%NWL%}  ; %NWL%if ( currentFileInfo )  {%NWL%newFileInfo . entryPath = currentFileInfo . entryPath ; %NWL%newFileInfo . rootpath = currentFileInfo . rootpath ; %NWL%newFileInfo . rootFilename = currentFileInfo . rootFilename ; %NWL%8
)  ; %NWL%this . x = coordinates . x ; %NWL%this . y = coordinates . y ; %NWL%this . index = this . x + this . y * COLS ;%NWL%} else if ( arguments [ 0 ]  >  = 0 && arguments [ 0 ]  < ROWS * COLS )  {%NWL%this . index = arguments [ 0 ]  ; %NWL%coordinates = getCoordinatesFromIndex (%NWL%this . index%NWL%)  ; %NWL%this . x = coordinates . x ; %NWL%this . y = coordinates . y ; %NWL%1
this . uToggleHandler = config . toggleHandler ; %NWL%this . uCheckHandler = config . checkHandler ; %NWL%config . scope = this ; %NWL%config . handler = this . pHandler ; %NWL%config . toggleHandler = this . pToggleHandler ; %NWL%config . checkHandler = this . pCheckHandler ; %NWL%var ctrl = this . control = config . control ; %NWL%delete config . control ; %NWL%this . activateOnEnable = !!config . activateOnEnable ; %NWL%delete config . activateOnEnable ; %NWL%this . deactivateOnDisable = !!config . deactivateOnDisable ; %NWL%8
bucket : Tools . copy ( model . bucket )  ,%NWL%primaryKey : Tools . copy ( model . primaryKey )  ,%NWL%action : action ,%NWL%userData : Tools . copy ( userData )  ,%NWL%properties : Tools . copy ( model . properties )  ,%NWL%relations : Tools . copy ( model . relations )%NWL%}%NWL%switch ( action )  {%NWL%case Constants . ACTION_FETCH : %NWL%ret . conditions = Tools . copy ( model . conditions )  ; %NWL%ret . parameters = Tools . copy ( model . parameters )  ; %NWL%9
}  ; %NWL%$scope . lowerVolume = function (  )  {%NWL%$scope . volume = $scope . volume - 5 >  = 5 ? $scope . volume - 5 : 0 ; %NWL%mopidyservice . setVolume ( $scope . volume )  ;%NWL%}  ; %NWL%$scope . toggleShuffle = function (  )  {%NWL%$scope . isRandom = !$scope . isRandom ; %NWL%mopidyservice . setRandom ( $scope . isRandom )  ;%NWL%}  ; %NWL%$scope . toggleRepeat = function (  )  {%NWL%$scope . isRepeat = !$scope . isRepeat ; %NWL%6
}%NWL%bCatString = bCats . join (  " | "  )  ; %NWL%if ( aCatString =  =  = bCatString )  {%NWL%returnData [ i ]  . xField = higherLevelData [ j ]  . xField ; %NWL%returnData [ i ]  . xValue = higherLevelData [ j ]  . xValue ; %NWL%returnData [ i ]  . xCount = higherLevelData [ j ]  . xCount ; %NWL%returnData [ i ]  . yField = higherLevelData [ j ]  . yField ; %NWL%returnData [ i ]  . yValue = higherLevelData [ j ]  . yValue ; %NWL%returnData [ i ]  . yCount = higherLevelData [ j ]  . yCount ; %NWL%returnData [ i ]  . zField = higherLevelData [ j ]  . zField ; %NWL%returnData [ i ]  . zValue = higherLevelData [ j ]  . zValue ; %NWL%3
sprite . touchmove = sprite . mousemove = function ( data )  {%NWL%var point =  { x : 0 , y : 0 }  ; %NWL%point . x = data . global . x - this . position . x ; %NWL%point . y = data . global . y - this . position . y ; %NWL%this . handlePointerMove ( point )  ; %NWL%return ;%NWL%}%NWL%sprite . mousedown = sprite . touchstart = function ( data )  {%NWL%var point =  { x : 0 , y : 0 }  ; %NWL%point . x = data . global . x - this . position . x ; %NWL%point . y = data . global . y - this . position . y ; %NWL%2
Ident . prototype . __defineGetter__ (  ' hash '  , function (  )  {%NWL%return this . name ;%NWL%}  )  ; %NWL%Ident . prototype . __proto__ = Node . prototype ; %NWL%Ident . prototype . clone = function ( parent )  {%NWL%var clone = new Ident ( this . name )  ; %NWL%clone . val = this . val . clone ( parent , clone )  ; %NWL%clone . mixin = this . mixin ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%clone . filename = this . filename ; %NWL%7
var a = require (  ' a '  )  ; %NWL%var mock = a . mock ; %NWL%var requireMock = a . requireMock ; %NWL%function act ( c )  {%NWL%c . emptyFilter = requireMock (  '  .  / emptyFilter '  )  ; %NWL%c . mock = mock ; %NWL%c . table = requireMock (  '  .  / table '  )  ; %NWL%c . commit = requireMock (  '  .  / table / commit '  )  ; %NWL%c . rollback = requireMock (  '  .  / table / rollback '  )  ; %NWL%c . pools = requireMock (  '  .  / pools '  )  ; %NWL%c . log = requireMock (  '  .  / table / log '  )  ; %NWL%7
for ( j = 0 ; j < this . columns ; j +  +  )  {%NWL%current . push ( 0 )  ;%NWL%}%NWL%this . zOffsets . push ( current )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%JSM . LegoBrick = function ( positionX , positionY , rows , columns , large , color )%NWL%{%NWL%this . positionX = positionX || 0 ; %NWL%this . positionY = positionY || 0 ; %NWL%9
callback ( err )  ; %NWL%return ;%NWL%}%NWL%callback ( null )  ; %NWL%return ;%NWL%}  )  ;%NWL%}%NWL%exports . save_user = function ( user , callback )  {%NWL%var new_user = new User (  )  ; %NWL%new_user . sessionId = user . sessionId ; %NWL%new_user . username = user . username ; %NWL%9
precision ,%NWL%offset ,%NWL%target = null ,%NWL%synchronizing = false ; %NWL%function ServerDate (  )  {%NWL%return this%NWL%? ServerDate%NWL% : ServerDate . toString (  )  ;%NWL%}%NWL%ServerDate . parse = Date . parse ; %NWL%ServerDate . UTC = Date . UTC ; %NWL%9
if ( object . servers . length =  = 0 ) throw new Error (  " connection string must contain at least one seed host "  )  ; %NWL%object . db_options . native_parser = _setNativeParser ( object . db_options )  ; %NWL%if ( typeof object . server_options . auto_reconnect ! =  ' boolean '  )  {%NWL%object . server_options . auto_reconnect = true ;%NWL%}%NWL%for ( var i = 0 ; i < object . servers . length ; i +  +  )  {%NWL%var _server_options =  { poolSize : 1 , socketOptions :  { connectTimeoutMS : 1000 }  , auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%8
exports . abacast   = require (  "  .  / abacast "  )  ; %NWL%exports . accujazz  = require (  "  .  / accujazz "  )  ; %NWL%exports . accuradio  = require (  "  .  / accuradio "  )  ; %NWL%exports . amazon   = require (  "  .  / amazon "  )  ; %NWL%exports . bandcamp  = require (  "  .  / bandcamp "  )  ; %NWL%exports . beats   = require (  "  .  / beats "  )  ; %NWL%exports . earbits   = require (  "  .  / earbits "  )  ; %NWL%exports . focusatwill  = require (  "  .  / focusatwill "  )  ; %NWL%exports . google   = require (  "  .  / google "  )  ; %NWL%exports . hoopla   = require (  "  .  / hoopla "  )  ; %NWL%exports . jango   = require (  "  .  / jango "  )  ; %NWL%0
failCB = jasmine . createSpy (  )  ,%NWL%args =  {  }  ; %NWL%spyOn ( webview ,  " windowGroup "  )  . andReturn ( 42 )  ; %NWL%args . eventId =  " 12345 "  ; %NWL%args . message =  " Hello World "  ; %NWL%args . type = 0 ; %NWL%args . settings =  { title :  " Hi "  }  ; %NWL%args . eventId = encodeURIComponent ( JSON . stringify ( args . eventId )  )  ; %NWL%args . message = encodeURIComponent ( args . message )  ; %NWL%args . type = encodeURIComponent ( args . type )  ; %NWL%args . settings = encodeURIComponent ( JSON . stringify ( args . settings )  )  ; %NWL%7
if ( obj . items . type ! = null )  {%NWL%this . refDataType = obj . items . type ;%NWL%}%NWL%if ( obj . items . $ref ! = null )  {%NWL%this . refDataType = obj . items . $ref ;%NWL%}%NWL%}%NWL%this . dataTypeWithRef = this . refDataType ! = null ? this . dataType +  '  [  '  + this . refDataType +  '  ]  '  : this . dataType ; %NWL%if ( obj . allowableValues ! = null )  {%NWL%this . valueType = obj . allowableValues . valueType ; %NWL%this . values = obj . allowableValues . values ; %NWL%9
if ( data . address . city && data . address . city ! =  '  -  ' && data . address . city ! =  ' NaN '  )%NWL%result . city = data . address . city ; %NWL%if ( data . address . region && data . address . region ! =  '  -  ' && data . address . region ! =  ' NaN '  )%NWL%result . region = data . address . region ;%NWL%}%NWL%if ( data . latitude )%NWL%result . latitude = data . latitude ; %NWL%if ( data . longitude )%NWL%result . longitude = data . longitude ; %NWL%if ( data . zoom )%NWL%result . zoom = data . zoom ; %NWL%6
return modes [ lang ] ? CodeMirror . getMode ( cmCfg , modes [ lang ]  )  : null ;%NWL%}  ;%NWL%}  (  )  )  ; %NWL%if ( modeCfg . highlightFormatting =  =  = undefined )%NWL%modeCfg . highlightFormatting = false ; %NWL%if ( modeCfg . maxBlockquoteDepth =  =  = undefined )%NWL%modeCfg . maxBlockquoteDepth = 0 ; %NWL%if ( modeCfg . underscoresBreakWords =  =  = undefined )%NWL%modeCfg . underscoresBreakWords = true ; %NWL%if ( modeCfg . fencedCodeBlocks =  =  = undefined ) modeCfg . fencedCodeBlocks = false ; %NWL%if ( modeCfg . taskLists =  =  = undefined ) modeCfg . taskLists = false ; %NWL%9
air . ErrorEvent = window . runtime . flash . events . ErrorEvent ; %NWL%air . Event = window . runtime . flash . events . Event ; %NWL%air . EventDispatcher = window . runtime . flash . events . EventDispatcher ; %NWL%air . FileListEvent = window . runtime . flash . events . FileListEvent ; %NWL%air . HTTPStatusEvent = window . runtime . flash . events . HTTPStatusEvent ; %NWL%air . IOErrorEvent = window . runtime . flash . events . IOErrorEvent ; %NWL%air . InvokeEvent = window . runtime . flash . events . InvokeEvent ; %NWL%air . NetStatusEvent = window . runtime . flash . events . NetStatusEvent ; %NWL%air . OutputProgressEvent = window . runtime . flash . events . OutputProgressEvent ; %NWL%air . ProgressEvent = window . runtime . flash . events . ProgressEvent ; %NWL%air . SecurityErrorEvent = window . runtime . flash . events . SecurityErrorEvent ; %NWL%0
if ( typeof model =  =  =  ' function '  )  {%NWL%model = new model ( pineapple . models )  ;%NWL%}%NWL%if ( typeof model =  =  =  ' string '  )  {%NWL%model = pineapple . model . get ( model , true )  ; %NWL%this . inherits ( model )  ; %NWL%continue ;%NWL%}%NWL%if ( typeof model ! =  =  ' object '  ) continue ; %NWL%this . schema  = pineapple . utils . object . merge ( this . schema , model . schema )  ; %NWL%this . options  = pineapple . utils . object . merge ( this . options , model . options )  ; %NWL%9
}  ,%NWL%enumerable : true%NWL%}  ,%NWL%b :  {%NWL%get : function (  )  {%NWL%return this . _b ;%NWL%}  ,%NWL%set : function ( bValue )  {%NWL%var locB = this . _b ; %NWL%locB . vertices = bValue . vertices ; %NWL%locB . colors = bValue . colors ; %NWL%9
getSprite : function (  )  {%NWL%return this . sprite ;%NWL%}  ,%NWL%setSprite : function ( sprite )  {%NWL%this . sprite = sprite ;%NWL%}  ,%NWL%initWithWidthAndHeight : null ,%NWL%_initWithWidthAndHeightForCanvas : function ( width , height , format , depthStencilFormat )  {%NWL%var locCacheCanvas = this . _cacheCanvas , locScaleFactor = cc . contentScaleFactor (  )  ; %NWL%locCacheCanvas . width = 0 | ( width * locScaleFactor )  ; %NWL%locCacheCanvas . height = 0 | ( height * locScaleFactor )  ; %NWL%9
. orient (  ( rightAlignYAxis ) ? ' right '  :  ' left '  )%NWL% ; %NWL%var showTooltip = function ( e , offsetElement )  {%NWL%if ( offsetElement )  {%NWL%var svg = d3 . select ( offsetElement )  . select (  ' svg '  )  ; %NWL%var viewBox =  ( svg . node (  )  ) ? svg . attr (  ' viewBox '  )  : null ; %NWL%if ( viewBox )  {%NWL%viewBox = viewBox . split (  '  '  )  ; %NWL%var ratio = parseInt ( svg . style (  ' width '  )  )  / viewBox [ 2 ]  ; %NWL%e . pos [ 0 ]  = e . pos [ 0 ]  * ratio ; %NWL%e . pos [ 1 ]  = e . pos [ 1 ]  * ratio ; %NWL%9
function O_Total_PlayOnce (  )  {%NWL%if ( checkNull (  )  )  {%NWL%OVERALL . total_PlayOnce = storage . total_PlayOnce + SESSION . total_PlayOnce ;%NWL%}%NWL%else {%NWL%OVERALL . total_PlayOnce = SESSION . total_PlayOnce ;%NWL%}%NWL%}%NWL%function O_Total_Speed (  )  {%NWL%if ( checkNull (  )  )  {%NWL%OVERALL . total_Speed = storage . total_Speed + SESSION . total_Speed ; %NWL%2
}  ; %NWL%function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%5
this . eventPool_ . releaseObject (  ( startEvent )  )  ; %NWL%break ;%NWL%}%NWL%}%NWL%} else {%NWL%stopEvent =  (%NWL%this . eventPool_ . getObject (  )  )  ; %NWL%stopEvent . eventType = goog . debug . Trace_ . EventType . STOP ; %NWL%stopEvent . startTime = startEvent . startTime ; %NWL%stopEvent . comment = startEvent . comment ; %NWL%stopEvent . type = startEvent . type ; %NWL%8
,  ' gridfs / grid '%NWL%, 	 ' gridfs / chunk '%NWL%,  ' gridfs / gridstore '  ]  . forEach ( function ( path )  {%NWL%var module = require (  '  .  /  '  + path )  ; %NWL%for ( var i in module )  {%NWL%exports [ i ]  = module [ i ]  ;%NWL%}%NWL%}  )  ; %NWL%exports . ReplSetServers = exports . ReplSet ; %NWL%exports . Binary = require (  ' bson '  )  . Binary ; %NWL%exports . Code = require (  ' bson '  )  . Code ; %NWL%9
p . sx =  options [ prefix +  ' scale '  ]  [ 0 ]  ; %NWL%p . sy =  options [ prefix +  ' scale '  ]  [ 1 ]  ;%NWL%}%NWL%if ( options [ prefix +  ' width '  ] ! =  = undefined )  {%NWL%p . width =  options [ prefix +  ' width '  ]  ;%NWL%}%NWL%if ( options [ prefix +  ' height '  ] ! =  = undefined )  {%NWL%p . height =  options [ prefix +  ' height '  ]  ;%NWL%}%NWL%if ( options [ prefix +  ' opacity '  ] ! =  = undefined )  {%NWL%p . opacity =  options [ prefix +  ' opacity '  ]  ; %NWL%4
var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%5
element . parentNode . replaceChild ( newElement , element )  ;%NWL%}  ;%NWL%}  ; %NWL%CodeMirror . fromTextArea = function ( area , options )  {%NWL%if ( typeof area =  =  " string "  )%NWL%area = document . getElementById ( area )  ; %NWL%options = options || {  }  ; %NWL%if ( area . style . width && options . width =  = null )%NWL%options . width = area . style . width ; %NWL%if ( area . style . height && options . height =  = null )%NWL%options . height = area . style . height ; %NWL%8
this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if ( this . debug )%NWL%this . log = console . error%NWL%this . silent = !!options . silent%NWL%0
function initialize ( instance )  {%NWL%if ( !instance . __internal )  {%NWL%delete instance . __init ; %NWL%if ( null =  =  = reflow )  {%NWL%document . body . setAttribute (  ' tabindex '  ,  ' 0 '  )  ;%NWL%}%NWL%var setup ; %NWL%if ( typeof instance . setup =  =  =  ' function '  )  {%NWL%setup = instance . setup (  )  ; %NWL%setup . options = setup . options || {  }  ; %NWL%setup . focus = setup . focus || {  }  ; %NWL%9
jQuery (  ' #opacity - label '  )  . show (  )  ; %NWL%jQuery (  ' #opacity - volume '  )  . show (  )  ; %NWL%if ( typeof scene . volume . opacity ! =  ' undefined '  )  {%NWL%volume . opacity = scene . volume . opacity ;%NWL%}%NWL%}%NWL%}%NWL%jQuery (  ' #opacity - volume '  )  . slider (  " option "  ,  " value "  ,%NWL%volume . opacity * 100 )  ; %NWL%if ( typeof scene . volume . lowerThreshold ! =  ' undefined '  )  {%NWL%volume . lowerThreshold = scene . volume . lowerThreshold ; %NWL%3
Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%proxy . stopImmediatePropagation = proto . stopImmediatePropagation ; %NWL%6
templateString : template ,%NWL%constructor : function ( obj )  {%NWL%this . name = obj . name ; %NWL%this . clientId = obj . clientId ; %NWL%this . clientSecret = obj . clientSecret ; %NWL%this . authUrl = obj . authUrl ; %NWL%this . tokenUrl = obj . tokenUrl ; %NWL%this . type = obj . type ; %NWL%this . grantType = obj . grantType ; %NWL%this . authentication = obj . authentication ; %NWL%this . override = obj . override ; %NWL%2
nls . pageCountIndication ,%NWL%nls . dialogConfirm ,%NWL%nls . dialogCancel ,%NWL%nls . all%NWL%]  ;%NWL%}  ,%NWL%_regApis : function (  )  {%NWL%var g = this . grid ; %NWL%g . currentPage = lang . hitch ( this , this . currentPage )  ; %NWL%g . nextPage = lang . hitch ( this , this . nextPage )  ; %NWL%g . prevPage = lang . hitch ( this , this . prevPage )  ; %NWL%8
fs . read = wrap ( fs . read ,  ' fs . read '  , 5 )  ; %NWL%fs . writeBuffer = wrap ( fs . writeBuffer ,  ' fs . write '  , 5 )  ; %NWL%fs . writeString = wrap ( fs . writeString ,  ' fs . write '  , 4 )  ; %NWL%fs . fstat = wrap ( fs . fstat ,  ' fs . fstat '  , 1 )  ; %NWL%fs . fsync = wrap ( fs . fsync ,  ' fs . fsync '  , 1 )  ; %NWL%fs . ftruncate = wrap ( fs . ftruncate ,  ' fs . ftruncate '  , 2 )  ; %NWL%fs . futimes = wrap ( fs . futimes ,  ' fs . futimes '  , 3 )  ; %NWL%fs . stat = wrap ( fs . stat ,  ' fs . stat '  , 1 )  ; %NWL%fs . link = wrap ( fs . link ,  ' fs . link '  , 2 )  ; %NWL%fs . lstat = wrap ( fs . lstat ,  ' fs . lstat '  , 1 )  ; %NWL%fs . chmod = wrap ( fs . chmod ,  ' fs . chmod '  , 2 )  ; %NWL%5
}  ; %NWL%$ . extend ( Markdownarea . prototype ,  {%NWL%init : function (  )  {%NWL%var $this = this , tpl = Markdownarea . template ; %NWL%tpl = tpl . replace (  / \ { \ : lblPreview\ }  / g , this . options . lblPreview )  ; %NWL%tpl = tpl . replace (  / \ { \ : lblCodeview\ }  / g , this . options . lblCodeview )  ; %NWL%this . markdownarea = $ ( tpl )  ; %NWL%this . content   = this . markdownarea . find (  "  . uk - markdownarea - content "  )  ; %NWL%this . toolbar   = this . markdownarea . find (  "  . uk - markdownarea - toolbar "  )  ; %NWL%this . preview   = this . markdownarea . find (  "  . uk - markdownarea - preview "  )  . children (  )  . eq ( 0 )  ; %NWL%this . code   = this . markdownarea . find (  "  . uk - markdownarea - code "  )  ; %NWL%7
options . end = options . duration +  ( options . start -  (  + options . from )  )  ;%NWL%}%NWL%if ( updates . hasOwnProperty (  " zindex "  )  )  {%NWL%options . zindex = updates . zindex ; %NWL%options . setZIndex (  )  ;%NWL%}%NWL%if ( updates . title )  {%NWL%options . title = updates . title ;%NWL%}%NWL%if ( updates . denied )  {%NWL%options . denied = updates . denied ; %NWL%3
newItem . top = offset . top ; %NWL%newItem . width = elem . width (  )  ; %NWL%newItem . height = elem . height (  )  ; %NWL%newItem . borderLeftWidth = elem . css (  ' borderLeftWidth '  ) || 0 ; %NWL%newItem . borderTopWidth = elem . css (  ' borderTopWidth '  ) || 0 ; %NWL%newItem . borderRightWidth = elem . css (  ' borderRightWidth '  ) || 0 ; %NWL%newItem . borderBottomWidth = elem . css (  ' borderBottomWidth '  ) || 0 ; %NWL%newItem . borderLeftColor = elem . css (  ' borderLeftColor '  )  ; %NWL%newItem . borderTopColor = elem . css (  ' borderTopColor '  )  ; %NWL%newItem . borderRightColor = elem . css (  ' borderRightColor '  )  ; %NWL%newItem . borderBottomColor = elem . css (  ' borderBottomColor '  )  ; %NWL%7
fill = dojox . gfx . makeParameters ( dojox . gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeX "  )  {%NWL%var span = dim . height - offsets . t - offsets . b ; %NWL%fill . y1 = offsets . t + span * fill . y1 / 100 ; %NWL%fill . y2 = offsets . t + span * fill . y2 / 100 ;%NWL%}%NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeY "  )  {%NWL%var span = dim . width - offsets . l - offsets . r ; %NWL%fill . x1 = offsets . l + span * fill . x1 / 100 ; %NWL%fill . x2 = offsets . l + span * fill . x2 / 100 ; %NWL%9
var newSnapshot =  {  }  ; %NWL%newSnapshot . repository = $scope . selectedRepository ; %NWL%if ( result . name )  {%NWL%newSnapshot . snapshot = result . name ;%NWL%} else {%NWL%var now = moment (  )  . format (  " YYYYMMDDHHmmss "  )  ; %NWL%newSnapshot . snapshot = result . prefix +  "  -  "  + now ;%NWL%}%NWL%newSnapshot . indices = result . indices ; %NWL%newSnapshot . ignoreUnavailable = result . ignoreUnavailable ; %NWL%newSnapshot . includeGlobalState = result . includeGlobalState ; %NWL%8
PIXI . Texture . prototype . destroy = function ( destroyBase )%NWL%{%NWL%if ( destroyBase ) this . baseTexture . destroy (  )  ; %NWL%this . valid = false ;%NWL%}  ; %NWL%PIXI . Texture . prototype . setFrame = function ( frame )%NWL%{%NWL%this . noFrame = false ; %NWL%this . frame = frame ; %NWL%this . width = frame . width ; %NWL%this . height = frame . height ; %NWL%9
}  ; %NWL%options =  {%NWL%method :  ' stream '  ,%NWL%params : options%NWL%}  ; %NWL%if ( options . params . path )  {%NWL%options . path = options . params . path ; %NWL%delete options . params . path ;%NWL%}%NWL%if ( options . params . auth )  {%NWL%options . auth = options . params . auth ; %NWL%6
return this . popups [ this . popups . length - 1 ]  ;%NWL%}  ; %NWL%this . popups =  [  ]  ;%NWL%}  ; %NWL%popupManager = new PopupManager (  )  ; %NWL%function Popup ( data )  {%NWL%this . title = data . title ; %NWL%this . subtitle = data . subtitle ; %NWL%this . img = data . img ; %NWL%this . value = data . value ; %NWL%this . bordercolor = data . bordercolor ; %NWL%6
this . update = __bind ( this . update , this )  ; %NWL%this . onResize = __bind ( this . onResize , this )  ; %NWL%this . onRefresh = __bind ( this . onRefresh , this )  ; %NWL%this . getItemWidth = __bind ( this . getItemWidth , this )  ; %NWL%this . layout = __bind ( this . layout , this )  ; %NWL%this . layoutFull = __bind ( this . layoutFull , this )  ; %NWL%this . layoutColumns = __bind ( this . layoutColumns , this )  ; %NWL%this . filter = __bind ( this . filter , this )  ; %NWL%this . clear = __bind ( this . clear , this )  ; %NWL%this . getActiveItems = __bind ( this . getActiveItems , this )  ; %NWL%this . refreshPlaceholders = __bind ( this . refreshPlaceholders , this )  ; %NWL%0
light = ROT . Color . add ( this . ambientLight , lighting )  ;%NWL%}%NWL%if ( tileData . color )  {%NWL%var color = ROT . Color . fromString ( tileData . color )  ; %NWL%color = overlay ( light , color )  ; %NWL%tileData . color = ROT . Color . toRGB ( color )  ;%NWL%}%NWL%if ( tileData . bgColor )  {%NWL%var bgColor = ROT . Color . fromString ( tileData . bgColor )  ; %NWL%bgColor = overlay ( light , bgColor )  ; %NWL%tileData . bgColor = ROT . Color . toRGB ( bgColor )  ; %NWL%5
( divStyle . msTransform =  =  =  '  ' ? ' msTransform '  :%NWL%( divStyle . WebkitTransform =  =  =  '  ' ? ' WebkitTransform '  :%NWL%( divStyle . OTransform =  =  =  '  ' ? ' OTransform '  :%NWL%( divStyle . Transform =  =  =  '  ' ? ' Transform '  : %NWL%false )  )  )  )  ; %NWL%$ . cssProps . transformOrigin =%NWL%divStyle . MozTransformOrigin =  =  =  '  ' ? ' MozTransformOrigin '  :%NWL%( divStyle . msTransformOrigin =  =  =  '  ' ? ' msTransformOrigin '  :%NWL%( divStyle . WebkitTransformOrigin =  =  =  '  ' ? ' WebkitTransformOrigin '  :%NWL%( divStyle . OTransformOrigin =  =  =  '  ' ? ' OTransformOrigin '  :%NWL%( divStyle . TransformOrigin =  =  =  '  ' ? ' TransformOrigin '  : %NWL%0
if ( typeof offset ! =  =  ' undefined '  )%NWL%binding . bindByName (  " offset "  , offset )  ; %NWL%params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%var requests =  [  ]  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%request . requestUrl = stmt . row . requestUrl ; %NWL%7
for ( var i = 0 ; i < results . length ;  +  + i )  {%NWL%var resultElement = results [ i ]  ; %NWL%if ( resultElement . dataGrid )%NWL%resultElement . dataGrid . updateLayout (  )  ;%NWL%}%NWL%}  ,%NWL%saveToCookie : function ( cookie )%NWL%{%NWL%cookie . type = WebInspector . ContentViewCookieType . Database ; %NWL%cookie . host = this . representedObject . host ; %NWL%cookie . name = this . representedObject . name ; %NWL%9
json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%0
return angular . extend (  {  }  , options )  ;%NWL%}%NWL%}  ; %NWL%EventBusStub . reconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . reconnect "  ; %NWL%EventBusStub . close . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . close "  ; %NWL%EventBusStub . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . login "  ; %NWL%EventBusStub . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . send "  ; %NWL%EventBusStub . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . publish "  ; %NWL%EventBusStub . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . registerHandler "  ; %NWL%EventBusStub . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . unregisterHandler "  ; %NWL%EventBusStub . readyState . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . readyState "  ; %NWL%3
y : 0 . 0 ,%NWL%z : 0 . 0 ,%NWL%initialize : function ( x , y , z )  {%NWL%this . x =  ( x ? x : 0 )  ; %NWL%this . y =  ( y ? y : 0 )  ; %NWL%this . z =  ( z ? z : 0 )  ;%NWL%}  ,%NWL%copy : function ( vector )  {%NWL%this . x = vector . x ; %NWL%this . y = vector . y ; %NWL%this . z = vector . z ; %NWL%8
for ( var tileY = tileStartY ; tileY <  = tileEndY ; tileY +  +  )  {%NWL%for ( var tileX = tileStartX ; tileX <  = tileEndX ; tileX +  +  )  {%NWL%if ( this . tilePresent ( tileX , tileY )  )  {%NWL%colObj . p . x = tileX * p . tileW + p . x + p . tileW / 2 ; %NWL%colObj . p . y = tileY * p . tileH + p . y + p . tileH / 2 ; %NWL%col = Q . collision ( obj , colObj )  ; %NWL%if ( col && col . magnitude > 0 &&%NWL%( !normal . collided || normal . magnitude < col . magnitude )  )  {%NWL%normal . collided = true ; %NWL%normal . separate [ 0 ]  = col . separate [ 0 ]  ; %NWL%normal . separate [ 1 ]  = col . separate [ 1 ]  ; %NWL%9
air . SoundLoaderContext = window . runtime . flash . media . SoundLoaderContext ; %NWL%air . SoundMixer = window . runtime . flash . media . SoundMixer ; %NWL%air . SoundTransform = window . runtime . flash . media . SoundTransform ; %NWL%air . Microphone = window . runtime . flash . media . Microphone ; %NWL%air . Video = window . runtime . flash . media . Video ; %NWL%air . Camera = window . runtime . flash . media . Camera ; %NWL%air . SoundCodec = window . runtime . flash . media . SoundCodec ; %NWL%air . EncryptedLocalStore = window . runtime . flash . data . EncryptedLocalStore ; %NWL%air . SQLCollationType = window . runtime . flash . data . SQLCollationType ; %NWL%air . SQLColumnNameStyle = window . runtime . flash . data . SQLColumnNameStyle ; %NWL%air . SQLColumnSchema = window . runtime . flash . data . SQLColumnSchema ; %NWL%7
if ( options . matchBase && - 1 =  =  = pattern . indexOf (  "  /  "  )  )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%6
position =  [  " before "  ,  " after "  ]  ;%NWL%} else if ( angle < 2 * Math . PI - pi4 )  {%NWL%position =  [  " above "  ,  " below "  ]  ;%NWL%}%NWL%break ;%NWL%}%NWL%var lt = this . chart . getCoords (  )  ; %NWL%aroundRect . x +  = lt . x ; %NWL%aroundRect . y +  = lt . y ; %NWL%aroundRect . x = Math . round ( aroundRect . x )  ; %NWL%aroundRect . y = Math . round ( aroundRect . y )  ; %NWL%9
}  , 1000 )  ;%NWL%}  ; %NWL%var _fillUserAgentBeforeViewport = function ( device )  {%NWL%device . pixelRatio = window . devicePixelRatio || 1 ; %NWL%device . iPhone =  / iPhone / i . test ( navigator . userAgent )  ; %NWL%device . iPhone4 =  ( device . iPhone && device . pixelRatio =  = 2 )  ; %NWL%device . iPad =  / iPad / i . test ( navigator . userAgent )  ; %NWL%device . iOS = device . iPhone || device . iPad ; %NWL%device . applePhone = device . iPhone || device . iPhone4 ; %NWL%device . appleTablet = device . iPad ; %NWL%device . android =  / android / i . test ( navigator . userAgent )  ; %NWL%4
height : 12 ,%NWL%shape :  " rect "  ,%NWL%padding :  {%NWL%top : 0 ,%NWL%left : 0 ,%NWL%right : 0 ,%NWL%bottom : 0%NWL%}%NWL%}  ; %NWL%defs . fill . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " fill "  )  ; %NWL%defs . border . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " border "  )  ; %NWL%9
rowspan  : this . rowspan || undefined ,%NWL%width   : this . width || undefined ,%NWL%placeholder : this . placeholder || undefined ,%NWL%id    : this . id ,%NWL%cls   : this . cls || undefined%NWL%}  ; %NWL%if ( this . valueField )  {%NWL%props . valueField = this . valueField ;%NWL%}%NWL%if ( this . displayField )  {%NWL%props . displayField = this . displayField ; %NWL%7
this . timestampParam = opts . timestampParam || ' t '  ; %NWL%this . timestampRequests = opts . timestampRequests ; %NWL%this . transports = opts . transports || [  ' polling '  ,  ' websocket '  ]  ; %NWL%this . readyState =  '  '  ; %NWL%this . writeBuffer =  [  ]  ; %NWL%this . callbackBuffer =  [  ]  ; %NWL%this . policyPort = opts . policyPort || 843 ; %NWL%this . rememberUpgrade = opts . rememberUpgrade || false ; %NWL%this . open (  )  ; %NWL%this . binaryType = null ; %NWL%this . onlyBinaryUpgrades = opts . onlyBinaryUpgrades ; %NWL%1
this . createPatterns (  )  ; %NWL%this . resetCurrentPattern (  )  ; %NWL%this . ticker = new Ticker (  )  ; %NWL%this . ticker . interval = 100 ; %NWL%this . ticker . callback = this . ontick . bind ( this )  ;%NWL%}  ,%NWL%createPatterns : function (  )  {%NWL%Object . keys ( this . data . patterns )  . forEach ( function ( patterName )  {%NWL%this [ patterName ]  = new Pattern ( this . data . patterns [ patterName ]  , this )  ; %NWL%this [ patterName ]  . context = this . context ; %NWL%this [ patterName ]  . master = this . master ; %NWL%9
}%NWL%}%NWL%}  )  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%if ( config . svg2js )  {%NWL%defaults . svg2js = config . svg2js ;%NWL%}%NWL%if ( config . js2svg )  {%NWL%defaults . js2svg = config . js2svg ; %NWL%7
assert . optionalObject ( options . headers ,  ' options . headers '  )  ; %NWL%assert . object ( options . log ,  ' options . log '  )  ; %NWL%assert . optionalFunc ( options . signRequest ,  ' options . signRequest '  )  ; %NWL%assert . optionalString ( options . socketPath ,  ' options . socketPath '  )  ; %NWL%assert . optionalString ( options . url ,  ' options . url '  )  ; %NWL%EventEmitter . call ( this )  ; %NWL%var self = this ; %NWL%this . agent = options . agent ; %NWL%this . ca = options . ca ; %NWL%this . cert = options . cert ; %NWL%this . ciphers = options . ciphers ; %NWL%7
if ( current =  =  = undefined && !extensible )%NWL%return this . _reject ( throwing ,  " object not extensible "  )  ; %NWL%if ( current =  =  = undefined && extensible )%NWL%{%NWL%var p ; %NWL%if ( IsGenericDescriptor ( desc ) || IsDataDescriptor ( desc )  )%NWL%{%NWL%p = new PropertyDescriptor (  )  ; %NWL%p . value = examine ( desc ,  " value "  , true )  ; %NWL%p . writable = examine ( desc ,  " writable "  , true )  ; %NWL%p . enumerable = examine ( desc ,  " enumerable "  , true )  ; %NWL%8
curLeft +  = element . scrollLeft ; %NWL%curTop +  = element . scrollTop ;%NWL%}%NWL%return { left : curLeft , top : curTop }  ;%NWL%}%NWL%function AnchorBox ( x , y , width , height )%NWL%{%NWL%this . x = x || 0 ; %NWL%this . y = y || 0 ; %NWL%this . width = width || 0 ; %NWL%this . height = height || 0 ; %NWL%7
"  ) ? "  +%NWL%"  ) ? "  +%NWL%"  ( ? :  "  +  /  / time zone%NWL%" Z| "  +  /  / UTC capture%NWL%"  (  [  +  -  ]  )  ( \\d\\d )  :  ( \\d\\d )  "  +  /  / timezone offset%NWL%"  ) ? "  +%NWL%" $ "  )  ; %NWL%for ( var key in NativeDate )%NWL%Date [ key ]  = NativeDate [ key ]  ; %NWL%Date . now = NativeDate . now ; %NWL%Date . UTC = NativeDate . UTC ; %NWL%9
this . start . row = fold . start . row ; %NWL%this . start . column = fold . start . column ;%NWL%}%NWL%} else if ( fold . start . row =  = this . end . row )  {%NWL%this . folds . push ( fold )  ; %NWL%this . end . row = fold . end . row ; %NWL%this . end . column = fold . end . column ;%NWL%} else if ( fold . end . row =  = this . start . row )  {%NWL%this . folds . unshift ( fold )  ; %NWL%this . start . row = fold . start . row ; %NWL%this . start . column = fold . start . column ; %NWL%6
this . dir = function (  )  { log ( arguments ,  ' dir '  )  ;  }  ; %NWL%this . dirxml = function (  )  { log ( arguments ,  ' dirxml '  )  ;  }  ; %NWL%this . error = function (  )  { log ( arguments ,  ' error '  )  ;  }  ; %NWL%this . exception = function (  )  { log ( arguments ,  ' exception '  )  ;  }  ; %NWL%this . group = function (  )  { log ( arguments ,  ' group '  )  ;  }  ; %NWL%this . groupCollapsed = function (  )  { log ( arguments ,  ' groupCollapsed '  )  ;  }  ; %NWL%this . groupEnd = function (  )  { log ( arguments ,  ' groupEnd '  )  ;  }  ; %NWL%this . info = function (  )  { log ( arguments ,  ' info '  )  ;  }  ; %NWL%this . log = function (  )  { log ( arguments ,  ' log '  )  ;  }  ; %NWL%this . profile = function (  )  { log ( arguments ,  ' profile '  )  ;  }  ; %NWL%this . profileEnd = function (  )  { log ( arguments ,  ' profileEnd '  )  ;  }  ; %NWL%0
if ( ! ( this instanceof Norch )  )  {%NWL%return new Norch ( options )  ;%NWL%}%NWL%var listToArray = function ( val )  {%NWL%return [  ]  . concat ( val . split (  '  ,  '  )  )  ;%NWL%}  ; %NWL%this . bodyParser = require (  ' body - parser '  )  ; %NWL%this . colors = require (  ' colors '  )  ; %NWL%this . fs = require (  ' fs '  )  ; %NWL%this . http = require (  ' http '  )  ; %NWL%this . path = require (  ' path '  )  ; %NWL%7
new_contact . jnAcc = old . jnAcc ; %NWL%new_contact . jtAcc = old . jtAcc ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%this . contacts = contacts ; %NWL%this . handler = handler ; %NWL%this . swappedColl =  ( a . collision_type ! =  = handler . a )  ; %NWL%this . e = a . e * b . e ; %NWL%this . u = a . u * b . u ; %NWL%9
headtrackr . camshift . Rectangle = function ( x , y , w , h )  {%NWL%this . x = x ; %NWL%this . y = y ; %NWL%this . width = w ; %NWL%this . height = h ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . camshift . Rectangle (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%c . x = this . x ; %NWL%c . y = this . y ; %NWL%7
var params = stmt . newBindingParamsArray (  )  ,%NWL%binding = params . newBindingParams (  )  ; %NWL%binding . bindByName (  " requestName "  , requestName )  ; %NWL%params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%request . requestUrl = stmt . row . requestUrl ; %NWL%7
this . saveSettings = function (  )%NWL%{%NWL%saveItem ( saveName . settings , uiSettings )  ;%NWL%}%NWL%this . restoreSettings = function (  )%NWL%{%NWL%var s = restoreItem ( saveName . settings )  ; %NWL%if ( !s ) return false ; %NWL%uiSettings . markOwnUnits = s . markOwnUnits ; %NWL%uiSettings . markEnemyUnits = s . markEnemyUnits ; %NWL%uiSettings . use3D = s . use3D ; %NWL%8
pathGroup . palette = args . palette ; %NWL%canvas . add ( pathGroup )  ; %NWL%return pathGroup ;%NWL%}  ; %NWL%var updateProperties = function ( obj , recvdObj )  {%NWL%obj . width = recvdObj . width ; %NWL%obj . height = recvdObj . height ; %NWL%obj . left = recvdObj . left ; %NWL%obj . top = recvdObj . top ; %NWL%obj . scaleX = recvdObj . scaleX ; %NWL%obj . scaleY = recvdObj . scaleY ; %NWL%5
this . config = configuration ; %NWL%this . connect = this . connect . bind ( this )  ; %NWL%this . _getConnections = this . connect . bind ( this )  ; %NWL%this . call = this . call . bind ( this )  ; %NWL%this . callProcedure = this . callProcedure . bind ( this )  ; %NWL%this . exit = this . connect . bind ( this )  ; %NWL%this . connectionStats = this . connectionStats . bind ( this )  ; %NWL%this . _connectListener = this . _connectListener . bind ( this )  ; %NWL%this . _connectErrorListener = this . _connectErrorListener . bind ( this )  ; %NWL%this . _queryResponseListener = this . _queryResponseListener . bind ( this )  ; %NWL%this . _queryResponseErrorListener = this . _queryResponseErrorListener . bind ( this )  ; %NWL%8
window . top . scrollTo ( 0 , 1 )  ;%NWL%}%NWL%function _update ( w , h )  {%NWL%canvasElement . width = w || window . innerWidth ; %NWL%canvasElement . height = h || window . innerHeight ;%NWL%}%NWL%function canvas (  )  {%NWL%return canvasElement ;%NWL%}%NWL%canvas . create = _create ; %NWL%canvas . fullScreen = _fullScreen ; %NWL%9
lodash . forInRight = objects . forInRight ; %NWL%lodash . forOwn = forOwn ; %NWL%lodash . forOwnRight = objects . forOwnRight ; %NWL%lodash . functions = objects . functions ; %NWL%lodash . groupBy = collections . groupBy ; %NWL%lodash . indexBy = collections . indexBy ; %NWL%lodash . initial = arrays . initial ; %NWL%lodash . intersection = arrays . intersection ; %NWL%lodash . invert = objects . invert ; %NWL%lodash . invoke = collections . invoke ; %NWL%lodash . keys = objects . keys ; %NWL%0
}  ; %NWL%return service ;%NWL%}  )  . controller (  " YaTreeviewCtrl "  ,  [  " $scope "  ,  " $timeout "  ,  " YaTreeviewService "  , function ( $scope , $timeout , YaTreeviewService )  {%NWL%var fillOptions = function ( clientOptions )  {%NWL%var options =  {  }  ; %NWL%clientOptions = clientOptions || {  }  ; %NWL%options . childrenKey = clientOptions . childrenKey || " children "  ; %NWL%options . hasChildrenKey = clientOptions . hasChildrenKey || " has_children "  ; %NWL%options . onExpand = clientOptions . onExpand || angular . noop ; %NWL%options . onCollapse = clientOptions . onCollapse || angular . noop ; %NWL%options . onSelect = clientOptions . onSelect || angular . noop ; %NWL%8
validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . registerHandler "  ; %NWL%wrapped . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . unregisterHandler "  ; %NWL%wrapped . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . send "  ; %NWL%wrapped . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . publish "  ; %NWL%wrapped . getConnectionState . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . getConnectionState "  ; %NWL%wrapped . isValidSession . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . isValidSession "  ; %NWL%5
fns . jqtpl = fromStringRenderer (  ' jqtpl '  )  ; %NWL%fns . jqtpl . render = function ( str , options , fn )  {%NWL%var engine = requires . jqtpl || ( requires . jqtpl = require ( sailsAppPath +  '  / jqtpl '  )  )  ; %NWL%try {%NWL%engine . template ( str , str )  ; %NWL%fn ( null , engine . tmpl ( str , options )  )  ;%NWL%} catch ( err )  {%NWL%fn ( err )  ;%NWL%}%NWL%}  ; %NWL%fns . haml = fromStringRenderer (  ' haml '  )  ; %NWL%0
name    : Sequelize . STRING%NWL%}  , noTimeStamps )  ; %NWL%exports . Track = Track = sequelize . define (  ' Track '  ,  {%NWL%title    : Sequelize . STRING ,%NWL%order    : Sequelize . INTEGER ,%NWL%filePath   : Sequelize . STRING ,%NWL%}  , noTimeStamps )  ; %NWL%Artist . hasMany ( Album )  ; %NWL%Album . hasMany ( Track )  ; %NWL%Album . belongsTo ( Artist )  ; %NWL%exports . Device = Device = sequelize . define (  ' Device '  ,  {%NWL%2
this . postCreate (  )  ;%NWL%}  ,%NWL%createElements : function (  )  {%NWL%this . node . innerHTML = SiteEditorTemplate ; %NWL%lib . processTextNodes ( this . node , messages )  ; %NWL%this . siteForm = lib . $ (  "  . siteForm "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name = lib . $ (  "  . siteConfigName "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name . id = this . id +  " _name "  ;  /  / $NON - NLS - 0$%NWL%this . nameInvalid = lib . $ (  "  . nameInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint = lib . $ (  "  . hostHint "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint . id = this . id +  " _hostHint "  ;  /  / $NON - NLS - 0$%NWL%7
function Attribute (  )  {%NWL%Y . AttributeCore . apply ( this , arguments )  ; %NWL%Y . AttributeObservable . apply ( this , arguments )  ; %NWL%Y . AttributeExtras . apply ( this , arguments )  ;%NWL%}%NWL%Y . mix ( Attribute , Y . AttributeCore , false , null , 1 )  ; %NWL%Y . mix ( Attribute , Y . AttributeExtras , false , null , 1 )  ; %NWL%Y . mix ( Attribute , Y . AttributeObservable , true , null , 1 )  ; %NWL%Attribute . INVALID_VALUE = Y . AttributeCore . INVALID_VALUE ; %NWL%Attribute . _ATTR_CFG = Y . AttributeCore . _ATTR_CFG . concat ( Y . AttributeObservable . _ATTR_CFG )  ; %NWL%Attribute . protectAttrs = Y . AttributeCore . protectAttrs ; %NWL%8
var superDesc =  ( possibleDesc ! =  = null && typeof possibleDesc =  =  =  ' object ' && possibleDesc . isDescriptor ) ? possibleDesc : undefined ; %NWL%superProperty = superDesc ;%NWL%}%NWL%if ( superProperty =  =  = undefined || ! ( superProperty instanceof ComputedProperty )  )  {%NWL%return property ;%NWL%}%NWL%property = o_create ( property )  ; %NWL%property . _getter = wrap ( property . _getter , superProperty . _getter )  ; %NWL%if ( superProperty . _setter )  {%NWL%if ( property . _setter )  {%NWL%property . _setter = wrap ( property . _setter , superProperty . _setter )  ; %NWL%7
Message . broadcast = function ( text )  {%NWL%Main . forEach ( function ( main )  {%NWL%Main . addMessage ( main , text )  ;%NWL%}  )  ;%NWL%}%NWL%Message . receive = function ( key , msg )  {%NWL%msg . from = Main . get ( key )  . username ; %NWL%if ( !Message . receive . test ( key , msg )  ) return ; %NWL%var parse = Message . parseText ( msg . text )  ;  	 /  / text%NWL%msg . hasItem = parse . hasItem ; %NWL%msg . hasPuush = parse . hasPuush ; %NWL%9
function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%this . suffix = __bind ( this . suffix , this )  ; %NWL%4
self . destroyed = false%NWL%self . errorEmitted = false%NWL%self . readable = self . writable = false%NWL%self . bytesRead = 0%NWL%self . _bytesDispatched = 0%NWL%self . _connecting = false%NWL%self . ondata = null%NWL%self . onend = null%NWL%if ( options . server )  {%NWL%self . server = options . server%NWL%self . id = options . id%NWL%9
top : args . top || 0 ,%NWL%left : args . left || $wrapper . offset (  )  . left%NWL%}  )  . addClass ( options . className )  ; %NWL%options . onStart . apply ( $this [ 0 ]  )  ; %NWL%$wrapper . addClass (  ' sticky - active '  )  ;%NWL%}  ,%NWL%_reset = function ( args )  {%NWL%args = args || {  }  ; %NWL%args . position = args . position || ' absolute '  ; %NWL%args . top = args . top || 0 ; %NWL%args . left = args . left || 0 ; %NWL%9
;  ( function ( undefined )  {%NWL%angular . module (  ' observeOnScopeApp '  ,  [  ' rx '  ]  )%NWL%. controller (  ' AppCtrl '  , function ( $scope , observeOnScope )  {%NWL%observeOnScope ( $scope ,  ' name '  )%NWL%. map ( function ( data )  {%NWL%return data ;%NWL%}  )%NWL%. subscribe ( function ( change )  {%NWL%$scope . observedChange = change ; %NWL%$scope . newValue = change . newValue ; %NWL%$scope . oldValue = change . oldValue ; %NWL%9
this . prev = null ; %NWL%this . match =  '  '  ; %NWL%this . index = 0 ; %NWL%this . pos =  - 1 ; %NWL%this . enc4 =  '   '  ; %NWL%this . next (  )  ;%NWL%}  ; %NWL%Iterator . prototype . clone = function (  )  {%NWL%var c = new Iterator ( this . id_array )  ; %NWL%c . prev = this . prev ; %NWL%c . match = this . match ; %NWL%9
if ( !relative . hostname ) relative . hostname =  '  '  ; %NWL%if ( relPath [ 0 ] ! =  =  '  '  ) relPath . unshift (  '  '  )  ; %NWL%if ( relPath . length < 2 ) relPath . unshift (  '  '  )  ; %NWL%result . pathname = relPath . join (  '  /  '  )  ;%NWL%} else {%NWL%result . pathname = relative . pathname ;%NWL%}%NWL%result . search = relative . search ; %NWL%result . query = relative . query ; %NWL%result . host = relative . host || '  '  ; %NWL%result . auth = relative . auth ; %NWL%5
}%NWL%if ( !Object . isSealed )  {%NWL%Object . isSealed = function isSealed ( object )  {%NWL%if ( Object ( object ) ! =  = object )  {%NWL%throw new TypeError (  ' Object . isSealed can only be called on Objects .  '  )  ;%NWL%}%NWL%return false ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isFrozen )  {%NWL%Object . isFrozen = function isFrozen ( object )  {%NWL%2
var actual =  '  '  ; %NWL%var expect =  '  '  ; %NWL%printBugNumber ( BUGNUMBER )  ; %NWL%printStatus ( summary )  ; %NWL%var count = 0 ; %NWL%var result =  "  "  ; %NWL%var value =  "  "  ; %NWL%var t = new Object (  )  ; %NWL%t . one =  " one "  ; %NWL%t . two =  " two "  ; %NWL%t . three =  " three "  ; %NWL%8
return 0 ; %NWL%return ( this . issuedOn / 1000 ) | 0 ;%NWL%}  ; %NWL%BadgeInstance . markAllAsSeen = function markAllAsSeen ( email , callback )  {%NWL%var query =  { user : email }  ; %NWL%var update =  { seen : true }  ; %NWL%var options =  { multi : true }  ; %NWL%BadgeInstance . update ( query , update , options , callback )  ;%NWL%}  ; %NWL%BadgeInstance . markAllAsRead = BadgeInstance . markAllAsSeen ; %NWL%BadgeInstance . deleteAllByUser = function deleteAllByUser ( email , callback )  {%NWL%3
canvas . hexagonalPixelate = wrap ( hexagonalPixelate )  ; %NWL%canvas . hueSaturation = wrap ( hueSaturation )  ; %NWL%canvas . colorHalftone = wrap ( colorHalftone )  ; %NWL%canvas . triangleBlur = wrap ( triangleBlur )  ; %NWL%canvas . unsharpMask = wrap ( unsharpMask )  ; %NWL%canvas . perspective = wrap ( perspective )  ; %NWL%canvas . matrixWarp = wrap ( matrixWarp )  ; %NWL%canvas . bulgePinch = wrap ( bulgePinch )  ; %NWL%canvas . tiltShift = wrap ( tiltShift )  ; %NWL%canvas . dotScreen = wrap ( dotScreen )  ; %NWL%canvas . edgeWork = wrap ( edgeWork )  ; %NWL%0
}  ,%NWL%setCssText : function ( val )  {%NWL%var sheet =  { cssRules :  [  ]  }  ; %NWL%var parser = new CSSParser ( val )  ; %NWL%var token = parser . getToken ( true , true )  ; %NWL%if ( token . isAtRule (  " @ - mozkeyframes "  )  )  {%NWL%if ( parser . parseKeyframesRule ( token , sheet )  )  {%NWL%var newRule = sheet . cssRules [ 0 ]  ; %NWL%this . cssRules = newRule . cssRules ; %NWL%this . name = newRule . name ; %NWL%this . parsedCssText = newRule . parsedCssText ; %NWL%8
return false ;%NWL%}  ,%NWL%getVersion : function ( name , field )  {%NWL%field = field || ' dependencies '  ; %NWL%return this . json [ field ]  [ name ]  ;%NWL%}%NWL%}  ; %NWL%SocketService . on (  ' bower '  , function ( data )  {%NWL%service . loaded = true ; %NWL%service . name = data . name ; %NWL%service . path = data . path ; %NWL%9
this . _y = y ; %NWL%this . _z = z ; %NWL%this . _order = order || this . _order ; %NWL%this . onChangeCallback (  )  ; %NWL%return this ;%NWL%}  ,%NWL%copy : function ( euler )  {%NWL%this . _x = euler . _x ; %NWL%this . _y = euler . _y ; %NWL%this . _z = euler . _z ; %NWL%this . _order = euler . _order ; %NWL%7
var robot ; %NWL%var cop ; %NWL%var text ; %NWL%function create (  )  {%NWL%game . stage . backgroundColor =  ' #404040 '  ; %NWL%chick = game . add . sprite ( 0 , 0 ,  ' atlas '  ,  ' budbrain_chick . png '  )  ; %NWL%chick . x = chick . animations . currentFrame . x ; %NWL%chick . y = chick . animations . currentFrame . y ; %NWL%car = game . add . sprite ( 0 , 0 ,  ' atlas '  ,  ' supercars_parsec . png '  )  ; %NWL%car . x = car . animations . currentFrame . x ; %NWL%car . y = car . animations . currentFrame . y ; %NWL%9
this . secondaryIndexes =  {  }  ; %NWL%this . globalIndexes =  {  }  ; %NWL%var context =  { hashKey : config . hashKey }  ; %NWL%var self = this ; %NWL%Joi . validate ( config , internals . configSchema ,  { context : context }  , function ( err , data )  {%NWL%if ( err )  {%NWL%var msg =  ' Invalid table schema , check your config '  ; %NWL%throw new Error ( msg + err . annotate (  )  )  ;%NWL%}%NWL%self . hashKey  = data . hashKey ; %NWL%self . rangeKey  = data . rangeKey ; %NWL%9
require (  "  .  / def / mozilla "  )  ; %NWL%require (  "  .  / def / e4x "  )  ; %NWL%require (  "  .  / def / fb - harmony "  )  ; %NWL%exports . Type = types . Type ; %NWL%exports . builtInTypes = types . builtInTypes ; %NWL%exports . namedTypes = types . namedTypes ; %NWL%exports . builders = types . builders ; %NWL%exports . defineMethod = types . defineMethod ; %NWL%exports . getFieldValue = types . getFieldValue ; %NWL%exports . eachField = types . eachField ; %NWL%exports . someField = types . someField ; %NWL%3
else if ( typeof ( this . highlightColors )  =  =  ' string '  )  {%NWL%this . highlightColors =  [  ]  ; %NWL%for ( var i = 0 ; i < this . _dataColors . length ; i +  +  )  {%NWL%this . highlightColors . push ( this . highlightColors )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%function preInit ( target , data , options )  {%NWL%options = options || {  }  ; %NWL%options . axesDefaults = options . axesDefaults || {  }  ; %NWL%options . grid = options . grid || {  }  ; %NWL%9
exports . center = function ( _coords )  {%NWL%if ( !arguments . length ) return center ; %NWL%center = _coords ; %NWL%return this ;%NWL%}  ; %NWL%exports . scale = function ( _scale )  {%NWL%if ( !arguments . length ) return scale ; %NWL%scale = _scale ; %NWL%return this ;%NWL%}  ; %NWL%exports . size = function ( _size )  {%NWL%5
SHA384 : require (  '  .  / sha384 '  )  . SHA384 ,%NWL%SHA512 : require (  '  .  / sha512 '  )  . SHA512 ,%NWL%SHA3 : require (  '  .  / sha3 '  )  . SHA3 ,%NWL%MD5 : require (  '  .  / md5 '  )  . MD5 ,%NWL%RIPEMD160 : require (  '  .  / ripemd160 '  )  . RIPEMD160%NWL%}  ; %NWL%exports . modes =  {%NWL%CTR : require (  '  .  / ctr '  )%NWL%}  ; %NWL%exports . scrypt = require (  '  .  / scrypt '  )  . scrypt ; %NWL%exports . pbkdf2 = require (  '  .  / pbkdf2 '  )  . pbkdf2 ; %NWL%9
this . collection ( function ( err , collection )  {%NWL%collection . find (  {  ' filename '  : self . filename }  , function ( err , cursor )  {%NWL%cursor . nextObject ( function ( err , doc )  {%NWL%if ( doc ! = null )  {%NWL%self . fileId = doc . _id ; %NWL%self . contentType = doc . contentType ; %NWL%self . internalChunkSize = doc . chunkSize ; %NWL%self . uploadDate = doc . uploadDate ; %NWL%self . aliases = doc . aliases ; %NWL%self . length = doc . length ; %NWL%self . metadata = doc . metadata ; %NWL%5
json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%json . colorSpread = this . colorSpread . toJSON ( json . colorSpread )  ; %NWL%json . time = this . time ; %NWL%json . _time = this . _time ; %NWL%json . duration = this . duration ; %NWL%json . loop = this . loop ; %NWL%json . playing = this . playing ; %NWL%json . emitting = this . emitting ; %NWL%0
exports . setFilter = defaultInstance . setFilter ; %NWL%exports . setTag = defaultInstance . setTag ; %NWL%exports . setExtension = defaultInstance . setExtension ; %NWL%exports . parseFile = defaultInstance . parseFile ; %NWL%exports . precompile = defaultInstance . precompile ; %NWL%exports . compile = defaultInstance . compile ; %NWL%exports . compileFile = defaultInstance . compileFile ; %NWL%exports . render = defaultInstance . render ; %NWL%exports . renderFile = defaultInstance . renderFile ; %NWL%exports . run = defaultInstance . run ; %NWL%exports . invalidateCache = defaultInstance . invalidateCache ; %NWL%0
var node = place ; %NWL%place = function ( n )  { node . appendChild ( n )  ;  }  ;%NWL%}%NWL%if ( options . lineNumbers ) place = wrapLineNumberDiv ( place )  ; %NWL%place ( frame )  ; %NWL%frame . CodeMirror = this ; %NWL%this . win = frame . contentWindow ; %NWL%if ( typeof options . parserfile =  =  " string "  )%NWL%options . parserfile =  [ options . parserfile ]  ; %NWL%if ( typeof options . stylesheet =  =  " string "  )%NWL%options . stylesheet =  [ options . stylesheet ]  ; %NWL%8
this . onMouseMove = function ( name , e )  {%NWL%var listeners = this . editor . _eventRegistry && this . editor . _eventRegistry . mousemove ; %NWL%if ( !listeners || !listeners . length )%NWL%return ; %NWL%this . editor . _emit ( name , new MouseEvent ( e , this . editor )  )  ;%NWL%}  ; %NWL%this . onMouseWheel = function ( name , e )  {%NWL%var mouseEvent = new MouseEvent ( e , this . editor )  ; %NWL%mouseEvent . speed = this . $scrollSpeed * 2 ; %NWL%mouseEvent . wheelX = e . wheelX ; %NWL%mouseEvent . wheelY = e . wheelY ; %NWL%9
}%NWL%outputStream . push ( out )  ;%NWL%}  ; %NWL%fluid . demands (  " flock . audioStrategy . platform "  ,  " flock . platform . nodejs "  ,  {%NWL%funcName :  " flock . audioStrategy . nodejs "%NWL%}  )  ; %NWL%fluid . registerNamespace (  " flock . midi . nodejs "  )  ; %NWL%flock . midi . nodejs . MIDIAccess = function ( options )  {%NWL%this . sysex = options . sysex ! =  = undefined ? options . sysex : false ; %NWL%this . input = new midi . input (  )  ; %NWL%this . output = new midi . output (  )  ; %NWL%9
!relobj . authority &&%NWL%!relobj . query%NWL%)  {%NWL%if ( relobj . fragment ! = n )  {%NWL%uriobj . fragment = relobj . fragment ;%NWL%}%NWL%relobj = uriobj ;%NWL%} else if ( !relobj . scheme )  {%NWL%relobj . scheme = uriobj . scheme ; %NWL%if ( !relobj . authority )  {%NWL%relobj . authority = uriobj . authority ; %NWL%8
if ( helper . isString ( options . reporters )  )  {%NWL%options . reporters = options . reporters . split (  '  ,  '  )  ;%NWL%}%NWL%if ( helper . isString ( options . removedFiles )  )  {%NWL%options . removedFiles = options . removedFiles . split (  '  ,  '  )  ;%NWL%}%NWL%if ( helper . isString ( options . addedFiles )  )  {%NWL%options . addedFiles = options . addedFiles . split (  '  ,  '  )  ;%NWL%}%NWL%if ( helper . isString ( options . changedFiles )  )  {%NWL%options . changedFiles = options . changedFiles . split (  '  ,  '  )  ; %NWL%1
}  ; %NWL%goog . graphics . Path . prototype . getCurrentPoint = function (  )  {%NWL%return this . currentPoint_ && this . currentPoint_ . concat (  )  ;%NWL%}  ; %NWL%goog . graphics . Path . prototype . clone = function (  )  {%NWL%var path = new this . constructor (  )  ; %NWL%path . segments_ = this . segments_ . concat (  )  ; %NWL%path . count_ = this . count_ . concat (  )  ; %NWL%path . arguments_ = this . arguments_ . concat (  )  ; %NWL%path . closePoint_ = this . closePoint_ && this . closePoint_ . concat (  )  ; %NWL%path . currentPoint_ = this . currentPoint_ && this . currentPoint_ . concat (  )  ; %NWL%9
handle . view . appendTo ( this . views )  ;%NWL%}%NWL%}  )  ; %NWL%var ConnectionView = Class ( View , function (  )  {%NWL%this . init = function ( conn )  {%NWL%this . conn = conn ; %NWL%conn . onSubscribed = bind ( this ,  ' onSubscribed '  )  ; %NWL%conn . onMessaged = bind ( this ,  ' onMessaged '  )  ; %NWL%conn . onOpen = bind ( this ,  ' onOpen '  )  ; %NWL%conn . onClose = bind ( this ,  ' onClose '  )  ; %NWL%conn . onError = bind ( this ,  ' onError '  )  ; %NWL%6
this . itemHeightsDirty = true ; %NWL%this . placeholders =  [  ]  ; %NWL%$ . extend ( true , this , defaultOptions , options )  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . onResize = __bind ( this . onResize , this )  ; %NWL%this . onRefresh = __bind ( this . onRefresh , this )  ; %NWL%this . getItemWidth = __bind ( this . getItemWidth , this )  ; %NWL%this . layout = __bind ( this . layout , this )  ; %NWL%this . layoutFull = __bind ( this . layoutFull , this )  ; %NWL%this . layoutColumns = __bind ( this . layoutColumns , this )  ; %NWL%this . filter = __bind ( this . filter , this )  ; %NWL%3
var f = document . forms [ 0 ]  , nl = f . elements , ed = tinyMCEPopup . editor , dom = ed . dom , n = ed . selection . getNode (  )  ; %NWL%tinyMCEPopup . resizeToInnerSize (  )  ; %NWL%this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%8
Telenode = require (  ' telenode '  )  ,%NWL%ReadWriteStream = require (  '  .  .  / common / read - write - stream '  )  ; %NWL%var Sms = module . exports = function Sms ( options )  {%NWL%if ( !options || !options . from || !options . to%NWL%|| ( !options . auth && !options . client )  )  {%NWL%throw new Error (  ' options . auth ( or options . client )  , options . from , and options . to are required '  )  ;%NWL%}%NWL%ReadWriteStream . call ( this )  ; %NWL%this . auth  = options . auth ; %NWL%this . to   = options . to ; %NWL%this . from  = options . from ; %NWL%8
}%NWL%self . minWidth = !colDef . minWidth ? 30 : colDef . minWidth ; %NWL%self . maxWidth = !colDef . maxWidth ? 9000 : colDef . maxWidth ; %NWL%self . field =  ( colDef . field =  =  = undefined ) ? colDef . name : colDef . field ; %NWL%if ( typeof ( self . field ) ! =  =  ' string '  )  {%NWL%gridUtil . logError (  ' Field is not a string , this is likely to break the code , Field is :  '  + self . field )  ;%NWL%}%NWL%self . name = colDef . name ; %NWL%self . displayName =  ( colDef . displayName =  =  = undefined ) ? gridUtil . readableColumnName ( colDef . name )  : colDef . displayName ; %NWL%self . aggregationType = angular . isDefined ( colDef . aggregationType ) ? colDef . aggregationType : null ; %NWL%self . footerCellTemplate = angular . isDefined ( colDef . footerCellTemplate ) ? colDef . footerCellTemplate : null ; %NWL%9
this . _ensureCapacity ( this . length * 2 )  ;%NWL%}%NWL%this . buffer [ this . tail ]  = x ; %NWL%this . tail =  ( this . tail + 1 ) & ( this . buffer . length - 1 )  ;%NWL%+  + this . length ; %NWL%return this . length ;%NWL%}  ; %NWL%Queue . prototype . shift = function (  )  {%NWL%var x = this . buffer [ this . head ]  ; %NWL%this . buffer [ this . head ]  = void 0 ; %NWL%this . head =  ( this . head + 1 ) & ( this . buffer . length - 1 )  ; %NWL%3
else if ( this . mbox_sha1sum ! =  = null )  {%NWL%result . mbox_sha1sum = this . mbox_sha1sum ;%NWL%}%NWL%else if ( this . openid ! =  = null )  {%NWL%result . openid = this . openid ;%NWL%}%NWL%else if ( this . account ! =  = null )  {%NWL%result . account = this . account . asVersion ( version )  ;%NWL%}%NWL%if ( this . name ! =  = null )  {%NWL%result . name = this . name ; %NWL%1
first +  +  ;%NWL%}%NWL%if ( dow =  = daysInMonth [ mon . getMonth (  )  ]  )  {%NWL%last = daysInMonth [ mon . getMonth (  )  ]  ;%NWL%}%NWL%if ( cls . length =  = 0 )  {%NWL%if (%NWL%today . getDate (  )  =  = date . getDate (  )%NWL%&& dow =  = date . getDate (  )%NWL%&& today . getMonth (  )  =  = date . getMonth (  )%NWL%&& today . getFullYear (  )  =  = date . getFullYear (  )%NWL%9
if ( v . name =  = varname ) return true ; %NWL%return false ;%NWL%}%NWL%var state = cx . state ; %NWL%if ( state . context )  {%NWL%cx . marked =  " def "  ; %NWL%if ( inList ( state . localVars )  ) return ; %NWL%state . localVars =  { name : varname , next : state . localVars }  ;%NWL%} else {%NWL%if ( inList ( state . globalVars )  ) return ; %NWL%state . globalVars =  { name : varname , next : state . globalVars }  ; %NWL%7
exports . createGalleryClient = gallery . createGalleryClient ; %NWL%var azureSchedulerManagement = require (  ' azure - mgmt - scheduler '  )  ; %NWL%exports . SchedulerManagementClient = azureSchedulerManagement . SchedulerManagementClient ; %NWL%exports . createSchedulerManagementClient = azureSchedulerManagement . createSchedulerManagementClient ; %NWL%var azureScheduler = require (  ' azure - scheduler '  )  ; %NWL%exports . SchedulerClient = azureScheduler . SchedulerClient ; %NWL%exports . createSchedulerClient = azureScheduler . createSchedulerClient ; %NWL%var azureMonitoring = require (  ' azure - monitoring '  )  ; %NWL%exports . EventsClient = azureMonitoring . EventsClient ; %NWL%exports . createEventsClient = azureMonitoring . createEventsClient ; %NWL%exports . AlertsClient = azureMonitoring . AlertsClient ; %NWL%8
return util . find ( fields , function ( field )  {%NWL%return field . pathName =  =  = dep . path && field . id =  =  = dep . field ;%NWL%}  ) || null ;%NWL%}%NWL%function Field ( props )  {%NWL%this . path = props . path ; %NWL%this . id = props . id ; %NWL%this . key = props . key ; %NWL%this . alias = props . alias ; %NWL%this . url = props . url ; %NWL%this . pathName = props . pathName ; %NWL%5
if ( CHECK_IS_ARRAY ( format )  =  =  = true )  {%NWL%isMatched = EACH ( format , function ( format )  {%NWL%return find ( format ) ! =  = true ;%NWL%}  ) ! =  = true ;%NWL%} else {%NWL%isMatched = find ( format )  ;%NWL%}%NWL%self . checkIsMatched = checkIsMatched = function (  )  {%NWL%return isMatched ;%NWL%}  ; %NWL%self . getURIParams = getURIParams = function (  )  {%NWL%7
return cb ( err )  ;%NWL%}%NWL%if ( code ! =  = 0 )  {%NWL%debug (  ' runGithub git clone bad exit code :  '  + code )  ; %NWL%return cb ( code )  ;%NWL%}%NWL%cb (  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . runCmds = workerRunCommon . runCmds ; %NWL%exports . runCmd = workerRunCommon . runCmd ; %NWL%9
b2 . Transform = Box2D . Common . Math . b2Transform ; %NWL%b2 . Math = Box2D . Common . Math . b2Math ; %NWL%b2 . BodyDef = Box2D . Dynamics . b2BodyDef ; %NWL%b2 . Body = Box2D . Dynamics . b2Body ; %NWL%b2 . FixtureDef = Box2D . Dynamics . b2FixtureDef ; %NWL%b2 . Fixture = Box2D . Dynamics . b2Fixture ; %NWL%b2 . World = Box2D . Dynamics . b2World ; %NWL%b2 . MassData = Box2D . Collision . Shapes . b2MassData ; %NWL%b2 . PolygonShape = Box2D . Collision . Shapes . b2PolygonShape ; %NWL%b2 . CircleShape = Box2D . Collision . Shapes . b2CircleShape ; %NWL%b2 . DebugDraw = Box2D . Dynamics . b2DebugDraw ; %NWL%2
}  )  ; %NWL%$rootScope . $on (  ' $routeChangeSuccess '  , function ( event , current , previous , rejection )  {%NWL%}  )  ; %NWL%$rootScope . $on (  ' $viewContentLoaded '  , function ( event )  {%NWL%}  )  ; %NWL%$rootScope . $on (  ' $includeContentLoaded '  , function ( event )  {%NWL%}  )  ; %NWL%$rootScope . settings = config ; %NWL%$rootScope . session = $session ; %NWL%$rootScope . filepicker = $filepicker ; %NWL%$rootScope . accessibility = $accessibility ; %NWL%8
if ( obj . hasOwnProperty (  " startY "  )  )  {%NWL%this . startY = obj . startY ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " chartType "  )  )  {%NWL%this . chartType = obj . chartType ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " gradientColor1 "  )  )  {%NWL%this . gradientColor1 = obj . gradientColor1 ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " gradientColor2 "  )  )  {%NWL%this . gradientColor2 = obj . gradientColor2 ; %NWL%1
}  ,%NWL%interceptAfter : function ( object , methodName , fn , scope )  {%NWL%var method = object [ methodName ] || Ext . emptyFn ; %NWL%return ( object [ methodName ]  = function (  )  {%NWL%method . apply ( this , arguments )  ; %NWL%return fn . apply ( scope || this , arguments )  ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%Ext . defer = Ext . Function . alias ( Ext . Function ,  ' defer '  )  ; %NWL%Ext . pass = Ext . Function . alias ( Ext . Function ,  ' pass '  )  ; %NWL%9
colObj . p . y = tileY * p . tileH + p . y + p . tileH / 2 ; %NWL%col = Q . collision ( obj , colObj )  ; %NWL%if ( col && col . magnitude > 0 &&%NWL%( !normal . collided || normal . magnitude < col . magnitude )  )  {%NWL%normal . collided = true ; %NWL%normal . separate [ 0 ]  = col . separate [ 0 ]  ; %NWL%normal . separate [ 1 ]  = col . separate [ 1 ]  ; %NWL%normal . magnitude = col . magnitude ; %NWL%normal . distance = col . distance ; %NWL%normal . normalX = col . normalX ; %NWL%normal . normalY = col . normalY ; %NWL%5
C . lua_topointer = F (  " lua_topointer "  , const_void_ptr_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushnil = F (  " lua_pushnil "  , void_t ,  [ lua_State ]  )  ; %NWL%C . lua_pushnumber = F (  " lua_pushnumber "  , void_t ,  [ lua_State , lua_Number ]  )  ; %NWL%C . lua_pushinteger = F (  " lua_pushinteger "  , void_t ,  [ lua_State , lua_Integer ]  )  ; %NWL%C . lua_pushlstring = F (  " lua_pushlstring "  , void_t ,  [ lua_State , const_char_ptr_t , size_t ]  )  ; %NWL%C . lua_pushstring = F (  " lua_pushstring "  , void_t ,  [ lua_State , const_char_ptr_t ]  )  ; %NWL%C . lua_pushcclosure = F (  " lua_pushcclosure "  , void_t ,  [ lua_State , lua_CFunction , int_t ]  )  ; %NWL%C . lua_pushboolean = F (  " lua_pushboolean "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushlightuserdata = F (  " lua_pushlightuserdata "  , void_t ,  [ lua_State , void_ptr_t ]  )  ; %NWL%C . lua_pushthread = F (  " lua_pushthread "  , int_t ,  [ lua_State ]  )  ; %NWL%C . lua_gettable = F (  " lua_gettable "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%7
if ( this . root_ . key =  = key )  {%NWL%return ;%NWL%}%NWL%var node = new SplayTree . Node ( key , value )  ; %NWL%if ( key > this . root_ . key )  {%NWL%node . left = this . root_ ; %NWL%node . right = this . root_ . right ; %NWL%this . root_ . right = null ;%NWL%} else {%NWL%node . right = this . root_ ; %NWL%node . left = this . root_ . left ; %NWL%6
json . format = this . format ; %NWL%json . wrap = this . wrap ; %NWL%return json ;%NWL%}  ; %NWL%RenderTarget . prototype . fromJSON = function ( json )  {%NWL%Class . prototype . fromJSON . call ( this , json )  ; %NWL%this . width = json . width ; %NWL%this . height = json . height ; %NWL%this . invWidth = json . invWidth ; %NWL%this . invHeight = json . invHeight ; %NWL%this . generateMipmap = json . generateMipmap ; %NWL%6
infoText . id =  ' progress_circle_info_ '  + this . id ; %NWL%document . body . appendChild ( infoText )  ; %NWL%this . infoText = infoText ;%NWL%}  ; %NWL%Circle . prototype =  {%NWL%constructor : Circle ,%NWL%update : function (  )  {%NWL%this . progress = this . progressListener (  )  ; %NWL%this . _draw (  )  ; %NWL%if ( this . infoListener )  {%NWL%this . info = this . infoListener (  )  ; %NWL%7
folder . add ( this ,  ' di '  , 0 . 0 , 2 . 0 )  . name (  ' Direct . Illum .  '  )  ; %NWL%folder . add ( this ,  ' ao '  , 0 . 0 , 1 . 0 )  . name (  ' SSAO '  )  ;%NWL%}%NWL%return CompositingControl ;%NWL%}  )  (  )  ; %NWL%Lighting =  ( function ( _super )  {%NWL%__extends ( Lighting , _super )  ; %NWL%function Lighting ( gui )  {%NWL%this . update = __bind ( this . update , this )  ; %NWL%this . bouncesChanged = __bind ( this . bouncesChanged , this )  ; %NWL%this . computeRadiance = __bind ( this . computeRadiance , this )  ; %NWL%8
}  ,%NWL%getRows : function (  )  {%NWL%return this . rows ;%NWL%}%NWL%}  , function (  )  {%NWL%Ext . define (  ' Ext . device . sqlite . SQLResultSetRowList '  ,  {%NWL%names : null ,%NWL%rows : null ,%NWL%constructor : function ( data )  {%NWL%this . names = data . names ; %NWL%this . rows = data . rows ; %NWL%9
this . container = document . createElement (  ' div '  )  ; %NWL%this . container . style . position =  ' absolute '  ; %NWL%this . container . style . width =  ' 250px '  ; %NWL%this . container . style . height =  ' 250px '  ; %NWL%this . container . style . visibility =  ' hidden '  ; %NWL%this . container . style . cursor =  ' pointer '  ; %NWL%this . container . addEventListener (  ' mousedown '  , onMouseDown , false )  ; %NWL%this . container . addEventListener (  ' touchstart '  , onTouchStart , false )  ; %NWL%hue = document . createElement (  " canvas "  )  ; %NWL%hue . width = gradient . width ; %NWL%hue . height = gradient . height ; %NWL%9
return reply . response ( err ! =  = null && err ! =  = undefined ? err : response )  ;%NWL%}  ; %NWL%reply . _replied = false ; %NWL%reply . _next = Hoek . once ( next )  ; %NWL%reply . realm = realm ; %NWL%reply . request = request ; %NWL%reply . response = internals . response ; %NWL%reply . close = internals . close ; %NWL%reply . state = internals . state ; %NWL%reply . unstate = internals . unstate ; %NWL%reply . redirect = internals . redirect ; %NWL%6
}  ; %NWL%exports . getPrimaryKey = getPrimaryKey ; %NWL%exports . createAPIRequest = function ( storeRequest , action , returnData )  {%NWL%var ret ; %NWL%var baseProps =  ' bucket primaryKey revision properties relations application returnData '  . w (  )  ; %NWL%var CUDProps =  ' key record '  . w (  )  ; %NWL%var baseReq = Tools . copyProperties ( baseProps , storeRequest ,  {  }  )  ; %NWL%switch ( action )  {%NWL%case Constants . ACTION_FETCH : %NWL%baseReq . conditions = Tools . copy ( storeRequest . conditions )  ; %NWL%baseReq . parameters = Tools . copy ( storeRequest . parameters )  ; %NWL%9
}%NWL%}  ; %NWL%Sequence . prototype . hasErrorHandler = function (  )  {%NWL%return this . _callback || this . listeners (  ' error '  )  . length > 1 ;%NWL%}  ; %NWL%Sequence . prototype . _packetToError = function ( packet )  {%NWL%var code = ErrorConstants [ packet . errno ] || ' UNKNOWN_CODE_PLEASE_REPORT '  ; %NWL%var err  = new Error ( code +  '  :  '  + packet . message )  ; %NWL%err . code = code ; %NWL%err . errno = packet . errno ; %NWL%err . sqlState = packet . sqlState ; %NWL%9
}  ,%NWL%setView : function ( center , zoom , bearing , pitch )  {%NWL%this . stop (  )  ; %NWL%var tr = this . transform ,%NWL%zoomChanged = tr . zoom ! =  =  + zoom ,%NWL%bearingChanged = tr . bearing ! =  =  + bearing ,%NWL%pitchChanged = tr . pitch ! =  =  + pitch ; %NWL%tr . center = LatLng . convert ( center )  ; %NWL%tr . zoom =  + zoom ; %NWL%tr . bearing =  + bearing ; %NWL%tr . pitch =  + pitch ; %NWL%8
if ( document . getElementById )  { this . use_gebi = true ;  }%NWL%else if ( document . all )  { this . use_css = true ;  }%NWL%else if ( document . layers )  { this . use_layers = true ;  }%NWL%else { this . type =  " WINDOW "  ;  }%NWL%this . offsetX = 0 ; %NWL%this . offsetY = 0 ; %NWL%this . getXYPosition = PopupWindow_getXYPosition ; %NWL%this . populate = PopupWindow_populate ; %NWL%this . setUrl = PopupWindow_setUrl ; %NWL%this . setWindowProperties = PopupWindow_setWindowProperties ; %NWL%this . refresh = PopupWindow_refresh ; %NWL%6
}%NWL%ReconnectingWebSocket . prototype . onopen = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onclose = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onconnecting = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onmessage = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onerror = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . debugAll = false ; %NWL%ReconnectingWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%ReconnectingWebSocket . OPEN = WebSocket . OPEN ; %NWL%ReconnectingWebSocket . CLOSING = WebSocket . CLOSING ; %NWL%ReconnectingWebSocket . CLOSED = WebSocket . CLOSED ; %NWL%7
_cstracker . track ( _inputcanvas )  ; %NWL%var csresult = _cstracker . getTrackObj (  )  ; %NWL%if ( params . debug )  {%NWL%params . debug . getContext (  ' 2d '  )  . putImageData ( _cstracker . getBackProjectionImg (  )  , 0 , 0 )  ;%NWL%}%NWL%var diff =  ( new Date )  . getTime (  )  - start ; %NWL%var result = new headtrackr . facetrackr . TrackObj (  )  ; %NWL%result . width = csresult . width ; %NWL%result . height = csresult . height ; %NWL%result . x = csresult . x ; %NWL%result . y = csresult . y ; %NWL%7
inherits ( BrowserHarness , Harness )%NWL%function BrowserHarness ( outPipe )  {%NWL%if ( browserHarness ) return browserHarness%NWL%if ( ! ( this instanceof BrowserHarness )  )  {%NWL%return browserHarness = new BrowserHarness%NWL%}%NWL%browserHarness = global . TAP_Browser_Harness = this%NWL%Harness . call ( this , Test )%NWL%if ( outPipe ) this . output . pipe ( outPipe )%NWL%this . test = this . test . bind ( this )%NWL%this . plan = this . plan . bind ( this )%NWL%9
}%NWL%if ( address . addressLine2 =  = this . options . emptyValue . addressLine2 )  {%NWL%address . addressLine2 =  '  '  ;%NWL%}%NWL%if ( address . city =  = this . options . emptyValue . city )  {%NWL%address . city =  '  '  ;%NWL%}%NWL%if ( address . state =  = this . options . emptyValue . state )  {%NWL%address . state =  '  '  ;%NWL%}%NWL%if ( address . zip =  = this . options . emptyValue . zip )  {%NWL%1
if ( typeof ( colDef . cellTooltip )  =  =  =  ' undefined ' || colDef . cellTooltip =  =  = false )  {%NWL%self . cellTooltip = false ;%NWL%} else if ( colDef . cellTooltip =  =  = true )  {%NWL%self . cellTooltip = function ( row , col )  {%NWL%return self . grid . getCellValue ( row , col )  ;%NWL%}  ;%NWL%} else {%NWL%self . cellTooltip = colDef . cellTooltip ;%NWL%}%NWL%self . footerCellClass = colDef . footerCellClass ; %NWL%self . cellClass = colDef . cellClass ; %NWL%7
setup : function (  )  {%NWL%this . timer = registry . get (  ' timer '  )  ; %NWL%this . level = registry . get (  ' currentLevel '  )  ; %NWL%this . input = registry . get (  ' input '  )  ; %NWL%var camera = this . camera = new THREE . PerspectiveCamera ( 25 , screenUtil . width / screenUtil . height , 50 , 1e7 )  ; %NWL%this . scene . add ( camera )  ; %NWL%var controls = this . controls = new SpaceshipControls ( camera )  ; %NWL%controls . movementSpeed = 0 ; %NWL%controls . rollSpeed = this . shipStats . rollSpeed ; %NWL%controls . maxSpeed = this . shipStats . maxSpeed ; %NWL%controls . inertia = this . shipStats . inertia ; %NWL%8
return $rootScope . $broadcast (  ' auth : login - error '  , error )  ;%NWL%}%NWL%}  ,%NWL%addScopeMethods : function (  )  {%NWL%$rootScope . user = this . user ; %NWL%$rootScope . authenticate = this . authenticate . bind ( this )  ; %NWL%$rootScope . signOut = this . signOut . bind ( this )  ; %NWL%$rootScope . destroyAccount = this . destroyAccount . bind ( this )  ; %NWL%$rootScope . submitRegistration = this . submitRegistration . bind ( this )  ; %NWL%$rootScope . submitLogin = this . submitLogin . bind ( this )  ; %NWL%$rootScope . requestPasswordReset = this . requestPasswordReset . bind ( this )  ; %NWL%5
this . inherited ( arguments )  ; %NWL%if ( this . showMoreLabel =  = null )%NWL%{%NWL%this . showMoreLabel =  " showMore . label "  ;%NWL%}%NWL%this . showMoreLabel = this . message ( this . showMoreLabel )  ; %NWL%if ( this . showLessLabel =  = null )%NWL%{%NWL%this . showLessLabel =  " showLess . label "  ;%NWL%}%NWL%this . showLessLabel = this . message ( this . showLessLabel )  ; %NWL%5
this . minSize = opts . minSize ! = undefined ? opts . minSize : 0 . 1 ; %NWL%this . maxSize = opts . maxSize ! = undefined ? opts . maxSize : 0 . 5 ; %NWL%this . sizeTween = new Tween ( opts . sizeTween )  ; %NWL%this . alphaTween = new Tween ( opts . alphaTween )  ; %NWL%this . colorTween = new Tween ( opts . colorTween )  ; %NWL%this . velocity = opts . velocity ! = undefined ? opts . velocity : new Vec3 ; %NWL%this . velocitySpread = opts . velocitySpread ! = undefined ? opts . velocitySpread : new Vec3 ; %NWL%this . acceleration = opts . acceleration ! = undefined ? opts . acceleration : new Vec3 ; %NWL%this . accelerationSpread = opts . accelerationSpread ! = undefined ? opts . accelerationSpread : new Vec3 ; %NWL%this . angularVelocity = opts . angularVelocity ! = undefined ? opts . angularVelocity : 0 ; %NWL%this . angularVelocitySpread = opts . angularVelocitySpread ! = undefined ? opts . angularVelocitySpread : 0 ; %NWL%9
this . regSerializer ( this . fourJointToJson , this . fourJointFromJson )  ; %NWL%return this ;%NWL%}%NWL%UIFourJoint . prototype . fourJointToJson = function ( o )  {%NWL%o . points =  [  {  }  ,  {  }  ,  {  }  ,  {  }  ]  ; %NWL%o . points [ 0 ]  . x = this . points [ 0 ]  . x ; %NWL%o . points [ 0 ]  . y = this . points [ 0 ]  . y ; %NWL%o . points [ 1 ]  . x = this . points [ 1 ]  . x ; %NWL%o . points [ 1 ]  . y = this . points [ 1 ]  . y ; %NWL%o . points [ 2 ]  . x = this . points [ 2 ]  . x ; %NWL%o . points [ 2 ]  . y = this . points [ 2 ]  . y ; %NWL%6
}%NWL%}  )  ;%NWL%}  )  )  ; %NWL%exports . ensureAuthenticated = function ensureAuthenticated ( req , res , next )  {%NWL%if ( req . isAuthenticated (  )  )  {%NWL%res . locals . user = req . user ; %NWL%return next (  )  ;%NWL%}%NWL%res . redirect (  '  / login '  )%NWL%}%NWL%exports . checkUser = function checkUser ( req , res , next )  {%NWL%3
this . angularAcceleration = json . angularAcceleration ; %NWL%this . angularVelocitySpread = json . angularVelocitySpread ; %NWL%this . randomAngle = json . randomAngle ; %NWL%this . emissionRate = json . emissionRate ; %NWL%this . color . fromJSON ( json . color )  ; %NWL%this . colorSpread . fromJSON ( json . colorSpread )  ; %NWL%this . time = json . time ; %NWL%this . _time = json . _time ; %NWL%this . duration = json . duration ; %NWL%this . loop = json . loop ; %NWL%this . playing = json . playing ; %NWL%0
Buffer = require (  ' buffer '  )  . Buffer ; %NWL%utils . createDeflate = function createDeflate ( version )  {%NWL%var deflate = zlib . createDeflate (  {%NWL%dictionary : spdy . protocol [ version ]  . dictionary ,%NWL%windowBits : 11%NWL%}  )  ; %NWL%deflate . locked = false ; %NWL%deflate . lockBuffer =  [  ]  ; %NWL%return deflate ;%NWL%}  ; %NWL%utils . createInflate = function createInflate ( version )  {%NWL%1
inherits ( BrowserHarness , Harness )%NWL%function BrowserHarness ( outPipe )  {%NWL%if ( browserHarness ) return browserHarness%NWL%if ( ! ( this instanceof BrowserHarness )  )  {%NWL%return browserHarness = new BrowserHarness%NWL%}%NWL%browserHarness = global . TAP_Browser_Harness = this%NWL%BrowserHarness . super . call ( this , Test )%NWL%if ( outPipe ) this . output . pipe ( outPipe )%NWL%this . test = this . test . bind ( this )%NWL%this . plan = this . plan . bind ( this )%NWL%9
}  ; %NWL%block . bullet =  /  ( ? :  [  *  +  -  ] |\d + \ .  )  /  ; %NWL%block . item =  / ^ (  *  )  ( bull )  [ ^\n ]  *  ( ? : \n ( ?!\1bull )  [ ^\n ]  *  )  *  /  ; %NWL%block . item = replace ( block . item ,  ' gm '  )%NWL%(  / bull / g , block . bullet )%NWL%(  )  ; %NWL%block . list = replace ( block . list )%NWL%(  / bull / g , block . bullet )%NWL%(  ' hr '  ,  / \n +  ( ? =  ( ? :  *  [  -  * _ ]  )  { 3 ,  }  *  ( ? : \n + |$ )  )  /  )%NWL%(  )  ; %NWL%block . html = replace ( block . html )%NWL%6
}%NWL%, createFlyingDot : function ( geo )  {%NWL%var marker = map . markers . list [ geo . ip ]%NWL%if ( !marker ) return%NWL%var source =  {%NWL%x : marker . ipList . object . parentNode . offsetLeft + marker . ipList . object . offsetLeft + 100%NWL%, y : marker . ipList . object . parentNode . offsetTop + marker . ipList . object . offsetTop + 6%NWL%}%NWL%var target = map . latLongToPx ( marker . latlon )%NWL%target . x +  = map . offset . x + map . margin%NWL%target . y +  = map . offset . y + map . margin%NWL%9
x : input . x ,%NWL%y : input . y%NWL%}  ; %NWL%if ( input . target ) continue ; %NWL%var x = input . x , y = input . y ; %NWL%var p = t ? m . multiplyPoint ( m . invert ( t )  , x , y )  :  {%NWL%x : x ,%NWL%y : y%NWL%}  ; %NWL%input . x = p . x ; %NWL%input . y = p . y ; %NWL%9
var emailPattern =  / ^ [ a - zA - Z0 - 9 . _ -  ]  + @ [ a - zA - Z0 - 9 .  -  ]  + \ .  [ a - zA - Z ]  { 2 , 4 } $ /  ; %NWL%return emailPattern . test ( email )  ;%NWL%}%NWL%window . IsEmail = IsEmail ; %NWL%function Viewport ( args )  {%NWL%this . el     = $ (  ' # '  + args . id )  . removeClass (  ' desktop tablet mobile '  )  . addClass ( args . iface )  ; %NWL%this . iface    = args . iface ; %NWL%this . device    = args . device ; %NWL%this . deviceOs   = args . deviceOs ; %NWL%this . onChange   = args . onChange ; %NWL%this . fbCanvas   = args . fbCanvas ; %NWL%6
if ( !this . equals )  {%NWL%this . equals = element . getAttribute (  ' equals '  )  ;%NWL%}  ; %NWL%if ( !this . callback )  {%NWL%this . callback = element . getAttribute (  ' callback '  )  ;%NWL%}  ; %NWL%if ( !this . realname )  {%NWL%this . realname = element . getAttribute (  ' realname '  )  ;%NWL%}  ; %NWL%if ( !this . max )  {%NWL%this . max = element . getAttribute (  ' max '  )  ; %NWL%1
req . acceptsCharsets = function (  )  {%NWL%var accept = accepts ( this )  ; %NWL%return accept . charsets . apply ( accept , arguments )  ;%NWL%}  ; %NWL%req . acceptsCharset = deprecate . function ( req . acceptsCharsets ,%NWL%' req . acceptsCharset : Use acceptsCharsets instead '  )  ; %NWL%req . acceptsLanguages = function (  )  {%NWL%var accept = accepts ( this )  ; %NWL%return accept . languages . apply ( accept , arguments )  ;%NWL%}  ; %NWL%req . acceptsLanguage = deprecate . function ( req . acceptsLanguages ,%NWL%4
this . attributeNamespace = null ; %NWL%this . oldValue = null ;%NWL%}%NWL%function copyMutationRecord ( original )  {%NWL%var record = new MutationRecord ( original . type , original . target )  ; %NWL%record . addedNodes = original . addedNodes . slice (  )  ; %NWL%record . removedNodes = original . removedNodes . slice (  )  ; %NWL%record . previousSibling = original . previousSibling ; %NWL%record . nextSibling = original . nextSibling ; %NWL%record . attributeName = original . attributeName ; %NWL%record . attributeNamespace = original . attributeNamespace ; %NWL%7
var locClearColor = this . _clearColor ; %NWL%locClearColor . r = clearColor . r ; %NWL%locClearColor . g = clearColor . g ; %NWL%locClearColor . b = clearColor . b ; %NWL%locClearColor . a = clearColor . a ; %NWL%this . _clearColorStr =  " rgba (  "  +  ( 0 | clearColor . r )  +  "  ,  "  +  ( 0 | clearColor . g )  +  "  ,  "  +  ( 0 | clearColor . b )  +  "  ,  "  + clearColor . a / 255 +  "  )  "  ;%NWL%}  ,%NWL%_setClearColorForWebGL : function ( clearColor )  {%NWL%var locClearColor = this . _clearColor ; %NWL%locClearColor . r = clearColor . r ; %NWL%locClearColor . g = clearColor . g ; %NWL%3
}  ; %NWL%OneThumbSlider . prototype . getCssClass = function ( orientation )  {%NWL%return goog . getCssName (  ' test - slider '  , orientation )  ;%NWL%}  ; %NWL%function TwoThumbSlider (  )  {%NWL%goog . ui . SliderBase . call ( this )  ;%NWL%}%NWL%goog . inherits ( TwoThumbSlider , goog . ui . SliderBase )  ; %NWL%TwoThumbSlider . prototype . createThumbs = function (  )  {%NWL%this . valueThumb = goog . dom . getElement (  ' valueThumb '  )  ; %NWL%this . extentThumb = goog . dom . getElement (  ' extentThumb '  )  ; %NWL%9
this . type = this . gl . UNSIGNED_BYTE ;%NWL%}%NWL%this . target = this . gl . TEXTURE_2D ;%NWL%}%NWL%Texture2D . prototype . upload = function ( image )  {%NWL%this . uploadImage ( image )  ; %NWL%return this ;%NWL%}  ; %NWL%Texture2D . prototype . uploadImage = function ( image )  {%NWL%this . width = image . width ; %NWL%this . height = image . height ; %NWL%9
if ( cookie . maxAge (  )  )%NWL%data . expires = Number . secondsToString ( parseInt ( cookie . maxAge (  )  , 10 )  )  ; %NWL%else if ( cookie . expires (  )  )%NWL%data . expires = new Date ( cookie . expires (  )  )  . toGMTString (  )  ; %NWL%else%NWL%data . expires = WebInspector . UIString (  " Session "  )  ;%NWL%}%NWL%data . size = cookie . size (  )  ; %NWL%const checkmark =  " \u2713 "  ; %NWL%data . httpOnly =  ( cookie . httpOnly (  ) ? checkmark :  "  "  )  ; %NWL%data . secure =  ( cookie . secure (  ) ? checkmark :  "  "  )  ; %NWL%9
}  ; %NWL%var proto = sp . Skeleton . WebGLRenderCmd . prototype = Object . create ( cc . Node . WebGLRenderCmd . prototype )  ; %NWL%proto . constructor = sp . Skeleton . WebGLRenderCmd ; %NWL%proto . rendering = function ( ctx )  {%NWL%var node = this . _node ; %NWL%this . _shaderProgram . use (  )  ; %NWL%this . _shaderProgram . _setUniformForMVPMatrixWithMat4 ( this . _stackMatrix )  ; %NWL%var color = node . getColor (  )  , locSkeleton = node . _skeleton ; %NWL%locSkeleton . r = color . r / 255 ; %NWL%locSkeleton . g = color . g / 255 ; %NWL%locSkeleton . b = color . b / 255 ; %NWL%9
for ( var i in options )  {%NWL%if ( params . options [ i ]  =  =  = undefined ) params . options [ i ]  = options [ i ]%NWL%}%NWL%return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . post = def ( request . post )%NWL%de . put = def ( request . put )%NWL%8
else if ( this . response )  {%NWL%this . response . abort (  )%NWL%}%NWL%this . emit (  " abort "  )%NWL%}%NWL%Request . prototype . pipeDest = function ( dest )  {%NWL%var response = this . response%NWL%if ( dest . headers )  {%NWL%dest . headers [  ' content - type '  ]  = response . headers [  ' content - type '  ]%NWL%if ( response . headers [  ' content - length '  ]  )  {%NWL%dest . headers [  ' content - length '  ]  = response . headers [  ' content - length '  ]%NWL%8
}%NWL%var space = fill . space ; %NWL%switch ( fill . type )  {%NWL%case " linear "  : %NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeX " || space =  =  =  " shapeY "  )  {%NWL%fill = gfx . makeParameters ( gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeX "  )  {%NWL%var span = dim . height - offsets . t - offsets . b ; %NWL%fill . y1 = offsets . t + span * fill . y1 / 100 ; %NWL%fill . y2 = offsets . t + span * fill . y2 / 100 ; %NWL%9
this . options = Object . extend (  {%NWL%interval : 0 . 1 ,%NWL%resultsElement :  '  . search - results '%NWL%}  , options || {  }  )  ; %NWL%this . element . writeAttribute (  " autocomplete "  ,  " off "  )  ; %NWL%this . element . up (  ' form '  )  . observe (  " submit "  , Event . stop )  ; %NWL%if ( Prototype . Browser . WebKit )%NWL%this . element . type =  " search "  ; %NWL%this . menu = this . options . menu ; %NWL%this . links = this . menu . select (  ' a '  )  ; %NWL%this . resultsElement = this . options . resultsElement ; %NWL%8
}  )  ;%NWL%}%NWL%if ( values )  {%NWL%Object . keys ( values )  . forEach ( function ( name )  {%NWL%that [ name ]  = values [ name ]  ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%Message . messageType = Message . prototype . messageType = details . messageType ; %NWL%Message . packageName = Message . prototype . packageName = details . packageName ; %NWL%Message . messageName = Message . prototype . messageName = details . messageName ; %NWL%8
this . get = pd . get ; %NWL%if (  " set " in pd )%NWL%this . set = pd . set ; %NWL%if (  " configurable " in pd )%NWL%this . configurable = pd . configurable ; %NWL%if (  " writable " in pd )%NWL%this . writable = pd . writable ; %NWL%if (  " enumerable " in pd )%NWL%this . enumerable = pd . enumerable ; %NWL%if (  " value " in pd )%NWL%this . value = pd . value ; %NWL%0
}  )  ; %NWL%loader . crossOrigin = this . crossOrigin ; %NWL%loader . load ( url , image )  ;%NWL%}%NWL%return texture ;%NWL%}  ; %NWL%THREE . MTLLoader . ensurePowerOfTwo_ = function ( image )  {%NWL%if ( ! THREE . MTLLoader . isPowerOfTwo_ ( image . width ) || ! THREE . MTLLoader . isPowerOfTwo_ ( image . height )  )  {%NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%canvas . width = THREE . MTLLoader . nextHighestPowerOfTwo_ ( image . width )  ; %NWL%canvas . height = THREE . MTLLoader . nextHighestPowerOfTwo_ ( image . height )  ; %NWL%9
var Peer = Class (  {%NWL%initialize : function ( clientId )  {%NWL%this . clientId = clientId ; %NWL%this . name =  " Unknown "  ; %NWL%this . avatar = null ; %NWL%this . color =  " #ff0000 "  ; %NWL%this . newPeer = true ;%NWL%}  ,%NWL%update : function ( msg )  {%NWL%this . name = msg . name || this . name ; %NWL%this . avatar = msg . avatar || this . avatar ; %NWL%9
}  ; %NWL%window . RTCPeerConnection = window . RTCPeerConnection ||%NWL%window . webkitRTCPeerConnection ||%NWL%window . mozRTCPeerConnection ||%NWL%function (  )  {%NWL%}  ; %NWL%window . RTCIceCandidate = window . RTCIceCandidate ||%NWL%window . mozRTCIceCandidate ||%NWL%function (  )  {%NWL%}  ; %NWL%window . RTCSessionDescription = window . RTCSessionDescription ||%NWL%1
name :  " toggleRegexpMode "  ,%NWL%bindKey :  { win :  " Alt - R|Alt -  /  "  , mac :  " Ctrl - Alt - R|Ctrl - Alt -  /  "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . regExpOption . checked = !sb . regExpOption . checked ; %NWL%sb . $syncOptions (  )  ;%NWL%}%NWL%}  ,  {%NWL%name :  " toggleCaseSensitive "  ,%NWL%bindKey :  { win :  " Alt - C|Alt - I "  , mac :  " Ctrl - Alt - R|Ctrl - Alt - I "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . caseSensitiveOption . checked = !sb . caseSensitiveOption . checked ; %NWL%3
if ( !o . shape || o . type ! =  =  " onmouseover "  )  { return ;  }%NWL%var aroundRect =  { type :  " rect "  }  , position =  [  " after "  ,  " before "  ]  ; %NWL%switch ( o . element )  {%NWL%case " marker "  : %NWL%aroundRect . x = o . cx ; %NWL%aroundRect . y = o . cy ; %NWL%aroundRect . w = aroundRect . h = 1 ; %NWL%break ; %NWL%case " circle "  : %NWL%aroundRect . x = o . cx - o . cr ; %NWL%aroundRect . y = o . cy - o . cr ; %NWL%9
dupes . length = 0 ; %NWL%objs . length = 0 ; %NWL%if ( !rect ) continue ; %NWL%rect . _w = rect . _x + rect . _w ; %NWL%rect . _h = rect . _y + rect . _h ; %NWL%rect . _x =  ( rect . _x > 0 ) ? ( rect . _x|0 )  :  ( rect . _x|0 )  - 1 ; %NWL%rect . _y =  ( rect . _y > 0 ) ? ( rect . _y|0 )  :  ( rect . _y|0 )  - 1 ; %NWL%rect . _w -  = rect . _x ; %NWL%rect . _h -  = rect . _y ; %NWL%rect . _w =  ( rect . _w =  =  =  ( rect . _w|0 )  ) ? rect . _w :  ( rect . _w|0 )  + 1 ; %NWL%rect . _h =  ( rect . _h =  =  =  ( rect . _h|0 )  ) ? rect . _h :  ( rect . _h|0 )  + 1 ; %NWL%9
this . expr = expr ; %NWL%this . block = block ;%NWL%}  ; %NWL%Each . prototype . __proto__ = Node . prototype ; %NWL%Each . prototype . clone = function ( parent )  {%NWL%var clone = new Each ( this . val , this . key )  ; %NWL%clone . expr = this . expr . clone ( parent , clone )  ; %NWL%clone . block = this . block . clone ( parent , clone )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%clone . filename = this . filename ; %NWL%8
}  ; %NWL%OIT . prototype . isDestroyed = function (  )  {%NWL%return false ;%NWL%}  ; %NWL%OIT . prototype . destroy = function (  )  {%NWL%destroyResources ( this )  ; %NWL%if ( defined ( this . _compositeCommand )  )  {%NWL%this . _compositeCommand . shaderProgram = this . _compositeCommand . shaderProgram && this . _compositeCommand . shaderProgram . destroy (  )  ;%NWL%}%NWL%if ( defined ( this . _adjustTranslucentCommand )  )  {%NWL%this . _adjustTranslucentCommand . shaderProgram = this . _adjustTranslucentCommand . shaderProgram && this . _adjustTranslucentCommand . shaderProgram . destroy (  )  ; %NWL%7
var self = this ; %NWL%this . toolname =  " roitool "  ; %NWL%this . box_roi_x = document . getElementById (  " box_roi_x "  )  ; %NWL%this . box_roi_y = document . getElementById (  " box_roi_y "  )  ; %NWL%this . box_roi_w = document . getElementById (  " box_roi_w "  )  ; %NWL%this . box_roi_h = document . getElementById (  " box_roi_h "  )  ; %NWL%this . box_roi_r = document . getElementById (  " box_roi_r "  )  ; %NWL%this . mouseCatcher = document . createElement (  " div "  )  ; %NWL%this . mouseCatcher . className =  " sliceMouseCatcher "  ; %NWL%this . mouseCatcher . style . cursor =  " default "  ; %NWL%this . button_roi_apply = document . getElementById (  " button_roi_apply "  )  ; %NWL%2
}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%this . prefix = __bind ( this . prefix , this )  ; %NWL%this . suffix = __bind ( this . suffix , this )  ; %NWL%this . date = __bind ( this . date , this )  ; %NWL%1
return res ;%NWL%}  ,%NWL%printStartup : function ( startup )  {%NWL%var arr =  [  ]  ; %NWL%if ( startup . order ! =  = undefined && startup . order ! =  =  '  '  )  {%NWL%arr . push (  ' order =  '  + startup . order )  ;%NWL%}%NWL%if ( startup . up ! =  = undefined && startup . up ! =  =  '  '  )  {%NWL%arr . push (  ' up =  '  + startup . up )  ;%NWL%}%NWL%if ( startup . down ! =  = undefined && startup . down ! =  =  '  '  )  {%NWL%4
' use strict '  ; %NWL%var pkg     = require (  '  .  .  / package . json '  )  ; %NWL%var dotenv    = require (  ' dotenv '  )  ;  /  / https :  /  / www . npmjs . com / package / dotenv%NWL%dotenv . load (  )  ; %NWL%var config    =  {  }  ; %NWL%config . name    = pkg . name ; %NWL%config . version   = pkg . version ; %NWL%config . description  = pkg . description ; %NWL%config . company   = pkg . company ; %NWL%config . author   = pkg . author ; %NWL%config . keywords   = pkg . keywords ; %NWL%5
if ( request . sort )  {%NWL%reqParams . sort = jsonUtil . toJson ( request . sort )  ;%NWL%}%NWL%if ( request . queryOptions )  {%NWL%reqParams . queryOptions = jsonUtil . toJson ( request . queryOptions )  ;%NWL%}%NWL%if ( typeof request . start =  =  " number "  )  {%NWL%reqParams . start =  "  "  + request . start ;%NWL%}%NWL%if ( typeof request . count =  =  " number "  )  {%NWL%reqParams . count =  "  "  + request . count ; %NWL%7
if ( !forceMovement )  {%NWL%this . _interpolationManager . LoadPayload ( payload )  ;%NWL%} else {%NWL%this . Position = payload . Position ; %NWL%this . Rotation = payload . Rotation ;%NWL%}%NWL%if ( !this . UserControlled || forceMovement )  {%NWL%this . Mass = payload . Mass ; %NWL%this . Forces = payload . Forces ; %NWL%this . Velocity = payload . Velocity ; %NWL%this . Moving = payload . Moving ; %NWL%3
var index =  [  ]  ; %NWL%var categories =  {%NWL%Combine :  [  ]  ,%NWL%Transform :  [  ]  ,%NWL%Calculate :  [  ]  ,%NWL%Filter :  [  ]  ,%NWL%Special :  [  ]%NWL%}  ; %NWL%function addFuncDef ( funcDef )  {%NWL%funcDef . params = funcDef . params || [  ]  ; %NWL%funcDef . defaultParams = funcDef . defaultParams || [  ]  ; %NWL%9
var cwd = path . dirname ( process . execPath )  ;%NWL%}%NWL%var module = new Module ( name )  ; %NWL%module . filename = path . join ( cwd , name )  ; %NWL%module . paths = Module . _nodeModulePaths ( cwd )  ; %NWL%var script = process . _eval ; %NWL%var body = script ; %NWL%script =  ' global . __filename =  '  + JSON . stringify ( name )  +  '  ; \n '  +%NWL%' global . exports = exports ; \n '  +%NWL%' global . module = module ; \n '  +%NWL%' global . __dirname = __dirname ; \n '  +%NWL%8
template ,%NWL%css%NWL%)  {%NWL%return declare (  [ _WidgetBase , _TemplatedMixin , _AppAware , _StateAware , _NavigationMixin , _FooterMixin ]  ,  {%NWL%router : null ,%NWL%request : null ,%NWL%session : null ,%NWL%templateString : template ,%NWL%constructor : function ( params )  {%NWL%this . router = params . router ; %NWL%this . request = params . request ; %NWL%9
now . setMotion ( dmData )  ;%NWL%}%NWL%function setTripComputer (  )  {%NWL%var tcData = new Object (  )  ; %NWL%tcData . c1 = $ (  ' #tc - c1 '  )  . val (  )  ; %NWL%tcData . c2 = $ (  ' #tc - c2 '  )  . val (  )  ; %NWL%tcData . s1 = $ (  ' #tc - s1 '  )  . val (  )  ; %NWL%tcData . s2 = $ (  ' #tc - s2 '  )  . val (  )  ; %NWL%tcData . d = $ (  ' #tc - d '  )  . val (  )  ; %NWL%tcData . m = $ (  ' #tc - m '  )  . val (  )  ; %NWL%tcData . r = $ (  ' #tc - r '  )  . val (  )  ; %NWL%4
dojo . provide (  " dojox . charting . Theme "  )  ; %NWL%dojo . require (  " dojox . gfx "  )  ; %NWL%dojo . require (  " dojox . charting . _color "  )  ;%NWL%( function (  )  {%NWL%var dxc = dojox . charting ; %NWL%dxc . Theme = function ( kwArgs )  {%NWL%kwArgs = kwArgs|| {  }  ; %NWL%this . chart = dojo . mixin ( dojo . clone ( dxc . Theme . _def . chart )  , kwArgs . chart|| {  }  )  ; %NWL%this . axis = dojo . mixin ( dojo . clone ( dxc . Theme . _def . axis )  , kwArgs . axis|| {  }  )  ; %NWL%this . series = dojo . mixin ( dojo . clone ( dxc . Theme . _def . series )  , kwArgs . series|| {  }  )  ; %NWL%this . marker = dojo . mixin ( dojo . clone ( dxc . Theme . _def . marker )  , kwArgs . marker|| {  }  )  ; %NWL%7
setLineWidth : function ( width )  {%NWL%this . _lineWidth = width ;%NWL%}  ,%NWL%getLineWidth : function (  )  {%NWL%return this . _lineWidth ;%NWL%}  ,%NWL%setDrawColor : function ( color )  {%NWL%var locDrawColor = this . _drawColor ; %NWL%locDrawColor . r = color . r ; %NWL%locDrawColor . g = color . g ; %NWL%locDrawColor . b = color . b ; %NWL%9
{%NWL%var gameWorldObj =  {  }  ; %NWL%gameWorldObj . Cells  = gameWorld ;  /  / hack because this was written for clientside originally . sorry time is short :  /%NWL%return new GameWorldModelIso ( gameWorldObj , cameraX , cameraY , canvasWidth , canvasHeight , cellWidth , cellHeight )  ;%NWL%}%NWL%exports . update = GameWorldModelIso . prototype . update ; %NWL%exports . getAllVisibleCells = GameWorldModelIso . prototype . getAllVisibleCells ; %NWL%exports . getSortCellOfSprite = GameWorldModelIso . prototype . getSortCellOfSprite ; %NWL%exports . getRandomOnScreenCel = GameWorldModelIso . prototype . getRandomOnScreenCel ; %NWL%exports . getRandomOnScreenCellWorldValues = GameWorldModelIso . prototype . getRandomOnScreenCellWorldValues ; %NWL%exports . getVisibleCellFromWorldCell = GameWorldModelIso . prototype . getVisibleCellFromWorldCell ; %NWL%5
test = Y . guid (  )  ; %NWL%try {%NWL%LS . setItem ( test , test )  ; %NWL%LS . removeItem ( test )  ; %NWL%return true ;%NWL%} catch ( e )  {%NWL%return false ;%NWL%}%NWL%}  )  (  )  ,%NWL%LocalSync . _data = LocalSync . _data || {  }  ; %NWL%LocalSync . _store = LocalSync . _store || {  }  ; %NWL%9
this . domElement . parentNode . appendChild ( this . div )  ; %NWL%this . div . innerHTML = this . getHTML ( box . width , box . height )  ;%NWL%}  ,%NWL%positionElement : function (  )  {%NWL%var box = ZeroClipboard . getDOMObjectPosition ( this . domElement )  ; %NWL%var style = this . div . style ; %NWL%style . position =  ' absolute '  ; %NWL%style . left =  ( this . domElement . offsetLeft )  +  ' px '  ; %NWL%style . top = this . domElement . offsetTop +  ' px '  ; %NWL%style . width = box . width +  ' px '  ; %NWL%style . height = box . height +  ' px '  ; %NWL%9
setBindings : function (  )  {%NWL%this . importFile = this . importFile . bind ( this )  ; %NWL%this . onUndoRedoStateChanged = this . onUndoRedoStateChanged . bind ( this )  ; %NWL%this . onAttributeChange = this . onAttributeChange . bind ( this )  ; %NWL%this . onCollaboratorChange = this . onCollaboratorChange . bind ( this )  ; %NWL%this . onCollaborativeStringEvent =%NWL%this . onCollaborativeStringEvent . bind ( this )  ; %NWL%this . onListChange = this . onListChange . bind ( this )  ; %NWL%this . onReferenceShifted = this . onReferenceShifted . bind ( this )  ; %NWL%this . onCursorsChange = this . onCursorsChange . bind ( this )  ; %NWL%this . onMapValueChanged = this . onMapValueChanged . bind ( this )  ; %NWL%1
return {%NWL%initialize : function ( baseOptions )  {%NWL%baseOptions . onRegisterApi = baseOptions . onRegisterApi || angular . noop (  )  ; %NWL%baseOptions . data = baseOptions . data || [  ]  ; %NWL%baseOptions . columnDefs = baseOptions . columnDefs || [  ]  ; %NWL%baseOptions . excludeProperties = baseOptions . excludeProperties || [  ' $$hashKey '  ]  ; %NWL%baseOptions . enableRowHashing = baseOptions . enableRowHashing ! =  = false ; %NWL%baseOptions . rowIdentity = baseOptions . rowIdentity || function rowIdentity ( row )  {%NWL%return gridUtil . hashKey ( row )  ;%NWL%}  ; %NWL%baseOptions . getRowIdentity = baseOptions . getRowIdentity || function getRowIdentity ( row )  {%NWL%7
restrict :  ' A '  ,%NWL%replace : true ,%NWL%templateUrl :  ' partials / line - timeseries . html '  ,%NWL%scope :  {%NWL%data :  '  =  '%NWL%}  ,%NWL%link : function ( scope )  {%NWL%scope . yAxisTickFormat = D3Service . yAxisIntegerTickFormat ; %NWL%scope . xAxisTickFormat = D3Service . xAxisTickFormat ; %NWL%scope . yFunction = D3Service . yFunction ; %NWL%scope . xFunction = D3Service . xFunction ; %NWL%8
o = args && args [ 0 ]  ; %NWL%if ( Y . Lang . isObject ( o , true )  )  {%NWL%o2 =  {  }  ; %NWL%Y . mix ( o2 , ef , true , FACADE_KEYS )  ; %NWL%Y . mix ( ef , o , true )  ; %NWL%Y . mix ( ef , o2 , true , FACADE_KEYS )  ; %NWL%ef . type = o . type || ef . type ;%NWL%}%NWL%ef . details = this . details ; %NWL%ef . target = this . originalTarget || this . target ; %NWL%ef . currentTarget = this . currentTarget ; %NWL%8
)  ; %NWL%dojox . drawing . manager . Anchor = dojox . drawing . util . oo . declare (%NWL%function ( options )  {%NWL%this . defaults = dojox . drawing . defaults . copy (  )  ; %NWL%this . mouse = options . mouse ; %NWL%this . point = options . point ; %NWL%this . pointIdx = options . pointIdx ; %NWL%this . util = options . util ; %NWL%this . id = options . id || this . util . uid (  " anchor "  )  ; %NWL%this . org = dojo . mixin (  {  }  , this . point )  ; %NWL%this . stencil = options . stencil ; %NWL%4
var childNodes = el . childNodes ; %NWL%function createNode ( type )  {%NWL%var newNode =  { x : 0 , y : 0 }  ; %NWL%newNode . type = type ; %NWL%return newNode ;%NWL%}%NWL%if ( tag =  =  =  " b "  )  {%NWL%this . bold = this . bold + 1 ;%NWL%}%NWL%else if ( tag =  =  =  " i "  )  {%NWL%this . italic = this . italic + 1 ; %NWL%7
material . shader . setUniformBySemantic ( _gl ,  ' SKIN_MATRIX '  , skinMatricesArray )  ;%NWL%}%NWL%return Renderable . prototype . render . call ( this , _gl , globalMaterial )  ;%NWL%}%NWL%}  )  ; %NWL%Mesh . POINTS = glenum . POINTS ; %NWL%Mesh . LINES = glenum . LINES ; %NWL%Mesh . LINE_LOOP = glenum . LINE_LOOP ; %NWL%Mesh . LINE_STRIP = glenum . LINE_STRIP ; %NWL%Mesh . TRIANGLES = glenum . TRIANGLES ; %NWL%Mesh . TRIANGLE_STRIP = glenum . TRIANGLE_STRIP ; %NWL%5
var env = jasmine . getEnv (  )  ; %NWL%env . addReporter ( new jasmine . HtmlReporter )  ; %NWL%env . addReporter ( new jasmine . PrintReporter )  ; %NWL%function exposeFrom ( obj )  {%NWL%obj . spyOn = jasmine . spyOn ; %NWL%obj . it = jasmine . it ; %NWL%obj . xit = jasmine . xit ; %NWL%obj . expect = jasmine . expect ; %NWL%obj . runs = jasmine . runs ; %NWL%obj . waits = jasmine . waits ; %NWL%obj . waitsFor = jasmine . waitsFor ; %NWL%4
spdy . protocol =  {  }  ; %NWL%try {%NWL%spdy . protocol . generic = require (  '  .  / spdy / protocol / generic . node '  )  ;%NWL%} catch ( e )  {%NWL%spdy . protocol . generic = require (  '  .  / spdy / protocol / generic . js '  )  ;%NWL%}%NWL%spdy . protocol [ 2 ]  = require (  '  .  / spdy / protocol / v2 '  )  ; %NWL%spdy . protocol [ 3 ]  = require (  '  .  / spdy / protocol / v3 '  )  ; %NWL%spdy . parser = require (  '  .  / spdy / parser '  )  ; %NWL%spdy . response = require (  '  .  / spdy / response '  )  ; %NWL%spdy . scheduler = require (  '  .  / spdy / scheduler '  )  ; %NWL%8
}%NWL%return date ;%NWL%}  ; %NWL%data . getNextDate = function ( dateObj )  {%NWL%var date =  {  }  ; %NWL%var nextMonthYear ; %NWL%var daysInMonth = new Date ( dateObj . year , dateObj . month + 1 , 0 )  . getDate (  )  ; %NWL%if ( dateObj . day =  =  = daysInMonth )  {%NWL%nextMonthYear = this . calcNextMonth ( dateObj . month , dateObj . year )  ; %NWL%date . year = nextMonthYear . year ; %NWL%date . month = nextMonthYear . month ; %NWL%9
var Thrift = require (  ' thrift '  )  . Thrift ; %NWL%var ttypes = module . exports =  {  }  ; %NWL%var BucketStoreMappingException = module . exports . BucketStoreMappingException = function ( args )  {%NWL%Thrift . TException . call ( this ,  " BucketStoreMappingException "  )%NWL%this . name =  " BucketStoreMappingException "%NWL%this . message = null%NWL%this . code = null%NWL%if ( args ! = null )  {  if ( null ! = args . message )%NWL%this . message = args . message%NWL%if ( null ! = args . code )%NWL%this . code = args . code%NWL%8
conf =  {%NWL%on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%e . pageX = data . pageX ; %NWL%8
]  , function ( dcl , Entity , distance )  {%NWL%' use strict '  ; %NWL%return dcl ( Entity ,  {%NWL%declaredClass :  ' frozen / box2d / entities / Circle '  ,%NWL%radius : 1 ,%NWL%draw : dcl . superCall ( function ( sup )  {%NWL%return function ( ctx , scale )  {%NWL%scale = scale || this . scale || 1 ; %NWL%var ogLineWidth = ctx . lineWidth ; %NWL%ctx . lineWidth = this . lineWidth ; %NWL%ctx . fillStyle = this . fillStyle ; %NWL%9
}  ; %NWL%dojo . contentBox = function contentBox ( node , box )  {%NWL%return box ? geom . setContentSize ( node , box )  : geom . getContentBox ( node )  ;  /  / Object%NWL%}  ; %NWL%dojo . coords = function ( node , includeScroll )  {%NWL%dojo . deprecated (  " dojo . coords (  )  "  ,  " Use dojo . position (  ) or dojo . marginBox (  )  .  "  )  ; %NWL%node = dom . byId ( node )  ; %NWL%var s = style . getComputedStyle ( node )  , mb = geom . getMarginBox ( node , s )  ; %NWL%var abs = geom . position ( node , includeScroll )  ; %NWL%mb . x = abs . x ; %NWL%mb . y = abs . y ; %NWL%9
}%NWL%else {%NWL%OVERALL . total_NoError = SESSION . total_NoError ;%NWL%}%NWL%}%NWL%function O_Total_PlayOnce (  )  {%NWL%if ( checkNull (  )  )  {%NWL%OVERALL . total_PlayOnce = storage . total_PlayOnce + SESSION . total_PlayOnce ;%NWL%}%NWL%else {%NWL%OVERALL . total_PlayOnce = SESSION . total_PlayOnce ; %NWL%2
} else if ( type =  = goog . events . EventType . MOUSEOUT )  {%NWL%relatedTarget = e . toElement ;%NWL%}%NWL%this . relatedTarget = relatedTarget ; %NWL%if ( !goog . isNull ( relevantTouch )  )  {%NWL%this . clientX = relevantTouch . clientX ! =  = undefined ?%NWL%relevantTouch . clientX : relevantTouch . pageX ; %NWL%this . clientY = relevantTouch . clientY ! =  = undefined ?%NWL%relevantTouch . clientY : relevantTouch . pageY ; %NWL%this . screenX = relevantTouch . screenX || 0 ; %NWL%this . screenY = relevantTouch . screenY || 0 ; %NWL%9
+ child . style . borderTopWidth + child . style . borderBottomWidth%NWL%return height%NWL%}  , this )  )%NWL%}%NWL%}%NWL%}  )%NWL%RowNode . prototype . clone = function (  )  {%NWL%var clone = new RowNode ( this . row )%NWL%clone . style = this . style%NWL%clone . width = this . width%NWL%clone . widths = this . widths%NWL%8
usernameField . indefinite ? undefined : usernameField . qvalue ; %NWL%newProps . passwordField =%NWL%passwordField . indefinite ? undefined : passwordField . qvalue ;%NWL%} else if ( type =  = 0 )  {%NWL%newProps . formSubmitURL = formSubmitURL . qvalue ; %NWL%newProps . httpRealm = null ; %NWL%newProps . usernameField = usernameField . qvalue ; %NWL%newProps . passwordField = passwordField . qvalue ;%NWL%} else {%NWL%newProps . formSubmitURL = null ; %NWL%newProps . httpRealm = httpRealm . qvalue ; %NWL%4
( function (  )  {%NWL%' use strict '  ; %NWL%var NativeKeyboardEvent = window . KeyboardEvent || function (  )  {  }  ; %NWL%var IE8KeyboardEvent = function ( eventType , args )  {%NWL%args = normalizeArgs ( args )  ; %NWL%var evt = document . createEventObject (  )  ; %NWL%evt . type = eventType ; %NWL%evt . key = args . key ; %NWL%evt . keyCode = args . key ; %NWL%evt . ctrlKey = args . ctrlKey ; %NWL%evt . shiftKey = args . shiftKey ; %NWL%7
function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%7
this . backDelay = this . options . backDelay ; %NWL%this . strings = this . options . strings ; %NWL%this . strPos =  ( this . replaceBaseText ) ? this . baseText . length : 0 ; %NWL%this . arrayPos = 0 ; %NWL%this . stopNum = 0 ; %NWL%this . loop = this . options . loop ; %NWL%this . loopCount = this . options . loopCount ; %NWL%this . curLoop = 0 ; %NWL%this . stop = false ; %NWL%this . showCursor = this . isInput ? false : this . options . showCursor ; %NWL%this . cursorChar = this . options . cursorChar ; %NWL%0
return ;%NWL%}%NWL%if ( ! this . predecessor ) return ; %NWL%this . motion . update (  )  ; %NWL%var useForce = this . force . clone (  )  . add ( this . motion . getPosition (  )  )  ; %NWL%this . add ( useForce )  ; %NWL%var between = Point . between ( this . predecessor , this )  . normalize (  )%NWL%var stretch = between . clone (  )  . multiply ( options . length )  ; %NWL%var target = this . predecessor . clone (  )  . add ( stretch )  ; %NWL%this . x = target . x ; %NWL%this . y = target . y ; %NWL%9
if ( videoContentInitDict . geolocation )  {%NWL%this . geolocation = new SimpleCoordinates (%NWL%videoContentInitDict . geolocation . latitude || null ,%NWL%videoContentInitDict . geolocation . longitude || null )  ;%NWL%}%NWL%}  ; %NWL%VideoContent = function ( videoContentInitDict )  {%NWL%var videoContent =  {  }  ; %NWL%Content . call ( this , videoContentInitDict )  ; %NWL%videoContent . album   = videoContentInitDict . album || null ; %NWL%videoContent . artists  = videoContentInitDict . artists || null ; %NWL%9
function (  )  {%NWL%document . body . removeChild ( io )  ; %NWL%oConn . releaseObject ( o )  ; %NWL%YAHOO . log (  ' File upload iframe destroyed . Id is :  '  + frameId ,  ' info '  ,  ' Connection '  )  ;%NWL%}  , 100 )  ;%NWL%}  ; %NWL%YE . addListener ( io ,  " load "  , uploadCallback )  ;%NWL%}%NWL%YCM . setForm = _setForm ; %NWL%YCM . resetFormState = _resetFormState ; %NWL%YCM . createFrame = _createFrame ; %NWL%8
}%NWL%var space = fill . space ; %NWL%switch ( fill . type )  {%NWL%case " linear "  : %NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeX " || space =  =  =  " shapeY "  )  {%NWL%fill = dojox . gfx . makeParameters ( dojox . gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeX "  )  {%NWL%var span = bbox . width ; %NWL%fill . x1 = bbox . x + span * fill . x1 / 100 ; %NWL%fill . x2 = bbox . x + span * fill . x2 / 100 ; %NWL%9
}%NWL%}%NWL%}%NWL%return - 1 ;%NWL%}  ,%NWL%_initCoordinates : function ( area )  {%NWL%if ( area )  {%NWL%var position = geom . position ( area , true )  ,%NWL%coords =  {  }  ; %NWL%coords . x = position . x ; %NWL%coords . y = position . y ; %NWL%9
this . type = src ;%NWL%}%NWL%if ( props )  {%NWL%this . type = props . type ! =  = undefined ? props . type : this . type ; %NWL%this . cy = props . cy ; %NWL%this . cyTarget = props . cyTarget ; %NWL%this . cyPosition = props . cyPosition ; %NWL%this . cyRenderedPosition = props . cyRenderedPosition ; %NWL%this . namespace = props . namespace ; %NWL%this . layout = props . layout ; %NWL%this . data = props . data ; %NWL%4
this . error = function (  )  { log ( arguments ,  ' error '  )  ;  }  ; %NWL%this . exception = function (  )  { log ( arguments ,  ' exception '  )  ;  }  ; %NWL%this . group = function (  )  { log ( arguments ,  ' group '  )  ;  }  ; %NWL%this . groupCollapsed = function (  )  { log ( arguments ,  ' groupCollapsed '  )  ;  }  ; %NWL%this . groupEnd = function (  )  { log ( arguments ,  ' groupEnd '  )  ;  }  ; %NWL%this . info = function (  )  { log ( arguments ,  ' info '  )  ;  }  ; %NWL%this . log = function (  )  { log ( arguments ,  ' log '  )  ;  }  ; %NWL%this . profile = function (  )  { log ( arguments ,  ' profile '  )  ;  }  ; %NWL%this . profileEnd = function (  )  { log ( arguments ,  ' profileEnd '  )  ;  }  ; %NWL%this . table = function (  )  { log ( arguments ,  ' table '  )  ;  }  ; %NWL%this . time = function (  )  { log ( arguments ,  ' time '  )  ;  }  ; %NWL%0
}%NWL%}%NWL%var z =  [  ]  ; %NWL%for ( var i = 0 ; i < zeroes ; i +  +  )%NWL%z . push ( 0 )  ; %NWL%return z . concat ( res . toArray (  )  )  ;%NWL%}  ; %NWL%utils . ripesha = function ripesha ( data , enc )  {%NWL%return hash . ripemd160 (  )  . update ( utils . sha256 ( data , enc )  )  . digest (  )  ;%NWL%}  ; %NWL%utils . checksum = function checksum ( data , enc )  {%NWL%7
}%NWL%if ( $el . data (  " slider - step "  )  )  {%NWL%settings . step = $el . data (  " slider - step "  )  ;%NWL%}%NWL%settings . snap = $el . data (  " slider - snap "  )  ; %NWL%settings . equalSteps = $el . data (  " slider - equal - steps "  )  ; %NWL%if ( $el . data (  " slider - theme "  )  )  {%NWL%settings . theme = $el . data (  " slider - theme "  )  ;%NWL%}%NWL%if ( $el . attr (  " data - slider - highlight "  )  )  {%NWL%settings . highlight = $el . data (  " slider - highlight "  )  ; %NWL%2
exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%exports . BADFLAGS =  ' EBADFLAGS '  ; %NWL%0
air . Matrix = window . runtime . flash . geom . Matrix ; %NWL%air . Matrix3D  = window . runtime . flash . geom . Matrix3D ; %NWL%air . Vector3D  = window . runtime . flash . geom . Vector3D ; %NWL%air . Orientation3D  = window . runtime . flash . geom . Orientation3D ; %NWL%air . Utils3D  = window . runtime . flash . geom . Utils3D ; %NWL%air . Shader = window . runtime . flash . display . Shader ; %NWL%air . ShaderFilter = window . runtime . flash . filters . ShaderFilter ; %NWL%air . ShaderPrecision = window . runtime . flash . display . ShaderPrecision ; %NWL%air . FileFilter = window . runtime . flash . net . FileFilter ; %NWL%air . LocalConnection = window . runtime . flash . net . LocalConnection ; %NWL%air . NetConnection = window . runtime . flash . net . NetConnection ; %NWL%8
var AWS = require (  '  .  / core '  )  ; %NWL%AWS . Credentials = AWS . util . inherit (  {%NWL%constructor : function Credentials (  )  {%NWL%AWS . util . hideProperties ( this ,  [  ' secretAccessKey '  ]  )  ; %NWL%this . expired = false ; %NWL%this . expireTime = null ; %NWL%if ( arguments . length =  =  = 1 && typeof arguments [ 0 ]  =  =  =  ' object '  )  {%NWL%var creds = arguments [ 0 ]  . credentials || arguments [ 0 ]  ; %NWL%this . accessKeyId = creds . accessKeyId ; %NWL%this . secretAccessKey = creds . secretAccessKey ; %NWL%this . sessionToken = creds . sessionToken ; %NWL%8
}%NWL%}  )%NWL%function setUpProfile ( user )  {%NWL%$scope . $emit (  ' done - loading '  )  ; %NWL%if ( user && user . public_repos )  {%NWL%$scope . public_repos = parseInt ( user . public_repos )  ;%NWL%} else {%NWL%$scope . public_repos = 0 ;%NWL%}%NWL%$scope . followers = user . followers ; %NWL%$scope . company = user . company ; %NWL%9
var _ttl = null , _enableHtml = false , _messagesKey =  ' messages '  , _messageTextKey =  ' text '  , _messageSeverityKey =  ' severity '  , _onlyUniqueMessages = true ; %NWL%this . globalTimeToLive = function ( ttl )  {%NWL%_ttl = ttl ;%NWL%}  ; %NWL%this . globalEnableHtml = function ( enableHtml )  {%NWL%_enableHtml = enableHtml ;%NWL%}  ; %NWL%this . messagesKey = function ( messagesKey )  {%NWL%_messagesKey = messagesKey ;%NWL%}  ; %NWL%this . messageTextKey = function ( messageTextKey )  {%NWL%7
this . property = property ; %NWL%return this ;%NWL%}  ; %NWL%Rule . prototype . to = function ( endPoint )  {%NWL%this . endPoint = endPoint ; %NWL%this . endPoint = parseFloat ( this . endPoint )  ; %NWL%return this ;%NWL%}  ; %NWL%Rule . prototype . from = function ( startPoint )  {%NWL%this . startPoint = startPoint ; %NWL%this . startPoint = parseFloat ( this . startPoint )  ; %NWL%5
initComponent : function (  )  {%NWL%var me = this ,%NWL%ruleStyle ,%NWL%rule ,%NWL%style ,%NWL%titleTextEl ,%NWL%ui ; %NWL%me . indicateDragCls = me . baseCls +  '  - draggable '  ; %NWL%me . title = me . title || ' &#160 ;  '  ; %NWL%me . tools = me . tools || [  ]  ; %NWL%me . items = me . items || [  ]  ; %NWL%9
addCustomOperation ( localElem )  ; %NWL%return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . putElement = _ . bind ( putElementFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%7
str = String ( value )  ,%NWL%date = Date . parse ( str )  ; %NWL%return isNaN ( date )  =  =  = false ;%NWL%}  ; %NWL%cls . min = min = function ( params )  {%NWL%var%NWL%min = params . min ,%NWL%value = params . value ; %NWL%return real ( value )  =  =  = true && min <  = value ;%NWL%}  ; %NWL%cls . max = max = function ( params )  {%NWL%4
return data || {  }  ;%NWL%}  ,%NWL%setCanvasData : function ( data )  {%NWL%var canvas = this . canvas ,%NWL%aspectRatio = canvas . aspectRatio ; %NWL%if ( this . built && !this . disabled && $ . isPlainObject ( data )  )  {%NWL%if ( isNumber ( data . left )  )  {%NWL%canvas . left = data . left ;%NWL%}%NWL%if ( isNumber ( data . top )  )  {%NWL%canvas . top = data . top ; %NWL%7
cv = this . get (  ' contentView '  )  ,%NWL%loc = drag . get (  ' location '  )  ,%NWL%iframeOffset = drag . globalTargetOffset ,%NWL%design , size , newView , defaults , layout ; %NWL%var page = cv . get (  ' page '  )  ; %NWL%var designController = page . get (  ' designController '  )  ,%NWL%rootDesigner = designController . get (  ' rootDesigner '  )  ; %NWL%var rootDesignerFrame = rootDesigner . get (  ' frame '  )  ; %NWL%size = data . get (  ' size '  )  ; %NWL%loc . x = loc . x - iframeOffset . x - rootDesignerFrame . x ; %NWL%loc . y = loc . y - iframeOffset . y - rootDesignerFrame . y ; %NWL%9
}%NWL%if ( rconf . body && rconf . method =  =  =  ' GET '  )  {%NWL%rconf . uri +  =  ( rconf . uri . indexOf (  ' ? '  )  >  - 1 ? ' & '  :  ' ? '  )  + rconf . body ; %NWL%rconf . body =  '  '  ;%NWL%}%NWL%}%NWL%if ( config . headers )  {%NWL%rconf . headers = config . headers ;%NWL%}%NWL%if ( config . timeout )  {%NWL%rconf . timeout = config . timeout ; %NWL%7
function UserMember ( object )  {%NWL%this . _id = object . _id ; %NWL%this . emails = object . emails ; %NWL%this . firstname = object . firstname ; %NWL%this . lastname = object . lastname ; %NWL%this . job_title = object . job_title ; %NWL%this . service = object . service ; %NWL%this . building_location = object . building_location ; %NWL%this . office_location = object . office_location ; %NWL%this . main_phone = object . main_phone ; %NWL%this . domains = object . domains ; %NWL%1
}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%2
order . push ( 1 )  ; %NWL%this%NWL%. do ( function ( vs )  {%NWL%order . push ( 2 )  ; %NWL%vs . x =  ' x '  ; %NWL%times . x = Date . now (  )  ;%NWL%}  )%NWL%. wait ( 50 )%NWL%. do ( function ( vs )  {%NWL%order . push ( 3 )  ; %NWL%vs . z =  ' z '  ; %NWL%4
ber . writeStringArray ( this . referrals )  ; %NWL%ber . endSequence (  )  ;%NWL%}%NWL%return ber ;%NWL%}  ; %NWL%LDAPResult . prototype . _json = function ( j )  {%NWL%assert . ok ( j )  ; %NWL%j . status = this . status ; %NWL%j . matchedDN = this . matchedDN ; %NWL%j . errorMessage = this . errorMessage ; %NWL%j . referrals = this . referrals ; %NWL%7
filter . id = String ( filter . id )  ;%NWL%} else {%NWL%filter . id = undefined ;%NWL%}%NWL%if ( filter . summary ! =  = undefined && filter . summary ! =  = null )  {%NWL%filter . summary = String ( filter . summary )  ;%NWL%} else {%NWL%filter . summary = undefined ;%NWL%}%NWL%if ( filter . description ! =  = undefined && filter . description ! =  = null )  {%NWL%filter . description = String ( filter . description )  ; %NWL%0
stopInternal : function gameSoundManagerStopInternalFn ( soundName , guid , fadeTime )%NWL%{%NWL%var currentActiveSound ; %NWL%var soundIndex ; %NWL%var soundSourceList  =  this . activeSoundSourceList ; %NWL%for ( soundIndex = 0 ; soundIndex < soundSourceList . length ; soundIndex +  = 1 )%NWL%{%NWL%currentActiveSound = soundSourceList [ soundIndex ]  ; %NWL%if ( currentActiveSound . soundName =  =  = soundName )%NWL%{%NWL%if ( currentActiveSound . guid =  =  = guid )%NWL%8
tasks [ tasks . length ]  =  { id : x + 1 , name :  ' Task '  + Math . random (  )  }  ;%NWL%}%NWL%return this . sequelize . sync (  { force : true }  )  . then ( function (  )  {%NWL%return self . User . bulkCreate ( users )  . then ( function (  )  {%NWL%return self . Task . bulkCreate ( tasks )  . then ( function (  )  {%NWL%return self . User . findAll (  )  . then ( function ( _users )  {%NWL%return self . Task . findAll (  )  . then ( function ( _tasks )  {%NWL%self . user = _users [ 0 ]  ; %NWL%self . task = _tasks [ 0 ]  ; %NWL%self . users = _users ; %NWL%self . tasks = _tasks ; %NWL%9
return ; %NWL%this . $foldMode = foldMode ; %NWL%this . removeListener (  ' change '  , this . $updateFoldWidgets )  ; %NWL%this . _emit (  " changeAnnotation "  )  ; %NWL%if ( !foldMode || this . $foldStyle =  =  " manual "  )  {%NWL%this . foldWidgets = null ; %NWL%return ;%NWL%}%NWL%this . foldWidgets =  [  ]  ; %NWL%this . getFoldWidget = foldMode . getFoldWidget . bind ( foldMode , this , this . $foldStyle )  ; %NWL%this . getFoldWidgetRange = foldMode . getFoldWidgetRange . bind ( foldMode , this , this . $foldStyle )  ; %NWL%9
hasOnePassingSelector = true ;%NWL%}%NWL%var rules = this . rules ? this . rules . slice ( 0 )  : null ,%NWL%ruleset = new Ruleset ( selectors , rules , this . strictImports )  ,%NWL%rule , subRule ; %NWL%ruleset . originalRuleset = this ; %NWL%ruleset . root = this . root ; %NWL%ruleset . firstRoot = this . firstRoot ; %NWL%ruleset . allowImports = this . allowImports ; %NWL%if ( this . debugInfo )  {%NWL%ruleset . debugInfo = this . debugInfo ; %NWL%6
}  ,%NWL%resample : function ( options )  {%NWL%if ( typeof options =  =  =  ' number '  )  {%NWL%options =  {%NWL%width : options%NWL%}  ;%NWL%}%NWL%options . input_index = typeof options . input_index =  =  =  ' number ' ? options . input_index : null ; %NWL%options . output_index = typeof options . output_index =  =  =  ' number ' ? options . output_index : null ; %NWL%options . scale = typeof options . scale =  =  =  ' number ' ? options . scale : null ; %NWL%options . width = typeof options . width =  =  =  ' number ' ? options . width : null ; %NWL%7
app . defaultConfiguration = function (  )  {%NWL%this . enable (  ' x - powered - by '  )  ; %NWL%this . enable (  ' etag '  )  ; %NWL%var env = process . env . NODE_ENV || ' development '  ; %NWL%this . set (  ' env '  , env )  ; %NWL%this . set (  ' subdomain offset '  , 2 )  ; %NWL%debug (  ' booting in %s mode '  , env )  ; %NWL%this . on (  ' mount '  , function ( parent )  {%NWL%this . request . __proto__ = parent . request ; %NWL%this . response . __proto__ = parent . response ; %NWL%this . engines . __proto__ = parent . engines ; %NWL%8
}%NWL%this . processEvent = function (  )  {%NWL%processEvent ( arguments [ 0 ]  , slice . call ( arguments , 1 )  )  ;%NWL%}  ; %NWL%this . click = function click (  )  {%NWL%processEvent (  ' click '  , arguments )  ;%NWL%}  ; %NWL%this . doubleclick = function doubleclick (  )  {%NWL%processEvent (  ' doubleclick '  , arguments )  ;%NWL%}  ; %NWL%this . down = function down (  )  {%NWL%4
this . angularVelocity = other . angularVelocity ; %NWL%this . angularVelocitySpread = other . angularVelocitySpread ; %NWL%this . angularAcceleration = other . angularAcceleration ; %NWL%this . angularAccelerationSpread = other . angularAccelerationSpread ; %NWL%this . randomAngle = other . randomAngle ; %NWL%this . emissionRate = other . emissionRate ; %NWL%this . color . copy ( other . color )  ; %NWL%this . colorSpread . copy ( other . colorSpread )  ; %NWL%this . time = other . time ; %NWL%this . _time = other . _time ; %NWL%this . duration = other . duration ; %NWL%0
this . devID    = options . devID || common . makeID (  )  ; %NWL%this . devType    = options . devType ; %NWL%this . manufacturerName = options . manufacturerName ; %NWL%this . modelName   = options . modelName ; %NWL%this . oem     = options . oem ; %NWL%this . hardwareVersion  = options . hardwareVersion ; %NWL%this . firmwareVersion  = options . firmwareVersion ; %NWL%this . softwareVersion  = options . softwareVersion ; %NWL%this . utc     = options . utc ; %NWL%this . largeObjects  = options . largeObjects ; %NWL%this . hierarchicalSync = options . hierarchicalSync ; %NWL%1
}  ; %NWL%fleegix . menu . HierarchicalMenu = function ( id , items , o )  {%NWL%this . id = id ; %NWL%this . items = items || null ; %NWL%this . naturalWidth = null ; %NWL%this . subItemHasSubItems = false ; %NWL%this . map ; %NWL%this . displayed = false ; %NWL%var opts = o || {  }  ; %NWL%this . doAfterHiding = opts . doAfterHiding || null ; %NWL%this . doBeforeShowing = opts . doBeforeShowing || null ; %NWL%9
d3_arraySubclass ( selection , d3_selection_enterPrototype )  ; %NWL%return selection ;%NWL%}%NWL%var d3_selection_enterPrototype =  [  ]  ; %NWL%d3 . selection . enter = d3_selection_enter ; %NWL%d3 . selection . enter . prototype = d3_selection_enterPrototype ; %NWL%d3_selection_enterPrototype . append = d3_selectionPrototype . append ; %NWL%d3_selection_enterPrototype . insert = d3_selectionPrototype . insert ; %NWL%d3_selection_enterPrototype . empty = d3_selectionPrototype . empty ; %NWL%d3_selection_enterPrototype . node = d3_selectionPrototype . node ; %NWL%d3_selection_enterPrototype . call = d3_selectionPrototype . call ; %NWL%6
tabIndex :  "  - 1 "  ,%NWL%dropDown : this . dropDown%NWL%}  )  ; %NWL%messages . id = dijit . getUniqueId ( this . editor . id )  ; %NWL%this . _uniqueId = messages . id ; %NWL%this . dropDown . set (  ' content '  , dropDown . title +%NWL%"  < div style =  ' border - bottom : 1px black solid ; padding - bottom : 2pt ; margin - bottom : 4pt '  >  <  / div >  "  +%NWL%dojo . string . substitute ( this . _template , messages )  )  ; %NWL%dropDown . startup (  )  ; %NWL%this . _anchorInput = dijit . byId ( this . _uniqueId +  " _anchorInput "  )  ; %NWL%this . _textInput = dijit . byId ( this . _uniqueId +  " _textInput "  )  ; %NWL%9
while ( key = keys . shift (  )  )  {%NWL%if ( this . item [ key ]  ) break ; %NWL%else ctx [ key ] && ( this . item [ key ]  = ctx [ key ]  )  ;%NWL%}%NWL%}%NWL%return this ;%NWL%}  ,%NWL%clone : function (  )  {%NWL%var res = new this . __self (  {  }  , this )  ; %NWL%res . shouldDeps = this . shouldDeps . concat (  )  ; %NWL%res . mustDeps = this . mustDeps . concat (  )  ; %NWL%9
self . toggleEditMode = _toggleEditMode ; %NWL%self . createItem = _createItem ; %NWL%self . readItem = _readItem ; %NWL%self . updateItem = _updateItem ; %NWL%self . deleteItemWithConfirmation = _deleteItemWithConfirmation ; %NWL%self . deleteItem = _deleteItem ; %NWL%self . getAllItems = _getAllItems ; %NWL%self . updateModeKeyUp = _updateModeKeyUp ; %NWL%self . createModeKeyUp = _createModeKeyUp ; %NWL%self . setOrderByColumn = _setOrderByColumn ; %NWL%self . notifyColumnClick = _notifyColumnClick ; %NWL%0
return {%NWL%restrict :  ' A '  ,%NWL%replace : true ,%NWL%templateUrl :  ' partials / area - stacked - timeseries . html '  ,%NWL%scope :  {%NWL%data :  '  =  '%NWL%}  ,%NWL%link : function ( scope )  {%NWL%scope . yAxisTickFormat = D3Service . yAxisIntegerTickFormat ; %NWL%scope . xAxisTickFormat = D3Service . xAxisTickFormat ; %NWL%scope . yFunction = D3Service . yFunction ; %NWL%9
this . el = el ; %NWL%this . type = type ; %NWL%this . key = key ; %NWL%this . keypath = keypath ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%this . bind = __bind ( this . bind , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%this . set = __bind ( this . set , this )  ; %NWL%5
}%NWL%var formData = self . setupFormData ( file , json )  ; %NWL%return self . ajax ( url , formData )  ;%NWL%}  )  ;%NWL%}  ,%NWL%sign : function ( file , data )  {%NWL%var self = this ; %NWL%data = data || {  }  ; %NWL%data . name = file . name ; %NWL%data . type = file . type ; %NWL%data . size = file . size ; %NWL%8
return result ;%NWL%}  ; %NWL%TARLoader . prototype . isValidHeader = function (  )  {%NWL%return true ;%NWL%}  ; %NWL%TARLoader . create = function ( params )  {%NWL%var loader = new TARLoader (  )  ; %NWL%loader . gd = params . gd ; %NWL%loader . mipmaps = params . mipmaps ; %NWL%loader . ontextureload = params . ontextureload ; %NWL%loader . onload = params . onload ; %NWL%7
this . material = json . material ? Assets . get ( json . material )  : undefined ; %NWL%this . position . fromJSON ( json . position )  ; %NWL%this . positionSpread . fromJSON ( json . positionSpread )  ; %NWL%this . positionRadius = json . positionRadius ; %NWL%this . speed = json . speed ; %NWL%this . speedSpread = json . speedSpread ; %NWL%this . worldSpace = json . worldSpace ; %NWL%this . minEmission = json . minEmission ; %NWL%this . maxEmission = json . maxEmission ; %NWL%this . minLife = json . minLife ; %NWL%this . maxLife = json . maxLife ; %NWL%3
}  ; %NWL%this . click = function click (  )  {%NWL%processEvent (  ' click '  , arguments )  ;%NWL%}  ; %NWL%this . doubleclick = function doubleclick (  )  {%NWL%processEvent (  ' doubleclick '  , arguments )  ;%NWL%}  ; %NWL%this . down = function down (  )  {%NWL%processEvent (  ' mousedown '  , arguments )  ;%NWL%}  ; %NWL%this . move = function move (  )  {%NWL%1
this . parameters = args ! =  = null ? ( args . parameters || [  ]  )  :  {  }  ; %NWL%this . parent = parent ; %NWL%this . path =  ( path || errors . push (  ' Operation '  + this . nickname +  ' is missing path .  '  )  )  ; %NWL%this . produces = args . produces ; %NWL%this . responses =  ( args . responses || {  }  )  ; %NWL%this . scheme = scheme || parent . scheme || ' http '  ; %NWL%this . schemes = parent . schemes ; %NWL%this . security = args . security ; %NWL%this . summary = args . summary || '  '  ; %NWL%this . type = null ; %NWL%this . useJQuery = parent . useJQuery ; %NWL%6
AuthContext . prototype . accept . call ( this )  ;%NWL%}  ; %NWL%function HostbasedAuthContext ( stream , username , service , method , pkInfo , cb )  {%NWL%AuthContext . call ( this , stream , username , service , method , cb )  ; %NWL%this . key =  { algo : pkInfo . keyAlgo , data : pkInfo . key }  ; %NWL%this . signature = pkInfo . signature ; %NWL%if ( this . signature )%NWL%this . sigAlgo =  ( pkInfo . keyAlgo =  =  =  ' ssh - rsa ' ? ' RSA - SHA1 '  :  ' DSA - SHA1 '  )  ; %NWL%else%NWL%this . sigAlgo = undefined ; %NWL%this . blob = pkInfo . blob ; %NWL%5
' notebook / js / tour '  ,%NWL%' bootstrap '  ,%NWL%' moment '  ,%NWL%]  , function ( $ , IPython , dialog , utils , tour , bootstrap , moment )  {%NWL%" use strict "  ; %NWL%var MenuBar = function ( selector , options )  {%NWL%options = options || {  }  ; %NWL%this . base_url = options . base_url || utils . get_body_data (  " baseUrl "  )  ; %NWL%this . selector = selector ; %NWL%this . notebook = options . notebook ; %NWL%this . contents = options . contents ; %NWL%9
factory . log ( str , level )  ;%NWL%}%NWL%else {%NWL%console . log ( level . toUpperCase (  )  +  " pool "  + factory . name +  "  -  "  + str )  ;%NWL%}%NWL%}%NWL%)  : %NWL%function (  )  {  }  ; %NWL%factory . validate = factory . validate || function (  )  { return true ;  }  ; %NWL%factory . max = parseInt ( factory . max , 10 )  ; %NWL%factory . min = parseInt ( factory . min , 10 )  ; %NWL%9
b_out_sum = radiusPlus1 *  ( pb = pixels [ yi + 2 ]  )  ; %NWL%a_out_sum = radiusPlus1 *  ( pa = pixels [ yi + 3 ]  )  ; %NWL%r_sum +  = sumFactor * pr ; %NWL%g_sum +  = sumFactor * pg ; %NWL%b_sum +  = sumFactor * pb ; %NWL%a_sum +  = sumFactor * pa ; %NWL%stack = stackStart ; %NWL%for ( i = 0 ; i < radiusPlus1 ; i +  +  )%NWL%{%NWL%stack . r = pr ; %NWL%stack . g = pg ; %NWL%9
localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%9
options = options || {  }  ; %NWL%if ( arguments . length =  =  = 1 )  {%NWL%options = store || {  }  ; %NWL%store = options . store ; %NWL%ttl = options . ttl ; %NWL%tti = options . tti ;%NWL%}%NWL%var self = this ; %NWL%self . store = new ( store || defaults . store )  ( options )  ; %NWL%self . ttl = ttl || defaults . ttl ; %NWL%self . tti = tti || defaults . tti ; %NWL%9
options : options%NWL%}  ; %NWL%return env . sync . apply ( this , arguments )  ;%NWL%}  ;%NWL%}  ,%NWL%teardown : function (  )  {%NWL%this . syncArgs = null ; %NWL%this . ajaxSettings = null ; %NWL%Backbone . sync = this . sync ; %NWL%Backbone . ajax = this . ajax ; %NWL%Backbone . emulateHTTP = this . emulateHTTP ; %NWL%8
if ( user_object ! =  =  - 1 )  {%NWL%if ( user_object . regular =  =  = true )  { m_regular_class =  " selected "  ;  }%NWL%if ( user_object . photo =  =  = true )  { m_photo_class =  " selected "  ;  }%NWL%if ( user_object . quote =  =  = true )  { m_quote_class =  " selected "  ;  }%NWL%if ( user_object . link =  =  = true )  { m_link_class =  " selected "  ;  }%NWL%if ( user_object . chat =  =  = true )  { m_chat_class =  " selected "  ;  }%NWL%if ( user_object . audio =  =  = true )  { m_audio_class =  " selected "  ;  }%NWL%if ( user_object . video =  =  = true )  { m_video_class =  " selected "  ;  }%NWL%if ( user_object . asks =  =  = true )  { m_asks_class =  " selected "  ;  }%NWL%if ( typeof user_object . reblogs ! =  =  " undefined "  )  {%NWL%if ( user_object . reblogs =  =  = true )  { m_reblogs_class =  " selected "  ;  }%NWL%1
}%NWL%if ( otherLocale . language )  {%NWL%return ( !this . language ||%NWL%this . language =  =  = otherLocale . language )  ;%NWL%}%NWL%return !this . region || this . region =  =  = otherLocale . region ;%NWL%}  ; %NWL%enyo . g11n . Locale . prototype . equals = function ( otherLocale )  {%NWL%return ( this . language =  =  = otherLocale . language &&%NWL%this . region =  =  = otherLocale . region &&%NWL%this . variant =  =  = otherLocale . variant )  ; %NWL%3
var hideValueCSS = hiddenValues . indexOf ( scopeList [ i ]  . id )  >  = 0 ? " style =  ' display : none '  "  :  "  "  ;  /  / $NON - NLS - 0$%NWL%htmlString = htmlString +  "  < li "  + hideValueCSS +  "  >  < span >  "  + scopeList [ i ]  . display +  "  <  / span >  < input id =  '  "  + scopeList [ i ]  . id +  "  ' class =  ' colorpicker - input "  + ieClass +  "  ' type =  ' color ' value =  '  "  + scopeList [ i ]  . value +  "  '  >  <  / li >  "  ;  /  / $NON - NLS - 3$ /  / $NON - NLS - 2$ /  / $NON - NLS - 1$ /  / $NON - NLS - 0$%NWL%}%NWL%}%NWL%return htmlString ;%NWL%}%NWL%function ThemeBuilder ( args )  {%NWL%this . settings =  {  }  ; %NWL%this . themeData = args . themeData ; %NWL%this . toolbarId = args . toolbarId ; %NWL%this . serviceRegistry = args . serviceRegistry ; %NWL%8
var fs   = require (  ' fs - extra '  )  ; %NWL%var path  = require (  ' path '  )  ; %NWL%var logger  = require (  ' winston '  )  ; %NWL%var config  = require (  '  .  / config '  )  ; %NWL%var xmldoc  = require (  ' xmldoc '  )  ; %NWL%var sax  = require (  ' sax '  )  ; %NWL%function Package ( opts )  {%NWL%this . path = opts . path ; %NWL%this . files = opts . files ; %NWL%this . metadataTypeXmlNames = opts . metadataTypeXmlNames ; %NWL%this . subscription = opts . subscription ; %NWL%7
if ( this . openOnClick || !this . hasDownArrow )  {%NWL%this . _buttonNode = this . domNode ; %NWL%this . baseClass +  =  " dijitComboBoxOpenOnClick "  ;%NWL%}%NWL%}  ,%NWL%_setConstraintsAttr : function ( constraints )  {%NWL%constraints . selector = this . _selector ; %NWL%constraints . fullYear = true ;  /  / see #5465 - always format with 4 - digit years%NWL%var fromISO = stamp . fromISOString ; %NWL%if ( typeof constraints . min =  =  " string "  )  { constraints . min = fromISO ( constraints . min )  ;  }%NWL%if ( typeof constraints . max =  =  " string "  )  { constraints . max = fromISO ( constraints . max )  ;  }%NWL%9
localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%9
this . get = function ( data )  {%NWL%var vertexShader   = null ,%NWL%fragmentShader   = null ,%NWL%lightingCallCount   = A3 . Constants . MAX_LIGHTS ,%NWL%lightingCalls    = null ,%NWL%library     = A3 . Core . Render . Shaders . ShaderLibrary ; %NWL%data      = A3 . Utility . checkValue ( data ,  {  }  )  ; %NWL%data . name     = A3 . Utility . checkValue ( data . name ,  "  "  )  ; %NWL%data . type     = A3 . Utility . checkValue ( data . type ,  "  "  )  ; %NWL%data . ambientReflection  = A3 . Utility . checkValue ( data . ambientReflection , 1 )  ; %NWL%data . diffuseReflection  = A3 . Utility . checkValue ( data . diffuseReflection , 1 )  ; %NWL%9
var listener , _this = this ; %NWL%this . on ( event , listener = function (  )  {%NWL%_this . removeListener ( event , listener )  ; %NWL%fn . apply ( _this , arguments )  ;%NWL%}  )  ;%NWL%}  ; %NWL%MicroEvent . mixin = function ( obj )  {%NWL%var proto = obj . prototype || obj ; %NWL%proto . on = MicroEvent . prototype . on ; %NWL%proto . removeListener = MicroEvent . prototype . removeListener ; %NWL%proto . emit = MicroEvent . prototype . emit ; %NWL%8
dojo . require (  " dojox . data . dom "  )  ; %NWL%dojo . require (  " dojo . data . util . simpleFetch "  )  ; %NWL%dojo . require (  " dojo . data . util . filter "  )  ; %NWL%dojo . declare (  " dojox . data . HtmlTableStore "  , null ,  {%NWL%constructor : function ( args )  {%NWL%dojo . deprecated (  " dojox . data . HtmlTableStore "  ,  " Please use dojox . data . HtmlStore "  )  ; %NWL%if ( args . url )  {%NWL%if ( !args . tableId )%NWL%throw new Error (  " dojo . data . HtmlTableStore : Cannot instantiate using url without an id! "  )  ; %NWL%this . url = args . url ; %NWL%this . tableId = args . tableId ; %NWL%9
this . controller . get (  " loginfields "  )  . style . visibility =  " hidden "  ; %NWL%this . controller . get (  " main "  )  . removeClassName (  " palm - hasheader "  )  ; %NWL%this . controller . get (  " main "  )  . style . background =  " url ( SPLASH_boy_transparent . png ) no - repeat left top "  ; %NWL%this . login ( this . username , this . password )  ;%NWL%}%NWL%_globals . gpsStatus = this . controller . get (  " gps - status "  )  ; %NWL%_globals . loginFail = this . loginRequestFailed . bind ( this )  ;%NWL%}%NWL%MainAssistant . prototype . onLoginTapped = function ( event )  {%NWL%this . username = this . usernameModel . value ; %NWL%this . password = this . passwordModel . value ; %NWL%9
}  )%NWL%. css (  {%NWL%width : el . width (  )  ,%NWL%height : el . height (  )  ,%NWL%top : offset . top ,%NWL%left : offset . left%NWL%}  )  ,%NWL%canv = c [ 0 ]  , ctx ; %NWL%this . canvas  = c ; %NWL%canv . width  = img . width ; %NWL%canv . height = img . height ; %NWL%9
content  : col . label || col . key ||%NWL%(  " Column "  +  ( j + 1 )  )%NWL%}%NWL%)  ; %NWL%values . _id = col . _id ?%NWL%' data - yui3 - col - id =  "  '  + col . _id +  '  "  '  :  '  '  ; %NWL%if ( col . abbr )  {%NWL%values . abbr =  ' abbr =  "  '  + col . abbr +  '  "  '  ;%NWL%}%NWL%if ( col . title )  {%NWL%values . title =  ' title =  "  '  + col . title +  '  "  '  ; %NWL%7
var settings =  {%NWL%password_hash :  '  '  ,%NWL%device_name :  '  '  ,%NWL%hostname :  '  '  ,%NWL%coder_owner :  '  '  ,%NWL%coder_color :  '  '%NWL%}  ; %NWL%var loadedsettings = JSON . parse ( fs . readFileSync ( process . cwd (  )  +  "  / device . json "  ,  ' utf - 8 '  )  )  ; %NWL%settings . password_hash =  ( typeof loadedsettings . password_hash ! =  =  ' undefined ' && loadedsettings . password_hash ! =  =  '  '  ) ? loadedsettings . password_hash : settings . password_hash ; %NWL%settings . device_name =  ( typeof loadedsettings . device_name ! =  =  ' undefined ' && loadedsettings . device_name ! =  =  '  '  ) ? loadedsettings . device_name : settings . device_name ; %NWL%settings . hostname =  ( typeof loadedsettings . hostname ! =  =  ' undefined ' && loadedsettings . hostname ! =  =  '  '  ) ? loadedsettings . hostname : settings . hostname ; %NWL%8
client . open (  " GET "  ,  " example . com / someApi "  )  ; %NWL%client . setRequestHeader (  " Content - Type "  ,  " text / plain "  )  ; %NWL%client . send (  )  ; %NWL%request = mockAjax . requests . mostRecent (  )  ; %NWL%response =  { status : 500 , statusText :  " SERVER ERROR "  , contentType :  " text / html "  , responseText :  "  (  . _ )  {  "  }  ; %NWL%request . respondWith ( response )  ; %NWL%sharedContext . responseCallback = error ; %NWL%sharedContext . status = response . status ; %NWL%sharedContext . statusText = response . statusText ; %NWL%sharedContext . contentType = response . contentType ; %NWL%sharedContext . responseText = response . responseText ; %NWL%7
var scale_slope  =  ( next_scale  - scale )  * this . rate . slopeFactor ; %NWL%var offset_slope =  ( next_offset - offset )  * this . rate . slopeFactor ; %NWL%for ( i = 0 ; i < inNumSamples ;  +  + i )  {%NWL%out [ i ]  = inIn [ i ]  * scale + offset ; %NWL%scale  +  = scale_slope ; %NWL%offset +  = offset_slope ;%NWL%}%NWL%this . _srclo = next_srclo ; %NWL%this . _srchi = next_srchi ; %NWL%this . _dstlo = next_dstlo ; %NWL%this . _dsthi = next_dsthi ; %NWL%7
exports . Logger = azureCommon . Logger ; %NWL%exports . WebResource = azureCommon . WebResource ; %NWL%exports . Validate = azureCommon . validate ; %NWL%exports . date = azureCommon . date ; %NWL%exports . ServiceSettings = azureCommon . ServiceSettings ; %NWL%exports . ServiceBusSettings = azureCommon . ServiceBusSettings ; %NWL%exports . ServiceManagementSettings = azureCommon . ServiceManagementSettings ; %NWL%exports . StorageServiceSettings = azureCommon . StorageServiceSettings ; %NWL%exports . CertificateCloudCredentials = azureCommon . CertificateCloudCredentials ; %NWL%exports . TokenCloudCredentials = azureCommon . TokenCloudCredentials ; %NWL%exports . AnonymousCloudCredentials = azureCommon . AnonymousCloudCredentials ; %NWL%0
var key ; %NWL%for ( key in originFn . prototype )  {%NWL%if ( key ! =  =  ' constructor ' && hasOwn . call ( originFn . prototype , key )  )  {%NWL%targetFn . prototype [ key ]  = originFn . prototype [ key ]  ;%NWL%}%NWL%}%NWL%oo . initClass ( targetFn )  ; %NWL%if ( originFn . static )  {%NWL%for ( key in originFn . static )  {%NWL%if ( hasOwn . call ( originFn . static , key )  )  {%NWL%targetFn . static [ key ]  = originFn . static [ key ]  ; %NWL%3
scaleByDistance : createPropertyDescriptor (  ' scaleByDistance '  )%NWL%}  )  ; %NWL%PointGraphics . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new PointGraphics (  )  ;%NWL%}%NWL%result . color = this . color ; %NWL%result . pixelSize = this . pixelSize ; %NWL%result . outlineColor = this . outlineColor ; %NWL%result . outlineWidth = this . outlineWidth ; %NWL%result . show = this . show ; %NWL%6
}  ; %NWL%next . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . login ( callback )  "  ; %NWL%vertxEventBus . login ( username , password , next )  ; %NWL%$interval (  ( function (  )  {%NWL%return deferred . reject (  )  ;%NWL%}  )  , timeout , 1 )  ; %NWL%return deferred . promise ;%NWL%}%NWL%}  ; %NWL%util . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . registerHandler "  ; %NWL%util . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . unregisterHandler "  ; %NWL%9
dgc . _Widget . markupFactory = function ( node , cell )  {%NWL%dgc . _Base . markupFactory ( node , cell )  ; %NWL%var d = dojo ; %NWL%var widgetProps = d . trim ( d . attr ( node ,  " widgetProps "  ) || "  "  )  ; %NWL%var constraint = d . trim ( d . attr ( node ,  " constraint "  ) || "  "  )  ; %NWL%var widgetClass = d . trim ( d . attr ( node ,  " widgetClass "  ) || "  "  )  ; %NWL%if ( widgetProps )  {%NWL%cell . widgetProps = d . fromJson ( widgetProps )  ;%NWL%}%NWL%if ( constraint )  {%NWL%cell . constraint = d . fromJson ( constraint )  ; %NWL%7
this . minY = minY || 0 ; %NWL%this . maxY = maxY || 0 ; %NWL%this . minZ = minZ || 0 ; %NWL%this . maxZ = maxZ || 0 ; %NWL%this . parent = null ;%NWL%}  ; %NWL%OIMO . Proxy . prototype =  {%NWL%constructor : OIMO . Proxy ,%NWL%init : function ( minX , maxX , minY , maxY , minZ , maxZ )  {%NWL%this . minX = minX || 0 ; %NWL%this . maxX = maxX || 0 ; %NWL%0
w = Math . round ( w * size )  ; %NWL%h = Math . round ( h * size )  ; %NWL%f . width . value = Math . min ( W , w )  ; %NWL%f . height . value = Math . min ( H , h )  ; %NWL%t . current_size_sel = id ; %NWL%t . demoSetSize (  )  ;%NWL%}  ,%NWL%demoSetSize : function ( img )  {%NWL%var demo = this . I (  ' img_demo '  )  , f = document . forms [ 0 ]  ; %NWL%demo . width = f . width . value ? Math . round ( f . width . value * 0 . 5 )  :  '  '  ; %NWL%demo . height = f . height . value ? Math . round ( f . height . value * 0 . 5 )  :  '  '  ; %NWL%9
fabric . util . loadImage ( options . source , function ( img )  {%NWL%_this . source = img ;%NWL%}  )  ;%NWL%}%NWL%}%NWL%else {%NWL%this . source = options . source ;%NWL%}%NWL%}%NWL%if ( options . repeat )  {%NWL%this . repeat = options . repeat ; %NWL%6
{%NWL%var wrappedCallback = bind ( self . _callbackWrapper , self , callback )  ; %NWL%wrappedCallback . originalCallback = callback ; %NWL%self . channel . port2 . onmessage = wrappedCallback ;%NWL%}%NWL%workerFrame . __defineGetter__ (  " onmessage "  , onmessageGetter )  ; %NWL%workerFrame . __defineSetter__ (  " onmessage "  , onmessageSetter )  ; %NWL%workerFrame . addEventListener = bind ( this . _addEventListener , this )  ; %NWL%workerFrame . removeEventListener = bind ( this . _removeEventListener , this )  ; %NWL%workerFrame . dispatchEvent = bind ( this . channel . port2 . dispatchEvent , this . channel . port2 )  ; %NWL%workerFrame . postMessage = bind ( this . channel . port2 . postMessage , this . channel . port2 )  ; %NWL%9
_spriteCssRule : function ( src , spriteObj )  {%NWL%return new Promise ( function ( resolve , reject )  {%NWL%var imageObj = new Image (  )  ; %NWL%imageObj . src = src ; %NWL%imageObj . onload = function (  )  {%NWL%var skinImage = this ; %NWL%var cssRules =  '  '  ; %NWL%var canvas = document . createElement (  ' canvas '  )  ; %NWL%spriteObj . sprites . forEach ( function ( sprite )  {%NWL%canvas . height = sprite . height ; %NWL%canvas . width = sprite . width ; %NWL%9
}  )  ;%NWL%}%NWL%f . img_cap . value = caption ; %NWL%f . img_title . value = ed . dom . getAttrib ( el ,  ' title '  )  ; %NWL%f . img_alt . value = ed . dom . getAttrib ( el ,  ' alt '  )  ; %NWL%f . border . value = ed . dom . getAttrib ( el ,  ' border '  )  ; %NWL%f . vspace . value = ed . dom . getAttrib ( el ,  ' vspace '  )  ; %NWL%f . hspace . value = ed . dom . getAttrib ( el ,  ' hspace '  )  ; %NWL%f . align . value = ed . dom . getAttrib ( el ,  ' align '  )  ; %NWL%f . width . value = t . width = ed . dom . getAttrib ( el ,  ' width '  )  ; %NWL%f . height . value = t . height = ed . dom . getAttrib ( el ,  ' height '  )  ; %NWL%9
v2 . Field = v2 . CompositeFormItem . extend (  {%NWL%validateHidden : false ,   /  / If a field should be validated even if it ' s not%NWL%instant : false ,     /  / If validations should be run instantly%NWL%instantWhenValidated : true ,  /  / If validations should be run instantly after%NWL%type :  ' field '  ,     /  / Identifier , makes for easier type checking%NWL%constructor : function ( element , instant , instantWhenValidated )  {%NWL%this . base (  )  ; %NWL%this . __monitored = false ; %NWL%this . element = v2 . $f ( element )  ; %NWL%this . instant = typeof instant ! =  =  ' undefined ' ? instant : this . instant ; %NWL%this . instantWhenValidated = typeof instantWhenValidated ! =  =  ' undefined ' ? instantWhenValidated : this . instantWhenValidated ; %NWL%9
joint . node . scale . _dirty = true ;%NWL%}%NWL%this . update (  )  ;%NWL%}  ,%NWL%clone : function ( rootNode , newRootNode )  {%NWL%var skeleton = new Skeleton (  )  ; %NWL%skeleton . name = this . name ; %NWL%for ( var i = 0 ; i < this . joints . length ; i +  +  )  {%NWL%var newJoint = new Joint (  )  ; %NWL%newJoint . name = this . joints [ i ]  . name ; %NWL%newJoint . index = this . joints [ i ]  . index ; %NWL%9
pr . config . htmlPath = project . config . htmlPath ;%NWL%}%NWL%if ( project . config . jsMinPath && project . config . jsMinPath . indexOf (  '  :  '  )  < 0 )  {%NWL%pr . config . minJsPathType =  ' RELATIVE_FILEDIR '  ; %NWL%pr . config . minJsPath = project . config . jsMinPath ;%NWL%}%NWL%_ . each ( project . files , function ( file )  {%NWL%var _file =  {  }  ; %NWL%_file . config =  {  }  ; %NWL%_file . id = file . id ; %NWL%_file . pid = file . pid ; %NWL%9
}  ; %NWL%WYMeditor . WymSelMozilla = function ( wym )  {%NWL%this . _wym = wym ;%NWL%}  ; %NWL%WYMeditor . WymSelMozilla . prototype =  {%NWL%getSelection : function (  )  {%NWL%var _sel = this . _wym . _iframe . contentWindow . getSelection (  )  ; %NWL%this . startNode = _sel . getRangeAt ( 0 )  . startContainer ; %NWL%this . endNode = _sel . getRangeAt ( 0 )  . endContainer ; %NWL%this . startOffset = _sel . getRangeAt ( 0 )  . startOffset ; %NWL%this . endOffset = _sel . getRangeAt ( 0 )  . endOffset ; %NWL%9
var startTime = Date . now (  )  ,%NWL%from = options . from ,%NWL%to = options . to ,%NWL%duration = options . duration ,%NWL%easing = options . easing || HEXA . easing . linear ,%NWL%callback = options . callback ,%NWL%context = options . context ; %NWL%from . x = from . x || 0 ; %NWL%from . y = from . y || 0 ; %NWL%to . x = to . x || 0 ; %NWL%to . y = to . y || 0 ; %NWL%9
}%NWL%}  ,%NWL%clearObject : function ( obj_in , light_shader )  {%NWL%var gl = GLCore . gl ; %NWL%if ( renderBindState . uv ! =  = undef && renderBindState . uv ! =  =  - 1 )  {%NWL%gl . disableVertexAttribArray ( renderBindState . uv )  ;%NWL%}%NWL%if ( renderBindState . un ! =  = undef && renderBindState . un ! =  =  - 1 )  {%NWL%gl . disableVertexAttribArray ( renderBindState . un )  ;%NWL%}%NWL%if ( renderBindState . uc ! =  = undef && renderBindState . uc ! =  =  - 1 )  {%NWL%4
}  ; %NWL%return stats ;%NWL%}  ; %NWL%exports . Application =  ( function (  )  {%NWL%function _Class ( canvas )  {%NWL%var floatExt , folder , gui , resmap ,%NWL%_this = this ; %NWL%this . canvas = canvas ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . resize = __bind ( this . resize , this )  ; %NWL%this . lightChange = __bind ( this . lightChange , this )  ; %NWL%8
layout . min = sheetmedia . match ( mq . minRegex )  ; %NWL%layout . max = sheetmedia . match ( mq . maxRegex )  ; %NWL%if ( layout . min || layout . max )  {%NWL%if ( layout . min )  {%NWL%layout . min = layout . min [ 0 ]  . split (  '  :  '  )  [ 1 ]  ; %NWL%layout . min = parseInt ( layout . min , 10 )  ;%NWL%} else {%NWL%layout . min = 0 ;%NWL%}%NWL%if ( layout . max )  {%NWL%layout . max = layout . max [ 0 ]  . split (  '  :  '  )  [ 1 ]  ; %NWL%4
function updateHash (  )  {%NWL%for ( var i = 0 ; i < feeds . length ; i +  +  )  {%NWL%var obj = $ (  ' # '  + feeds [ i ]  . channel +  '  - feed '  )  ; %NWL%if ( !obj . length )  {%NWL%feeds . splice ( i , 1 )  ; %NWL%continue ;%NWL%}%NWL%feeds [ i ]  . top = obj . position (  )  . top ; %NWL%feeds [ i ]  . left = obj . position (  )  . left ; %NWL%feeds [ i ]  . width = obj . width (  )  ; %NWL%feeds [ i ]  . height = obj . height (  )  ; %NWL%9
grid . api . registerEventsFromObject ( publicApi . events )  ; %NWL%grid . api . registerMethodsFromObject ( publicApi . methods )  ;%NWL%}  ,%NWL%defaultGridOptions : function ( gridOptions )  {%NWL%gridOptions . saveWidths = gridOptions . saveWidths ! =  = false ; %NWL%gridOptions . saveOrder = gridOptions . saveOrder ! =  = false ; %NWL%gridOptions . saveScroll = gridOptions . saveScroll =  =  = true ; %NWL%gridOptions . saveFocus = gridOptions . saveScroll ! =  = true && gridOptions . saveFocus ! =  = false ; %NWL%gridOptions . saveVisible = gridOptions . saveVisible ! =  = false ; %NWL%gridOptions . saveSort = gridOptions . saveSort ! =  = false ; %NWL%gridOptions . saveFilter = gridOptions . saveFilter ! =  = false ; %NWL%4
this . aspect = other . aspect ; %NWL%this . invWidth = 1 / this . width ; %NWL%this . invHeight = 1 / this . height ; %NWL%this . autoResize = other . autoResize ; %NWL%this . background . copy ( other . background )  ; %NWL%this . far = other . far ; %NWL%this . near = other . near ; %NWL%this . fov = other . fov ; %NWL%this . orthographic = other . orthographic ; %NWL%this . orthographicSize = other . orthographicSize ; %NWL%this . minOrthographicSize = other . minOrthographicSize ; %NWL%0
function Z001_MapScript (  )  {%NWL%this . Init = function Init ( zone )  {%NWL%this . zone = zone ;%NWL%}%NWL%this . Uninit = function (  )  {%NWL%clearInterval ( this . minTimer )  ;%NWL%}%NWL%this . onClientJoin = function onClientJoin ( client )  {%NWL%console . log (  ' A client joined map 1 '  )  ;%NWL%}%NWL%this . onClientLeave = function onClientLeave ( client )  {%NWL%7
query . sortBy =  ' invoiceDate '  ; %NWL%query . sortDirection =  ' desc '  ; %NWL%return query ;%NWL%}%NWL%function renderReport ( promiseResults )  {%NWL%promiseResults . then ( function ( response )  {%NWL%console . info ( response )  ; %NWL%var queryResult = queryResultDisplayBuilder . transform ( response , saleOverTimeResultBuilder )  ; %NWL%$scope . results = queryResult . items ; %NWL%$scope . itemsPerPage = queryResult . itemsPerPage ; %NWL%$scope . totalItems = queryResult . totalItems ; %NWL%9
var Org = function ( address )  {%NWL%this . html = function (  )  {%NWL%return new Directive (  ' org < span class =  " value "  >  '  +%NWL%int2hex32 ( address )  +  '  <  / span >  '  )  . html (  )  ;%NWL%}  ;%NWL%}  ; %NWL%var Instruction = function ( ops )  {%NWL%' use strict '  ; %NWL%this . address = ops . address ; %NWL%this . addressHex32 = int2hex32 ( this . address )  ; %NWL%this . jumpAddress = ops . jumpAddress ; %NWL%8
}%NWL%return obj ;  /  / Object%NWL%}%NWL%dojo . lang . extend = function ( constructor ,  props )  {%NWL%for ( var i = 1 , l = arguments . length ; i < l ; i +  +  )  {%NWL%dojo . lang . _mixin ( constructor . prototype , arguments [ i ]  )  ;%NWL%}%NWL%return constructor ;  /  / Object%NWL%}%NWL%dojo . inherits = dojo . lang . inherits ; %NWL%dojo . mixin = dojo . lang . mixin ; %NWL%9
if ( !request . store )  {%NWL%request . store = this ;%NWL%}%NWL%var self = this ; %NWL%var scope = request . scope || kernel . global ; %NWL%var reqParams =  {  }  ; %NWL%if ( request . query )  {%NWL%reqParams . query = jsonUtil . toJson ( request . query )  ;%NWL%}%NWL%if ( request . sort )  {%NWL%reqParams . sort = jsonUtil . toJson ( request . sort )  ; %NWL%7
this . menuItemHoverStyle =  "  "  ; %NWL%this . popup = null ; %NWL%this . hoverClassName =  "  "  ; %NWL%this . hoverColor =  "  "  ; %NWL%this . oldColor = this . menuLabelElement . style . color ; %NWL%this . oldTextDecoration = this . menuLabelElement . style . textDecoration ; %NWL%this . oldClassName = this . menuLabelElement . className ; %NWL%this . Show = WebPartMenu_Show ; %NWL%this . Hide = WebPartMenu_Hide ; %NWL%this . Hover = WebPartMenu_Hover ; %NWL%this . Unhover = WebPartMenu_Unhover ; %NWL%7
}  ; %NWL%var setup_onpopstate_event_handler = function ( server )  {%NWL%}  ; %NWL%return EventListener ;%NWL%}  )  (  )  ; %NWL%ClientExpress . Request =  ( function ( raw_data )  {%NWL%var Request = function ( raw_data )  {%NWL%var self = this ; %NWL%this . session = raw_data . session ; %NWL%this . params =  {  }  ; %NWL%this . title = raw_data . title ; %NWL%8
dojo . declare (  " dojox . data . OpmlStore "  , null ,  {%NWL%constructor : function ( keywordParameters )  {%NWL%this . _xmlData = null ; %NWL%this . _arrayOfTopLevelItems =  [  ]  ; %NWL%this . _arrayOfAllItems =  [  ]  ; %NWL%this . _metadataNodes = null ; %NWL%this . _loadFinished = false ; %NWL%this . url = keywordParameters . url ; %NWL%this . _opmlData = keywordParameters . data ;  /  / XML DOM Document%NWL%if ( keywordParameters . label )  {%NWL%this . label = keywordParameters . label ; %NWL%7
function BinaryWriter ( estimatedSize )%NWL%{%NWL%this . estimatedSize = estimatedSize ; %NWL%this . pos = 0 ; %NWL%this . data = new Uint8Array ( estimatedSize )  ; %NWL%this . masks =  [ 0x0 , 0xFF + 1 , 0xFFFF + 1 , 0xFFFFFF + 1 , 0xFFFFFFFF + 1 ]  ; %NWL%this . writeUInt8 = function writeUInt8 ( value , bigEndian )%NWL%{%NWL%return this . writeInteger ( value , 1 , bigEndian )  ;%NWL%}  ; %NWL%this . writeInt8 = function writeInt8 ( value , bigEndian )%NWL%6
arr . writeUInt16BE = BP . writeUInt16BE%NWL%arr . writeUInt32LE = BP . writeUInt32LE%NWL%arr . writeUInt32BE = BP . writeUInt32BE%NWL%arr . writeInt8 = BP . writeInt8%NWL%arr . writeInt16LE = BP . writeInt16LE%NWL%arr . writeInt16BE = BP . writeInt16BE%NWL%arr . writeInt32LE = BP . writeInt32LE%NWL%arr . writeInt32BE = BP . writeInt32BE%NWL%arr . writeFloatLE = BP . writeFloatLE%NWL%arr . writeFloatBE = BP . writeFloatBE%NWL%arr . writeDoubleLE = BP . writeDoubleLE%NWL%0
exports . destroyServer = function destroyServer ( server , callback )  {%NWL%var serverId = server instanceof base . Server ? server . id : server ; %NWL%azureApi . destroyServer ( this , serverId , function ( err )  {%NWL%if ( callback )  {%NWL%return !err%NWL%? callback && callback ( null ,  { ok : serverId }  )%NWL% : callback && callback ( err )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%exports . stopServer = function stopServer ( server , callback )  {%NWL%0
cSMILTimeElement . apply ( this , arguments )  ;%NWL%}  ; %NWL%cSMILAnimationElement . prototype	 = new cSMILTimeElement (  " #element - animation "  )  ; %NWL%function fSMILAnimationElement_init ( oEvent )  {%NWL%var oElement	 = oEvent . currentTarget ; %NWL%oElement . targetElement	 = fElement_getAttribute ( oElement ,  " targetElement "  ) || fElement_getAttribute ( oElement ,  " xlink : href "  )  ; %NWL%oElement . attributeName	 = fElement_getAttribute ( oElement ,  " attributeName "  )  ; %NWL%oElement . attributeType	 = fElement_getAttribute ( oElement ,  " attributeType "  )  ; %NWL%oElement . from		 = fNodeAnimation_parseValue ( fElement_getAttribute ( oElement ,  " from "  )  )  ; %NWL%oElement . to			 = fNodeAnimation_parseValue ( fElement_getAttribute ( oElement ,  ' to '  )  )  ; %NWL%oElement . by			 = fNodeAnimation_parseValue ( fElement_getAttribute ( oElement ,  ' by '  )  )  ; %NWL%9
}  ; %NWL%Grapnel = require (  '  .  / grapnel '  )  . Grapnel ; %NWL%Warden =  ( function ( _super )  {%NWL%__extends ( Warden , _super )  ; %NWL%function Warden ( opts )  {%NWL%var action , route ; %NWL%if ( opts =  = null )  {%NWL%opts =  {  }  ;%NWL%}%NWL%this . match = __bind ( this . match , this )  ; %NWL%this . findController = __bind ( this . findController , this )  ; %NWL%9
this . white = white || 0 ; %NWL%this . black = black || 0 ; %NWL%this . current_input_masks = current_input_masks || 0 ; %NWL%this . height_px = height_px || 0 ; %NWL%this . width_px = width_px || 0 ; %NWL%this . height_mm = height_mm || 0 ; %NWL%this . width_mm = width_mm || 0 ; %NWL%this . maps_min = maps_min || 0 ; %NWL%this . maps_max = maps_max || 0 ; %NWL%this . root_visual = root_visual || 0 ; %NWL%this . backing_stores = backing_stores || 0 ; %NWL%0
return value =  =  = defaultValue ;%NWL%}%NWL%function getStringOrNull ( obj , property )  {%NWL%return typeof obj [ property ]  =  =  =  ' string ' ? obj [ property ]  : null ;%NWL%}%NWL%function SettingImpl ( json )  {%NWL%this . pid = json . pid ; %NWL%this . isRef = getStringOrNull ( json ,  ' classId '  )  ;  /  / $NON - NLS - 0$%NWL%this . classId = this . isRef ? json . classId : this . pid +  '  . type '  ;  /  / $NON - NLS - 0$%NWL%this . name = getStringOrNull ( json ,  ' name '  )  ;  /  / $NON - NLS - 0$%NWL%this . nameKey = getStringOrNull ( json ,  ' nameKey '  )  ;  /  / $NON - NLS - 0$%NWL%9
}  ; %NWL%GameManager . prototype . isGameTerminated = function (  )  {%NWL%return this . over || ( this . won && !this . keepPlaying )  ;%NWL%}  ; %NWL%GameManager . prototype . setup = function (  )  {%NWL%var previousState = this . storageManager . getGameState (  )  ; %NWL%if ( previousState )  {%NWL%this . grid   = new Grid ( previousState . grid . size ,%NWL%previousState . grid . cells )  ;  /  / Reload grid%NWL%this . score   = previousState . score ; %NWL%this . over   = previousState . over ; %NWL%9
var BaseModel , Issues ,%NWL%bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%extend = function ( child , parent )  { for ( var key in parent )  { if ( hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ,%NWL%hasProp =  {  }  . hasOwnProperty ; %NWL%BaseModel = require (  '  .  .  / BaseModel '  )  ; %NWL%Issues =  ( function ( superClass )  {%NWL%extend ( Issues , superClass )  ; %NWL%function Issues (  )  {%NWL%this . edit = bind ( this . edit , this )  ; %NWL%this . create = bind ( this . create , this )  ; %NWL%this . show = bind ( this . show , this )  ; %NWL%8
}  )%NWL%. factory (  ' GraphModelFactory '  , function ( client )  {%NWL%var Graph = Backbone . View . extend (  {%NWL%initialize : function ( options )  {%NWL%this . objs = options . objs ; %NWL%this . objs . on (  ' reset '  , this . reset , this )  ; %NWL%this . objs . on (  ' add '  , this . add , this )  ; %NWL%this . objs . on (  ' remove '  , this . remove , this )  ; %NWL%this . nodes =  [  ]  ; %NWL%this . links =  [  ]  ; %NWL%this . clustering = options . clustering ; %NWL%4
y >  = this . getHandleTopLeftY (  ) && y <  = this . getHandleTopLeftY (  )  + this . handleSize ;%NWL%}  ; %NWL%fc . Crop . prototype . getCropOverlap = function ( x , y )  {%NWL%return x >  = this . x && x <  = this . x + this . width &&%NWL%y >  = this . y && y <  = this . y + this . height ;%NWL%}  ; %NWL%fc . Crop . prototype . setSize = function ( width , height )  {%NWL%if ( width > this . maxSize || height > this . maxSize )  {%NWL%var resizedImage = this . getResizedImage (  )  ; %NWL%this . width = resizedImage . width ; %NWL%this . height = resizedImage . height ; %NWL%9
}  ; %NWL%Viewport . prototype . overrideScreenInfo = function ( width , height , orientation )  {%NWL%this . screenInfo =  { width : width , height : height , orientation : orientation }  ;%NWL%}  ; %NWL%function EventHandler ( args )  {%NWL%this . el = $ (  ' # '  + args . id )  ; %NWL%this . dragTolerance = args . dragTolerance || 3 ; %NWL%this . mouse   = args . mouse ; %NWL%this . onClick   = args . onClick ; %NWL%this . onDrag   = args . onDrag ; %NWL%this . onDragStart  = args . onDragStart ; %NWL%7
}  )  ; %NWL%DataSourceClock . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new DataSourceClock (  )  ;%NWL%}%NWL%result . startTime = this . startTime ; %NWL%result . stopTime = this . stopTime ; %NWL%result . currentTime = this . currentTime ; %NWL%result . clockRange = this . clockRange ; %NWL%result . clockStep = this . clockStep ; %NWL%result . multiplier = this . multiplier ; %NWL%5
var Node = require (  '  .  / node '  )  ; %NWL%var Member = module . exports = function Member ( left , right )  {%NWL%Node . call ( this )  ; %NWL%this . left = left ; %NWL%this . right = right ;%NWL%}  ; %NWL%Member . prototype . __proto__ = Node . prototype ; %NWL%Member . prototype . clone = function (  )  {%NWL%var clone = new Member ( this . left . clone (  )  , this . right . clone (  )  )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%9
}%NWL%overlay . show (  )  ; %NWL%overlay . css (  { top : pos . top - 22 , left : pos . left - 22 }  )  ; %NWL%overlay . text ( DB . getItemName ( item )  )  ;%NWL%}%NWL%function onEquipmentOut (  )%NWL%{%NWL%Equipment . ui . find (  '  . overlay '  )  . hide (  )  ;%NWL%}%NWL%Equipment . onUnEquip   = function onUnEquip (  )  {  }  ; %NWL%Equipment . onConfigUpdate = function onConfigUpdate (  )  {  }  ; %NWL%9
if ( isfav ( self . xindent )  )  {%NWL%txtfav . text =  ' F '  ;%NWL%} else {%NWL%txtfav . text =  ' G '  ;%NWL%}%NWL%console . log ( img . ximage_backup )  ;%NWL%}%NWL%}  ; %NWL%var offscreen = function (  )  {%NWL%img . width = self . getSize (  )  . width ; %NWL%img . height = self . getSize (  )  . height ; %NWL%9
this . _reset . legends = true ; %NWL%return this ;%NWL%}  ; %NWL%prototype . width = function ( width )  {%NWL%if ( this . _defs ) this . _defs . width = width ; %NWL%if ( this . _defs && this . _defs . marks ) this . _defs . marks . width = width ; %NWL%if ( this . _scene ) this . _scene . items [ 0 ]  . width = width ; %NWL%this . _reset . axes = true ; %NWL%return this ;%NWL%}  ; %NWL%prototype . height = function ( height )  {%NWL%3
hackNative (  )%NWL%attach (  )%NWL%keep (  )%NWL%seajs . config (  { cwd : normalize ( process . cwd (  )  )  +  "  /  "  }  )%NWL%function runSeaJS ( filepath )  {%NWL%var code = fs . readFileSync ( path . join ( __dirname , filepath )  ,  " utf8 "  )%NWL%code = code . replace (  "  }  )  ( this )  ;  "  ,  "  }  )  ( exports )  ;  "  )%NWL%var sandbox = require (  "  .  / sandbox "  )%NWL%vm . runInNewContext ( code , sandbox ,  " sea - debug . vm "  )%NWL%global . seajs = sandbox . exports . seajs%NWL%global . define = sandbox . exports . define%NWL%9
return carena . build (  {  }  ,  [  " composer . Pipe "  ]  )  ;%NWL%}  ,%NWL%createProxy : function (  )  {%NWL%var proxy = safe . proxy = carena . build (  {  }  ,  [%NWL%" carena . Node "  ,%NWL%" carena . Eventable "  ,%NWL%" carena . Draggable "  ,%NWL%]  )  ; %NWL%proxy . x   = obj . x ; %NWL%proxy . y   = obj . y ; %NWL%proxy . width  = obj . width ; %NWL%8
var binding = new URITemplate (  "  {  , params *  }  "  )  . expand (  {  /  / $NON - NLS - 0$%NWL%params : params%NWL%}  )  ; %NWL%return "  ,  "  + binding ;  /  / $NON - NLS - 0$%NWL%}  ; %NWL%searchUtils . convertFindURLBinding = function ( findParams )  {%NWL%if ( typeof findParams . regEx =  =  =  " string "  )  {  /  / $NON - NLS - 0$%NWL%findParams . regEx =  ( findParams . regEx . toLowerCase (  )  =  =  =  " true "  )  ;  /  / $NON - NLS - 0$%NWL%}%NWL%if ( typeof findParams . caseSensitive =  =  =  " string "  )  {  /  / $NON - NLS - 0$%NWL%findParams . caseSensitive =  ( findParams . caseSensitive . toLowerCase (  )  =  =  =  " true "  )  ;  /  / $NON - NLS - 0$%NWL%7
var Key = require (  '  .  / Key '  )  ; %NWL%var KeyLine = require (  '  .  / KeyLine '  )  ; %NWL%var amgui = require (  '  .  .  / amgui '  )  ; %NWL%function Param ( opt =  {  }  , timeline )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . timeline = timeline ; %NWL%this . _lineH =  amgui . LINE_HEIGHT ; %NWL%this . _inputs =  [  ]  ; %NWL%this . _defaultValue = opt . defaultValue || 0 ; %NWL%this . _onChangeInput = this . _onChangeInput . bind ( this )  ; %NWL%this . _onClickTgglKey = this . _onClickTgglKey . bind ( this )  ; %NWL%9
m . lineno = self . lineno ; %NWL%m . row = self . row ;%NWL%}%NWL%}%NWL%callStack . pop (  )  ; %NWL%return result ;%NWL%} else {%NWL%m = cache [ start ]  ; %NWL%self . cur = m . cur ; %NWL%self . lineno = m . lineno ; %NWL%self . row = m . row ; %NWL%8
]  ,%NWL%function ( _ , Backbone , BackstrappMarionette ,%NWL%BaseCollection , BaseModel , BaseController , BaseRouter ,%NWL%stackRegion , stackManager , appSettings , effect )  {%NWL%var ns = BackstrappMarionette ; %NWL%stackManager . init ( ns )  ; %NWL%appSettings . init ( ns )  ; %NWL%ns . Collection = BaseCollection ; %NWL%ns . Model = BaseModel ; %NWL%ns . Controller = BaseController ; %NWL%ns . Router = BaseRouter ; %NWL%7
}%NWL%GameBoyAdvanceSound . prototype . clockAudioEnvelope = function (  )  {%NWL%this . channel1 . clockAudioEnvelope (  )  ; %NWL%this . channel2 . clockAudioEnvelope (  )  ; %NWL%this . channel4 . clockAudioEnvelope (  )  ;%NWL%}%NWL%GameBoyAdvanceSound . prototype . computeAudioChannels = function (  )  {%NWL%this . channel1 . FrequencyCounter =  (  ( this . channel1 . FrequencyCounter | 0 )  -  ( this . audioClocksUntilNextEvent | 0 )  ) | 0 ; %NWL%this . channel2 . FrequencyCounter =  (  ( this . channel2 . FrequencyCounter | 0 )  -  ( this . audioClocksUntilNextEvent | 0 )  ) | 0 ; %NWL%this . channel3 . counter =  (  ( this . channel3 . counter | 0 )  -  ( this . audioClocksUntilNextEvent | 0 )  ) | 0 ; %NWL%this . channel4 . counter =  (  ( this . channel4 . counter | 0 )  -  ( this . audioClocksUntilNextEvent | 0 )  ) | 0 ; %NWL%9
var tls = require (  ' tls '  )  ; %NWL%var Protobuf = require (  ' protobuf . js '  )  ; %NWL%var riakproto = require (  ' riakproto '  )  ; %NWL%var _merge = require (  '  .  / merge '  )  ; %NWL%var Parser = require (  '  .  / parser '  )  ; %NWL%function ConnectionManager ( options )  {%NWL%this . host = options . host ; %NWL%this . port = options . port ; %NWL%this . connectTimeout = options . connectTimeout ; %NWL%this . parseValues = options . parseValues ; %NWL%this . auth = options . auth ; %NWL%6
}%NWL%if ( options . my [ 1 ]  =  =  =  " bottom "  )  {%NWL%position . top -  = elemHeight ;%NWL%} else if ( options . my [ 1 ]  =  =  =  " center "  )  {%NWL%position . top -  = elemHeight / 2 ;%NWL%}%NWL%position . left +  = myOffset [ 0 ]  ; %NWL%position . top +  = myOffset [ 1 ]  ; %NWL%if ( !supportsOffsetFractions )  {%NWL%position . left = round ( position . left )  ; %NWL%position . top = round ( position . top )  ; %NWL%9
" odin / core / assets / assets "%NWL%]  ,%NWL%function ( Enums , Component , Assets )  {%NWL%" use strict "  ; %NWL%function Sprite ( opts )  {%NWL%opts || ( opts =  {  }  )  ; %NWL%Component . call ( this ,  " Sprite "  , opts )  ; %NWL%this . visible = opts . visible ! = undefined ? !! opts . visible : true ; %NWL%this . blending = opts . blending ! = undefined ? opts . blending : Enums . Blending . Default ; %NWL%this . layer = opts . layer ! = undefined ? opts . layer : 0 ; %NWL%this . z = opts . z ! = undefined ? opts . z : 0 ; %NWL%9
fill = dojox . gfx . makeParameters ( dojox . gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeX "  )  {%NWL%var span = bbox . width ; %NWL%fill . x1 = bbox . x + span * fill . x1 / 100 ; %NWL%fill . x2 = bbox . x + span * fill . x2 / 100 ;%NWL%}%NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeY "  )  {%NWL%var span = bbox . height ; %NWL%fill . y1 = bbox . y + span * fill . y1 / 100 ; %NWL%fill . y2 = bbox . y + span * fill . y2 / 100 ; %NWL%9
Ext . apply ( o ,  {%NWL%height : this . height ,%NWL%width : this . width%NWL%}  )  ;%NWL%}%NWL%return o ;%NWL%}  ,%NWL%applyState : function ( state )  {%NWL%this . widgetGuid = state . widgetGuid ; %NWL%this . uniqueId = state . uniqueId ; %NWL%this . name = state . name ; %NWL%8
var expect =  '  '  ; %NWL%printBugNumber ( BUGNUMBER )  ; %NWL%printStatus ( summary )  ; %NWL%var count = 0 ; %NWL%var result =  "  "  ; %NWL%var value =  "  "  ; %NWL%var t = new Object (  )  ; %NWL%t . one =  " one "  ; %NWL%t . two =  " two "  ; %NWL%t . three =  " three "  ; %NWL%t . four =  " four "  ; %NWL%7
for ( var p in options )  { this . _options [ p ]  = options [ p ]  ;  }%NWL%this . _features =  {%NWL%" Room "  : 4 ,%NWL%" Corridor "  : 4%NWL%}%NWL%this . _featureAttempts = 20 ; %NWL%this . _walls =  {  }  ; %NWL%this . _digCallback = this . _digCallback . bind ( this )  ; %NWL%this . _canBeDugCallback = this . _canBeDugCallback . bind ( this )  ; %NWL%this . _isWallCallback = this . _isWallCallback . bind ( this )  ; %NWL%this . _priorityWallCallback = this . _priorityWallCallback . bind ( this )  ; %NWL%7
a = a . match (  / ^ ( \W ) ? (  .  *  )  /  )  ; var b = document [  " getElement "  +  ( a [ 1 ] ?a [ 1 ]  =  =  " # " ? " ById "  :  " sByClassName "  :  " sByTagName "  )  ]  ( a [ 2 ]  )  ; %NWL%var ret =  [  ]  ; 	b! = null&& ( b . length?ret = b : b . length =  = 0?ret = b : ret =  [ b ]  )  ; 	return ret ;%NWL%}%NWL%function extend ( a , b )  { var c =  {  }  ; for ( var d in a ) c [ d ]  = a [ d ]  ; for ( var e in b ) c [ e ]  = b [ e ]  ; return c }%NWL%function draw ( ctx , dimensions , template )  {%NWL%var dimension_arr =  [ dimensions . height , dimensions . width ]  . sort (  )  ; %NWL%var maxFactor = Math . round ( dimension_arr [ 1 ]  / 16 )  ,%NWL%minFactor = Math . round ( dimension_arr [ 0 ]  / 16 )  ; %NWL%var text_height = Math . max ( template . size , maxFactor )  ; %NWL%canvas . width = dimensions . width ; %NWL%canvas . height = dimensions . height ; %NWL%9
opts = dir%NWL%dir = process . cwd (  )%NWL%}%NWL%if ( typeof opts =  =  =  ' function '  )  {%NWL%onReady = opts%NWL%opts =  {  }%NWL%}%NWL%if ( typeof opts =  =  =  ' undefined '  ) opts =  {  }%NWL%if ( !onReady ) onReady = function (  )  {  }%NWL%if ( typeof opts . init =  =  =  ' undefined '  ) opts . init = true%NWL%if ( typeof opts . storage =  =  =  ' undefined '  ) opts . storage = true%NWL%9
}%NWL%if ( typeof options . opens =  =  ' string '  )%NWL%this . opens = options . opens ; %NWL%if ( typeof options . showWeekNumbers =  =  ' boolean '  )  {%NWL%this . showWeekNumbers = options . showWeekNumbers ;%NWL%}%NWL%if ( typeof options . buttonClasses =  =  ' string '  )  {%NWL%this . buttonClasses =  [ options . buttonClasses ]  ;%NWL%}%NWL%if ( typeof options . buttonClasses =  =  ' object '  )  {%NWL%this . buttonClasses = options . buttonClasses ; %NWL%2
}  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%module . exports . ebayApiPostXmlRequest = ebayApiPostXmlRequest ; %NWL%var paginateGetRequest = function paginateGetRequest ( options , callback )  {%NWL%if ( ! options . serviceName ) return callback ( new Error (  " Missing serviceName "  )  )  ; %NWL%if ( ! options . opType ) return callback ( new Error (  " Missing opType "  )  )  ; %NWL%if ( ! options . appId ) return callback ( new Error (  " Missing appId "  )  )  ; %NWL%options . params = options . params || {  }  ; %NWL%options . filters = options . filters || {  }  ; %NWL%options . reqOptions = options . reqOptions || {  }  ; %NWL%8
if ( typeof schema . size ! =  =  ' number ' || schema . size < 1 )  {%NWL%throw ' Unexpected size '  + JSON . stringify ( schema . size )  +  ' for fixed type at '  + path ;%NWL%}%NWL%schema . namespace = schema . namespace || namespace ; %NWL%defineNamedType ( schema , path )  ; %NWL%return decorate ( schema )  ;%NWL%} else if ( schema . type =  =  =  ' array '  )  {%NWL%schema . items = parseSchema ( schema . items , namespace , joinPath ( path ,  ' items '  )  )  ; %NWL%return decorate ( schema )  ;%NWL%} else if ( schema . type =  =  =  ' map '  )  {%NWL%schema . values = parseSchema ( schema . values , namespace , joinPath ( path ,  ' values '  )  )  ; %NWL%7
}  ;%NWL%}  ; %NWL%lineparser . notp = this . notp = function ( item )  {%NWL%if (  ( typeof item )  =  =  =  ' string '  )  {%NWL%item = self . literal ( item )  ;%NWL%}%NWL%return function (  )  {%NWL%return !item (  )  ;%NWL%}  ;%NWL%}  ; %NWL%lineparser . may = this . may = function ( item )  {%NWL%2
}%NWL%if ( divname ! =  "  "  )  {%NWL%var cp = new PopupWindow ( divname )  ;%NWL%}%NWL%else {%NWL%var cp = new PopupWindow (  )  ; %NWL%cp . setSize ( 225 , 250 )  ;%NWL%}%NWL%cp . currentValue =  " #FFFFFF "  ; %NWL%cp . writeDiv = ColorPicker_writeDiv ; %NWL%cp . highlightColor = ColorPicker_highlightColor ; %NWL%9
this . onChangeAttribute && connect . disconnect ( this . onChangeAttribute )  ; %NWL%this . onChangeData && connect . disconnect ( this . onChangeData )  ; %NWL%this . swapped = this . parent . cloneNode ( true )  ; %NWL%this . parent . parentNode . replaceChild ( this . swapped , this . parent )  ;%NWL%}%NWL%}  ,%NWL%render : function ( context , buffer )  {%NWL%this . parent = buffer . getParent (  )  ; %NWL%if ( this . options . node )  {%NWL%this . onAddNode = connect . connect ( buffer ,  " onAddNode "  , lang . hitch ( this ,  " _swap "  ,  " node "  )  )  ; %NWL%this . onRemoveNode = connect . connect ( buffer ,  " onRemoveNode "  , lang . hitch ( this ,  " _swap "  ,  " node "  )  )  ; %NWL%9
to  : 100 ,%NWL%step : 0 . 1%NWL%}  ,%NWL%initialize : function ( id , config )  {%NWL%var self = this ; %NWL%var op = extend (  {  }  , this . default_config )  ; %NWL%this . config = extend ( op , config )  ; %NWL%this . observers =  [  ]  ; %NWL%this . base  = _$ ( id )  ; %NWL%this . bar  = $N (  " DIV "  ,  {  " class "  :  " slider - bar "  }  )  ; %NWL%this . handle = $N (  " DIV "  ,  {  " class "  :  " slider - handle "  }  )  ; %NWL%9
res . render (  ' create '  ,  {%NWL%title :  ' linkr | create '%NWL%, user : user%NWL%, path : req . route . path%NWL%}  )  ;%NWL%}  )  ; %NWL%app . post (  '  / create '  , function ( req , res )  {%NWL%if ( req . body . email && req . body . pass && ( req . body . pass =  =  = req . body . confirm ) && req . body . first && req . body . last )  {%NWL%var user = new users (  )  ; %NWL%user . first = req . body . first ; %NWL%user . last = req . body . last ; %NWL%9
armA . rotation = angle0 ; %NWL%if ( !this . running ) armB . rotation = armA . rotation - angle1 ; %NWL%else armB . rotation = armA . rotation - angle1 - fourtyFive ; %NWL%armB . x = armA . getPin (  )  . x ; %NWL%armB . y = armA . getPin (  )  . y ;%NWL%}  ,%NWL%bodyAngle : function ( body , leg )  {%NWL%var angle =  -  ( 180 - this . sets . thighBase )  * this . ToRad ; %NWL%body . rotation = angle ; %NWL%body . x = leg . x ; %NWL%body . y = leg . y ; %NWL%9
if ( !isNaN ( this . op1 )  )  { this . op1 = Number ( this . op1 )  ;  }%NWL%if ( !isNaN ( this . op2 )  )  { this . op2 = Number ( this . op2 )  ;  }%NWL%if ( this . op1 =  =  " true "  )  { this . op1 = true ;  }%NWL%if ( this . op2 =  =  " true "  )  { this . op2 = true ;  }%NWL%if ( this . op1 =  =  " false "  )  { this . op1 = false ;  }%NWL%if ( this . op2 =  =  " false "  )  { this . op2 = false ;  }%NWL%if ( this . op1 =  =  " null "  )  { this . op1 = null ;  }%NWL%if ( this . op2 =  =  " null "  )  { this . op2 = null ;  }%NWL%try { this . op1 = JSON . parse ( this . op1 )  ;  }%NWL%catch ( e )  { this . op1 = this . op1 ;  }%NWL%try { this . op2 = JSON . parse ( this . op2 )  ;  }%NWL%8
}  ; %NWL%self . appendTo = appendTo = function ( node )  {%NWL%var%NWL%parentEl = node . getContentEl (  )  ; %NWL%if ( parentEl ! =  = undefined )  {%NWL%parentEl . appendChild ( wrapperEl )  ; %NWL%attach ( node )  ;%NWL%}%NWL%return self ;%NWL%}  ; %NWL%self . prepend = prepend = function ( node )  {%NWL%1
r = r ! =  = 0 ? 1 / sqrt ( r )  : r ; %NWL%vel . x = dx * r * spd ; %NWL%vel . y = dy * r * spd ; %NWL%vel . z = dz * r * spd ;%NWL%}%NWL%vel . transformMat4Rotation ( transformMatrix )  ; %NWL%acc . x = acceleration . x + randFloat (  - accelerationSpread . x , accelerationSpread . x )  ; %NWL%acc . y = acceleration . y + randFloat (  - accelerationSpread . y , accelerationSpread . y )  ; %NWL%acc . z = acceleration . z + randFloat (  - accelerationSpread . z , accelerationSpread . z )  ; %NWL%particle . angularVelocity = angularVelocity + randFloat (  - angularVelocitySpread , angularVelocitySpread )  ; %NWL%particle . angularAcceleration = angularAcceleration + randFloat (  - angularAccelerationSpread , angularAccelerationSpread )  ; %NWL%9
canvas . bulgePinch = wrap ( bulgePinch )  ; %NWL%canvas . tiltShift = wrap ( tiltShift )  ; %NWL%canvas . dotScreen = wrap ( dotScreen )  ; %NWL%canvas . edgeWork = wrap ( edgeWork )  ; %NWL%canvas . lensBlur = wrap ( lensBlur )  ; %NWL%canvas . zoomBlur = wrap ( zoomBlur )  ; %NWL%canvas . noise = wrap ( noise )  ; %NWL%canvas . denoise = wrap ( denoise )  ; %NWL%canvas . curves = wrap ( curves )  ; %NWL%canvas . swirl = wrap ( swirl )  ; %NWL%canvas . ink = wrap ( ink )  ; %NWL%0
}  ; %NWL%var isFiat = function ( value )  {%NWL%return _ . contains ( fiat_currencies , value )  ;%NWL%}  ; %NWL%var Trader = function ( config )  {%NWL%_ . bindAll ( this )  ; %NWL%this . currency =  " EUR "  ; %NWL%this . asset =  " XBT "  ; %NWL%if ( _ . isObject ( config )  )  {%NWL%this . key = config . key ; %NWL%this . secret = config . secret ; %NWL%9
var cr1u =  ( r1X * this . m_u . y - r1Y * this . m_u . x )  ; %NWL%var cr2u =  ( r2X * this . m_u . y - r2Y * this . m_u . x )  ; %NWL%this . m_mass = this . m_body1 . m_invMass + this . m_body1 . m_invI * cr1u * cr1u + this . m_body2 . m_invMass + this . m_body2 . m_invI * cr2u * cr2u ; %NWL%this . m_mass = 1 . 0 / this . m_mass ; %NWL%if ( box2d . World . s_enableWarmStarting )  {%NWL%var PX = this . m_impulse * this . m_u . x ; %NWL%var PY = this . m_impulse * this . m_u . y ; %NWL%this . m_body1 . m_linearVelocity . x -  = this . m_body1 . m_invMass * PX ; %NWL%this . m_body1 . m_linearVelocity . y -  = this . m_body1 . m_invMass * PY ; %NWL%this . m_body1 . m_angularVelocity -  = this . m_body1 . m_invI *  ( r1X * PY - r1Y * PX )  ; %NWL%this . m_body2 . m_linearVelocity . x +  = this . m_body2 . m_invMass * PX ; %NWL%7
}%NWL%if ( rconf . body && rconf . method =  =  =  ' GET '  )  {%NWL%rconf . uri +  =  ( rconf . uri . indexOf (  ' ? '  )  >  - 1 ? ' & '  :  ' ? '  )  + rconf . body ; %NWL%rconf . body =  '  '  ;%NWL%}%NWL%}%NWL%if ( config . headers )  {%NWL%rconf . headers = config . headers ;%NWL%}%NWL%if ( config . timeout )  {%NWL%rconf . timeout = config . timeout ; %NWL%7
obj . _valids . merge ( schema . _valids , schema . _invalids )  ; %NWL%obj . _invalids . merge ( schema . _invalids , schema . _valids )  ; %NWL%obj . _tests = obj . _tests . concat ( schema . _tests )  ; %NWL%obj . _refs = obj . _refs . concat ( schema . _refs )  ; %NWL%Hoek . merge ( obj . _flags , schema . _flags )  ; %NWL%obj . _description = schema . _description || obj . _description ; %NWL%obj . _unit = schema . _unit || obj . _unit ; %NWL%obj . _notes = obj . _notes . concat ( schema . _notes )  ; %NWL%obj . _tags = obj . _tags . concat ( schema . _tags )  ; %NWL%obj . _examples = obj . _examples . concat ( schema . _examples )  ; %NWL%obj . _meta = obj . _meta . concat ( schema . _meta )  ; %NWL%2
addIcon = false ; %NWL%if ( icon ! =  = this . _icon )  {%NWL%if ( this . _icon )  {%NWL%this . _removeIcon (  )  ;%NWL%}%NWL%addIcon = true ; %NWL%if ( options . title )  {%NWL%icon . title = options . title ;%NWL%}%NWL%if ( options . alt )  {%NWL%icon . alt = options . alt ; %NWL%7
verify ( update , function ( err , verified )  {%NWL%t . strictEqual ( verified , true )%NWL%isVerified = true%NWL%}  )%NWL%t . ok ( isVerified )%NWL%var Emitter = require (  '  .  .  / events '  )%NWL%var e = new Emitter ( secure )%NWL%ids . e = e . id%NWL%var d = new Emitter ( security ( keys ,  '  '  ,  '  '  )  )%NWL%var f = new Emitter ( secure2 )%NWL%ids . f = f . id%NWL%7
} else {%NWL%this . arm = null ;%NWL%}%NWL%this . tools =  [  ]  ; %NWL%this . _translation = data . t ; %NWL%this . _rotation = _ . flatten ( data . r )  ; %NWL%this . _scaleFactor = data . s ; %NWL%this . timeVisible = data . timeVisible ; %NWL%this . stabilizedPalmPosition = data . stabilizedPalmPosition ; %NWL%this . type = data . type ; %NWL%this . grabStrength = data . grabStrength ; %NWL%7
function exchangeDispatcher ( topicMatcher , topicDispatcher )  {%NWL%var dispatcher , topics ; %NWL%dispatcher =  {  }  ; %NWL%topics =  {  }  ; %NWL%dispatcher . subscribe = function subscribe ( topic , handler )  {%NWL%if ( !topics . hasOwnProperty ( topic )  )  {%NWL%topics [ topic ]  = topicDispatcher (  )  ;%NWL%}%NWL%topics [ topic ]  . subscribe ( handler )  ;%NWL%}  ; %NWL%dispatcher . unsubscribe = function unsubscribe ( topic , handler )  {%NWL%4
result . show = this . show ; %NWL%result . coordinates = this . coordinates ; %NWL%result . material = this . material ; %NWL%result . height = this . height ; %NWL%result . extrudedHeight = this . extrudedHeight ; %NWL%result . granularity = this . granularity ; %NWL%result . stRotation = this . stRotation ; %NWL%result . rotation = this . rotation ; %NWL%result . fill = this . fill ; %NWL%result . outline = this . outline ; %NWL%result . outlineColor = this . outlineColor ; %NWL%0
var spinnerClass =  ' scui - combobox - spinner - view '  ; %NWL%pane . verifyDomStructure = function verifyDomStructure ( view )  {%NWL%var layer = view . $ (  )  ; %NWL%var textField = view . $ (  '  . %@ '  . fmt ( textFieldClass )  )  ; %NWL%var dropDownButton = view . $ (  '  . %@ '  . fmt ( buttonClass )  )  ; %NWL%ok ( layer . hasClass (  ' scui - combobox - view '  )  ,  " Top div has class ' scui - combobox - view '  "  )  ; %NWL%equals ( layer . children (  )  . length , 2 ,  " Top div has two children "  )  ; %NWL%ok ( textField . length ,  " Has child with class %@ "  . fmt ( textFieldClass )  )  ; %NWL%ok ( dropDownButton . length ,  " Has child with class %@ "  . fmt ( buttonClass )  )  ;%NWL%}  ; %NWL%pane . verifyEmpty = function verifyEmpty ( view )  {%NWL%1
}%NWL%}%NWL%base . GLCore = GLCore ; %NWL%base . setFullScreen = setFullScreen ; %NWL%base . init = initCubicVR ; %NWL%base . start = startUp ; %NWL%base . addResizeable = GLCore . addResizeable ; %NWL%base . setFixedAspect = GLCore . setFixedAspect ; %NWL%base . setFixedSize = GLCore . setFixedSize ; %NWL%base . setCanvasSizeFactor = GLCore . setCanvasSizeFactor ; %NWL%base . getCanvas = GLCore . getCanvas ; %NWL%6
exports . kansorc = nodeunit . testCase (  {%NWL%setUp : function ( cb )  {%NWL%var _PATHS = kansorc . PATHS ; %NWL%this . _DEFAULTS = kansorc . DEFAULTS ; %NWL%this . _loadFile = kansorc . loadFile ; %NWL%this . _exists = fs . exists ; %NWL%cb (  )  ;%NWL%}  ,%NWL%tearDown : function ( cb )  {%NWL%kansorc . PATHS = this . _PATHS ; %NWL%kansorc . DEFAULTS = this . _DEFAULTS ; %NWL%9
var alto =  {  }  ; %NWL%window . alto = alto ; %NWL%_ . extend ( alto , Backbone . Events )  ; %NWL%alto . initialize = function ( options )  {%NWL%if ( options . mode )  {%NWL%alto . mode = options . mode ;%NWL%} else {%NWL%alto . mode =  ' views '  ;%NWL%}%NWL%alto . url_scheme = options . url_scheme ; %NWL%alto . query = options . query ; %NWL%5
}  ; %NWL%this . _loadInProgress = false ; 	 /  / Got to track the initial load to prevent duelling loads of the dataset .%NWL%this . _queuedFetches =  [  ]  ; %NWL%this . identifier = keywordParameters . identifier ; %NWL%if ( this . identifier =  =  =  "  "  )  {%NWL%delete this . identifier ;%NWL%} else {%NWL%this . _idMap =  {  }  ;%NWL%}%NWL%if (  " separator " in keywordParameters )  {%NWL%this . separator = keywordParameters . separator ; %NWL%3
this . minZ = minZ || 0 ; %NWL%this . maxZ = maxZ || 0 ; %NWL%this . parent = null ;%NWL%}  ; %NWL%OIMO . Proxy . prototype =  {%NWL%constructor : OIMO . Proxy ,%NWL%init : function ( minX , maxX , minY , maxY , minZ , maxZ )  {%NWL%this . minX = minX || 0 ; %NWL%this . maxX = maxX || 0 ; %NWL%this . minY = minY || 0 ; %NWL%this . maxY = maxY || 0 ; %NWL%0
def = $ . event . special [  ' drag '  + type ]  . defaults ,%NWL%data ; %NWL%ok ( $elem . drag ( type , fn )  [ 0 ]  =  = elem ,  '  . drag (  '  +  ( type ? '  "  '  + type +  '  "  ,  '  :  '  '  )  +  ' fn )  '  )  ; %NWL%ok ( data = $ . data ( elem , $ . event . special . drag . datakey )  ,  " drag data exists "  )  ; %NWL%ok ( $ . data ( elem ,  " events "  )  ,  " event data exists "  )  ; %NWL%ok ( $ . data ( elem ,  " events "  )  [  ' drag '  + type ]  [ 0 ]  ,  '  " drag '  + type +  '  " event handler added '  )  ; %NWL%ok ( data . which =  = def . which ,  '  " which " default stored '  )  ; %NWL%ok ( data . distance =  = def . distance ,  '  " distance " default stored '  )  ; %NWL%ok ( data . not =  = def . not ,  '  " not " default stored '  )  ; %NWL%ok ( data . handle =  = def . handle ,  '  " handle " default stored '  )  ; %NWL%ok ( data . relative =  = def . relative ,  '  " relative " default stored '  )  ; %NWL%6
}  ; %NWL%Wkt . Wkt . prototype . fromObject = function ( obj )  {%NWL%var result ; %NWL%if ( obj . hasOwnProperty (  ' type '  ) && obj . hasOwnProperty (  ' coordinates '  )  )  {%NWL%result = this . fromJson ( obj )  ;%NWL%} else {%NWL%result = this . deconstruct . call ( this , obj )  ;%NWL%}%NWL%this . components = result . components ; %NWL%this . isRectangle = result . isRectangle || false ; %NWL%this . type = result . type ; %NWL%8
" zIndex " 		 :  " 10000 "%NWL%}  )  ;%NWL%}%NWL%$ ( document )  . on (  " mousemove . vakata . jstree touchmove . vakata . jstree "  , $ . vakata . dnd . drag )  ; %NWL%$ ( document )  . on (  " mouseup . vakata . jstree touchend . vakata . jstree "  , $ . vakata . dnd . stop )  ; %NWL%return false ;%NWL%}  ,%NWL%drag : function ( e )  {%NWL%if ( e . type =  =  =  " touchmove " && e . originalEvent && e . originalEvent . changedTouches && e . originalEvent . changedTouches [ 0 ]  )  {%NWL%e . pageX = e . originalEvent . changedTouches [ 0 ]  . pageX ; %NWL%e . pageY = e . originalEvent . changedTouches [ 0 ]  . pageY ; %NWL%9
var identity =  ( function (  )  {%NWL%' use strict '  ; %NWL%var Identity = function (  )  {%NWL%var identity =  {  }  ; %NWL%identity . sex = sex (  )  ; %NWL%identity . firstName = firstName ( identity . sex )  ; %NWL%identity . lastName = lastName (  )  ; %NWL%identity . emailAddress = emailAddress ( identity . firstName , identity . lastName )  ; %NWL%identity . phoneNumber = phoneNumber (  )  ; %NWL%identity . street = street (  )  ; %NWL%identity . city = city (  )  ; %NWL%4
return false ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%xajax . debug . isLoaded = true ; %NWL%xjx =  {  }%NWL%xjx . $ = xajax . tools . $ ; %NWL%xjx . getFormValues = xajax . tools . getFormValues ; %NWL%xjx . call = xajax . call ; %NWL%xjx . request = xajax . request ; %NWL%9
newBadge . description = badge . strapline ; %NWL%newBadge . name = badge . name ; %NWL%newBadge . status = badge . archived ? ' archived '  :  ' published '  ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%newBadge . timeUnits = badge . timeUnits ; %NWL%newBadge . evidenceType = badge . evidenceType ; %NWL%newBadge . limit = badge . limit ; %NWL%newBadge . unique = badge . unique ; %NWL%1
" anchor "  :  [  - 10 ,  - 10 ]  ,%NWL%" size "  :  [ 13 , 13 ]%NWL%}  )  ; %NWL%this . _moveMarker . on (  ' drag '  , function ( e )  {%NWL%var markerPos = that . _moveMarker . getLatLng (  )  ,%NWL%latDelta = markerPos . lat - that . _nw . lat ,%NWL%lngDelta = markerPos . lng - that . _nw . lng ; %NWL%that . _nw = new L . LatLng ( that . _nw . lat + latDelta , that . _nw . lng + lngDelta , true )  ; %NWL%that . _ne = new L . LatLng ( that . _ne . lat + latDelta , that . _ne . lng + lngDelta , true )  ; %NWL%that . _sw = new L . LatLng ( that . _sw . lat + latDelta , that . _sw . lng + lngDelta , true )  ; %NWL%that . _se = new L . LatLng ( that . _se . lat + latDelta , that . _se . lng + lngDelta , true )  ; %NWL%7
}  )  ; %NWL%return [ xOffset , yOffset ]  ;%NWL%}  ; %NWL%function flipCanvas ( canvas , direction )  {%NWL%if ( $ . inArray ( direction ,  [  ' horizontal '  ,  ' vertical '  ,  ' both '  ]  )  =  =  =  - 1 )  {%NWL%$ . error (  ' Flip value must be one of horizontal , vertical or both '  )  ;%NWL%}%NWL%var flippedCanvas = $ (  '  < canvas /  >  '  )  [ 0 ]  ,%NWL%flippedContext ; %NWL%flippedCanvas . width = canvas . width ; %NWL%flippedCanvas . height = canvas . height ; %NWL%9
that . consoleMsg (  ' error '  , arguments )  ;%NWL%}  ; %NWL%console . dir = function (  )  {%NWL%that . consoleMsg (  ' dir '  , arguments )  ;%NWL%}  ; %NWL%return this ;%NWL%}  ,%NWL%revertConsole : function (  )  {%NWL%console . log = this . clog ; %NWL%console . warn = this . cwarn ; %NWL%console . error = this . cerror ; %NWL%8
}%NWL%}%NWL%}  ,%NWL%_resizeColumnOff : function ( e )  {%NWL%dojo . body (  )  . style . cursor =  " default "  ; %NWL%dojo . disconnect ( this . _connectResizeColumnMove )  ; %NWL%dojo . disconnect ( this . _connectResizeColumnOff )  ; %NWL%this . _connectResizeColumnOff = this . _connectResizeColumnMove = null ; %NWL%if ( !this . liveResizeColumns )  {%NWL%this . _currentColumn . style [  " width "  ]  = this . _currentColumnWidth +  " px "  ; %NWL%this . _nextColumn . style [  " width "  ]  = this . _nextColumnWidth +  " px "  ; %NWL%9
outerElement . setStyle = outerElement . setStyle . bind ( outerElement )  ; %NWL%outerElement . show = function (  )  {%NWL%this . style . display =  ' block '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . show = outerElement . show . bind ( outerElement )  ; %NWL%outerElement . hide = function (  )  {%NWL%this . style . display =  ' none '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . hide = outerElement . hide . bind ( outerElement )  ; %NWL%0
return this ;%NWL%}  ; %NWL%this . enable . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . enable "  ; %NWL%this . useDebug = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . debugEnabled ;%NWL%}%NWL%options . debugEnabled = value =  =  = true ; %NWL%return this ;%NWL%}  ; %NWL%this . useDebug . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useDebug "  ; %NWL%2
break%NWL%default : %NWL%this . _error ( new Error (  ' Atok#addRule : invalid type / handler , must be Number / String / Function '  )  )%NWL%return this%NWL%}%NWL%if ( first =  =  = 0 )%NWL%this . _error ( new Error (  ' Atok#addRule : invalid first subrule , must be > 0 '  )  )%NWL%else {%NWL%var groupProps = Object . create ( null )%NWL%groupProps . group = this . _group%NWL%groupProps . groupStart = this . _groupStart%NWL%9
hasOnePassingSelector = true ;%NWL%}%NWL%var rules = this . rules ? this . rules . slice ( 0 )  : null ,%NWL%ruleset = new ( tree . Ruleset )  ( selectors , rules , this . strictImports )  ,%NWL%rule , subRule ; %NWL%ruleset . originalRuleset = this ; %NWL%ruleset . root = this . root ; %NWL%ruleset . firstRoot = this . firstRoot ; %NWL%ruleset . allowImports = this . allowImports ; %NWL%if ( this . debugInfo )  {%NWL%ruleset . debugInfo = this . debugInfo ; %NWL%6
state . nameordesc = $ (  " #searchFormText "  )  . val (  )  ; %NWL%state . asname = $ (  " #asname "  )  . val (  )  ; %NWL%state . asdescription = $ (  " #asdescription "  )  . val (  )  ; %NWL%state . aspriority = $ (  " #aspriority "  )  . val (  )  ; %NWL%state . asauthor = $ (  " #asauthor "  )  . val (  )  ; %NWL%state . bugid = $ (  " #bugid "  )  . val (  )  ; %NWL%state . addedversion = $ (  " #addedversion "  )  . val (  )  ; %NWL%state . astype = $ (  " #astype "  )  . val (  )  ; %NWL%state . asfolder = $ (  " #asfolder "  )  . val (  )  ; %NWL%state . asauto = $ (  " #asauto "  )  . val (  )  ; %NWL%state . asproduct = $ (  " #asproduct "  )  . val (  )  ; %NWL%1
exports . sed = common . wrap (  ' sed '  , _sed )  ; %NWL%var _grep = require (  '  .  / src / grep '  )  ; %NWL%exports . grep = common . wrap (  ' grep '  , _grep )  ; %NWL%var _which = require (  '  .  / src / which '  )  ; %NWL%exports . which = common . wrap (  ' which '  , _which )  ; %NWL%var _echo = require (  '  .  / src / echo '  )  ; %NWL%exports . echo = _echo ;  /  / don ' t common . wrap (  ) as it could parse '  - options '%NWL%var _dirs = require (  '  .  / src / dirs '  )  . dirs ; %NWL%exports . dirs = common . wrap (  " dirs "  , _dirs )  ; %NWL%var _pushd = require (  '  .  / src / dirs '  )  . pushd ; %NWL%exports . pushd = common . wrap (  ' pushd '  , _pushd )  ; %NWL%0
}%NWL%var setter = createUniformSetter ( info )  ; %NWL%uniforms [ name ]  = setter ; %NWL%if ( info . type =  = gl . SAMPLER_2D || info . type =  = gl . SAMPLER_CUBE )  {%NWL%textures [ name ]  = setter ;%NWL%}%NWL%}%NWL%that . textures = textures ; %NWL%that . attrib = attribs ; %NWL%that . attribLoc = attribLocs ; %NWL%that . uniform = uniforms ; %NWL%8
nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%nl . lang . value = dom . getAttrib ( n ,  ' lang '  )  ; %NWL%nl . usemap . value = dom . getAttrib ( n ,  ' usemap '  )  ; %NWL%nl . longdesc . value = dom . getAttrib ( n ,  ' longdesc '  )  ; %NWL%5
}%NWL%if ( requestSettings . dataType =  =  ' json ' && ( typeof mockHandler . responseText =  =  ' object '  )  )  {%NWL%this . responseText = JSON . stringify ( mockHandler . responseText )  ;%NWL%} else if ( requestSettings . dataType =  =  ' xml '  )  {%NWL%if ( typeof mockHandler . responseXML =  =  ' string '  )  {%NWL%this . responseXML = parseXML ( mockHandler . responseXML )  ;%NWL%} else {%NWL%this . responseXML = mockHandler . responseXML ;%NWL%}%NWL%} else {%NWL%this . responseText = mockHandler . responseText ; %NWL%7
}%NWL%if ( height < 0 || height > 255 )  {%NWL%throw (  ' Invalid height ; must be in the range 0 .  . 255 '  )  ;%NWL%}%NWL%if ( textureImage . width ! = 256 ||%NWL%textureImage . height ! = 256 )  {%NWL%throw (  ' Invalid texture dimensions ; must be 256x256 '  )  ;%NWL%}%NWL%var textureCanvas  = document . createElement (  ' canvas '  )  ; %NWL%textureCanvas . width  = textureImage . width ; %NWL%textureCanvas . height = textureImage . height ; %NWL%9
fill = dojox . gfx . makeParameters ( dojox . gfx . defaultLinearGradient , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeX "  )  {%NWL%var span = dim . height - offsets . t - offsets . b ; %NWL%fill . y1 = offsets . t + span * fill . y1 / 100 ; %NWL%fill . y2 = offsets . t + span * fill . y2 / 100 ;%NWL%}%NWL%if ( space =  =  =  " plot " || space =  =  =  " shapeY "  )  {%NWL%var span = dim . width - offsets . l - offsets . r ; %NWL%fill . x1 = offsets . l + span * fill . x1 / 100 ; %NWL%fill . x2 = offsets . l + span * fill . x2 / 100 ; %NWL%9
for ( i = 0 ; i < activeObjects . length ; i +  = 1 )  {%NWL%curObject = activeObjects [ i ]  ; %NWL%if ( curObject . type =  =  =  ' dialog '  )  {%NWL%entityX = curObject . x - MapSurface . x +  ( curObject . w / 2 )  -  ( curObject . sprite . w / 2 )  ; %NWL%entityY = curObject . y - MapSurface . y - curObject . sprite . h +  ( 5 * Math . cos ( Scene . ticker . currentTick / 8 . 0 )  )  ; %NWL%curObject . sprite . position ( entityX , entityY )  ; %NWL%curObject . sprite . canvasUpdate ( MapSurface . front )  ;%NWL%} else if ( curObject . type =  =  =  ' entity '  )  {%NWL%if ( SpriteJS . Map . collides ( curObject . x + 24 , curObject . y + 24 )  )  {%NWL%curObject . xv =  - curObject . xv ; %NWL%curObject . yv =  - curObject . yv ; %NWL%9
if ( session . selection . inMultiSelectMode )%NWL%this . $onMultiSelect (  )  ; %NWL%else%NWL%this . $onSingleSelect (  )  ;%NWL%}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%editor . $onMultiSelect = editor . $onMultiSelect . bind ( editor )  ; %NWL%editor . $onSingleSelect = editor . $onSingleSelect . bind ( editor )  ; %NWL%7
this . $onMultiSelect (  )  ; %NWL%else%NWL%this . $onSingleSelect (  )  ;%NWL%}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%if ( editor . $multiselectOnSessionChange )%NWL%return ; %NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%editor . $onMultiSelect = editor . $onMultiSelect . bind ( editor )  ; %NWL%8
if ( queryParam (  ' sumSeries '  ) ! = null )  {%NWL%config . sumSeries = queryParam (  ' sumSeries '  )  ;%NWL%}%NWL%if ( queryParam (  ' defaultLineWidth '  ) ! = null )  {%NWL%config . defaultLineWidth = queryParam (  ' defaultLineWidth '  )  ;%NWL%}%NWL%if ( queryParam (  ' defaultParameters '  ) ! = null )  {%NWL%config . defaultParameters = queryParam (  ' defaultParameters '  )  ;%NWL%}%NWL%if ( queryParam (  ' slideshow '  ) ! = null )  {%NWL%config . slideshow = queryParam (  ' slideshow '  )  ; %NWL%1
render = true ; %NWL%ret . dimensions = app . flags . fluid . output ( flag )  ; %NWL%ret . fluid = true ;%NWL%} else if ( app . flags . colors . match ( flag )  )  {%NWL%ret . theme = app . flags . colors . output ( flag )  ;%NWL%} else if ( options . themes [ flag ]  )  {%NWL%ret . theme = options . themes [ flag ]  ;%NWL%} else if ( app . flags . text . match ( flag )  )  {%NWL%ret . text = app . flags . text . output ( flag )  ;%NWL%} else if ( app . flags . font . match ( flag )  )  {%NWL%ret . font = app . flags . font . output ( flag )  ; %NWL%8
this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if ( this . debug )%NWL%this . log = console . error%NWL%this . silent = !!options . silent%NWL%0
this . setSTream = function setStream ( s )  {%NWL%options . stream = s ;%NWL%}  ; %NWL%var __bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ; %NWL%var TapInterface =  ( function (  )  {%NWL%function TapInterface (  )  {%NWL%this . genOutput_ = __bind ( this . genOutput_ , this )  ; %NWL%this . testCount = __bind ( this . testCount , this )  ; %NWL%this . bailOut = __bind ( this . bailOut , this )  ; %NWL%this . skip = __bind ( this . skip , this )  ; %NWL%this . notOk = __bind ( this . notOk , this )  ; %NWL%6
var bindAll = require (  ' lib / bind - all '  )  ; %NWL%module . exports = function ( options )  { return new ConfirmController ( options )  ;  }  ; %NWL%module . exports . ConfirmController = ConfirmController ; %NWL%function ConfirmController ( app )  {%NWL%this . app = app ; %NWL%this . settings = app . settings ; %NWL%this . activity = app . activity ; %NWL%this . camera = app . camera ; %NWL%this . container = app . el ; %NWL%this . ConfirmView = app . ConfirmView || ConfirmView ; %NWL%this . prepareBlob = app . prepareBlob || prepareBlob ; %NWL%9
var num_lines_d = 15 ; %NWL%assertEquals ( start_a , Debug . sourcePosition ( a )  )  ; %NWL%assertEquals ( start_b , Debug . sourcePosition ( b )  )  ; %NWL%assertEquals ( start_c , Debug . sourcePosition ( c )  )  ; %NWL%assertEquals ( start_d , Debug . sourcePosition ( d )  )  ; %NWL%var script = Debug . findScript ( a )  ; %NWL%assertTrue ( script . data =  =  = Debug . findScript ( b )  . data )  ; %NWL%assertTrue ( script . data =  =  = Debug . findScript ( c )  . data )  ; %NWL%assertTrue ( script . data =  =  = Debug . findScript ( d )  . data )  ; %NWL%assertTrue ( script . source =  =  = Debug . findScript ( b )  . source )  ; %NWL%assertTrue ( script . source =  =  = Debug . findScript ( c )  . source )  ; %NWL%7
this . eventKeyDown = __bind ( this . eventKeyDown , this )  ; %NWL%this . clearAll = __bind ( this . clearAll , this )  ; %NWL%this . eventDeleteFileConfirmed = __bind ( this . eventDeleteFileConfirmed , this )  ; %NWL%this . eventRenameFile = __bind ( this . eventRenameFile , this )  ; %NWL%this . eventDeleteClicked = __bind ( this . eventDeleteClicked , this )  ; %NWL%this . eventMouseLeaveFile = __bind ( this . eventMouseLeaveFile , this )  ; %NWL%this . eventMouseEnterFile = __bind ( this . eventMouseEnterFile , this )  ; %NWL%this . eventSelectFile = __bind ( this . eventSelectFile , this )  ; %NWL%this . resetClicksOnFileList = __bind ( this . resetClicksOnFileList , this )  ; %NWL%this . setupConfirm = __bind ( this . setupConfirm , this )  ; %NWL%this . addOneRoute = __bind ( this . addOneRoute , this )  ; %NWL%0
Cartesian3 . multiplyByScalar ( up , t , normal )  ; %NWL%Cartesian3 . add ( nearCenter , normal , normal )  ; %NWL%Cartesian3 . subtract ( normal , position , normal )  ; %NWL%Cartesian3 . normalize ( normal , normal )  ; %NWL%Cartesian3 . cross ( normal , right , normal )  ; %NWL%plane = planes [ 3 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 3 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x = normal . x ; %NWL%plane . y = normal . y ; %NWL%9
fillerRange . setEnd ( lastRange . endContainer , lastRange . endOffset )  ; %NWL%return {%NWL%firstRange : firstRange ,%NWL%lastRange : lastRange ,%NWL%fillerRange : fillerRange%NWL%}  ;%NWL%}%NWL%function getBoundingRect ( rect1 , rect2 )  {%NWL%var resultRect =  {  }  ; %NWL%resultRect . top = Math . min ( rect1 . top , rect2 . top )  ; %NWL%resultRect . left = Math . min ( rect1 . left , rect2 . left )  ; %NWL%9
percent =  ( this . outerElement . value / parseInt ( this . outerElement . maxValue )  )  ;%NWL%}%NWL%xpos = Math . floor ( parseInt ( window . getComputedStyle ( this . outerElement . outer )  . width )  * percent )  ; %NWL%this . outerElement . fill . style . width = xpos +  ' px '  ;%NWL%}  ; %NWL%progress . setValue = progress . setValue . bind ( progress )  ; %NWL%progress . setState = function ( state )  {%NWL%this . outerElement . state = state ; %NWL%this . setValue (  )  ;%NWL%}  ; %NWL%progress . setState = progress . setState . bind ( progress )  ; %NWL%5
this . _events [ type ]  = true ; %NWL%AttributeProvider . prototype . createEvent . apply ( this , arguments )  ;%NWL%}  ,%NWL%init : function ( el , attr )  {%NWL%_initElement . apply ( this , arguments )  ;%NWL%}%NWL%}  ; %NWL%var _initElement = function ( el , attr )  {%NWL%this . _queue = this . _queue || [  ]  ; %NWL%this . _events = this . _events || {  }  ; %NWL%this . _configs = this . _configs || {  }  ; %NWL%9
' Geeno was here! '  , 5 ,  ' ABCDEFGHIJKLMNPQRSTUVWXYZ '  )  ,%NWL%PARTIALS =  {  }  ,%NWL%helpers = require (  '  .  / handlebars . helpers . js '  )  ,%NWL%handler , tpl , fetchJson ; %NWL%module . exports = http ; %NWL%helpers . precompile = function (  )  {%NWL%}  ; %NWL%helpers . partial = function ( partialName , partialObj )  {%NWL%PARTIALS [ partialName ]  = partialObj . fn ;%NWL%}  ; %NWL%helpers . block = function ( blockName , blockObj )  {%NWL%7
}  ,%NWL%createProxy : function (  )  {%NWL%var proxy = safe . proxy = carena . build (  {  }  ,  [%NWL%" carena . Node "  ,%NWL%" carena . Eventable "  ,%NWL%" carena . Draggable "  ,%NWL%]  )  ; %NWL%proxy . x   = obj . x ; %NWL%proxy . y   = obj . y ; %NWL%proxy . width  = obj . width ; %NWL%proxy . height = obj . height ; %NWL%7
var auth = getAuth (  )  ; %NWL%data = data || this . toJSON (  )  ; %NWL%this . set (  ' title '  , auth . encrypt ( data . title )  )  ; %NWL%this . set (  ' content '  , auth . encrypt ( data . content )  )  ; %NWL%this . set (  ' synchronized '  , 0 )  ;%NWL%}  ,%NWL%decrypt : function (  )  {%NWL%var data = this . toJSON (  )  ,%NWL%auth = getAuth (  )  ; %NWL%data . title = auth . decrypt ( data . title )  ; %NWL%data . content = auth . decrypt ( data . content )  ; %NWL%9
height : 24 ,%NWL%shape :  " rect "  ,%NWL%padding :  {%NWL%top : 0 ,%NWL%left : 0 ,%NWL%right : 0 ,%NWL%bottom : 0%NWL%}%NWL%}  ; %NWL%defs . fill . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " fill "  )  ; %NWL%defs . border . color = this . _getDefaultColor ( this . get (  " graphOrder "  )  ,  " border "  )  ; %NWL%9
var params = stmt . newBindingParamsArray (  )  ,%NWL%binding = params . newBindingParams (  )  ; %NWL%binding . bindByName (  " uuid "  , uuid )  ; %NWL%params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%request . requestUrl = stmt . row . requestUrl ; %NWL%7
var out =  {  }  , i ; %NWL%for ( i = 0 ; i < filter . length ; i +  +  )  {%NWL%if ( src [ filter [ i ]  ] ! =  = undefined )  {%NWL%out [ filter [ i ]  ]  = src [ filter [ i ]  ]  ;%NWL%}%NWL%}%NWL%return out ;%NWL%}%NWL%}  ; %NWL%sjcl . encrypt = sjcl . json . encrypt ; %NWL%sjcl . decrypt = sjcl . json . decrypt ; %NWL%9
this . offsetY =  ( goog . userAgent . WEBKIT || e . offsetY ! =  = undefined ) ?%NWL%e . offsetY : e . layerY ; %NWL%this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ;%NWL%}%NWL%this . button = e . button ; %NWL%this . keyCode = e . keyCode || 0 ; %NWL%this . charCode = e . charCode || ( type =  =  ' keypress ' ? e . keyCode : 0 )  ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%7
this . setOptions (  )  ;%NWL%}%NWL%GaugePointer . prototype . setOptions = function ( options )  {%NWL%if ( options =  = null )  {%NWL%options = null ;%NWL%}%NWL%updateObjectValues ( this . options , options )  ; %NWL%this . length = this . canvas . height * this . options . length ; %NWL%this . strokeWidth = this . canvas . height * this . options . strokeWidth ; %NWL%this . maxValue = this . gauge . maxValue ; %NWL%this . minValue = this . gauge . minValue ; %NWL%9
this . lights =  [  ]  ; %NWL%for ( var i = 0 ; i < lights . length ;  +  + i )  {%NWL%var l = lights [ i ]  ; %NWL%this . lights . push (  { direction : lite . normalize ( l . direction )  , color : lite . toStdColor ( l . color )  }  )  ;%NWL%}%NWL%this . ambient = lite . toStdColor ( ambient . color ? ambient . color :  " white "  )  ; %NWL%this . ambient = lite . scaleColor ( ambient . intensity , this . ambient )  ; %NWL%this . ambient = lite . scaleColor ( this . ambient . a , this . ambient )  ; %NWL%this . ambient . a = 1 ; %NWL%this . specular = lite . toStdColor ( specular ? specular :  " white "  )  ; %NWL%this . specular = lite . scaleColor ( this . specular . a , this . specular )  ; %NWL%7
var blockCount = this . blocked . length ; %NWL%for ( var i = 0 ; i < blockCount ;  +  + i )  {%NWL%if ( possibleBlocks . indexOf ( this . blocked [ i ]  )  < 0 ) return false ; %NWL%possibleBlocks . splice ( this . blocked [ i ]  , 1 )  ;%NWL%}%NWL%}%NWL%return true ;%NWL%}  ; %NWL%Item . prototype . copy = function ( item )  {%NWL%this . type = item . type ; %NWL%this . value = item . value ; %NWL%9
inputEx . JsonSchema . Builder = function ( opts )  {%NWL%var options = opts || {  }  ; %NWL%this . options  = options ; %NWL%this . schemaToParamMap = options . schemaToParamMap || {%NWL%' title '  :  ' label '  ,%NWL%' description '  :  ' description '  ,%NWL%' _inputex '  : null	 /  / null value means copy child key / value pairs into field options directly%NWL%}  ; %NWL%this . referenceResolver = options . referenceResolver || null ; %NWL%this . defaultOptions = options . defaultOptions || {  }  ; %NWL%this . schemaIdentifierMap = options . schemaIdentifierMap || {  }  ; %NWL%9
addCustomOperation ( localElem )  ; %NWL%return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . putElement = _ . bind ( putElementFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%7
hpl . update_convolver (  )  ; %NWL%hpl . play_source (  )  ; %NWL%setTimeout ( rotate , 2000 )  ;%NWL%}%NWL%rotate (  )  ;%NWL%}%NWL%}%NWL%var mouse_move = function ( e )  {%NWL%if ( !isNaN ( e . theta ) && !isNaN ( e . phi ) && ( e . theta ! = hpl . theta || e . phi ! = hpl . phi )  )  {%NWL%hpl . theta = e . theta ; %NWL%hpl . phi = e . phi ; %NWL%9
if ( !this . _transitions . hasOwnProperty ( leaveState )  )%NWL%this . _transitions [ leaveState ]  =  {  }%NWL%data . callbacks = this . _collectMethods (  ( data . callbacks || [  ]  )  )%NWL%this . _transitions [ leaveState ]  [ event ]  = data%NWL%}  ,%NWL%state : function ( name , data )  {%NWL%if ( name =  =  = ANY_STATE )%NWL%throw new Error (  ' state name "  '  + ANY_STATE +  '  " is forbidden '  )%NWL%data = _ . clone ( data )%NWL%data . enter = this . _collectMethods (  ( data . enter || [  ]  )  )%NWL%data . leave = this . _collectMethods (  ( data . leave || [  ]  )  )%NWL%2
if ( this . filename && options . nodeWebkitAppName )  {%NWL%console . log (  "  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  "  )  ; %NWL%console . log (  " WARNING : The nodeWebkitAppName option is deprecated "  )  ; %NWL%console . log (  " To get the path to the directory where Node Webkit stores the data "  )  ; %NWL%console . log (  " for your app , use the internal nw . gui module like this "  )  ; %NWL%console . log (  " require (  ' nw . gui '  )  . App . dataPath "  )  ; %NWL%console . log (  " See https :  /  / github . com / rogerwang / node - webkit / issues / 500 "  )  ; %NWL%console . log (  "  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  "  )  ; %NWL%this . filename = Persistence . getNWAppFilename ( options . nodeWebkitAppName , this . filename )  ; %NWL%this . tempFilename = Persistence . getNWAppFilename ( options . nodeWebkitAppName , this . tempFilename )  ; %NWL%this . oldFilename = Persistence . getNWAppFilename ( options . nodeWebkitAppName , this . oldFilename )  ; %NWL%8
fill = dojox . gfx . makeParameters ( dojox . gfx . defaultPattern , fill )  ; %NWL%fill . space = space ; %NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeX "  )  {%NWL%var span = bbox . width ; %NWL%fill . x = bbox . x + span * fill . x / 100 ; %NWL%fill . width = span * fill . width / 100 ;%NWL%}%NWL%if ( space =  =  =  " shape " || space =  =  =  " shapeY "  )  {%NWL%var span = bbox . height ; %NWL%fill . y = bbox . y + span * fill . y / 100 ; %NWL%fill . height = span * fill . height / 100 ; %NWL%5
this . parent . parentNode . replaceChild ( this . swapped , this . parent )  ;%NWL%}%NWL%}  ,%NWL%render : function ( context , buffer )  {%NWL%this . parent = buffer . getParent (  )  ; %NWL%if ( this . options . node )  {%NWL%this . onAddNode = dojo . connect ( buffer ,  " onAddNode "  , dojo . hitch ( this ,  " _swap "  ,  " node "  )  )  ; %NWL%this . onRemoveNode = dojo . connect ( buffer ,  " onRemoveNode "  , dojo . hitch ( this ,  " _swap "  ,  " node "  )  )  ;%NWL%}%NWL%if ( this . options . text )  {%NWL%this . onChangeData = dojo . connect ( buffer ,  " onChangeData "  , dojo . hitch ( this ,  " _swap "  ,  " node "  )  )  ; %NWL%6
this . invI2e10 = tmpI [ 3 ]  ; %NWL%this . invI2e11 = tmpI [ 4 ]  ; %NWL%this . invI2e12 = tmpI [ 5 ]  ; %NWL%this . invI2e20 = tmpI [ 6 ]  ; %NWL%this . invI2e21 = tmpI [ 7 ]  ; %NWL%this . invI2e22 = tmpI [ 8 ]  ; %NWL%this . id . data1 = contactInfo . id . data1 ; %NWL%this . id . data2 = contactInfo . id . data2 ; %NWL%this . id . flip = contactInfo . id . flip ; %NWL%this . friction = this . shape1 . friction * this . shape2 . friction ; %NWL%this . restitution = this . shape1 . restitution * this . shape2 . restitution ; %NWL%9
if (  ( typeof locale =  =  ' number ' || typeof locale =  =  ' string '  ) && timezone =  = null )  {%NWL%timezone = locale ; %NWL%locale = undefined ;%NWL%}%NWL%return _strftime ( fmt , d , locale ,  { timezone : timezone }  )  ;%NWL%}%NWL%namespace . strftimeUTC = strftime . strftimeUTC = strftimeUTC ; %NWL%function strftimeUTC ( fmt , d , locale )  {%NWL%return _strftime ( fmt , d , locale ,  { utc : true }  )  ;%NWL%}%NWL%namespace . localizedStrftime = strftime . localizedStrftime = localizedStrftime ; %NWL%6
container . appendChild ( nums )  ; %NWL%scroller . className =  " CodeMirror - line - numbers "  ; %NWL%nums . appendChild ( scroller )  ; %NWL%scroller . innerHTML =  "  < div >  "  + firstNum +  "  <  / div >  "  ; %NWL%return nums ;%NWL%}%NWL%function frameHTML ( options )  {%NWL%if ( typeof options . parserfile =  =  " string "  )%NWL%options . parserfile =  [ options . parserfile ]  ; %NWL%if ( typeof options . basefiles =  =  " string "  )%NWL%options . basefiles =  [ options . basefiles ]  ; %NWL%8
this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%this . query = options . query || '  '  ; %NWL%this . endpoint = options . endpoint || " https :  /  / spreadsheets . google . com "  ; %NWL%this . singleton = !!options . singleton ; %NWL%3
focusManager . addUI ( this )  ; %NWL%return this ;%NWL%}  ; %NWL%HomescreenWindow . prototype = Object . create ( AppWindow . prototype )  ; %NWL%HomescreenWindow . prototype . _DEBUG = false ; %NWL%HomescreenWindow . prototype . CLASS_NAME =  ' HomescreenWindow '  ; %NWL%HomescreenWindow . prototype . setBrowserConfig =%NWL%function hw_setBrowserConfig ( manifestURL )  {%NWL%var app = window . applications . getByManifestURL ( manifestURL )  ; %NWL%this . origin = app . origin ; %NWL%this . manifestURL = app . manifestURL ; %NWL%9
if ( filter . description ! =  = undefined && filter . description ! =  = null )  {%NWL%filter . description = String ( filter . description )  ;%NWL%} else {%NWL%filter . description = undefined ;%NWL%}%NWL%if ( filter . location ! =  = undefined && filter . location ! =  = null )  {%NWL%filter . location = String ( filter . location )  ;%NWL%} else {%NWL%filter . location = undefined ;%NWL%}%NWL%if ( filter . catetory ! =  = undefined && filter . catetory ! =  = null )  {%NWL%0
if ( !PIXI . defaultRenderer )%NWL%{%NWL%PIXI . sayHello (  ' webGL '  )  ; %NWL%PIXI . defaultRenderer = this ;%NWL%}%NWL%this . type = PIXI . WEBGL_RENDERER ; %NWL%this . resolution = options . resolution ; %NWL%this . transparent = options . transparent ; %NWL%this . autoResize = options . autoResize || false ; %NWL%this . preserveDrawingBuffer = options . preserveDrawingBuffer ; %NWL%this . clearBeforeRender = options . clearBeforeRender ; %NWL%6
}  )  ;%NWL%}  )  ; %NWL%function benchmark ( description , fn )  {%NWL%it ( description , function ( cb )  {%NWL%var self = this ; %NWL%var startedAt = self . microtime . now (  )  ; %NWL%fn . apply ( this ,  [ function _callback (  )  {%NWL%var _result =  {  }  ; %NWL%_result . expected = self . expected ; %NWL%self . expected = null ; %NWL%_result . comment = self . comment ; %NWL%8
require (  ' stack . io '  )  . io (  { host : config . host , timeout : 15 }  , function ( err , io )  {%NWL%config . ready ( function ( config )  {%NWL%self . auth = require (  ' auth '  )  ( config , io )  ; %NWL%if ( config . modules . DB_ENABLED )  {%NWL%self . db = require (  ' db '  )  ( config , io )  ;%NWL%}%NWL%if ( config . modules . SYNC_ENABLED )  {%NWL%self . sync = require (  ' sync '  )  ( config , io )  ;%NWL%}%NWL%if ( config . modules . TWITTER_ENABLED )  {%NWL%self . twitter = require (  ' twitter '  )  ( config , io )  ; %NWL%2
}%NWL%var vec4  = new Vector4 (  )  ; %NWL%var matrix = new Matrix4 (  )  ; %NWL%vec4 . setFrom ( vector )  ; %NWL%Matrix4 . multiply ( this . _projectionMatrix , this . _viewMatrix , matrix )  ; %NWL%matrix . inverse (  )  ; %NWL%vec4 . x =  ( vec4 . x - this . viewRect . x )  / this . viewRect . width ; %NWL%vec4 . y =  ( vec4 . y - this . viewRect . y )  / this . viewRect . height ; %NWL%vec4 . x = vec4 . x * 2 - 1 ; %NWL%vec4 . y = vec4 . y * 2 - 1 ; %NWL%vec4 . z = vec4 . z * 2 - 1 ; %NWL%8
{%NWL%out . a = 1 ; %NWL%return Phaser . Color . hexToColor ( value , out )  ;%NWL%}%NWL%}%NWL%else if ( typeof value =  =  =  ' number '  )%NWL%{%NWL%var tempColor = Phaser . Color . getRGB ( value )  ; %NWL%out . r = tempColor . r ; %NWL%out . g = tempColor . g ; %NWL%out . b = tempColor . b ; %NWL%9
}  ; %NWL%cc . V3F_C4B_T2F_Quad . BYTES_PER_ELEMENT = 96 ; %NWL%Object . defineProperties ( cc . V3F_C4B_T2F_Quad . prototype ,  {%NWL%tl :  {%NWL%get : function (  )  {%NWL%return this . _tl ;%NWL%}  ,%NWL%set : function ( tlValue )  {%NWL%var locTl = this . _tl ; %NWL%locTl . vertices = tlValue . vertices ; %NWL%locTl . colors = tlValue . colors ; %NWL%9
this . pageContainer = doc . createElement (  " div "  )  ; %NWL%this . scrollBorder  =  { x : 0 , y : 0 }  ; %NWL%this . page    = 0 ; %NWL%this . preventScroll = false ; %NWL%this . pageCssProperties =  {%NWL%margin : 0%NWL%}  ; %NWL%this . _onStart = proxy ( this . _onStart , this )  ; %NWL%this . _onMove = proxy ( this . _onMove , this )  ; %NWL%this . _onEnd = proxy ( this . _onEnd , this )  ; %NWL%this . _onKeydown = proxy ( this . _onKeydown , this )  ; %NWL%7
}%NWL%}%NWL%}%NWL%Vizi . PickManager . handleTouchMove = function ( event )%NWL%{%NWL%if ( event . touches . length > 0 )  {%NWL%event . screenX = event . touches [ 0 ]  . screenX ; %NWL%event . screenY = event . touches [ 0 ]  . screenY ; %NWL%event . clientX = event . touches [ 0 ]  . clientX ; %NWL%event . clientY = event . touches [ 0 ]  . clientY ; %NWL%event . pageX = event . touches [ 0 ]  . pageX ; %NWL%6
nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%0
onFailure (  )  ;%NWL%}  )  ;%NWL%}%NWL%function _getFeedItemFromXml ( xml )  {%NWL%var newFeedItem =  {  }  ,%NWL%searchableXml = angular . element ( xml )  ; %NWL%newFeedItem . guid = searchableXml . find (  ' guid '  )  . text (  )  ; %NWL%newFeedItem . title = searchableXml . find (  ' title '  )  . text (  )  ; %NWL%newFeedItem . link = searchableXml . find (  ' link '  )  . text (  )  ; %NWL%newFeedItem . date = Date . parse ( searchableXml . find (  ' pubDate '  )  . text (  )  )  ; %NWL%newFeedItem . description = searchableXml . find (  ' description '  )  . text (  )  ; %NWL%6
function saveDataPoint ( name , duration )  {%NWL%var functionData  = report [ name ]  ; %NWL%if ( !functionData )  {%NWL%functionData = createReport ( name )  ;%NWL%}%NWL%functionData . calls +  +  ; %NWL%functionData . points . push ( duration )  ; %NWL%if ( functionData . calls > 1 )  {%NWL%functionData . avg =  (  ( functionData . avg *  ( functionData . calls - 1 )  )  + duration )  / functionData . calls ; %NWL%functionData . min = Math . min ( functionData . min , duration )  ; %NWL%functionData . max = Math . max ( functionData . max , duration )  ; %NWL%9
return this . _parser . execute ( d . _nettyBuffer (  )  )  ;%NWL%}%NWL%HTTPParser . prototype . finish = function (  )  {%NWL%this . _parser . finish (  )  ;%NWL%}%NWL%HTTPParser . kOnHeaders = 0 ; %NWL%HTTPParser . kOnHeadersComplete = 1 ; %NWL%HTTPParser . kOnBody = 2 ; %NWL%HTTPParser . kOnMessageComplete = 3 ; %NWL%HTTPParser . REQUEST  = io . nodyn . http . HTTPParser . REQUEST ; %NWL%HTTPParser . RESPONSE = io . nodyn . http . HTTPParser . RESPONSE ; %NWL%9
air . URLRequestHeader = window . runtime . flash . net . URLRequestHeader ; %NWL%air . URLRequestMethod = window . runtime . flash . net . URLRequestMethod ; %NWL%air . URLStream = window . runtime . flash . net . URLStream ; %NWL%air . URLVariables = window . runtime . flash . net . URLVariables ; %NWL%air . Socket = window . runtime . flash . net . Socket ; %NWL%air . XMLSocket = window . runtime . flash . net . XMLSocket ; %NWL%air . Responder = window . runtime . flash . net . Responder ; %NWL%air . ObjectEncoding = window . runtime . flash . net . ObjectEncoding ; %NWL%air . NetStream = window . runtime . flash . net . NetStream ; %NWL%air . NetStreamInfo = window . runtime . flash . net . NetStreamInfo ; %NWL%air . NetStreamPlayOptions = window . runtime . flash . net . NetStreamPlayOptions ; %NWL%0
if ( typeof arg0 =  =  " number "  )  {  /  / this is time " valueof "%NWL%arg0 = new Date ( arg0 )  ;%NWL%}%NWL%if ( arg0 instanceof Date )  {%NWL%this . fromGregorian ( arg0 )  ;%NWL%} else if ( arg0 =  =  "  "  )  {%NWL%this . _date = new Date (  "  "  )  ;  /  / TODO : should this be NaN? _date is not a Date object%NWL%} else {  /  / this is hebrew . Date object%NWL%this . _year = arg0 . _year ; %NWL%this . _month =  arg0 . _month ; %NWL%this . _date = arg0 . _date ; %NWL%8
}%NWL%PropertyDescriptor . prototype . update = function update ( pd )%NWL%{%NWL%if (  " get " in pd )%NWL%this . get = pd . get ; %NWL%if (  " set " in pd )%NWL%this . set = pd . set ; %NWL%if (  " configurable " in pd )%NWL%this . configurable = pd . configurable ; %NWL%if (  " writable " in pd )%NWL%this . writable = pd . writable ; %NWL%4
getSuspensionStiffness : function (  )  {%NWL%return this . suspensionStiffness ;%NWL%}  ,%NWL%setSuspensionRest : function ( suspensionRest_in )  {%NWL%this . suspensionRest = suspensionRest_in ;%NWL%}  ,%NWL%getSuspensionRest : function (  )  {%NWL%return this . suspensionRest ;%NWL%}  ,%NWL%setDampingRelaxation : function ( dampingRelaxation_in )  {%NWL%this . dampingRelaxation = dampingRelaxation_in ; %NWL%4
import . Point ; %NWL%exports = Class ( function (  )  {%NWL%this . init = function ( a , b , c , d )  {%NWL%switch ( arguments . length )  {%NWL%case 0 : %NWL%this . start = new Point (  )  ; %NWL%this . end = new Point (  )  ; %NWL%break ; %NWL%case 1 : %NWL%this . start = new Point ( a . start )  ; %NWL%this . end = new Point ( a . end )  ; %NWL%9
return out ;%NWL%}%NWL%}  ; %NWL%Step =  ( function ( _super )  {%NWL%__extends ( Step , _super )  ; %NWL%function Step ( shepherd , options )  {%NWL%this . shepherd = shepherd ; %NWL%this . destroy = __bind ( this . destroy , this )  ; %NWL%this . scrollTo = __bind ( this . scrollTo , this )  ; %NWL%this . complete = __bind ( this . complete , this )  ; %NWL%this . cancel = __bind ( this . cancel , this )  ; %NWL%7
if ( promise . isCancelled )  {%NWL%opts . complete ( null ,  { status :  ' cancelled '  }  )  ;%NWL%} else {%NWL%fun ( self , opts , promise )  ;%NWL%}%NWL%}  )  ;%NWL%} else {%NWL%fun ( self , opts , promise )  ;%NWL%}%NWL%promise . on = emitter . on . bind ( emitter )  ; %NWL%promise . once = emitter . once . bind ( emitter )  ; %NWL%9
exports . ConnectionStringParser = azureCommon . ConnectionStringParser ; %NWL%exports . Logger = azureCommon . Logger ; %NWL%exports . WebResource = azureCommon . WebResource ; %NWL%exports . Validate = azureCommon . validate ; %NWL%exports . date = azureCommon . date ; %NWL%exports . ServiceSettings = azureCommon . ServiceSettings ; %NWL%exports . ServiceBusSettings = azureCommon . ServiceBusSettings ; %NWL%exports . ServiceManagementSettings = azureCommon . ServiceManagementSettings ; %NWL%exports . StorageServiceSettings = azureCommon . StorageServiceSettings ; %NWL%exports . CertificateCloudCredentials = azureCommon . CertificateCloudCredentials ; %NWL%exports . TokenCloudCredentials = azureCommon . TokenCloudCredentials ; %NWL%0
testLine +  =  ' not '  ;%NWL%}%NWL%testLine +  =  (  ' ok '  + tap . count )  ; %NWL%tap . puts ( formatTestLine ( testLine , formatDetails ( details )  )  )  ;%NWL%}  ; %NWL%tap . testDone = function testDone (  )  {%NWL%if ( isPlanRequired ( qu . config )  )  {%NWL%tap . expectedCount +  = qu . config . current . expected ;%NWL%}%NWL%}  ; %NWL%tap . done = function done (  )  {%NWL%5
divideFactor : function ( c1 , f )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red / f ; %NWL%result . green = c1 . green / f ; %NWL%result . blue = c1 . blue / f ; %NWL%return result ;%NWL%}  ,%NWL%limit : function (  )  {%NWL%this . red =  ( this . red > 0 . 0 ) ? (  ( this . red > 1 . 0 ) ? 1 . 0 : this . red )  : 0 . 0 ; %NWL%this . green =  ( this . green > 0 . 0 ) ? (  ( this . green > 1 . 0 ) ? 1 . 0 : this . green )  : 0 . 0 ; %NWL%this . blue =  ( this . blue > 0 . 0 ) ? (  ( this . blue > 1 . 0 ) ? 1 . 0 : this . blue )  : 0 . 0 ; %NWL%8
this . fireEvent (  " featuremodified "  , this , feature )  ;%NWL%} else if ( feature . state =  =  = OpenLayers . State . INSERT )  {%NWL%this . editing = false ; %NWL%feature . layer && feature . layer . destroyFeatures (  [ feature ]  )  ; %NWL%this . fireEvent (  " canceledit "  , this , null )  ; %NWL%this . close (  )  ;%NWL%} else {%NWL%var layer = feature . layer ; %NWL%layer . drawFeature ( feature ,  { display :  " none "  }  )  ; %NWL%feature . geometry = this . geometry ; %NWL%feature . attributes = this . attributes ; %NWL%9
"  .  / models / buffer_queue "  ]  ,%NWL%function ( chime , dc , noise , probe , mic , spectrum , load_sample , sample , jsnode , buffer_queue )  {%NWL%return function maker ( S , sh )  {%NWL%var models = sh . models || ( sh . models =  {  }  )  ; %NWL%models . chime = chime ( S , sh )  ; %NWL%models . dc = dc ( S , sh )  ; %NWL%models . noise = noise ( S , sh )  ; %NWL%models . probe = probe ( S , sh )  ; %NWL%models . mic = mic ( S , sh )  ; %NWL%models . spectrum = spectrum ( S , sh )  ; %NWL%models . load_sample = load_sample ( S , sh )  ; %NWL%4
}  )  ; %NWL%Thoth . SocketIO = require ( corePath +  '  / SocketIO '  )  . SocketIO ; %NWL%Thoth . UserCache = require ( corePath +  '  / UserCache '  )  . UserCache ; %NWL%Thoth . Auth = require ( corePath +  '  / Auth '  )  . Auth ; %NWL%Thoth . FileAuth = require ( libPath +  '  / FileAuth '  )  . FileAuth ; %NWL%Thoth . Session = require ( corePath +  '  / Session '  )  . Session ; %NWL%Thoth . Store = require ( corePath +  '  / Store '  )  . Store ; %NWL%Thoth . WrapperStore = require ( corePath +  '  / WrapperStore '  )  . WrapperStore ; %NWL%Thoth . ApplicationStore = require ( corePath +  '  / ApplicationStore '  )  . ApplicationStore ; %NWL%Thoth . MemStore = require ( corePath +  '  / MemStore '  )  . MemStore ; %NWL%Thoth . DiskStore = require ( corePath +  '  / DiskStore '  )  . DiskStore ; %NWL%1
result . outlineWidth = this . outlineWidth ; %NWL%result . show = this . show ; %NWL%result . scaleByDistance = this . scaleByDistance ; %NWL%return result ;%NWL%}  ; %NWL%PointGraphics . prototype . merge = function ( source )  {%NWL%if ( !defined ( source )  )  {%NWL%throw new DeveloperError (  ' source is required .  '  )  ;%NWL%}%NWL%this . color = defaultValue ( this . color , source . color )  ; %NWL%this . pixelSize = defaultValue ( this . pixelSize , source . pixelSize )  ; %NWL%9
}%NWL%MutationObserver . prototype . constructor = MutationObserver ; %NWL%MutationObserver . name =  ' MutationObserver '  ; %NWL%MutationRecord . prototype . constructor = MutationRecord ; %NWL%MutationRecord . name =  ' MutationRecord '  ; %NWL%function copyMutationRecord ( original )  {%NWL%var record = new MutationRecord ( original . type , original . target )  ; %NWL%record . addedNodes = original . addedNodes . slice (  )  ; %NWL%record . removedNodes = original . removedNodes . slice (  )  ; %NWL%record . previousSibling = original . previousSibling ; %NWL%record . nextSibling = original . nextSibling ; %NWL%9
return domEvents . cloneKeyboardEvent ( e )  ;%NWL%} else {%NWL%return domEvents . cloneCustomEvent ( e )  ;%NWL%}%NWL%}  ,%NWL%EventTarget :  {%NWL%implementsIn : function ( eventClass , static_class )  {%NWL%if ( !static_class && typeof ( eventClass )  =  =  " function "  ) eventClass = eventClass . prototype ; %NWL%eventClass . dispatchEvent = domEvents . EventTarget . prototype . dispatchEvent ; %NWL%eventClass . addEventListener = domEvents . EventTarget . prototype . addEventListener ; %NWL%eventClass . removeEventListener = domEvents . EventTarget . prototype . removeEventListener ; %NWL%8
' orion / git / util '  ,%NWL%' orion / Deferred '  ,%NWL%' orion / git / gitCommands '  ,%NWL%' orion / objects '%NWL%]  , function ( messages , mCommandRegistry , mExplorer , URITemplate , i18nUtil , uiUtil , util , Deferred , mGitCommands , objects )  {%NWL%var repoTemplate = new URITemplate (  " git / git - repository . html# {  , resource , params *  }  "  )  ;  /  / $NON - NLS - 0$%NWL%function GitRepoListModel ( options )  {%NWL%this . root = options . root ; %NWL%this . registry = options . registry ; %NWL%this . handleError = options . handleError ; %NWL%this . section = options . section ; %NWL%7
getJasmineRequire (  )  . core = function ( jRequire )  {%NWL%var j$ =  {  }  ; %NWL%jRequire . base ( j$ , jasmineGlobal )  ; %NWL%j$ . util = jRequire . util (  )  ; %NWL%j$ . errors = jRequire . errors (  )  ; %NWL%j$ . Any = jRequire . Any ( j$ )  ; %NWL%j$ . Anything = jRequire . Anything ( j$ )  ; %NWL%j$ . CallTracker = jRequire . CallTracker (  )  ; %NWL%j$ . MockDate = jRequire . MockDate (  )  ; %NWL%j$ . Clock = jRequire . Clock (  )  ; %NWL%j$ . DelayedFunctionScheduler = jRequire . DelayedFunctionScheduler (  )  ; %NWL%3
if ( mapping . source )  {%NWL%newMapping . source = mapping . source ; %NWL%if ( sourceRoot )  {%NWL%newMapping . source = util . relative ( sourceRoot , newMapping . source )  ;%NWL%}%NWL%newMapping . original =  {%NWL%line : mapping . originalLine ,%NWL%column : mapping . originalColumn%NWL%}  ; %NWL%if ( mapping . name )  {%NWL%newMapping . name = mapping . name ; %NWL%1
if ( objUser ! = null )  {%NWL%response . status = 200 ; %NWL%var userAgent = request . getHeader (  " User - Agent "  )  ; %NWL%var android = userAgent . indexOf (  " Android "  )  ; %NWL%if ( android > 0 )  {%NWL%print (  " 200 "  )  ;%NWL%} else {%NWL%var userFeed =  {  }  ; %NWL%userFeed . tenantId = stringify ( objUser [  " tenantId "  ]  )  ; %NWL%userFeed . username = objUser [  " username "  ]  ; %NWL%userFeed . email = objUser [  " email "  ]  ; %NWL%9
sc_assert ( size . width < 2048 ,  " `size . width` too big in SC . rendorToDataUrl :  "  + size . width )  ; %NWL%sc_assert ( size . height > 0 ,   " `size . height` too small in SC . rendorToDataUrl :  "  + size . height )  ; %NWL%sc_assert ( size . width < 2048 ,  " `size . height` too big in SC . rendorToDataUrl :  "  + size . height )  ; %NWL%sc_assert ( typeof type =  =  =  ' string '  ,  " `type` argument must be a string "  )  ; %NWL%sc_assert ( typeof renderFunction =  =  =  ' function '  ,  " `renderFunction` must be a function "  )  ; %NWL%var canvas = SC . _cachedCanvas ; %NWL%if ( !canvas )  {%NWL%canvas = SC . _cachedCanvas = document . createElement (  ' canvas '  )  ;%NWL%}%NWL%canvas . width = size . width ; %NWL%canvas . height = size . height ; %NWL%9
buildTemplateData_ ( component , data )  {%NWL%var newData =  {  }  ; %NWL%var attrNames = component . getAttrNames (  )  ; %NWL%for ( var i = 0 ; i < attrNames . length ; i +  +  )  {%NWL%var name = attrNames [ i ]  ; %NWL%if ( name ! =  =  ' element ' && !component . getAttrConfig ( name )  . isComponentsArray )  {%NWL%newData [ name ]  = component [ name ]  ;%NWL%}%NWL%}%NWL%newData . componentName = data . componentName ; %NWL%newData . children = data . children ; %NWL%9
Util ,%NWL%TextBox ,%NWL%Select ,%NWL%Button ,%NWL%TrackConfigEditor%NWL%)  {%NWL%var uniqCounter = 0 ; %NWL%return declare ( null ,  {%NWL%constructor : function ( args )  {%NWL%this . browser = args . browser ; %NWL%this . fileDialog = args . fileDialog ; %NWL%9
oAttribute . nodeType		 = 2 ; %NWL%oAttribute . ownerElement	 = oNode ; %NWL%oAttribute . ownerDocument = oNode . ownerDocument ; %NWL%oAttribute . specified	 = true ; %NWL%oAttribute . value		 =%NWL%oAttribute . nodeValue	 = oNode2 . nodeValue ; %NWL%oAttribute . name			 =%NWL%oAttribute . nodeName		 = oNode2 . nodeName ; %NWL%oAttribute . localName	 = oNode2 . baseName ; %NWL%oAttribute . prefix		 = oNode2 . prefix || null ; %NWL%oAttribute . namespaceURI	 = oNode2 . namespaceURI || null ; %NWL%9
break ; %NWL%case " z "  : %NWL%uvm . projection_axis = enums . uv . axis . Z ; %NWL%break ;%NWL%}%NWL%}%NWL%if ( uvelem . center )  {%NWL%uvm . center = util . floatDelimArray ( meshKit . getTextNode ( uvelem ,  " center "  )  )  ;%NWL%}%NWL%if ( uvelem . rotation )  {%NWL%uvm . rotation = util . floatDelimArray ( meshKit . getTextNode ( uvelem ,  " rotation "  )  )  ; %NWL%7
var methods = require (  " methods "  )  ; %NWL%var ContextError = require (  " context - error "  )  ; %NWL%var reader = require (  "  .  / reader "  )  ; %NWL%module . exports = function ( api , parent , verOpts )  {%NWL%if ( verOpts . name =  = undefined )  {%NWL%throw new Error (  " NAME is a required filed when creating a version "  )  ;%NWL%}%NWL%var ver =  {  }  ; %NWL%ver . name = verOpts . name ; %NWL%ver . desc = verOpts . desc || "  "  ; %NWL%ver . api_name = verOpts . api_name ; %NWL%8
var imgs = spriteSheet . _images ; %NWL%var canvas = SpriteSheetUtils . _workingCanvas ; %NWL%var ctx = SpriteSheetUtils . _workingContext ; %NWL%var il = imgs . length / count ; %NWL%for ( var i = 0 ; i < il ; i +  +  )  {%NWL%var src = imgs [ i ]  ; %NWL%src . __tmp = i ;  /  / a bit hacky , but faster than doing indexOf below .%NWL%ctx . setTransform ( 1 , 0 , 0 , 1 , 0 , 0 )  ; %NWL%ctx . clearRect ( 0 , 0 , canvas . width + 1 , canvas . height + 1 )  ; %NWL%canvas . width = src . width ; %NWL%canvas . height = src . height ; %NWL%9
if ( !isObjectNothing ( CaseService . sortOrder )  )  {%NWL%params . sort_order = CaseService . sortOrder ;%NWL%}%NWL%if ( !isObjectNothing ( CaseService . owner )  )  {%NWL%params . owner_ssoname = CaseService . owner ;%NWL%}%NWL%if ( !isObjectNothing ( CaseService . type )  )  {%NWL%params . type = CaseService . type ;%NWL%}%NWL%if ( !isObjectNothing ( CaseService . severity )  )  {%NWL%params . severity = CaseService . severity ; %NWL%7
for ( var z = 0 ; z < 3 ; z +  +  )  {%NWL%sum +  = m1 [ x ]  [ z ]  * m2 [ z ]  [ y ]  ;%NWL%}%NWL%result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%9
this . destroyed = false ;%NWL%}  )  ;%NWL%} else {%NWL%return Backbone . Model . prototype . sync . apply ( this , arguments )  ;%NWL%}%NWL%}  ,%NWL%parse : function ( resp , xhr )  {%NWL%if ( ! resp )%NWL%return resp ; %NWL%resp . date = new Date ( resp . date )  ; %NWL%resp . modified = new Date ( resp . modified )  ; %NWL%9
"  .  .  / _Plugin "  ,%NWL%"  .  .  /  .  .  / EnhancedGrid "%NWL%]  , function ( declare , array , lang , html , evt , keys , _Plugin , EnhancedGrid )  {%NWL%var Menu = declare (  " dojox . grid . enhanced . plugins . Menu "  , _Plugin ,  {%NWL%name :  " menus "  ,%NWL%types :  [  ' headerMenu '  ,  ' rowMenu '  ,  ' cellMenu '  ,  ' selectedRegionMenu '  ]  ,%NWL%constructor : function (  )  {%NWL%var g = this . grid ; %NWL%g . showMenu = lang . hitch ( g , this . showMenu )  ; %NWL%g . _setRowMenuAttr = lang . hitch ( this ,  ' _setRowMenuAttr '  )  ; %NWL%g . _setCellMenuAttr = lang . hitch ( this ,  ' _setCellMenuAttr '  )  ; %NWL%9
}  ; %NWL%base . setGlobalDepthAlpha = GLCore . setDepthAlpha ; %NWL%base . setDefaultFilter = GLCore . setDefaultFilter ; %NWL%base . setSoftShadows = GLCore . setSoftShadows ; %NWL%base . setQuality = GLCore . setQuality ; %NWL%base . getQuality = GLCore . getQuality ; %NWL%base . RegisterModule = CubicVR . RegisterModule ; %NWL%base . getScriptLocation = CubicVR . getScriptLocation ; %NWL%base . setFogExp = GLCore . setFogExp ; %NWL%base . setFogLinear = GLCore . setFogLinear ; %NWL%base . setFogNoise = GLCore . setFogNoise ; %NWL%2
if ( this . children . member ( uiObject )  )  {%NWL%this . children = this . children . without ( uiObject )  ; %NWL%uiObject . parent = undefined ; %NWL%if ( uiObject instanceof ORYX . Core . Shape )  {%NWL%if ( uiObject instanceof ORYX . Core . Edge )  {%NWL%uiObject . removeMarkers (  )  ; %NWL%uiObject . node = this . node . childNodes [ 0 ]  . childNodes [ 2 ]  . removeChild ( uiObject . node )  ; %NWL%this . edges = this . edges . without ( uiObject )  ;%NWL%} else {%NWL%uiObject . node = this . node . childNodes [ 0 ]  . childNodes [ 1 ]  . removeChild ( uiObject . node )  ; %NWL%this . nodes = this . nodes . without ( uiObject )  ; %NWL%1
}%NWL%}  ;%NWL%}%NWL%}%NWL%exports . describe = global . describe ; %NWL%exports . xdescribe = global . xdescribe ; %NWL%exports . describe . skip = global . describe . skip ; %NWL%exports . after = wrapped ( global . after )  ; %NWL%exports . afterEach = wrapped ( global . afterEach )  ; %NWL%exports . before = wrapped ( global . before )  ; %NWL%exports . beforeEach = wrapped ( global . beforeEach )  ; %NWL%7
this . handleRouteNameChange = __bind ( this . handleRouteNameChange , this )  ; %NWL%this . handleFileChanged = __bind ( this . handleFileChanged , this )  ; %NWL%this . handleFile = __bind ( this . handleFile , this )  ; %NWL%this . eventDropFiles = __bind ( this . eventDropFiles , this )  ; %NWL%this . eventUploadFiles = __bind ( this . eventUploadFiles , this )  ; %NWL%this . preventDefault = __bind ( this . preventDefault , this )  ; %NWL%this . eventSaveChanges = __bind ( this . eventSaveChanges , this )  ; %NWL%this . eventKeyDown = __bind ( this . eventKeyDown , this )  ; %NWL%this . clearAll = __bind ( this . clearAll , this )  ; %NWL%this . eventDeleteFileConfirmed = __bind ( this . eventDeleteFileConfirmed , this )  ; %NWL%this . eventRenameFile = __bind ( this . eventRenameFile , this )  ; %NWL%0
return wrapper ;%NWL%}  ; %NWL%exports . Loader = CustomLoader ; %NWL%function HookedPlainTextConsole ( hook , print , innerID )  {%NWL%this . log = hook . bind ( null ,  " log "  , innerID )  ; %NWL%this . info = hook . bind ( null ,  " info "  , innerID )  ; %NWL%this . warn = hook . bind ( null ,  " warn "  , innerID )  ; %NWL%this . error = hook . bind ( null ,  " error "  , innerID )  ; %NWL%this . debug = hook . bind ( null ,  " debug "  , innerID )  ; %NWL%this . exception = hook . bind ( null ,  " exception "  , innerID )  ; %NWL%this . time = hook . bind ( null ,  " time "  , innerID )  ; %NWL%4
continue ;%NWL%}%NWL%logMock ( mockHandler , requestSettings )  ; %NWL%if ( requestSettings . dataType =  =  =  " jsonp "  )  {%NWL%if (  ( mockRequest = processJsonpMock ( requestSettings , mockHandler , origSettings )  )  )  {%NWL%return mockRequest ;%NWL%}%NWL%}%NWL%mockHandler . cache = requestSettings . cache ; %NWL%mockHandler . timeout = requestSettings . timeout ; %NWL%mockHandler . global = requestSettings . global ; %NWL%8
canvas_id , audio_context , type )  {%NWL%this . num_bins = num_bins ; %NWL%this . num_points = num_points ; %NWL%this . canvas_id = canvas_id ; %NWL%this . update_rate_ms = 50 ; %NWL%this . smoothing = 0 . 75 ; %NWL%this . type = type || SpectrumBox . Types . FREQUENCY ; %NWL%this . valid_points = 0 ; %NWL%this . canvas = document . getElementById ( canvas_id )  ; %NWL%this . width = this . canvas . width - 12 ; %NWL%this . height = this . canvas . height - 12 ; %NWL%9
( function (  )  {%NWL%var __bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%Todo . AppController =  ( function ( _super )  {%NWL%__extends ( AppController , _super )  ; %NWL%function AppController (  )  {%NWL%this . clearCompleted = __bind ( this . clearCompleted , this )  ; %NWL%this . createItem = __bind ( this . createItem , this )  ; %NWL%this . itemsChanged = __bind ( this . itemsChanged , this )  ; %NWL%this . setMode = __bind ( this . setMode , this )  ; %NWL%7
define (  [  ' durandal / system '  ,  ' knockout '  ]  , function ( system , ko )  {%NWL%var activator ; %NWL%function ensureSettings ( settings )  {%NWL%if ( settings =  = undefined )  {%NWL%settings =  {  }  ;%NWL%}%NWL%if ( !settings . closeOnDeactivate )  {%NWL%settings . closeOnDeactivate = activator . defaults . closeOnDeactivate ;%NWL%}%NWL%if ( !settings . beforeActivate )  {%NWL%settings . beforeActivate = activator . defaults . beforeActivate ; %NWL%7
this . overlayContainerElement = null ; %NWL%this . zones = new Array (  )  ; %NWL%this . dragState = null ; %NWL%this . menu = null ; %NWL%this . draggedWebPart = null ; %NWL%this . AddZone = WebPartManager_AddZone ; %NWL%this . IsDragDropEnabled = WebPartManager_IsDragDropEnabled ; %NWL%this . DragDrop = WebPartManager_DragDrop ; %NWL%this . InitiateWebPartDragDrop = WebPartManager_InitiateWebPartDragDrop ; %NWL%this . CompleteWebPartDragDrop = WebPartManager_CompleteWebPartDragDrop ; %NWL%this . ContinueWebPartDragDrop = WebPartManager_ContinueWebPartDragDrop ; %NWL%5
else if ( criteria . join ! =  =  '  '  )%NWL%this . join +  =  '  '  + criteria . join ;%NWL%}%NWL%if ( this . having ! =  = criteria . having )  {%NWL%if ( this . having =  =  =  '  '  )%NWL%this . having = criteria . having ; %NWL%else if ( criteria . having ! =  =  '  '  )%NWL%this . having =  "  (  "  + this . having +  "  )  "  + and +  "  (  "  + criteria . having +  "  )  "  ;%NWL%}%NWL%if ( criteria . distinct > 0 )%NWL%this . distinct = criteria . distinct ; %NWL%5
this . order = obj . order ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . locales = obj . locales ;%NWL%}  ; %NWL%cubes . Measure = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%0
}%NWL%}%NWL%}%NWL%return modes ;%NWL%}%NWL%function IrcCommand ( command , data )  {%NWL%this . command = command +  =  '  '  ; %NWL%this . params = _ . clone ( data . params )  ; %NWL%this . tags = _ . clone ( data . tags )  ; %NWL%this . prefix = data . prefix ; %NWL%this . nick = data . nick ; %NWL%9
var MetricDisplay = require (  '  .  .  / backbone_components / metric_display '  )  ; %NWL%var WheelGraphMetric = Class . extend (  {%NWL%defaults :  {%NWL%metric : null ,%NWL%base : null ,%NWL%clock : null%NWL%}  ,%NWL%init : function ( options )  {%NWL%this . config = _ . extend (  {  }  , this . defaults , options )  ; %NWL%this . metric = this . config . metric ; %NWL%this . base = this . config . base ; %NWL%9
return this . warnings && this . warnings . indexOf (  " timeout "  )  >  - 1 ;%NWL%}  ; %NWL%PageTestLogSchema . methods . hasWarning = function (  )  {%NWL%return this . warnings && this . warnings . length > 0 ;%NWL%}  ; %NWL%PageTestLogSchema . methods . created_at_format = function (  )  {%NWL%return moment ( this . created_at )  . format (  " DD - MM - YY HH : mm "  )  ;%NWL%}  ; %NWL%exports . PluginTest = db . model (  ' PluginTest '  , PluginTestSchema )  ; %NWL%exports . PageTestLog = db . model (  ' PageTestLog '  , PageTestLogSchema )  ; %NWL%exports . TestUrlsSet = db . model (  ' TestUrlsSet '  , TestUrlsSetSchema )  ; %NWL%8
}%NWL%assert . ok = ok ; %NWL%assert . equal = function equal ( actual , expected , message )  {%NWL%if ( actual ! = expected ) fail ( actual , expected , message ,  '  =  =  '  , assert . equal )  ;%NWL%}  ; %NWL%assert . notEqual = function notEqual ( actual , expected , message )  {%NWL%if ( actual =  = expected )  {%NWL%fail ( actual , expected , message ,  ' ! =  '  , assert . notEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . deepEqual = function deepEqual ( actual , expected , message )  {%NWL%2
}  ; %NWL%if ( typeof syntax . tokens ! =  =  ' undefined '  )  {%NWL%if ( syntax . tokens . length > 0 )  {%NWL%options . range =  ( typeof syntax . tokens [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . tokens [ 0 ]  . loc ! =  =  ' undefined '  )  ;%NWL%}%NWL%}%NWL%if ( typeof syntax . comments ! =  =  ' undefined '  )  {%NWL%if ( syntax . comments . length > 0 )  {%NWL%options . range =  ( typeof syntax . comments [ 0 ]  . range ! =  =  ' undefined '  )  ; %NWL%options . loc =  ( typeof syntax . comments [ 0 ]  . loc ! =  =  ' undefined '  )  ; %NWL%9
this . setOptions ( options )  ;%NWL%}%NWL%this . deferred = new Deferred (  )  ; %NWL%this . callbacks = Callbacks (  ' unique '  )  ;%NWL%}  ,%NWL%setOptions : function ( options )  {%NWL%if ( options . destination )  {%NWL%this . destination = options . destination ;%NWL%}%NWL%if ( options . template )  {%NWL%this . template = options . template ; %NWL%7
dojo . require (  " dojo . widget . HtmlWidget "  )  ; %NWL%dojo . widget . defineWidget (%NWL%" dojo . widget . TreeToggleOnSelect "  ,%NWL%dojo . widget . HtmlWidget ,%NWL%{%NWL%selector :  "  "  ,%NWL%controller :  "  "  ,%NWL%selectEvent :  " select "  ,%NWL%initialize : function (  )  {%NWL%this . selector = dojo . widget . byId ( this . selector )  ; %NWL%this . controller = dojo . widget . byId ( this . controller )  ; %NWL%9
info  : prepareLogFn ( $log . info ,  className , colorCSS )  ,%NWL%warn  : prepareLogFn ( $log . warn ,  className , colorCSS )  ,%NWL%debug : prepareLogFn ( $log . debug ,  className , colorCSS )  ,%NWL%error : prepareLogFn ( $log . error ,  className )  /  / NO styling of ERROR messages%NWL%}  ;%NWL%}  ; %NWL%$log . log  = prepareLogFn ( $log . log )  ; %NWL%$log . info  = prepareLogFn ( $log . info )  ; %NWL%$log . warn  = prepareLogFn ( $log . warn )  ; %NWL%$log . debug = prepareLogFn ( $log . debug )  ; %NWL%$log . error = prepareLogFn ( $log . error )  ; %NWL%7
for ( var i = 0 ; i < labels . length ; i +  +  )  {%NWL%binding . bindByName (  " labelName "  + i , labels [ i ]  )  ;%NWL%}%NWL%binding . bindByName (  " num "  , labels . length )  ; %NWL%params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%var requests =  [  ]  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%9
var helper = require (  '  .  / helper . js '  )%NWL%, 	Mu	  = require (  ' mu '  )  ; %NWL%Mu . root = Path . join ( __dirname ,  '  .  / templates '  )  ; %NWL%exports . version =  " 0 . 2 . 0dev "  ; %NWL%exports . as = require (  '  .  / as . js '  )  ; %NWL%exports . push = require (  '  .  / push . js '  )  ; %NWL%exports . hcard = require (  '  .  / hcard . js '  )  ; %NWL%exports . webfinger = require (  '  .  / webfinger . js '  )  ; %NWL%exports . salmon = require (  '  .  / salmon . js '  )  ; %NWL%exports . activities = helper . activities ; %NWL%exports . profile = helper . profile ; %NWL%9
}%NWL%options = options || {  }%NWL%this . _endEmitted = false%NWL%this . EOF =  {  }%NWL%this . _emitQueue =  [  ]%NWL%this . paused = false%NWL%this . _processingEmitQueue = false%NWL%this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . cache = options . cache || {  }%NWL%this . statCache = options . statCache || {  }%NWL%9
result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%6
loader . setResponseType (  ' arraybuffer '  )  ; %NWL%loader . load ( url , function ( buffer )  {%NWL%var dds = scope . parse ( buffer , true )  ; %NWL%if ( dds . isCubemap )  {%NWL%var faces = dds . mipmaps . length / dds . mipmapCount ; %NWL%for ( var f = 0 ; f < faces ; f +  +  )  {%NWL%images [ f ]  =  { mipmaps :  [  ]  }  ; %NWL%for ( var i = 0 ; i < dds . mipmapCount ; i +  +  )  {%NWL%images [ f ]  . mipmaps . push ( dds . mipmaps [ f * dds . mipmapCount + i ]  )  ; %NWL%images [ f ]  . format = dds . format ; %NWL%images [ f ]  . width = dds . width ; %NWL%9
, mat3 = glMatrix . mat3%NWL%, vec3 = glMatrix . vec3%NWL%, _ = require (  " underscore "  )  ; %NWL%var Hand = module . exports = function ( data )  {%NWL%this . id = data . id ; %NWL%this . palmPosition = data . palmPosition ; %NWL%this . direction = data . direction ; %NWL%this . palmVelocity = data . palmVelocity ; %NWL%this . palmNormal = data . palmNormal ; %NWL%this . sphereCenter = data . sphereCenter ; %NWL%this . sphereRadius = data . sphereRadius ; %NWL%4
if ( typeof ( r ) ! =  =  ' string '  )%NWL%throw new TypeError (  ' options . referrals must be an array [ string ]  '  )  ;%NWL%}  )  ;%NWL%}%NWL%} else {%NWL%options =  {  }  ;%NWL%}%NWL%LDAPMessage . call ( this , options )  ; %NWL%this . status = options . status || 0 ;  /  / LDAP SUCCESS%NWL%this . matchedDN = options . matchedDN || '  '  ; %NWL%this . errorMessage = options . errorMessage || '  '  ; %NWL%9
}%NWL%source = object ; %NWL%object = lodash ;%NWL%}%NWL%return fn ( object , source , options )  ;%NWL%}  ;%NWL%}  ( mixin )  )  ; %NWL%lodash . after = functions . after ; %NWL%lodash . assign = objects . assign ; %NWL%lodash . at = collections . at ; %NWL%lodash . bind = functions . bind ; %NWL%7
var dur = x . z [ m ]  . l ! = null ? ( x . z [ m ]  . l * 1000 )  : 500 ; %NWL%moveDuration +  = dur ; %NWL%var motion =  {%NWL%x :  { from : last . x , to : x . z [ m ]  . x / 1000 , dur : dur , delay : 0 }  ,%NWL%y :  { from : last . y , to : x . z [ m ]  . y / 1000 , dur : dur , delay : 0 }%NWL%}  ; %NWL%last . x = motion . x . to ; %NWL%last . y = motion . y . to ; %NWL%if ( x . z [ m ]  . t ! =  = last . alpha )  {%NWL%motion . alpha =  { from : last . alpha , to : x . z [ m ]  . t , dur : dur , delay : 0 }  ; %NWL%last . alpha = motion . alpha . to ; %NWL%6
this . acceleration = opts . acceleration ! = undefined ? opts . acceleration : new Vec2 ; %NWL%this . accelerationSpread = opts . accelerationSpread ! = undefined ? opts . accelerationSpread : new Vec2 ; %NWL%this . angularVelocity = opts . angularVelocity ! = undefined ? opts . angularVelocity : 0 ; %NWL%this . angularVelocitySpread = opts . angularVelocitySpread ! = undefined ? opts . angularVelocitySpread : 0 ; %NWL%this . angularAcceleration = opts . angularAcceleration ! = undefined ? opts . angularAcceleration : 0 ; %NWL%this . angularAccelerationSpread = opts . angularAccelerationSpread ! = undefined ? opts . angularAccelerationSpread : 0 ; %NWL%this . randomAngle = opts . randomAngle ! = undefined ? opts . randomAngle : true ; %NWL%this . emissionRate = opts . emissionRate ! = undefined ? opts . emissionRate : 1 / 60 ; %NWL%this . color = opts . color ! = undefined ? opts . color : new Color ; %NWL%this . colorSpread = opts . colorSpread ! = undefined ? opts . colorSpread : new Color ; %NWL%this . time = opts . time ! = undefined ? opts . time : 0 ; %NWL%2
me . movePlanPopup . show (  )  ;%NWL%}  ,%NWL%onSavePlanRequest : function ( values )  {%NWL%var me = this ; %NWL%if ( me . savePlanPopUp =  = null || me . savePlanPopUp . isDestroyed )%NWL%me . savePlanPopUp = Ext . create (  ' Ssp . view . tools . map . SavePlan '  ,  { hidden : true , saveAs : false , viewToClose : values . viewToClose , loaderDialogEventName : values . loaderDialogEventName }  )  ; %NWL%me . savePlanPopUp . show (  )  ;%NWL%}  ,%NWL%onSaveTemplateRequest : function ( values )  {%NWL%var me = this ; %NWL%if ( me . saveTemplatePopUp =  = null || me . saveTemplatePopUp . isDestroyed )%NWL%4
assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%if ( actual ! =  = expected )  {%NWL%fail ( actual , expected , message ,  '  =  =  =  '  , assert . strictEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . notStrictEqual = function notStrictEqual ( actual , expected , message )  {%NWL%0
}%NWL%if ( typeof resolver =  =  =  ' function '  )  {%NWL%return resolver ( domain , callback )  ;%NWL%} else {%NWL%throw new Error (  ' Unknown type "  '  + type_ +  '  "  '  )  ;%NWL%}%NWL%}  ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%7
_audioVideo : function ( type , props , attachment )  {%NWL%var shortcode , html , extension ; %NWL%props = wp . media . string . props ( props , attachment )  ; %NWL%if ( props . link ! =  =  ' embed '  )%NWL%return wp . media . string . link ( props )  ; %NWL%shortcode =  {  }  ; %NWL%if (  ' video '  =  =  = type )  {%NWL%if ( attachment . width )%NWL%shortcode . width = attachment . width ; %NWL%if ( attachment . height )%NWL%shortcode . height = attachment . height ; %NWL%8
start : function ( event , ui )  {%NWL%$ ( this )  . addClass (  " ui - dialog - resizing "  )  ; %NWL%self . _trigger (  ' resizeStart '  , event , filteredUi ( ui )  )  ;%NWL%}  ,%NWL%resize : function ( event , ui )  {%NWL%self . _trigger (  ' resize '  , event , filteredUi ( ui )  )  ;%NWL%}  ,%NWL%stop : function ( event , ui )  {%NWL%$ ( this )  . removeClass (  " ui - dialog - resizing "  )  ; %NWL%options . height = $ ( this )  . height (  )  ; %NWL%options . width = $ ( this )  . width (  )  ; %NWL%9
params . only =  [ params . only ]  ;%NWL%}%NWL%params . only . forEach ( function ( action )  {%NWL%if ( action in availableRoutes )  {%NWL%activeRoutes [ action ]  = availableRoutes [ action ]  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%else if ( params . except )  {%NWL%if ( typeof params . except =  =  =  ' string '  )  {%NWL%params . except =  [ params . except ]  ; %NWL%0
arrayCopy = require (  '  .  / arrayCopy '  )  ; %NWL%function lazyClone (  )  {%NWL%var actions = this . __actions__ ,%NWL%iteratees = this . __iteratees__ ,%NWL%views = this . __views__ ,%NWL%result = new LazyWrapper ( this . __wrapped__ )  ; %NWL%result . __actions__ = actions ? arrayCopy ( actions )  : null ; %NWL%result . __dir__ = this . __dir__ ; %NWL%result . __filtered__ = this . __filtered__ ; %NWL%result . __iteratees__ = iteratees ? arrayCopy ( iteratees )  : null ; %NWL%result . __takeCount__ = this . __takeCount__ ; %NWL%7
}  ; %NWL%return map [ direction ]  ;%NWL%}  ; %NWL%GameManager . prototype . buildTraversals = function ( vector )  {%NWL%var traversals =  { x :  [  ]  , y :  [  ]  }  ; %NWL%for ( var pos = 0 ; pos < this . size ; pos +  +  )  {%NWL%traversals . x . push ( pos )  ; %NWL%traversals . y . push ( pos )  ;%NWL%}%NWL%if ( vector . x =  =  = 1 ) traversals . x = traversals . x . reverse (  )  ; %NWL%if ( vector . y =  =  = 1 ) traversals . y = traversals . y . reverse (  )  ; %NWL%9
this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if (  / \bglob\b /  . test ( process . env . NODE_DEBUG || '  '  )  )%NWL%this . debug = true%NWL%if ( this . debug )%NWL%this . log = console . error%NWL%this . silent = !!options . silent%NWL%0
var ele = $ ( this )  , f = ele . data (  ' ukFilter '  )  , infilter = filter . length ? false : true ; %NWL%if ( f )  {%NWL%f = f . split (  /  ,  /  )  . map ( function ( item )  { return item . trim (  )  ;  }  )  ; %NWL%filter . forEach ( function ( item )  {%NWL%if ( f . indexOf ( item )  >  - 1 ) infilter = true ;%NWL%}  )  ;%NWL%}%NWL%elements [ infilter ? " visible "  :  " hidden "  ]  . push ( ele )  ;%NWL%}  )  ; %NWL%elements . hidden  = $ ( elements . hidden )  . map ( function (  )  { return this [ 0 ]  ;  }  )  ; %NWL%elements . visible = $ ( elements . visible )  . map ( function (  )  { return this [ 0 ]  ;  }  )  ; %NWL%9
this . x = a . x ; %NWL%this . y = a . y ; %NWL%break ; %NWL%case 2 :  /  /  ( x , y )  ,  ( width , height )%NWL%this . x = a . x ; %NWL%this . y = a . y ; %NWL%this . width = b . x ; %NWL%this . height = b . y ; %NWL%break ; %NWL%case 3 :  /  /  ( x , y )  , width , height%NWL%this . x = a . x ; %NWL%1
describe (  '  . isDocument (  )  '  , function (  )  {%NWL%it (  ' should test if the given object is Document '  , function (  )  {%NWL%_ . isDocument ( DOC_MOCK )  . should . eql ( true )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%describe (  ' forEach '  , function (  )  {%NWL%var forEach = _ . forEach ; %NWL%it (  ' should iterate over * own * object properties '  , function (  )  {%NWL%function MyObj (  )  {%NWL%this . bar =  ' barVal '  ; %NWL%this . baz =  ' bazVal '  ; %NWL%9
onAfter : h%NWL%}  ; %NWL%if ( f =  =  ' max '  )%NWL%f = 9e9 ; %NWL%h = $ . extend (  {  }  , j . defaults , h )  ; %NWL%g = g || h . duration ; %NWL%h . queue = h . queue && h . axis . length > 1 ; %NWL%if ( h . queue )%NWL%g /  = 2 ; %NWL%h . offset = both ( h . offset )  ; %NWL%h . over = both ( h . over )  ; %NWL%9
return this ;%NWL%}  ; %NWL%this . usePrefix . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . usePrefix "  ; %NWL%this . useUrlServer = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . urlServer ;%NWL%}%NWL%options . urlServer = value ; %NWL%return this ;%NWL%}  ; %NWL%this . useUrlServer . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useUrlServer "  ; %NWL%2
module . exports = Backbone . View . extend (  {%NWL%template : templates . header ,%NWL%events :  {%NWL%' focus input '  :  ' checkPlaceholder '  ,%NWL%' change input [ data - mode =  " path "  ]  '  :  ' updatePath '  ,%NWL%' change input [ data - mode =  " title "  ]  '  :  ' updateTitle '%NWL%}  ,%NWL%initialize : function ( options )  {%NWL%_ . bindAll ( this )  ; %NWL%this . user = options . user ; %NWL%this . repo = options . repo ; %NWL%9
ByteBufferPrototype . writeFloat = ByteBufferPrototype . writeFloat32 ; %NWL%ByteBufferPrototype . readFloat32 = function ( offset )  {%NWL%if ( !this . noAssert )  {%NWL%}%NWL%var value = this . littleEndian%NWL%? this . buffer . readFloatLE ( offset , true )%NWL% : this . buffer . readFloatBE ( offset , true )  ; %NWL%var value = this . view . getFloat32 ( offset , this . littleEndian )  ; %NWL%return value ;%NWL%}  ; %NWL%ByteBufferPrototype . readFloat = ByteBufferPrototype . readFloat32 ; %NWL%0
exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%exports . BADFLAGS =  ' EBADFLAGS '  ; %NWL%0
function Item ( type , count , metadata , nbt )  {%NWL%if ( type =  = null ) return ; %NWL%this . type = type ; %NWL%this . count = count ; %NWL%this . metadata = metadata =  = null ? 0 : metadata ; %NWL%this . nbt = nbt || new Buffer ( 0 )  ; %NWL%var itemEnum = items [ type ] || blocks [ type ]  ; %NWL%assert . ok ( itemEnum )  ; %NWL%this . name = itemEnum . name ; %NWL%this . displayName = itemEnum . displayName ; %NWL%this . stackSize = itemEnum . stackSize ; %NWL%8
pointerId : null ,%NWL%events :  [%NWL%' pointerdown '  ,%NWL%' pointermove '  ,%NWL%' pointerup '  ,%NWL%' pointercancel '%NWL%]  ,%NWL%pointerdown : function ( inEvent )  {%NWL%if ( inEvent . isPrimary && !this . pointerId )  {%NWL%this . pointerId = inEvent . pointerId ; %NWL%this . target = inEvent . target ; %NWL%9
gesture = new ScreenTapGesture ( data )  ; %NWL%break ; %NWL%case ' keyTap '  : %NWL%gesture = new KeyTapGesture ( data )  ; %NWL%break ; %NWL%default : %NWL%throw " unknown gesture type "  ;%NWL%}%NWL%gesture . id = data . id ; %NWL%gesture . handIds = data . handIds . slice (  )  ; %NWL%gesture . pointableIds = data . pointableIds . slice (  )  ; %NWL%9
if ( request . query . tags )  {%NWL%content . tags = request . query . tags ;%NWL%}%NWL%if ( request . query . tagmode )  {%NWL%content . tagmode = request . query . tagmode ;%NWL%}%NWL%if ( request . query . userid )  {%NWL%content . id = request . query . userid ;%NWL%}%NWL%if ( request . query . userids )  {%NWL%content . ids = request . query . userids ; %NWL%7
node . predecessors = g . predecessors ( k )  ; %NWL%node . successors = g . successors ( k )  ; %NWL%nodes . push ( node )  ; %NWL%var mnx = x - node . width / 2 ; %NWL%var mny = y - node . height / 2 ; %NWL%var mxx = x + node . width / 2 ; %NWL%var mxy = y + node . height / 2 ; %NWL%center . x +  = x ; %NWL%center . y +  = y ; %NWL%mn . x = Math . min ( mn . x , mnx )  ; %NWL%mn . y = Math . min ( mn . y , mny )  ; %NWL%9
this . authenticate = function ( callback )  {%NWL%if ( !this . loaded )  {%NWL%return false ;%NWL%}%NWL%var self = this ; %NWL%$ . getJSON ( self . handler ,  {  " action "  :  " auth "  ,  " auth "  :  " jwysiwyg "  }  , function ( json , textStatus )  {%NWL%if ( json . success )  {%NWL%self . move = json . data . move ; %NWL%self . rename = json . data . rename ; %NWL%self . remove = json . data . remove ; %NWL%self . mkdir = json . data . mkdir ; %NWL%7
this . path = expr ; %NWL%this . once = once || false ;%NWL%}  ; %NWL%Import . prototype . __proto__ = Node . prototype ; %NWL%Import . prototype . clone = function ( parent )  {%NWL%var clone = new Import (  )  ; %NWL%clone . path = this . path . nodeName ? this . path . clone ( parent , clone )  : this . path ; %NWL%clone . once = this . once ; %NWL%clone . mtime = this . mtime ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%7
, stylesheet = theme . stylesheet%NWL%, functionality = theme . functionality%NWL%, mapsTheme = theme . mapsTheme%NWL%, optional = options . optional ; %NWL%chartObject . timeline_duration =  " timeline_duration " in options ? options . timeline_duration : mapsTheme . timeline_duration ; %NWL%chartObject . margin_left = options . timeline_margin_left ? options . timeline_margin_left : mapsTheme . timeline_margin_left ; %NWL%chartObject . margin_right = options . timeline_margin_right ? options . timeline_margin_right : mapsTheme . timeline_margin_right ; %NWL%chartObject . margin_top = options . timeline_margin_top ? options . timeline_margin_top : mapsTheme . timeline_margin_top ; %NWL%chartObject . margin_bottom = options . timeline_margin_bottom ? options . timeline_margin_bottom : mapsTheme . timeline_margin_bottom ; %NWL%chartObject . tooltip_position_top = options . tooltip_position_top ? options . tooltip_position_top : mapsTheme . tooltip_position_top ; %NWL%chartObject . tooltip_position_left = options . tooltip_position_left ? options . tooltip_position_left : mapsTheme . tooltip_position_left ; %NWL%9
pickers [ i ]  . onTouchStart ( event )  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%Vizi . PickManager . handleTouchMove = function ( event )%NWL%{%NWL%if ( event . touches . length > 0 )  {%NWL%event . screenX = event . touches [ 0 ]  . screenX ; %NWL%event . screenY = event . touches [ 0 ]  . screenY ; %NWL%9
}%NWL%var doSlideshow = function (  )  {%NWL%if ( step < 0 )  {%NWL%step = backgrounds . length - 1 ;%NWL%}%NWL%if ( step >  = backgrounds . length || !backgrounds [ step - 1 ]  )  {%NWL%step = 0 ;%NWL%}%NWL%var settings = backgrounds [ step +  +  ]  ; %NWL%settings . walk = options . walk ; %NWL%settings . loading = options . loading ; %NWL%9
var self = this ; %NWL%this . addBlankFather = _addBlankFather ; %NWL%this . addBlankMother = _addBlankMother ; %NWL%this . addBlankParents = _addBlankParents ; %NWL%this . addListener = _addListener ; %NWL%this . findAncestors = _findAncestors ; %NWL%this . findDescendants = _findDescendants ; %NWL%this . findLineageList = _findLineageList ; %NWL%this . findParents = _findParents ; %NWL%this . findPerson = _findPerson ; %NWL%this . findOffspring = _findOffspring ; %NWL%1
}%NWL%plane . x = normal . x ; %NWL%plane . y = normal . y ; %NWL%plane . z = normal . z ; %NWL%plane . w =  - Cartesian3 . dot ( normal , position )  ; %NWL%plane = planes [ 4 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 4 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x = direction . x ; %NWL%plane . y = direction . y ; %NWL%9
} else {%NWL%return ( Math . max . apply ( null , keys )  + 1 )  . toString (  )  ;%NWL%}%NWL%}%NWL%var ProxyRule = Class (  {%NWL%extends : EventTarget ,%NWL%initialize : function initialize ( rule )  {%NWL%EventTarget . prototype . initialize . call ( this , rule )  ; %NWL%if ( rule )  {  /  / Copy constructor%NWL%this . id = rule . id ; %NWL%this . type = rule . type ; %NWL%9
}%NWL%this . preloadImg = img ;%NWL%}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . forms [ 0 ]  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%9
this . to = data . to ; %NWL%this . worker = data . worker ; %NWL%if ( this . from =  =  = this . to )  {%NWL%this . postMessage (  { cmd :  ' finished '  , worker : this . worker }  )  ; %NWL%close (  )  ;%NWL%}%NWL%break ; %NWL%case ' finished '  : %NWL%this . finished +  +  ; %NWL%if ( this . finished > 1 )  {%NWL%this . array = data . array ; %NWL%0
this . position = data . position ; %NWL%this . direction = data . direction ; %NWL%this . progress = data . progress ;%NWL%}%NWL%ScreenTapGesture . prototype . toString = function (  )  {%NWL%return " ScreenTapGesture [  "  + JSON . stringify ( this )  +  "  ]  "  ;%NWL%}%NWL%var KeyTapGesture = function ( data )  {%NWL%this . position = data . position ; %NWL%this . direction = data . direction ; %NWL%this . progress = data . progress ; %NWL%0
this . init (  )  ; %NWL%this . element . data (  " markdownarea "  , this )  ;%NWL%}  ; %NWL%$ . extend ( Markdownarea . prototype ,  {%NWL%init : function (  )  {%NWL%var $this = this , tpl = Markdownarea . template ; %NWL%tpl = tpl . replace (  / \ { \ : lblPreview\ }  / g , this . options . lblPreview )  ; %NWL%tpl = tpl . replace (  / \ { \ : lblCodeview\ }  / g , this . options . lblCodeview )  ; %NWL%this . markdownarea = $ ( tpl )  ; %NWL%this . content   = this . markdownarea . find (  "  . uk - markdownarea - content "  )  ; %NWL%this . toolbar   = this . markdownarea . find (  "  . uk - markdownarea - toolbar "  )  ; %NWL%9
' orion / git / uiUtil '  ,%NWL%' orion / git / util '  ,%NWL%' orion / Deferred '  ,%NWL%' orion / git / gitCommands '  ,%NWL%' orion / objects '%NWL%]  , function ( messages , mCommandRegistry , mExplorer , URITemplate , i18nUtil , uiUtil , util , Deferred , mGitCommands , objects )  {%NWL%var repoTemplate = new URITemplate (  " git / git - repository . html# {  , resource , params *  }  "  )  ;  /  / $NON - NLS - 0$%NWL%function GitRepoListModel ( options )  {%NWL%this . root = options . root ; %NWL%this . registry = options . registry ; %NWL%this . handleError = options . handleError ; %NWL%8
}  ; %NWL%self . getInnerWidth = getInnerWidth = function (  )  {%NWL%return wrapperEl . clientWidth ;%NWL%}  ; %NWL%self . getHeight = getHeight = function (  )  {%NWL%return wrapperEl . offsetHeight ;%NWL%}  ; %NWL%self . getInnerHeight = getInnerHeight = function (  )  {%NWL%return wrapperEl . clientHeight ;%NWL%}  ; %NWL%self . getLeft = getLeft = function (  )  {%NWL%1
this . formChannel . trigger (  ' updateFinished '  )  ;%NWL%}  ,%NWL%updateCollectionAttributes : function ( JSONUpdate )  {%NWL%this . name    = JSONUpdate [  " name "  ]  ; %NWL%this . descriptionFr = JSONUpdate [  " descriptionFr "  ]  ; %NWL%this . descriptionEn = JSONUpdate [  " descriptionEn "  ]  ; %NWL%this . keywordsFr  = JSONUpdate [  " keywordsFr "  ]  ; %NWL%this . keywordsEn  = JSONUpdate [  " keywordsEn "  ]  ; %NWL%this . labelFr   = JSONUpdate [  " labelFr "  ]  ; %NWL%this . labelEn   = JSONUpdate [  " labelEn "  ]  ; %NWL%this . tag    = JSONUpdate [  " tag "  ]  ; %NWL%3
overrides = this . _wrapper . overrides ,%NWL%x = e . pageX ,%NWL%y = e . pageY ,%NWL%c ,%NWL%currentTarget = this . _currentTarget ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%5
this . domBreakpoints = this . createSetting (  " domBreakpoints "  ,  [  ]  )  ; %NWL%this . xhrBreakpoints = this . createSetting (  " xhrBreakpoints "  ,  [  ]  )  ; %NWL%this . sourceMapsEnabled = this . createSetting (  " sourceMapsEnabled "  , false )  ; %NWL%this . cacheDisabled = this . createSetting (  " cacheDisabled "  , false )  ; %NWL%this . overrideUserAgent = this . createSetting (  " overrideUserAgent "  ,  "  "  )  ; %NWL%this . userAgent = this . createSetting (  " userAgent "  ,  "  "  )  ; %NWL%this . deviceMetrics = this . createSetting (  " deviceMetrics "  ,  "  "  )  ; %NWL%this . deviceFitWindow = this . createSetting (  " deviceFitWindow "  , false )  ; %NWL%this . emulateTouchEvents = this . createSetting (  " emulateTouchEvents "  , false )  ; %NWL%this . showPaintRects = this . createSetting (  " showPaintRects "  , false )  ; %NWL%this . continuousPainting = this . createSetting (  " continuousPainting "  , false )  ; %NWL%2
var fn = require (  '  .  / fn '  )  ; %NWL%module . exports = function ( obj )  {%NWL%function ensure_array ( obj )  {%NWL%var array = obj ? [  ]  . concat ( obj )  :  [  ]  ; %NWL%array . in_array = fn . curry ( array , in_array , array )  ; %NWL%array . each = fn . curry ( array , each , array )  ; %NWL%array . eachAsync = fn . curry ( array , eachAsync , array )  ; %NWL%array . collect = fn . curry ( array , collect , array )  ; %NWL%array . flatten = fn . curry ( array , flatten , array )  ; %NWL%array . inject = fn . curry ( array , inject , array )  ; %NWL%array . push_all = fn . curry ( array , push_all , array )  ; %NWL%4
if ( typeof define ! =  =  ' function '  )  {%NWL%var define = require (  ' amdefine '  )  ( module )  ;%NWL%}%NWL%define ( function ( require )  {%NWL%var LifeCycle = require (  '  .  / lifecycle '  )  ; %NWL%var WoodmanError = require (  '  .  / error '  )  ; %NWL%var Appender = function ( config )  {%NWL%config = config || {  }  ; %NWL%LifeCycle . call ( this )  ; %NWL%this . name = config . name ; %NWL%this . layout = config . layout ; %NWL%9
if ( options . dests . length ! =  = 0 )  {%NWL%console . error (  " Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid .  "  )  ;%NWL%} else {%NWL%response . setEncoding ( options . encoding )  ;%NWL%}%NWL%}%NWL%options . dests . forEach ( function ( dest )  {%NWL%if ( dest . headers )  {%NWL%dest . headers [  ' content - type '  ]  = response . headers [  ' content - type '  ]  ; %NWL%if ( response . headers [  ' content - length '  ]  )  {%NWL%dest . headers [  ' content - length '  ]  = response . headers [  ' content - length '  ]  ; %NWL%8
this . touchStartX = 0 ; %NWL%this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . touchBoundary = 10 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { return FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onMouse = function (  )  { return FastClick . prototype . onMouse . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { return FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%8
proto . info = function info (  )  {%NWL%var args = Array . prototype . slice . call ( arguments )%NWL%args . unshift (  ' info '  )%NWL%this . emit . apply ( this , args )%NWL%}%NWL%proto . warn = function warn (  )  {%NWL%var args = Array . prototype . slice . call ( arguments )%NWL%args . unshift (  ' warn '  )%NWL%this . emit . apply ( this , args )%NWL%}%NWL%proto . verbose = function verbose (  )  {%NWL%0
if ( args . user ! =  = undefined )  {%NWL%this . user = args . user ;%NWL%}%NWL%if ( args . publicUserInfo ! =  = undefined )  {%NWL%this . publicUserInfo = args . publicUserInfo ;%NWL%}%NWL%if ( args . noteStoreUrl ! =  = undefined )  {%NWL%this . noteStoreUrl = args . noteStoreUrl ;%NWL%}%NWL%if ( args . webApiUrlPrefix ! =  = undefined )  {%NWL%this . webApiUrlPrefix = args . webApiUrlPrefix ; %NWL%1
lodash . now = utilities . now ; %NWL%lodash . parseInt = utilities . parseInt ; %NWL%lodash . random = utilities . random ; %NWL%lodash . reduce = collections . reduce ; %NWL%lodash . reduceRight = collections . reduceRight ; %NWL%lodash . result = utilities . result ; %NWL%lodash . size = collections . size ; %NWL%lodash . some = collections . some ; %NWL%lodash . sortedIndex = arrays . sortedIndex ; %NWL%lodash . template = utilities . template ; %NWL%lodash . unescape = utilities . unescape ; %NWL%0
conf =  {%NWL%on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%e . pageX = data . pageX ; %NWL%8
}%NWL%}  )  )  ; %NWL%ensure ( wrapper )  ; %NWL%return wrapper ;%NWL%}  ; %NWL%exports . Loader = CustomLoader ; %NWL%function HookedPlainTextConsole ( hook , print , innerID )  {%NWL%this . log = hook . bind ( null ,  " log "  , innerID )  ; %NWL%this . info = hook . bind ( null ,  " info "  , innerID )  ; %NWL%this . warn = hook . bind ( null ,  " warn "  , innerID )  ; %NWL%this . error = hook . bind ( null ,  " error "  , innerID )  ; %NWL%7
if ( !entity . isAvailable ( time ) || !Property . getValueOrDefault ( wall . show , time , true )  )  {%NWL%return ;%NWL%}%NWL%var options = this . _options ; %NWL%var positions = Property . getValueOrUndefined ( wall . positions , time , options . positions )  ; %NWL%if ( !defined ( positions )  )  {%NWL%return ;%NWL%}%NWL%options . positions = positions ; %NWL%options . minimumHeights = Property . getValueOrUndefined ( wall . minimumHeights , time , options . minimumHeights )  ; %NWL%options . maximumHeights = Property . getValueOrUndefined ( wall . maximumHeights , time , options . maximumHeights )  ; %NWL%9
Lang = YAHOO . lang ,%NWL%FLASH_CID =  " clsid : d27cdb6e - ae6d - 11cf - 96b8 - 444553540000 "  ,%NWL%FLASH_TYPE =  " application / x - shockwave - flash "  ,%NWL%FLASH_VER =  " 10 . 22 "  ,%NWL%EXPRESS_INSTALL_URL =  " http :  /  / fpdownload . macromedia . com / pub / flashplayer / update / current / swf / autoUpdater . swf? "  + Math . random (  )  ,%NWL%EVENT_HANDLER =  " YAHOO . widget . SWF . eventHandler "  ,%NWL%possibleAttributes =  { align :  "  "  , allowfullscreen :  "  "  , allownetworking :  "  "  , allowscriptaccess :  "  "  , base :  "  "  , bgcolor :  "  "  , devicefont :  "  "  , loop :  "  "  , menu :  "  "  , name :  "  "  , play :  "  "  , quality :  "  "  , salign :  "  "  , seamlesstabbing :  "  "  , scale :  "  "  , swliveconnect :  "  "  , tabindex :  "  "  , wmode :  "  "  }  ; %NWL%YAHOO . widget . SWF = function ( p_oElement , swfURL , p_oAttributes  )  {%NWL%this . _queue = this . _queue || [  ]  ; %NWL%this . _events = this . _events || {  }  ; %NWL%this . _configs = this . _configs || {  }  ; %NWL%9
fnArraySwitch ( aiMapping , iFrom , iTo )  ; %NWL%var aiInvertMapping = fnInvertKeyValues ( aiMapping )  ; %NWL%for ( i = 0 , iLen = oSettings . aaSorting . length ; i < iLen ; i +  +  )%NWL%{%NWL%oSettings . aaSorting [ i ]  [ 0 ]  = aiInvertMapping [ oSettings . aaSorting [ i ]  [ 0 ]  ]  ;%NWL%}%NWL%if ( oSettings . aaSortingFixed ! =  = null )%NWL%{%NWL%for ( i = 0 , iLen = oSettings . aaSortingFixed . length ; i < iLen ; i +  +  )%NWL%{%NWL%oSettings . aaSortingFixed [ i ]  [ 0 ]  = aiInvertMapping [ oSettings . aaSortingFixed [ i ]  [ 0 ]  ]  ; %NWL%4
var tar = sys . id ( commandData )  ; %NWL%if ( !sys . uniqueId ( tar )  )  {%NWL%normalbot . sendMessage ( src ,  " Target doesn ' t have a unique ID ( update needed )  "  , channel )  ; %NWL%return ;%NWL%}%NWL%var id = sys . uniqueId ( tar )  . id ; %NWL%var psuedo = !sys . uniqueId ( tar )  . isUnique ; %NWL%var type =  ( command =  =  =  " idban " ? " banned "  :  " muted "  )  ; %NWL%var banInfo =  {  }  ; %NWL%banInfo . name = sys . name ( tar )  ; %NWL%banInfo . ip = sys . ip ( tar )  ; %NWL%9
" use strict "  ; %NWL%var Tilt = Tilt || {  }  ; %NWL%var EXPORTED_SYMBOLS =  [  " Tilt . Sprite "  ]  ; %NWL%Tilt . Sprite = function ( texture , region , properties )  {%NWL%Tilt . Profiler . intercept (  " Tilt . Sprite "  , this )  ; %NWL%properties = properties || {  }  ; %NWL%this . hidden = properties . hidden || false ; %NWL%this . disabled = properties . disabled || false ; %NWL%this . onmousedown = properties . onmousedown || undefined ; %NWL%this . onmouseup = properties . onmouseup || undefined ; %NWL%this . onclick = properties . onclick || undefined ; %NWL%8
goog . math . Vec2 . prototype . magnitude = function (  )  {%NWL%return Math . sqrt ( this . x * this . x + this . y * this . y )  ;%NWL%}  ; %NWL%goog . math . Vec2 . prototype . squaredMagnitude = function (  )  {%NWL%return this . x * this . x + this . y * this . y ;%NWL%}  ; %NWL%goog . math . Vec2 . prototype . scale =%NWL%( goog . math . Coordinate . prototype . scale )  ; %NWL%goog . math . Vec2 . prototype . invert = function (  )  {%NWL%this . x =  - this . x ; %NWL%this . y =  - this . y ; %NWL%9
component . withDefaults (  )  . shouldComponentUpdate . debug . should . be . a (  ' function '  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%describe (  ' debugger '  , function (  )  {%NWL%beforeEach ( function (  )  {%NWL%this . debug = console . debug ; %NWL%this . info = console . info ;%NWL%}  )  ; %NWL%afterEach ( function (  )  {%NWL%console . debug = this . debug ; %NWL%console . info = this . info ; %NWL%9
_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%_server_options . sslPass = object . rs_options . sslPass ;%NWL%} else if ( object . server_options . ssl )  {%NWL%_server_options . ssl = object . server_options . ssl ; %NWL%_server_options . sslValidate = object . server_options . sslValidate ; %NWL%_server_options . sslCA = object . server_options . sslCA ; %NWL%_server_options . sslCert = object . server_options . sslCert ; %NWL%_server_options . sslKey = object . server_options . sslKey ; %NWL%_server_options . sslPass = object . server_options . sslPass ; %NWL%5
this . profilerEnabled = this . createSetting (  " profilerEnabled "  , false )  ; %NWL%this . eventListenersFilter = this . createSetting (  " eventListenersFilter "  ,  " all "  )  ; %NWL%this . lastActivePanel = this . createSetting (  " lastActivePanel "  ,  " elements "  )  ; %NWL%this . lastViewedScriptFile = this . createSetting (  " lastViewedScriptFile "  ,  " application "  )  ; %NWL%this . monitoringXHREnabled = this . createSetting (  " monitoringXHREnabled "  , false )  ; %NWL%this . preserveConsoleLog = this . createSetting (  " preserveConsoleLog "  , false )  ; %NWL%this . resourcesLargeRows = this . createSetting (  " resourcesLargeRows "  , true )  ; %NWL%this . resourcesSortOptions = this . createSetting (  " resourcesSortOptions "  ,  { timeOption :  " responseTime "  , sizeOption :  " transferSize "  }  )  ; %NWL%this . resourceViewTab = this . createSetting (  " resourceViewTab "  ,  " preview "  )  ; %NWL%this . showInheritedComputedStyleProperties = this . createSetting (  " showInheritedComputedStyleProperties "  , false )  ; %NWL%this . showUserAgentStyles = this . createSetting (  " showUserAgentStyles "  , true )  ; %NWL%6
modKeys = eventDescriptor . modKeys || '  '  ,%NWL%xy ; %NWL%if (  ' x ' in eventDescriptor )  {%NWL%event . xy = xy = Ext . fly ( target )  . getXY (  )  ; %NWL%xy [ 0 ]  +  = eventDescriptor . x ; %NWL%xy [ 1 ]  +  = eventDescriptor . y ;%NWL%}%NWL%if (  ' wheel ' in eventDescriptor )  {%NWL%}%NWL%event . type = eventDescriptor . type ; %NWL%event . button = eventDescriptor . button ; %NWL%9
if ( props . again )  {%NWL%this . askFor (  )  ;%NWL%} else {%NWL%cb (  )  ;%NWL%}%NWL%}  . bind ( this )  )  ;%NWL%}  ; %NWL%ResourceGenerator . prototype . files = function files (  )  {%NWL%this . baseName = this . generatorConfig . baseName ; %NWL%this . packageName = this . generatorConfig . packageName ; %NWL%this . entities = this . generatorConfig . entities ; %NWL%8
} else {%NWL%other . push ( node )  ;%NWL%}%NWL%}  , this )  ; %NWL%if ( props . length )  {%NWL%var selfLiteral = new nodes . Literal (  ' & '  )  ; %NWL%selfLiteral . lineno = media . lineno ; %NWL%selfLiteral . filename = media . filename ; %NWL%var selfSelector = new nodes . Selector ( selfLiteral )  ; %NWL%selfSelector . lineno = media . lineno ; %NWL%selfSelector . filename = media . filename ; %NWL%9
air . NativeMenuItem = window . runtime . flash . display . NativeMenuItem ; %NWL%air . Screen = window . runtime . flash . display . Screen ; %NWL%air . Loader  = window . runtime . flash . display . Loader ; %NWL%air . Bitmap = window . runtime . flash . display . Bitmap ; %NWL%air . BitmapData = window . runtime . flash . display . BitmapData ; %NWL%air . Keyboard = window . runtime . flash . ui . Keyboard ; %NWL%air . KeyLocation = window . runtime . flash . ui . KeyLocation ; %NWL%air . Mouse = window . runtime . flash . ui . Mouse ; %NWL%air . ReferencesValidationSetting = window . runtime . flash . security . ReferencesValidationSetting ; %NWL%air . RevocationCheckSettings = window . runtime . flash . security . RevocationCheckSettings ; %NWL%air . SignatureStatus = window . runtime . flash . security . SignatureStatus ; %NWL%8
result . material = this . material ; %NWL%result . height = this . height ; %NWL%result . extrudedHeight = this . extrudedHeight ; %NWL%result . granularity = this . granularity ; %NWL%result . stRotation = this . stRotation ; %NWL%result . rotation = this . rotation ; %NWL%result . fill = this . fill ; %NWL%result . outline = this . outline ; %NWL%result . outlineColor = this . outlineColor ; %NWL%result . outlineWidth = this . outlineWidth ; %NWL%result . closeTop = this . closeTop ; %NWL%0
exports . createMultiplexServer = server . createMultiplexServer ; %NWL%var web_server = require (  '  .  / web_server '  )  ; %NWL%exports . createWebServer = web_server . createWebServer ; %NWL%exports . Int64 = require (  ' node - int64 '  )  ; %NWL%exports . Q = require (  ' q '  )  ; %NWL%var mprocessor = require (  '  .  / multiplexed_processor '  )  ; %NWL%var mprotocol = require (  '  .  / multiplexed_protocol '  )  ; %NWL%exports . Multiplexer = mprotocol . Multiplexer ; %NWL%exports . MultiplexedProcessor = mprocessor . MultiplexedProcessor ; %NWL%exports . TFramedTransport = require (  '  .  / transport '  )  . TFramedTransport ; %NWL%exports . TBufferedTransport = require (  '  .  / transport '  )  . TBufferedTransport ; %NWL%9
this . fillFileList (  ' out_list '  , fl )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%8
EDAMUserException = module . exports . EDAMUserException = function ( args )  {%NWL%Thrift . TException . call ( this ,  " EDAMUserException "  )%NWL%this . name =  " EDAMUserException "%NWL%this . errorCode = null ; %NWL%this . parameter = null ; %NWL%if ( args )  {%NWL%if ( args . errorCode ! =  = undefined )  {%NWL%this . errorCode = args . errorCode ;%NWL%}%NWL%if ( args . parameter ! =  = undefined )  {%NWL%this . parameter = args . parameter ; %NWL%7
for ( var i in options )  {%NWL%if ( params . options [ i ]  =  =  = undefined ) params . options [ i ]  = options [ i ]%NWL%}%NWL%return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . post = def ( request . post )%NWL%de . put = def ( request . put )%NWL%8
}  ,%NWL%reposition : function ( elem )  {%NWL%if ( elem )  {%NWL%this . domElement = ZeroClipboard_TableTools . $ ( elem )  ; %NWL%if ( !this . domElement ) this . hide (  )  ;%NWL%}%NWL%if ( this . domElement && this . div )  {%NWL%var box = ZeroClipboard_TableTools . getDOMObjectPosition ( this . domElement )  ; %NWL%var style = this . div . style ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%9
}  ; %NWL%eraseAllButton . onclick = function ( e )  {%NWL%context . clearRect ( 0 , 0 , canvas . width , canvas . height )  ; %NWL%drawGrid (  ' lightgray '  , 10 , 10 )  ; %NWL%saveDrawingSurface (  )  ;%NWL%}  ; %NWL%strokeStyleSelect . onchange = function ( e )  {%NWL%context . strokeStyle = strokeStyleSelect . value ;%NWL%}  ; %NWL%fillStyleSelect . onchange = function ( e )  {%NWL%context . fillStyle = fillStyleSelect . value ; %NWL%7
throw new Error (  " Brackets - shell is not a secure general purpose web browser . Use NativeApp . openURLInDefaultBrowser (  ) to open URLs in the user ' s main browser "  )  ;%NWL%}%NWL%return real_windowOpen . apply ( window , arguments )  ;%NWL%}  ; %NWL%var DefaultCtor = jQuery . fn . init ; %NWL%jQuery . fn . init = function ( firstArg , secondArg )  {%NWL%var jQObject = new DefaultCtor ( firstArg , secondArg )  ; %NWL%if ( firstArg && firstArg . _EventDispatcher )  {%NWL%jQObject . on  = firstArg . on . bind ( firstArg )  ; %NWL%jQObject . one = firstArg . one . bind ( firstArg )  ; %NWL%jQObject . off = firstArg . off . bind ( firstArg )  ; %NWL%8
if ( !self . element )  {%NWL%throw new Error (  ' element not found '  )  ;%NWL%}%NWL%if ( support . mspointer )  {%NWL%self . element . style . msTouchAction =  ' pan - y '  ;%NWL%}%NWL%opts = opts || {  }  ; %NWL%self . distance = opts . distance ; %NWL%self . maxPoint = opts . maxPoint ; %NWL%self . disableTouch =  ( opts . disableTouch =  =  = undefined ) ? false : opts . disableTouch ; %NWL%self . disable3d =  ( opts . disable3d =  =  = undefined ) ? false : opts . disable3d ; %NWL%9
}%NWL%}  ;%NWL%}%NWL%ReconnectingWebSocket . prototype . onopen = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onclose = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onconnecting = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onmessage = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onerror = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . debugAll = false ; %NWL%ReconnectingWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%ReconnectingWebSocket . OPEN = WebSocket . OPEN ; %NWL%9
started = !started ;%NWL%}%NWL%function setupClock (  )  {%NWL%" use strict "  ; %NWL%var opts  = $ [ deck ]  (  ' getOptions '  )  ; %NWL%if ( !opts . clock . enable )  {%NWL%$ ( opts . selectors . clock )  . remove (  )  ; %NWL%return ;%NWL%}%NWL%dom . toggle  = $ ( opts . selectors . toggle )  ; %NWL%dom . time  = $ ( opts . selectors . time )  ; %NWL%9
'  < button class =  " done "  > Done <  / button >  '  +%NWL%'  < button class =  " revert "  > Revert <  / button >  '  +%NWL%'  < button class =  " backward " title =  " Go backward in time "  >  < img src =  " img / backward . png " alt =  " Backward "  >  <  / button >  '  +%NWL%'  < button class =  " forward " title =  " Go forward in time "  >  < img src =  " img / forward . png " alt =  " Forward "  >  <  / button >  '  +%NWL%'  < div class =  " no - previous "  > There are no previous versions for this file .  <  / div >  '  ; %NWL%galaxyBackground . now = $ (  "  . now "  , galaxyBackground )  [ 0 ]  ; %NWL%galaxyBackground . then = $ (  "  . then "  , galaxyBackground )  [ 0 ]  ; %NWL%galaxyBackground . done = $ (  "  . done "  , galaxyBackground )  [ 0 ]  ; %NWL%galaxyBackground . revert = $ (  "  . revert "  , galaxyBackground )  [ 0 ]  ; %NWL%galaxyBackground . backward = $ (  "  . backward "  , galaxyBackground )  [ 0 ]  ; %NWL%galaxyBackground . forward = $ (  "  . forward "  , galaxyBackground )  [ 0 ]  ; %NWL%5
Thoth . Store = require ( corePath +  '  / Store '  )  . Store ; %NWL%Thoth . WrapperStore = require ( corePath +  '  / WrapperStore '  )  . WrapperStore ; %NWL%Thoth . ApplicationStore = require ( corePath +  '  / ApplicationStore '  )  . ApplicationStore ; %NWL%Thoth . MemStore = require ( corePath +  '  / MemStore '  )  . MemStore ; %NWL%Thoth . DiskStore = require ( corePath +  '  / DiskStore '  )  . DiskStore ; %NWL%Thoth . Server = require ( corePath +  '  / Server '  )  . Server ; %NWL%Thoth . RPCHooks = require ( corePath +  '  / RPCHooks '  )  . RPCHooks ; %NWL%Thoth . Policies = require ( corePath +  '  / Policies '  )  . Policies ; %NWL%Thoth . PolicyModel = require ( corePath +  '  / PolicyModel '  )  . PolicyModel ; %NWL%Thoth . log = sys . log ; %NWL%Thoth . inspect = sys . inspect ; %NWL%9
this . diskNumberStart   = reader . readInt ( 2 )  ; %NWL%this . internalFileAttributes = reader . readInt ( 2 )  ; %NWL%this . externalFileAttributes = reader . readInt ( 4 )  ; %NWL%this . localHeaderOffset   = reader . readInt ( 4 )  ; %NWL%if ( this . isEncrypted (  )  )  {%NWL%throw new Error (  " Encrypted zip are not supported "  )  ;%NWL%}%NWL%this . fileName = reader . readString ( this . fileNameLength )  ; %NWL%this . readExtraFields ( reader )  ; %NWL%this . parseZIP64ExtraField ( reader )  ; %NWL%this . fileComment = reader . readString ( this . fileCommentLength )  ; %NWL%7
key : options . key ,%NWL%secret : options . secret ,%NWL%cookie :  {  }%NWL%}  ; %NWL%if (  " proxy " in options )%NWL%sessionOptions . proxy = options . proxy ; %NWL%var cookie = sessionOptions . cookie ; %NWL%if (  " secure " in options )%NWL%cookie . secure = options . secure ; %NWL%if (  " maxAge " in options )%NWL%cookie . maxAge = options . maxAge ; %NWL%8
this . update = function ( config )  {%NWL%this . config = config ; %NWL%if ( this . session . selectionMarkerCount > 0 )  {%NWL%var selections = this . session . $selectionMarkers ; %NWL%var i = 0 , sel , cursorIndex = 0 ; %NWL%for ( var i = selections . length ; i -  -  ;  )  {%NWL%sel = selections [ i ]  ; %NWL%var pixelPos = this . getPixelPosition ( sel . cursor , true )  ; %NWL%var style =  ( this . cursors [ cursorIndex +  +  ] || this . addCursor (  )  )  . style ; %NWL%style . left = pixelPos . left +  " px "  ; %NWL%style . top = pixelPos . top +  " px "  ; %NWL%9
}  ; %NWL%exports . substitute = function substitute ( cb )  {%NWL%this . callee = cb ( this . callee ,  ' callee '  ) || this . callee ; %NWL%this . params = this . params . map ( function ( stmt )  {%NWL%return cb ( stmt ,  ' params '  )  ;%NWL%}  )  . filter ( ident )  ;%NWL%}  ; %NWL%exports . getType = function getType ( ctx )  {%NWL%return this . callee . getType ( ctx )  . getReturnType (  )  ;%NWL%}  ; %NWL%exports . validateTypes = function validateTypes ( ctx )  {%NWL%7
!Property . isConstant ( cornerType )  )  {%NWL%if ( !this . _dynamic )  {%NWL%this . _dynamic = true ; %NWL%this . _geometryChanged . raiseEvent ( this )  ;%NWL%}%NWL%} else {%NWL%var options = this . _options ; %NWL%options . vertexFormat = isColorMaterial ? PerInstanceColorAppearance . VERTEX_FORMAT : MaterialAppearance . MaterialSupport . TEXTURED . vertexFormat ; %NWL%options . positions = positions . getValue ( Iso8601 . MINIMUM_VALUE , options . positions )  ; %NWL%options . height = defined ( height ) ? height . getValue ( Iso8601 . MINIMUM_VALUE )  : undefined ; %NWL%options . extrudedHeight = defined ( extrudedHeight ) ? extrudedHeight . getValue ( Iso8601 . MINIMUM_VALUE )  : undefined ; %NWL%9
this . nomount = !!options . nomount%NWL%if ( !pattern )  {%NWL%throw new Error (  " must provide pattern "  )%NWL%}%NWL%if ( options . matchBase && - 1 =  =  = pattern . indexOf (  "  /  "  )  )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . dot = !!options . dot%NWL%0
var Node = module . require (  "  .  / Node "  )  . Node ; %NWL%function Range ( start , operator , to )  {%NWL%Node . call ( this )  ; %NWL%this . type =  " Range "  ; %NWL%this . operator = operator ; %NWL%this . start = start ; %NWL%if ( typeof this . start ! =  =  " undefined " && this . start ! =  = null )  {%NWL%this . start . parent = this ;%NWL%}%NWL%this . to = to ; %NWL%if ( typeof this . to ! =  =  " undefined " && this . to ! =  = null )  {%NWL%6
each (  [  ' Function '  ,  ' Object '  ,  ' Array '  ]  , function ( name )  {%NWL%typeChecks [  ' is '  + name ]  = function ( obj )  {%NWL%return toString . call ( obj )  =  =  '  [ object '  + name +  '  ]  '  ;%NWL%}  ;%NWL%}  )  ; %NWL%exports . each = each ; %NWL%exports . map = map ; %NWL%exports . isFunction = typeChecks . isFunction ; %NWL%exports . isObject = typeChecks . isObject ; %NWL%exports . isArray = typeChecks . isArray ; %NWL%exports . isFactory = typeChecks . isFactory ; %NWL%7
_src =  '  '  ;%NWL%}%NWL%}  ,%NWL%enumerable : true%NWL%}%NWL%}  )  ;%NWL%}%NWL%platform . createCanvas = function createCanvasMock (  )  {%NWL%return {  }  ;%NWL%}  ; %NWL%platform . createImage = function createImageMock (  )  {%NWL%7
Vector = require (  ' burner '  )  . Vector ; %NWL%function Mover ( opt_options )  {%NWL%Item . call ( this )  ;%NWL%}%NWL%Utils . extend ( Mover , Item )  ; %NWL%Mover . prototype . init = function ( world , opt_options )  {%NWL%Mover . _superClass . init . call ( this , world , opt_options )  ; %NWL%var options = opt_options || {  }  ; %NWL%this . color = options . color || [ 255 , 255 , 255 ]  ; %NWL%this . borderRadius = options . borderRadius || 0 ; %NWL%this . borderWidth = options . borderWidth || 0 ; %NWL%9
elem = sb . create (  " div "  )  ; %NWL%var imgPanel = sb . create (  " div "  )  ; %NWL%imgPanel . setAttribute (  " style "  , data . panelAtt )  ; %NWL%var img = new Image (  )  ; %NWL%img . src = data . value ; %NWL%elem . appendChild ( img )  ; %NWL%elem . appendChild ( imgPanel )  ; %NWL%elem . setAttribute (  " style "  , data . cAttr )  ; %NWL%img . style [  " borderTopLeftRadius "  ]  = elem . style [  " borderTopLeftRadius "  ]  ; %NWL%img . style [  " borderTopRightRadius "  ]  = elem . style [  " borderTopRightRadius "  ]  ; %NWL%img . style [  " borderBottompLeftRadius "  ]  = elem . style [  " borderBottompLeftRadius "  ]  ; %NWL%8
}%NWL%}  )  ; %NWL%setTimeout ( function (  )  { server . bind ( node . port , node . iface )  ;  }  , 250 )  ;%NWL%}%NWL%RED . nodes . registerType (  " udp in "  , UDPin )  ; %NWL%function UDPout ( n )  {%NWL%RED . nodes . createNode ( this , n )  ; %NWL%this . port = n . port ; %NWL%this . outport = n . outport|| "  "  ; %NWL%this . base64 = n . base64 ; %NWL%this . addr = n . addr ; %NWL%7
component : undefined ,%NWL%defaults :  {%NWL%" index "  : null /  / int ( equal to this . index )%NWL%}  ,%NWL%actions : undefined ,%NWL%initialize : function ( attributes , options )  {%NWL%options = options || {  }  ; %NWL%this . category = options . category ; %NWL%this . index = options . index ; %NWL%this . component = options . component ; %NWL%this . actions = options . actions ; %NWL%7
Vizi . PickManager . clickedObject = null ;%NWL%}%NWL%Vizi . PickManager . handleTouchStart = function ( event )%NWL%{%NWL%if ( event . touches . length > 0 )  {%NWL%event . screenX = event . touches [ 0 ]  . screenX ; %NWL%event . screenY = event . touches [ 0 ]  . screenY ; %NWL%event . clientX = event . touches [ 0 ]  . clientX ; %NWL%event . clientY = event . touches [ 0 ]  . clientY ; %NWL%event . pageX = event . touches [ 0 ]  . pageX ; %NWL%event . pageY = event . touches [ 0 ]  . pageY ; %NWL%5
self . lineno = m . lineno ; %NWL%self . row = m . row ; %NWL%break ;%NWL%} else if ( m . cur =  =  = self . cur )  {%NWL%m . result = result ; %NWL%break ;%NWL%} else {%NWL%m . result = result ; %NWL%m . cur = self . cur ; %NWL%m . lineno = self . lineno ; %NWL%m . row = self . row ; %NWL%8
this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . locales = obj . locales ;%NWL%}  ; %NWL%cubes . Measure = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%0
}%NWL%}  )  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%exports . updateAccount = function ( newData , callback )%NWL%{%NWL%accounts . findOne (  { user : newData . user }  , function ( e , o )  {%NWL%o . name 		 = newData . name ; %NWL%o . email 	 = newData . email ; %NWL%o . country 	 = newData . country ; %NWL%8
}  . bind ( this )  )  ; %NWL%dialog . open (  { native : $ . System . Windows . Application . Current . MainWindow }  )  ;%NWL%}  ; %NWL%item . addEventListener (  ' PreviewMouseDown '  , item . previewMouseDown . bind ( this )  )  ; %NWL%item . Header =  " Choose .  .  .  "  ; %NWL%return item ;%NWL%}%NWL%function FileInput ( options )  {%NWL%options = options || {  }  ; %NWL%this . nativeClass = this . nativeClass || $ . System . Windows . Controls . ComboBox ; %NWL%this . nativeViewClass = this . nativeViewClass || $ . System . Windows . Controls . ComboBox ; %NWL%9
}%NWL%this . el = null ; %NWL%this . childrenRendered = false ; %NWL%this . rendered = false ; %NWL%YAHOO . ext . tree . TreeNode . superclass . constructor . call ( this , attributes )  ; %NWL%this . expanded = attributes . expanded =  =  = true ; %NWL%this . isTarget = attributes . isTarget ! =  = false ; %NWL%this . draggable = attributes . draggable ! =  = false && attributes . allowDrag ! =  = false ; %NWL%this . allowChildren = attributes . allowChildren ! =  = false && attributes . allowDrop ! =  = false ; %NWL%this . text = attributes . text ; %NWL%this . disabled = attributes . disabled =  =  = true ; %NWL%5
uritemplate = require (  ' uritemplate '  )  ; %NWL%nodes = require (  '  .  / nodes '  )  ; %NWL%util = require (  '  .  / util '  )  ; %NWL%this . Transformations =  ( function (  )  {%NWL%function Transformations ( settings )  {%NWL%this . settings = settings ; %NWL%this . isContentTypeString = __bind ( this . isContentTypeString , this )  ; %NWL%this . add_key_value_to_node = __bind ( this . add_key_value_to_node , this )  ; %NWL%this . apply_default_media_type_to_resource = __bind ( this . apply_default_media_type_to_resource , this )  ; %NWL%this . get_media_type = __bind ( this . get_media_type , this )  ; %NWL%this . load_default_media_type = __bind ( this . load_default_media_type , this )  ; %NWL%6
return angular . extend (  {  }  , options )  ;%NWL%}%NWL%}  ; %NWL%EventBusStub . reconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . reconnect "  ; %NWL%EventBusStub . close . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . close "  ; %NWL%EventBusStub . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . login "  ; %NWL%EventBusStub . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . send "  ; %NWL%EventBusStub . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . publish "  ; %NWL%EventBusStub . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . registerHandler "  ; %NWL%EventBusStub . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . unregisterHandler "  ; %NWL%EventBusStub . readyState . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . readyState "  ; %NWL%3
this . config . fakeDirection = this . config . fakeDirection || [  - this . config . direction [ 0 ]  ,  - this . config . direction [ 1 ]  ]  ; %NWL%this . config . className = this . config . className || CSS_PREFIX +  ' Terminal '  ; %NWL%this . config . connectedClassName = this . config . connectedClassName || CSS_PREFIX +  ' Terminal - connected '  ; %NWL%this . config . dropinviteClassName = this . config . dropinviteClassName || CSS_PREFIX +  ' Terminal - dropinvite '  ; %NWL%this . config . editable = YAHOO . lang . isUndefined ( this . config . editable ) ? true : this . config . editable ; %NWL%this . config . nMaxWires = this . config . nMaxWires || Infinity ; %NWL%this . config . wireConfig = this . config . wireConfig || {  }  ; %NWL%this . config . editingWireConfig = this . config . editingWireConfig || this . config . wireConfig ; %NWL%this . config . alwaysSrc = this . config . alwaysSrc || false ; %NWL%this . eventAddWire = new YAHOO . util . CustomEvent (  " eventAddWire "  )  ; %NWL%this . eventRemoveWire = new YAHOO . util . CustomEvent (  " eventRemoveWire "  )  ; %NWL%9
}%NWL%}%NWL%Vizi . PickManager . handleTouchEnd = function ( event )%NWL%{%NWL%if ( event . changedTouches . length > 0 )  {%NWL%event . screenX = event . changedTouches [ 0 ]  . screenX ; %NWL%event . screenY = event . changedTouches [ 0 ]  . screenY ; %NWL%event . clientX = event . changedTouches [ 0 ]  . clientX ; %NWL%event . clientY = event . changedTouches [ 0 ]  . clientY ; %NWL%event . pageX = event . changedTouches [ 0 ]  . pageX ; %NWL%event . pageY = event . changedTouches [ 0 ]  . pageY ; %NWL%5
this . data [ this . dataPos +  +  ]  = x ; %NWL%this . data [ this . dataPos +  +  ]  = y ; %NWL%this . segments [ this . segmentsPos +  +  ]  = vg . VGPathCommand . VG_HLINE_TO_REL ; %NWL%this . data [ this . dataPos +  +  ]  = w ; %NWL%this . segments [ this . segmentsPos +  +  ]  = vg . VGPathCommand . VG_VLINE_TO_REL ; %NWL%this . data [ this . dataPos +  +  ]  = h ; %NWL%this . segments [ this . segmentsPos +  +  ]  = vg . VGPathCommand . VG_HLINE_TO_REL ; %NWL%this . data [ this . dataPos +  +  ]  =  - w ; %NWL%this . segments [ this . segmentsPos +  +  ]  = vg . VGPathSegment . VG_CLOSE_PATH ; %NWL%this . x = this . sx = x ; %NWL%this . y = this . sy = y ; %NWL%9
' i18n!orion / edit / nls / messages '  ,%NWL%' orion / search / InlineSearchPane '  ,%NWL%' orion / keyBinding '  ,%NWL%' orion / webui / Slideout '  ]  ,%NWL%function ( objects , mCommands , mOutliner , lib , MiniNavViewMode , ProjectNavViewMode , mGlobalCommands , messages , InlineSearchPane , mKeyBinding , mSlideout )  {%NWL%function Sidebar ( params )  {%NWL%this . params = params ; %NWL%this . preferences = params . preferences ; %NWL%this . commandRegistry = params . commandRegistry ; %NWL%this . contentTypeRegistry = params . contentTypeRegistry ; %NWL%this . fileClient = params . fileClient ; %NWL%7
var concSplit = self . options [  '  - c '  ]  . split (  '  .  .  '  )  ; %NWL%self . concurrentStart =  + concSplit [ 0 ]  ; %NWL%self . concurrentEnd =  + concSplit [ 1 ]  ; %NWL%if ( self . concurrentEnd < self . concurrentStart )  {%NWL%console . log (  " Concurrents x .  . y : y cannot be less than x "  )  ; %NWL%return self . cleanup (  )  ;%NWL%}%NWL%}%NWL%else {%NWL%self . concurrentStart =  + self . concurrentStart ; %NWL%self . concurrentEnd =  + self . concurrentEnd ; %NWL%9
this . ovmap . zoomToMaxExtent (  )  ; %NWL%this . wComp = parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - left - width '  )  )  +%NWL%parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - right - width '  )  )  ; %NWL%this . wComp =  ( this . wComp ) ? this . wComp : 2 ; %NWL%this . hComp = parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - top - width '  )  )  +%NWL%parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - bottom - width '  )  )  ; %NWL%this . hComp =  ( this . hComp ) ? this . hComp : 2 ; %NWL%5
json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%this . out_sy = json . out_sy ; %NWL%this . layer_type = json . layer_type ; %NWL%7
if ( file . mime =  =  ' application / x - empty '  )  {%NWL%info . mime =  ' text / plain '  ;%NWL%}%NWL%if ( file . linkTo )  {%NWL%info . alias = file . linkTo ;%NWL%}%NWL%if ( file . linkTo )  {%NWL%info . linkTo = file . linkTo ;%NWL%}%NWL%if ( file . tmb )  {%NWL%info . tmb = file . tmb ; %NWL%7
( function (  )  {%NWL%var surface , surfaceNode ; %NWL%dojox . drawing . manager . Stencil = dojox . drawing . util . oo . declare (%NWL%function ( options )  {%NWL%surface = options . surface ; %NWL%this . canvas = options . canvas ; %NWL%this . defaults = dojox . drawing . defaults . copy (  )  ; %NWL%this . undo = options . undo ; %NWL%this . mouse = options . mouse ; %NWL%this . keys = options . keys ; %NWL%this . anchors = options . anchors ; %NWL%5
}  ,  {%NWL%type :  ' confirm '  ,%NWL%name :  ' tpl '  ,%NWL%message :  ' Would you like to create a template with your View? '  ,%NWL%default : false%NWL%}%NWL%]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%this . initName = props . initName ; %NWL%this . srcPath = pg . cleanupPath ( props . srcPath )  ; %NWL%this . path = pg . cleanupPath ( props . path )  ; %NWL%9
link : function ( scope )  {%NWL%scope . yAxisTickFormat = D3Service . yAxisPercentageTickFormat ; %NWL%scope . xAxisTickFormat = D3Service . xAxisTickFormat ; %NWL%scope . yFunction = D3Service . yFunction ; %NWL%scope . xFunction = D3Service . xFunction ; %NWL%scope . id = D3Service . getId (  )  ; %NWL%scope . height = 250 ; %NWL%scope . flags = $rootScope . flags ; %NWL%scope . $on (  ' widgetResized '  , function ( event , size )  {%NWL%scope . width = size . width || scope . width ; %NWL%scope . height = size . height || scope . height ; %NWL%9
createTextNode : function (  )  { return document . createTextNode . apply ( document , arguments )  ;  }  ,%NWL%timer : new jasmine . Timer (  )%NWL%}  )  ; %NWL%htmlReporter . initialize (  )%NWL%env . addReporter ( jasmineInterface . jsApiReporter )  ; %NWL%env . addReporter ( htmlReporter )  ; %NWL%addJasmineReporters ( jasmineInterface , env )  ; %NWL%window . setTimeout = window . setTimeout ; %NWL%window . setInterval = window . setInterval ; %NWL%window . clearTimeout = window . clearTimeout ; %NWL%window . clearInterval = window . clearInterval ; %NWL%7
url +  =  ' ? '  + params ;%NWL%} else {%NWL%url +  =  ' & '  + params ;%NWL%}%NWL%} else if (  ' POST '  =  =  = method || ' PUT '  =  =  = method )  {%NWL%ioConfig . data = params ;%NWL%}%NWL%}%NWL%if ( config )  {%NWL%ioConfig . headers = config . headers ; %NWL%ioConfig . timeout = config . timeout ; %NWL%9
function act ( c )  {%NWL%c . mock = mock ; %NWL%c . table =  {  }  ; %NWL%c . initialDto =  {  }  ; %NWL%c . dto =  {  }  ; %NWL%c . mapFields = requireMock (  '  .  / mapFields '  )  ; %NWL%c . newSingleRelatedToDto = requireMock (  '  .  / newSingleRelatedToDto '  )  ; %NWL%c . newManyRelatedToDto = requireMock (  '  .  / newManyRelatedToDto '  )  ; %NWL%c . promise = requireMock (  '  .  .  /  .  .  / promise '  )  ; %NWL%c . extractDto = requireMock (  '  .  / newToDto / extractDto '  )  ; %NWL%c . resultToPromise = requireMock (  '  .  .  /  .  .  / resultToPromise '  )  ; %NWL%8
boxClass :  ' wow '  ,%NWL%animateClass :  ' animated '  ,%NWL%offset : 0 ,%NWL%mobile : true%NWL%}  ; %NWL%function WOW ( options )  {%NWL%if ( options =  = null )  {%NWL%options =  {  }  ;%NWL%}%NWL%this . scrollCallback = __bind ( this . scrollCallback , this )  ; %NWL%this . scrollHandler = __bind ( this . scrollHandler , this )  ; %NWL%9
gl . bufferData ( gl . ARRAY_BUFFER , data . buffer , gl . STATIC_DRAW )  ; %NWL%function onTextureLoaded ( texture , i )  {%NWL%_objects [ i ]  . texture  = texture ; %NWL%_objects [ i ]  . complete = true ;%NWL%}%NWL%for ( i = 0 ; i < count ;  +  + i )  {%NWL%if ( !_objects [ i ]  )  {%NWL%_objects [ i ]  =  {  }  ;%NWL%}%NWL%_objects [ i ]  . vertCount  = data . infos [ i ]  . vertCount ; %NWL%_objects [ i ]  . vertOffset = data . infos [ i ]  . vertOffset ; %NWL%9
draw : dcl . superCall ( function ( sup )  {%NWL%return function ( ctx , scale )  {%NWL%scale = scale || this . scale || 1 ; %NWL%var ogLineWidth = ctx . lineWidth ; %NWL%ctx . lineWidth = this . lineWidth ; %NWL%ctx . save (  )  ; %NWL%ctx . translate ( this . x * scale , this . y * scale )  ; %NWL%ctx . rotate ( this . angle )  ; %NWL%ctx . translate (  -  ( this . x )  * scale ,  -  ( this . y )  * scale )  ; %NWL%ctx . fillStyle = this . fillStyle ; %NWL%ctx . strokeStyle = this . strokeStyle ; %NWL%4
Fast . apply = Fast [  ' function '  ]  . apply ; %NWL%Fast . bind = Fast [  ' function '  ]  . bind ; %NWL%Fast . partial = Fast [  ' function '  ]  . partial ; %NWL%Fast . partialConstructor = Fast [  ' function '  ]  . partialConstructor ; %NWL%Fast [  ' try '  ]  = Fast . attempt = Fast [  ' function '  ]  [  ' try '  ]  ; %NWL%Fast . assign = Fast . object . assign ; %NWL%Fast . cloneObject = Fast . object . clone ;  /  / @deprecated use fast . object . clone (  )%NWL%Fast . keys = Fast . object . keys ; %NWL%Fast . values = Fast . object . values ; %NWL%Fast . clone = require (  '  .  / clone '  )  ; %NWL%Fast . map = require (  '  .  / map '  )  ; %NWL%9
ttl : 10%NWL%}  ; %NWL%for ( key in defaults )  {%NWL%if ( key in opts ) continue ; %NWL%opts [ key ]  = defaults [ key ]  ;%NWL%}%NWL%this . host = host ; %NWL%this . admin = opts . admin ; %NWL%this . serial = opts . serial ; %NWL%this . refresh = opts . refresh ; %NWL%this . retry = opts . retry ; %NWL%7
state = GenStateCompleted ; %NWL%if ( method =  =  =  " next "  )  {%NWL%context . dispatchException ( thrown )  ;%NWL%} else {%NWL%arg = thrown ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%generator . next = invoke . bind ( generator ,  " next "  )  ; %NWL%generator . throw = invoke . bind ( generator ,  " throw "  )  ; %NWL%9
arguments :  [ $scope . username ]%NWL%}  ,  {%NWL%method :  ' POST '  ,%NWL%success : function ( response )  {%NWL%$scope . isReply = true ; %NWL%value = JSON . parse ( response [  ' value '  ]  )  ; %NWL%$scope . id = value [  ' id '  ]  ; %NWL%$scope . name = value [  ' name '  ]  ; %NWL%$scope . screenName = value [  ' screenName '  ]  ; %NWL%$scope . location = value [  ' location '  ]  ; %NWL%$scope . description = value [  ' description '  ]  ; %NWL%6
if ( onmouseoutsrc ! =  "  " && tinyMCE . getParam (  ' convert_urls '  )  )%NWL%onmouseoutsrc = convertURL ( onmouseoutsrc , elm , true )  ; %NWL%var style = tinyMCE . parseStyle ( tinyMCE . getAttrib ( elm ,  " style "  )  )  ; %NWL%orgImageWidth = trimSize ( getStyle ( elm ,  ' width '  )  )%NWL%orgImageHeight = trimSize ( getStyle ( elm ,  ' height '  )  )  ; %NWL%formObj . src . value  = src ; %NWL%formObj . alt . value  = tinyMCE . getAttrib ( elm ,  ' alt '  )  ; %NWL%formObj . title . value  = tinyMCE . getAttrib ( elm ,  ' title '  )  ; %NWL%formObj . border . value = trimSize ( getStyle ( elm ,  ' border '  ,  ' borderWidth '  )  )  ; %NWL%formObj . vspace . value = tinyMCE . getAttrib ( elm ,  ' vspace '  )  ; %NWL%formObj . hspace . value = tinyMCE . getAttrib ( elm ,  ' hspace '  )  ; %NWL%6
return false ; %NWL%xajax . debug . writeMessage (  ' Retry count exceeded .  '  )  ; %NWL%return false ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%xajax . debug . isLoaded = true ; %NWL%xjx =  {  }%NWL%xjx . $ = xajax . tools . $ ; %NWL%xjx . getFormValues = xajax . tools . getFormValues ; %NWL%9
}%NWL%}%NWL%if ( fromCount )%NWL%{%NWL%if ( this . _display . begin )%NWL%{%NWL%from . display = this . _display . begin ;%NWL%}%NWL%if ( this . _visibility . begin )%NWL%{%NWL%from . visibility = this . _visibility . begin ; %NWL%6
lastColumnWidth : this . lastColumnWidth%NWL%}  )  ;%NWL%}  ; %NWL%DocumentContext . prototype . endDetachedBlock = function (  )  {%NWL%var saved = this . snapshots . pop (  )  ; %NWL%this . x = saved . x ; %NWL%this . y = saved . y ; %NWL%this . availableWidth = saved . availableWidth ; %NWL%this . availableHeight = saved . availableHeight ; %NWL%this . page = saved . page ; %NWL%this . endingCell = saved . endingCell ; %NWL%5
if ( type =  =  =  " provider "  )  {%NWL%newUser . isOutpatientDoctor =  " true "  ;%NWL%}%NWL%else if ( type =  =  =  " patient " && formp . donateOrgans )  {%NWL%newUser . donateOrgans =  " true "%NWL%}%NWL%if ( formp . email )  {%NWL%newUser . email = formp . email ;%NWL%}%NWL%if ( formp . phone )  {%NWL%newUser . phone = formp . phone ; %NWL%7
function setArrowNonce ( window , n )  {%NWL%randomize_ids = true ; %NWL%arrowprefix = prefix + n +  ' _ '  ; %NWL%pathdata . fw . id = arrowprefix +  ' fw '  ; %NWL%pathdata . bk . id = arrowprefix +  ' bk '  ;%NWL%}%NWL%function unsetArrowNonce ( window )  {%NWL%randomize_ids = false ; %NWL%arrowprefix = prefix ; %NWL%pathdata . fw . id = arrowprefix +  ' fw '  ; %NWL%pathdata . bk . id = arrowprefix +  ' bk '  ; %NWL%3
for ( prop in style . style )  {%NWL%if ( result . style [ prop ]  =  =  = undefined )  {%NWL%result . style [ prop ]  = style . style [ prop ]  ;%NWL%}%NWL%}%NWL%}%NWL%if ( style . attributes )  {%NWL%if ( !result . attributes )  { result . attributes  =  {  }  ;  }%NWL%for ( prop in style . attributes )  {%NWL%if ( result . attributes [ prop ]  =  =  = undefined )  {%NWL%result . attributes [ prop ]  = style . attributes [ prop ]  ; %NWL%2
process . domain = null ; %NWL%process . _exiting = false ;%NWL%}  ; %NWL%startup . globalTimeouts = function (  )  {%NWL%const timers = NativeModule . require (  ' timers '  )  ; %NWL%global . clearImmediate = timers . clearImmediate ; %NWL%global . clearInterval = timers . clearInterval ; %NWL%global . clearTimeout = timers . clearTimeout ; %NWL%global . setImmediate = timers . setImmediate ; %NWL%global . setInterval = timers . setInterval ; %NWL%global . setTimeout = timers . setTimeout ; %NWL%5
this . table = options . table ;%NWL%}  ; %NWL%util . inherits ( error . ExclusionConstraintError , error . DatabaseError )  ; %NWL%error . DatabaseError . prototype . message ; %NWL%error . DatabaseError . prototype . fields ; %NWL%error . DatabaseError . prototype . value ; %NWL%error . DatabaseError . prototype . index ; %NWL%error . ValidationErrorItem = function ( message , type , path , value )  {%NWL%this . message = message || '  '  ; %NWL%this . type = type || null ; %NWL%this . path = path || null ; %NWL%9
}%NWL%}%NWL%else {%NWL%this . source = options . source ;%NWL%}%NWL%}%NWL%if ( options . repeat )  {%NWL%this . repeat = options . repeat ;%NWL%}%NWL%if ( options . offsetX )  {%NWL%this . offsetX = options . offsetX ; %NWL%3
var connection = require (  '  .  / connection '  )  ; %NWL%exports . Connection = connection . Connection ; %NWL%exports . createClient = connection . createClient ; %NWL%exports . createConnection = connection . createConnection ; %NWL%exports . createSSLConnection = connection . createSSLConnection ; %NWL%exports . createStdIOClient = connection . createStdIOClient ; %NWL%exports . createStdIOConnection = connection . createStdIOConnection ; %NWL%var httpConnection = require (  '  .  / http_connection '  )  ; %NWL%exports . HttpConnection = httpConnection . HttpConnection ; %NWL%exports . createHttpConnection = httpConnection . createHttpConnection ; %NWL%exports . createHttpClient = httpConnection . createHttpClient ; %NWL%8
}%NWL%return - Math . log ( this . es [ y ]  )  ;%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%8
this . _rowCount = rowCount ; %NWL%this . _position = 0 ; %NWL%this . _contentHeight = rowCount * defaultRowHeight ; %NWL%this . _defaultRowHeight = defaultRowHeight ; %NWL%this . _rowHeightGetter = rowHeightGetter ?%NWL%rowHeightGetter :%NWL%(  )  =  > defaultRowHeight ; %NWL%this . _viewportHeight = viewportHeight ; %NWL%this . scrollRowIntoView = this . scrollRowIntoView . bind ( this )  ; %NWL%this . setViewportHeight = this . setViewportHeight . bind ( this )  ; %NWL%this . scrollBy = this . scrollBy . bind ( this )  ; %NWL%8
if ( typeof resolver =  =  =  ' function '  )  {%NWL%return resolver ( domain , callback )  ;%NWL%} else {%NWL%throw new Error (  ' Unknown type "  '  + type_ +  '  "  '  )  ;%NWL%}%NWL%}  ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%6
' use strict '  ; %NWL%var jws = require (  ' jws '  )  ; %NWL%var fs = require (  ' fs '  )  ; %NWL%var request = require (  ' request '  )  ; %NWL%var GAPI = function ( options , callback )  {%NWL%this . token = null ; %NWL%this . token_expires = null ; %NWL%this . iss = options . iss ; %NWL%this . scope = options . scope ; %NWL%this . sub = options . sub ; %NWL%this . prn = options . prn ; %NWL%7
' use strict '  ; %NWL%var prepareBlob = require (  ' lib / prepare - preview - blob '  )  ; %NWL%var debug = require (  ' debug '  )  (  ' controller : confirm '  )  ; %NWL%var ConfirmView = require (  ' views / confirm '  )  ; %NWL%var bindAll = require (  ' lib / bind - all '  )  ; %NWL%module . exports = function ( options )  { return new ConfirmController ( options )  ;  }  ; %NWL%module . exports . ConfirmController = ConfirmController ; %NWL%function ConfirmController ( app )  {%NWL%this . app = app ; %NWL%this . settings = app . settings ; %NWL%this . activity = app . activity ; %NWL%9
if ( this . userId ! =  = null && this . userId ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' userId '  , Thrift . Type . I32 , 1 )  ; %NWL%output . writeI32 ( this . userId )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . shardId ! =  = null && this . shardId ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' shardId '  , Thrift . Type . STRING , 2 )  ; %NWL%output . writeString ( this . shardId )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . privilege ! =  = null && this . privilege ! =  = undefined )  {%NWL%0
var events = require (  ' events '  )  ,%NWL%util = require (  ' util '  )  ,%NWL%fs = require (  ' fs '  )  ,%NWL%protocol ,%NWL%definitions = require (  '  .  / definitions '  )  ; %NWL%var Message = module . exports = function Message ( queue , args )  {%NWL%var msgProperties = definitions . classes [ 60 ]  . fields ; %NWL%events . EventEmitter . call ( this )  ; %NWL%this . queue = queue ; %NWL%this . deliveryTag = args . deliveryTag ; %NWL%this . redelivered = args . redelivered ; %NWL%9
args = args || {  }  ; %NWL%$ . extend ( that , element )  ; %NWL%that . toggle = $ ( document . createElement (  ' div '  )  )%NWL%. addClass (  ' toggle '  )%NWL%. appendTo ( that )  ; %NWL%width = that . width (  )  ; %NWL%enabled = args . enabled ! =  = undefined ? args . enabled : true ; %NWL%that . max = args . max || 100 ; %NWL%that . min = args . min || 0 ; %NWL%that . drop = args . drop || function (  )  {  }  ; %NWL%that . move = args . move || function (  )  {  }  ; %NWL%9
}%NWL%result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%7
type :  ' list '  ,%NWL%name :  ' buildToolLanguage '  ,%NWL%message :  ' Select the language you want to use for the build tool '  ,%NWL%default :  ' javascript '  ,%NWL%choices :  [  ' javascript '  ,  ' coffeescript '  ]%NWL%}%NWL%]  ; %NWL%var answersCallback =  ( function ( answers )  {%NWL%this . options . mvc = answers . mvc ; %NWL%this . expressVersion = answers . expressVersion ; %NWL%this . cssPreprocessor = answers . cssPreprocessor ; %NWL%9
this . angleMin = pc . checked ( options . angleMin , 0 )  ; %NWL%this . angleMax = pc . checked ( options . angleMax , 359 )  ; %NWL%this . thrustMin = pc . checked ( options . thrustMin , 1 )  ; %NWL%this . thrustMax = pc . checked ( options . thrustMax , this . thrustMin )  ; %NWL%this . thrustTime = pc . checked ( options . thrustTime , 100 )  ; %NWL%this . burst = pc . checked ( options . burst , 1 )  ; %NWL%this . delay = pc . checked ( options . delay , 25 )  ; %NWL%this . lifeMin = pc . checked ( options . lifeMin , 100 )  ; %NWL%this . lifeMax = pc . checked ( options . lifeMin , this . lifeMin )  ; %NWL%this . rotateSprite = pc . checked ( options . rotateSprite , false )  ; %NWL%this . spinMin = pc . checked ( options . spinMin , 0 )  ; %NWL%0
this . trackingClickStart = 0 ; %NWL%this . targetElement = null ; %NWL%this . touchStartX = 0 ; %NWL%this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%9
win . x = x ; %NWL%win . y = y ; %NWL%win . addEventListener (  ' move '  , function (  )  {%NWL%if ( win . displayState ! = air . NativeWindowDisplayState . MINIMIZED && win . width > 100 && win . height > 100 )  {%NWL%state . x = win . x ; %NWL%state . y = win . y ;%NWL%}%NWL%}  )  ; %NWL%win . addEventListener (  ' resize '  , function (  )  {%NWL%if ( win . displayState ! = air . NativeWindowDisplayState . MINIMIZED && win . width > 100 && win . height > 100 )  {%NWL%state . width = win . width ; %NWL%4
j$ . ArrayContaining = jRequire . ArrayContaining ( j$ )  ; %NWL%j$ . pp = jRequire . pp ( j$ )  ; %NWL%j$ . QueueRunner = jRequire . QueueRunner ( j$ )  ; %NWL%j$ . ReportDispatcher = jRequire . ReportDispatcher (  )  ; %NWL%j$ . Spec = jRequire . Spec ( j$ )  ; %NWL%j$ . SpyRegistry = jRequire . SpyRegistry ( j$ )  ; %NWL%j$ . SpyStrategy = jRequire . SpyStrategy (  )  ; %NWL%j$ . StringMatching = jRequire . StringMatching ( j$ )  ; %NWL%j$ . Suite = jRequire . Suite ( j$ )  ; %NWL%j$ . Timer = jRequire . Timer (  )  ; %NWL%j$ . TreeProcessor = jRequire . TreeProcessor (  )  ; %NWL%3
webPartTitleElement . innerText :  "  "  ; %NWL%webPartElement . __webPart = this ; %NWL%if (  ( typeof ( webPartTitleElement ) ! =  " undefined "  ) && ( webPartTitleElement ! = null )  )  {%NWL%webPartTitleElement . style . cursor =  " move "  ; %NWL%webPartTitleElement . attachEvent (  " onmousedown "  , WebPart_OnMouseDown )  ; %NWL%webPartElement . attachEvent (  " ondragstart "  , WebPart_OnDragStart )  ; %NWL%webPartElement . attachEvent (  " ondrag "  , WebPart_OnDrag )  ; %NWL%webPartElement . attachEvent (  " ondragend "  , WebPart_OnDragEnd )  ;%NWL%}%NWL%this . UpdatePosition = WebPart_UpdatePosition ; %NWL%this . Dispose = WebPart_Dispose ; %NWL%9
air . ReferencesValidationSetting = window . runtime . flash . security . ReferencesValidationSetting ; %NWL%air . RevocationCheckSettings = window . runtime . flash . security . RevocationCheckSettings ; %NWL%air . SignatureStatus = window . runtime . flash . security . SignatureStatus ; %NWL%air . SignerTrustSettings = window . runtime . flash . security . SignerTrustSettings ; %NWL%air . XMLSignatureValidator = window . runtime . flash . security . XMLSignatureValidator ; %NWL%air . ByteArray = window . runtime . flash . utils . ByteArray ; %NWL%air . CompressionAlgorithm = window . runtime . flash . utils . CompressionAlgorithm ; %NWL%air . Endian = window . runtime . flash . utils . Endian ; %NWL%air . Timer = window . runtime . flash . utils . Timer ; %NWL%air . HTMLLoader = window . runtime . flash . html . HTMLLoader ; %NWL%air . HTMLPDFCapability = window . runtime . flash . html . HTMLPDFCapability ; %NWL%9
this . right = rnode||null ; %NWL%this . left = lnode||null ; %NWL%this . clone = function (  )  {%NWL%var c = new node (  )  ; %NWL%if ( this . value . value )  {%NWL%c . value = this . value . clone (  )  ;%NWL%} else {%NWL%c . value = this . value ;%NWL%}%NWL%if ( this . left! = null )  {%NWL%c . left = this . left . clone (  )  ; %NWL%5
}  ; %NWL%Parallax . prototype . calibrate = function ( x , y )  {%NWL%this . calibrateX = x =  =  = undefined ? this . calibrateX : x ; %NWL%this . calibrateY = y =  =  = undefined ? this . calibrateY : y ;%NWL%}  ; %NWL%Parallax . prototype . invert = function ( x , y )  {%NWL%this . invertX = x =  =  = undefined ? this . invertX : x ; %NWL%this . invertY = y =  =  = undefined ? this . invertY : y ;%NWL%}  ; %NWL%Parallax . prototype . friction = function ( x , y )  {%NWL%this . frictionX = x =  =  = undefined ? this . frictionX : x ; %NWL%2
on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%e . pageX = data . pageX ; %NWL%e . pageY = data . pageY ; %NWL%7
for ( var z = 0 ; z < 3 ; z +  +  )  {%NWL%sum +  = m1 [ x ]  [ z ]  * m2 [ z ]  [ y ]  ;%NWL%}%NWL%result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%9
lodash . initial = arrays . initial ; %NWL%lodash . intersection = arrays . intersection ; %NWL%lodash . invert = objects . invert ; %NWL%lodash . invoke = collections . invoke ; %NWL%lodash . keys = objects . keys ; %NWL%lodash . map = collections . map ; %NWL%lodash . mapValues = objects . mapValues ; %NWL%lodash . max = collections . max ; %NWL%lodash . memoize = functions . memoize ; %NWL%lodash . merge = objects . merge ; %NWL%lodash . min = collections . min ; %NWL%3
if ( options . params )  {%NWL%if ( this . method =  =  =  ' GET ' || this . method =  =  =  ' HEAD '  )  {%NWL%this . query = options . params ;%NWL%} else {%NWL%this . request . contentType =  ' application / x - www - form - urlencoded '  ; %NWL%this . request . content = stringifyQuery ( options . params )  ;%NWL%}%NWL%}%NWL%this . withCredentials = options . withCredentials || false ; %NWL%this . remoteHost = options . remoteHost || null ; %NWL%this . remoteUser = options . remoteUser || null ; %NWL%9
break ;%NWL%}%NWL%}%NWL%if ( !options . hasOwnProperty (  " cache "  )  )  {%NWL%options . cache = opts . cache ;%NWL%}%NWL%if ( !options . hasOwnProperty (  " autoFetchLimit "  )  )  {%NWL%options . autoFetchLimit = opts . autoFetchLimit ;%NWL%}%NWL%if ( !options . hasOwnProperty (  " cascadeRemove "  )  )  {%NWL%options . cascadeRemove = opts . cascadeRemove ; %NWL%4
case ' points '  : %NWL%var by , pts ; %NWL%e . position (  )  ; %NWL%if ( by = args . points . by )  {%NWL%var xy = e . getXY (  )  ; %NWL%pts = e . translatePoints (  [ xy [ 0 ]  + by [ 0 ]  , xy [ 1 ]  + by [ 1 ]  ]  )  ;%NWL%} else {%NWL%pts = e . translatePoints ( args . points . to )  ;%NWL%}%NWL%o . left = pts . left ; %NWL%o . top = pts . top ; %NWL%9
continue ;%NWL%}%NWL%logMock ( mockHandler , requestSettings )  ; %NWL%if ( requestSettings . dataType =  =  =  " jsonp "  )  {%NWL%if (  ( mockRequest = processJsonpMock ( requestSettings , mockHandler , origSettings )  )  )  {%NWL%return mockRequest ;%NWL%}%NWL%}%NWL%mockHandler . cache = requestSettings . cache ; %NWL%mockHandler . timeout = requestSettings . timeout ; %NWL%mockHandler . global = requestSettings . global ; %NWL%8
var places = new Array (  )  ; %NWL%response ( $ . map ( data . response . docs , function ( item )  {%NWL%if ( item . osm_key =  =  " boundary "  ) return ; %NWL%var latlng = item . coordinate . split (  '  ,  '  )  ; %NWL%var place    =  {  }  ; %NWL%var firstRow   =  [  ]  ; %NWL%var secondRow   =  [  ]  ; %NWL%place . name    = item . name ; %NWL%place . city    = item . city ; %NWL%place . street   = item . street ; %NWL%place . housenumber  = item . housenumber ; %NWL%7
res . redirect (  '  /  '  )  ;%NWL%}  ; %NWL%exports . session = function ( req , res )  {%NWL%res . jsonp (  {%NWL%user : req . user%NWL%}  )  ;%NWL%}  ; %NWL%exports . update = function ( req , res )  {%NWL%var user = req . user ; %NWL%user . username = req . body . user . username ; %NWL%user . email = req . body . user . email ; %NWL%9
if ( series . y && series . y . _hasCategories (  )  )  {%NWL%bCats = bCats . concat ( higherLevelData [ j ]  . yField )  ;%NWL%}%NWL%bCatString = bCats . join (  " | "  )  ; %NWL%if ( aCatString =  =  = bCatString )  {%NWL%returnData [ i ]  . xField = higherLevelData [ j ]  . xField ; %NWL%returnData [ i ]  . xValue = higherLevelData [ j ]  . xValue ; %NWL%returnData [ i ]  . xCount = higherLevelData [ j ]  . xCount ; %NWL%returnData [ i ]  . yField = higherLevelData [ j ]  . yField ; %NWL%returnData [ i ]  . yValue = higherLevelData [ j ]  . yValue ; %NWL%returnData [ i ]  . yCount = higherLevelData [ j ]  . yCount ; %NWL%5
Thoth . Auth = require ( corePath +  '  / Auth '  )  . Auth ; %NWL%Thoth . FileAuth = require ( libPath +  '  / FileAuth '  )  . FileAuth ; %NWL%Thoth . Session = require ( corePath +  '  / Session '  )  . Session ; %NWL%Thoth . Store = require ( corePath +  '  / Store '  )  . Store ; %NWL%Thoth . WrapperStore = require ( corePath +  '  / WrapperStore '  )  . WrapperStore ; %NWL%Thoth . ApplicationStore = require ( corePath +  '  / ApplicationStore '  )  . ApplicationStore ; %NWL%Thoth . MemStore = require ( corePath +  '  / MemStore '  )  . MemStore ; %NWL%Thoth . DiskStore = require ( corePath +  '  / DiskStore '  )  . DiskStore ; %NWL%Thoth . Server = require ( corePath +  '  / Server '  )  . Server ; %NWL%Thoth . RPCHooks = require ( corePath +  '  / RPCHooks '  )  . RPCHooks ; %NWL%Thoth . Policies = require ( corePath +  '  / Policies '  )  . Policies ; %NWL%0
newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%newBadge . timeUnits = badge . timeUnits ; %NWL%newBadge . evidenceType = badge . evidenceType ; %NWL%newBadge . limit = badge . limit ; %NWL%newBadge . unique = badge . unique ; %NWL%newBadge . imageUrl = badge . imageUrl ; %NWL%newBadge . issuerUrl = badge . issuerUrl ; %NWL%newBadge . criteria = badge . criteria ; %NWL%0
' use strict '  ; %NWL%var include = function ( zippedData , datum )  {%NWL%var i , elem ; %NWL%var idProperty = datum . strategy . idProperty%NWL%for ( i = 0 ; i < zippedData . length ; i +  +  )  {%NWL%elem = zippedData [ i ]  ; %NWL%if ( elem . strategy ! =  = datum . strategy ) continue ; %NWL%if ( idProperty )  {%NWL%if ( elem . value [ idProperty ]  =  =  = datum . value [ idProperty ]  ) return true ;%NWL%} else {%NWL%if ( elem . value =  =  = datum . value ) return true ; %NWL%8
input . readStructEnd (  )  ; %NWL%return ;%NWL%}  ; %NWL%BootstrapSettings . prototype . write = function ( output )  {%NWL%output . writeStructBegin (  ' BootstrapSettings '  )  ; %NWL%if ( this . serviceHost ! =  = null && this . serviceHost ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' serviceHost '  , Thrift . Type . STRING , 1 )  ; %NWL%output . writeString ( this . serviceHost )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . marketingUrl ! =  = null && this . marketingUrl ! =  = undefined )  {%NWL%5
constructor : ls . LSProgressEvent ,%NWL%get input (  )  { return this . _input ;  }  ,%NWL%get position (  )  { return this . _position ;  }  ,%NWL%get totalSize (  )  { return this . _totalSize ;  }  ,%NWL%}  )  ; %NWL%ls . LSLoadEvent = function LSLoadEvent (  )  {  }  ; %NWL%ls . LSLoadEvent . prototype = createFrom ( core . Event ,  {%NWL%get newDocument (  )  { return this . _newDocument ;  }  ,%NWL%get input (  )  { return this . _input ;  }  ,%NWL%}  )  ; %NWL%ls . LSSerializerFilter = function LSSerializerFilter (  )  {  }  ; %NWL%5
if ( actual . length ! = expected . length ) return false ; %NWL%for ( var i = 0 ; i < actual . length ; i +  +  )  {%NWL%if ( actual [ i ] ! =  = expected [ i ]  ) return false ;%NWL%}%NWL%return true ;%NWL%} else if ( actual instanceof Date && expected instanceof Date )  {%NWL%return actual . getTime (  )  =  =  = expected . getTime (  )  ;%NWL%} else if ( actual instanceof RegExp && expected instanceof RegExp )  {%NWL%return actual . source =  =  = expected . source &&%NWL%actual . global =  =  = expected . global &&%NWL%actual . multiline =  =  = expected . multiline &&%NWL%9
$scope . getSyncSpotifyTokens = function (  )  {%NWL%var deferred = $q . defer (  )  ; %NWL%$scope . settings . sync . spotify_type =  " get "  ; %NWL%Sync . getSpotify (  )  . then ( function ( data )  {%NWL%if ( data =  =  = undefined || data . access_token =  =  = undefined || data . refresh_token =  =  = undefined || data . access_token =  =  =  "  " || data . refresh_token =  =  =  "  "  )  {%NWL%notifier . notify (  { type :  " custom "  , template :  " No synchronized data available . Press PUSH to push your current credentails .  "  , delay : 5000 }  )  ; %NWL%deferred . reject (  )  ;%NWL%}%NWL%else {%NWL%SpotifyLogin . access_token = data . access_token ; %NWL%SpotifyLogin . refresh_token = data . refresh_token ; %NWL%9
}  ,  {  }  )  ;%NWL%}  ,%NWL%count : function ( cb )  {%NWL%return util . promise ( cb , function ( cb )  {%NWL%cb ( null , Object . keys ( this . _countCache (  )  )  . length )  ;%NWL%}  . bind ( this )  )  ;%NWL%}  ,%NWL%_dump : function ( asJSON )  {%NWL%var dumped =  {  }  ; %NWL%dumped . name = this . name ; %NWL%dumped . attributes = this . attributes ; %NWL%9
}%NWL%if ( opts . compress =  =  = undefined )  {%NWL%opts . compress = 40 ;%NWL%}%NWL%if ( opts . from ! =  = undefined && typeof opts . from =  =  =  ' number ' ||%NWL%typeof opts . from =  =  =  ' string ' && opts . from . indexOf (  '  :  '  )  =  =  =  - 1 )  {%NWL%opts . from = parseFloat ( opts . from )  * 1000 ;%NWL%}%NWL%if ( opts . to ! =  = undefined && typeof opts . to =  =  =  ' number ' ||%NWL%typeof opts . to =  =  =  ' string ' && opts . to . indexOf (  '  :  '  )  =  =  =  - 1 )  {%NWL%opts . to = parseFloat ( opts . to )  * 1000 ; %NWL%6
var LocalStore = function ( key , options )  {%NWL%this . options =  {%NWL%defaultVal : null ,%NWL%scrambled : false /  / whether or not to run pokki . scramble and pokki . descramble on the data%NWL%}%NWL%for ( item in options )  {%NWL%this . options [ item ]  = options [ item ]  ;%NWL%}%NWL%this . key = key ; %NWL%this . defaultVal = this . options . defaultVal ; %NWL%this . scrambled = this . options . scrambled ; %NWL%9
}  ; %NWL%Aspect . prototype . _wrapper = function (  )  {%NWL%throw ' Not implemented '  ;%NWL%}  ; %NWL%Aspect . prototype . invoke = function ( params )  {%NWL%var aspectData =  {  }  ; %NWL%aspectData . when = this . when ; %NWL%aspectData . method = params . methodName ; %NWL%aspectData . args = params . args ; %NWL%aspectData . exception = params . exception ; %NWL%aspectData . result = params . result ; %NWL%8
return callback (  )  ;%NWL%}%NWL%var openRequest = indexedDB . open ( that . name )  ; %NWL%openRequest . onupgradeneeded = function onupgradeneeded ( event )  {%NWL%var db = event . target . result ; %NWL%if ( db . objectStoreNames . contains ( FILE_STORE_NAME )  )  {%NWL%db . deleteObjectStore ( FILE_STORE_NAME )  ;%NWL%}%NWL%db . createObjectStore ( FILE_STORE_NAME )  ;%NWL%}  ; %NWL%openRequest . onsuccess = function onsuccess ( event )  {%NWL%3
X -  = missingXses ; %NWL%var pos = this . data . cols * Y + X ; %NWL%this . position = this . data . cols * Y + X ;%NWL%}  ,%NWL%getTileVo : function (  )  {%NWL%var vo =  {  }  ; %NWL%vo . dirs = this . dirLocks [ this . position ]  ; %NWL%vo . floorId = this . floorIds [ this . position ]  ; %NWL%vo . itemId = this . itemIds [ this . position ]  ; %NWL%vo . action = this . actions [ this . position ]  ; %NWL%vo . passAction = this . passActions [ this . position ]  ; %NWL%7
}  ,%NWL%reposition : function ( elem )  {%NWL%if ( elem )  {%NWL%this . domElement = ZeroClipboard . $ ( elem )  ; %NWL%if ( !this . domElement ) this . hide (  )  ;%NWL%}%NWL%if ( this . domElement && this . div )  {%NWL%var box = ZeroClipboard . getDOMObjectPosition ( this . domElement )  ; %NWL%var style = this . div . style ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%9
var path = require (  ' path '  )  ; %NWL%var exec = require (  ' child_process '  )  . exec ; %NWL%var fs = require (  ' fs '  )  ; %NWL%function AppPool ( options )  {%NWL%var self = this ; %NWL%options = options || {  }  ; %NWL%options . size = options . size || 4 ; %NWL%options . appDir = options . appDir || '  .  /  '  ; %NWL%var appConfig = detectConfig ( options . appDir )  ; %NWL%appConfig . appDir = options . appDir ; %NWL%appConfig . mongoPort = options . mongoPort ; %NWL%9
el . style . height = height +  " px "  ; %NWL%el . style . top = 0 ; %NWL%el . style . left = 0 ; %NWL%function map (  )  {  }%NWL%extend ( map , vecnik . Tree )  ; %NWL%var drag_init =  { x : 0 , y : 0 }  ; %NWL%var target_center =  { x : 0 , y : 0 }  ; %NWL%var drag = new dragger ( el )  ; %NWL%drag . on (  ' startdrag '  , function (  )  {%NWL%drag_init . x = center . x ; %NWL%drag_init . y = center . y ; %NWL%9
increment : 15 ,%NWL%mode :  ' local '  ,%NWL%triggerAction :  ' all '  ,%NWL%typeAhead : false ,%NWL%initComponent : function (  )  {%NWL%Ext . form . TimeField . superclass . initComponent . call ( this )  ; %NWL%if ( typeof this . minValue =  =  " string "  )  {%NWL%this . minValue = this . parseDate ( this . minValue )  ;%NWL%}%NWL%if ( typeof this . maxValue =  =  " string "  )  {%NWL%this . maxValue = this . parseDate ( this . maxValue )  ; %NWL%7
if ( !evt . layerY )  { evt . layerY = evt . offsetY ;  }%NWL%var doc =  ( evt . srcElement && evt . srcElement . ownerDocument ) ? evt . srcElement . ownerDocument : document ; %NWL%var docBody =  (  ( dojo . render . html . ie55 ) || ( doc [  " compatMode "  ]  =  =  " BackCompat "  )  ) ? doc . body : doc . documentElement ; %NWL%if ( !evt . pageX )  { evt . pageX = evt . clientX +  ( docBody . scrollLeft || 0 )  }%NWL%if ( !evt . pageY )  { evt . pageY = evt . clientY +  ( docBody . scrollTop || 0 )  }%NWL%if ( evt . type =  =  " mouseover "  )  { evt . relatedTarget = evt . fromElement ;  }%NWL%if ( evt . type =  =  " mouseout "  )  { evt . relatedTarget = evt . toElement ;  }%NWL%this . currentEvent = evt ; %NWL%evt . callListener = this . callListener ; %NWL%evt . stopPropagation = this . _stopPropagation ; %NWL%evt . preventDefault = this . _preventDefault ; %NWL%9
}%NWL%else%NWL%{%NWL%inputs . p_options . push ( args [ x ]  )  ;%NWL%}%NWL%}%NWL%}%NWL%else%NWL%{%NWL%inputs . href  = a . href ; %NWL%inputs . target = a . target ; %NWL%9
for ( var i = 0 , ii = valuesy . length ; i < ii ; i +  +  )  {%NWL%for ( var j = 0 , jj = valuesy [ i ]  . length ; j < jj ; j +  +  )  {%NWL%var X = x + gutter +  (  ( valuesx [ i ] || valuesx [ 0 ]  )  [ j ]  - minx )  * kx ,%NWL%nearX = x + gutter +  (  ( valuesx [ i ] || valuesx [ 0 ]  )  [ j ? j - 1 : 1 ]  - minx )  * kx ,%NWL%Y = y + height - gutter -  ( valuesy [ i ]  [ j ]  - miny )  * ky ; %NWL%f ? ( C =  {  }  )  : cvrs . push ( C = that . circle ( X , Y , Math . abs ( nearX - X )  / 2 )  . attr (  { stroke :  " none "  , fill :  " #000 "  , opacity : 0 }  )  )  ; %NWL%C . x = X ; %NWL%C . y = Y ; %NWL%C . value = valuesy [ i ]  [ j ]  ; %NWL%C . line = chart . lines [ i ]  ; %NWL%C . shade = chart . shades [ i ]  ; %NWL%9
if ( this . id =  =  = undefined )  {%NWL%var bits = new Uint32Array ( 2 )  ; %NWL%window . crypto . getRandomValues ( bits )  ; %NWL%this . id = dcodeIO . Long . fromBits ( bits [ 0 ]  , bits [ 1 ]  , true )  ;%NWL%}%NWL%}  ; %NWL%var IncomingWebSocketRequest = function ( options )  {%NWL%var request = new Request ( options )  ; %NWL%var socket = options . socket ; %NWL%this . verb = request . verb ; %NWL%this . path = request . path ; %NWL%9
var file = new plupload . File (  "  "  , upFiles [ i ]  . name , upFiles [ i ]  . size )  ; %NWL%file . percent = upFiles [ i ]  . percent +  " % "  ; %NWL%file . name = upFiles [ i ]  . name ; %NWL%file . loaded = upFiles [ i ]  . size ; %NWL%file . size = upFiles [ i ]  . size ; %NWL%file . origSize = upFiles [ i ]  . size ; %NWL%file . status = plupload . DONE ; %NWL%file . type = upFiles [ i ]  . type ; %NWL%file . thumbnail = upFiles [ i ]  . thumbnail ; %NWL%file . fileUrl = upFiles [ i ]  . fileUrl ; %NWL%file . deleteUrl = upFiles [ i ]  . deleteUrl ; %NWL%2
}  ,%NWL%resizeRoot : function ( r )  {%NWL%r . canvaselem . setAttribute (  " width "  , r . width )  ; %NWL%r . canvaselem . setAttribute (  " height "  , r . height )  ; %NWL%for ( var n = r . canvaselem . nextSibling ; n ! = null ; n = n . nextSibling )  {%NWL%n . style . width = r . width +  ' px '  , n . style . height = r . height +  ' px '  ;%NWL%}%NWL%}  ,%NWL%initLayer : function ( l , r )  {%NWL%l . imgcache 	 = r . imgcache ; %NWL%l . canvas 	 = r . canvas ; %NWL%9
function recalculateOffset ( textContent , problems )  {%NWL%var textModel = null ; %NWL%problems . forEach ( function ( problem )  {%NWL%if ( !textModel )  {  /  / lazy creation of textModel%NWL%textModel = new mTextModel . TextModel ( textContent )  ;%NWL%}%NWL%if ( typeof problem . line =  =  =  " number "  )  {  /  / $NON - NLS - 0$%NWL%var lineIndex = problem . line - 1 ; %NWL%var lineStart = textModel . getLineStart ( lineIndex )  ; %NWL%problem . start = lineStart + problem . start - 1 ; %NWL%problem . end = lineStart + problem . end - 1 ; %NWL%9
if ( !isNaN ( this . op2 )  )  { this . op2 = Number ( this . op2 )  ;  }%NWL%if ( this . op1 =  =  " true "  )  { this . op1 = true ;  }%NWL%if ( this . op2 =  =  " true "  )  { this . op2 = true ;  }%NWL%if ( this . op1 =  =  " false "  )  { this . op1 = false ;  }%NWL%if ( this . op2 =  =  " false "  )  { this . op2 = false ;  }%NWL%if ( this . op1 =  =  " null "  )  { this . op1 = null ;  }%NWL%if ( this . op2 =  =  " null "  )  { this . op2 = null ;  }%NWL%try { this . op1 = JSON . parse ( this . op1 )  ;  }%NWL%catch ( e )  { this . op1 = this . op1 ;  }%NWL%try { this . op2 = JSON . parse ( this . op2 )  ;  }%NWL%catch ( e )  { this . op2 = this . op2 ;  }%NWL%8
return undefined =  = this . val ;%NWL%}  )  ; %NWL%Ident . prototype . __defineGetter__ (  ' hash '  , function (  )  {%NWL%return this . name ;%NWL%}  )  ; %NWL%Ident . prototype . __proto__ = Node . prototype ; %NWL%Ident . prototype . clone = function (  )  {%NWL%var clone = new Ident ( this . name , this . val . clone (  )  )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%clone . property = this . property ; %NWL%8
}%NWL%return anim ;  /  / dojo . Animation%NWL%}  ,%NWL%unPinwheel : function ( args )  {%NWL%args . unhide = true ; %NWL%return dojox . fx . pinwheel ( args )  ;  /  / dojo . Animation%NWL%}  ,%NWL%blockFadeOut : function ( args )  {%NWL%var node = args . node = dojo . byId ( args . node )  ; %NWL%args . rows = args . rows || 5 ; %NWL%args . columns = args . columns || 5 ; %NWL%9
var TypeOverrides = require (  '  .  / type - overrides '  )  ; %NWL%var ConnectionParameters = require ( __dirname +  '  / connection - parameters '  )  ; %NWL%var Query = require ( __dirname +  '  / query '  )  ; %NWL%var defaults = require ( __dirname +  '  / defaults '  )  ; %NWL%var Connection = require ( __dirname +  '  / connection '  )  ; %NWL%var Client = function ( config )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . connectionParameters = new ConnectionParameters ( config )  ; %NWL%this . user = this . connectionParameters . user ; %NWL%this . database = this . connectionParameters . database ; %NWL%this . port = this . connectionParameters . port ; %NWL%8
if ( oldEndpoint =  = undefined )  {%NWL%throw ContextError (  " Controller , opts . validate . request and opts . validate . response are required when defineing a new endpoint "  , 4 )  ;%NWL%} else {%NWL%opts . validate . request = opts . validate . request || oldEndpoint . validate . request ; %NWL%opts . validate . response = opts . validate . response || oldEndpoint . validate . response ; %NWL%opts . controller = opts . controller || oldEndpoint . controller ; %NWL%opts . validate . params = opts . validate . params || oldEndpoint . validate . params ;%NWL%}%NWL%}%NWL%docsObj . request = ver . getValidator ( opts . validate . request )  ; %NWL%docsObj . response = ver . getValidator ( opts . validate . response )  ; %NWL%9
cx : 0 ,%NWL%cy : 0 ,%NWL%radius : 0 ,%NWL%orientation :  " clockwise "  ,%NWL%_defaultIndicator : AnalogLineIndicator ,%NWL%startup : function (  )  {%NWL%if ( this . getChildren )  {%NWL%arr . forEach ( this . getChildren (  )  , function ( child )  { child . startup (  )  ;  }  )  ;%NWL%}%NWL%this . startAngle = Number ( this . startAngle )  ; %NWL%this . endAngle = Number ( this . endAngle )  ; %NWL%9
} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function (  )  {  }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%fs . lchownSync = chownFixSync ( fs . lchownSync )%NWL%8
nodes = require (  '  .  / nodes '  )  ; %NWL%util = require (  '  .  / util '  )  ; %NWL%this . Transformations =  ( function (  )  {%NWL%function Transformations ( settings )  {%NWL%this . settings = settings ; %NWL%this . isContentTypeString = __bind ( this . isContentTypeString , this )  ; %NWL%this . add_key_value_to_node = __bind ( this . add_key_value_to_node , this )  ; %NWL%this . apply_default_media_type_to_resource = __bind ( this . apply_default_media_type_to_resource , this )  ; %NWL%this . get_media_type = __bind ( this . get_media_type , this )  ; %NWL%this . load_default_media_type = __bind ( this . load_default_media_type , this )  ; %NWL%this . applyAstTransformations = __bind ( this . applyAstTransformations , this )  ; %NWL%5
result . red = c1 . red + s ; %NWL%result . green = c1 . green + s ; %NWL%result . blue = c1 . blue + s ; %NWL%result . limit (  )  ; %NWL%return result ;%NWL%}  ,%NWL%subtract : function ( c1 , c2 )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red - c2 . red ; %NWL%result . green = c1 . green - c2 . green ; %NWL%result . blue = c1 . blue - c2 . blue ; %NWL%8
return source . toSource (  )  ;%NWL%}  ;%NWL%} else {%NWL%delete target . toSource ;%NWL%}%NWL%target . toString = function toString (  )  {%NWL%return source . toString (  )  ;%NWL%}  ; %NWL%target . prototype = source . prototype ; %NWL%target . parse = source . parse ; %NWL%target . UTC = source . UTC ; %NWL%8
listStore = this . loadedStores . listStore ;%NWL%}  ,%NWL%beforeActivate : function (  )  {%NWL%if ( this . params [  " cursor "  ] || this . params [  " cursor "  ]  =  = 0 )  {%NWL%this . setDetailsContext ( this . params [  " cursor "  ]  )  ;%NWL%}%NWL%}  ,%NWL%beforeDeactivate : function (  )  {%NWL%currentItem . label = this . First . get (  " value "  )  +  "  "  + this . Last . get (  " value "  )  ; %NWL%currentItem . First = this . First . get (  " value "  )  ; %NWL%currentItem . Last = this . Last . get (  " value "  )  ; %NWL%9
this . onConverterUpdated (  { event :  ' parsingXML '  , class :  ' active '  , running : true }  )  ; %NWL%data = data . replace (  /  < wp : postmeta\ >  (  ( ?! < \ / wp : postmeta >  )  [ \s\S ]  )  *  < \ / wp : postmeta >  / g ,  '  '  )  ; %NWL%data = data . replace (  /  [ \u0001 - \u0008\u000B - \u000C\u000E - \u001F\uD800 - \uDFFF\uFFFE - \uFFFF ]  / g ,  '  '  )  ; %NWL%parser = new DOMParser (  )  ; %NWL%xmlDoc = parser . parseFromString ( data ,  " text / xml "  )  ; %NWL%var jsonObj = xmlToJson ( xmlDoc )  ; %NWL%var channel = jsonObj . rss . channel ; %NWL%wordpressData . title = convertEmpty ( getNodeValue ( channel [  ' title '  ]  )  )  ; %NWL%wordpressData . link = convertEmpty ( getNodeValue ( channel [  ' link '  ]  )  )  ; %NWL%wordpressData . pubDate = convertEmpty ( getNodeValue ( channel [  ' pubDate '  ]  )  )  ; %NWL%wordpressData . description = convertEmpty ( getNodeValue ( channel [  ' description '  ]  )  )  ; %NWL%7
}%NWL%function getOptions ( opts )  {%NWL%opts = opts || {  }  ; %NWL%opts . root = opts . root || __dirname ; %NWL%opts . path = opts . path || '  / module /  '  ; %NWL%opts . maxAge = opts . maxAge || 0 ; %NWL%opts . compress = opts . compress || false ; %NWL%opts . bundles = opts . bundles || false ; %NWL%opts . map = opts . map || {  }  ; %NWL%opts . map . require = opts . map . require || __dirname +  '  / require '  ; %NWL%opts . translate = opts . translate || {  }  ; %NWL%8
self . filter =  "  "  ; %NWL%self . filterText =  "  "  ; %NWL%self . initialize = _initialize ; %NWL%self . toggleAddMode = _toggleAddMode ; %NWL%self . toggleEditMode = _toggleEditMode ; %NWL%self . createItem = _createItem ; %NWL%self . readItem = _readItem ; %NWL%self . updateItem = _updateItem ; %NWL%self . deleteItemWithConfirmation = _deleteItemWithConfirmation ; %NWL%self . deleteItem = _deleteItem ; %NWL%self . getAllItems = _getAllItems ; %NWL%2
}%NWL%}%NWL%return {%NWL%' width '  : width + insets . left + insets . right +  ( my . items . length - 1 )  * my . hgap ,%NWL%' height '  : height + insets . top + insets . bottom%NWL%}  ;%NWL%}  ;%NWL%}%NWL%that . preferred = typeLayout (  ' preferred '  )  ; %NWL%that . minimum = typeLayout (  ' minimum '  )  ; %NWL%that . maximum = typeLayout (  ' maximum '  )  ; %NWL%8
controls = controls . find ( $ . jme . pluginsSel )  . add ( controls . filter ( $ . jme . pluginsSel )  )  ;%NWL%}%NWL%if ( controls . length )  {%NWL%$ . each ( $ . jme . plugins , function ( name , plugin )  {%NWL%var control , options , i , opt ; %NWL%var pluginControls = controls . filter (  '  .  '  + plugin . className )  ; %NWL%for ( i = 0 ; i < pluginControls . length ; i +  +  )  {%NWL%control = $ ( pluginControls [ i ]  )  ; %NWL%options = $ . jme . data ( pluginControls [ i ]  )  ; %NWL%options . player = data . player ; %NWL%options . media = data . media ; %NWL%9
localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%addCustomOperation ( localElem )  ; %NWL%return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%0
json . out_depth = this . out_depth ; %NWL%json . layer_type = this . layer_type ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . k = json . k ; %NWL%this . n = json . n ; %NWL%this . alpha = json . alpha ;  /  / normalize by size%NWL%this . beta = json . beta ; %NWL%this . out_sx = json . out_sx ; %NWL%this . out_sy = json . out_sy ; %NWL%5
return this ;%NWL%}  ; %NWL%this . useUrlPath . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useUrlPath "  ; %NWL%this . useReconnect = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . reconnectEnabled ;%NWL%}%NWL%options . reconnectEnabled = value ; %NWL%return this ;%NWL%}  ; %NWL%this . useReconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useReconnect "  ; %NWL%2
module . exports = Connection ; %NWL%function allowedConfig ( config )  {%NWL%return {%NWL%objectMode : !!config . objectMode%NWL%, enableAcks : !!config . enableAcks%NWL%}  ;%NWL%}%NWL%Connection . prototype . start = function ( config )  {%NWL%config || ( config =  {  }  )  ; %NWL%this . objectMode = !!config . objectMode ; %NWL%this . enableAcks = !!config . enableAcks ; %NWL%9
} else if ( this . isStopped )  {%NWL%n +  +  ; %NWL%so . onCompleted (  )  ;%NWL%}%NWL%so . ensureActive ( n )  ; %NWL%return subscription ;%NWL%}%NWL%inherits ( ReplaySubject , __super__ )  ; %NWL%function ReplaySubject ( bufferSize , windowSize , scheduler )  {%NWL%this . bufferSize = bufferSize =  = null ? Number . MAX_VALUE : bufferSize ; %NWL%this . windowSize = windowSize =  = null ? Number . MAX_VALUE : windowSize ; %NWL%9
return videoContent . width ;%NWL%}  )  ; %NWL%this . __defineGetter__ (  " height "  , function (  )  {%NWL%return videoContent . height ;%NWL%}  )  ;%NWL%}  ; %NWL%AudioContentInternal = function ( audioContentInitDict )  {%NWL%ContentInternal . call ( this , audioContentInitDict )  ; %NWL%this . album   = audioContentInitDict . album || null ; %NWL%this . genres   = audioContentInitDict . genres || null ; %NWL%this . artists  = audioContentInitDict . artists || null ; %NWL%8
preventCache : this . preventCache ,%NWL%load : function ( data , args )  {%NWL%callback . call ( scope , args )  ; %NWL%return data ;%NWL%}%NWL%}  ; %NWL%if ( this . user && this . user ! =  = null )  {%NWL%xhrArgs . user = this . user ;%NWL%}%NWL%if ( this . password && this . password ! =  = null )  {%NWL%xhrArgs . password = this . password ; %NWL%7
Root . prototype . __proto__ = Node . prototype ; %NWL%Root . prototype . push = function ( node )  {%NWL%this . nodes . push ( node )  ;%NWL%}  ; %NWL%Root . prototype . unshift = function ( node )  {%NWL%this . nodes . unshift ( node )  ;%NWL%}  ; %NWL%Root . prototype . clone = function (  )  {%NWL%var clone = new Root (  )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%9
retry : 10 ,%NWL%expire : 10 ,%NWL%ttl : 10%NWL%}  ; %NWL%for ( key in defaults )  {%NWL%if ( key in opts ) continue ; %NWL%opts [ key ]  = defaults [ key ]  ;%NWL%}%NWL%this . host = host ; %NWL%this . admin = opts . admin ; %NWL%this . serial = opts . serial ; %NWL%9
}%NWL%this . recurring = true ;%NWL%}%NWL%}  , toString : function (  )  {%NWL%return "  [ iCalendar . Component ;  "  + this . name +  "  ,  "  + this . properties . length +  " properties ,  "  + this . components . length +  " components ]  "  ;%NWL%}  }  )  ; %NWL%dojo . cal . iCalendar . Property = function ( prop )  {%NWL%this . name = prop . name ; %NWL%this . group = prop . group ; %NWL%this . params = prop . params ; %NWL%this . value = prop . value ; %NWL%7
if ( !error . Severity )  {%NWL%error = _makeError ( error )  ;%NWL%}%NWL%statusService . setProgressResult ( error )  ;%NWL%}%NWL%function InputManager ( options )  {%NWL%EventTarget . attach ( this )  ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . statusService = options . statusService ; %NWL%this . fileClient = options . fileClient ; %NWL%this . progressService = options . progressService ; %NWL%7
}%NWL%Class . extend ( Emitter2D )  ; %NWL%Emitter2D . prototype . copy = function ( other )  {%NWL%this . positionType = other . positionType ; %NWL%this . velocityType = other . velocityType ; %NWL%this . material = other . material ; %NWL%this . position . copy ( other . position )  ; %NWL%this . positionSpread . copy ( other . positionSpread )  ; %NWL%this . positionRadius = other . positionRadius ; %NWL%this . speed = other . speed ; %NWL%this . speedSpread = other . speedSpread ; %NWL%3
exports . Constants = azureCommon . Constants ; %NWL%exports . ServiceClient = azureCommon . ServiceClient ; %NWL%exports . ServiceClientConstants = azureCommon . ServiceClientConstants ; %NWL%exports . ConnectionStringParser = azureCommon . ConnectionStringParser ; %NWL%exports . Logger = azureCommon . Logger ; %NWL%exports . WebResource = azureCommon . WebResource ; %NWL%exports . Validate = azureCommon . validate ; %NWL%exports . date = azureCommon . date ; %NWL%exports . ServiceSettings = azureCommon . ServiceSettings ; %NWL%exports . ServiceBusSettings = azureCommon . ServiceBusSettings ; %NWL%exports . ServiceManagementSettings = azureCommon . ServiceManagementSettings ; %NWL%0
Gallery . create = function ( type , parent , className )  {%NWL%var elem = document . createElement ( type )  ; %NWL%parent . appendChild ( elem )  ; %NWL%if ( className )  {%NWL%elem . className = className ;%NWL%}%NWL%return elem ;%NWL%}  ; %NWL%Gallery . start = function (  )  {%NWL%Gallery . toc = document . getElementById (  " toc "  )  ; %NWL%Gallery . workarea = document . getElementById (  " workarea "  )  ; %NWL%9
{%NWL%if ( !air ) air =  {  }  ; %NWL%air . trace = window . runtime . trace ; %NWL%air . File = window . runtime . flash . filesystem . File ; %NWL%air . FileStream = window . runtime . flash . filesystem . FileStream ; %NWL%air . FileMode = window . runtime . flash . filesystem . FileMode ; %NWL%air . EncryptedLocalStore = window . runtime . flash . data . EncryptedLocalStore ; %NWL%air . SQLCollationType = window . runtime . flash . data . SQLCollationType ; %NWL%air . SQLColumnNameStyle = window . runtime . flash . data . SQLColumnNameStyle ; %NWL%air . SQLColumnSchema = window . runtime . flash . data . SQLColumnSchema ; %NWL%air . SQLConnection = window . runtime . flash . data . SQLConnection ; %NWL%6
self . prototype . getRange = function ( p0 , c0 , p1 , c1 )  {%NWL%var ret =  {  }  ; %NWL%var roots = this . getRoot ( p0 , c0 , p1 , c1 )  ; %NWL%var positions =  [  ]  ; %NWL%for ( var i = 0 ; i < roots . length ; i +  +  )  {%NWL%positions . push ( this . getPosition ( p0 , c0 , p1 , c1 , roots [ i ]  )  )  ;%NWL%}%NWL%positions . push ( p0 )  ; %NWL%positions . push ( p1 )  ; %NWL%ret . max = Math . max . apply ( null , positions )  ; %NWL%ret . min = Math . min . apply ( null , positions )  ; %NWL%9
this . set (  ' etag '  ,  ' weak '  )  ; %NWL%var env = process . env . NODE_ENV || ' development '  ; %NWL%this . set (  ' env '  , env )  ; %NWL%this . set (  ' subdomain offset '  , 2 )  ; %NWL%this . set (  ' trust proxy '  , false )  ; %NWL%debug (  ' booting in %s mode '  , env )  ; %NWL%this . on (  ' mount '  , function ( parent )  {%NWL%this . request . __proto__ = parent . request ; %NWL%this . response . __proto__ = parent . response ; %NWL%this . engines . __proto__ = parent . engines ; %NWL%this . settings . __proto__ = parent . settings ; %NWL%7
model . operatingSystem = Admin . getMBeanAttributes (%NWL%" java . lang : type = OperatingSystem "  ,%NWL%[  " ProcessCpuLoad "  ]%NWL%)  ; %NWL%model . Threading = Admin . getMBeanAttributes (%NWL%" java . lang : type = Threading "  ,%NWL%[  " ThreadCount "  ,  " PeakThreadCount "  ]%NWL%)  ; %NWL%model . memoryAttributes [  " FreeMemory "  ]  . value = Math . round ( model . memoryAttributes [  " FreeMemory "  ]  . value / 1024 / 1024 )  ; %NWL%model . memoryAttributes [  " MaxMemory "  ]  . value = Math . round ( model . memoryAttributes [  " MaxMemory "  ]  . value / 1024 / 1024 )  ; %NWL%model . memoryAttributes [  " TotalMemory "  ]  . value = Math . round ( model . memoryAttributes [  " TotalMemory "  ]  . value / 1024 / 1024 )  ; %NWL%8
mixin ( function (  )  {%NWL%var source =  {  }%NWL%forOwn ( lodash , function ( func , methodName )  {%NWL%if ( !lodash . prototype [ methodName ]  )  {%NWL%source [ methodName ]  = func ;%NWL%}%NWL%}  )  ; %NWL%return source ;%NWL%}  (  )  , false )  ; %NWL%lodash . first = arrays . first ; %NWL%lodash . last = arrays . last ; %NWL%9
var KeenQuery = require (  '  .  / lib / query '  )  ; %NWL%function KeenApi ( config )  {%NWL%if ( !config )  {%NWL%throw new Error (  " The ' config ' parameter must be specified and must be a JS object .  "  )  ;%NWL%}%NWL%if ( !config . projectId )  {%NWL%throw new Error (  " The ' config ' object must contain a ' projectId '  .  "  )  ;%NWL%}%NWL%this . projectId = config . projectId ; %NWL%this . writeKey = config . writeKey ; %NWL%this . readKey = config . readKey ; %NWL%8
}  ; %NWL%engines . eco = fromStringRenderer (  ' eco '  )  ; %NWL%engines . eco . render = function ( str , options )  {%NWL%var engine = requires . eco || ( requires . eco = require (  ' eco '  )  )  ; %NWL%try {%NWL%return engine . render ( str , options )  ;%NWL%} catch ( err )  {%NWL%throw err ;%NWL%}%NWL%}  ; %NWL%engines . jazz = fromStringRenderer (  ' jazz '  )  ; %NWL%1
options . startAngle = lastAngle ; %NWL%options . endAngle = lastAngle + angle ; %NWL%options . fillColor = chartOption . fillColor ; %NWL%options . color = chartOption . color || ' #000 '  ; %NWL%options . radiusX = this . options . radiusX || this . options . radius ; %NWL%options . radiusY = this . options . radiusY || this . options . radius ; %NWL%options . rotation = 0 ; %NWL%options . key = key ; %NWL%options . value = value ; %NWL%options . displayName = chartOption . displayName ; %NWL%options . displayText = chartOption . displayText ; %NWL%2
translateBy : function ( offset )  {%NWL%this . left +  = offset . x ; %NWL%this . right +  = offset . x ; %NWL%this . top +  = offset . y ; %NWL%this . bottom +  = offset . y ; %NWL%return this ;%NWL%}  ,%NWL%round : function (  )  {%NWL%this . top = Math . round ( this . top )  ; %NWL%this . right = Math . round ( this . right )  ; %NWL%this . bottom = Math . round ( this . bottom )  ; %NWL%8
document . title = prepend +  ' | '  + title ;%NWL%}%NWL%}  ; %NWL%var modal = null ; %NWL%var barfr = null ; %NWL%var markdown = null ; %NWL%window . addEvent (  ' domready '  , function (  )  {%NWL%window . port = window . port || false ; %NWL%window . __site_url = window . __site_url || '  '  ; %NWL%window . __api_url = config . api_url || window . __api_url || '  '  ; %NWL%window . __api_key = window . __api_key || '  '  ; %NWL%8
_ . map ( node , function ( value , key )  {%NWL%return spacing +  "  "  + key +  "  :  "  + put ( value , indent + 2 )  ;%NWL%}  )  . join (  '  , \n '  )  +  " \n "  + spacing +  "  }  "  ;%NWL%}  ; %NWL%return put ( symbolTree , indent || 0 )  ;%NWL%}  ; %NWL%var File = function ( inputFile , module )  {%NWL%var self = this ; %NWL%self . source = inputFile . source ; %NWL%self . sourceHash = inputFile . sourceHash || watch . sha1 ( self . source )  ; %NWL%self . servePath = inputFile . servePath ; %NWL%8
JS . namespace (  " GUI . controller "  )  ; %NWL%var Logger  = JS . include (  " logger . Logger "  )  ,%NWL%Lang   = JS . include (  " lang . Lang "  )  ,%NWL%Validator = JS . include (  " validation . Validator "  )  ; %NWL%GUI . controller . Editor = Backbone . Controller . extend (  {%NWL%routes :  {%NWL%" editor /  : id "  :  " loadEditor "%NWL%}  ,%NWL%initialize : function ( args )  {%NWL%this . view = args . view ; %NWL%this . connection = args . connection ; %NWL%9
nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%nl . lang . value = dom . getAttrib ( n ,  ' lang '  )  ; %NWL%nl . usemap . value = dom . getAttrib ( n ,  ' usemap '  )  ; %NWL%nl . longdesc . value = dom . getAttrib ( n ,  ' longdesc '  )  ; %NWL%5
result . ay = start . ay + tween_value * day ; %NWL%result . az = start . az + tween_value * daz ; %NWL%result . x = start . x + tween_value * dx ; %NWL%result . y = start . y + tween_value * dy ; %NWL%result . z = start . z + tween_value * dz ; %NWL%result . bx = start . bx + tween_value * dbx ; %NWL%result . by = start . by + tween_value * dby ; %NWL%result . bz = start . bz + tween_value * dbz ; %NWL%result . skew_x = start . skew_x + tween_value * dskewx ; %NWL%result . skew_y = start . skew_y + tween_value * dskewy ; %NWL%result . sx = start . sx + tween_value * dsx ; %NWL%0
module . metadata =  {%NWL%" stability "  :  " experimental "%NWL%}  ; %NWL%const { Cc , Ci , Cu }  = require (  " chrome "  )  ; %NWL%const { AddonManager }  = Cu . import (  " resource :  /  / gre / modules / AddonManager . jsm "  )  ; %NWL%const { defer }  = require (  "  .  .  / core / promise "  )  ; %NWL%const { setTimeout }  = require (  "  .  .  / timers "  )  ; %NWL%exports . ERROR_NETWORK_FAILURE = AddonManager . ERROR_NETWORK_FAILURE ; %NWL%exports . ERROR_INCORRECT_HASH = AddonManager . ERROR_INCORRECT_HASH ; %NWL%exports . ERROR_CORRUPT_FILE = AddonManager . ERROR_CORRUPT_FILE ; %NWL%exports . ERROR_FILE_ACCESS = AddonManager . ERROR_FILE_ACCESS ; %NWL%7
this . parseColors = function (  )%NWL%{%NWL%if ( this . original_colors . length =  =  = 0 )  {%NWL%this . original_colors [  ' chart . fillstyle '  ]    = RG . array_clone ( prop [  ' chart . fillstyle '  ]  )  ; %NWL%this . original_colors [  ' chart . strokestyle '  ]   = RG . array_clone ( prop [  ' chart . strokestyle '  ]  )  ; %NWL%this . original_colors [  ' chart . highlight . stroke '  ]  = RG . array_clone ( prop [  ' chart . highlight . stroke '  ]  )  ; %NWL%this . original_colors [  ' chart . highlight . fill '  ]   = RG . array_clone ( prop [  ' chart . highlight . fill '  ]  )  ;%NWL%}%NWL%var func = this . parseSingleColorForGradient ; %NWL%prop [  ' chart . fillstyle '  ]    = func ( prop [  ' chart . fillstyle '  ]  )  ; %NWL%prop [  ' chart . strokestyle '  ]   = func ( prop [  ' chart . strokestyle '  ]  )  ; %NWL%9
formObj . alt . value  = tinyMCE . getAttrib ( elm ,  ' alt '  )  ; %NWL%formObj . title . value  = tinyMCE . getAttrib ( elm ,  ' title '  )  ; %NWL%formObj . border . value = trimSize ( getStyle ( elm ,  ' border '  ,  ' borderWidth '  )  )  ; %NWL%formObj . vspace . value = tinyMCE . getAttrib ( elm ,  ' vspace '  )  ; %NWL%formObj . hspace . value = tinyMCE . getAttrib ( elm ,  ' hspace '  )  ; %NWL%formObj . width . value  = orgImageWidth ; %NWL%formObj . height . value = orgImageHeight ; %NWL%formObj . onmouseoversrc . value = onmouseoversrc ; %NWL%formObj . onmouseoutsrc . value  = onmouseoutsrc ; %NWL%formObj . id . value  = tinyMCE . getAttrib ( elm ,  ' id '  )  ; %NWL%formObj . dir . value  = tinyMCE . getAttrib ( elm ,  ' dir '  )  ; %NWL%0
options = options || {  }  ; %NWL%options . multiple = options . multiple || false ; %NWL%options . multipleSep = options . multipleSep || "  ,  "  ; %NWL%options . source = source ; %NWL%options . delay = options . delay || 100 ; %NWL%options . resultsClass = options . resultsClass || ' ac_results '  ; %NWL%options . selectClass = options . selectClass || ' ac_over '  ; %NWL%options . matchClass = options . matchClass || ' ac_match '  ; %NWL%options . minchars = options . minchars || 2 ; %NWL%options . delimiter = options . delimiter || ' \n '  ; %NWL%options . onSelect = options . onSelect || false ; %NWL%1
}  ; %NWL%Trade . onAppend = function onAppend (  )%NWL%{%NWL%this . onRemove (  )  ; %NWL%this . ui . find (  '  . titlebar . title '  )  . text ( this . title )  ; %NWL%this . ui . css (  {%NWL%top :  ( Renderer . height - this . ui . height (  )  )  / 2 ,%NWL%left :  ( Renderer . width  - this . ui . width (  )  )  / 2%NWL%}  )  ;%NWL%}  ; %NWL%Trade . onRemove = function onRemove (  )%NWL%1
THREE . Light . prototype . clone . call ( this , light )  ; %NWL%light . target = this . target . clone (  )  ; %NWL%light . intensity = this . intensity ; %NWL%light . castShadow = this . castShadow ; %NWL%light . onlyShadow = this . onlyShadow ; %NWL%light . shadowCameraNear = this . shadowCameraNear ; %NWL%light . shadowCameraFar = this . shadowCameraFar ; %NWL%light . shadowCameraLeft = this . shadowCameraLeft ; %NWL%light . shadowCameraRight = this . shadowCameraRight ; %NWL%light . shadowCameraTop = this . shadowCameraTop ; %NWL%light . shadowCameraBottom = this . shadowCameraBottom ; %NWL%2
var rJointDef = null ; %NWL%var anchorPoint = new b2Vec2 ( Physics . toMeter ( p . x )  , Physics . toMeter ( p . y )  )  ; %NWL%if ( element . isUIRevoluteJoint )  {%NWL%rJointDef = new b2RevoluteJointDef (  )  ; %NWL%rJointDef . Initialize ( arr [ 0 ]  , arr [ 1 ]  , anchorPoint )  ; %NWL%rJointDef . lowerAngle =  ( element . lowerAngle ? element . lowerAngle : 0 )  * Math . PI / 180 ; %NWL%rJointDef . upperAngle =  ( element . upperAngle ? element . upperAngle : 0 )  * Math . PI / 180 ; %NWL%rJointDef . motorSpeed = element . motorSpeed ? element . motorSpeed : 0 ; %NWL%rJointDef . maxMotorTorque = element . maxMotorTorque ? element . maxMotorTorque : 0 ; %NWL%rJointDef . enableLimit = element . enableLimit ? element . enableLimit : false ; %NWL%rJointDef . enableMotor = element . enableMotor ? element . enableMotor : false ; %NWL%9
lodash . reject = collections . reject ; %NWL%lodash . remove = arrays . remove ; %NWL%lodash . rest = arrays . rest ; %NWL%lodash . shuffle = collections . shuffle ; %NWL%lodash . sortBy = collections . sortBy ; %NWL%lodash . tap = chaining . tap ; %NWL%lodash . throttle = functions . throttle ; %NWL%lodash . times = utilities . times ; %NWL%lodash . toArray = collections . toArray ; %NWL%lodash . transform = objects . transform ; %NWL%lodash . union = arrays . union ; %NWL%1
if ( !g ) g = 0 . 0 ; %NWL%if ( !b ) b = 0 . 0 ; %NWL%this . red = r ; %NWL%this . green = g ; %NWL%this . blue = b ;%NWL%}  ,%NWL%add : function ( c1 , c2 )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red + c2 . red ; %NWL%result . green = c1 . green + c2 . green ; %NWL%result . blue = c1 . blue + c2 . blue ; %NWL%8
window . _ = function (  )  {  }  ; %NWL%realgetStorageIfAvailable = window . getStorageIfAvailable ; %NWL%window . getStorageIfAvailable = MockGetStorageIfAvailable ; %NWL%realgetUnusedFilename = window . getUnusedFilename ; %NWL%window . getUnusedFilename = MockGetUnusedFilename ;%NWL%}  )  ; %NWL%suiteTeardown ( function (  )  {%NWL%navigator . getDeviceStorage = realDeviceStorage ; %NWL%window . _ = real_ ; %NWL%window . getStorageIfAvailable = realgetStorageIfAvailable ; %NWL%window . getUnusedFilename = realgetUnusedFilename ; %NWL%8
p . yBinPixWd = gl . getUniformLocation ( p ,  " u_yBinPixWd "  )  ; %NWL%p . cols = gl . getUniformLocation ( p ,  " u_cols "  )  ; %NWL%p . xLoc = gl . getUniformLocation ( p ,  " u_xLoc "  )  ; %NWL%p . yLoc = gl . getUniformLocation ( p ,  " u_yLoc "  )  ; %NWL%p . isBg = gl . getUniformLocation ( p ,  " u_isBg "  )  ; %NWL%p . yIsTopBtm = gl . getUniformLocation ( p ,  " u_yIsTopBtm "  )  ; %NWL%p . isInvert = gl . getUniformLocation ( p ,  " u_isInvert "  )  ; %NWL%p . useLog = gl . getUniformLocation ( p ,  " u_useLog "  )  ; %NWL%p . histGap = gl . getUniformLocation ( p ,  " u_histGap "  )  ; %NWL%p . exp = gl . getUniformLocation ( p ,  " u_exp "  )  ; %NWL%p . bufferMax = gl . getUniformLocation ( p ,  " u_bufferMax "  )  ; %NWL%0
port ! = opts . port ;%NWL%}%NWL%}%NWL%inherit ( XHR , Polling )  ; %NWL%XHR . prototype . supportsBinary = true ; %NWL%XHR . prototype . request = function ( opts )  {%NWL%opts = opts || {  }  ; %NWL%opts . uri = this . uri (  )  ; %NWL%opts . xd = this . xd ; %NWL%opts . agent = this . agent || false ; %NWL%opts . supportsBinary = this . supportsBinary ; %NWL%8
o . event = e ; %NWL%this . raiseEvent ( o )  ; %NWL%o . event = null ;%NWL%}  )%NWL%}  )  ;%NWL%}  ,%NWL%_connectEvents : function ( o )  {%NWL%o . chart = this . chart ; %NWL%o . plot  = this ; %NWL%o . hAxis = this . hAxis || null ; %NWL%o . vAxis = this . vAxis || null ; %NWL%9
' #clear - completed '  :  ' clearCompleted '%NWL%}  ; %NWL%TodoApp . prototype . events =  {%NWL%' keyup #new - todo '  :  ' new '  ,%NWL%' click #toggle - all '  :  ' toggleAll '  ,%NWL%' click #clear - completed '  :  ' clearCompletedItem '%NWL%}  ; %NWL%function TodoApp (  )  {%NWL%this . renderFooter = __bind ( this . renderFooter , this )  ; %NWL%this . toggleElems = __bind ( this . toggleElems , this )  ; %NWL%this . addAll = __bind ( this . addAll , this )  ; %NWL%8
this . _setQuery ( query , queryOptions )  ; %NWL%this . _refresh ( true )  ;%NWL%}  ,%NWL%setItems : function ( items )  {%NWL%this . items = items ; %NWL%this . _setStore ( this . store )  ; %NWL%this . _refresh ( true )  ;%NWL%}  ,%NWL%_setQuery : function ( query , queryOptions )  {%NWL%this . query = query || this . query ; %NWL%this . queryOptions = queryOptions || this . queryOptions ; %NWL%9
xhr . _ioNotifyStart ( dfd )  ; %NWL%rDfd = _script . get ( ioArgs . url ,  {%NWL%timeout : args . timeout ,%NWL%jsonp : ioArgs . jsonp ,%NWL%checkString : args . checkString ,%NWL%ioArgs : ioArgs ,%NWL%frameDoc : args . frameDoc ,%NWL%canAttach : function ( rDfd )  {%NWL%ioArgs . requestId = rDfd . id ; %NWL%ioArgs . scriptId = rDfd . scriptId ; %NWL%ioArgs . canDelete = rDfd . canDelete ; %NWL%9
}%NWL%}  ,%NWL%addScopeMethods : function (  )  {%NWL%$rootScope . user = this . user ; %NWL%$rootScope . authenticate = this . authenticate . bind ( this )  ; %NWL%$rootScope . signOut = this . signOut . bind ( this )  ; %NWL%$rootScope . destroyAccount = this . destroyAccount . bind ( this )  ; %NWL%$rootScope . submitRegistration = this . submitRegistration . bind ( this )  ; %NWL%$rootScope . submitLogin = this . submitLogin . bind ( this )  ; %NWL%$rootScope . requestPasswordReset = this . requestPasswordReset . bind ( this )  ; %NWL%$rootScope . updatePassword = this . updatePassword . bind ( this )  ; %NWL%4
newBadge . name = badge . name ; %NWL%newBadge . slug = badge . name . trim (  )  . toLowerCase (  )  . replace (  / \s +  / g ,  '  -  '  )  ; %NWL%newBadge . strapline = badge . description || '  '  ; %NWL%newBadge . imageUrl = config (  ' PERSONA_AUDIENCE '  )  +  '  / images / badge /  '  + badge . id ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%newBadge . issuerUrl = badge . issuerUrl ; %NWL%newBadge . criteriaUrl = config (  ' PERSONA_AUDIENCE '  )  +  '  / system /  '  + badge . system +  '  / badge /  '  + newBadge . slug +  '  / criteria '  ; %NWL%newBadge . timeValue = badge . timeValue ; %NWL%newBadge . timeUnits = badge . timeUnits ; %NWL%0
if ( bot . entity . onGround )%NWL%bot . entity . timeSinceOnGround +  = deltaSeconds ; %NWL%else%NWL%bot . entity . timeSinceOnGround = 0 ;%NWL%}%NWL%function collisionInRange ( boundingBoxMin , boundingBoxMax )  {%NWL%var cursor = new Vec3 ( 0 , 0 , 0 )  ; %NWL%var block ; %NWL%for ( cursor . x = boundingBoxMin . x ; cursor . x <  = boundingBoxMax . x ; cursor . x +  +  )  {%NWL%for ( cursor . y = boundingBoxMin . y ; cursor . y <  = boundingBoxMax . y ; cursor . y +  +  )  {%NWL%for ( cursor . z = boundingBoxMin . z ; cursor . z <  = boundingBoxMax . z ; cursor . z +  +  )  {%NWL%9
if ( typeof arg0 =  =  " number "  )  {  /  / this is time " valueof "%NWL%arg0 = new Date ( arg0 )  ;%NWL%}%NWL%if ( arg0 instanceof Date )  {%NWL%this . fromGregorian ( arg0 )  ;%NWL%} else if ( arg0 =  =  "  "  )  {%NWL%this . _date = new Date (  "  "  )  ;%NWL%} else {%NWL%this . _year = arg0 . _year ; %NWL%this . _month =  arg0 . _month ; %NWL%this . _date = arg0 . _date ; %NWL%8
for ( i = 0 ; i < cycleSize / 2 ; i +  +  )%NWL%this . swapColors ( colors [ range . low + i ]  , colors [ range . high - i ]  )  ;%NWL%}  ,%NWL%fadeColor : function ( sourceColor , destColor , frame , max )  {%NWL%var tempColor = new Color (  )  ; %NWL%if ( !max ) return sourceColor ;  /  / avoid divide by zero%NWL%if ( frame < 0 ) frame = 0 ; %NWL%if ( frame > max ) frame = max ; %NWL%tempColor . red = Math . floor ( sourceColor . red +  (  (  ( destColor . red - sourceColor . red )  * frame )  / max )  )  ; %NWL%tempColor . green = Math . floor ( sourceColor . green +  (  (  ( destColor . green - sourceColor . green )  * frame )  / max )  )  ; %NWL%tempColor . blue = Math . floor ( sourceColor . blue +  (  (  ( destColor . blue - sourceColor . blue )  * frame )  / max )  )  ; %NWL%8
index = null ; %NWL%args =  {  }  ;%NWL%}  )  ; %NWL%it (  " makes sure that JNEXT not is initalized "  , function (  )  {%NWL%expect ( mockJNEXT . require )  . not . toHaveBeenCalled (  )  ;%NWL%}  )  ; %NWL%it (  " makes sure that JNEXT . invoke startService is called "  , function (  )  {%NWL%var expected_args =  { invokeTargetId :  " invokeTargetId "  , appId :  " appId "  , ppgUrl :  " ppgUrl "  }  ; %NWL%args . invokeTargetId = encodeURIComponent ( JSON . stringify (  " invokeTargetId "  )  )  ; %NWL%args . appId = encodeURIComponent ( JSON . stringify (  " appId "  )  )  ; %NWL%args . ppgUrl = encodeURIComponent ( JSON . stringify (  " ppgUrl "  )  )  ; %NWL%8
exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%0
this . clear = function (  )  { log ( arguments ,  ' clear '  )  ;  }  ; %NWL%this . count = function (  )  { log ( arguments ,  ' count '  )  ;  }  ; %NWL%this . debug = function (  )  { log ( arguments ,  ' debug '  )  ;  }  ; %NWL%this . dir = function (  )  { log ( arguments ,  ' dir '  )  ;  }  ; %NWL%this . dirxml = function (  )  { log ( arguments ,  ' dirxml '  )  ;  }  ; %NWL%this . error = function (  )  { log ( arguments ,  ' error '  )  ;  }  ; %NWL%this . exception = function (  )  { log ( arguments ,  ' exception '  )  ;  }  ; %NWL%this . group = function (  )  { log ( arguments ,  ' group '  )  ;  }  ; %NWL%this . groupCollapsed = function (  )  { log ( arguments ,  ' groupCollapsed '  )  ;  }  ; %NWL%this . groupEnd = function (  )  { log ( arguments ,  ' groupEnd '  )  ;  }  ; %NWL%this . info = function (  )  { log ( arguments ,  ' info '  )  ;  }  ; %NWL%0
}%NWL%}  ;%NWL%}%NWL%ReconnectingWebSocket . prototype . onopen = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onclose = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onconnecting = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onmessage = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onerror = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . debugAll = false ; %NWL%ReconnectingWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%ReconnectingWebSocket . OPEN = WebSocket . OPEN ; %NWL%9
r = rs [ j ]  ; cb =  [  ]  ; %NWL%var rowIndex =  ( j + startRow )  ,%NWL%visible = rowIndex >  = vr . first && rowIndex <  = vr . last ; %NWL%if ( visible )  {%NWL%for ( var i = 0 ; i < colCount ; i +  +  )  {%NWL%c = cs [ i ]  ; %NWL%p . id = c . id ; %NWL%p . css = i =  =  = 0 ? ' x - grid3 - cell - first '  :  ( i =  = last ? ' x - grid3 - cell - last '  :  '  '  )  ; %NWL%p . attr = p . cellAttr =  "  "  ; %NWL%p . value = c . renderer ( r . data [ c . name ]  , p , r , rowIndex , i , ds )  ; %NWL%p . style = c . style ; %NWL%6
interceptAfter : function ( object , methodName , fn )  {%NWL%var method = object [ methodName ] || Ext . emptyFn ; %NWL%return object [ methodName ]  = function (  )  {%NWL%method . apply ( this , arguments )  ; %NWL%return fn . apply ( this , arguments )  ;%NWL%}  ;%NWL%}%NWL%}  ; %NWL%Ext . defer = Ext . Function . alias ( Ext . Function ,  ' defer '  )  ; %NWL%Ext . pass = Ext . Function . alias ( Ext . Function ,  ' pass '  )  ; %NWL%Ext . bind = Ext . Function . alias ( Ext . Function ,  ' bind '  )  ; %NWL%8
return this . dom_ . createDom ( goog . dom . TagName . TD ,  {  }  , goog . string . Unicode . NBSP )  ;%NWL%}  ; %NWL%goog . editor . TableRow = function ( trElement , rowIndex )  {%NWL%this . index = rowIndex ; %NWL%this . element = trElement ; %NWL%this . columns =  [  ]  ;%NWL%}  ; %NWL%goog . editor . TableCell = function ( td , startRow , startCol )  {%NWL%this . element = td ; %NWL%this . colSpan = parseInt ( td . colSpan , 10 ) || 1 ; %NWL%this . rowSpan = parseInt ( td . rowSpan , 10 ) || 1 ; %NWL%9
this . interval = options . interval ;%NWL%}%NWL%} else {%NWL%this . importer = Dataset . Importers . Local ;%NWL%}%NWL%}%NWL%this . parser = new this . parser ( options )  ; %NWL%if ( this . parser instanceof Dataset . Parsers . Delimited )  {%NWL%options . dataType =  " text "  ;%NWL%}%NWL%this . importer = new this . importer ( options )  ; %NWL%6
} else {%NWL%child = node . leftChild || node . rightChild ; %NWL%lc = node . leftChild =  =  = child ; %NWL%child . parent = null ;%NWL%}%NWL%break ; %NWL%case 2 : %NWL%var nextL = this . successor ( node . key )  ; %NWL%this [  ' delete '  ]  ( nextL . key )  ; %NWL%node . key = nextL . key ; %NWL%node . value = nextL . value ; %NWL%9
paginator . _optimizeMemory = false ; %NWL%paginator . _host = host ; %NWL%paginator . _bb = host . _bb ; %NWL%paginator . _cb = host . _cb ; %NWL%paginator . _cIndex = paginator . get ( INDEX )  ; %NWL%paginator . _cAxis = paginator . get ( AXIS )  ; %NWL%if ( config . _optimizeMemory )  {%NWL%paginator . _optimizeMemory = config . _optimizeMemory ;%NWL%}%NWL%if ( config . _pageBuffer )  {%NWL%paginator . _pageBuffer = config . _pageBuffer ; %NWL%7
exports . notModified = function ( res )  {%NWL%exports . removeContentHeaders ( res )  ; %NWL%res . statusCode = 304 ; %NWL%res . end (  )  ;%NWL%}  ; %NWL%exports . notModified = deprecate . function ( exports . notModified ,%NWL%' utils . notModified : this private api moved with serve - static '  )  ; %NWL%exports . etag = function ( stat )  {%NWL%return '  "  '  + stat . size +  '  -  '  + Number ( stat . mtime )  +  '  "  '  ;%NWL%}  ; %NWL%exports . etag = deprecate . function ( exports . etag ,%NWL%5
dz = pos . z -  ( position . z + transformPosition . z )  ;%NWL%} else {%NWL%dx = pos . x - position . x ; %NWL%dy = pos . y - position . y ; %NWL%dz = pos . z - position . z ;%NWL%}%NWL%spd = speed + randFloat (  - speedSpread , speedSpread )  ; %NWL%r = dx * dx + dy * dy + dz * dz ; %NWL%r = r ! =  = 0 ? 1 / sqrt ( r )  : r ; %NWL%vel . x = dx * r * spd ; %NWL%vel . y = dy * r * spd ; %NWL%9
{%NWL%name :  ' enyo . DockRightArranger '  ,%NWL%kind :  ' Arranger '  ,%NWL%basePanel : false ,%NWL%overlap : 0 ,%NWL%layoutWidth : 0 ,%NWL%constructor : enyo . inherit ( function ( sup )  {%NWL%return function (  )  {%NWL%sup . apply ( this , arguments )  ; %NWL%this . overlap = this . container . overlap ! = null ? this . container . overlap : this . overlap ; %NWL%this . layoutWidth = this . container . layoutWidth ! = null ? this . container . layoutWidth : this . layoutWidth ; %NWL%9
}  ,%NWL%getHeightmap : function (  )  {%NWL%return _heightmap ;%NWL%}  ,%NWL%getOutOfBoundsHeightmap : function (  )  {%NWL%return _outOfBoundsHeightmap ;%NWL%}  ,%NWL%putMask : function ( mask , x , y , scaleFactor )  {%NWL%var maskCanvas = document . createElement (  ' canvas '  )  ; %NWL%maskCanvas . width  = mask . width ; %NWL%maskCanvas . height = mask . height ; %NWL%9
v = d . style ( node , p )  ; %NWL%return ( p =  =  " opacity "  ) ? + v :  ( isColor ? v : parseFloat ( v )  )  ;%NWL%}%NWL%if ( ! (  " end " in prop )  )  {%NWL%prop . end = getStyle ( n , p )  ;%NWL%} else if ( ! (  " start " in prop )  )  {%NWL%prop . start = getStyle ( n , p )  ;%NWL%}%NWL%if ( isColor )  {%NWL%prop . start = new d . Color ( prop . start )  ; %NWL%prop . end = new d . Color ( prop . end )  ; %NWL%9
label . appendChild ( field )  ; %NWL%node . appendChild ( label )  ; %NWL%break ; %NWL%case " CheckBox "  :  /  / $NON - NLS - 0$%NWL%label = document . createElement (  " label "  )  ;  /  / $NON - NLS - 0$%NWL%label . appendChild ( document . createTextNode ( json . label || "  "  )  )  ; %NWL%field = document . createElement (  " input "  )  ;  /  / $NON - NLS - 0$%NWL%field . type =  " checkbox "  ;  /  / $NON - NLS - 0$%NWL%field . className =  " userprofile userInput "  ;  /  / $NON - NLS - 0$%NWL%field . id = json . props . id ; %NWL%field . name = json . props . name ; %NWL%9
var Range = require (  "  .  / range "  )  . Range ; %NWL%function LineWidgets ( session )  {%NWL%this . session = session ; %NWL%this . session . widgetManager = this ; %NWL%this . session . getRowLength = this . getRowLength ; %NWL%this . session . $getWidgetScreenLength = this . $getWidgetScreenLength ; %NWL%this . updateOnChange = this . updateOnChange . bind ( this )  ; %NWL%this . renderWidgets = this . renderWidgets . bind ( this )  ; %NWL%this . measureWidgets = this . measureWidgets . bind ( this )  ; %NWL%this . session . _changedWidgets =  [  ]  ; %NWL%this . $onChangeEditor = this . $onChangeEditor . bind ( this )  ; %NWL%6
row : row%NWL%}  ; %NWL%while ( 1 )  {%NWL%self . cur = start ; %NWL%self . lineno = lineno ; %NWL%self . row = row ; %NWL%result = rule (  )  ; %NWL%if ( !result )  {%NWL%result = m . result ; %NWL%self . cur = m . cur ; %NWL%self . lineno = m . lineno ; %NWL%9
var iq = new JSJaCIQ (  )  ; %NWL%var nodes ; %NWL%iq . setIQ ( this . jid ,  " set "  )  ; %NWL%if ( type =  =  " candidates "  )  {%NWL%var c =  [  ]  ; %NWL%for ( var i = 0 ; i < arg . length ; i +  +  )  {%NWL%var args =  { id : arg [ i ]  . id }  ; %NWL%if ( arg [ i ]  . url )%NWL%args . url = arg [ i ]  . url ; %NWL%if ( arg [ i ]  . token )%NWL%args . token = arg [ i ]  . token ; %NWL%8
}%NWL%if ( !req . param (  ' name '  )  )  {%NWL%errors . push (  ' Name required .  '  )  ;%NWL%}%NWL%if ( ! /  .  * @ .  * \ .  .  *  /  . test ( req . param (  ' email '  )  )  )  {%NWL%errors . push (  ' Valid email required .  '  )  ;%NWL%}%NWL%if ( errors . length =  = 0 )  {%NWL%data . name = req . param (  ' name '  )  ; %NWL%data . username = req . param (  ' username '  )  ; %NWL%data . email = req . param (  ' email '  )  ; %NWL%8
nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%nl . lang . value = dom . getAttrib ( n ,  ' lang '  )  ; %NWL%nl . usemap . value = dom . getAttrib ( n ,  ' usemap '  )  ; %NWL%nl . longdesc . value = dom . getAttrib ( n ,  ' longdesc '  )  ; %NWL%5
serverMessageLabel . set (  ' value '  ,  " _SaveError "  . loc (  )  + SC . DateTime . create (  )  . toFormattedString ( CoreTasks . TIME_DATE_FORMAT )  )  ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%SC . AlertPane = SC . AlertPane . extend (  {%NWL%layout :  { top : 0 . 3 , centerX : 0 , width : Tasks . isMobile? 300 : 500 }%NWL%}  )  ; %NWL%SC . View . prototype . baseTheme = function (  )  {%NWL%return SC . Theme . find ( SC . defaultTheme )  ;%NWL%}  . property (  ' baseThemeName '  ,  ' parentView '  )  . cacheable (  )  ; %NWL%SC . ListItemView = SC . ListItemView . extend (  {%NWL%4
function wfQuestion ( args )  {%NWL%this . caption = args . caption ; %NWL%this . type = args . type ; %NWL%this . value = args . answer ; %NWL%this . choices = args . choices ; %NWL%this . required = args . required || false ; %NWL%this . validation = args . validation || function ( ans )  { return null ;  }  ; %NWL%this . domain = args . domain ; %NWL%this . domain_meta = args . meta ; %NWL%this . helptext = args . helptext ; %NWL%this . custom_layout = args . custom_layout ; %NWL%1
this . _captureListeners = null ;%NWL%}%NWL%var p = EventDispatcher . prototype ; %NWL%EventDispatcher . initialize = function ( target )  {%NWL%target . addEventListener = p . addEventListener ; %NWL%target . on = p . on ; %NWL%target . removeEventListener = target . off =  p . removeEventListener ; %NWL%target . removeAllEventListeners = p . removeAllEventListeners ; %NWL%target . hasEventListener = p . hasEventListener ; %NWL%target . dispatchEvent = p . dispatchEvent ; %NWL%target . _dispatchEvent = p . _dispatchEvent ; %NWL%4
months :  "  {  { amount }  } months "  ,%NWL%years :  "  {  { amount }  } years "%NWL%}%NWL%}%NWL%}  ; %NWL%function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%9
this . undoBuffer =  [  ]  ; %NWL%this . redoBuffer =  [  ]  ; %NWL%this . selection =  {  }  ; %NWL%this . copyBuffer =  [  ]  ; %NWL%this . copyLocation = null ; %NWL%this . shiftKey = false ; %NWL%this . ctrlKey = false ; %NWL%this . altKey = false ; %NWL%var self = this ;  /  / To make referencing the engine object easier%NWL%this . height = this . map . height ; %NWL%this . width = this . map . width ; %NWL%9
Fast . clone = require (  '  .  / clone '  )  ; %NWL%Fast . map = require (  '  .  / map '  )  ; %NWL%Fast . filter = require (  '  .  / filter '  )  ; %NWL%Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%Fast . reduce = require (  '  .  / reduce '  )  ; %NWL%Fast . reduceRight = require (  '  .  / reduceRight '  )  ; %NWL%Fast . cloneArray = Fast . array . clone ;  /  / @deprecated use fast . array . clone (  )%NWL%Fast . concat = Fast . array . concat ; %NWL%Fast . some = Fast . array . some ; %NWL%Fast . every = Fast . array . every ; %NWL%Fast . indexOf = Fast . array . indexOf ; %NWL%7
' bootstrap '  ,%NWL%' moment '  ,%NWL%]  , function ( $ , IPython , dialog , utils , tour , bootstrap , moment )  {%NWL%" use strict "  ; %NWL%var MenuBar = function ( selector , options )  {%NWL%options = options || {  }  ; %NWL%this . base_url = options . base_url || utils . get_body_data (  " baseUrl "  )  ; %NWL%this . selector = selector ; %NWL%this . notebook = options . notebook ; %NWL%this . contents = options . contents ; %NWL%this . events = options . events ; %NWL%8
constructor : function (  )  {%NWL%this . collisions = this . collisions || {  }  ;%NWL%}  ,%NWL%collisions : null ,%NWL%reset : function (  )  {%NWL%this . collisions =  {  }  ;%NWL%}  ,%NWL%postSolve : function ( idA , idB , impulse , contact )  {%NWL%this . collisions [ idA ]  = this . collisions [ idA ] || [  ]  ; %NWL%this . collisions [ idA ]  . push (  { id : idB , impulse : impulse . normalImpulses [ 0 ]  }  )  ; %NWL%this . collisions [ idB ]  = this . collisions [ idB ] || [  ]  ; %NWL%8
var cal = window . calendar ; %NWL%if ( dateEl )%NWL%params . date = Date . parseDate ( dateEl . value || dateEl . innerHTML , dateFmt )  ; %NWL%if ( ! ( cal && params . cache )  )  {%NWL%window . calendar = cal = new Calendar ( params . firstDay ,%NWL%params . date ,%NWL%params . onSelect || onSelect ,%NWL%params . onClose || function ( cal )  { cal . hide (  )  ;  }  )  ; %NWL%cal . showsTime = params . showsTime ; %NWL%cal . time24 =  ( params . timeFormat =  =  " 24 "  )  ; %NWL%cal . weekNumbers = params . weekNumbers ; %NWL%8
var esprima = lazy (  ' esprima - fb '  )%NWL%var profile = require (  ' debug '  )  (  ' ecstacy : js : profile '  )%NWL%var applySourceMap = require (  ' apply - source - map '  )%NWL%var convert = require (  ' convert - source - map '  )%NWL%var db = require (  ' polyfills - db '  )  . recast%NWL%var Ecstacy = require (  '  .  / ecstacy '  )%NWL%module . exports = JS%NWL%Ecstacy . extend ( JS )%NWL%JS . db = db%NWL%JS . transform = db . transform%NWL%JS . transforms = db . transforms%NWL%9
MimeNode . prototype . _isValidDate = function ( date )  {%NWL%return Object . prototype . toString . call ( date )  =  =  =  '  [ object Date ]  ' && date . toString (  ) ! =  =  ' Invalid Date '  ;%NWL%}  ; %NWL%MimeNode . prototype . _decodeHeaderCharset = function ( parsed , options )  {%NWL%options = options || {  }  ; %NWL%if ( typeof parsed . value =  =  =  ' string '  )  {%NWL%parsed . value = mimefuncs . mimeWordsDecode ( parsed . value )  ;%NWL%}%NWL%Object . keys ( parsed . params || {  }  )  . forEach ( function ( key )  {%NWL%if ( typeof parsed . params [ key ]  =  =  =  ' string '  )  {%NWL%parsed . params [ key ]  = mimefuncs . mimeWordsDecode ( parsed . params [ key ]  )  ; %NWL%6
else {%NWL%console . log (  " Plugin "  + name +  " already exists .  "  )  ;%NWL%}%NWL%}  ; %NWL%PhoneGap . onDOMContentLoaded = new PhoneGap . Channel (  ' onDOMContentLoaded '  )  ; %NWL%PhoneGap . onNativeReady = new PhoneGap . Channel (  ' onNativeReady '  )  ; %NWL%PhoneGap . onPhoneGapInit = new PhoneGap . Channel (  ' onPhoneGapInit '  )  ; %NWL%PhoneGap . onPhoneGapReady = new PhoneGap . Channel (  ' onPhoneGapReady '  )  ; %NWL%PhoneGap . onPhoneGapInfoReady = new PhoneGap . Channel (  ' onPhoneGapInfoReady '  )  ; %NWL%PhoneGap . onResume = new PhoneGap . Channel (  ' onResume '  )  ; %NWL%PhoneGap . onPause = new PhoneGap . Channel (  ' onPause '  )  ; %NWL%4
if ( Y_Lang . isArray ( fillColor )  )%NWL%{%NWL%markerStyles . fill . color = fillColor [ i % fillColor . length ]  ;%NWL%}%NWL%else%NWL%{%NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ;%NWL%}%NWL%if ( Y_Lang . isArray ( borderColor )  )%NWL%{%NWL%markerStyles . border . color = borderColor [ i % borderColor . length ]  ; %NWL%2
delete dat . time%NWL%return dat%NWL%}  )  . map ( function ( dat )  {%NWL%if ( typeof dat . keywords =  =  =  " string "  )  {%NWL%dat . keywords = dat . keywords . split (  /  [  , \s ]  +  /  )%NWL%}%NWL%if ( Array . isArray ( dat . keywords )  )  {%NWL%dat . keywords = dat . keywords . join (  "  "  )%NWL%}%NWL%if ( typeof dat . author =  =  =  " string "  )  {%NWL%dat . author = dat . author . split (  /  [  , \s ]  +  /  )%NWL%4
json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%json . num_inputs = this . num_inputs ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%this . out_sy = json . out_sy ; %NWL%this . layer_type = json . layer_type ; %NWL%this . num_inputs = json . num_inputs ; %NWL%6
canvas . dotScreen = wrap ( dotScreen )  ; %NWL%canvas . edgeWork = wrap ( edgeWork )  ; %NWL%canvas . lensBlur = wrap ( lensBlur )  ; %NWL%canvas . zoomBlur = wrap ( zoomBlur )  ; %NWL%canvas . noise = wrap ( noise )  ; %NWL%canvas . denoise = wrap ( denoise )  ; %NWL%canvas . curves = wrap ( curves )  ; %NWL%canvas . swirl = wrap ( swirl )  ; %NWL%canvas . ink = wrap ( ink )  ; %NWL%canvas . vignette = wrap ( vignette )  ; %NWL%canvas . vibrance = wrap ( vibrance )  ; %NWL%0
contentType :  ' audio / mpeg '  ,%NWL%startTime : new Date (  )  ,%NWL%error : null%NWL%}  ; %NWL%function MockDownload ( params )  {%NWL%params = params || {  }  ; %NWL%this . id = params . id || ' 0 '  ; %NWL%this . totalBytes = params . totalBytes || DEFAULT_PARAMS . totalBytes ; %NWL%this . currentBytes = params . currentBytes || DEFAULT_PARAMS . currentBytes ; %NWL%this . url = params . url || DEFAULT_PARAMS . url ; %NWL%this . path = params . path || DEFAULT_PARAMS . path ; %NWL%7
registerHelpers ; %NWL%if ( !utils . isProduction )  {%NWL%hbs . handlebars . logger . level = 0 ;%NWL%}%NWL%coreHelpers . asset  = require (  '  .  / asset '  )  ; %NWL%coreHelpers . author  = require (  '  .  / author '  )  ; %NWL%coreHelpers . body_class  = require (  '  .  / body_class '  )  ; %NWL%coreHelpers . content  = require (  '  .  / content '  )  ; %NWL%coreHelpers . date  = require (  '  .  / date '  )  ; %NWL%coreHelpers . encode  = require (  '  .  / encode '  )  ; %NWL%coreHelpers . excerpt  = require (  '  .  / excerpt '  )  ; %NWL%4
}%NWL%module . exports = Page ; %NWL%Page . addDefaults = function ( basis , item )  {%NWL%if ( typeof item =  =  =  " undefined "  )  { item =  {  }  ;  }%NWL%basis . item = basis . item || item . id ; %NWL%basis . language = basis . language || cody . Application . kDefaultLanguage ; %NWL%basis . title = basis . title || item . name || cody . Item . kDefaultName ; %NWL%basis . created = basis . created || new Date (  )  ; %NWL%basis . updated = basis . updated || new Date (  )  ; %NWL%basis . link = basis . link || "  "  ; %NWL%basis . keywords = basis . keywords || "  "  ; %NWL%9
this . positionSpread . copy ( other . positionSpread )  ; %NWL%this . positionRadius = other . positionRadius ; %NWL%this . speed = other . speed ; %NWL%this . speedSpread = other . speedSpread ; %NWL%this . worldSpace = other . worldSpace ; %NWL%this . minEmission = other . minEmission ; %NWL%this . maxEmission = other . maxEmission ; %NWL%this . minLife = other . minLife ; %NWL%this . maxLife = other . maxLife ; %NWL%this . minSize = other . minSize ; %NWL%this . maxSize = other . maxSize ; %NWL%1
if ( this . copyrightLabel ! = null && lang . trim ( this . copyrightLabel ) ! =  "  "  )%NWL%{%NWL%this . copyrightLabel = this . message ( this . copyrightLabel )  ;%NWL%}%NWL%else%NWL%{%NWL%this . copyrightLabel = this . message (  " label . copyright "  )  ;%NWL%}%NWL%if ( this . altText ! = null && lang . trim ( this . altText ) ! =  "  "  )%NWL%{%NWL%this . altText = this . message ( this . altText )  ; %NWL%2
newBadge . issuerUrl = badge . issuerUrl ; %NWL%newBadge . criteria = badge . criteria ; %NWL%newBadge . alignments = badge . alignments ; %NWL%newBadge . created = new Date ( badge . created )  ; %NWL%newBadge . lastUpdated = new Date ( badge . created )  ;  /  / not a typo .  badgekit - api doesn ' t yet have a notion of last updated .%NWL%newBadge . badgeType = badge . type ; %NWL%newBadge . categories = badge . categories || [  ]  ; %NWL%newBadge . tags = badge . tags || [  ]  ; %NWL%newBadge . system = badge . system ? badge . system . slug : null ; %NWL%newBadge . issuer = badge . issuer ? badge . issuer . slug : null ; %NWL%newBadge . program = badge . program ? badge . program . slug : null ; %NWL%8
var last_element = document . body . children [ document . body . children . length - 1 ]  ; %NWL%var children =  [  ]  ; %NWL%var element_count = container . children . length ; %NWL%for ( var index = 0 ; index < element_count ; index +  = 1 )%NWL%children . push ( container . children [ index ]  )  ; %NWL%while ( children . length > 0 )  {%NWL%var child = children . shift (  )  ; %NWL%document . body . insertBefore ( child , last_element )  ;%NWL%}%NWL%this . main_wrapper = document . getElementById (  '  < % = html_element_id (  : main_wrapper ) % >  '  )  ; %NWL%this . spacer = document . getElementById (  '  < % = html_element_id (  : spacer ) % >  '  )  ; %NWL%9
var hsl = factories . HSL (  )  ; %NWL%hsl . hue   =  ( colorGroups [ 2 ] % 360 + 360 ) % 360 ; %NWL%hsl . saturation = Math . max ( 0 , Math . min ( parseInt ( colorGroups [ 3 ]  , 10 )  / 100 , 1 )  )  ; %NWL%hsl . lightness  = Math . max ( 0 , Math . min ( parseInt ( colorGroups [ 4 ]  , 10 )  / 100 , 1 )  )  ; %NWL%hsl . alpha   = !!colorGroups [ 5 ] ? Math . max ( 0 , Math . min ( 1 , parseFloat ( colorGroups [ 6 ]  )  )  )  : 1 ; %NWL%return hsl ;%NWL%}  ,%NWL%_fromHSL : function ( HSL )  {%NWL%var newHSL = factories . HSL (  )  ; %NWL%newHSL . hue = HSL . hue ; %NWL%newHSL . saturation = HSL . saturation ; %NWL%9
this . left +  = offset . x ; %NWL%this . right +  = offset . x ; %NWL%this . top +  = offset . y ; %NWL%this . bottom +  = offset . y ; %NWL%return this ;%NWL%}  ,%NWL%round : function (  )  {%NWL%this . top = Math . round ( this . top )  ; %NWL%this . right = Math . round ( this . right )  ; %NWL%this . bottom = Math . round ( this . bottom )  ; %NWL%this . left = Math . round ( this . left )  ; %NWL%7
years :  "  {  { amount }  } years "%NWL%}%NWL%}%NWL%}  ; %NWL%function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%8
this . _host = base . _host ; %NWL%this . _port = base . _port ; %NWL%this . _path = base . _path . slice (  )  ; %NWL%this . _query = base . _query ; %NWL%break loop ;%NWL%} else if (  '  /  '  =  = c || ' \\ '  =  = c )  {%NWL%if (  ' \\ '  =  = c )%NWL%err (  ' \\ is an invalid code point .  '  )  ; %NWL%state =  ' relative slash '  ;%NWL%} else if (  ' ? '  =  = c )  {%NWL%this . _host = base . _host ; %NWL%1
styles . width = Math . max ( rel . siblingRect . width , rel . elementRect . width )  ; %NWL%else%NWL%styles . width = rel . elementRect . width ; %NWL%if ( this . inline )%NWL%styles . top = loc + this . winTopScroll . y ; %NWL%else%NWL%styles . top = this . rect . top + this . winTopScroll . y + loc ; %NWL%if ( styles . top - this . winTopScroll . y < this . rect . top || styles . top - this . winTopScroll . y > this . rect . bottom )%NWL%return false ; %NWL%if ( this . inline )%NWL%styles . left = rel . elementRect . left ; %NWL%2
test (  ' Should position tabs horizontally '  , function (  )  {%NWL%this . children [ 0 ]  . pos = this . children [ 0 ]  . getBoundingClientRect (  )  ; %NWL%this . children [ 1 ]  . pos = this . children [ 1 ]  . getBoundingClientRect (  )  ; %NWL%this . children [ 2 ]  . pos = this . children [ 2 ]  . getBoundingClientRect (  )  ; %NWL%assert . isTrue ( this . children [ 0 ]  . pos . right < this . children [ 1 ]  . pos . right )  ; %NWL%assert . isTrue ( this . children [ 1 ]  . pos . right < this . children [ 2 ]  . pos . right )  ;%NWL%}  )  ; %NWL%test (  ' Should size each tab to fill horizontal space equally '  , function (  )  {%NWL%this . el . pos = this . el . getBoundingClientRect (  )  ; %NWL%this . children [ 0 ]  . pos = this . children [ 0 ]  . getBoundingClientRect (  )  ; %NWL%this . children [ 1 ]  . pos = this . children [ 1 ]  . getBoundingClientRect (  )  ; %NWL%1
this . minX = minX ; %NWL%this . maxX = maxX ; %NWL%this . minY = minY ; %NWL%this . maxY = maxY ; %NWL%this . minZ = minZ ; %NWL%this . maxZ = maxZ ;%NWL%}  ,%NWL%combine : function ( aabb1 , aabb2 )  {%NWL%this . minX =  ( aabb1 . minX < aabb2 . minX ) ? aabb1 . minX : aabb2 . minX ; %NWL%this . maxX =  ( aabb1 . maxX > aabb2 . maxX ) ? aabb1 . maxX : aabb2 . maxX ; %NWL%this . minY =  ( aabb1 . minY < aabb2 . minY ) ? aabb1 . minY : aabb2 . minY ; %NWL%8
function CreateBackgroundService ( serviceName , require , exports , module )  {%NWL%var exec = require (  " cordova / exec "  )  ; %NWL%var BackgroundService = function ( serviceName )  {%NWL%var ServiceName = serviceName%NWL%this . getServiceName = function (  )  {%NWL%return ServiceName ;%NWL%}  ;%NWL%}  ; %NWL%var BackgroundServiceError = function ( code , message )  {%NWL%this . code = code || null ; %NWL%this . message = message || null ; %NWL%9
util . inherits ( VoltMessageManager , EventEmitter )  ; %NWL%function VoltConnection ( configuration )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . config = configuration ; %NWL%this . onConnect = this . onConnect . bind ( this )  ; %NWL%this . onError = this . onError . bind ( this )  ; %NWL%this . onRead = this . onRead . bind ( this )  ; %NWL%this . _send = this . _send . bind ( this )  ; %NWL%this . _flush = this . _flush . bind ( this )  ; %NWL%this . isValidConnection = this . isValidConnection . bind ( this )  ; %NWL%this . isBlocked = this . isBlocked . bind ( this )  ; %NWL%4
var children =  [  ]  ; %NWL%var element_count = container . children . length ; %NWL%for ( var index = 0 ; index < element_count ; index +  = 1 )%NWL%children . push ( container . children [ index ]  )  ; %NWL%while ( children . length > 0 )  {%NWL%var child = children . shift (  )  ; %NWL%document . body . insertBefore ( child , last_element )  ;%NWL%}%NWL%this . main_wrapper = document . getElementById (  '  < % = html_element_id (  : main_wrapper ) % >  '  )  ; %NWL%this . spacer = document . getElementById (  '  < % = html_element_id (  : spacer ) % >  '  )  ; %NWL%this . style_wrapper = document . getElementById (  '  < % = html_element_id (  : style_wrapper ) % >  '  )  ; %NWL%8
' JBrowse / Model / Location '%NWL%]  ,%NWL%function ( declare , dom , focus , dijitTextBox , ActionBarDialog , on , Button , Location )  {%NWL%return declare ( ActionBarDialog ,%NWL%{%NWL%autofocus : false ,%NWL%title :  ' Set highlight '  ,%NWL%constructor : function ( args )  {%NWL%this . browser = args . browser ; %NWL%this . setCallback  = args . setCallback || function (  )  {  }  ; %NWL%this . cancelCallback = args . cancelCallback || function (  )  {  }  ; %NWL%9
hints . audio . mandatory = merge ( hints . audio . mandatory , audioMandatoryConstraints )  ;%NWL%}%NWL%if ( hints . video ! =  = false && typeof hints . video ! =  =  ' boolean '  )  {%NWL%var videoMandatoryConstraints = videoConstraints . mandatory ; %NWL%if ( videoMandatoryConstraints )  {%NWL%var mandatory =  {  }  ; %NWL%if ( videoMandatoryConstraints . minWidth )  {%NWL%mandatory . minWidth = videoMandatoryConstraints . minWidth ;%NWL%}%NWL%if ( videoMandatoryConstraints . minHeight )  {%NWL%mandatory . minHeight = videoMandatoryConstraints . minHeight ; %NWL%7
reduced . open_time = row . open_time ; %NWL%reduced . open   = row . open ;%NWL%}%NWL%if ( row . sort_close > reduced . sort_close )  {%NWL%reduced . sort_close = row . sort_close ; %NWL%reduced . close_time = row . close_time ; %NWL%reduced . close   = row . close ;%NWL%}%NWL%} else {%NWL%if ( row . open_time < reduced . open_time )  {%NWL%reduced . open_time = row . open_time ; %NWL%1
else%NWL%this . $onSingleSelect (  )  ;%NWL%}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%if ( editor . $multiselectOnSessionChange )%NWL%return ; %NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%editor . $onMultiSelect = editor . $onMultiSelect . bind ( editor )  ; %NWL%editor . $onSingleSelect = editor . $onSingleSelect . bind ( editor )  ; %NWL%7
multiply : function ( c1 , c2 )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red * c2 . red ; %NWL%result . green = c1 . green * c2 . green ; %NWL%result . blue = c1 . blue * c2 . blue ; %NWL%return result ;%NWL%}  ,%NWL%multiplyScalar : function ( c1 , f )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red * f ; %NWL%result . green = c1 . green * f ; %NWL%9
partialResult =  {%NWL%host : stackConfig . server ,%NWL%port : stackConfig . port ,%NWL%transport : stackConfig . transport ,%NWL%meth : msgConfig . meth ,%NWL%auth : hasAuth ,%NWL%data : finalRes%NWL%}  ; %NWL%if ( parsedService )  {%NWL%partialResult . service = parsedService . service ; %NWL%partialResult . version = parsedService . version ; %NWL%9
_date . headline			 = data . date [ i ]  . headline ; %NWL%_date . type				 = data . date [ i ]  . type ; %NWL%_date . date				 = VMM . Date . prettyDate ( _date . startdate , false , _date . precisiondate )  ; %NWL%_date . asset				 = data . date [ i ]  . asset ; %NWL%_date . fulldate			 = _date . startdate . getTime (  )  ; %NWL%_date . text				 = data . date [ i ]  . text ; %NWL%_date . content			 =  "  "  ; %NWL%_date . tag				 = data . date [ i ]  . tag ; %NWL%_date . slug				 = data . date [ i ]  . slug ; %NWL%_date . uniqueid			 = VMM . Util . unique_ID ( 7 )  ; %NWL%_date . classname			 = data . date [ i ]  . classname ; %NWL%0
if ( conflict . content =  =  = undefined )  {%NWL%throw new Error (  ' Missing conflict . content option '  )  ;%NWL%}%NWL%this . conflicts . push ( conflict )  ; %NWL%return this ;%NWL%}  ; %NWL%conflicter . reset = function reset (  )  {%NWL%this . conflicts =  [  ]  ; %NWL%return this ;%NWL%}  ; %NWL%conflicter . pop = function pop (  )  {%NWL%6
mTextModel , mUndoStack ,%NWL%mFolderView , mEditorView , mPluginEditorView , mMarkdownView , mMarkdownEditor ,%NWL%mCommandRegistry , mContentTypes , mFileClient , mFileCommands , mEditorCommands , mSelection , mStatus , mProgress , mOperationsClient , mOutliner , mDialogs , mExtensionCommands , ProjectCommands , mSearchClient ,%NWL%EventTarget , URITemplate , i18nUtil , PageUtil , objects , lib , Deferred , mProjectClient , mSplitter , mSplitMenu%NWL%)  {%NWL%var exports =  {  }  ; %NWL%var enableSplitEditor = false ; %NWL%var uriTemplate = new URITemplate (  " # {  , resource , params *  }  "  )  ;  /  / $NON - NLS - 0$%NWL%function MenuBar ( options )  {%NWL%this . parentNode = options . parentNode ; %NWL%this . commandRegistry = options . commandRegistry ; %NWL%9
if ( obj . hasOwnProperty (  " rotate "  )  )  {%NWL%this . rotate = obj . rotate ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " angle "  )  )  {%NWL%this . angle = obj . angle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " textFillStyle "  )  )  {%NWL%this . textFillStyle = obj . textFillStyle ;%NWL%}%NWL%if ( obj . hasOwnProperty (  " lineStrokeStyle "  )  )  {%NWL%this . lineStrokeStyle = obj . lineStrokeStyle ; %NWL%1
cc . Node . prototype . onEnter . call ( this )  ;%NWL%}  ,%NWL%getColor : function (  )  {%NWL%var locColor = this . _color ; %NWL%return cc . color ( locColor . r , locColor . g , locColor . b , locColor . a )  ;%NWL%}  ,%NWL%setColor : function ( color )  {%NWL%var locColor = this . _color ; %NWL%locColor . r = color . r ; %NWL%locColor . g = color . g ; %NWL%locColor . b = color . b ; %NWL%9
}  )  ; %NWL%this . onMatchFound . addEventListener ( function ( matchManager , match )  {%NWL%matchManager . currentMatch = match ;%NWL%}  )  ; %NWL%this . onMatchRequestCanceled = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onMatchRequestCanceled "  , function ( sourceListener , args )%NWL%{%NWL%if ( me . matchManagerID =  =  = args [ 0 ]  )  {%NWL%sourceListener ( me )  ;%NWL%}%NWL%}  )  ; %NWL%this . onMatchRequestFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onMatchRequestFailed "  , function ( sourceListener , args )%NWL%4
this . description = args . description ; %NWL%this . host = parent . host || ' localhost '  ; %NWL%this . method =  ( httpMethod || errors . push (  ' Operation '  + operationId +  ' is missing method .  '  )  )  ; %NWL%this . models = models || {  }  ; %NWL%this . nickname =  ( operationId || errors . push (  ' Operations must have a nickname .  '  )  )  ; %NWL%this . operation = args ; %NWL%this . operations =  {  }  ; %NWL%this . parameters = args ! =  = null ? ( args . parameters || [  ]  )  :  {  }  ; %NWL%this . parent = parent ; %NWL%this . path =  ( path || errors . push (  ' Operation '  + this . nickname +  ' is missing path .  '  )  )  ; %NWL%this . produces = args . produces ; %NWL%0
}%NWL%return config ;%NWL%}  ,%NWL%_getRoot = function ( node , subscriber )  {%NWL%return subscriber . _extra . root || ( node . get ( NODE_TYPE )  =  =  = 9 ) ? node : node . get ( OWNER_DOCUMENT )  ;%NWL%}  ,%NWL%_normTouchFacade = function ( touchFacade , touch , params )  {%NWL%touchFacade . pageX = touch . pageX ; %NWL%touchFacade . pageY = touch . pageY ; %NWL%touchFacade . screenX = touch . screenX ; %NWL%touchFacade . screenY = touch . screenY ; %NWL%7
}%NWL%var Tabletop = function ( options )  {%NWL%if ( !this || ! ( this instanceof Tabletop )  )  {%NWL%return new Tabletop ( options )  ;%NWL%}%NWL%if ( typeof ( options )  =  =  =  ' string '  )  {%NWL%options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%8
return ;%NWL%}%NWL%module (  ' LMD cache @ '  + ENV_NAME )  ; %NWL%asyncTest (  " localStorage cache + cache_async test "  , function (  )  {%NWL%expect ( 11 )  ; %NWL%ok ( typeof ls [  ' lmd '  ]  =  =  =  " string "  ,  ' LMD Should create cache '  )  ; %NWL%var lmd = JSON . parse ( ls [  ' lmd '  ]  )  ; %NWL%ok ( typeof lmd . modules =  =  =  ' object '  ,  ' Should save modules '  )  ; %NWL%ok ( typeof lmd . main =  =  =  ' string '  ,  ' Should save main function as string '  )  ; %NWL%ok ( typeof lmd . lmd =  =  =  ' string '  ,  ' Should save lmd source as string '  )  ; %NWL%ok ( typeof lmd . options =  =  =  ' object '  ,  ' Should save options '  )  ; %NWL%7
}%NWL%return keys ;%NWL%}  ; %NWL%var pSlice = Array . prototype . slice ; %NWL%var assert = exports ; %NWL%assert . AssertionError = function AssertionError ( options )  {%NWL%this . name =  " AssertionError "  ; %NWL%this . message = options . message ; %NWL%this . actual = options . actual ; %NWL%this . expected = options . expected ; %NWL%this . operator = options . operator ; %NWL%7
this . indices [ index_name ]  = obj ;%NWL%}%NWL%this . addRecord = function ( record )  {%NWL%this . records . push ( record )  ;%NWL%}  ; %NWL%return this ;%NWL%}%NWL%function oIndex ( index )  {%NWL%this . name = index . name ; %NWL%this . keyPath = index . keyPath ; %NWL%this . unique = index . unique ; %NWL%8
Fast . map = require (  '  .  / map '  )  ; %NWL%Fast . filter = require (  '  .  / filter '  )  ; %NWL%Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%Fast . reduce = require (  '  .  / reduce '  )  ; %NWL%Fast . reduceRight = require (  '  .  / reduceRight '  )  ; %NWL%Fast . cloneArray = Fast . array . clone ;  /  / @deprecated use fast . array . clone (  )%NWL%Fast . concat = Fast . array . concat ; %NWL%Fast . some = Fast . array . some ; %NWL%Fast . every = Fast . array . every ; %NWL%Fast . indexOf = Fast . array . indexOf ; %NWL%Fast . lastIndexOf = Fast . array . lastIndexOf ; %NWL%6
self . setPropertyOrDefault ( colDef ,  ' filters '  , defaultFilters )  ;%NWL%} else if ( self . filters . length =  =  = defaultFilters . length )  {%NWL%self . filters . forEach ( function ( filter , index )  {%NWL%if ( typeof ( defaultFilters [ index ]  . placeholder ) ! =  =  ' undefined '  )  {%NWL%filter . placeholder = defaultFilters [ index ]  . placeholder ;%NWL%}%NWL%if ( typeof ( defaultFilters [ index ]  . flags ) ! =  =  ' undefined '  )  {%NWL%filter . flags = defaultFilters [ index ]  . flags ;%NWL%}%NWL%if ( typeof ( defaultFilters [ index ]  . type ) ! =  =  ' undefined '  )  {%NWL%filter . type = defaultFilters [ index ]  . type ; %NWL%4
return function ( id , offset )  {%NWL%var node = new TablePageBreakNode ( id , offset )%NWL%node . children = children . map ( function ( child )  {%NWL%return child . clone (  )%NWL%}  )%NWL%return node%NWL%}%NWL%}%NWL%TablePageBreakNode . prototype . _compute = function ( cursor )  {%NWL%this . x = cursor . x%NWL%this . y = cursor . y%NWL%9
toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%9
if ( self . isLoose ) callback = self . looseHandle ; %NWL%var result = callback . call ( self , this , getThisReference )  ; %NWL%if ( result ) this . hasSuper = true ; %NWL%if ( result =  =  = true ) return ; %NWL%return result ;%NWL%}%NWL%}  ; %NWL%export default class ReplaceSupers {%NWL%constructor ( opts : Object , inClass? : boolean = false )  {%NWL%this . topLevelThisReference = opts . topLevelThisReference ; %NWL%this . methodPath    = opts . methodPath ; %NWL%9
this . onopen ( make_event (  ' open '  )  )  ;%NWL%}%NWL%}  ,%NWL%_receive_data : function ( data )  {%NWL%this . onmessage ( make_event (  " message "  ,  {  ' data '  : data }  )  )  ;%NWL%}%NWL%}  ; %NWL%FakeWebSocket . OPEN = WebSocket . OPEN ; %NWL%FakeWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%FakeWebSocket . CLOSING = WebSocket . CLOSING ; %NWL%FakeWebSocket . CLOSED = WebSocket . CLOSED ; %NWL%7
cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . locales = obj . locales ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . nonadditive = obj . nonadditive ; %NWL%1
t . path = base . path . replace (  /  [ ^\ /  ]  + $ /  ,  '  '  )  + r . path ;%NWL%}%NWL%t . path = removeDotSegments ( t . path )  ;%NWL%}%NWL%t . query = r . query ;%NWL%}%NWL%t . authority = base . authority ;%NWL%}%NWL%t . scheme = base . scheme ;%NWL%}%NWL%t . fragment = r . fragment ; %NWL%4
this . wheelRef . obj = this . wheelModel ; %NWL%this . wheelObj . bindChild ( this . wheelRef )  ;%NWL%}  ,%NWL%setSuspensionStiffness : function ( suspensionStiffness_in )  {%NWL%this . suspensionStiffness = suspensionStiffness_in ;%NWL%}  ,%NWL%getSuspensionStiffness : function (  )  {%NWL%return this . suspensionStiffness ;%NWL%}  ,%NWL%setSuspensionRest : function ( suspensionRest_in )  {%NWL%this . suspensionRest = suspensionRest_in ; %NWL%4
}  ; %NWL%var current_keys =  {%NWL%codes :  {  }  ,%NWL%ctrl : false ,%NWL%alt : false ,%NWL%shift : false%NWL%}  ; %NWL%function update_current_modifiers ( key )  {%NWL%current_keys . ctrl = key . ctrl ; %NWL%current_keys . alt = key . alt ; %NWL%current_keys . shift = key . shift ; %NWL%8
Player . position ( Map . playerStart . x - surfaceX , Map . playerStart . y - surfaceY )  ; %NWL%Player . update (  )  ; %NWL%Scene . Ticker ( paint ,  {  ' useAnimationRequest '  : true }  )  . run (  )  ;%NWL%}  /  / end main (  )%NWL%function setupGame ( callback )  {%NWL%var layer , soundList , direction , doc ; %NWL%doc = window . document ; %NWL%if ( debug . output )  {%NWL%debug . fps = doc . getElementById (  ' fps '  )  ; %NWL%debug . load = doc . getElementById (  ' load '  )  ; %NWL%debug . dropped = doc . getElementById (  ' dropped '  )  ; %NWL%8
if ( !settings )%NWL%settings =  {  }  ; %NWL%if ( settings . elements )%NWL%settings . elements = dojo . mixin (  {  }  , this . elements , settings . elements )  ; %NWL%if ( settings . tags )%NWL%settings . tags = dojo . mixin (  {  }  , this . tags , settings . tags )  ; %NWL%dojo . mixin ( this , settings )  ; %NWL%if ( !settings . tags )%NWL%settings . tags = this . tags ; %NWL%if ( !settings . p11nAlgorithm )%NWL%settings . p11nAlgorithm = this . p11nAlgorithm ; %NWL%8
if ( !number )  { throw invalidArgument ;  }%NWL%return update ( raw (  ) % number )  ;%NWL%}  ; %NWL%object . reverseSign = function (  )  { return update ( Math . abs ( raw (  )  *  - 1 )  )  ;  }  ; %NWL%object . abs = function (  )  { return update ( Math . abs ( raw (  )  )  )  ;  }  ; %NWL%object . acos = function (  )  { return update ( Math . acos ( raw (  )  )  )  ;  }  ; %NWL%object . asin = function (  )  { return update ( Math . asin ( raw (  )  )  )  ;  }  ; %NWL%object . atan = function (  )  { return update ( Math . atan ( raw (  )  )  )  ;  }  ; %NWL%object . ceil = function (  )  { return update ( Math . ceil ( raw (  )  )  )  ;  }  ; %NWL%object . cos = function (  )  { return update ( Math . cos ( raw (  )  )  )  ;  }  ; %NWL%object . exp = function (  )  { return update ( Math . exp ( raw (  )  )  )  ;  }  ; %NWL%4
}%NWL%}%NWL%return function ( node , selector )  {%NWL%return node [ testFunc ]  ( selector )  ;%NWL%}%NWL%}  )  (  )  ; %NWL%function View ( config )  {%NWL%this . template = config . template || null ; %NWL%this . container = config . container || ' body '  ; %NWL%this . events = config . events || {  }  ; %NWL%this . model = config . model || null ; %NWL%7
}  ; %NWL%cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . locales = obj . locales ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%2
var fieldsNeeded =  [  ]  ; %NWL%var selectedChartType = $chartTypeDropDown . val (  )  ; %NWL%if ( chartTypes [ selectedChartType ]  )  {%NWL%var ct = chartTypes [ selectedChartType ]  ; %NWL%for ( var f in ct . fields )  {%NWL%var field = ct . fields [ f ]  ; %NWL%field . val = field . $input . val (  )  ; %NWL%if ( field . val && gmeta [ field . val ]  )  {%NWL%field . datatype = gmeta [ field . val ]  . datatype ; %NWL%field . min = gmeta [ field . val ]  . min ; %NWL%field . max = gmeta [ field . val ]  . max ; %NWL%8
}  ,%NWL%applyParentTransform : function ( parent )  {%NWL%var locWorldInfo = this . _worldInfo ; %NWL%var locParentWorldTransform = parent . _worldTransform ; %NWL%var locParentWorldInfo = parent . _worldInfo ; %NWL%var x = locWorldInfo . x ; %NWL%var y = locWorldInfo . y ; %NWL%locWorldInfo . x = x * locParentWorldTransform . a + y * locParentWorldTransform . c + locParentWorldInfo . x ; %NWL%locWorldInfo . y = x * locParentWorldTransform . b + y * locParentWorldTransform . d + locParentWorldInfo . y ; %NWL%locWorldInfo . scaleX = locWorldInfo . scaleX * locParentWorldInfo . scaleX ; %NWL%locWorldInfo . scaleY = locWorldInfo . scaleY * locParentWorldInfo . scaleY ; %NWL%9
proto . assertPassedMapping = function assertPassedMapping (  )  {%NWL%this . assertCycleSequence ( this . mappingName )  ;%NWL%}  ; %NWL%proto . assertPassedMappingWithArguments = function assertPassedMappingWithArguments (  )  {%NWL%this . assertPassedMapping (  )  ; %NWL%if ( this . actualMappingArguments . length ! = this . expectedMappingArguments . length ||%NWL%this . actualMappingArguments [ 0 ] ! = this . expectedMappingArguments [ 0 ] ||%NWL%this . actualMappingArguments [ 1 ] ! = this . expectedMappingArguments [ 1 ]  )%NWL%throw ( new Error (  " Expected arguments to be passed to mapping .  "  )  )  ;%NWL%}  ; %NWL%proto . assertPassedMappingWithMultipleArguments = function assertPassedMappingWithMultipleArguments (  )  {%NWL%0
req . body . lastName = S ( req . body . lastName || '  '  )  . trim (  )  . capitalize (  )  . s ; %NWL%app . models . User . findOrCreateLocal ( req . body , function ( err , user )  {%NWL%if ( err )  { return _sendError ( err )  ;  }%NWL%req . logIn ( user , function ( err )  {%NWL%if ( err )  { return _sendError ( err )  ;  }%NWL%return cb ( null , user . getSafeJSON (  )  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}%NWL%exports . login =  { POST : loginPOST }  ; %NWL%exports . logout =  { POST : logoutPOST }  ; %NWL%9
}%NWL%return loss ;%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%8
module . paths = Module . _nodeModulePaths ( cwd )  ; %NWL%var script = process . _eval ; %NWL%script = regenerator . compile ( script ,  {%NWL%includeRuntime :  ' object ' ! =  = typeof regeneratorRuntime%NWL%}  )  . code ; %NWL%if ( !Module . _contextLoad )  {%NWL%var body = script ; %NWL%script =  ' global . __filename =  '  + JSON . stringify ( name )  +  '  ; \n '  +%NWL%' global . exports = exports ; \n '  +%NWL%' global . module = module ; \n '  +%NWL%' global . __dirname = __dirname ; \n '  +%NWL%8
}  ,%NWL%destroy   : function destroy (  )  {%NWL%this . inherited ( arguments )  ; %NWL%DEBUG && this . log (  " ########## Destroyed .  "  )  ;%NWL%}  ,%NWL%infoChanged  : function infoChanged (  )  {%NWL%if ( !this . info )  {%NWL%return ;%NWL%}%NWL%this . event = this . info . event ; %NWL%this . parentId = this . info . parentId ; %NWL%9
function createReporterDom ( version )  {%NWL%dom . reporter = self . createDom (  ' div '  ,  { id :  ' HTMLReporter '  , className :  ' jasmine_reporter '  }  ,%NWL%dom . banner = self . createDom (  ' div '  ,  { className :  ' banner '  }  ,%NWL%self . createDom (  ' span '  ,  { className :  ' title '  }  ,  " Jasmine "  )  ,%NWL%self . createDom (  ' span '  ,  { className :  ' version '  }  , version )  )  ,%NWL%dom . symbolSummary = self . createDom (  ' ul '  ,  { className :  ' symbolSummary '  }  )  ,%NWL%dom . alert = self . createDom (  ' div '  ,  { className :  ' alert '  }  ,%NWL%self . createDom (  ' span '  ,  { className :  ' exceptions '  }  ,%NWL%self . createDom (  ' label '  ,  { className :  ' label '  ,  ' for '  :  ' no_try_catch '  }  ,  ' No try / catch '  )  ,%NWL%self . createDom (  ' input '  ,  { id :  ' no_try_catch '  , type :  ' checkbox '  }  )  )  )  ,%NWL%dom . results = self . createDom (  ' div '  ,  { className :  ' results '  }  ,%NWL%6
gl . linkProgram ( p )  ; %NWL%p . textureWd = gl . getUniformLocation ( p ,  " u_texw "  )  ; %NWL%p . textureHt = gl . getUniformLocation ( p ,  " u_texh "  )  ; %NWL%p . texture = gl . getUniformLocation ( p ,  " u_data "  )  ; %NWL%p . visTileWd = gl . getUniformLocation ( p ,  " u_visTileWd "  )  ; %NWL%p . visTileHt = gl . getUniformLocation ( p ,  " u_visTileHt "  )  ; %NWL%p . visibleTileWd = gl . getUniformLocation ( p ,  " u_visibleTileWd "  )  ; %NWL%p . visibleTileHt = gl . getUniformLocation ( p ,  " u_visibleTileHt "  )  ; %NWL%p . visXPos = gl . getUniformLocation ( p ,  " u_visXPos "  )  ; %NWL%p . visYPos = gl . getUniformLocation ( p ,  " u_visYPos "  )  ; %NWL%p . binCnts = gl . getUniformLocation ( p ,  " u_binCnts "  )  ; %NWL%9
}  /  / end `rawRequest`%NWL%function HttpClient ( options )  {%NWL%assert . object ( options ,  ' options '  )  ; %NWL%assert . optionalObject ( options . headers ,  ' options . headers '  )  ; %NWL%assert . object ( options . log ,  ' options . log '  )  ; %NWL%assert . optionalFunc ( options . signRequest ,  ' options . signRequest '  )  ; %NWL%assert . optionalString ( options . socketPath ,  ' options . socketPath '  )  ; %NWL%assert . optionalString ( options . url ,  ' options . url '  )  ; %NWL%EventEmitter . call ( this )  ; %NWL%this . agent = options . agent ; %NWL%this . cert = options . cert ; %NWL%9
if ( typeof object . server_options . auto_reconnect ! =  ' boolean '  )  {%NWL%object . server_options . auto_reconnect = true ;%NWL%}%NWL%for ( var i = 0 ; i < object . servers . length ; i +  +  )  {%NWL%var _server_options =  { poolSize : 1 , socketOptions :  { connectTimeoutMS : 1000 }  , auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%6
context . fixtures =  {%NWL%registerFileAs : fixtures . registerFileAs . bind ( fixtures )  ,%NWL%}  ; %NWL%var originalIt = context . it ; %NWL%context . it = runInsideFiber ( context . it )  ; %NWL%context . it . skip = runInsideFiber ( originalIt . skip )  ; %NWL%context . it . only = runInsideFiber ( originalIt . only )  ; %NWL%context . specify = context . it ; %NWL%context . xspecify = context . xit = context . it . skip ; %NWL%context . before = runInsideFiber ( context . before )  ; %NWL%context . beforeEach = runInsideFiber ( context . beforeEach )  ; %NWL%4
}%NWL%if ( g_mVB_Pos_font =  = null )  {%NWL%g_mVB_Pos_font = MakeGlFloatBuffer ( gl ,  [  ]  , gl . DYNAMIC_DRAW )  ; %NWL%g_mVB_Tex_font = MakeGlFloatBuffer ( gl ,  [  ]  , gl . DYNAMIC_DRAW )  ; %NWL%g_mVB_Pos2_font =  [ this . kMaxVerticesPerString * 2 ]  ; %NWL%g_mVB_Tex2_font =  [ this . kMaxVerticesPerString * 2 ]  ;%NWL%}%NWL%this . mVB_Pos = g_mVB_Pos_font ; %NWL%this . mVB_Tex = g_mVB_Tex_font ; %NWL%this . mVB_Pos2 = g_mVB_Pos2_font ; %NWL%this . mVB_Tex2 = g_mVB_Tex2_font ; %NWL%7
input . readStructEnd (  )  ; %NWL%return ;%NWL%}  ; %NWL%PublicUserInfo . prototype . write = function ( output )  {%NWL%output . writeStructBegin (  ' PublicUserInfo '  )  ; %NWL%if ( this . userId ! =  = null && this . userId ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' userId '  , Thrift . Type . I32 , 1 )  ; %NWL%output . writeI32 ( this . userId )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . shardId ! =  = null && this . shardId ! =  = undefined )  {%NWL%5
'  <  / div >  '  ,%NWL%'  < div ng - if =  " iFrameSrc " class =  " slide "  >  < iframe ng - src =  "  {  { iFrameSrc }  }  "  >  <  / div >  '%NWL%]  . join (  '  '  )  ,%NWL%controller :  ' SlideCtrl '%NWL%}  )  .%NWL%otherwise (  { redirectTo :  '  / firstSlide '  }  )  ;%NWL%}  )  ; %NWL%app . run ( function ( $rootScope , $document , $location , presentation )  {%NWL%presentation . getConfig ( function ( config )  {%NWL%$rootScope . title = config . title ; %NWL%$rootScope . slides = config . slides ; %NWL%9
command ; %NWL%for ( command in Engine . commands )  {%NWL%commands . push ( command )  ;%NWL%}%NWL%return commands ;%NWL%}%NWL%}  ; %NWL%CommandManager = new ( Registry . extend ( CommandManager )  )  (  )  ; %NWL%Aloha . execCommand = CommandManager . execCommand ; %NWL%Aloha . queryCommandEnabled = CommandManager . queryCommandEnabled ; %NWL%Aloha . queryCommandIndeterm = CommandManager . queryCommandIndeterm ; %NWL%8
}  ,%NWL%deserialize : function (  )  {%NWL%var allVars = $ . getUrlVars (  )  ; %NWL%state . key = allVars [  ' key '  ] ?allVars [  ' key '  ]  :  - 100 ; %NWL%state . disabled =  ' true '  =  =  = allVars [  ' disabled '  ]  ; %NWL%state . search =  ' true '  =  =  = allVars [  ' search '  ]  ; %NWL%state . subfolder =  ' true '  =  =  = allVars [  ' subfolder '  ]  ; %NWL%state . page = allVars [  ' page '  ] ?allVars [  ' page '  ]  : 1 ; %NWL%state . elems = allVars [  ' elems '  ] ?allVars [  ' elems '  ]  : 50 ; %NWL%state . nameordesc = allVars [  ' nameordesc '  ] || "  "  ; %NWL%state . asname = allVars [  ' asname '  ] || "  "  ; %NWL%9
addCustomOperation ( localElem )  ; %NWL%return onElemRestangularized ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%7
}  )%NWL%. factory ( result . UtestStoreResult ,  [ result . UtestStore , function ( UtestStore )  {%NWL%return UtestStore . getValue (  )  ;%NWL%}  ]  )  ; %NWL%result . UtestConstant =  " UtestConstant "  + suffix ; %NWL%result . UtestFactory =  " UtestFactory "  + suffix ; %NWL%result . factory_name =  " UtestFactory . name nSg56eHrWo "  + suffix ; %NWL%module . factory ( result . UtestFactory ,  [ result . UtestConstant , function ( UtestConstant )  {%NWL%return { name : result . factory_name , const_name : UtestConstant }  ;%NWL%}  ]  )  ; %NWL%result . UtestValue =  " UtestValue "  + suffix ; %NWL%4
if ( this . units =  =  " min "  )  { this . duration = this . duration * 1000 * 60 ;  }%NWL%if ( this . units =  =  " hr "  )  { this . duration = this . duration * 1000 * 60 * 60 ;  }%NWL%}%NWL%this . op1Templated = this . op1 . indexOf (  "  {  {  "  ) ! =  - 1 ; %NWL%this . op2Templated = this . op2 . indexOf (  "  {  {  "  ) ! =  - 1 ; %NWL%if ( !isNaN ( this . op1 )  )  { this . op1 = Number ( this . op1 )  ;  }%NWL%if ( !isNaN ( this . op2 )  )  { this . op2 = Number ( this . op2 )  ;  }%NWL%if ( this . op1 =  =  " true "  )  { this . op1 = true ;  }%NWL%if ( this . op2 =  =  " true "  )  { this . op2 = true ;  }%NWL%if ( this . op1 =  =  " false "  )  { this . op1 = false ;  }%NWL%if ( this . op2 =  =  " false "  )  { this . op2 = false ;  }%NWL%9
if ( typeof params . options . default_value =  =  ' undefined '  ) params . options . default_value  = 0 ; %NWL%StatRelation . parent . _init . call ( this , params )  ;%NWL%}  ; %NWL%StatRelation . prototype . merge_with = function ( criteria )  {%NWL%StatRelation . parent . merge_with . call ( this , criteria )  ; %NWL%this . default_value = criteria . default_value || this . default_value ;%NWL%}  ; %NWL%StatRelation . prototype . get_options = function (  )  {%NWL%var options = StatRelation . parent . get_options . call ( this )  ; %NWL%options . select   = this . select ; %NWL%options . default_value = this . default_value ; %NWL%9
basis . user = basis . user || parent . user ; %NWL%basis . sortorder = basis . sortorder || 9999 ; %NWL%basis . orderby = basis . orderby || parent . orderby ; %NWL%basis . dated = basis . dated || new Date (  )  ; %NWL%basis . validfrom = basis . validfrom || new Date (  )  ; %NWL%basis . validto = basis . validto || cody . Application . endOfTime (  )  ; %NWL%basis . template = basis . template || parent . template . defaultchild ; %NWL%basis . showcontent = basis . showcontent || Item . kContent ; %NWL%basis . needslogin = basis . needslogin || parent . needslogin ; %NWL%basis . defaultrequest = basis . defaultrequest || " list "  ; %NWL%basis . alloweddomains = basis . alloweddomains || parent . alloweddomains ; %NWL%0
if ( parent )  {%NWL%if ( !this . transition )  { this . transition = parent . transition ;  }%NWL%if ( this . icon1 && parent . iconBase &&%NWL%parent . iconBase . charAt ( parent . iconBase . length - 1 )  =  =  =  '  /  '  )  {%NWL%this . icon1 = parent . iconBase + this . icon1 ;%NWL%}%NWL%if ( !this . icon1 )  { this . icon1 = parent . iconBase ;  }%NWL%if ( !this . iconPos1 )  { this . iconPos1 = parent . iconPos ;  }%NWL%if ( this . icon2 && parent . iconBase &&%NWL%parent . iconBase . charAt ( parent . iconBase . length - 1 )  =  =  =  '  /  '  )  {%NWL%this . icon2 = parent . iconBase + this . icon2 ; %NWL%4
var types = require (  "  .  / lib / types "  )  ; %NWL%require (  "  .  / def / core "  )  ; %NWL%require (  "  .  / def / es6 "  )  ; %NWL%require (  "  .  / def / mozilla "  )  ; %NWL%require (  "  .  / def / e4x "  )  ; %NWL%require (  "  .  / def / fb - harmony "  )  ; %NWL%exports . Type = types . Type ; %NWL%exports . builtInTypes = types . builtInTypes ; %NWL%exports . namedTypes = types . namedTypes ; %NWL%exports . builders = types . builders ; %NWL%exports . defineMethod = types . defineMethod ; %NWL%6
self . children_loaded = 0 ; %NWL%self . children_rendered = 0 ; %NWL%self . no_children = false ; %NWL%self . init ( opts )  ;%NWL%}%NWL%init ( opts )  {%NWL%var self = this ,%NWL%$component = opts . component ; %NWL%self . config = BlocksConfig . getConfig (  )  ; %NWL%self . parent = opts . parent ; %NWL%self . page = opts . page ; %NWL%9
air . FileStream = window . runtime . flash . filesystem . FileStream ; %NWL%air . FileMode = window . runtime . flash . filesystem . FileMode ; %NWL%air . EncryptedLocalStore = window . runtime . flash . data . EncryptedLocalStore ; %NWL%air . SQLCollationType = window . runtime . flash . data . SQLCollationType ; %NWL%air . SQLColumnNameStyle = window . runtime . flash . data . SQLColumnNameStyle ; %NWL%air . SQLColumnSchema = window . runtime . flash . data . SQLColumnSchema ; %NWL%air . SQLConnection = window . runtime . flash . data . SQLConnection ; %NWL%air . SQLError = window . runtime . flash . errors . SQLError ; %NWL%air . SQLErrorEvent = window . runtime . flash . events . SQLErrorEvent ; %NWL%air . SQLErrorOperation = window . runtime . flash . errors . SQLErrorOperation ; %NWL%air . SQLEvent = window . runtime . flash . events . SQLEvent ; %NWL%8
this . COLGROUP = wtTable . COLGROUP ; %NWL%this . utils = WalkontableTableRenderer . utils ;%NWL%}%NWL%WalkontableTableRenderer . prototype . render = function (  )  {%NWL%if ( !this . wtTable . isWorkingOnClone (  )  )  {%NWL%this . instance . getSetting (  ' beforeDraw '  , true )  ;%NWL%}%NWL%this . rowHeaders = this . instance . getSetting (  ' rowHeaders '  )  ; %NWL%this . rowHeaderCount = this . rowHeaders . length ; %NWL%this . fixedRowsTop = this . instance . getSetting (  ' fixedRowsTop '  )  ; %NWL%this . columnHeaders = this . instance . getSetting (  ' columnHeaders '  )  ; %NWL%7
issues . failuresReset = function failuresReset (  )  {%NWL%Utils . merge ( this , JSON . parse ( JSON . stringify ( this . config )  )  )  ;%NWL%}  ; %NWL%Object . defineProperty ( issues ,  ' details '  ,  {%NWL%get : function getDetails (  )  {%NWL%var res =  {  }  ; %NWL%res . server = this . server ; %NWL%res . tokens = this . tokens ; %NWL%res . messages = this . messages ; %NWL%if ( this . failures )  {%NWL%res . failures = this . failures ; %NWL%6
return Step ;%NWL%}  )  ( Evented )  ; %NWL%Shepherd =  ( function ( _super )  {%NWL%__extends ( Shepherd , _super )  ; %NWL%function Shepherd ( options )  {%NWL%var _ref1 ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . hide = __bind ( this . hide , this )  ; %NWL%this . cancel = __bind ( this . cancel , this )  ; %NWL%this . back = __bind ( this . back , this )  ; %NWL%this . next = __bind ( this . next , this )  ; %NWL%7
}%NWL%return { x : x , y : y }  ;%NWL%}  ,%NWL%updatePosition : function (  )  {%NWL%var me = this ,%NWL%items = me . items ,%NWL%pos , i , l , bbox ; %NWL%if ( me . isDisplayed (  )  )  {%NWL%pos = me . calcPosition (  )  ; %NWL%me . x = pos . x ; %NWL%me . y = pos . y ; %NWL%9
}  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%shouldCorrectlyReAuthorizeReconnectedConnections : function ( test )  {%NWL%var user_name =  ' spongebob2 '  ; %NWL%var password =  ' password '  ; %NWL%var p_client = new Db ( MONGODB , new Server (  " 127 . 0 . 0 . 1 "  , 27017 ,  { auto_reconnect : true , poolSize : 3 }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%p_client . bson_deserializer = client . bson_deserializer ; %NWL%p_client . bson_serializer = client . bson_serializer ; %NWL%p_client . pkFactory = client . pkFactory ; %NWL%8
return divs [ i ]  ;%NWL%}%NWL%}%NWL%}  ; %NWL%var runner , spec , fakeTimer ; %NWL%beforeEach ( function (  )  {%NWL%fakeTimer = new jasmine . FakeTimer (  )  ; %NWL%env . setTimeout = fakeTimer . setTimeout ; %NWL%env . clearTimeout = fakeTimer . clearTimeout ; %NWL%env . setInterval = fakeTimer . setInterval ; %NWL%env . clearInterval = fakeTimer . clearInterval ; %NWL%7
this . _momentScripts =  [  ]  ; %NWL%this . _baseH = 21 ; %NWL%this . _isShowingIntervalScrips = false ; %NWL%this . _isHidingSelectedElems = false ; %NWL%this . _isPlaying = false ; %NWL%this . _onSelectClick = this . _onSelectClick . bind ( this )  ; %NWL%this . _onChangeTime = this . _onChangeTime . bind ( this )  ; %NWL%this . _onChangeIntervalScript = this . _onChangeIntervalScript . bind ( this )  ; %NWL%this . _onDeleteIntervalScript = this . _onDeleteIntervalScript . bind ( this )  ; %NWL%this . _onMoveIntervalScript = this . _onMoveIntervalScript . bind ( this )  ; %NWL%this . _onClickAddIntervalScript = this . _onClickAddIntervalScript . bind ( this )  ; %NWL%5
_wrapError : function ( err )  {%NWL%var errorObject =  {  }  ; %NWL%errorObject . stack = err . stack || '  '  ; %NWL%errorObject . message = err . message || err . toString (  )  ; %NWL%errorObject . type = err . type || ' Error '  ; %NWL%errorObject . constructorName = err . constructor . name || ' Error '  ; %NWL%if ( err . name )  {%NWL%errorObject . name = err . name ;%NWL%}%NWL%if ( err . code )  {%NWL%errorObject . code = err . code ; %NWL%7
var self = this ; %NWL%this . game = _game ; %NWL%this . key =  { SPACE : 0 , LEFT_ARROW : 0 , UP_ARROW : 0 , RIGHT_ARROW : 0 , DOWN_ARROW : 0 , A : 0 , B : 0 , C : 0 , D : 0 , E : 0 , F : 0 , G : 0 , H : 0 , I : 0 , J : 0 , K : 0 , L : 0 , M : 0 , N : 0 , O : 0 , P : 0 , Q : 0 , R : 0 , S : 0 , T : 0 , U : 0 , V : 0 , W : 0 , X : 0 , Y : 0 , Z : 0 }  ; %NWL%this . mouse =  { x : 0 , y : 0 , BUTTON_LEFT : 0 , BUTTON_MIDDLE : 0 , BUTTON_RIGHT : 0 }  ; %NWL%this . touch =  [  ]  ; %NWL%this . gamepad =  [  ]  ; %NWL%this . gamepadEnabled = false ; %NWL%this . accelerometer =  { x : 0 , y : 0 , z : 0 , alpha : 0 , beta : 0 , gamma : 0 , interval : 0 }  ; %NWL%this . keydown = function ( _e )  { self . onkeydown ( _e )  }  ; %NWL%this . keyup = function ( _e )  { self . onkeyup ( _e )  }  ; %NWL%this . mousedown = function ( _e )  { self . onmousedown ( _e )  }  ; %NWL%8
return new Tabletop ( options )  ;%NWL%}%NWL%if ( typeof ( options )  =  =  =  ' string '  )  {%NWL%options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%8
dgc . _Widget . markupFactory = function ( node , cell )  {%NWL%dgc . _Base . markupFactory ( node , cell )  ; %NWL%var d = dojo ; %NWL%var widgetProps = d . trim ( d . attr ( node ,  " widgetProps "  ) || "  "  )  ; %NWL%var constraint = d . trim ( d . attr ( node ,  " constraint "  ) || "  "  )  ; %NWL%var widgetClass = d . trim ( d . attr ( node ,  " widgetClass "  ) || "  "  )  ; %NWL%if ( widgetProps )  {%NWL%cell . widgetProps = d . fromJson ( widgetProps )  ;%NWL%}%NWL%if ( constraint )  {%NWL%cell . constraint = d . fromJson ( constraint )  ; %NWL%7
}  )  ;%NWL%}  )  ;%NWL%}%NWL%else if ( freeExports && freeModule )  {%NWL%freeExports . byKind = spotlight . byKind ; %NWL%freeExports . byName = spotlight . byName ; %NWL%freeExports . byValue = spotlight . byValue ; %NWL%freeExports . custom = spotlight . custom ; %NWL%freeExports . debug = spotlight . debug ; %NWL%freeExports . runInContext = spotlight . runInContext ; %NWL%freeExports . version = spotlight . version ; %NWL%4
before :  [  ]  ,%NWL%after :  [  ]%NWL%}  ; %NWL%if ( !parentModule )  {%NWL%return result ;%NWL%}%NWL%if ( Array . isArray ( opts )  )  {%NWL%result . before = resolvePaths ( parentModule , opts )  ;%NWL%} else {%NWL%result . before = resolvePaths ( parentModule , opts . before )  ; %NWL%result . after = resolvePaths ( parentModule , opts . after )  ; %NWL%9
self . name = details . name ; %NWL%self . protocol = details . protocol ; %NWL%self . port = details . port ; %NWL%self . algorithm = details . algorithm ; %NWL%self . cluster = details . cluster ; %NWL%self . status = details . status ; %NWL%self . timeout = details . timeout ; %NWL%self . halfClosed = details . halfClosed ; %NWL%self . nodes = details . nodes || [  ]  ; %NWL%self . virtualIps = details . virtualIps || [  ]  ; %NWL%self . sourceAddresses = details . sourceAddresses ; %NWL%0
}%NWL%this . Uninit = function (  )  {%NWL%clearInterval ( this . minTimer )  ;%NWL%}%NWL%this . onClientJoin = function onClientJoin ( client )  {%NWL%console . log (  ' A client joined map 1 '  )  ;%NWL%}%NWL%this . onClientLeave = function onClientLeave ( client )  {%NWL%console . log (  ' A client leaved map 1 '  )  ;%NWL%}%NWL%this . onCharacterLevel = function onCharacterLevel ( client )  {%NWL%4
}%NWL%} else {%NWL%if ( !filter ( fns [ i ]  )  )  {%NWL%fns . splice ( i , 1 )  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%var newRoutes = deepCopy ( routes )  ; %NWL%newRoutes . matched = routes . matched ; %NWL%newRoutes . captures = routes . captures ; %NWL%9
function offcanvas ( sltor , useropt )  {%NWL%var element = $ (  (  ( sltor || "  "  )  +  "  . st - offcanvas "  ) || "  . st - offcanvas "  )  ; %NWL%if ( element [ 0 ]  =  = undefined || element . data (  " st - offcanvas "  )  =  = true )  {%NWL%return false ;%NWL%}%NWL%this . element = element ; %NWL%this . showmenuselector = this . element . find (  "  . showmenubutton "  )  ; %NWL%this . showadditionalselector = this . element . find (  "  . showadditionalbutton "  )  ; %NWL%this . menu = this . element . find (  "  . st - offcanvas - menu "  )  ; %NWL%this . main = this . element . find (  "  . st - offcanvas - main "  )  ; %NWL%this . additional = this . element . find (  "  . st - offcanvas - additional "  )  ; %NWL%8
content . editableAttributes = contentInitDict . editableAttributes || [  ]  ; %NWL%content . id     = contentInitDict . id || Math . uuid ( null , 16 )  ; %NWL%content . name     = contentInitDict . name || "  "  ; %NWL%content . type     = contentInitDict . type || " IMAGE "  ; %NWL%content . mimeType    = contentInitDict . mimeType || "  "  ; %NWL%content . title     = contentInitDict . title || "  "  ; %NWL%content . contentURI   = contentInitDict . contentURI || "  "  ; %NWL%content . thumbnailURIs   = contentInitDict . thumbnailURIs || null ; %NWL%content . releaseDate   = contentInitDict . releaseDate ?%NWL%new Date ( contentInitDict . releaseDate )  : null ; %NWL%content . modifiedDate   = contentInitDict . modifiedDate ?%NWL%8
axis . cross ( vec1 )  ;%NWL%}%NWL%axis . normalize (  )  ; %NWL%quaternion . rotationAxis ( axis , Math . PI )  ;%NWL%}%NWL%} else {%NWL%var s = Math . sqrt (  ( 1 + a )  * 2 )  , invs = 1 / s ; %NWL%v1 . cross ( v2 )  ; %NWL%quaternion . x = v1 . x * invs ; %NWL%quaternion . y = v1 . y * invs ; %NWL%quaternion . z = v1 . z * invs ; %NWL%8
}  )  ; %NWL%$rootScope . $on (  ' playerService . play '  , function (  )  {%NWL%audio . play (  )  ;%NWL%}  )  ; %NWL%$rootScope . $on (  ' playerService . pause '  , function (  )  {%NWL%audio . pause (  )  ;%NWL%}  )  ; %NWL%$rootScope . $on (  ' playerService . playNew '  , function ( e , data )  {%NWL%audio . pause (  )  ; %NWL%audio . src = data . src ; %NWL%audio . type = data . type ; %NWL%9
onSelect : function ( itemToSelect )  {%NWL%$ ( itemToSelect )  . addClass ( that . options . styles . selected )  ;%NWL%}  ,%NWL%onUnselect : function ( selectedItem )  {%NWL%$ ( selectedItem )  . removeClass ( that . options . styles . selected )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%var prepareTemplateElements = function ( that )  {%NWL%that . rowTemplate = that . locate (  " rowTemplate "  )  . remove (  )  ; %NWL%that . errorInfoRowTemplate = that . locate (  " errorInfoRowTemplate "  )  . remove (  )  ; %NWL%9
var result = isResult ? errOrResult : errOrResult . result ; %NWL%switch ( result )  {%NWL%case Cr . NS_ERROR_FILE_NOT_FOUND : %NWL%return new Error (  " path does not exist :  "  + filename )  ;%NWL%}%NWL%return isResult ? new Error (  " XPCOM error code :  "  + errOrResult )  : errOrResult ;%NWL%}%NWL%exports . exists = function exists ( filename )  {%NWL%return MozFile ( filename )  . exists (  )  ;%NWL%}  ; %NWL%exports . isFile = function isFile ( filename )  {%NWL%7
} while ( src < size )  ; %NWL%return dst ;%NWL%} else {%NWL%return data ;%NWL%}%NWL%}  ; %NWL%TGALoader . create = function ( params )  {%NWL%var loader = new TGALoader (  )  ; %NWL%loader . gd = params . gd ; %NWL%loader . onload = params . onload ; %NWL%loader . onerror = params . onerror ; %NWL%8
URI . prototype . toString = function (  )  {%NWL%return exports . format ( this )  ;%NWL%}  ; %NWL%URI . parse = function ( uri )  {%NWL%require (  " narwhal / deprecated "  )  . deprecated (  " URI . parse is deprecated , use require (  ' uri '  )  . parse "  )  ; %NWL%return new URI ( uri )  ;%NWL%}  ; %NWL%exports . unescape = URI . unescape = function ( uri , plus )  {%NWL%return decodeURI ( uri )  . replace (  / \ +  / g ,  "  "  )  ;%NWL%}  ; %NWL%exports . unescapeComponent = URI . unescapeComponent = function ( uri , plus )  {%NWL%7
setText : function ( t )  {%NWL%if ( this . rendered )  {%NWL%this . el . update ( t )  ;%NWL%} else {%NWL%this . text = t ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%Ext . reg (  ' tbtext '  , T . TextItem )  ; %NWL%T . Button = Ext . extend ( Ext . Button ,  {  }  )  ; %NWL%T . SplitButton = Ext . extend ( Ext . SplitButton ,  {  }  )  ; %NWL%9
dojo . connect ( anim ,  " onPlay "  , anim , args . onPlay )  ;%NWL%}%NWL%if ( args . onEnd )  {%NWL%dojo . connect ( anim ,  " onEnd "  , anim , args . onEnd )  ;%NWL%}%NWL%return anim ;  /  / dojo . Animation%NWL%}  ,%NWL%explode : function ( args )  {%NWL%var node = args . node = dojo . byId ( args . node )  ; %NWL%args . rows = args . rows || 3 ; %NWL%args . columns = args . columns || 3 ; %NWL%9
function parseClass ( params , constructor )  {%NWL%var key ,%NWL%value ,%NWL%saved =  {  }  ; %NWL%delete params . $locked ; %NWL%if ( hasOwn ( params ,  ' $constants '  )  )  {%NWL%saved . $constants = params . $constants ; %NWL%delete params . $constants ;%NWL%}%NWL%if ( hasOwn ( params ,  ' $finals '  )  )  {%NWL%saved . $finals = params . $finals ; %NWL%6
this . transposeSelections = function ( dir )  {%NWL%var session = this . session ; %NWL%var sel = session . multiSelect ; %NWL%var all = sel . ranges ; %NWL%for ( var i = all . length ; i -  -  ;  )  {%NWL%var range = all [ i ]  ; %NWL%if ( range . isEmpty (  )  )  {%NWL%var tmp = session . getWordRange ( range . start . row , range . start . column )  ; %NWL%range . start . row = tmp . start . row ; %NWL%range . start . column = tmp . start . column ; %NWL%range . end . row = tmp . end . row ; %NWL%8
headtrackr . camshift . TrackObj = function (  )  {%NWL%this . height = 0 ; %NWL%this . width = 0 ; %NWL%this . angle = 0 ; %NWL%this . x = 0 ; %NWL%this . y = 0 ; %NWL%this . clone = function (  )  {%NWL%var c = new headtrackr . camshift . TrackObj (  )  ; %NWL%c . height = this . height ; %NWL%c . width = this . width ; %NWL%c . angle = this . angle ; %NWL%8
ReadWriteStream = require (  '  .  .  / common / read - write - stream '  )  ; %NWL%var Sms = module . exports = function Sms ( options )  {%NWL%if ( !options || !options . from || !options . to%NWL%|| ( !options . auth && !options . client )  )  {%NWL%throw new Error (  ' options . auth ( or options . client )  , options . from , and options . to are required '  )  ;%NWL%}%NWL%ReadWriteStream . call ( this )  ; %NWL%this . auth  = options . auth ; %NWL%this . to   = options . to ; %NWL%this . from  = options . from ; %NWL%this . interval = options . interval ; %NWL%7
' style '  :  ' overflow : hidden ; position : relative ; width :  '  +%NWL%goog . graphics . VmlGraphics . toCssSize ( pixelWidth )  +  '  ; height :  '  +%NWL%goog . graphics . VmlGraphics . toCssSize ( pixelHeight )%NWL%}  )  ; %NWL%this . setElementInternal ( divElement )  ; %NWL%var group = this . createVmlElement (  ' group '  )  ; %NWL%var style = group . style ; %NWL%style . position =  ' absolute '  ; %NWL%style . left = style . top = 0 ; %NWL%style . width = this . width ; %NWL%style . height = this . height ; %NWL%9
exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%exports . BADFLAGS =  ' EBADFLAGS '  ; %NWL%exports . NONAME =  ' ENONAME '  ; %NWL%exports . BADHINTS =  ' EBADHINTS '  ; %NWL%exports . NOTINITIALIZED =  ' ENOTINITIALIZED '  ; %NWL%exports . LOADIPHLPAPI =  ' ELOADIPHLPAPI '  ; %NWL%exports . ADDRGETNETWORKPARAMS =  ' EADDRGETNETWORKPARAMS '  ; %NWL%exports . CANCELLED =  ' ECANCELLED '  ; %NWL%0
Grapnel = require (  '  .  / grapnel '  )  . Grapnel ; %NWL%Warden =  ( function ( _super )  {%NWL%__extends ( Warden , _super )  ; %NWL%function Warden ( opts )  {%NWL%var action , route ; %NWL%if ( opts =  = null )  {%NWL%opts =  {  }  ;%NWL%}%NWL%this . match = __bind ( this . match , this )  ; %NWL%this . findController = __bind ( this . findController , this )  ; %NWL%this . navigate = __bind ( this . navigate , this )  ; %NWL%8
actor . scale_y = actor . org_scale_y ; %NWL%actor . depth = actor . org_depth ; %NWL%actor . opacity = actor . org_opacity ; %NWL%actor . current_frame = actor . org_current_frame ; %NWL%actor . vr = actor . org_vr ; %NWL%actor . vx = actor . org_vx ; %NWL%actor . vy = actor . org_vy ; %NWL%actor . vd = actor . org_vd ; %NWL%actor . vo = actor . org_vo ; %NWL%actor . vsx = actor . org_vsx ; %NWL%actor . vsy = actor . org_vsy ; %NWL%0
if ( config [ key ]  . fileNames =  =  = undefined && config [ key ]  . sizes ! =  = undefined )  {%NWL%for ( sizeKey in config [ key ]  . sizes )  {%NWL%if ( config [ key ]  . sizes . hasOwnProperty ( sizeKey )  )  {%NWL%fileNames [ config [ key ]  . sizes [ sizeKey ]  ]  = config [ key ]  . sizes [ sizeKey ]  ;%NWL%}%NWL%}%NWL%config [ key ]  . fileNames = fileNames ;%NWL%}%NWL%if ( config [ key ]  . sizes =  =  = undefined )  { config [ key ]  . sizes = this . config . default . sizes ;  }%NWL%if ( config [ key ]  . fileNames =  =  = undefined )  { config [ key ]  . fileNames = this . config . default . fileNames ;  }%NWL%if ( config [ key ]  . imagePath =  =  = undefined )  { config [ key ]  . imagePath = this . config . default . imagePath ;  }%NWL%8
this . _attributes =  [  ]  ; 			 /  / e . g .  [  " Title "  ,  " Year "  ,  " Producer "  ]%NWL%this . _attributeIndexes =  {  }  ; 	 /  / e . g .  { Title : 0 , Year : 1 , Producer : 2 }%NWL%this . _dataArray =  [  ]  ; 			 /  / e . g .  [  [  < Item0 >  ]  ,  [  < Item1 >  ]  ,  [  < Item2 >  ]  ]%NWL%this . _arrayOfAllItems =  [  ]  ; 		 /  / e . g .  [  { _csvId : 0 , _csvStore : store }  ,  .  .  .  ]%NWL%this . _loadFinished = false ; %NWL%if ( keywordParameters . url )  {%NWL%this . url = keywordParameters . url ;%NWL%}%NWL%this . _csvData = keywordParameters . data ; %NWL%if ( keywordParameters . label )  {%NWL%this . label = keywordParameters . label ; %NWL%6
$ ( this )  . addClass (  ' calendar - selected '  )  ; %NWL%setDate (  )  ;%NWL%}  )  ;%NWL%}%NWL%function setDate (  )  {%NWL%var menu = $ ( target )  . find (  '  . calendar - menu '  )  ; %NWL%var year = menu . find (  '  . calendar - menu - year '  )  . val (  )  ; %NWL%var month = menu . find (  '  . calendar - selected '  )  . attr (  ' abbr '  )  ; %NWL%if ( !isNaN ( year )  )  {%NWL%opts . year = parseInt ( year )  ; %NWL%opts . month = parseInt ( month )  ; %NWL%9
if ( this . innerMode && this . innerState )  {%NWL%res . innerState = CodeMirror . copyState ( this . innerMode , this . innerState )  ;%NWL%}%NWL%res . restOfLine = this . restOfLine ; %NWL%res . isIncludeFiltered = this . isIncludeFiltered ; %NWL%res . isEach = this . isEach ; %NWL%res . lastTag = this . lastTag ; %NWL%res . scriptType = this . scriptType ; %NWL%res . isAttrs = this . isAttrs ; %NWL%res . attrsNest = this . attrsNest . slice (  )  ; %NWL%res . inAttributeName = this . inAttributeName ; %NWL%3
}  ; %NWL%Furatto . Suraido =  ( function (  )  {%NWL%function Suraido ( el , options )  {%NWL%var weakSelf ,%NWL%_this = this ; %NWL%this . el = el ; %NWL%this . prev = __bind ( this . prev , this )  ; %NWL%this . next = __bind ( this . next , this )  ; %NWL%this . stop = __bind ( this . stop , this )  ; %NWL%this . play = __bind ( this . play , this )  ; %NWL%this . to = __bind ( this . to , this )  ; %NWL%6
var ViewCollection = Displayable . extend (  " ViewCollection "  ,  {%NWL%template :  '  < ul >  <  / ul >  '  ,%NWL%_views : null ,%NWL%_models : null ,%NWL%_ViewClass : null ,%NWL%_filter : null ,%NWL%_delegateOnAdd : null ,%NWL%constructor : function ( ViewClass , collectionTemplate )  {%NWL%this . _onAdd = this . _onAdd . bind ( this )  ; %NWL%this . _onRemove = this . _onRemove . bind ( this )  ; %NWL%this . _onSort = this . _onSort . bind ( this )  ; %NWL%8
this . errors = this . getElement (  " errors "  )  ; %NWL%if ( this . errors )  {%NWL%this . model . log (  " Widget : attached errors :  "  + this . errors . id )  ;%NWL%}%NWL%}  ,%NWL%showErrors : function showErrors ( errors )  {%NWL%if ( ! this . errors )  { return ;  }%NWL%this . errors . value = errors ;%NWL%}  ,%NWL%setupAbout : function setupAbout (  )  {%NWL%this . about = this . getElement (  " about "  )  ; %NWL%0
this . uid = opts . uid || 0 ; %NWL%this . gid = opts . gid || 0 ; %NWL%this . mode = opts . mode || 0 ; %NWL%this . size = opts . size || 0 ; %NWL%this . mtime = toDate ( opts . mtime )  ; %NWL%this . atime = toDate ( opts . atime )  ; %NWL%this . ctime = toDate ( opts . ctime )  ; %NWL%this . type = opts . type ; %NWL%this . target = opts . target ; %NWL%this . link = opts . link ; %NWL%this . blob = opts . blob ; %NWL%7
Container . ShindigBase 	 = xml . getElementsByTagName (  " ShindigBase "  )  [ 0 ]  . textContent ; %NWL%Container . relayUrl 		 = xml . getElementsByTagName (  " ShindigBase "  )  [ 1 ]  . textContent ; %NWL%var gadgets 			 = xml . getElementsByTagName (  " Gadget "  )  ; %NWL%for ( var i = 0 ; i < gadgets . length ; i +  +  )  {%NWL%var options =  {  }  ; %NWL%if ( gadgets [ i ]  . getElementsByTagName (  " options "  )  [ 0 ]  )  {%NWL%var optionsTmp = gadgets [ i ]  . getElementsByTagName (  " options "  )  [ 0 ]  ; %NWL%if ( optionsTmp . getElementsByTagName (  " minHeight "  )  [ 0 ]  )%NWL%options . minHeight = optionsTmp . getElementsByTagName (  " minHeight "  )  [ 0 ]  . textContent ; %NWL%if ( optionsTmp . getElementsByTagName (  " minWidth "  )  [ 0 ]  )%NWL%options . minWidth = optionsTmp . getElementsByTagName (  " minWidth "  )  [ 0 ]  . textContent ; %NWL%8
if ( step < 0 )  {%NWL%step = backgrounds . length - 1 ;%NWL%}%NWL%if ( step >  = backgrounds . length || !backgrounds [ step - 1 ]  )  {%NWL%step = 0 ;%NWL%}%NWL%var settings = backgrounds [ step +  +  ]  ; %NWL%settings . walk = options . walk ; %NWL%settings . loading = options . loading ; %NWL%if ( typeof settings . fade =  =  " undefined "  )  {%NWL%settings . fade = options . fade ; %NWL%7
var viewport = page . getViewport ( scale )  ; %NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%if ( viewport . height > 170 || viewport . width > 130 )  {%NWL%scale = 0 . 1 ;%NWL%}%NWL%else if ( viewport . height < 129 || viewport . width < 86 )  {%NWL%scale = 0 . 3 ;%NWL%}%NWL%viewport = page . getViewport ( scale )  ; %NWL%canvas . height = viewport . height ; %NWL%canvas . width = viewport . width ; %NWL%9
DataSourceCacheExtension . prototype =  {%NWL%initializer : function ( config )  {%NWL%this . doBefore (  " _defRequestFn "  , this . _beforeDefRequestFn )  ; %NWL%this . doBefore (  " _defResponseFn "  , this . _beforeDefResponseFn )  ;%NWL%}  ,%NWL%_beforeDefRequestFn : function ( e )  {%NWL%var entry =  ( this . retrieve ( e . request )  ) || null ,%NWL%payload = e . details [ 0 ]  ; %NWL%if ( entry && entry . response )  {%NWL%payload . cached  = entry . cached ; %NWL%payload . response = entry . response ; %NWL%9
if ( r . scheme ! =  = null && r . scheme . toLowerCase (  )  =  =  = base . scheme . toLowerCase (  )  )  {%NWL%r . scheme = null ;%NWL%}%NWL%if ( r . scheme ! =  = null )  {%NWL%t . scheme = r . scheme ; %NWL%t . authority = r . authority ; %NWL%t . path = removeDotSegments ( r . path )  ; %NWL%t . query = r . query ;%NWL%} else {%NWL%if ( r . authority ! =  = null )  {%NWL%t . authority = r . authority ; %NWL%4
psData . mr = $ (  ' #pf - mr '  )  . val (  )  ; %NWL%psData . r = $ (  ' #pf - r '  )  . val (  )  ; %NWL%psData . or = $ (  ' #pf - or '  )  . val (  )  ; %NWL%now . setPsFront ( psData )  ;%NWL%}%NWL%function setPsRear (  )  {%NWL%var psData = new Object (  )  ; %NWL%psData . ol = $ (  ' #pr - ol '  )  . val (  )  ; %NWL%psData . l = $ (  ' #pr - l '  )  . val (  )  ; %NWL%psData . ml = $ (  ' #pr - ml '  )  . val (  )  ; %NWL%psData . mr = $ (  ' #pr - mr '  )  . val (  )  ; %NWL%7
return distance ;%NWL%}  ; %NWL%JSM . MidCoord = function ( a , b )%NWL%{%NWL%return new JSM . Coord (  ( a . x + b . x )  / 2 . 0 ,  ( a . y + b . y )  / 2 . 0 ,  ( a . z + b . z )  / 2 . 0 )  ;%NWL%}  ; %NWL%JSM . VectorMultiply = function ( vector , scalar )%NWL%{%NWL%var result = new JSM . Vector ( 0 . 0 , 0 . 0 , 0 . 0 )  ; %NWL%result . x = vector . x * scalar ; %NWL%result . y = vector . y * scalar ; %NWL%9
material . attributes = this . attributes ; %NWL%material . defines = this . defines ; %NWL%material . shading = this . shading ; %NWL%material . wireframe = this . wireframe ; %NWL%material . wireframeLinewidth = this . wireframeLinewidth ; %NWL%material . fog = this . fog ; %NWL%material . lights = this . lights ; %NWL%material . vertexColors = this . vertexColors ; %NWL%material . skinning = this . skinning ; %NWL%material . morphTargets = this . morphTargets ; %NWL%material . morphNormals = this . morphNormals ; %NWL%0
scaleTool :  {%NWL%mouseMove : function ( ctx , mpos , mdelta , keyState )  {%NWL%var diff =  [ mpos [ 0 ]  - mousePos [ 0 ]  , mpos [ 1 ]  - mousePos [ 1 ]  ]  ; %NWL%if ( mouseMoveMode =  =  =  ' x '  )  {%NWL%selectedObject . scale [ 0 ]  = selectedObject . origins . scale [ 0 ]  + diff [ 0 ]  * scaleFactor ; %NWL%selectedObject . scale [ 1 ]  = selectedObject . origins . scale [ 1 ]  ; %NWL%selectedObject . scale [ 2 ]  = selectedObject . origins . scale [ 2 ]  ;%NWL%}%NWL%else if ( mouseMoveMode =  =  =  ' y '  )  {%NWL%selectedObject . scale [ 1 ]  = selectedObject . origins . scale [ 1 ]  - diff [ 1 ]  * scaleFactor ; %NWL%selectedObject . scale [ 0 ]  = selectedObject . origins . scale [ 0 ]  ; %NWL%5
}%NWL%LevelUP . prototype . readStream =%NWL%LevelUP . prototype . createReadStream = function ( options )  {%NWL%var self = this%NWL%options = extend (  { keys : true , values : true }  , this . options , options )%NWL%options . keyEncoding  = options . keyEncoding%NWL%options . valueEncoding = options . valueEncoding%NWL%if ( isDefined ( options . start )  )%NWL%options . start = this . _codec . encodeKey ( options . start ,  [ options ]  )%NWL%if ( isDefined ( options . end )  )%NWL%options . end = this . _codec . encodeKey ( options . end ,  [ options ]  )%NWL%8
var curTop = 0 ; %NWL%for ( var element = this ; element ; element = element . scrollParent )  {%NWL%curLeft +  = element . scrollLeft ; %NWL%curTop +  = element . scrollTop ;%NWL%}%NWL%return { left : curLeft , top : curTop }  ;%NWL%}%NWL%function AnchorBox ( x , y , width , height )%NWL%{%NWL%this . x = x || 0 ; %NWL%this . y = y || 0 ; %NWL%9
if ( xhr . status =  = 200 )  {%NWL%var response = xhr . responseText ; %NWL%tokens . created_time = new Date (  )  . valueOf (  )  ; %NWL%try {%NWL%var parsedResponse = JSON . parse ( response )  ; %NWL%restclient . log ( parsedResponse )  ; %NWL%restclient . log ( typeof parsedResponse . expires_in )  ; %NWL%if ( typeof parsedResponse . access_token =  =  =  ' string '  )%NWL%tokens . access_token = parsedResponse . access_token ; %NWL%if ( typeof parsedResponse . refresh_token =  =  =  ' string '  )%NWL%tokens . refresh_token = parsedResponse . refresh_token ; %NWL%8
"  .  / models / mic "  ,%NWL%"  .  / models / spectrum "  ,%NWL%"  .  / models / load_sample "  ,%NWL%"  .  / models / sample "  ,%NWL%"  .  / models / jsnode "  ,%NWL%"  .  / models / buffer_queue "  ]  ,%NWL%function ( chime , dc , noise , probe , mic , spectrum , load_sample , sample , jsnode , buffer_queue )  {%NWL%return function maker ( S , sh )  {%NWL%var models = sh . models || ( sh . models =  {  }  )  ; %NWL%models . chime = chime ( S , sh )  ; %NWL%models . dc = dc ( S , sh )  ; %NWL%9
_p . visit = _p . _visitForWebGL ; %NWL%_p . draw = _p . _drawForWebGL ; %NWL%_p . setClearColor = _p . _setClearColorForWebGL ;%NWL%} else {%NWL%_p . ctor = _p . _ctorForCanvas ; %NWL%_p . cleanup = _p . _cleanupForCanvas ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForCanvas ; %NWL%_p . begin = _p . _beginForCanvas ; %NWL%_p . _beginWithClear = _p . _beginWithClearForCanvas ; %NWL%_p . end = _p . _endForCanvas ; %NWL%_p . clearRect = _p . _clearRectForCanvas ; %NWL%4
document . getElementById (  ' src '  )  . style . width =  ' 180px '  ; %NWL%e = ed . selection . getNode (  )  ; %NWL%this . fillFileList (  ' image_list '  ,  ' tinyMCEImageList '  )  ; %NWL%if ( e . nodeName =  =  ' IMG '  )  {%NWL%f . src . value = ed . dom . getAttrib ( e ,  ' src '  )  ; %NWL%f . alt . value = ed . dom . getAttrib ( e ,  ' alt '  )  ; %NWL%f . border . value = this . getAttrib ( e ,  ' border '  )  ; %NWL%f . vspace . value = this . getAttrib ( e ,  ' vspace '  )  ; %NWL%f . hspace . value = this . getAttrib ( e ,  ' hspace '  )  ; %NWL%f . width . value = ed . dom . getAttrib ( e ,  ' width '  )  ; %NWL%f . height . value = ed . dom . getAttrib ( e ,  ' height '  )  ; %NWL%4
exports . ArrayNode = require (  '  .  / ArrayNode '  )  ; %NWL%exports . AssignmentNode = require (  '  .  / AssignmentNode '  )  ; %NWL%exports . BlockNode = require (  '  .  / BlockNode '  )  ; %NWL%exports . ConditionalNode = require (  '  .  / ConditionalNode '  )  ; %NWL%exports . ConstantNode = require (  '  .  / ConstantNode '  )  ; %NWL%exports . IndexNode = require (  '  .  / IndexNode '  )  ; %NWL%exports . FunctionAssignmentNode = require (  '  .  / FunctionAssignmentNode '  )  ; %NWL%exports . FunctionNode = require (  '  .  / FunctionNode '  )  ; %NWL%exports . Node = require (  '  .  / Node '  )  ; %NWL%exports . OperatorNode = require (  '  .  / OperatorNode '  )  ; %NWL%exports . RangeNode = require (  '  .  / RangeNode '  )  ; %NWL%0
if ( cut ) txt = selectedText ; %NWL%else doc . replaceRange ( txt , start , end )  ;%NWL%}%NWL%this . cut = function (  )  {%NWL%superClipboard ( true )  ;%NWL%}%NWL%this . paste = function (  )  {%NWL%superClipboard ( false )  ;%NWL%}%NWL%exports . cut = this . cut ; %NWL%exports . paste = this . paste ; %NWL%9
json . width = this . width ; %NWL%json . height = this . height ; %NWL%json . invWidth = this . invWidth ; %NWL%json . invHeight = this . invHeight ; %NWL%json . generateMipmap = this . generateMipmap ; %NWL%json . flipY = this . flipY ; %NWL%json . premultiplyAlpha = this . premultiplyAlpha ; %NWL%json . anisotropy = this . anisotropy ; %NWL%json . filter = this . filter ; %NWL%json . format = this . format ; %NWL%json . wrap = this . wrap ; %NWL%0
record = new jute . protocol . SetDataRequest (  )  ; %NWL%record . path = op . path ; %NWL%if ( Buffer . isBuffer ( op . data )  )  {%NWL%record . data = new Buffer ( op . data . length )  ; %NWL%op . data . copy ( record . data )  ;%NWL%}%NWL%record . version = op . version ; %NWL%break ; %NWL%case jute . OP_CODES . CHECK : %NWL%record = new jute . protocol . CheckVersionRequest (  )  ; %NWL%record . path = op . path ; %NWL%6
html +  =  '  '  ; %NWL%if ( err )  {%NWL%return callback ( err )  ;%NWL%}%NWL%config . scripts = config . scripts || [  ]  ; %NWL%if ( typeof config . scripts =  =  =  ' string '  )  {%NWL%config . scripts =  [ config . scripts ]  ;%NWL%}%NWL%config . src = config . src || [  ]  ; %NWL%if ( typeof config . src =  =  =  ' string '  )  {%NWL%config . src =  [ config . src ]  ; %NWL%6
settingsApp . controller (  ' settingsCtrl '  , function ( $scope , $http , $modal , $timeout , $window )  {%NWL%$scope . isoLangs = isoLangs ; %NWL%if ( localStorage . getItem (  ' oauth_token '  )  )  {%NWL%$scope . oauthToken = localStorage . getItem (  ' oauth_token '  )  ; %NWL%$scope . oauthKey = localStorage . getItem (  ' oauth_key '  )  ;%NWL%}%NWL%$http . get (  '  / settings / load '  )  . success ( function ( data )  {%NWL%$scope . availableLanguages = data . availableLanguages ; %NWL%$scope . availableQuality = data . availableQuality ; %NWL%$scope . availableScreensavers = data . availableScreensavers ; %NWL%$scope . tvFormatTypes = data . tvFormatTypes ; %NWL%7
gl . compileShader ( fs2d )  ; %NWL%var program2d = this . program2d = gl . createProgram (  )  ; %NWL%gl . attachShader ( program2d , vs )  ; %NWL%gl . attachShader ( program2d , fs2d )  ; %NWL%gl . linkProgram ( program2d )  ; %NWL%gl . deleteShader ( vs )  ; %NWL%gl . deleteShader ( fs2d )  ; %NWL%gl . useProgram ( program2d )  ; %NWL%program2d . u_sampler0 = gl . getUniformLocation ( program2d ,  " u_sampler0 "  )  ; %NWL%program2d . a_position = gl . getAttribLocation ( program2d ,  " a_position "  )  ; %NWL%program2d . a_uv = gl . getAttribLocation ( program2d ,  " a_uv "  )  ; %NWL%9
_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%_server_options . sslKey = object . rs_options . sslKey ; %NWL%_server_options . sslPass = object . rs_options . sslPass ;%NWL%} else if ( object . server_options . ssl )  {%NWL%_server_options . ssl = object . server_options . ssl ; %NWL%_server_options . sslValidate = object . server_options . sslValidate ; %NWL%_server_options . sslCA = object . server_options . sslCA ; %NWL%_server_options . sslCert = object . server_options . sslCert ; %NWL%7
$scope , $state ,%NWL%HeaderNavigationItems ,%NWL%UserService , AuthService%NWL%)  {%NWL%$scope . user = UserService . user ; %NWL%$scope . auth = AuthService ; %NWL%$scope . navigationItems = HeaderNavigationItems ; %NWL%$scope . isNotActive = function isNotActive ( item )  {%NWL%return !! ( item . state =  =  =  ' examples ' && $state . current . name =  =  =  ' examples . about '  )  ;%NWL%}  ; %NWL%$scope . isActive = function isActive ( item )  {%NWL%7
}  . bind ( this )  )  ;%NWL%}  ; %NWL%Compiler . prototype . createChildCompiler = function ( compilation , compilerName , outputOptions )  {%NWL%var childCompiler = new Compiler (  )  ; %NWL%for ( var name in this . _plugins )  {%NWL%if (  [  " make "  ,  " compile "  ,  " emit "  ,  " after - emit "  ,  " invalid "  ,  " done "  ,  " this - compilation "  ]  . indexOf ( name )  < 0 )%NWL%childCompiler . _plugins [ name ]  = this . _plugins [ name ]  . slice (  )  ;%NWL%}%NWL%childCompiler . name = compilerName ; %NWL%childCompiler . outputPath = this . outputPath ; %NWL%childCompiler . inputFileSystem = this . inputFileSystem ; %NWL%9
assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%if ( actual ! =  = expected )  {%NWL%fail ( actual , expected , message ,  '  =  =  =  '  , assert . strictEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . notStrictEqual = function notStrictEqual ( actual , expected , message )  {%NWL%0
} else {%NWL%this . syslogView = new syslogView . View (  {%NWL%el : $body%NWL%}  )  ; %NWL%this . addSubViews ( this . syslogView )  ;%NWL%}%NWL%} else if ( view =  =  =  ' #virtual '  )  {%NWL%if ( this . virtualView )  {%NWL%this . virtualView . render (  )  ;%NWL%} else {%NWL%this . virtualView = new virtualView . View (  {%NWL%1
var gDoingMetric  = false ; %NWL%var gPrintSettingsInterface = Components . interfaces . nsIPrintSettings ; %NWL%var gDoDebug = false ; %NWL%function initDialog (  )%NWL%{%NWL%gDialog = new Object ; %NWL%gDialog . orientation  = document . getElementById (  " orientation "  )  ; %NWL%gDialog . portrait   = document . getElementById (  " portrait "  )  ; %NWL%gDialog . landscape   = document . getElementById (  " landscape "  )  ; %NWL%gDialog . printBG   = document . getElementById (  " printBG "  )  ; %NWL%gDialog . shrinkToFit  = document . getElementById (  " shrinkToFit "  )  ; %NWL%6
var el = !YTPlayer . isBackground ? data . containment : jQuery ( window )  ; %NWL%win . width = el . width (  )  ; %NWL%win . height = el . height (  )  ; %NWL%var margin = 24 ; %NWL%var vid =  {  }  ; %NWL%vid . width = win . width +  (  ( win . width * margin )  / 100 )  ; %NWL%vid . height = data . ratio =  =  " 16 / 9 " ? Math . ceil (  ( 9 * win . width )  / 16 )  : Math . ceil (  ( 3 * win . width )  / 4 )  ; %NWL%vid . marginTop =  -  (  ( vid . height - win . height )  / 2 )  ; %NWL%vid . marginLeft =  -  (  ( win . width *  ( margin / 2 )  )  / 100 )  ; %NWL%if ( vid . height < win . height )  {%NWL%vid . height = win . height +  (  ( win . height * margin )  / 100 )  ; %NWL%5
}  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%return ViewOnSiteTreeModel ;%NWL%}  (  )  )  ; %NWL%var ViewOnSiteRenderer =  ( function (  )  {%NWL%function ViewOnSiteRenderer ( options )  {%NWL%SitesRenderer . apply ( this , Array . prototype . slice . call ( arguments )  )  ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . _commandService = options . commandRegistry ; %NWL%this . file = options . file ; %NWL%8
}  ,%NWL%setCssText : function ( val )  {%NWL%var sheet =  { cssRules :  [  ]  }  ; %NWL%var parser = new CSSParser ( val )  ; %NWL%var token = parser . getToken ( true , true )  ; %NWL%if ( token . isAtRule (  " @namespace "  )  )  {%NWL%if ( parser . parseNamespaceRule ( token , sheet )  )  {%NWL%var newRule = sheet . cssRules [ 0 ]  ; %NWL%this . url = newRule . url ; %NWL%this . prefix = newRule . prefix ; %NWL%this . parsedCssText = newRule . parsedCssText ; %NWL%8
}%NWL%}%NWL%this . positionItemY ( itemContext , info )  ;%NWL%}  ,%NWL%onBeforeInvalidateChild : function ( itemContext , options )  {%NWL%+  + itemContext . context . progressCount ; %NWL%if ( options . widthModel )  {%NWL%itemContext . widthModel = options . widthModel ;%NWL%}%NWL%if ( options . heightModel )  {%NWL%itemContext . heightModel = options . heightModel ; %NWL%7
}%NWL%if ( query . tags )  {%NWL%if ( query . tags instanceof Array )  {%NWL%content . tags = query . tags . join (  "  ,  "  )  ;%NWL%} else {%NWL%content . tags = query . tags ;%NWL%}%NWL%primaryKey . push (  " tags "  + content . tags )  ; %NWL%if ( query [  " tag_mode "  ] && ( query . tag_mode . toLowerCase (  )  =  =  =  " any " ||%NWL%query . tag_mode . toLowerCase (  )  =  =  =  " all "  )  )  {%NWL%content . tag_mode = query . tag_mode ; %NWL%5
function RegExpLexer ( dict , input , tokens )  {%NWL%var opts = processGrammar ( dict , tokens )  ; %NWL%var source = generateModuleBody ( opts )  ; %NWL%var lexer = eval ( source )  ; %NWL%lexer . yy =  {  }  ; %NWL%if ( input )  {%NWL%lexer . setInput ( input )  ;%NWL%}%NWL%lexer . generate = function (  )  { return generateFromOpts ( opts )  ;  }  ; %NWL%lexer . generateModule = function (  )  { return generateModule ( opts )  ;  }  ; %NWL%lexer . generateCommonJSModule = function (  )  { return generateCommonJSModule ( opts )  ;  }  ; %NWL%9
assert . equal ( typeof conf . port ,  ' number '  )%NWL%if ( conf . whitelist )  {%NWL%assert ( Array . isArray ( conf . whitelist )  )%NWL%conf . whitelist = conf . whitelist . filter ( function ( cidr )  {%NWL%assert . equal ( typeof cidr ,  ' string '  )%NWL%return ( cidr && cidr . charAt ( 0 ) ! =  =  ' # '  )%NWL%}  )  . concat ( locals )%NWL%}%NWL%conf . writers = conf . writers || [  ]%NWL%assert ( Array . isArray ( conf . writers )  )%NWL%conf . free = conf . free || [  ]%NWL%8
startPivot :  { x : 0 , y : 0 , z : 0 }  ,%NWL%endPivot :  { x : 0 , y : 0 , z : 0 }  ,%NWL%currentPivot :  { x : 0 , y : 0 , z : 0 }  ,%NWL%flightStartTime : null ,%NWL%flightDuration : null ,%NWL%__construct : function ( params ) 	 {%NWL%this . events = new BIMSURFER . Events ( this )  ; %NWL%if ( BIMSURFER . Util . isset ( params )  )  {%NWL%this . eye = params . eye || this . eye ; %NWL%this . look = params . look || this . look ; %NWL%this . zoom = params . zoom || this . zoom ; %NWL%8
startup : function (  )  {%NWL%if ( this . getChildren )  {%NWL%arr . forEach ( this . getChildren (  )  , function ( child )  { child . startup (  )  ;  }  )  ;%NWL%}%NWL%this . startAngle = Number ( this . startAngle )  ; %NWL%this . endAngle = Number ( this . endAngle )  ; %NWL%this . cx = Number ( this . cx )  ; %NWL%if ( !this . cx )  { this . cx = this . width / 2 ;  }%NWL%this . cy = Number ( this . cy )  ; %NWL%if ( !this . cy )  { this . cy = this . height / 2 ;  }%NWL%this . radius = Number ( this . radius )  ; %NWL%4
if ( Y_Lang . isArray ( fillColor )  )%NWL%{%NWL%markerStyles . fill . color = fillColor [ i % fillColor . length ]  ;%NWL%}%NWL%else%NWL%{%NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ;%NWL%}%NWL%if ( Y_Lang . isArray ( borderColor )  )%NWL%{%NWL%markerStyles . border . color = borderColor [ i % borderColor . length ]  ; %NWL%2
this . _position = 0 ; %NWL%this . _contentHeight = rowCount * defaultRowHeight ; %NWL%this . _defaultRowHeight = defaultRowHeight ; %NWL%this . _rowHeightGetter = rowHeightGetter ?%NWL%rowHeightGetter :%NWL%(  )  =  > defaultRowHeight ; %NWL%this . _viewportHeight = viewportHeight ; %NWL%this . scrollRowIntoView = this . scrollRowIntoView . bind ( this )  ; %NWL%this . setViewportHeight = this . setViewportHeight . bind ( this )  ; %NWL%this . scrollBy = this . scrollBy . bind ( this )  ; %NWL%this . scrollTo = this . scrollTo . bind ( this )  ; %NWL%7
function ( error , oauth_access_token , oauth_access_token_secret , tweetRes )  {%NWL%if ( error )  {%NWL%console . log (  ' getOAuthAccessToken error :  '  , error )  ; %NWL%return ;%NWL%}%NWL%req . session . oAuthVars . oauth_access_token = oauth_access_token ; %NWL%req . session . oAuthVars . oauth_access_token_secret = oauth_access_token_secret ; %NWL%req . session . oAuthVars . oauth_verifier = req . param (  ' oauth_verifier '  )  ; %NWL%var obj =  {  }  ; %NWL%obj . user_id = tweetRes . user_id ; %NWL%obj . screen_name = tweetRes . screen_name ; %NWL%9
function SettingImpl ( json )  {%NWL%this . pid = json . pid ; %NWL%this . isRef = getStringOrNull ( json ,  ' classId '  )  ;  /  / $NON - NLS - 0$%NWL%this . classId = this . isRef ? json . classId : this . pid +  '  . type '  ;  /  / $NON - NLS - 0$%NWL%this . name = getStringOrNull ( json ,  ' name '  )  ;  /  / $NON - NLS - 0$%NWL%this . nameKey = getStringOrNull ( json ,  ' nameKey '  )  ;  /  / $NON - NLS - 0$%NWL%this . nls = getStringOrNull ( json ,  ' nls '  )  ;  /  / $NON - NLS - 0$%NWL%this . properties = null ; %NWL%this . category = json . category || null ; %NWL%this . categoryKey = json . categoryKey || null ; %NWL%this . tags = json . tags ; %NWL%1
v . disp [ p ]  . x = 0 ; %NWL%v . disp [ p ]  . y = 0 ; %NWL%v . disp [ p ]  . z = 0 ;%NWL%}  )  ; %NWL%graph . eachNode ( function ( u )  {%NWL%if ( u . id ! = v . id )  {%NWL%$ . each ( property , function ( p )  {%NWL%var vp = v . getPos ( p )  , up = u . getPos ( p )  ; %NWL%dpos . x = vp . x - up . x ; %NWL%dpos . y = vp . y - up . y ; %NWL%dpos . z = vp . z - up . z ; %NWL%8
definedProperty . writable = true ;%NWL%}%NWL%if ( !definedProperty . hasOwnProperty (  ' writable '  )  )  {%NWL%var interceptors = struct . interceptors [ property . propName ] || {  }  ; %NWL%if ( property . set )  {%NWL%var setStack = interceptors . set || [  ]  ; %NWL%definedProperty . set = accessorFactory ( setStack , property . set , property . propName )  ;%NWL%}%NWL%if ( property . get )  {%NWL%var getStack = interceptors . get || [  ]  ; %NWL%definedProperty . get = accessorFactory ( getStack , property . get , property . propName )  ; %NWL%6
Tool . prototype . onmousedown = function ( ev , win , image , layer , currentPos , startPos )  {%NWL%var context = layer . context ; %NWL%this . drawAlt = ev . shiftKey ? true : false ; %NWL%if ( this . tmpEnable )  {%NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%canvas . style . position =  " absolute "  ; %NWL%canvas . style . top =  " 0px "  ; %NWL%canvas . style . left =  " 0px "  ; %NWL%canvas . style . zIndex = 9999 ; %NWL%canvas . width  = context . canvas . width ; %NWL%canvas . height = context . canvas . height ; %NWL%9
return null ;%NWL%}%NWL%log . blockNumber = utils . toDecimal ( log . blockNumber )  ; %NWL%log . transactionIndex = utils . toDecimal ( log . transactionIndex )  ; %NWL%log . logIndex = utils . toDecimal ( log . logIndex )  ; %NWL%return log ;%NWL%}  ; %NWL%var inputPostFormatter = function ( post )  {%NWL%post . payload = utils . toHex ( post . payload )  ; %NWL%post . ttl = utils . fromDecimal ( post . ttl )  ; %NWL%post . priority = utils . fromDecimal ( post . priority )  ; %NWL%9
RGraph . Resizing . originalh = obj . canvas . height ; %NWL%RGraph . Resizing . originalCanvasX = RGraph . getCanvasXY ( obj . canvas )  [ 0 ]  ; %NWL%RGraph . Resizing . originalCanvasY = RGraph . getCanvasXY ( obj . canvas )  [ 1 ]  ;%NWL%}%NWL%if (  coords [ 0 ]  >  ( canvas . width - resizeHandle - resizeHandle )%NWL%&& coords [ 0 ]  < canvas . width - resizeHandle%NWL%&& coords [ 1 ]  >  ( canvas . height - resizeHandle )%NWL%&& coords [ 1 ]  < canvas . height )  {%NWL%RGraph . FireCustomEvent ( canvas . __object__ ,  ' onresizebegin '  )  ; %NWL%canvas . width = canvas . __original_width__ ; %NWL%canvas . height = canvas . __original_height__ ; %NWL%9
netProgress . post ( requestedFile ,  [ request , NetUtils . now (  )  , win , xhr ]  )  ;%NWL%}%NWL%}  ,%NWL%onExamineResponse : function ( request , win )%NWL%{%NWL%var netProgress = this . context . netProgress ; %NWL%if ( !netProgress )%NWL%return ; %NWL%var info = new Object (  )  ; %NWL%info . responseStatus = request . responseStatus ; %NWL%info . responseStatusText = request . responseStatusText ; %NWL%9
( exports . p = function p ( expr )  {%NWL%expr = utils . unwrap ( expr )  ; %NWL%console . log (  ' \033 [ 90minspect : \033 [ 0m %s '%NWL%, expr . toString (  )  . replace (  / ^\ ( |\ ) $ / g ,  '  '  )  )  ; %NWL%return nodes . null ;%NWL%}  )  . raw = true ; %NWL%exports . error = function error ( msg )  {%NWL%utils . assertType ( msg ,  ' string '  ,  ' msg '  )  ; %NWL%throw new Error ( msg . val )  ;%NWL%}  ; %NWL%exports . warn = function warn ( msg )  {%NWL%6
var CODE_USE_ERROR = 500 ; %NWL%var CODE_OLD_CLIENT = 501 ; %NWL%var Command = function ( opts )  {%NWL%opts = opts || {  }  ; %NWL%this . userHandshake = opts . handshake ; %NWL%if ( opts . heartbeat )  {%NWL%this . heartbeatSec = opts . heartbeat ; %NWL%this . heartbeat = opts . heartbeat * 1000 ;%NWL%}%NWL%this . checkClient = opts . checkClient ; %NWL%this . useDict = opts . useDict ; %NWL%9
var centerY = b . y +  (  ( b . height / 2 )  -  ( height / 2 )  )  ; %NWL%var x = !Ext . isEmpty ( state . x , false ) ? state . x :  ( !Ext . isEmpty ( this . x , false ) ? this . x : centerX )  ; %NWL%var y = !Ext . isEmpty ( state . y , false ) ? state . y :  ( !Ext . isEmpty ( this . y , false ) ? this . y : centerY )  ; %NWL%win . width = width ; %NWL%win . height = height ; %NWL%win . x = x ; %NWL%win . y = y ; %NWL%win . addEventListener (  ' move '  , function (  )  {%NWL%if ( win . displayState ! = air . NativeWindowDisplayState . MINIMIZED && win . width > 100 && win . height > 100 )  {%NWL%state . x = win . x ; %NWL%state . y = win . y ; %NWL%9
return this . indexOf ( matchedItem )  >  = 0 ;%NWL%}  ; %NWL%this . ManagedElement =  ( function (  )  {%NWL%function ManagedElement ( elementID )  {%NWL%this . source = document . getElementById ( elementID )  ; %NWL%this . opacity = this . source . getAttribute (  " data - opacity "  ) || 1 ; %NWL%this . x = this . source . getAttribute (  " data - x "  ) || 0 ; %NWL%this . y = this . source . getAttribute (  " data - y "  ) || 0 ; %NWL%this . z = this . source . getAttribute (  " data - z "  ) || 0 ; %NWL%this . scaleX = this . source . getAttribute (  " data - scaleX "  ) || 1 ; %NWL%this . scaleY = this . source . getAttribute (  " data - scaleY "  ) || 1 ; %NWL%5
result . protocol = relative . protocol ; %NWL%if ( !relative . host && !hostlessProtocol [ relative . protocol ]  )  {%NWL%var relPath =  ( relative . pathname || '  '  )  . split (  '  /  '  )  ; %NWL%while ( relPath . length && ! ( relative . host = relPath . shift (  )  )  )  ; %NWL%if ( !relative . host ) relative . host =  '  '  ; %NWL%if ( !relative . hostname ) relative . hostname =  '  '  ; %NWL%if ( relPath [ 0 ] ! =  =  '  '  ) relPath . unshift (  '  '  )  ; %NWL%if ( relPath . length < 2 ) relPath . unshift (  '  '  )  ; %NWL%result . pathname = relPath . join (  '  /  '  )  ;%NWL%} else {%NWL%result . pathname = relative . pathname ; %NWL%0
result . total = accounting . formatMoney ( result . total )  ; %NWL%for ( item in result . items )  {%NWL%if ( result . items [ item ]  )  {%NWL%result . items [ item ]  . price = accounting . formatMoney ( result . items [ item ]  . price )  ; %NWL%result . items [ item ]  . amount = accounting . formatMoney ( result . items [ item ]  . amount )  ;%NWL%}%NWL%}%NWL%for ( item in result )  {%NWL%result [ item ]  . subtotal = accounting . formatMoney ( result [ item ]  . subtotal )  ; %NWL%result [ item ]  . vat_amount = accounting . formatMoney ( result [ item ]  . vat_amount )  ; %NWL%result [ item ]  . shipping_costs = accounting . formatMoney ( result [ item ]  . shipping_costs )  ; %NWL%8
return this ;%NWL%}  ,%NWL%_clear : function (  )  {%NWL%this . context . clearRect ( 0 , 0 , this . canvas . width , this . canvas . height )  ; %NWL%return this ;%NWL%}  ,%NWL%}  ; %NWL%var Circle = function ( params )  {%NWL%this . id = params . id ; %NWL%this . canvas = params . canvas ; %NWL%this . context = params . context ; %NWL%8
return loss ;%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%7
realIccManager = navigator . mozIccManager ; %NWL%realMobileOperator = window . MobileOperator ; %NWL%realSIMSlotManager = window . SIMSlotManager ; %NWL%realMozApps = navigator . mozApps ; %NWL%navigator . mozSettings = MockNavigatorSettings ; %NWL%window . asyncStorage = MockasyncStorage ; %NWL%window . XMLHttpRequest = MockXMLHttpRequest ; %NWL%navigator . mozMobileConnections = MockNavigatorMozMobileConnections ; %NWL%navigator . mozIccManager = MockNavigatorMozIccManager ; %NWL%window . MobileOperator = MockMobileOperator ; %NWL%window . SIMSlotManager = MockSIMSlotManager ; %NWL%5
if ( o . type =  =  =  " onplotreset "  )  {%NWL%delete this . angles ;%NWL%}%NWL%return ;%NWL%}%NWL%if ( !o . shape || o . type ! =  =  " onmouseover "  )  { return ;  }%NWL%var aroundRect =  { type :  " rect "  }  , position =  [  " after "  ,  " before "  ]  ; %NWL%switch ( o . element )  {%NWL%case " marker "  : %NWL%aroundRect . x = o . cx ; %NWL%aroundRect . y = o . cy ; %NWL%9
this . radial . scaleX = this . scaled ; %NWL%this . radial . scaleY = this . scaled ; %NWL%this . radial . rotPointX = 0 ; %NWL%this . radial . rotPointY = 0 ; %NWL%this . radial . x -  = this . radial . box . bounds . width / 2 ; %NWL%this . radial . y -  = this . radial . box . bounds . height / 1 . 5 ; %NWL%this . madeWith . scaleX = this . scaled ; %NWL%this . madeWith . scaleY = this . scaled ; %NWL%this . madeWith . rotPointX = 0 ; %NWL%this . madeWith . rotPointY = 0 ; %NWL%this . madeWith . x -  = this . madeWith . box . bounds . width / 2 ; %NWL%4
get encoding (  )  { return this . _encoding || null ;  }  ,%NWL%set encoding ( value )  { this . _encoding = value ;  }  ,%NWL%}  ; %NWL%ls . LSProgressEvent = function LSProgressEvent (  )  {  }  ; %NWL%ls . LSProgressEvent . prototype = createFrom ( events . Event ,  {%NWL%constructor : ls . LSProgressEvent ,%NWL%get input (  )  { return this . _input ;  }  ,%NWL%get position (  )  { return this . _position ;  }  ,%NWL%get totalSize (  )  { return this . _totalSize ;  }  ,%NWL%}  )  ; %NWL%ls . LSLoadEvent = function LSLoadEvent (  )  {  }  ; %NWL%3
' mode '  ]  ; %NWL%engine . utils . process_parameters ( parameters , par_list )  ; %NWL%this . parameters = parameters ; %NWL%World . superConstructor . apply ( this ,  [ parameters ]  )  ; %NWL%this . width = parameters . width ; %NWL%this . height = parameters . height ; %NWL%this . size =  [ this . width , this . height ]  ; %NWL%this . ai_waypoints = parameters . ai_waypoints ; %NWL%this . checkpoints = parameters . checkpoints ; %NWL%this . start_positions = parameters . start_positions ; %NWL%this . mode = parameters . mode ; %NWL%4
}  )  (  )  ; %NWL%YUI . add (  ' event - base - ie '  , function ( Y , NAME )  {%NWL%function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%9
return this . _cachedData ; %NWL%var resource = this . _resource ; %NWL%var data =  {  }  ; %NWL%if ( !this . _graphOnly )  {%NWL%var zeroTime = this . graphDataSource ? this . graphDataSource . zeroTime : 0 ; %NWL%data . name = WebInspector . displayNameForURL ( resource . url , resource . urlComponents )  ; %NWL%data . domain = WebInspector . displayNameForHost ( resource . urlComponents . host )  ; %NWL%data . scheme = resource . urlComponents . scheme ? resource . urlComponents . scheme . toUpperCase (  )  :  "  "  ; %NWL%data . method = resource . requestMethod ; %NWL%data . type = resource . type ; %NWL%data . statusCode = resource . statusCode ; %NWL%9
exports . TubeMap = TubeMap ; %NWL%exports . Maps = Maps ; %NWL%function Station ( opts )  {%NWL%this . id = opts . id ; %NWL%this . conns = opts . conns || [  ]  ; %NWL%this . name = opts . name || " Unknown "  ; %NWL%this . display_name = opts . display_name || " Unknown "  ; %NWL%this . rail = opts . rail ? parseInt ( opts . rail , 10 )  : null ; %NWL%this . total_lines = opts . total_lines ? parseInt ( opts . total_lines , 10 )  : 1 ; %NWL%this . latitude = parseFloat ( opts . latitude )  ; %NWL%this . longitude = parseFloat ( opts . longitude )  ; %NWL%9
_ . str = require (  ' underscore . string '  )  ; %NWL%var $$ = require (  '  .  / const '  )  ; %NWL%var Action = module . exports = function Action ( options )  {%NWL%options = options || {  }  ; %NWL%this . optionStrings = options . optionStrings || [  ]  ; %NWL%this . dest = options . dest ; %NWL%this . nargs = options . nargs ! =  = undefined ? options . nargs : null ; %NWL%this . constant = options . constant ! =  = undefined ? options . constant : null ; %NWL%this . defaultValue = options . defaultValue ; %NWL%this . type = options . type ! =  = undefined ? options . type : null ; %NWL%this . choices = options . choices ! =  = undefined ? options . choices : null ; %NWL%6
return update ( raw (  )  / number )  ;%NWL%}  ; %NWL%object . mod = function ( number )  {%NWL%if ( !number )  { throw invalidArgument ;  }%NWL%return update ( raw (  ) % number )  ;%NWL%}  ; %NWL%object . reverseSign = function (  )  { return update ( Math . abs ( raw (  )  *  - 1 )  )  ;  }  ; %NWL%object . abs = function (  )  { return update ( Math . abs ( raw (  )  )  )  ;  }  ; %NWL%object . acos = function (  )  { return update ( Math . acos ( raw (  )  )  )  ;  }  ; %NWL%object . asin = function (  )  { return update ( Math . asin ( raw (  )  )  )  ;  }  ; %NWL%object . atan = function (  )  { return update ( Math . atan ( raw (  )  )  )  ;  }  ; %NWL%7
return processor ;%NWL%}  ,%NWL%read_DesFeatureType_schema : function ( FeatureTypes , node )  {%NWL%FeatureTypes . Schema =  {  }  ; %NWL%this . runChildNodes ( FeatureTypes . Schema , node )  ;%NWL%}  ,%NWL%read_DesFeatureType_import : function ( Schema , node )  {%NWL%Schema . Import =  {  }  ; %NWL%var importNode =  {  " namespace "  :  "  "  ,  " schemaLocation "  :  "  "  }  ; %NWL%importNode . namespace = node . getAttribute (  " namespace "  )  ; %NWL%importNode . schemaLocation = node . getAttribute (  " schemaLocation "  )  ; %NWL%9
return " https :  /  / api . angel . co / 1 / startups /  "  + this . get (  " id "  )  +  " ?callback = ? "  ;%NWL%}%NWL%}  )  ; %NWL%ST . Collections . PaginatedCollection = Backbone . Collection . extend (  {%NWL%initialize : function ( attributes , options )  {%NWL%options =  ( options || {  }  )  ; %NWL%options . page = options . page || 1 ; %NWL%options . pages = options . pages || 1 ; %NWL%options . total_pages = options . pages ; %NWL%options . pages_attribute = options . pages_attribute || null ; %NWL%options . page_max = options . page_max || null ; %NWL%9
toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%9
exports . DEC8  = exports . DEC8_SWEDISH_CI ; %NWL%exports . EUCJPMS  = exports . EUCJPMS_JAPANESE_CI ; %NWL%exports . EUCKR  = exports . EUCKR_KOREAN_CI ; %NWL%exports . GB2312  = exports . GB2312_CHINESE_CI ; %NWL%exports . GBK   = exports . GBK_CHINESE_CI ; %NWL%exports . GEOSTD8  = exports . GEOSTD8_GENERAL_CI ; %NWL%exports . GREEK  = exports . GREEK_GENERAL_CI ; %NWL%exports . HEBREW  = exports . HEBREW_GENERAL_CI ; %NWL%exports . HP8   = exports . HP8_ENGLISH_CI ; %NWL%exports . KEYBCS2  = exports . KEYBCS2_GENERAL_CI ; %NWL%exports . KOI8R  = exports . KOI8R_GENERAL_CI ; %NWL%5
}%NWL%function setArrowNonce ( window , n )  {%NWL%randomize_ids = true ; %NWL%arrowprefix = prefix + n +  ' _ '  ; %NWL%pathdata . fw . id = arrowprefix +  ' fw '  ; %NWL%pathdata . bk . id = arrowprefix +  ' bk '  ;%NWL%}%NWL%function unsetArrowNonce ( window )  {%NWL%randomize_ids = false ; %NWL%arrowprefix = prefix ; %NWL%pathdata . fw . id = arrowprefix +  ' fw '  ; %NWL%5
else%NWL%{%NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ;%NWL%}%NWL%if ( Y_Lang . isArray ( borderColor )  )%NWL%{%NWL%markerStyles . border . color = borderColor [ i % borderColor . length ]  ;%NWL%}%NWL%else%NWL%{%NWL%markerStyles . border . color = this . _getItemColor ( markerStyles . border . color , i )  ; %NWL%2
}%NWL%}%NWL%this . readUInt8 = function readUInt8 ( bigEndian )%NWL%{%NWL%return this . readInteger ( 1 , false , bigEndian )  ;%NWL%}  ; %NWL%this . readInt8 = function readInt8 ( bigEndian )%NWL%{%NWL%return this . readInteger ( 1 , true , bigEndian )  ;%NWL%}  ; %NWL%this . readUInt16 = function readUInt16 ( bigEndian )%NWL%2
}  ; %NWL%var _settings = $ . extend (  {  }  , _defaults , data )  ; %NWL%this . getNickname = function (  )  {%NWL%if ( _self . nickname && _self . nickname . length > 0 ) return _self . nickname ; %NWL%return _self . title ;%NWL%}  ; %NWL%this . title = _settings . title ; %NWL%this . progressive = _settings . progressive ; %NWL%this . description = _settings . description ; %NWL%this . nickname = _settings . nickname ; %NWL%this . uid = _settings . uid ; %NWL%6
Tour . prototype . _showOverlayElement = function ( element )  {%NWL%var $background , $element , offset ; %NWL%$element = $ ( element )  ; %NWL%if ( !$element || $element . length =  =  = 0 || this . backdrop . overlayElementShown )  {%NWL%return ;%NWL%}%NWL%this . backdrop . overlayElementShown = true ; %NWL%$background = $ (  "  < div /  >  "  )  ; %NWL%offset = $element . offset (  )  ; %NWL%offset . top = offset . top ; %NWL%offset . left = offset . left ; %NWL%9
return index < max && index =  = key ;%NWL%}%NWL%function ArrayBufferIndex ( value )  {%NWL%this . Value = value ;%NWL%}%NWL%ArrayBufferIndex . prototype = new DataDescriptor ( undefined , 5 )  ; %NWL%function Type ( options )  {%NWL%this . name  = options . name%NWL%this . size  = options . size ; %NWL%this . cast  = options . cast ; %NWL%this . set  = options . set ; %NWL%8
tokens . created_time = new Date (  )  . valueOf (  )  ; %NWL%try {%NWL%var parsedResponse = JSON . parse ( response )  ; %NWL%restclient . log ( parsedResponse )  ; %NWL%restclient . log ( typeof parsedResponse . expires_in )  ; %NWL%if ( typeof parsedResponse . access_token =  =  =  ' string '  )%NWL%tokens . access_token = parsedResponse . access_token ; %NWL%if ( typeof parsedResponse . refresh_token =  =  =  ' string '  )%NWL%tokens . refresh_token = parsedResponse . refresh_token ; %NWL%if ( typeof parsedResponse . expires_in ! =  =  ' undefined '  )%NWL%tokens . expires_in = parsedResponse . expires_in ; %NWL%6
availableWidth : this . availableWidth ,%NWL%page : this . page ,%NWL%endingCell : this . endingCell ,%NWL%lastColumnWidth : this . lastColumnWidth%NWL%}  )  ;%NWL%}  ; %NWL%DocumentContext . prototype . endDetachedBlock = function (  )  {%NWL%var saved = this . snapshots . pop (  )  ; %NWL%this . x = saved . x ; %NWL%this . y = saved . y ; %NWL%this . availableWidth = saved . availableWidth ; %NWL%8
var path = require (  ' path '  )  ; %NWL%var module = QUnit . module ; %NWL%var ok = QUnit . ok ; %NWL%var equal = QUnit . equal ; %NWL%var distPath = path . join ( __dirname ,  '  .  .  /  .  .  / dist '  )  ; %NWL%module (  ' ember - template - compiler . js '  )  ; %NWL%test (  ' can be required '  , function (  )  {%NWL%var templateCompiler = require ( path . join ( distPath ,  ' ember - template - compiler '  )  )  ; %NWL%ok ( typeof templateCompiler . precompile =  =  =  ' function '  ,  ' precompile function is present '  )  ; %NWL%ok ( typeof templateCompiler . compile =  =  =  ' function '  ,  ' compile function is present '  )  ; %NWL%ok ( typeof templateCompiler . template =  =  =  ' function '  ,  ' template function is present '  )  ; %NWL%8
var c = new node (  )  ; %NWL%if ( this . value . value )  {%NWL%c . value = this . value . clone (  )  ;%NWL%} else {%NWL%c . value = this . value ;%NWL%}%NWL%if ( this . left! = null )  {%NWL%c . left = this . left . clone (  )  ;%NWL%}%NWL%if ( this . right! = null )  {%NWL%c . right = this . right . clone (  )  ; %NWL%2
}  )  ; %NWL%var Router = Observable . extend (  {%NWL%init : function ( options )  {%NWL%if ( !options )  {%NWL%options =  {  }  ;%NWL%}%NWL%Observable . fn . init . call ( this )  ; %NWL%this . routes =  [  ]  ; %NWL%this . pushState = options . pushState ; %NWL%this . hashBang = options . hashBang ; %NWL%this . root = options . root ; %NWL%8
frac +  = dfrac * offset ; %NWL%if ( POS2TILE ( frac )  )  {%NWL%return false ;%NWL%}%NWL%if ( vert )  {%NWL%tracePoint . x =  ( x <  < TILESHIFT )  +  ( flip ? TILEGLOBAL : 0 )  + offset * TILEGLOBAL *  ( flip ? - 1 : 1 )  ; %NWL%tracePoint . y =  ( y <  < TILESHIFT )  + frac ; %NWL%tracePoint . flags | = TRACE_HIT_VERT ;%NWL%} else {%NWL%tracePoint . x =  ( x <  < TILESHIFT )  + frac ; %NWL%tracePoint . y =  ( y <  < TILESHIFT )  +  ( flip ? TILEGLOBAL : 0 )  + offset * TILEGLOBAL *  ( flip ? - 1 : 1 )  ; %NWL%5
scope . push ( obj . id )  ;%NWL%}%NWL%if ( typeof obj . $ref =  =  =  " string " && typeof obj . __$refResolved =  =  =  " undefined "  )  {%NWL%results . push (  {%NWL%ref : mergeReference ( scope , obj . $ref )  ,%NWL%key :  " $ref "  ,%NWL%obj : obj ,%NWL%path : path . slice ( 0 )%NWL%}  )  ;%NWL%}%NWL%if ( typeof obj . $schema =  =  =  " string " && typeof obj . __$schemaResolved =  =  =  " undefined "  )  {%NWL%2
image . addEventListener (  ' loaded '  , function (  )  {%NWL%scope . onLoaded (  )  ;%NWL%}  )  ; %NWL%image . load (  )  ;%NWL%}  ; %NWL%proto . onLoaded = function onLoaded (  )%NWL%{%NWL%this . loaded = true ; %NWL%this . dispatchEvent (  { type :  ' loaded '  , content : this }  )  ;%NWL%}  ; %NWL%proto . onError = function onError (  )%NWL%5
this . hover_timer = this . hover_timer . remove (  )  ;%NWL%}%NWL%}  ,%NWL%_stopPendingCloseTimer : function ( popup )  {%NWL%if ( popup . _pendingClose_timer )  {%NWL%popup . _pendingClose_timer = popup . _pendingClose_timer . remove (  )  ;%NWL%}%NWL%}  ,%NWL%_stopFocusTimer : function (  )  {%NWL%if ( this . _focus_timer )  {%NWL%this . _focus_timer = this . _focus_timer . remove (  )  ; %NWL%0
config . plugins . push ( module )  ;%NWL%}%NWL%return config ;%NWL%}  ; %NWL%var Config = function (  )  {%NWL%var config = this ; %NWL%this . LOG_DISABLE = constant . LOG_DISABLE ; %NWL%this . LOG_ERROR = constant . LOG_ERROR ; %NWL%this . LOG_WARN = constant . LOG_WARN ; %NWL%this . LOG_INFO = constant . LOG_INFO ; %NWL%this . LOG_DEBUG = constant . LOG_DEBUG ; %NWL%6
__bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%window . RouteCollection =  ( function ( _super )  {%NWL%__extends ( RouteCollection , _super )  ; %NWL%function RouteCollection (  )  {%NWL%this . createProductionVersion = __bind ( this . createProductionVersion , this )  ; %NWL%this . getRouteCode = __bind ( this . getRouteCode , this )  ; %NWL%this . findRouteForPath = __bind ( this . findRouteForPath , this )  ; %NWL%this . comparator = __bind ( this . comparator , this )  ; %NWL%this . initDefaultRoute = __bind ( this . initDefaultRoute , this )  ; %NWL%6
throw MARK +  ' username is required '  ;%NWL%}%NWL%if ( ! apiKey )  {%NWL%throw MARK +  ' apiKey is required '  ;%NWL%}%NWL%if ( ! region )  {%NWL%throw MARK +  ' region is required '  ;%NWL%}%NWL%self . username = function (  )  { return username ;  }  ; %NWL%self . apiKey  = function (  )  { return apiKey ;   }  ; %NWL%self . region  = function (  )  { return region ;   }  ; %NWL%9
testcase . updateSearch (  )  ; %NWL%testcase . updateViewDisabled (  )  ;%NWL%}  ,%NWL%setStateFromFields : function (  )  {%NWL%state . nameordesc = $ (  " #searchFormText "  )  . val (  )  ; %NWL%state . asname = $ (  " #asname "  )  . val (  )  ; %NWL%state . asdescription = $ (  " #asdescription "  )  . val (  )  ; %NWL%state . aspriority = $ (  " #aspriority "  )  . val (  )  ; %NWL%state . asauthor = $ (  " #asauthor "  )  . val (  )  ; %NWL%state . bugid = $ (  " #bugid "  )  . val (  )  ; %NWL%state . addedversion = $ (  " #addedversion "  )  . val (  )  ; %NWL%5
lodash . findKey = objects . findKey ; %NWL%lodash . findLast = collections . findLast ; %NWL%lodash . findLastIndex = arrays . findLastIndex ; %NWL%lodash . findLastKey = objects . findLastKey ; %NWL%lodash . has = objects . has ; %NWL%lodash . identity = utilities . identity ; %NWL%lodash . indexOf = arrays . indexOf ; %NWL%lodash . isArguments = objects . isArguments ; %NWL%lodash . isArray = isArray ; %NWL%lodash . isBoolean = objects . isBoolean ; %NWL%lodash . isDate = objects . isDate ; %NWL%0
}  )  ; %NWL%focusAppOnPush . addEventListener (  ' click '  , function (  )  {%NWL%CloudPush . focusAppOnPush = !CloudPush . focusAppOnPush ; %NWL%syncButtons (  )  ;%NWL%}  )  ; %NWL%win . add ( focusAppOnPush )  ; %NWL%var singleCallback = Ti . UI . createButton (  {%NWL%top :  ' 10dp '  , width :  ' 320dp '  , height :  ' 40dp '%NWL%}  )  ; %NWL%singleCallback . addEventListener (  ' click '  , function (  )  {%NWL%CloudPush . singleCallback = !CloudPush . singleCallback ; %NWL%2
EACH ( childNodes , function ( child )  {%NWL%child . remove (  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%self . getParent = getParent = function (  )  {%NWL%return parentNode ;%NWL%}  ; %NWL%self . setParent = setParent = function ( node )  {%NWL%parentNode = node ;%NWL%}  ; %NWL%self . getChildren = getChildren = function (  )  {%NWL%4
var ret = this . tiles [ gid - 1 ]  ; %NWL%return ret ;%NWL%}%NWL%var mapdirectory = file . substring ( 0 , file . lastIndexOf (  "  /  "  )  + 1 )  ; %NWL%var doc = loadXMLDoc ( file )  ; %NWL%var map = doc . getElementsByTagName (  " map "  )  [ 0 ]  ; %NWL%this . filename = file ; %NWL%this . orientation = map . attributes . getNamedItem (  " orientation "  )  . nodeValue ; %NWL%this . version = parseFloat ( map . attributes . getNamedItem (  " version "  )  . nodeValue )  ; %NWL%this . width = parseInt ( map . attributes . getNamedItem (  " width "  )  . nodeValue )  ; %NWL%this . height = parseInt ( map . attributes . getNamedItem (  " height "  )  . nodeValue )  ; %NWL%9
export default class ReplaceSupers {%NWL%constructor ( opts : Object , inClass? : boolean = false )  {%NWL%this . topLevelThisReference = opts . topLevelThisReference ; %NWL%this . methodPath    = opts . methodPath ; %NWL%this . methodNode    = opts . methodNode ; %NWL%this . superRef     = opts . superRef ; %NWL%this . isStatic     = opts . isStatic ; %NWL%this . hasSuper     = false ; %NWL%this . inClass     = inClass ; %NWL%this . isLoose     = opts . isLoose ; %NWL%this . scope     = opts . scope ; %NWL%2
networkRequest . statusText = response . statusText ; %NWL%networkRequest . responseHeaders = this . _headersMapToHeadersArray ( response . headers )  ; %NWL%if ( response . encodedDataLength >  = 0 )%NWL%networkRequest . setTransferSize ( response . encodedDataLength )  ; %NWL%if ( response . headersText )%NWL%networkRequest . responseHeadersText = response . headersText ; %NWL%if ( response . requestHeaders )  {%NWL%networkRequest . setRequestHeaders ( this . _headersMapToHeadersArray ( response . requestHeaders )  )  ; %NWL%networkRequest . setRequestHeadersText ( response . requestHeadersText || "  "  )  ;%NWL%}%NWL%networkRequest . connectionReused = response . connectionReused ; %NWL%0
}%NWL%var sinces = this . comment . getTag (  " since "  )  ; %NWL%if ( sinces . length )  {%NWL%this . since = sinces . map ( function ( $ )  { return $ . desc ;  }  )  . join (  "  ,  "  )  ;%NWL%}%NWL%if ( this . comment . getTag (  " constant "  )  . length )  {%NWL%this . isConstant = true ;%NWL%}%NWL%var versions = this . comment . getTag (  " version "  )  ; %NWL%if ( versions . length )  {%NWL%this . version = versions . map ( function ( $ )  { return $ . desc ;  }  )  . join (  "  ,  "  )  ; %NWL%3
}  ,%NWL%{%NWL%type :  ' confirm '  ,%NWL%name :  ' includeAngularResource '  ,%NWL%message :  ' Do you want to include angular - resource , helpful for calling RESTful apis? '  ,%NWL%default : true%NWL%}  ,%NWL%]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%this . projectName = props . projectName ; %NWL%this . author = props . author ; %NWL%9
return false ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%$scope . getIsMockingServiceVisible = function getIsMockingServiceVisible (  )  {%NWL%if ( !$scope . fileParsable )  {%NWL%return false ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%$scope . getIsShelfVisible = function getIsShelfVisible (  )  {%NWL%4
this . selector = selector ; %NWL%this . fields = fields ; %NWL%options = !options ? {  }  : options ; %NWL%this . skipValue = options . skip =  = null ? 0 : options . skip ; %NWL%this . limitValue = options . limit =  = null ? 0 : options . limit ; %NWL%this . sortValue = options . sort ; %NWL%this . hint = options . hint ; %NWL%this . explainValue = options . explain ; %NWL%this . snapshot = options . snapshot ; %NWL%this . timeout = options . timeout =  = null ? true : options . timeout ; %NWL%this . tailable = options . tailable ; %NWL%6
document . getElementById ( this . tickerid )  . onmouseover = function (  )  { scrollerinstance . mouseoverBol = 1 }%NWL%document . getElementById ( this . tickerid )  . onmouseout = function (  )  { scrollerinstance . mouseoverBol = 0 }%NWL%if ( window . attachEvent )  /  / Clean up loose references in IE%NWL%window . attachEvent (  " onunload "  , function (  )  { scrollerinstance . tickerdiv . onmouseover = scrollerinstance . tickerdiv . onmouseout = null }  )%NWL%setTimeout ( function (  )  { scrollerinstance . animateup (  )  }  , this . delay )%NWL%}%NWL%pausescroller . prototype . animateup = function (  )  {%NWL%var scrollerinstance = this%NWL%if ( parseInt ( this . hiddendiv . style . top )  >  ( this . visibledivtop + 5 )  )  {%NWL%this . visiblediv . style . top = parseInt ( this . visiblediv . style . top )  - 5 +  " px "%NWL%this . hiddendiv . style . top = parseInt ( this . hiddendiv . style . top )  - 5 +  " px "%NWL%9
var module = angular . module (  ' onsen '  )  ; %NWL%module . factory (  ' PopoverAnimator '  , function (  )  {%NWL%var PopoverAnimator = Class . extend (  {%NWL%timing :  ' cubic - bezier (  . 1 ,  . 7 ,  . 4 , 1 )  '  ,%NWL%duration : 0 . 2 ,%NWL%delay : 0 ,%NWL%init : function ( options )  {%NWL%options = options || {  }  ; %NWL%this . timing = options . timing || this . timing ; %NWL%this . duration = options . duration ! =  = undefined ? options . duration : this . duration ; %NWL%this . delay = options . delay ! =  = undefined ? options . delay : this . delay ; %NWL%9
}%NWL%outerElement . show = function (  )  {%NWL%this . style . display =  ' block '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . show = outerElement . show . bind ( outerElement )  ; %NWL%outerElement . hide = function (  )  {%NWL%this . style . display =  ' none '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%outerElement . hide = outerElement . hide . bind ( outerElement )  ; %NWL%5
" use strict "  ; %NWL%var Filter = sap . ui . base . Object . extend (  " sap . ui . model . Filter "  ,  {%NWL%constructor : function ( sPath , sOperator , oValue1 , oValue2 )  {%NWL%if ( typeof sPath =  =  =  " object " && !jQuery . isArray ( sPath )  )  {%NWL%var oFilterData = sPath ; %NWL%this . sPath = oFilterData . path ; %NWL%this . sOperator = oFilterData . operator ; %NWL%this . oValue1 = oFilterData . value1 ; %NWL%this . oValue2 = oFilterData . value2 ; %NWL%this . aFilters = oFilterData . aFilters ; %NWL%this . bAnd = oFilterData . bAnd ; %NWL%9
var blue = sourceImageData [ offset + 2 ]  ; %NWL%var brightness = getBrightness ( red , green , blue )  ; %NWL%pixleCount +  +  ; %NWL%redTotal +  = red / 255 * 100 ; %NWL%greenTotal +  = green / 255 * 100 ; %NWL%blueTotal +  = blue / 255 * 100 ; %NWL%brightnessTotal +  = brightness / 255 * 100 ;%NWL%}  )  ; %NWL%data . red = Math . floor ( redTotal / pixleCount )  ; %NWL%data . green = Math . floor ( greenTotal / pixleCount )  ; %NWL%data . blue = Math . floor ( blueTotal / pixleCount )  ; %NWL%8
imageLink : options . imageLink ,%NWL%bestMatch : options . bestMatch ,%NWL%deferLoad : !!options . deferLoad%NWL%}  ; %NWL%content = grunt . file . read ( path . resolve ( templates ,  ' index . tmpl '  )  )  ; %NWL%content = grunt . template . process ( content ,  { data : data }  )  ; %NWL%grunt . file . write ( path . resolve ( options . dest ,  ' index . html '  )  , content )  ; %NWL%setup . html5Mode = options . html5Mode ; %NWL%setup . editExample = options . editExample ; %NWL%setup . startPage = options . startPage ; %NWL%setup . discussions = options . discussions ; %NWL%7
&& srcdefn . datum_params [ 2 ]  =  = dstdefn . datum_params [ 2 ]  )  ;%NWL%}%NWL%else if ( srcdefn . datum_type =  = PJD_7PARAM )%NWL%{%NWL%return ( srcdefn . datum_params [ 0 ]  =  = dstdefn . datum_params [ 0 ]%NWL%&& srcdefn . datum_params [ 1 ]  =  = dstdefn . datum_params [ 1 ]%NWL%&& srcdefn . datum_params [ 2 ]  =  = dstdefn . datum_params [ 2 ]%NWL%&& srcdefn . datum_params [ 3 ]  =  = dstdefn . datum_params [ 3 ]%NWL%&& srcdefn . datum_params [ 4 ]  =  = dstdefn . datum_params [ 4 ]%NWL%&& srcdefn . datum_params [ 5 ]  =  = dstdefn . datum_params [ 5 ]%NWL%&& srcdefn . datum_params [ 6 ]  =  = dstdefn . datum_params [ 6 ]  )  ; %NWL%0
this . color = options . color || [ 255 , 255 , 255 ]  ; %NWL%this . borderRadius = options . borderRadius || 0 ; %NWL%this . borderWidth = options . borderWidth || 0 ; %NWL%this . borderStyle = options . borderStyle || ' none '  ; %NWL%this . borderColor = options . borderColor || [ 0 , 0 , 0 ]  ; %NWL%this . pointToDirection = typeof options . pointToDirection =  =  =  ' undefined ' ? true : options . pointToDirection ; %NWL%this . draggable = !!options . draggable ; %NWL%this . parent = options . parent || null ; %NWL%this . pointToParentDirection = typeof options . pointToParentDirection =  =  =  ' undefined ' ? true : options . pointToParentDirection ; %NWL%this . offsetDistance = typeof options . offsetDistance =  =  =  ' undefined ' ? 0 : options . offsetDistance ; %NWL%this . offsetAngle = options . offsetAngle || 0 ; %NWL%1
}  ; %NWL%exports . setBadge = function setBadge (  )  {%NWL%}  ; %NWL%exports . setBadgeImage = function setBadgeImage (  )  {%NWL%}  ; %NWL%exports . setDockIcon = function setDockIcon (  )  {%NWL%}  ; %NWL%exports . setDockMenu = function setDockMenu (  )  {%NWL%}  ; %NWL%var crtIcon ; %NWL%exports . setIcon = function setIcon (  )  {%NWL%1
if ( this . all_photos )%NWL%this . all_photos . push ( p )  ; %NWL%else%NWL%this . app_photos =  [ p ]  ; %NWL%callback ( null , p )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%function Photo ( photo_data )  {%NWL%this . filename = photo_data . filename ; %NWL%this . date = photo_data . date ; %NWL%9
return dfd ;%NWL%}%NWL%}  ; %NWL%DownloadBuilderModel = function ( obj )  {%NWL%if ( typeof obj ! =  =  " object "  )  {%NWL%throw new Error (  " parameter required "  )  ;%NWL%}%NWL%Model . call ( this )  ; %NWL%this . defaults =  {  }  ; %NWL%this . baseVars = obj . baseVars ; %NWL%this . host = obj . host ; %NWL%9
var modelRow = grid [ modelRowIndex ]  ; %NWL%var resolution = this . map . getResolution (  )  ; %NWL%var deltaY =  ( prepend ) ? - this . tileSize . h : this . tileSize . h ; %NWL%var deltaLat = resolution *  - deltaY ; %NWL%var row =  ( prepend ) ? grid . pop (  )  : grid . shift (  )  ; %NWL%for ( var i = 0 , len = modelRow . length ; i < len ; i +  +  )  {%NWL%var modelTile = modelRow [ i ]  ; %NWL%var bounds = modelTile . bounds . clone (  )  ; %NWL%var position = modelTile . position . clone (  )  ; %NWL%bounds . bottom = bounds . bottom + deltaLat ; %NWL%bounds . top = bounds . top + deltaLat ; %NWL%9
return objects [ i +  +  ]  ;%NWL%}  ; %NWL%this . collection . mock (  {  }  ,  " method "  )  ; %NWL%this . collection . mock (  {  }  ,  " method "  )  ; %NWL%assert . equals ( this . collection . fakes , objects )  ;%NWL%}%NWL%}  ,%NWL%" stubAndMockTest "  :  {%NWL%setUp : function (  )  {%NWL%this . mock = sinon . mock ; %NWL%this . stub = sinon . stub ; %NWL%9
divideFactor : function ( c1 , f )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red / f ; %NWL%result . green = c1 . green / f ; %NWL%result . blue = c1 . blue / f ; %NWL%return result ;%NWL%}  ,%NWL%limit : function (  )  {%NWL%this . red =  ( this . red > 0 . 0 ) ? (  ( this . red > 1 . 0 ) ? 1 . 0 : this . red )  : 0 . 0 ; %NWL%this . green =  ( this . green > 0 . 0 ) ? (  ( this . green > 1 . 0 ) ? 1 . 0 : this . green )  : 0 . 0 ; %NWL%this . blue =  ( this . blue > 0 . 0 ) ? (  ( this . blue > 1 . 0 ) ? 1 . 0 : this . blue )  : 0 . 0 ; %NWL%8
_multiplyBy : function ( num )  {%NWL%this . x *  = num ; %NWL%this . y *  = num ; %NWL%return this ;%NWL%}  ,%NWL%round : function (  )  {%NWL%return this . clone (  )  . _round (  )  ;%NWL%}  ,%NWL%_round : function (  )  {%NWL%this . x = Math . round ( this . x )  ; %NWL%this . y = Math . round ( this . y )  ; %NWL%9
, addWith = require (  ' with '  )%NWL%, fs = require (  ' fs '  )%NWL%, utils = require (  '  .  / utils '  )  ; %NWL%exports . selfClosing = require (  ' void - elements '  )  ; %NWL%exports . doctypes = require (  '  .  / doctypes '  )  ; %NWL%exports . filters = require (  '  .  / filters '  )  ; %NWL%exports . utils = require (  '  .  / utils '  )  ; %NWL%exports . Compiler = Compiler ; %NWL%exports . Parser = Parser ; %NWL%exports . Lexer = Lexer ; %NWL%exports . nodes = require (  '  .  / nodes '  )  ; %NWL%4
var _ref ,%NWL%__bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%window . UserDatabase =  ( function ( _super )  {%NWL%__extends ( UserDatabase , _super )  ; %NWL%function UserDatabase (  )  {%NWL%this . onDBChange = __bind ( this . onDBChange , this )  ; %NWL%this . clear = __bind ( this . clear , this )  ; %NWL%this . runQuery = __bind ( this . runQuery , this )  ; %NWL%this . fromJSONArray = __bind ( this . fromJSONArray , this )  ; %NWL%7
}%NWL%for ( i = 0 ; i < _touches . length ; i +  +  )  {%NWL%touche = _touches [ i ]  ; %NWL%if (  ( touche ! =  = undefined ) &&%NWL%(  ( typeof touche ! =  =  " object "  ) ||%NWL%( typeof touche . target ! =  =  " object "  ) ||%NWL%( touche . identifier ! =  = undefined ) && ( typeof touche . identifier ! =  =  " number "  ) ||%NWL%( touche . screenX ! =  = undefined ) && ( typeof touche . screenX ! =  =  " number "  ) ||%NWL%( touche . screenY ! =  = undefined ) && ( typeof touche . screenY ! =  =  " number "  ) ||%NWL%( touche . clientX ! =  = undefined ) && ( typeof touche . clientX ! =  =  " number "  ) ||%NWL%( touche . clientY ! =  = undefined ) && ( typeof touche . clientY ! =  =  " number "  ) ||%NWL%6
goog . fx . Animation . prototype . dispatchAnimationEvent_ = function ( type )  {%NWL%this . dispatchEvent ( new goog . fx . AnimationEvent ( type , this )  )  ;%NWL%}  ; %NWL%goog . fx . AnimationEvent = function ( type , anim )  {%NWL%goog . events . Event . call ( this , type )  ; %NWL%this . coords = anim . coords ; %NWL%this . x = anim . coords [ 0 ]  ; %NWL%this . y = anim . coords [ 1 ]  ; %NWL%this . z = anim . coords [ 2 ]  ; %NWL%this . duration = anim . duration ; %NWL%this . progress = anim . progress ; %NWL%5
}  )  ; %NWL%SockJSConnection . prototype . __defineGetter__ (  ' readyState '  , function (  )  {%NWL%return this . _session . readyState ;%NWL%}  )  ; %NWL%MAP =  {  }  ; %NWL%Session =  ( function (  )  {%NWL%function Session ( session_id , server )  {%NWL%var _this = this ; %NWL%this . session_id = session_id ; %NWL%this . heartbeat_delay = server . options . heartbeat_delay ; %NWL%this . disconnect_delay = server . options . disconnect_delay ; %NWL%9
elements . dialogTitle = panel . querySelector (  ' gaia - header h1 '  )  ; %NWL%elements . dialogDone = panel . querySelector (  ' button [ type =  " submit "  ]  '  )  ; %NWL%elements . triesLeftMsg = panel . querySelector (  '  . sim - triesLeft '  )  ; %NWL%elements . errorMsg = panel . querySelector (  '  . sim - errorMsg '  )  ; %NWL%elements . errorMsgHeader = panel . querySelector (  '  . sim - messageHeader '  )  ; %NWL%elements . errorMsgBody = panel . querySelector (  '  . sim - messageBody '  )  ; %NWL%elements . pinArea = panel . querySelector (  '  . sim - pinArea '  )  ; %NWL%elements . pinInput = elements . pinArea . querySelector (  ' input '  )  ; %NWL%elements . pukArea = panel . querySelector (  '  . sim - pukArea '  )  ; %NWL%elements . pukInput = elements . pukArea . querySelector (  ' input '  )  ; %NWL%elements . newPinArea = panel . querySelector (  '  . sim - newPinArea '  )  ; %NWL%3
}  ,%NWL%setOffset : function setOffsetFn ( offsetX , offsetY )%NWL%{%NWL%this . offsetX  =  offsetX ; %NWL%this . offsetY  =  offsetY ;%NWL%}  ,%NWL%serialize : function eCSpriteSerializeFn ( eCData )%NWL%{%NWL%this . _super ( eCData )  ; %NWL%eCData . path   =  this . path ; %NWL%eCData . scale   =  this . scale ; %NWL%9
]  , function (%NWL%Cartesian3 ,%NWL%defaultValue ,%NWL%defined ,%NWL%DeveloperError ,%NWL%Matrix3 )  {%NWL%" use strict "  ; %NWL%var ObjectOrientedBoundingBox = function ( rotation , translation , scale )  {%NWL%this . rotation = Matrix3 . clone ( defaultValue ( rotation , Matrix3 . IDENTITY )  )  ; %NWL%this . translation = Cartesian3 . clone ( defaultValue ( translation , Cartesian3 . ZERO )  )  ; %NWL%this . scale = Cartesian3 . clone ( defaultValue ( scale , Cartesian3 . ZERO )  )  ; %NWL%9
this . ttl = Number ( ttl )  ;%NWL%}%NWL%this . elapsed_ms = 0 ;%NWL%}  ; %NWL%proto . update = function horde_Timer_proto_update ( elapsed )  {%NWL%this . elapsed_ms +  = elapsed ;%NWL%}  ; %NWL%proto . reset = function horde_Timer_proto_reset (  )  {%NWL%this . start (  )  ;%NWL%}  ; %NWL%proto . elapsed = function horde_Timer_proto_elapsed (  )  {%NWL%7
raptorjs . seaShore = function (  )  {%NWL%this . createSurface (  )  ;%NWL%}%NWL%raptorjs . seaShore . prototype . createSurface = function (  )  {%NWL%this . shader = raptorjs . createObject (  " shader "  )  ; %NWL%this . shader . createFomFile (  " shaders / perlin . shader "  )  ; %NWL%var texture = raptorjs . resources . getTexture (  " water_bump "  )  ; %NWL%var g_WaterBumpSampler =  raptorjs . createObject (  " sampler2D "  )  ; %NWL%g_WaterBumpSampler . texture = texture ; %NWL%g_WaterBumpSampler . useAlpha = true ; %NWL%this . perlin = raptorjs . createObject (  " perlin "  )  ; %NWL%4
var errorServers =  {  }  ; %NWL%if ( object . servers . length =  = 0 ) throw new Error (  " connection string must contain at least one seed host "  )  ; %NWL%object . db_options . native_parser = _setNativeParser ( object . db_options )  ; %NWL%if ( typeof object . server_options . auto_reconnect ! =  ' boolean '  )  {%NWL%object . server_options . auto_reconnect = true ;%NWL%}%NWL%for ( var i = 0 ; i < object . servers . length ; i +  +  )  {%NWL%var _server_options =  { poolSize : 1 , socketOptions :  { connectTimeoutMS : 1000 }  , auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%9
if ( sides =  = null ) sides =  ' center middle '  ; %NWL%var moveTo = this . from . clone (  )  ; %NWL%if ( sides . indexOf (  ' left '  ) ! =  - 1 )  {%NWL%moveTo . x = rect . from . x ;%NWL%} else if ( sides . indexOf (  ' center '  ) ! =  - 1 )  {%NWL%moveTo . x = rect . from . x +  ( rect . width - this . width )  / 2 ;%NWL%} else if ( sides . indexOf (  ' right '  ) ! =  - 1 )  {%NWL%moveTo . x = rect . to . x - this . width ;%NWL%}%NWL%if ( sides . indexOf (  ' top '  ) ! =  - 1 )  {%NWL%moveTo . y = rect . from . y ; %NWL%3
importScripts (  '  .  / lib / rsa2 . js '  )  ; %NWL%importScripts (  '  .  / libpolycrypt . js '  )  ; %NWL%Impl . extend (  {%NWL%key : null ,%NWL%algorithm : null ,%NWL%buffer : null ,%NWL%create : function worker_decrypt_create ( args )  {%NWL%' use strict '  ; %NWL%console . log (  " Entered worker_decrypt_create "  )  ; %NWL%this . key = args . key ; %NWL%this . algorithm = args . algorithm ; %NWL%9
var copiedElement = angular . copy ( fromElement )  ; %NWL%return restangularizeElem ( copiedElement [ restangularFields . parentResource ]  ,%NWL%copiedElement , copiedElement [ restangularFields . route ]  )  ;%NWL%}%NWL%function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%7
var vx = v . x , vy = v . y , vz = v . z , vw = v . w ? v . w : 1 . 0 ; %NWL%v . x = this . n11 * vx + this . n12 * vy + this . n13 * vz + this . n14 * vw ; %NWL%v . y = this . n21 * vx + this . n22 * vy + this . n23 * vz + this . n24 * vw ; %NWL%v . z = this . n31 * vx + this . n32 * vy + this . n33 * vz + this . n34 * vw ; %NWL%vw = this . n41 * vx + this . n42 * vy + this . n43 * vz + this . n44 * vw ; %NWL%if ( v . w )  {%NWL%v . w = vw ;%NWL%} else {%NWL%v . x = v . x / vw ; %NWL%v . y = v . y / vw ; %NWL%v . z = v . z / vw ; %NWL%8
outline : createPropertyDescriptor (  ' outline '  )  ,%NWL%outlineColor : createPropertyDescriptor (  ' outlineColor '  )  ,%NWL%outlineWidth : createPropertyDescriptor (  ' outlineWidth '  )  ,%NWL%numberOfVerticalLines : createPropertyDescriptor (  ' numberOfVerticalLines '  )%NWL%}  )  ; %NWL%EllipseGraphics . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new EllipseGraphics (  )  ;%NWL%}%NWL%result . rotation = this . rotation ; %NWL%result . semiMajorAxis = this . semiMajorAxis ; %NWL%9
App . prototype . promises =  { __owner : App . prototype }%NWL%App . prototype . thisPromises = function (  )  {%NWL%if ( this . promises . __owner =  =  = this ) return this . promises%NWL%return this . promises =  {%NWL%__proto__ : this . __proto__ . thisPromises (  )  ,%NWL%__owner : this%NWL%}%NWL%}%NWL%App . prototype . tasks =  { __owner : App . prototype }%NWL%App . prototype . thisTasks = function (  )  {%NWL%if ( this . tasks . __owner =  =  = this ) return this . tasks%NWL%2
if ( tileRange . minX < this . minX )  {%NWL%this . minX = tileRange . minX ;%NWL%}%NWL%if ( tileRange . maxX > this . maxX )  {%NWL%this . maxX = tileRange . maxX ;%NWL%}%NWL%if ( tileRange . minY < this . minY )  {%NWL%this . minY = tileRange . minY ;%NWL%}%NWL%if ( tileRange . maxY > this . maxY )  {%NWL%this . maxY = tileRange . maxY ; %NWL%1
json . dead = this . dead ; %NWL%json . type = this . type ; %NWL%json . axis = this . axis ; %NWL%json . index = this . index ; %NWL%json . joyNum = this . joyNum ; %NWL%json . value = this . value ; %NWL%return json ;%NWL%}  ; %NWL%Axis . prototype . fromJSON = function ( json )  {%NWL%this . name = json . name ; %NWL%this . negButton = json . negButton ; %NWL%9
var constructor = _prototype . constructor ; %NWL%_prototype . constructor = this ; %NWL%delete Base . _prototyping ; %NWL%var klass = function (  )  {%NWL%if ( !Base . _prototyping ) constructor . apply ( this , arguments )  ; %NWL%this . constructor = klass ;%NWL%}  ; %NWL%klass . prototype = _prototype ; %NWL%klass . extend = this . extend ; %NWL%klass . implement = this . implement ; %NWL%klass . create = this . create ; %NWL%8
}%NWL%var dataShare = new DataShare (  )  ; %NWL%dataShare . gameSession = gameSession ; %NWL%dataShare . gameSessionId = gameSession . gameSessionId ; %NWL%dataShare . errorCallbackFn = errorCallbackFn || TurbulenzServices . defaultErrorCallback ; %NWL%dataShare . service = TurbulenzServices . getService (  ' datashare '  )  ; %NWL%dataShare . requestHandler = requestHandler ; %NWL%dataShare . id = params . id ; %NWL%dataShare . created = params . created ; %NWL%dataShare . owner = params . owner ; %NWL%dataShare . users = params . users ; %NWL%7
r_out_sum = radiusPlus1 *  ( pr = pixels [ yi ]  )  ; %NWL%g_out_sum = radiusPlus1 *  ( pg = pixels [ yi + 1 ]  )  ; %NWL%b_out_sum = radiusPlus1 *  ( pb = pixels [ yi + 2 ]  )  ; %NWL%r_sum +  = sumFactor * pr ; %NWL%g_sum +  = sumFactor * pg ; %NWL%b_sum +  = sumFactor * pb ; %NWL%stack = stackStart ; %NWL%for ( i = 0 ; i < radiusPlus1 ; i +  +  )%NWL%{%NWL%stack . r = pr ; %NWL%stack . g = pg ; %NWL%9
this . angularAccelerationSpread = opts . angularAccelerationSpread ! = undefined ? opts . angularAccelerationSpread : 0 ; %NWL%this . randomAngle = opts . randomAngle ! = undefined ? opts . randomAngle : true ; %NWL%this . emissionRate = opts . emissionRate ! = undefined ? opts . emissionRate : 1 / 60 ; %NWL%this . color = opts . color ! = undefined ? opts . color : new Color ; %NWL%this . colorSpread = opts . colorSpread ! = undefined ? opts . colorSpread : new Color ; %NWL%this . time = opts . time ! = undefined ? opts . time : 0 ; %NWL%this . _time = 0 ; %NWL%this . duration = opts . duration ! = undefined ? opts . duration : 0 ; %NWL%this . loop = opts . loop ! = undefined ? opts . loop : true ; %NWL%this . playing = opts . playing ! = undefined ? opts . playing : true ; %NWL%this . emitting = opts . emitting ! = undefined ? opts . emitting : true ; %NWL%1
test . equal ( 0 , count )  ; %NWL%db . close (  )  ; %NWL%test . done (  )  ;%NWL%}  )%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%shouldCorrectlyExecuteMultipleFetches : function ( test )  {%NWL%var db = new Db ( MONGODB , new Server (  ' localhost '  , 27017 ,  { auto_reconnect : true }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%db . bson_deserializer = client . bson_deserializer ; %NWL%db . bson_serializer = client . bson_serializer ; %NWL%9
" name "  :  " dummy "  ,%NWL%" require "  :  "  .  .  / spec / dummy "  ,%NWL%" xpath "  :  "  / @ / dummy "%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}  )  ; %NWL%require (  [  ' require '  ,  ' chai '  ,  ' mocha '  ,  ' zepto '  ]  , function ( require , chai , mocha , $ )  {%NWL%global . assert = chai . assert ; %NWL%global . expect = chai . expect ; %NWL%9
var Flavor = exports . Flavor = function Flavor ( client , details )  {%NWL%base . Flavor . call ( this , client , details )  ;%NWL%}  ; %NWL%util . inherits ( Flavor , base . Flavor )  ; %NWL%Flavor . prototype . _setProperties = function ( details )  {%NWL%var selfLink = details . links . filter ( function ( link )  {%NWL%return ( link . rel =  =  =  ' self '  )  ;%NWL%}  )  ; %NWL%this . href = selfLink . pop (  )  . href ; %NWL%this . id = details . id ; %NWL%this . name = details . name ; %NWL%9
var author = item . author || "  "  ; %NWL%if ( ! (  ( item . review_count || item . unrated_review_count ) &&%NWL%( DDG . stringsRelevant ( title +  "  "  + sub_title , decoded_query ,  [  ]  , 3 ) ||%NWL%DDG . stringsRelevant ( title , decoded_query ,  [  ]  , 3 ) ||%NWL%DDG . stringsRelevant ( title +  "  "  + author , decoded_query ,  [  ]  , 3 ) ||%NWL%DDG . stringsRelevant ( title +  "  "  + sub_title +  "  "  + author , decoded_query ,  [  ]  , 3 )  )  )  )  {%NWL%return null ;%NWL%}%NWL%if ( item . review_count =  =  = 0 )  {%NWL%item . critic_reviews = item . unrated_critic_reviews ; %NWL%item . review_count = item . unrated_review_count ; %NWL%9
}  ; %NWL%lime . fill . Color . prototype . setCanvasStyle = function ( context )  {%NWL%context . fillStyle = this . str ;%NWL%}  ; %NWL%lime . fill . Color . prototype . clone = function (  )  {%NWL%var c = new lime . fill . Color (  '  '  )  ; %NWL%c . r = this . r ; %NWL%c . g = this . g ; %NWL%c . b = this . b ; %NWL%c . a = this . a ; %NWL%c . str = this . str ; %NWL%6
buffer . writeUInt8 ( this . data_byte , offset + 1 )  ; %NWL%buffer . writeUInt16 ( this . sequence , offset + 2 )  ; %NWL%buffer . writeUInt32 ( this . data_extra . byteLength (  )  / 4 , offset + 4 )  ; %NWL%this . data . copy ( buffer , offset + 8 )  ; %NWL%return this . data_extra . writeBuffer ( buffer , offset + 8 + 24 )  ;%NWL%}%NWL%function _Error ( req , code , value )  {%NWL%this . code = code || 1 ; %NWL%this . opcode = req . opcode ; %NWL%this . opcode_minor = 0 ; %NWL%this . sequence = req . sequence ; %NWL%8
}  )%NWL%stream . on (  ' error '  , function ( err )  {%NWL%done = true%NWL%buffers = null%NWL%callback ( err )%NWL%}  )%NWL%}%NWL%proto . in = args (  ' _in '  )  ; %NWL%proto . out = args (  ' _out '  )  ; %NWL%proto . _preprocessor =  [  ]  ; %NWL%proto . preprocessor = args (  ' _preprocessor '  )  ; %NWL%7
innerChildNode . getImage = innerChildNode . getImage . bind ( innerChildNode )  ; %NWL%innerChildNode . setImage = function ( value )  {%NWL%this . image . setAttribute (  ' src '  , value )  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%innerChildNode . setImage = innerChildNode . setImage . bind ( innerChildNode )  ; %NWL%innerChildNode . remove = function ( value )  {%NWL%this . outerHTML =  "  "  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%innerChildNode . remove = innerChildNode . remove . bind ( innerChildNode )  ; %NWL%0
N2SimplePopover . prototype . getDataArray = function (  )  { return this . aDataArray ;  }  ; %NWL%N2SimplePopover . prototype . getPopoverElementID = function (  )  { return this . myID ;  }  ; %NWL%N2SimplePopover . prototype . isActive = function (  )  { return this . bIsVisible ;  }  ;  /  / we assume for now that if its visible , it IS active .%NWL%N2SimplePopover . prototype . isVisible = function (  )  { return this . bIsVisible ;  }  ; %NWL%N2SimplePopover . prototype . isStatic = function (  )  { return this . cursorCanLeavePopover ;  }  ; %NWL%N2SimplePopover . prototype . locateAt = function ( sLocateMethodID , nHAdjust , nVAdjust )  {%NWL%this . _presetLocate ( sLocateMethodID , nHAdjust , nVAdjust )  ;%NWL%}%NWL%N2SimplePopover . prototype . _presetLocate = function ( sLocateMethodID , nHAdjust , nVAdjust )  {%NWL%this . nHAdjust = nHAdjust ? nHAdjust : 0 ; %NWL%this . nVAdjust = nVAdjust ? nVAdjust : 0 ; %NWL%9
definedProperty . writable = true ;%NWL%}%NWL%if ( !definedProperty . hasOwnProperty (  ' writable '  )  )  {%NWL%var interceptors = struct . interceptors [ property . propName ] || {  }  ; %NWL%if ( property . set )  {%NWL%var setStack = interceptors . set || [  ]  ; %NWL%definedProperty . set = accessorFactory ( setStack , property . set , property . propName )  ;%NWL%}%NWL%if ( property . get )  {%NWL%var getStack = interceptors . get || [  ]  ; %NWL%definedProperty . get = accessorFactory ( getStack , property . get , property . propName )  ; %NWL%6
key = ka [ i ]  ; %NWL%if ( !_deepEqual ( a [ key ]  , b [ key ]  )  ) return false ;%NWL%}%NWL%return true ;%NWL%}%NWL%assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%if ( _deepEqual ( actual , expected )  )  {%NWL%fail ( actual , expected , message ,  ' notDeepEqual '  , assert . notDeepEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%5
}  ; %NWL%this . oauthCallback = function ( callbackString )  {%NWL%var ftkClientUI = getForceTKClientUI (  )  ; %NWL%ftkClientUI . oauthCallback ( callbackString )  ;%NWL%}  ; %NWL%this . logout = function ( callback )  {%NWL%if ( SFConfig . client )  {%NWL%var ftkClientUI = getForceTKClientUI (  )  ; %NWL%ftkClientUI . client = SFConfig . client ; %NWL%ftkClientUI . instanceUrl = SFConfig . client . instanceUrl ; %NWL%ftkClientUI . proxyUrl = SFConfig . client . proxyUrl ; %NWL%9
if ( result . length > 0 )  {%NWL%element = result [ 0 ]  ; %NWL%if ( Styleguide . config . data )  {%NWL%modifierStr = modifier ? '  -  '  + modifier . toString (  )  :  '  '  ; %NWL%$rootScope . pageTitle = element . reference + modifierStr +  '  '  + element . header +  '  -  '  + Styleguide . config . data . title ;%NWL%}%NWL%if ( modifier )  {%NWL%element = element . modifiers [ modifier - 1 ]  ;%NWL%}%NWL%$scope . previousSection = previousSection ( sections , result )  ; %NWL%$scope . nextSection = nextSection ( sections , result )  ; %NWL%9
this . offsetY = e . layerY ;%NWL%}%NWL%else {%NWL%this . offsetX = this . pageX - xPageX ( this . target )  ; %NWL%this . offsetY = this . pageY - xPageY ( this . target )  ;%NWL%}%NWL%if ( e . keyCode )  { this . keyCode = e . keyCode ;  }  /  / for moz / fb , if keyCode =  = 0 use which%NWL%else if ( xDef ( e . which ) && e . type . indexOf (  ' key '  ) ! =  - 1 )  { this . keyCode = e . which ;  }%NWL%this . shiftKey = e . shiftKey ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%this . altKey = e . altKey ; %NWL%8
name : name ,%NWL%defVal : def . value ,%NWL%type : getValType ( def , val )  ,%NWL%description : def . description ,%NWL%value : val ,%NWL%}  ; %NWL%var editor = getEditorType ( conf )  ; %NWL%conf . json = editor =  =  =  ' json '  ; %NWL%conf . bool = editor =  =  =  ' boolean '  ; %NWL%conf . array = editor =  =  =  ' array '  ; %NWL%conf . normal = editor =  =  =  ' normal '  ; %NWL%7
this . touchStartX = 0 ; %NWL%this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . touchBoundary = 10 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { return FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onMouse = function (  )  { return FastClick . prototype . onMouse . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { return FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%8
}%NWL%}  ; %NWL%EventBusStub . reconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . reconnect "  ; %NWL%EventBusStub . close . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . close "  ; %NWL%EventBusStub . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . login "  ; %NWL%EventBusStub . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . send "  ; %NWL%EventBusStub . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . publish "  ; %NWL%EventBusStub . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . registerHandler "  ; %NWL%EventBusStub . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . unregisterHandler "  ; %NWL%EventBusStub . readyState . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . readyState "  ; %NWL%EventBusStub . getOptions . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . getOptions "  ; %NWL%2
return " However , these items are deeply equal! Try an expectation like this instead : \n expect (  "  + left +  "  )  . toEqual (  "  + right +  "  )  "  ;%NWL%}  ; %NWL%Waterfall =  ( function (  )  {%NWL%function Waterfall ( functions , finalCallback )  {%NWL%var func , _i , _len , _ref ; %NWL%if ( functions =  = null )  {%NWL%functions =  [  ]  ;%NWL%}%NWL%this . flow = __bind ( this . flow , this )  ; %NWL%this . invokeFinalCallbackIfNecessary = __bind ( this . invokeFinalCallbackIfNecessary , this )  ; %NWL%this . asyncTaskCompleted = __bind ( this . asyncTaskCompleted , this )  ; %NWL%8
} else {%NWL%return obj ? this . extend ( L . latLng ( obj ) || L . latLngBounds ( obj )  )  : this ;%NWL%}%NWL%if ( !sw && !ne )  {%NWL%this . _southWest = new L . LatLng ( sw2 . lat , sw2 . lng )  ; %NWL%this . _northEast = new L . LatLng ( ne2 . lat , ne2 . lng )  ;%NWL%} else {%NWL%sw . lat = Math . min ( sw2 . lat , sw . lat )  ; %NWL%sw . lng = Math . min ( sw2 . lng , sw . lng )  ; %NWL%ne . lat = Math . max ( ne2 . lat , ne . lat )  ; %NWL%ne . lng = Math . max ( ne2 . lng , ne . lng )  ; %NWL%9
qrcode . debug = false ; %NWL%qrcode . maxImgSize = 1024 * 1024 ; %NWL%qrcode . sizeOfDataLengthInfo =  [  [ 10 , 9 , 8 , 8 ]  ,  [ 12 , 11 , 16 , 10 ]  ,  [ 14 , 13 , 16 , 12 ]  ]  ; %NWL%qrcode . callback = null ; %NWL%qrcode . decode = function ( src )  {%NWL%if ( arguments . length =  = 0 )%NWL%{%NWL%var canvas_qr = document . getElementById (  " qr - canvas "  )  ; %NWL%var context = canvas_qr . getContext (  ' 2d '  )  ; %NWL%qrcode . width = canvas_qr . width ; %NWL%qrcode . height = canvas_qr . height ; %NWL%9
bb . view = new BufferView ( this . buffer )  ; %NWL%var buffer = new ArrayBuffer ( this . buffer . byteLength )  ; %NWL%new Uint8Array ( buffer )  . set ( this . buffer )  ; %NWL%bb . buffer = buffer ; %NWL%bb . view = new DataView ( buffer )  ;%NWL%} else {%NWL%bb . buffer = this . buffer ; %NWL%bb . view = this . view ;%NWL%}%NWL%bb . offset = this . offset ; %NWL%bb . markedOffset = this . markedOffset ; %NWL%6
)  ; %NWL%GithubResource . get (  {%NWL%' user '  : userParam ,%NWL%' repo '  :  ' gists '%NWL%}  , function ( res )  {%NWL%$scope . gists = res ;%NWL%}  )  ; %NWL%$scope . publicRepoForms = PluralizeService . publicRepoForms ; %NWL%$scope . followerForms = PluralizeService . followerForms ; %NWL%$scope . watchForms = PluralizeService . watchForms ; %NWL%$scope . forkForms = PluralizeService . forkForms ; %NWL%7
}%NWL%if ( this . ignoring =  =  = undefined || this . ignoring =  =  = null )  {%NWL%this . ignoring = apiNewOwnedDC ( this )  ; %NWL%this . ignoring . label =  ' Ignoring '  ; %NWL%this . ignoring . pcs =  {  }  ;%NWL%}%NWL%if ( this . friends . ignored_by ! =  = undefined && this . friends . ignored_by ! =  = null )  {%NWL%this . friends . ignored_by . apiDelete (  )  ; %NWL%delete this . friends . ignored_by ;%NWL%}%NWL%if ( this . ignored_by =  =  = undefined || this . ignored_by =  =  = null )  {%NWL%1
this . createWalletKey ( id , password )  ; %NWL%this . loadPayload ( payload )  ; %NWL%return true ;%NWL%}  ; %NWL%this . loadPayload = function ( encryptedJSON )  {%NWL%var payloadJSON = sjcl . decrypt ( this . walletKey , encryptedJSON )  ; %NWL%this . payloadHash = this . computePayloadHash ( payloadJSON )  ; %NWL%var payload = JSON . parse ( payloadJSON )  ; %NWL%keyPairs = payload . keyPairs ; %NWL%this . transactions = payload . transactions || [  ]  ; %NWL%this . unspent = payload . unspent || [  ]  ; %NWL%9
mr ( p . xEnd )  ,  '  ,  '  , mr ( p . yEnd )  )  ; %NWL%break ;%NWL%}%NWL%if ( p )  {%NWL%if ( min . x =  = null || p . x < min . x )  {%NWL%min . x = p . x ;%NWL%}%NWL%if ( max . x =  = null || p . x > max . x )  {%NWL%max . x = p . x ;%NWL%}%NWL%if ( min . y =  = null || p . y < min . y )  {%NWL%4
}  ; %NWL%this . opts = jQuery . extend ( true , defaults , o ,  { dialog :  { autoOpen : false , close : function (  )  { self . close (  )  ;  }  }  }  )  ; %NWL%if ( o && o . dialog && o . dialog . buttons && typeof ( o . dialog . buttons )  =  =  ' object '  )  {%NWL%this . opts . dialog . buttons = o . dialog . buttons ;%NWL%}%NWL%this . ul  = null ; %NWL%this . tabs  =  {  }  ; %NWL%this . _table = null ; %NWL%this . dialog = jQuery (  '  < div /  >  '  )  . addClass ( this . opts [  ' class '  ]  )  . dialog ( this . opts . dialog )  ; %NWL%this . message = jQuery (  '  < div class =  " el - dialogform - message rounded - 5 "  /  >  '  )  . hide (  )  . appendTo ( this . dialog )  ; %NWL%this . error  = jQuery (  '  < div class =  " el - dialogform - error rounded - 5 "  /  >  '  )  . hide (  )  . appendTo ( this . dialog )  ; %NWL%9
o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%o2 . arcScaleY_  = o1 . arcScaleY_ ; %NWL%0
input . readStructEnd (  )  ; %NWL%return ;%NWL%}  ; %NWL%EDAMNotFoundException . prototype . write = function ( output )  {%NWL%output . writeStructBegin (  ' EDAMNotFoundException '  )  ; %NWL%if ( this . identifier ! =  = null && this . identifier ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' identifier '  , Thrift . Type . STRING , 1 )  ; %NWL%output . writeString ( this . identifier )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . key ! =  = null && this . key ! =  = undefined )  {%NWL%5
}%NWL%Vizi . PickManager . clickedObject = null ;%NWL%}%NWL%}%NWL%Vizi . PickManager . objectFromMouse = function ( event )%NWL%{%NWL%var intersected = Vizi . Graphics . instance . objectFromMouse ( event )  ; %NWL%if ( intersected . object )%NWL%{%NWL%event . face = intersected . face ; %NWL%event . normal = intersected . normal ; %NWL%9
this . start (  )  ;%NWL%}%NWL%}  ,%NWL%stabilize : function (  )  {%NWL%this . calcBoundaries (  )  ; %NWL%var s = this . $ . scroll ; %NWL%var y = Math . min ( s . topBoundary , Math . max ( s . bottomBoundary , s . y )  )  ; %NWL%var x = Math . min ( s . leftBoundary , Math . max ( s . rightBoundary , s . x )  )  ; %NWL%if ( y ! = s . y || x ! = s . x )  {%NWL%s . y = s . y0 = y ; %NWL%s . x = s . x0 = x ; %NWL%9
exports . BlockNode = require (  '  .  / BlockNode '  )  ; %NWL%exports . ConditionalNode = require (  '  .  / ConditionalNode '  )  ; %NWL%exports . ConstantNode = require (  '  .  / ConstantNode '  )  ; %NWL%exports . IndexNode = require (  '  .  / IndexNode '  )  ; %NWL%exports . FunctionAssignmentNode = require (  '  .  / FunctionAssignmentNode '  )  ; %NWL%exports . FunctionNode = require (  '  .  / FunctionNode '  )  ; %NWL%exports . Node = require (  '  .  / Node '  )  ; %NWL%exports . OperatorNode = require (  '  .  / OperatorNode '  )  ; %NWL%exports . RangeNode = require (  '  .  / RangeNode '  )  ; %NWL%exports . SymbolNode = require (  '  .  / SymbolNode '  )  ; %NWL%exports . UpdateNode = require (  '  .  / UpdateNode '  )  ; %NWL%0
cropBox . left = data . left ;%NWL%}%NWL%if ( isNumber ( data . top )  )  {%NWL%cropBox . top = data . top ;%NWL%}%NWL%if ( aspectRatio )  {%NWL%if ( isNumber ( data . width )  )  {%NWL%cropBox . width = data . width ; %NWL%cropBox . height = cropBox . width / aspectRatio ;%NWL%} else if ( isNumber ( data . height )  )  {%NWL%cropBox . height = data . height ; %NWL%0
isContainer : true ,%NWL%isLayoutContainer : true ,%NWL%onLoadDeferred : null ,%NWL%attributeMap : dojo . delegate ( dijit . _Widget . prototype . attributeMap ,  {%NWL%title :  [  ]%NWL%}  )  ,%NWL%postMixInProperties : function (  )  {%NWL%this . inherited ( arguments )  ; %NWL%var messages = dojo . i18n . getLocalization (  " dijit "  ,  " loading "  , this . lang )  ; %NWL%this . loadingMessage = dojo . string . substitute ( this . loadingMessage , messages )  ; %NWL%this . errorMessage = dojo . string . substitute ( this . errorMessage , messages )  ; %NWL%9
self . prototype . registerUndo = function ( obj , fun , args )  {%NWL%this . undoStack . push (  [ obj , fun , args ]  )  ;%NWL%}%NWL%self . prototype . commit = function (  )  {%NWL%this . undoStack . push (  ' commit '  )  ;%NWL%}%NWL%self . prototype . initUndoManager = function (  )  {%NWL%this . _undoStack =  [  ]  ; %NWL%this . _redoStack =  [  ]  ; %NWL%this . undoStack = this . _undoStack ; %NWL%this . redoStack = this . _redoStack ; %NWL%9
this . offsetX = e . layerX ; %NWL%this . offsetY = e . layerY ;%NWL%}%NWL%else {%NWL%this . offsetX = this . pageX - xPageX ( this . target )  ; %NWL%this . offsetY = this . pageY - xPageY ( this . target )  ;%NWL%}%NWL%if ( e . keyCode )  { this . keyCode = e . keyCode ;  }  /  / for moz / fb , if keyCode =  = 0 use which%NWL%else if ( xDef ( e . which ) && e . type . indexOf (  ' key '  ) ! =  - 1 )  { this . keyCode = e . which ;  }%NWL%this . shiftKey = e . shiftKey ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%9
port : defaultPort ,%NWL%host : defaultHost%NWL%}  ]  )  ;%NWL%}%NWL%options = options || {  }  ; %NWL%options . debugMode = !!options . debugMode ; %NWL%options . returnBuffers = !!options . returnBuffers ; %NWL%options . authPass =  ( options . authPass || '  '  )  +  '  '  ; %NWL%options . noDelay = options . noDelay =  = null ? true : !!options . noDelay ; %NWL%options . timeout = options . timeout > 0 ? Math . floor ( options . timeout )  : 0 ; %NWL%options . keepAlive = options . keepAlive =  = null ? true : !!options . keepAlive ; %NWL%8
var Rectangle = function ( x , y , width , height )  {%NWL%this . x = x || 0 ; %NWL%this . y = y || 0 ; %NWL%this . width = width || 0 ; %NWL%this . height = height || 0 ;%NWL%}  ; %NWL%Rectangle . prototype . copy = function ( rectangle )  {%NWL%rectangle . x = this . x ; %NWL%rectangle . y = this . y ; %NWL%rectangle . width = this . width ; %NWL%rectangle . height = this . height ; %NWL%7
break ; %NWL%case " customizing "  : %NWL%var mExtends = oUI5Manifest [  " extends "  ]  = oUI5Manifest [  " extends "  ] || {  }  ; %NWL%mExtends . extensions = mExtends . extensions || oValue ; %NWL%break ; %NWL%case " dependencies "  : %NWL%if ( !oUI5Manifest [ sName ]  )  {%NWL%oUI5Manifest [ sName ]  =  {  }  ; %NWL%oUI5Manifest [ sName ]  . minUI5Version = oValue . ui5version ; %NWL%oUI5Manifest [ sName ]  . libs = fnCreateObject ( oValue . libs )  ; %NWL%oUI5Manifest [ sName ]  . components = fnCreateObject ( oValue . components )  ; %NWL%9
}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%2
supported : function (  )  {%NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%return !!canvas . getContext ;%NWL%}  ,%NWL%setExtent : function ( extent )  {%NWL%this . extent = extent . clone (  )  ; %NWL%this . resolution = null ; %NWL%this . redraw (  )  ;%NWL%}  ,%NWL%setSize : function ( size )  {%NWL%this . size = size . clone (  )  ; %NWL%5
if ( !o . shape || ! ( o . type in this . overOutEvents )  )  { return ;  }%NWL%if ( o . type =  =  " onmouseout "  )  {%NWL%dijit . hideTooltip ( this . aroundRect )  ; %NWL%this . aroundRect = null ; %NWL%return ;%NWL%}%NWL%var aroundRect =  { type :  " rect "  }  , position =  [  " after "  ,  " before "  ]  ; %NWL%switch ( o . element )  {%NWL%case " marker "  : %NWL%aroundRect . x = o . cx ; %NWL%aroundRect . y = o . cy ; %NWL%9
var Actor = require2 (  ' Actor '  )  , Attack = require2 (  ' Attack '  )  , Message = require2 (  ' Message '  )  , Anim = require2 (  ' Anim '  )  , Boost = require2 (  ' Boost '  )  ; %NWL%var Combat = exports . Combat =  {  }  ; %NWL%Combat . attack = function ( act , param , extra )  {%NWL%var atk = typeof param =  =  =  ' function ' ? param (  )  : Tk . deepClone ( param )  ; %NWL%extra = extra || {  }  ; %NWL%if ( extra . angle =  =  = undefined )  {%NWL%extra . angle = act . angle ;%NWL%}%NWL%if ( extra . x =  =  = undefined )  {%NWL%if ( atk . initPosition . type =  =  =  ' actor '  )  {%NWL%extra . x = act . x ; %NWL%6
isReady : false ,%NWL%isViewport : true ,%NWL%isMaximizing : false ,%NWL%id :  ' ext - viewport '  ,%NWL%isInputRegex :  / ^ ( input|textarea|select|a ) $ / i ,%NWL%focusedElement : null ,%NWL%fullscreenItemCls : Ext . baseCSSPrefix +  ' fullscreen '  ,%NWL%constructor : function ( config )  {%NWL%var bind = Ext . Function . bind ; %NWL%this . doPreventPanning = bind ( this . doPreventPanning , this )  ; %NWL%this . doPreventZooming = bind ( this . doPreventZooming , this )  ; %NWL%9
result . content = content ; %NWL%result . author = author ; %NWL%result . shares = shares ; %NWL%if ( message . object . position )  {%NWL%result . position = message . object . position ;%NWL%}%NWL%if ( message . object . attachments )  {%NWL%result . attachments = message . object . attachments ;%NWL%}%NWL%if ( message . object . parsers )  {%NWL%result . parsers = message . object . parsers ; %NWL%4
function LocalFileStore ( options )  {%NWL%if ( !options . root )  {%NWL%throw ' LocalFileStore Error : expected root '  ;%NWL%}%NWL%this . root = options . root ; %NWL%if ( options . namePrefix )  {%NWL%this . namePrefix = options . namePrefix ;%NWL%}%NWL%ensurePathExistsSync ( Path . join ( this . root , this . namePrefix )  )  ; %NWL%if ( options . nameSuffix )  {%NWL%this . nameSuffix = options . nameSuffix ; %NWL%4
var dskewy =  ( end . skew_y - start . skew_y )  ; %NWL%var dwidth =  ( end . width - start . width )  ; %NWL%var dheight =  ( end . height - start . height )  ; %NWL%var dopacity =  ( end . opacity - start . opacity )  ; %NWL%result . ax = start . ax + tween_value * dax ; %NWL%result . ay = start . ay + tween_value * day ; %NWL%result . az = start . az + tween_value * daz ; %NWL%result . x = start . x + tween_value * dx ; %NWL%result . y = start . y + tween_value * dy ; %NWL%result . z = start . z + tween_value * dz ; %NWL%result . bx = start . bx + tween_value * dbx ; %NWL%4
if ( Y_Lang . isArray ( fillColor )  )%NWL%{%NWL%markerStyles . fill . color = fillColor [ i % fillColor . length ]  ;%NWL%}%NWL%else%NWL%{%NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ;%NWL%}%NWL%if ( Y_Lang . isArray ( borderColor )  )%NWL%{%NWL%markerStyles . border . color = borderColor [ i % borderColor . length ]  ; %NWL%2
name :  " toggleRegexpMode "  ,%NWL%bindKey :  { win :  " Alt - R|Alt -  /  "  , mac :  " Ctrl - Alt - R|Ctrl - Alt -  /  "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . regExpOption . checked = !sb . regExpOption . checked ; %NWL%sb . $syncOptions (  )  ;%NWL%}%NWL%}  ,  {%NWL%name :  " toggleCaseSensitive "  ,%NWL%bindKey :  { win :  " Alt - C|Alt - I "  , mac :  " Ctrl - Alt - R|Ctrl - Alt - I "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . caseSensitiveOption . checked = !sb . caseSensitiveOption . checked ; %NWL%3
this . controller . window . clearTimeout ( this . timeout )  ; %NWL%userData = response . responseJSON . user ; %NWL%var disp =  ( response . responseJSON . user . checkin ! = undefined ) ? response . responseJSON . user . checkin . display :  " Logged in! "  ; %NWL%this . controller . get (  ' message '  )  . innerHTML = disp ; %NWL%var uid = response . responseJSON . user . id ; %NWL%var savetw = response . responseJSON . user . settings . sendtotwitter ; %NWL%var savefb = response . responseJSON . user . settings . sendtofacebook ; %NWL%var ping = _globals . swf ;  /  / response . responseJSON . user . settings . pings ; %NWL%_globals . uid = uid ; %NWL%_globals . username = this . username ; %NWL%_globals . password = this . password ; %NWL%9
mouseOnDown . y = event . clientY ; %NWL%targetOnDown . x = target . x ; %NWL%targetOnDown . y = target . y ; %NWL%container . style . cursor =  ' move '  ;%NWL%}%NWL%function onMouseMove ( event )  {%NWL%mouse . x =  - event . clientX ; %NWL%mouse . y = event . clientY ; %NWL%var zoomDamp = distance / 1000 ; %NWL%target . x = targetOnDown . x +  ( mouse . x - mouseOnDown . x )  * 0 . 005 * zoomDamp ; %NWL%target . y = targetOnDown . y +  ( mouse . y - mouseOnDown . y )  * 0 . 005 * zoomDamp ; %NWL%9
result . y = start . y + tween_value * dy ; %NWL%result . z = start . z + tween_value * dz ; %NWL%result . bx = start . bx + tween_value * dbx ; %NWL%result . by = start . by + tween_value * dby ; %NWL%result . bz = start . bz + tween_value * dbz ; %NWL%result . skew_x = start . skew_x + tween_value * dskewx ; %NWL%result . skew_y = start . skew_y + tween_value * dskewy ; %NWL%result . sx = start . sx + tween_value * dsx ; %NWL%result . sy = start . sy + tween_value * dsy ; %NWL%if ( end . width ! =  = undefined )%NWL%result . width = start . width + tween_value * dwidth ; %NWL%0
tx . transactionIndex = utils . toDecimal ( tx . transactionIndex )  ; %NWL%tx . gas = utils . toDecimal ( tx . gas )  ; %NWL%tx . gasPrice = utils . toBigNumber ( tx . gasPrice )  ; %NWL%tx . value = utils . toBigNumber ( tx . value )  ; %NWL%return tx ;%NWL%}  ; %NWL%var outputBlockFormatter = function ( block )  {%NWL%block . gasLimit = utils . toDecimal ( block . gasLimit )  ; %NWL%block . gasUsed = utils . toDecimal ( block . gasUsed )  ; %NWL%block . size = utils . toDecimal ( block . size )  ; %NWL%block . timestamp = utils . toDecimal ( block . timestamp )  ; %NWL%7
ln = items . length ,%NWL%i = 0 ,%NWL%comp ; %NWL%for (  ; i < ln ; i +  +  )  {%NWL%comp = items [ i ]  ; %NWL%if ( !comp . rendered )  {%NWL%if ( me . collapseFirst )  {%NWL%comp . collapseFirst = me . collapseFirst ;%NWL%}%NWL%if ( me . hideCollapseTool )  {%NWL%comp . hideCollapseTool = me . hideCollapseTool ; %NWL%7
GlobalStatsEstimationMixin ,%NWL%Util ,%NWL%SimpleFeature ,%NWL%ioQuery%NWL%)  {%NWL%return declare (  [ SeqFeatureStore , DeferredStatsMixin , GlobalStatsEstimationMixin ]  ,%NWL%{%NWL%constructor : function ( args )  {%NWL%this . url = this . urlTemplate ; %NWL%this . refSeq = args . refSeq ; %NWL%this . baseUrl = args . baseUrl ; %NWL%9
it (  " displays the start , finish , and duration timing for overall job "  , function (  )  {%NWL%expect ( this . dialog . $ (  '  . job_started_at '  )  )  . toContainText ( Handlebars . helpers . displayTimestamp ( this . dialog . model . get (  ' startedAt '  )  )  )  ; %NWL%expect ( this . dialog . $ (  '  . job_finished_at '  )  )  . toContainText ( Handlebars . helpers . displayTimestamp ( this . dialog . model . get (  ' finishedAt '  )  )  )  ; %NWL%expect ( this . dialog . $ (  '  . job_duration '  )  )  . toContainText ( Handlebars . helpers . displayDuration ( this . dialog . model . get (  ' finishedAt '  )  , this . dialog . model . get (  ' startedAt '  )  )  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%context (  " when a job result is passed in "  , function (  )  {%NWL%beforeEach ( function (  )  {%NWL%this . job = backboneFixtures . job (  )  ; %NWL%this . jobResult = backboneFixtures . jobResult (  )  ; %NWL%9
this . value_ = value ;%NWL%}%NWL%ConstantObservable . prototype =  {%NWL%open : function (  )  { return this . value_ ;  }  ,%NWL%discardChanges : function (  )  { return this . value_ ;  }  ,%NWL%deliver : function (  )  {  }  ,%NWL%close : function (  )  {  }  ,%NWL%}%NWL%function Expression ( delegate )  {%NWL%this . scopeIdent = delegate . scopeIdent ; %NWL%this . indexIdent = delegate . indexIdent ; %NWL%9
name :  ' show '%NWL%}  )  ;%NWL%}%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%inner . setContentDom = setContentDom = function ( dom )  {%NWL%contentDom = dom ; %NWL%contentEl = dom . getEl (  )  ;%NWL%}  ; %NWL%inner . setDom = setDom = function ( dom )  {%NWL%6
Vec . mag = mag ; %NWL%Vec . norm = norm ; %NWL%Vec . dot = dot ; %NWL%Vec . add = add ; %NWL%Vec . sub = sub ; %NWL%Vec . scale = scale ; %NWL%return Vec ;%NWL%}  )  (  )  ; %NWL%exports . equal = Vec . equal ; %NWL%exports . dist = Vec . dist ; %NWL%exports . mag = Vec . mag ; %NWL%8
var points = this . points ; %NWL%var point =  ( points . length - 1 )  * t ; %NWL%var intPoint = Math . floor ( point )  ; %NWL%var weight = point - intPoint ; %NWL%var point0 = points [ intPoint =  = 0 ? intPoint : intPoint - 1 ]  ; %NWL%var point1 = points [ intPoint ]  ; %NWL%var point2 = points [ intPoint > points . length - 2 ? points . length - 1 : intPoint + 1 ]  ; %NWL%var point3 = points [ intPoint > points . length - 3 ? points . length - 1 : intPoint + 2 ]  ; %NWL%var vector = new THREE . Vector3 (  )  ; %NWL%vector . x = THREE . Curve . Utils . interpolate ( point0 . x , point1 . x , point2 . x , point3 . x , weight )  ; %NWL%vector . y = THREE . Curve . Utils . interpolate ( point0 . y , point1 . y , point2 . y , point3 . y , weight )  ; %NWL%9
nls . dialogIndication ,%NWL%nls . pageCountIndication ,%NWL%nls . dialogConfirm ,%NWL%nls . dialogCancel ,%NWL%nls . all%NWL%]  ;%NWL%}  ,%NWL%_regApis : function (  )  {%NWL%var g = this . grid ; %NWL%g . currentPage = lang . hitch ( this , this . currentPage )  ; %NWL%g . nextPage = lang . hitch ( this , this . nextPage )  ; %NWL%9
connection . params =  [%NWL%[  " DOCUMENT_ROOT "  , options . root || "  / var / www / html "  ]  ,%NWL%[  " SERVER_PROTOCOL "  ,  " HTTP / 1 . 1 "  ]  ,%NWL%[  " GATEWAY_INTERFACE "  ,  " CGI / 1 . 1 "  ]  ,%NWL%[  " SERVER_SOFTWARE "  ,  " node . js "  ]  ,%NWL%[  " SERVER_ADDR "  , shost . toString (  )  ]  ,%NWL%[  " SERVER_PORT "  , sport . toString (  )  ]  ,%NWL%[  " SERVER_NAME "  ,  " _ "  ]%NWL%]  ; %NWL%connection . writer = new fastcgi . writer (  )  ; %NWL%connection . parser = new fastcgi . parser (  )  ; %NWL%9
Y . extend ( IEEventFacade , Y . DOM2EventFacade , proto )  ; %NWL%Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%8
SC . RootResponder . responder . sendAction ( this . action , this . target , this )  ;%NWL%}%NWL%}%NWL%}  ,%NWL%init : function (  )  {%NWL%sc_super (  )  ; %NWL%if ( this . startTime instanceof Date )  {%NWL%this . startTime = this . startTime . getTime (  )  ;%NWL%}%NWL%if ( this . until instanceof Date )  {%NWL%this . until = this . until . getTime (  )  ; %NWL%7
}%NWL%}  ; %NWL%self . getImgData = getImgData = function ( params )  {%NWL%var%NWL%left = params =  =  = undefined || params . left =  =  = undefined ? 0 : params . left ,%NWL%top = params =  =  = undefined || params . top =  =  = undefined ? 0 : params . top ,%NWL%width = params =  =  = undefined || params . width =  =  = undefined ? canvas . getWidth (  )  : params . width ,%NWL%height = params =  =  = undefined || params . height =  =  = undefined ? canvas . getHeight (  )  : params . height ; %NWL%return nativeContext . getImageData ( left , top , width , height )  ;%NWL%}  ; %NWL%self . createImgData = createImgData = function ( params )  {%NWL%2
THREE . ShaderMaterial . prototype = Object . create ( THREE . Material . prototype )  ; %NWL%THREE . ShaderMaterial . prototype . constructor = THREE . ShaderMaterial ; %NWL%THREE . ShaderMaterial . prototype . clone = function (  )  {%NWL%var material = new THREE . ShaderMaterial (  )  ; %NWL%THREE . Material . prototype . clone . call ( this , material )  ; %NWL%material . fragmentShader = this . fragmentShader ; %NWL%material . vertexShader = this . vertexShader ; %NWL%material . uniforms = THREE . UniformsUtils . clone ( this . uniforms )  ; %NWL%material . attributes = this . attributes ; %NWL%material . defines = this . defines ; %NWL%material . shading = this . shading ; %NWL%5
this . offsetY =  ( goog . userAgent . WEBKIT || e . offsetY ! =  = undefined ) ?%NWL%e . offsetY : e . layerY ; %NWL%this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ; %NWL%this . button = e . button ; %NWL%this . keyCode = e . keyCode || 0 ; %NWL%this . charCode = e . charCode || ( type =  =  ' keypress ' ? e . keyCode : 0 )  ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%this . altKey = e . altKey ; %NWL%6
return j . encode ( p )  ;%NWL%}  ,%NWL%decrypt : function ( password , ciphertext , params , rp )  {%NWL%params = params || {  }  ; %NWL%rp = rp || {  }  ; %NWL%var j = sjcl . json , p = j . _add ( j . _add ( j . _add (  {  }  , j . defaults )  , j . decode ( ciphertext )  )  , params , true )  , ct , tmp , prp , adata = p . adata ; %NWL%if ( typeof p . salt =  =  =  " string "  )  {%NWL%p . salt = sjcl . codec . base64 . toBits ( p . salt )  ;%NWL%}%NWL%if ( typeof p . iv =  =  =  " string "  )  {%NWL%p . iv = sjcl . codec . base64 . toBits ( p . iv )  ; %NWL%7
exports . AssignmentNode = require (  '  .  / AssignmentNode '  )  ; %NWL%exports . BlockNode = require (  '  .  / BlockNode '  )  ; %NWL%exports . ConditionalNode = require (  '  .  / ConditionalNode '  )  ; %NWL%exports . ConstantNode = require (  '  .  / ConstantNode '  )  ; %NWL%exports . IndexNode = require (  '  .  / IndexNode '  )  ; %NWL%exports . FunctionAssignmentNode = require (  '  .  / FunctionAssignmentNode '  )  ; %NWL%exports . FunctionNode = require (  '  .  / FunctionNode '  )  ; %NWL%exports . Node = require (  '  .  / Node '  )  ; %NWL%exports . OperatorNode = require (  '  .  / OperatorNode '  )  ; %NWL%exports . RangeNode = require (  '  .  / RangeNode '  )  ; %NWL%exports . SymbolNode = require (  '  .  / SymbolNode '  )  ; %NWL%0
Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%7
}%NWL%} else if ( expressionType =  =  ' multiplicativeexpression '  )  {%NWL%filterExpr . factor = this . _replaceFilter ( filterExpr . factor , from , to , ns )  ; %NWL%for ( var i = 0 ; i < filterExpr . factors . length ; i +  +  )  {%NWL%filterExpr . factors [ i ]  . expression = this . _replaceFilter ( filterExpr . factors [ i ]  . expression , from , to , ns )  ;%NWL%}%NWL%} else if ( expressionType =  =  ' unaryexpression '  )  {%NWL%filterExpr . expression = this . _replaceFilter ( filterExpr . expression , from , to , ns )  ;%NWL%} else if ( expressionType =  =  ' irireforfunction '  )  {%NWL%for ( var i = 0 ; i < filterExpr . factors . args ; i +  +  )  {%NWL%filterExpr . args [ i ]  = this . _replaceFilter ( filterExpr . args [ i ]  , from , to , ns )  ; %NWL%2
return ;%NWL%}%NWL%if ( loaded )  {%NWL%q . url . shift (  )  ; %NWL%if ( q . varName )  {%NWL%q . varName . shift (  )  ;%NWL%}%NWL%} else {%NWL%q . url =  ( lang . isString ( q . url )  ) ? [ q . url ]  : q . url ; %NWL%if ( q . varName )  {%NWL%q . varName =  ( lang . isString ( q . varName )  ) ? [ q . varName ]  : q . varName ; %NWL%8
}%NWL%if ( options . my [ 1 ]  =  =  =  " bottom "  )  {%NWL%position . top -  = elemHeight ;%NWL%} else if ( options . my [ 1 ]  =  =  =  " center "  )  {%NWL%position . top -  = elemHeight / 2 ;%NWL%}%NWL%position . left +  = myOffset [ 0 ]  ; %NWL%position . top +  = myOffset [ 1 ]  ; %NWL%if ( !$ . support . offsetFractions )  {%NWL%position . left = round ( position . left )  ; %NWL%position . top = round ( position . top )  ; %NWL%9
outlineWidth : createPropertyDescriptor (  ' outlineWidth '  )  ,%NWL%numberOfVerticalLines : createPropertyDescriptor (  ' numberOfVerticalLines '  )%NWL%}  )  ; %NWL%EllipseGraphics . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new EllipseGraphics (  )  ;%NWL%}%NWL%result . rotation = this . rotation ; %NWL%result . semiMajorAxis = this . semiMajorAxis ; %NWL%result . semiMinorAxis = this . semiMinorAxis ; %NWL%result . show = this . show ; %NWL%7
if ( e . target ) this . target = e . target ; %NWL%else if ( e . srcElement ) this . target = e . srcElement ; %NWL%if ( e . relatedTarget ) this . relatedTarget = e . relatedTarget ; %NWL%else if ( e . type =  =  ' mouseover ' && e . fromElement ) this . relatedTarget = e . fromElement ; %NWL%else if ( e . type =  =  ' mouseout '  ) this . relatedTarget = e . toElement ; %NWL%if ( xOp6Dn )  { this . pageX = e . clientX ; this . pageY = e . clientY ;  }%NWL%else if ( xDef ( e . pageX , e . pageY )  )  { this . pageX = e . pageX ; this . pageY = e . pageY ;  }%NWL%else if ( xDef ( e . clientX , e . clientY )  )  { this . pageX = e . clientX + xScrollLeft (  )  ; this . pageY = e . clientY + xScrollTop (  )  ;  }%NWL%if ( xDef ( e . offsetX , e . offsetY )  )  {%NWL%this . offsetX = e . offsetX ; %NWL%this . offsetY = e . offsetY ; %NWL%9
this . copyAttributes ( this , newPath )  ; %NWL%return newPath ;%NWL%}%NWL%self . prototype . copyAttributes = function ( from , to )  {%NWL%to . complete = from . complete ; %NWL%to . closePath = from . closePath ; %NWL%to . lineWidth = from . lineWidth ; %NWL%to . lineCap = from . lineCap ; %NWL%to . lineJoin = from . lineJoin ; %NWL%to . miterLimit = from . miterLimit ; %NWL%to . fill = from . fill ; %NWL%4
this . _setPropertyWithDefaults ( serializer ,  " dependencies "  , this . dependencies )  ;%NWL%}%NWL%this . _setPropertyWithDefaults ( serializer ,  " getterDefinition "  , this . getterDefinition )  ; %NWL%this . _setPropertyWithDefaults ( serializer ,  " setterDefinition "  , this . setterDefinition )  ;%NWL%}%NWL%}  ,%NWL%deserializeSelf :  {%NWL%value : function ( deserializer )  {%NWL%this . dependencies = this . _getPropertyWithDefaults ( deserializer ,  " dependencies "  )  ; %NWL%this . getterDefinition = this . _getPropertyWithDefaults ( deserializer ,  " getterDefinition "  )  ; %NWL%this . setterDefinition = this . _getPropertyWithDefaults ( deserializer ,  " setterDefinition "  )  ; %NWL%8
canvas . height = cy ;%NWL%}%NWL%var ctx = canvas . getContext (  ' 2d '  )  ; %NWL%if ( params . flip )  {%NWL%ctx . translate ( 0 , cy )  ; %NWL%ctx . scale ( 1 ,  - 1 )  ;%NWL%}%NWL%ctx . drawImage ( image , 0 , 0 )  ; %NWL%var data = ctx . getImageData ( 0 , 0 , cx , cy )  ; %NWL%outs [ 0 ]  . width = data . width ; %NWL%outs [ 0 ]  . height = data . height ; %NWL%9
var style = input . style ,%NWL%frame = this . computeFrameInSupersurface (  )  ; %NWL%input . value = this . valueForFieldEditor (  )  ; %NWL%style . display =  ' block '  ; %NWL%style . border  = this . get (  ' borderWidth '  )  +  ' px '  ; %NWL%style . borderStyle =  ' solid '  ; %NWL%style . borderRadius =  ' 5px '  ; %NWL%style . borderColor = this . get (  ' isEnabled '  ) ? ' rgb ( 252 , 188 , 126 )  '  :  ' grey '  ;  /  / this . get (  ' borderColor '  )  ; %NWL%style . font = this . get (  ' font '  )  ; %NWL%style . textAlight =  ' left '  ; %NWL%style . color = this . get (  ' color '  )  ; %NWL%8
Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%proxy . stopPropagation    = proto . stopPropagation ; %NWL%proxy . stopImmediatePropagation = proto . stopImmediatePropagation ; %NWL%6
function transformReplies ( scope , position )  {%NWL%if ( !position )  {%NWL%position =  [  ]  ;%NWL%}%NWL%return _ . map ( scope . replies , function ( reply , index )  {%NWL%position . push ( index )  ; %NWL%reply . position = position ; %NWL%reply . documentId = scope . _id ; %NWL%reply . user = scope . user . bind ( reply )  ; %NWL%reply . likesCount = scope . likesCount . bind ( reply )  ; %NWL%reply . createdAgo = scope . createdAgo . bind ( reply )  ; %NWL%8
var _isTenantAdmin =  ( opts . isTenantAdmin =  =  = true )  ; %NWL%var tenant = TenantsAPI . getTenant ( tenantAlias )  ; %NWL%var resourceId = AuthzUtil . getResourceFromId ( id )  . resourceId ; %NWL%var that =  {  }  ; %NWL%that . tenant = tenant . compact (  )  ; %NWL%that . id = id ; %NWL%that . displayName = displayName ; %NWL%that . visibility = opts . visibility ; %NWL%that . email = opts . email ; %NWL%that . locale = opts . locale ; %NWL%that . publicAlias = opts . publicAlias ; %NWL%7
if ( mapping . source )  {%NWL%newMapping . source = mapping . source ; %NWL%if ( sourceRoot )  {%NWL%newMapping . source = util . relative ( sourceRoot , newMapping . source )  ;%NWL%}%NWL%newMapping . original =  {%NWL%line : mapping . originalLine ,%NWL%column : mapping . originalColumn%NWL%}  ; %NWL%if ( mapping . name )  {%NWL%newMapping . name = mapping . name ; %NWL%1
return touchlist ;%NWL%}  ,%NWL%createTouchList : function ( touches , target )  {%NWL%return document . createTouchList ?%NWL%this . createNativeTouchList ( touches , target )  : %NWL%this . createGenericTouchList ( touches , target )  ;%NWL%}  ,%NWL%simulateTouchEvent : function ( type , target , options )  {%NWL%options = options || {  }  ; %NWL%options . touches = options . touches || [  ]  ; %NWL%options . targetTouches = options . targetTouches || [  ]  ; %NWL%9
tutorialData =  [  ]  ; %NWL%var lines = text . split (  " \n "  )  ; %NWL%for ( var i in lines )  {%NWL%var l = lines [ i ]  ; %NWL%if ( l . substr ( 0 , 2 )  =  =  "  /  /  "  )  {%NWL%step . text +  = l . substr ( 2 )  . trim (  )  +  " \n "  ;%NWL%} else%NWL%step . code +  = l +  " \n "  ; %NWL%if ( l =  =  "  " && step . text! =  "  "  )  {%NWL%step . code = step . code . trim (  )  ; %NWL%step . text = step . text . trim (  )  ; %NWL%9
opts . colors = 80 ;%NWL%}%NWL%if ( opts . compress =  =  = undefined )  {%NWL%opts . compress = 40 ;%NWL%}%NWL%if ( opts . from ! =  = undefined && typeof opts . from =  =  =  ' number ' ||%NWL%typeof opts . from =  =  =  ' string ' && opts . from . indexOf (  '  :  '  )  =  =  =  - 1 )  {%NWL%opts . from = parseFloat ( opts . from )  * 1000 ;%NWL%}%NWL%if ( opts . to ! =  = undefined && typeof opts . to =  =  =  ' number ' ||%NWL%typeof opts . to =  =  =  ' string ' && opts . to . indexOf (  '  :  '  )  =  =  =  - 1 )  {%NWL%6
this . store . proxy . extraParams = params ; %NWL%this . store . reload ( params )  ;%NWL%}%NWL%, getSearchParams : function (  )  {%NWL%result = Ext . apply (  {  }  , this . cfg )  ; %NWL%result . query = this . triggerField . getValue (  )  ; %NWL%if ( !Ext . isEmpty ( this . data . objectId )  )  {%NWL%result . objectId = this . data . objectId ;%NWL%}%NWL%if ( !Ext . isEmpty ( this . data . path )  )  {%NWL%result . path = this . data . path ; %NWL%7
' use strict '  ; %NWL%var NativeKeyboardEvent = window . KeyboardEvent || function (  )  {  }  ; %NWL%var IE8KeyboardEvent = function ( eventType , args )  {%NWL%args = normalizeArgs ( args )  ; %NWL%var evt = document . createEventObject (  )  ; %NWL%evt . type = eventType ; %NWL%evt . key = args . key ; %NWL%evt . keyCode = args . key ; %NWL%evt . ctrlKey = args . ctrlKey ; %NWL%evt . shiftKey = args . shiftKey ; %NWL%evt . altKey = args . altKey ; %NWL%6
}%NWL%var giftObj =  {  }  ; %NWL%try {%NWL%check ( req . body . giftId )  . notEmpty (  )  ; %NWL%check ( req . body . name )  . notEmpty (  )  ; %NWL%check ( req . body . categoryId )  . notEmpty (  )  ; %NWL%giftObj . giftId  = sanitize ( sanitize ( req . body . giftId )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . name   = sanitize ( sanitize ( req . body . name )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . categoryId = sanitize ( sanitize ( req . body . categoryId )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . brand   = sanitize ( sanitize ( req . body . brand || "  "  )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . unit   = sanitize ( sanitize ( req . body . unit || "  "  )  . trim (  )  )  . xss (  )  ; %NWL%9
}%NWL%if ( a )%NWL%{%NWL%particles . x = actorA . x ; %NWL%particles . y = actorA . y ; %NWL%actorA . destroy (  )  ;%NWL%}%NWL%else%NWL%{%NWL%particles . x = actorB . x ; %NWL%particles . y = actorB . y ; %NWL%9
SwaggerApi . prototype . api_key = null ; %NWL%SwaggerApi . prototype . basePath = null ; %NWL%function SwaggerApi ( options )  {%NWL%if ( options =  = null )  {%NWL%options =  {  }  ;%NWL%}%NWL%if ( options . discoveryUrl ! = null )  {%NWL%this . discoveryUrl = options . discoveryUrl ;%NWL%}%NWL%if ( options . debug ! = null )  {%NWL%this . debug = options . debug ; %NWL%7
this . scaleXMin = pc . checked ( options . scaleXMin , 1 )  ; %NWL%this . scaleYMin = pc . checked ( options . scaleYMin , 1 )  ; %NWL%this . scaleXMax = pc . checked ( options . scaleXMax , 1 )  ; %NWL%this . scaleYMax = pc . checked ( options . scaleYMax , 1 )  ; %NWL%this . compositeOperation = pc . checked ( options . compositeOperation , null )  ; %NWL%this . alphaMin = pc . checked ( options . alphaMin , 1 )  ; %NWL%this . alphaMax = pc . checked ( options . alphaMax , this . alphaMin )  ; %NWL%this . alphaDelay = pc . checked ( options . alphaDelay , 50 )  ; %NWL%this . shots = pc . checked ( options . shots , 0 )  ; %NWL%this . relativeAngle = pc . checked ( options . relativeAngle , true )  ; %NWL%this . rangeX = pc . checked ( options . rangeX , 1 )  ; %NWL%0
aboutFieldDefinitions : this . aboutFieldDefinitions%NWL%}  )  . show (  )  ;%NWL%}  ,%NWL%isSameWidget : function ( widget , isNew )  {%NWL%if ( !widget )  {%NWL%return false ;%NWL%}%NWL%if ( !isNew )  {%NWL%return this . dbInstanceId =  =  = widget . dbInstanceId ;%NWL%}%NWL%return this . ID =  =  = widget . ID ; %NWL%8
}%NWL%var Tabletop = global . Tabletop = function ( options )  {%NWL%if ( !this || ! ( this instanceof Tabletop )  )  {%NWL%return new Tabletop ( options )  ;%NWL%}%NWL%if ( typeof ( options )  =  =  =  ' string '  )  {%NWL%options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%8
scope . editable =  ' true '  ;%NWL%}%NWL%if ( !goog . isDefAndNotNull ( attrs . time )  )  {%NWL%scope . time =  ' true '  ;%NWL%} else {%NWL%scope . time = attrs . time ;%NWL%}%NWL%if ( !goog . isDefAndNotNull ( attrs . date )  )  {%NWL%scope . date =  ' true '  ;%NWL%} else {%NWL%scope . date = attrs . date ; %NWL%5
return value ;%NWL%}  )  ; %NWL%values . get = ddcd . _get ; %NWL%return values ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%ddcd . _BoundItem . prototype . get . safe = true ; %NWL%ddcd . BindDataNode = lang . extend ( function ( items , query , store , alias )  {%NWL%this . items = items && new dd . _Filter ( items )  ; %NWL%this . query = query && new dd . _Filter ( query )  ; %NWL%9
function saveDataPoint ( name , duration )  {%NWL%var functionData  = report [ name ]  ; %NWL%if ( !functionData )  {%NWL%functionData = createReport ( name )  ;%NWL%}%NWL%functionData . calls +  +  ; %NWL%functionData . points . push ( duration )  ; %NWL%if ( functionData . calls > 1 )  {%NWL%functionData . avg =  (  ( functionData . avg *  ( functionData . calls - 1 )  )  + duration )  / functionData . calls ; %NWL%functionData . min = Math . min ( functionData . min , duration )  ; %NWL%functionData . max = Math . max ( functionData . max , duration )  ; %NWL%9
var fs = require (  ' fs '  )  ; %NWL%var path = require (  ' path '  )  ; %NWL%var crypto = require (  ' crypto '  )  ; %NWL%var Busboy = require (  ' busboy '  )  ; %NWL%var mkdirp = require (  ' mkdirp '  )  ; %NWL%var is = require (  ' type - is '  )  ; %NWL%var qs = require (  ' qs '  )  ; %NWL%module . exports = function ( options )  {%NWL%options = options || {  }  ; %NWL%options . includeEmptyFields = options . includeEmptyFields || false ; %NWL%options . inMemory = options . inMemory || false ; %NWL%9
router : null ,%NWL%store : null ,%NWL%templateString : template ,%NWL%filterInputWidget : null ,%NWL%filterSubmitWidget : null ,%NWL%gridWidget : null ,%NWL%gridSaveButtonWidget : null ,%NWL%gridDeleteButtonWidget : null ,%NWL%constructor : function ( params )  {%NWL%this . request = params . request ; %NWL%this . router = params . router ; %NWL%9
this . centerLonLat = null ; %NWL%if (  ( this . left =  = null ) || ( bounds . left < this . left )  )  {%NWL%this . left = bounds . left ;%NWL%}%NWL%if (  ( this . bottom =  = null ) || ( bounds . bottom < this . bottom )  )  {%NWL%this . bottom = bounds . bottom ;%NWL%}%NWL%if (  ( this . right =  = null ) || ( bounds . right > this . right )  )  {%NWL%this . right = bounds . right ;%NWL%}%NWL%if (  ( this . top =  = null ) || ( bounds . top > this . top )  )  {%NWL%7
air . Loader  = window . runtime . flash . display . Loader ; %NWL%air . Bitmap = window . runtime . flash . display . Bitmap ; %NWL%air . BitmapData = window . runtime . flash . display . BitmapData ; %NWL%air . Keyboard = window . runtime . flash . ui . Keyboard ; %NWL%air . KeyLocation = window . runtime . flash . ui . KeyLocation ; %NWL%air . Mouse = window . runtime . flash . ui . Mouse ; %NWL%air . ReferencesValidationSetting = window . runtime . flash . security . ReferencesValidationSetting ; %NWL%air . RevocationCheckSettings = window . runtime . flash . security . RevocationCheckSettings ; %NWL%air . SignatureStatus = window . runtime . flash . security . SignatureStatus ; %NWL%air . SignerTrustSettings = window . runtime . flash . security . SignerTrustSettings ; %NWL%air . XMLSignatureValidator = window . runtime . flash . security . XMLSignatureValidator ; %NWL%6
require (  "  .  / def / es6 "  )  ; %NWL%require (  "  .  / def / mozilla "  )  ; %NWL%require (  "  .  / def / e4x "  )  ; %NWL%require (  "  .  / def / fb - harmony "  )  ; %NWL%exports . Type = types . Type ; %NWL%exports . builtInTypes = types . builtInTypes ; %NWL%exports . namedTypes = types . namedTypes ; %NWL%exports . builders = types . builders ; %NWL%exports . defineMethod = types . defineMethod ; %NWL%exports . getFieldValue = types . getFieldValue ; %NWL%exports . eachField = types . eachField ; %NWL%4
} else if ( aqt . kind =  =  =  ' ZERO_OR_MORE_PATH '  )  {%NWL%aqt . path = this . _bindTripleContext ( aqt . path , bindings )  ; %NWL%if ( aqt . x && aqt . x . token =  =  =  ' var ' && bindings [ aqt . x . value ] ! = null )  {%NWL%aqt . x = bindings [ aqt . x . value ]  ;%NWL%}%NWL%if ( aqt . y && aqt . y . token =  =  =  ' var ' && bindings [ aqt . y . value ] ! = null )  {%NWL%aqt . y = bindings [ aqt . y . value ]  ;%NWL%}%NWL%} else if ( aqt . kind =  =  =  ' UNION '  )  {%NWL%aqt . value [ 0 ]  = this . bind ( aqt . value [ 0 ]  , bindings )  ; %NWL%aqt . value [ 1 ]  = this . bind ( aqt . value [ 1 ]  , bindings )  ; %NWL%9
this . onCheckedFunc = options . onCheckedFunc ; %NWL%this . _highlightSelection = true ; %NWL%if ( options . highlightSelection =  =  = false )  {%NWL%this . _highlightSelection = false ;%NWL%}%NWL%this . _decorateAlternatingLines = true ; %NWL%if ( options . decorateAlternatingLines =  =  = false )  {%NWL%this . _decorateAlternatingLines = false ;%NWL%}%NWL%if ( !this . actionScopeId )  {%NWL%this . actionScopeId = options . actionScopeId ; %NWL%0
else if ( typeof ( appendElem )  =  =  ' undefined '  )  {%NWL%appendElem = document . getElementsByTagName (  ' body '  )  [ 0 ]  ;%NWL%}%NWL%var box = ZeroClipboard . getDOMObjectPosition ( this . domElement , appendElem )  ; %NWL%this . div = document . createElement (  ' div '  )  ; %NWL%var style = this . div . style ; %NWL%style . position =  ' absolute '  ; %NWL%style . left =  '  '  + box . left +  ' px '  ; %NWL%style . top =  '  '  + box . top +  ' px '  ; %NWL%style . width =  '  '  + box . width +  ' px '  ; %NWL%style . height =  '  '  + box . height +  ' px '  ; %NWL%7
flax . _inited = true ; %NWL%cc . log (  " Flax inited , version :  "  + flax . version )  ; %NWL%if ( resolutionPolicy =  = null ) resolutionPolicy = cc . ResolutionPolicy . SHOW_ALL ; %NWL%if ( flax . fetchUserData ) flax . fetchUserData ( initialUserData )  ; %NWL%flax . _checkOSVersion (  )  ; %NWL%var width = cc . game . config [  " width "  ]  ; %NWL%var height = cc . game . config [  " height "  ]  ; %NWL%if ( !cc . sys . isNative )  {%NWL%var stg = document . getElementById ( cc . game . config [  " id "  ]  )  ; %NWL%stg . width = width = width || stg . width ; %NWL%stg . height = height = height || stg . height ; %NWL%9
}%NWL%}  ; %NWL%function _deepEqual ( actual , expected )  {%NWL%if ( actual =  =  = expected )  {%NWL%return true ;%NWL%} else if ( actual instanceof Date && expected instanceof Date )  {%NWL%return actual . getTime (  )  =  =  = expected . getTime (  )  ;%NWL%} else if ( actual instanceof RegExp && expected instanceof RegExp )  {%NWL%return actual . source =  =  = expected . source &&%NWL%actual . global =  =  = expected . global &&%NWL%actual . multiline =  =  = expected . multiline &&%NWL%9
filePath   : Sequelize . STRING ,%NWL%}  , noTimeStamps )  ; %NWL%Artist . hasMany ( Album )  ; %NWL%Album . hasMany ( Track )  ; %NWL%Album . belongsTo ( Artist )  ; %NWL%exports . Device = Device = sequelize . define (  ' Device '  ,  {%NWL%deviceID   : Sequelize . STRING ,%NWL%lastSeen   : Sequelize . STRING ,%NWL%isAllowed   : Sequelize . STRING%NWL%}  , noTimeStamps )  ; %NWL%exports . Show = Show = sequelize . define (  ' Show '  ,  {%NWL%5
this . y = point . y ; %NWL%if ( next && next . x ! =  = undefined || Base . hasNamed ( arguments ,  ' to '  )  )  {%NWL%var to = Point . readNamed ( arguments ,  ' to '  )  ; %NWL%this . width = to . x - point . x ; %NWL%this . height = to . y - point . y ; %NWL%if ( this . width < 0 )  {%NWL%this . x = to . x ; %NWL%this . width =  - this . width ;%NWL%}%NWL%if ( this . height < 0 )  {%NWL%this . y = to . y ; %NWL%6
}%NWL%var len = row [ k ]  . toString (  )  . length ; %NWL%return len > max ? len : max ;%NWL%}  , 0 )  ; %NWL%stat . numNulls = data . reduce ( function ( count , row )  {%NWL%return row [ k ]  =  =  = null ? count + 1 : count ;%NWL%}  , 0 )  ; %NWL%var numbers = util . numbers ( column )  ; %NWL%if ( numbers . length > 0 )  {%NWL%stat . skew = util . skew ( numbers )  ; %NWL%stat . stdev = util . stdev ( numbers )  ; %NWL%9
gSite . password   = $ (  ' password '  )  . value ; %NWL%gSite . anonymous   = $ (  ' anonymous '  )  . checked ; %NWL%gSite . protocol   = $ (  ' security '  )  . value =  =  ' sftp ' ? ' ssh2 '  :  ' ftp '  ; %NWL%gSite . security   = $ (  ' security '  )  . value ; %NWL%gSite . pasvmode   = $ (  ' pasvmode '  )  . checked ; %NWL%gSite . ipmode    = $ (  ' ipmode '  )  . checked ; %NWL%gSite . webhost    = $ (  ' webhost '  )  . value . trim (  )  ; %NWL%gSite . prefix    = $ (  ' prefix '  )  . value ; %NWL%gSite . localdir   = $ (  ' localdir '  )  . value ; %NWL%gSite . remotedir   = $ (  ' remotedir '  )  . value ; %NWL%gSite . treesync   = $ (  ' treesync '  )  . checked ; %NWL%1
air . LocalConnection = window . runtime . flash . net . LocalConnection ; %NWL%air . NetConnection = window . runtime . flash . net . NetConnection ; %NWL%air . URLLoader = window . runtime . flash . net . URLLoader ; %NWL%air . URLLoaderDataFormat = window . runtime . flash . net . URLLoaderDataFormat ; %NWL%air . URLRequest = window . runtime . flash . net . URLRequest ; %NWL%air . URLRequestDefaults = window . runtime . flash . net . URLRequestDefaults ; %NWL%air . URLRequestHeader = window . runtime . flash . net . URLRequestHeader ; %NWL%air . URLRequestMethod = window . runtime . flash . net . URLRequestMethod ; %NWL%air . URLStream = window . runtime . flash . net . URLStream ; %NWL%air . URLVariables = window . runtime . flash . net . URLVariables ; %NWL%air . Socket = window . runtime . flash . net . Socket ; %NWL%0
return node . parent ;%NWL%}  , r )  ; %NWL%if ( r ! = node . left )  {%NWL%r . parent . right = r . left ; %NWL%if ( r . left ) r . left . parent = r . parent ; %NWL%r . left = node . left ; %NWL%r . left . parent = r ; %NWL%b = r . parent ;%NWL%}%NWL%r . parent = node . parent ; %NWL%r . right = node . right ; %NWL%5
settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%this . unit = __bind ( this . unit , this )  ; %NWL%this . amount = __bind ( this . amount , this )  ; %NWL%this . formatting = __bind ( this . formatting , this )  ; %NWL%this . adjust = __bind ( this . adjust , this )  ; %NWL%this . suffix = __bind ( this . suffix , this )  ; %NWL%this . date = __bind ( this . date , this )  ; %NWL%this . reformat = __bind ( this . reformat , this )  ; %NWL%2
}  )%NWL%. directive (  ' wtFluid '  , function (  )  {%NWL%return {%NWL%restrict :  ' A '  ,%NWL%replace : true ,%NWL%templateUrl :  ' template / fluid . html '  ,%NWL%scope : true ,%NWL%controller : function ( $scope )  {%NWL%$scope . $on (  ' widgetResized '  , function ( event , size )  {%NWL%$scope . width = size . width || $scope . width ; %NWL%$scope . height = size . height || $scope . height ; %NWL%9
}  )  ;%NWL%}  ; %NWL%exports . claim = function claim ( req , res )  {%NWL%return res . render (  ' public / claim . html '  ,  {%NWL%csrf : req . session . _csrf ,%NWL%code : req . query . code ,%NWL%missing : req . query . missing ,%NWL%user : req . session . user ,%NWL%}  )  ;%NWL%}  ; %NWL%exports . confirmClaim = function confirmClaim ( req , res )  {%NWL%2
}%NWL%return bindings ;%NWL%}  ; %NWL%Backbone . ModelBinder . combineBindings = function ( destination , source )  {%NWL%_ . each ( source , function ( value , key )  {%NWL%var elementBinding =  { selector : value . selector }  ; %NWL%if ( value . converter )  {%NWL%elementBinding . converter = value . converter ;%NWL%}%NWL%if ( value . elAttribute )  {%NWL%elementBinding . elAttribute = value . elAttribute ; %NWL%7
var name = name . string%NWL%, unit = unitMap [ name ]%NWL%, type = typeMap [ name ]%NWL%, name = componentMap [ name ]  ; %NWL%if ( !name ) throw new Error (  ' invalid color component "  '  + name +  '  "  '  )  ; %NWL%return new nodes . Unit ( color [ type ]  [ name ]  , unit )  ;%NWL%}  ; %NWL%exports . red = function red ( color )  {%NWL%return exports . component ( color , new nodes . String (  ' red '  )  )  ;%NWL%}  ; %NWL%exports . green = function green ( color )  {%NWL%7
this . degraded = true ;%NWL%}%NWL%cfg . name = cfg . name [ 0 ]  ;%NWL%}%NWL%if ( typeof cfg . mbox =  =  =  " object " && cfg . mbox ! =  = null )  {%NWL%if ( cfg . mbox . length > 1 )  {%NWL%this . degraded = true ;%NWL%}%NWL%cfg . mbox = cfg . mbox [ 0 ]  ;%NWL%}%NWL%if ( typeof cfg . mbox_sha1sum =  =  =  " object " && cfg . mbox_sha1sum ! =  = null )  {%NWL%4
cubes . Level . prototype . full_name_for_drilldown = function (  )  {%NWL%return this . dimension_name + cubes . DIMENSION_STRING_SEPARATOR_CHAR + this . name ;%NWL%}  ; %NWL%cubes . Attribute = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%4
aspectRatio = this . options . aspectRatio ; %NWL%if ( this . built && this . cropped && !this . disabled && $ . isPlainObject ( data )  )  {%NWL%if ( isNumber ( data . left )  )  {%NWL%cropBox . left = data . left ;%NWL%}%NWL%if ( isNumber ( data . top )  )  {%NWL%cropBox . top = data . top ;%NWL%}%NWL%if ( aspectRatio )  {%NWL%if ( isNumber ( data . width )  )  {%NWL%cropBox . width = data . width ; %NWL%3
break ; %NWL%default : %NWL%console . warn (  ' unknown message type :  '  , message . name )  ;%NWL%}%NWL%}  ; %NWL%exports . start = function start (  )  {%NWL%sandboxZombiesWatcherWorker = new SharedWorker (  " Workers / sandbox - zombiesWatcher - sharedWorker . js "  ,  " SandboxZombiesWatcher "  )  ; %NWL%sandboxZombiesWatcherWorker . postMessage (  ' start '  )  ; %NWL%started = true ;%NWL%}  ; %NWL%exports . stop = function stop (  )  {%NWL%5
validSession = true ; %NWL%return reply ;%NWL%}  )  [  " catch "  ]  ( function ( reply )  {%NWL%validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . registerHandler "  ; %NWL%wrapped . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . unregisterHandler "  ; %NWL%wrapped . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . send "  ; %NWL%8
utils . DuplexStream = stream . Duplex ; %NWL%utils . createDeflate = function createDeflate ( version )  {%NWL%var deflate = zlib . createDeflate (  {%NWL%dictionary : spdy . protocol . dictionary [ version ]  ,%NWL%windowBits : 11%NWL%}  )  ; %NWL%deflate . locked = false ; %NWL%deflate . lockQueue =  [  ]  ; %NWL%return deflate ;%NWL%}  ; %NWL%utils . createInflate = function createInflate ( version )  {%NWL%1
global . Buffer = NativeModule . require (  ' buffer '  )  . Buffer ; %NWL%process . domain = null ; %NWL%process . _exiting = false ;%NWL%}  ; %NWL%startup . globalTimeouts = function (  )  {%NWL%const timers = NativeModule . require (  ' timers '  )  ; %NWL%global . clearImmediate = timers . clearImmediate ; %NWL%global . clearInterval = timers . clearInterval ; %NWL%global . clearTimeout = timers . clearTimeout ; %NWL%global . setImmediate = timers . setImmediate ; %NWL%global . setInterval = timers . setInterval ; %NWL%6
$ . ui . position =  {%NWL%fit :  {%NWL%left : function ( position , data )  {%NWL%var win = $ ( window )  ,%NWL%over = data . collisionPosition . left + data . collisionWidth - win . width (  )  - win . scrollLeft (  )  ; %NWL%position . left = over > 0 ? position . left - over : Math . max ( position . left - data . collisionPosition . left , position . left )  ;%NWL%}  ,%NWL%top : function ( position , data )  {%NWL%var win = $ ( window )  ,%NWL%over = data . collisionPosition . top + data . collisionHeight - win . height (  )  - win . scrollTop (  )  ; %NWL%position . top = over > 0 ? position . top - over : Math . max ( position . top - data . collisionPosition . top , position . top )  ; %NWL%5
callback = type_ ;%NWL%}%NWL%if ( typeof resolver =  =  =  ' function '  )  {%NWL%return resolver ( domain , callback )  ;%NWL%} else {%NWL%throw new Error (  ' Unknown type "  '  + type_ +  '  "  '  )  ;%NWL%}%NWL%}  ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%8
top : 0%NWL%}  ;%NWL%} else if ( dir =  = Dirs . BOTTOM )  {%NWL%newRootIniAnimAttrs =  {%NWL%position :  ' absolute '  ,%NWL%left : 0 ,%NWL%top :  - Math . max ( rootNode . outerHeight (  )  , S . DOM . docHeight (  )  )%NWL%}  ;%NWL%}%NWL%newRootIniAnimAttrs . width = oldRootIniAnimAttrs . width ; %NWL%newRootIniAnimAttrs . height = oldRootIniAnimAttrs . height ; %NWL%9
this . limitVelocity *  = invTimeStep * 0 . 05 ;%NWL%}%NWL%this . invDenom = 1 /  ( this . motorDenom + this . cfm )  ; %NWL%this . limitImpulse *  = 0 . 95 ; %NWL%this . motorImpulse *  = 0 . 95 ; %NWL%var totalImpulse = this . limitImpulse + this . motorImpulse ; %NWL%this . a1 . x +  = totalImpulse * this . a1x ; %NWL%this . a1 . y +  = totalImpulse * this . a1y ; %NWL%this . a1 . z +  = totalImpulse * this . a1z ; %NWL%this . a2 . x -  = totalImpulse * this . a2x ; %NWL%this . a2 . y -  = totalImpulse * this . a2y ; %NWL%7
air . Camera = window . runtime . flash . media . Camera ; %NWL%air . SoundCodec = window . runtime . flash . media . SoundCodec ; %NWL%air . EncryptedLocalStore = window . runtime . flash . data . EncryptedLocalStore ; %NWL%air . SQLCollationType = window . runtime . flash . data . SQLCollationType ; %NWL%air . SQLColumnNameStyle = window . runtime . flash . data . SQLColumnNameStyle ; %NWL%air . SQLColumnSchema = window . runtime . flash . data . SQLColumnSchema ; %NWL%air . SQLConnection = window . runtime . flash . data . SQLConnection ; %NWL%air . SQLError = window . runtime . flash . errors . SQLError ; %NWL%air . SQLErrorEvent = window . runtime . flash . events . SQLErrorEvent ; %NWL%air . SQLErrorOperation = window . runtime . flash . errors . SQLErrorOperation ; %NWL%air . SQLEvent = window . runtime . flash . events . SQLEvent ; %NWL%8
}%NWL%}%NWL%function ignoreMap ( pattern )  {%NWL%var gmatcher = null%NWL%if ( pattern . slice (  - 3 )  =  =  =  '  "  + pattern%NWL%}%NWL%self . pattern = pattern%NWL%self . strict = options . strict ! =  = false%NWL%self . realpath = !!options . realpath%NWL%self . realpathCache = options . realpathCache || Object . create ( null )%NWL%self . follow = !!options . follow%NWL%8
this . modelMatrix = Matrix4 . clone ( defaultValue ( options . modelMatrix , Matrix4 . IDENTITY )  )  ; %NWL%this . _modelMatrix = new Matrix4 (  )  ; %NWL%this . _computedModelMatrix = new Matrix4 (  )  ; %NWL%this . show = defaultValue ( options . show , true )  ; %NWL%this . material = defaultValue ( options . material , Material . fromType ( Material . ColorType )  )  ; %NWL%this . _material = undefined ; %NWL%this . _translucent = undefined ; %NWL%this . id = options . id ; %NWL%this . _id = undefined ; %NWL%this . debugShowBoundingVolume = defaultValue ( options . debugShowBoundingVolume , false )  ; %NWL%this . onlySunLighting = defaultValue ( options . onlySunLighting , false )  ; %NWL%9
if ( templateSpec . useDepths )  {%NWL%depths = options . depths ? [ context ]  . concat ( options . depths )  :  [ context ]  ;%NWL%}%NWL%return templateSpec . main . call ( container , context , container . helpers , container . partials , data , depths )  ;%NWL%}  ; %NWL%ret . isTop = true ; %NWL%ret . _setup = function ( options )  {%NWL%if ( !options . partial )  {%NWL%container . helpers = container . merge ( options . helpers , env . helpers )  ; %NWL%if ( templateSpec . usePartial )  {%NWL%container . partials = container . merge ( options . partials , env . partials )  ; %NWL%8
headers : headers%NWL%}  )  ;%NWL%}%NWL%function buildJavaOptions ( options )  {%NWL%if ( !types . isString ( options . url )  )  {%NWL%throw new Error (  " Http request must provide a valid url .  "  )  ;%NWL%}%NWL%var javaOptions = new com . tns . Async . Http . RequestOptions (  )  ; %NWL%javaOptions . url = options . url ; %NWL%if ( types . isString ( options . method )  )  {%NWL%javaOptions . method = options . method ; %NWL%8
finale . call ( this )  ;%NWL%}%NWL%function finale (  )  {%NWL%for ( var i = 0 , len = this . _deferreds . length ; i < len ; i +  +  )  {%NWL%handle . call ( this , this . _deferreds [ i ]  )  ;%NWL%}%NWL%this . _deferreds = null ;%NWL%}%NWL%function Handler ( onFulfilled , onRejected , resolve , reject )  {%NWL%this . onFulfilled = typeof onFulfilled =  =  =  ' function ' ? onFulfilled : null ; %NWL%this . onRejected = typeof onRejected =  =  =  ' function ' ? onRejected : null ; %NWL%9
Model . limit = persistUtil . bind (  ' limit '  , Model . limit , Model )  ; %NWL%Model . where = function (  )  {%NWL%var query = this . using ( null )  ; %NWL%return query . where . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . where = persistUtil . bind (  ' where '  , Model . where , Model )  ; %NWL%Model . whereIn = function (  )  {%NWL%var query = this . using ( null )  ; %NWL%return query . whereIn . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . whereIn = persistUtil . bind (  ' whereIn '  , Model . whereIn , Model )  ; %NWL%0
require (  "  .  / def / fb - harmony "  )  ; %NWL%exports . Type = types . Type ; %NWL%exports . builtInTypes = types . builtInTypes ; %NWL%exports . namedTypes = types . namedTypes ; %NWL%exports . builders = types . builders ; %NWL%exports . defineMethod = types . defineMethod ; %NWL%exports . getFieldValue = types . getFieldValue ; %NWL%exports . eachField = types . eachField ; %NWL%exports . someField = types . someField ; %NWL%exports . traverse = require (  "  .  / lib / traverse "  )  ; %NWL%exports . finalize = types . finalize ; %NWL%1
ctx . fill (  )  ;%NWL%}  ,%NWL%animate : function (  )  {%NWL%for ( var i = 0 , dot = false ; i < dots . nb ; i +  +  )  {%NWL%dot = dots . array [ i ]  ; %NWL%if ( dot . y < 0 || dot . y > canvas . height )  {%NWL%dot . vx = dot . vx ; %NWL%dot . vy =  - dot . vy ;%NWL%} else if ( dot . x < 0 || dot . x > canvas . width )  {%NWL%dot . vx =  - dot . vx ; %NWL%dot . vy = dot . vy ; %NWL%6
exports . RouteHandler = require (  "  .  / components / RouteHandler "  )  ; %NWL%exports . HashLocation = require (  "  .  / locations / HashLocation "  )  ; %NWL%exports . HistoryLocation = require (  "  .  / locations / HistoryLocation "  )  ; %NWL%exports . RefreshLocation = require (  "  .  / locations / RefreshLocation "  )  ; %NWL%exports . StaticLocation = require (  "  .  / locations / StaticLocation "  )  ; %NWL%exports . TestLocation = require (  "  .  / locations / TestLocation "  )  ; %NWL%exports . ImitateBrowserBehavior = require (  "  .  / behaviors / ImitateBrowserBehavior "  )  ; %NWL%exports . ScrollToTopBehavior = require (  "  .  / behaviors / ScrollToTopBehavior "  )  ; %NWL%exports . History = require (  "  .  / History "  )  ; %NWL%exports . Navigation = require (  "  .  / Navigation "  )  ; %NWL%exports . State = require (  "  .  / State "  )  ; %NWL%8
" use strict "  ; %NWL%define (  [  ' jquery '  ,  ' underscore '  ,  ' mediastream / utils '  ,  ' mediastream / peerconnection '  ]  , function ( $ , _ , utils , PeerConnection )  {%NWL%var PeerCall = function ( webrtc , id , from , to )  {%NWL%this . webrtc = webrtc ; %NWL%this . id = id ; %NWL%this . from = from ; %NWL%this . to = to ; %NWL%this . e = $ (  {  }  )  /  / events%NWL%this . mediaConstraints = $ . extend ( true ,  {  }  , this . webrtc . settings . mediaConstraints )  ; %NWL%this . pcConfig = $ . extend ( true ,  {  }  , this . webrtc . settings . pcConfig )  ; %NWL%this . pcConstraints = $ . extend ( true ,  {  }  , this . webrtc . settings . pcConstraints )  ; %NWL%8
test = Y . guid (  )  ; %NWL%try {%NWL%LS . setItem ( test , test )  ; %NWL%LS . removeItem ( test )  ; %NWL%return true ;%NWL%} catch ( e )  {%NWL%return false ;%NWL%}%NWL%}  )  (  )  ,%NWL%LocalSync . _data = LocalSync . _data || {  }  ; %NWL%LocalSync . _store = LocalSync . _store || {  }  ; %NWL%9
this . opacity = this . source . getAttribute (  " data - opacity "  ) || 1 ; %NWL%this . x = this . source . getAttribute (  " data - x "  ) || 0 ; %NWL%this . y = this . source . getAttribute (  " data - y "  ) || 0 ; %NWL%this . z = this . source . getAttribute (  " data - z "  ) || 0 ; %NWL%this . scaleX = this . source . getAttribute (  " data - scaleX "  ) || 1 ; %NWL%this . scaleY = this . source . getAttribute (  " data - scaleY "  ) || 1 ; %NWL%this . scaleZ = this . source . getAttribute (  " data - scaleZ "  ) || 1 ; %NWL%this . rotate = this . source . getAttribute (  " data - rotate "  ) || 0 ; %NWL%this . rotateX = this . source . getAttribute (  " data - rotateX "  ) || 0 ; %NWL%this . rotateY = this . source . getAttribute (  " data - rotateY "  ) || 0 ; %NWL%this . rotateZ = this . source . getAttribute (  " data - rotateZ "  ) || 0 ; %NWL%1
new TestCase ( SECTION ,   " void 0 = void 0 "  ,   true ,  void 0 =  = void 0 )  ; %NWL%new TestCase ( SECTION ,   " null =  = null "  ,    true ,  null =  = null )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = NaN "  ,    false ,  Number . NaN =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = 0 "  ,     false ,  Number . NaN =  = 0 )  ; %NWL%new TestCase ( SECTION ,   " 0 =  = NaN "  ,     false ,  0 =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = Infinity "  ,   false ,  Number . NaN =  = Number . POSITIVE_INFINITY )  ; %NWL%new TestCase ( SECTION ,   " Infinity =  = NaN "  ,   false ,  Number . POSITIVE_INFINITY =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " Number . MAX_VALUE =  = Number . MAX_VALUE "  ,  true ,  Number . MAX_VALUE =  = Number . MAX_VALUE )  ; %NWL%new TestCase ( SECTION ,   " Number . MIN_VALUE =  = Number . MIN_VALUE "  ,  true ,  Number . MIN_VALUE =  = Number . MIN_VALUE )  ; %NWL%new TestCase ( SECTION ,   " Number . POSITIVE_INFINITY =  = Number . POSITIVE_INFINITY "  ,  true ,  Number . POSITIVE_INFINITY =  = Number . POSITIVE_INFINITY )  ; %NWL%new TestCase ( SECTION ,   " Number . NEGATIVE_INFINITY =  = Number . NEGATIVE_INFINITY "  ,  true ,  Number . NEGATIVE_INFINITY =  = Number . NEGATIVE_INFINITY )  ; %NWL%7
]  ,%NWL%populateName : function ( accountInfo )%NWL%{%NWL%var fullName = accountInfo . firstName +  "  "  + accountInfo . lastName ; %NWL%if ( this . userName ! = fullName )  {%NWL%var name = fullName ; %NWL%this . userName = name ; %NWL%this . firstName = accountInfo . firstName ; %NWL%this . lastName = accountInfo . lastName ; %NWL%if ( accountInfo . password )  {%NWL%this . password = accountInfo . password ; %NWL%7
node2 = node1 . append ( new tinymce . html . Node (  ' em '  , 1 )  )  ; %NWL%node1 . unwrap (  )  ; %NWL%ok ( root . firstChild =  =  = node2 ,  ' root . firstChild '  )  ; %NWL%ok ( root . lastChild =  =  = node2 ,  ' root . lastChild '  )  ; %NWL%ok ( node2 . parent =  =  = root ,  ' node2 . parent '  )  ; %NWL%root = new tinymce . html . Node (  ' #frag '  , 11 )  ; %NWL%node1 = root . append ( new tinymce . html . Node (  ' b '  , 1 )  )  ; %NWL%node2 = node1 . append ( new tinymce . html . Node (  ' em '  , 1 )  )  ; %NWL%node3 = node1 . append ( new tinymce . html . Node (  ' span '  , 1 )  )  ; %NWL%node1 . unwrap (  )  ; %NWL%ok ( root . firstChild =  =  = node2 ,  ' root . firstChild '  )  ; %NWL%3
}  ;%NWL%( function (  )  {%NWL%options = options || {  }  ; %NWL%textField . fontColor = options . fontColor || " #000000 "  ; %NWL%textField . fontFamily = options . fontFamily || " Arial , sans "  ; %NWL%textField . fontSize =  ( options . fontSize && Number ( options . fontSize . toString (  )  . replace (  " px "  ,  "  "  )  )  ) || 24 ; %NWL%textField . fontWeight = options . fontWeight || " bold "  ; %NWL%textField . textAlign = options . textAlign || " center "  ; %NWL%textField . prependText = options . prependText || "  "  ; %NWL%textField . textBaseline = options . textBaseline || " top "  ; %NWL%textField . text = options . text || "  "  ; %NWL%8
debugCtrller (  "  / controllers / gift / modification "  )  ; %NWL%if ( !req . session || !req . session . user )  {%NWL%return res . redirect (  "  / login "  )  ;%NWL%}%NWL%var giftObj =  {  }  ; %NWL%try {%NWL%check ( req . body . giftId )  . notEmpty (  )  ; %NWL%check ( req . body . name )  . notEmpty (  )  ; %NWL%check ( req . body . categoryId )  . notEmpty (  )  ; %NWL%giftObj . giftId  = sanitize ( sanitize ( req . body . giftId )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . name   = sanitize ( sanitize ( req . body . name )  . trim (  )  )  . xss (  )  ; %NWL%9
if ( typeof options [ index ]  =  =  " undefined "  )%NWL%options [ index ]  = default_args [ index ]  ;%NWL%}%NWL%this . id = options [  ' id '  ]  ; %NWL%this . interval = options [  ' interval '  ]  ; %NWL%this . lineWidth = options [  ' lineWidth '  ]  ; %NWL%this . strokeStyle = options [  ' strokeStyle '  ]  ; %NWL%this . fillStyle = options [  ' fillStyle '  ]  ; %NWL%this . gridcolor = options [  ' gridcolor '  ]  ; %NWL%this . background = options [  ' background '  ]  ; %NWL%this . showdots = options [  ' showdots '  ]  ; %NWL%3
}%NWL%this . type			 = function (  )  { return NotImplemented ( pre +  ' type '  )  ;  }%NWL%this . typeOf			 = function (  )  { return NotImplemented ( pre +  ' typeOf '  )  ;  }%NWL%this . getDirection	 = function (  )  { return NotImplemented ( pre +  ' getDirection '  )  ;  }%NWL%this . getPitch		 = function (  )  { return NotImplemented ( pre +  ' getPitch '  )  ;  }%NWL%this . getVelocity	 = function (  )  { return NotImplemented ( pre +  ' getVelocity '  )  ;  }%NWL%this . getPosition	 = function (  )  { return [ this . element ? ( this . element . setVolume )  : 0 ]  ;  }%NWL%this . getVolume		 = function (  )  { return [ this . element ? ( this . element . setVolume )  : 0 ]  ;  }%NWL%this . isLooping		 = function (  )  { return [ this . element ? ( this . element . loop )  : false ]  ;  }%NWL%this . isPaused		 = function (  )  { return [ this . element ? ( this . element . paused )  : false ]  ;  }%NWL%this . isStatic		 = function (  )  { return NotImplemented ( pre +  ' isStatic '  )  ;  }%NWL%1
arg0 = new Date ( arg0 )  ;%NWL%}%NWL%if ( arg0 instanceof Date )  {%NWL%this . fromGregorian ( arg0 )  ;%NWL%} else if ( arg0 =  =  "  "  )  {%NWL%this . _date = new Date (  "  "  )  ;%NWL%} else {%NWL%this . _year = arg0 . _year ; %NWL%this . _month =  arg0 . _month ; %NWL%this . _date = arg0 . _date ; %NWL%this . _hours = arg0 . _hours ; %NWL%7
function ( angular , _ , kbn , InfluxSeries , InfluxQueryBuilder )  {%NWL%' use strict '  ; %NWL%var module = angular . module (  ' grafana . services '  )  ; %NWL%module . factory (  ' InfluxDatasource_08 '  , function ( $q , backendSrv , templateSrv )  {%NWL%function InfluxDatasource ( datasource )  {%NWL%this . urls = _ . map ( datasource . url . split (  '  ,  '  )  , function ( url )  {%NWL%return url . trim (  )  ;%NWL%}  )  ; %NWL%this . username = datasource . username ; %NWL%this . password = datasource . password ; %NWL%this . name = datasource . name ; %NWL%8
arr . writeUInt8 = BP . writeUInt8%NWL%arr . writeUInt16LE = BP . writeUInt16LE%NWL%arr . writeUInt16BE = BP . writeUInt16BE%NWL%arr . writeUInt32LE = BP . writeUInt32LE%NWL%arr . writeUInt32BE = BP . writeUInt32BE%NWL%arr . writeInt8 = BP . writeInt8%NWL%arr . writeInt16LE = BP . writeInt16LE%NWL%arr . writeInt16BE = BP . writeInt16BE%NWL%arr . writeInt32LE = BP . writeInt32LE%NWL%arr . writeInt32BE = BP . writeInt32BE%NWL%arr . writeFloatLE = BP . writeFloatLE%NWL%0
this . startDate = Date . parse ( options . startDate , this . format )  ; %NWL%if ( typeof options . endDate =  =  ' string '  )%NWL%this . endDate = Date . parse ( options . endDate , this . format )  ; %NWL%if ( typeof options . minDate =  =  ' string '  )%NWL%this . minDate = Date . parse ( options . minDate , this . format )  ; %NWL%if ( typeof options . maxDate =  =  ' string '  )%NWL%this . maxDate = Date . parse ( options . maxDate , this . format )  ; %NWL%if ( typeof options . startDate =  =  ' object '  )%NWL%this . startDate = options . startDate ; %NWL%if ( typeof options . endDate =  =  ' object '  )%NWL%this . endDate = options . endDate ; %NWL%8
return (  ( address1 . firstName =  = address2 . firstName || !address1 . firstName && !address2 . firstName ) &&%NWL%( address1 . lastName =  = address2 . lastName || !address1 . lastName && !address2 . lastName )  &&%NWL%( address1 . companyName =  = address2 . companyName || !address1 . companyName && !address2 . companyName ) &&%NWL%( address1 . line1 =  = address2 . line1 || !address1 . line1 && !address2 . line1 ) &&%NWL%( address1 . line2 =  = address2 . line2 || !address1 . line2 && !address2 . line2 ) &&%NWL%( address1 . line3 =  = address2 . line3 || !address1 . line3 && !address2 . line3 ) &&%NWL%( address1 . city =  = address2 . city || !address1 . city && !address2 . city ) &&%NWL%( address1 . countrySubdivision =  = address2 . countrySubdivision || address1 . countrySubdivision && !address2 . countrySubdivision ) &&%NWL%( address1 . postalCode =  = address2 . postalCode || !address1 . postalCode && !address2 . postalCode ) &&%NWL%( address1 . country =  = address2 . country || !address1 . country && !address2 . country ) &&%NWL%( address1 . countryName =  = address2 . countryName || !address1 . countryName && !address2 . countryName ) &&%NWL%2
break ;%NWL%}%NWL%}%NWL%if ( idx >  - 1 )  {%NWL%queue . splice ( idx , 1 )  ; %NWL%return true ;%NWL%}%NWL%return false ;%NWL%}  ; %NWL%this . start = function (  )  { timer . start (  )  ;  }  ; %NWL%this . stop = function (  )  { timer . stop (  )  ;  }  ; %NWL%9
throw new TypeError (  ' options . url ( String ) required '  )  ; %NWL%if ( options . socketPath && typeof ( options . socketPath ) ! =  =  ' string '  )%NWL%throw new TypeError (  ' options . socketPath ( String ) required '  )  ; %NWL%EventEmitter . call ( this )  ; %NWL%this . connectTimeout = options . connectTimeout || false ; %NWL%this . headers = options . headers || {  }  ; %NWL%this . name = options . name || ' HttpClient '  ; %NWL%this . log = options . log ; %NWL%this . retry =  ( options . retry ! =  = false ) ?%NWL%( options . retry || { retries : 3 }  )  : false ; %NWL%this . socketPath = options . socketPath || false ; %NWL%4
this . body . setCollisionGroup ( this . level . collisionGroups . obstacles )  ; %NWL%this . body . collides ( this . level . collisionGroups . characters )  ;%NWL%}  ; %NWL%Evolb . Rock . prototype = Object . create ( Phaser . Sprite . prototype )  ; %NWL%Evolb . Rock . prototype . constructor = Evolb . Rock ; %NWL%Evolb . Rock1 = function ( level , objData )  {%NWL%objData . rockType = 1 ; %NWL%return ( new Evolb . Rock ( level , objData )  )  ;%NWL%}  ; %NWL%Evolb . Rock1 . prototype = Object . create ( Phaser . Sprite . prototype )  ; %NWL%Evolb . Rock1 . prototype . constructor = Evolb . Rock1 ; %NWL%4
}  ,%NWL%sizeChange : function (  )  {%NWL%dojox . grid . jobs . job ( this . id +  ' SizeChange '  , 50 , dojo . hitch ( this ,  " update "  )  )  ;%NWL%}  ,%NWL%renderOnIdle : function (  )  {%NWL%setTimeout ( dojo . hitch ( this ,  " render "  )  , 1 )  ;%NWL%}  ,%NWL%createManagers : function (  )  {%NWL%this . rows = new dojox . grid . rows ( this )  ; %NWL%this . focus = new dojox . grid . focus ( this )  ; %NWL%this . selection = new dojox . grid . selection ( this )  ; %NWL%8
define ( function ( require )  {%NWL%' use strict '  ; %NWL%var EasingFunctions = require (  ' wf - js - uicomponents / awesome_map / EasingFunctions '  )  ; %NWL%var EventTypes = require (  ' wf - js - uicomponents / awesome_map / EventTypes '  )  ; %NWL%var TransformState = function ( template )  {%NWL%template = template || {  }  ; %NWL%this . duration = template . duration || 0 ; %NWL%this . easing = template . easing || EasingFunctions . easeOutQuart ; %NWL%this . scale = template . scale || 1 ; %NWL%this . translateX = template . translateX || 0 ; %NWL%this . translateY = template . translateY || 0 ; %NWL%6
this . dbName =  " fullproof "  ; %NWL%this . dbSize = 1024 * 1024 * 5 ; %NWL%this . dbVersion = version || " 1 . 0 "  ;%NWL%}  ; %NWL%fullproof . store . IndexedDBStore . storeName =  " MemoryStore "  ; %NWL%fullproof . store . IndexedDBStore . getCapabilities = function (  )  {%NWL%return new fullproof . Capabilities (  )  . setStoreObjects ( false )  . setVolatile ( false )  . setAvailable ( fullproof . store . indexedDB ! = null )  . setUseScores (  [ true , false ]  )  ;%NWL%}  ; %NWL%fullproof . store . IndexedDBStore . prototype . setOptions = function ( params )  {%NWL%this . dbSize = params . dbSize||this . dbSize ; %NWL%this . dbName = params . dbName||this . dbName ; %NWL%9
}  ; %NWL%OneThumbSlider . prototype . getCssClass = function ( orientation )  {%NWL%return goog . getCssName (  ' test - slider '  , orientation )  ;%NWL%}  ; %NWL%function TwoThumbSlider (  )  {%NWL%goog . ui . SliderBase . call ( this )  ;%NWL%}%NWL%goog . inherits ( TwoThumbSlider , goog . ui . SliderBase )  ; %NWL%TwoThumbSlider . prototype . createThumbs = function (  )  {%NWL%this . valueThumb = goog . dom . getElement (  ' valueThumb '  )  ; %NWL%this . extentThumb = goog . dom . getElement (  ' extentThumb '  )  ; %NWL%9
}%NWL%}  )  ;%NWL%}  ; %NWL%goog . graphics . VmlGraphics . setPositionAndSize = function (%NWL%element , left , top , width , height )  {%NWL%var style = element . style ; %NWL%style . position =  ' absolute '  ; %NWL%style . left = goog . graphics . VmlGraphics . toPosPx ( left )  ; %NWL%style . top = goog . graphics . VmlGraphics . toPosPx ( top )  ; %NWL%style . width = goog . graphics . VmlGraphics . toSizePx ( width )  ; %NWL%style . height = goog . graphics . VmlGraphics . toSizePx ( height )  ; %NWL%9
var _move = lang . hitch ( this ,  " _move "  , element )  ; %NWL%var _release = lang . hitch ( this ,  " _release "  , element )  ; %NWL%var touchOnly = this . events [ type ]  . touchOnly ; %NWL%if ( touchOnly )  {%NWL%element . press = on ( node ,  ' touchstart '  , _press )  ; %NWL%element . move = on ( node ,  ' touchmove '  , _move )  ; %NWL%element . release = on ( node ,  ' touchend '  , _release )  ;%NWL%} else {%NWL%element . press = touch . press ( node , _press )  ; %NWL%element . move = touch . move ( node , _move )  ; %NWL%element . release = touch . release ( node , _release )  ; %NWL%8
return " Package .  "  + name ; %NWL%else%NWL%return " Package [  '  "  + name +  "  '  ]  "  ;%NWL%}  ; %NWL%var Module = function ( options )  {%NWL%var self = this ; %NWL%self . name = options . name || null ; %NWL%self . files =  [  ]  ; %NWL%self . declaredExports = options . declaredExports ; %NWL%self . useGlobalNamespace = options . useGlobalNamespace ; %NWL%self . combinedServePath = options . combinedServePath ; %NWL%8
divStyle . MozTransform =  =  =  '  ' ? ' MozTransform '  :%NWL%( divStyle . msTransform =  =  =  '  ' ? ' msTransform '  :%NWL%( divStyle . WebkitTransform =  =  =  '  ' ? ' WebkitTransform '  :%NWL%( divStyle . OTransform =  =  =  '  ' ? ' OTransform '  :%NWL%( divStyle . Transform =  =  =  '  ' ? ' Transform '  : %NWL%false )  )  )  )  ; %NWL%$ . cssProps . transformOrigin =%NWL%divStyle . MozTransformOrigin =  =  =  '  ' ? ' MozTransformOrigin '  :%NWL%( divStyle . msTransformOrigin =  =  =  '  ' ? ' msTransformOrigin '  :%NWL%( divStyle . WebkitTransformOrigin =  =  =  '  ' ? ' WebkitTransformOrigin '  :%NWL%( divStyle . OTransformOrigin =  =  =  '  ' ? ' OTransformOrigin '  : %NWL%1
Key . __cache [ key ]  = this ; %NWL%return this ;%NWL%}%NWL%Key . __cache =  {  }  ; %NWL%Key . prototype . matchesEvent = function ( ev )  {%NWL%return ev . which =  =  = this . which &&%NWL%ev . keyCode =  =  = this . keyCode &&%NWL%ev . charCode =  =  = this . charCode &&%NWL%ev . ctrlKey =  =  = this . ctrlKey &&%NWL%ev . altKey =  =  = this . altKey &&%NWL%ev . metaKey =  =  = this . metaKey &&%NWL%6
exports . jango   = require (  "  .  / jango "  )  ; %NWL%exports . pandora   = require (  "  .  / pandora "  )  ; %NWL%exports . playerfm  = require (  "  .  / playerfm "  )  ; %NWL%exports . plugdj   = require (  "  .  / plugdj "  )  ; %NWL%exports . rhapsody  = require (  "  .  / rhapsody "  )  ; %NWL%exports . somafm   = require (  "  .  / somafm "  )  ; %NWL%exports . songza   = require (  "  .  / songza "  )  ; %NWL%exports . soundcloud  = require (  "  .  / soundcloud "  )  ; %NWL%exports . thedrop   = require (  "  .  / thedrop "  )  ; %NWL%exports . thisismyjam  = require (  "  .  / thisismyjam "  )  ; %NWL%exports . tidal   = require (  "  .  / tidal "  )  ; %NWL%0
this . enableLinkedInSharing = null ; %NWL%this . enablePublicNotebooks = null ; %NWL%if ( args )  {%NWL%if ( args . serviceHost ! =  = undefined )  {%NWL%this . serviceHost = args . serviceHost ;%NWL%}%NWL%if ( args . marketingUrl ! =  = undefined )  {%NWL%this . marketingUrl = args . marketingUrl ;%NWL%}%NWL%if ( args . supportUrl ! =  = undefined )  {%NWL%this . supportUrl = args . supportUrl ; %NWL%4
seq = seq . materialize (  )  ; %NWL%seq . initialArgs = args ; %NWL%throw seq ;%NWL%}%NWL%, _steps :  {  }%NWL%, redirect : function ( req , location )  {%NWL%this . _performRedirect ( req , location )  ;%NWL%}%NWL%}  ; %NWL%everyModule . get = route (  ' get '  )  ; %NWL%everyModule . post = route (  ' post '  )  ; %NWL%9
var value = event . offsetY * 100 / volumeHeight ; %NWL%var volValue = 1 -  ( value / 100 )  ; %NWL%API . setVolume ( volValue )  ;%NWL%}  ; %NWL%scope . onMouseDownVolume = function onMouseDownVolume (  )  {%NWL%isChangingVolume = true ;%NWL%}  ; %NWL%scope . onMouseUpVolume = function onMouseUpVolume (  )  {%NWL%isChangingVolume = false ;%NWL%}  ; %NWL%scope . onMouseLeaveVolume = function onMouseLeaveVolume (  )  {%NWL%4
}%NWL%return new Operation (  { op :  ' add '  , path : superceded . path , value : record }  )  ;%NWL%}%NWL%function _mergeRecordWithLink ( superceded , superceding )  {%NWL%var record = superceding . value ; %NWL%var linkName = superceded . path [ 3 ]  ; %NWL%var linkId = superceded . path [ 4 ]  ; %NWL%var linkType = _linkTypeFor ( superceded . path )  ; %NWL%record . __rel = record . __rel || {  }  ; %NWL%if ( linkType =  =  =  ' hasMany '  )  {%NWL%record . __rel [ linkName ]  = record . __rel [ linkName ] || {  }  ; %NWL%8
this . columns = this . containerWidth = this . resizeTimer = null ; %NWL%this . activeItemCount = 0 ; %NWL%this . itemHeightsDirty = true ; %NWL%this . placeholders =  [  ]  ; %NWL%$ . extend ( true , this , defaultOptions , options )  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . onResize = __bind ( this . onResize , this )  ; %NWL%this . onRefresh = __bind ( this . onRefresh , this )  ; %NWL%this . getItemWidth = __bind ( this . getItemWidth , this )  ; %NWL%this . layout = __bind ( this . layout , this )  ; %NWL%this . layoutFull = __bind ( this . layoutFull , this )  ; %NWL%5
json . velocityType = this . velocityType ; %NWL%json . material = this . material ? this . material . name : undefined ; %NWL%json . position = this . position . toJSON ( json . position )  ; %NWL%json . positionSpread = this . positionSpread . toJSON ( json . positionSpread )  ; %NWL%json . positionRadius = this . positionRadius ; %NWL%json . speed = this . speed ; %NWL%json . speedSpread = this . speedSpread ; %NWL%json . worldSpace = this . worldSpace ; %NWL%json . minEmission = this . minEmission ; %NWL%json . maxEmission = this . maxEmission ; %NWL%json . minLife = this . minLife ; %NWL%0
object . db_options . native_parser = _setNativeParser ( object . db_options )  ; %NWL%if ( typeof object . server_options . auto_reconnect ! =  ' boolean '  )  {%NWL%object . server_options . auto_reconnect = true ;%NWL%}%NWL%for ( var i = 0 ; i < object . servers . length ; i +  +  )  {%NWL%var _server_options =  { poolSize : 1 , socketOptions :  { connectTimeoutMS : 1000 }  , auto_reconnect : false }  ; %NWL%if ( object . rs_options . ssl )  {%NWL%_server_options . ssl = object . rs_options . ssl ; %NWL%_server_options . sslValidate = object . rs_options . sslValidate ; %NWL%_server_options . sslCA = object . rs_options . sslCA ; %NWL%_server_options . sslCert = object . rs_options . sslCert ; %NWL%7
self . headers [  ' content - type '  ]  = mimetypes . lookup ( src . path . slice ( src . path . lastIndexOf (  '  .  '  )  + 1 )  )%NWL%} else {%NWL%if ( src . headers )  {%NWL%for ( var i in src . headers )  {%NWL%if ( !self . headers [ i ]  )  {%NWL%self . headers [ i ]  = src . headers [ i ]%NWL%}%NWL%}%NWL%}%NWL%if ( src . method && !self . method )  {%NWL%self . method = src . method%NWL%5
this . els = els ; %NWL%this . models = models ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%this . bind = __bind ( this . bind , this )  ; %NWL%this . select = __bind ( this . select , this )  ; %NWL%this . build = __bind ( this . build , this )  ; %NWL%this . bindingRegExp = __bind ( this . bindingRegExp , this )  ; %NWL%3
var headers = options . headers ; %NWL%if ( headers )  {%NWL%for ( var name in headers ) this . _driver . setHeader ( name , headers [ name ]  )  ;%NWL%}%NWL%this . _ping    = options . ping ; %NWL%this . _pingId   = 0 ; %NWL%this . readyState  = API . CONNECTING ; %NWL%this . bufferedAmount = 0 ; %NWL%this . protocol   =  '  '  ; %NWL%this . url    = this . _driver . url ; %NWL%this . version   = this . _driver . version ; %NWL%9
client . close (  )  ; %NWL%callback (  )  ;%NWL%} else {%NWL%client . close (  )  ; %NWL%callback (  )  ;%NWL%}%NWL%}  ,%NWL%shouldForceMongoDbServerToAssignId : function ( test )  {%NWL%var db = new Db ( MONGODB , new Server (  ' localhost '  , 27017 ,  { auto_reconnect : true }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  ,  ' forceServerObjectId '  : true }  )  ; %NWL%db . bson_deserializer = client . bson_deserializer ; %NWL%db . bson_serializer = client . bson_serializer ; %NWL%9
onClick : function ( value )  {%NWL%this . isOpening = false ; %NWL%this . hide (  )  ; %NWL%this . fireEvent (  ' close '  ,  [ this , value ]  )  ;%NWL%}  ,%NWL%changeText : function ( lang )  {%NWL%this . parent (  )  ; %NWL%if ( this . ok ! = undefined && this . ok ! = null )  {%NWL%this . ok . setLabel (  { set :  ' Jx '  , key :  ' confirm '  , value :  ' affirmativeLabel '  }  )  ;%NWL%}%NWL%if ( this . cancel ! = undefined && this . cancel ! = null )  {%NWL%7
return ( _ref = Backbone . Virtual . _dependencies ) ! = null ? _ref . push (  {%NWL%model : model ,%NWL%event : event%NWL%}  )  : void 0 ;%NWL%}  ; %NWL%function Virtual ( options )  {%NWL%this . remove = __bind ( this . remove , this )  ; %NWL%this . add = __bind ( this . add , this )  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . onChange = __bind ( this . onChange , this )  ; %NWL%this . run = __bind ( this . run , this )  ; %NWL%6
chartObject . click_enable = options . click_enable ? options . click_enable . toLowerCase (  )  : stylesheet . click_enable ; %NWL%chartObject . mode = options . mode ? options . mode . toLowerCase (  )  : stylesheet . mode ; %NWL%if ( options . title_text )  {%NWL%chartObject . title_text = options . title_text ; %NWL%chartObject . title_size =  " title_size " in options ? options . title_size : stylesheet . title_size ; %NWL%chartObject . title_color = options . title_color ? options . title_color : stylesheet . title_color ; %NWL%chartObject . title_weight = options . title_weight ? options . title_weight . toLowerCase (  )  : stylesheet . title_weight ; %NWL%chartObject . title_family = options . title_family ? options . title_family . toLowerCase (  )  : stylesheet . title_family ;%NWL%}%NWL%if ( options . subtitle_text )  {%NWL%chartObject . subtitle_text = options . subtitle_text ; %NWL%3
function normalizeArgs ( args )  {%NWL%args = args || {  }  ; %NWL%args . bubbles = defaultsTo ( false , args . bubbles )  ; %NWL%args . cancelable = defaultsTo ( false , args . cancelable )  ; %NWL%args . location = defaultsTo ( 0 , args . location )  ; %NWL%args . repeat = defaultsTo ( false , args . repeat )  ; %NWL%args . locale = defaultsTo (  '  '  , args . locale )  ; %NWL%args . ctrlKey = defaultsTo ( false , args . ctrlKey )  ; %NWL%args . shiftKey = defaultsTo ( false , args . shiftKey )  ; %NWL%args . altKey = defaultsTo ( false , args . altKey )  ; %NWL%args . metaKey = defaultsTo ( false , args . metaKey )  ; %NWL%2
if ( ! ( fileInfo . isCore )  )  {%NWL%var save =  { paths : module . paths , filename : module . filename }  ; %NWL%module . paths = module . constructor . _nodeModulePaths ( importingModule . fileInfo . dirname )  ; %NWL%module . filename = importingModule . fileInfo . filename ; %NWL%debug (  " importingModule "  , module . filename )  ;%NWL%}  ; %NWL%var requiredNodeJSModule = require ( fileInfo . importInfo . name )  ; %NWL%moduleNode . exports . getMembersFromObjProperties ( requiredNodeJSModule )  ; %NWL%if ( ! ( fileInfo . isCore )  )  {  /  / #restore%NWL%module . paths = save . paths ; %NWL%module . filename = save . filename ; %NWL%9
locQuad . tl . colors = tmpColor ; %NWL%locQuad . tr . colors = tmpColor ; %NWL%var locTextureLoaded = texture . isLoaded (  )  ; %NWL%_t . _textureLoaded = locTextureLoaded ; %NWL%if ( !locTextureLoaded )  {%NWL%_t . _rectRotated = rotated || false ; %NWL%if ( rect )  {%NWL%var locRect = _t . _rect ; %NWL%locRect . x = rect . x ; %NWL%locRect . y = rect . y ; %NWL%locRect . width = rect . width ; %NWL%8
exports . run = function ( files , callback )  {%NWL%var filesCount = 0 ; %NWL%if ( !Array . isArray ( files )  )  {%NWL%files =  [ files ]  ;%NWL%}%NWL%files . forEach ( function ( file )  {%NWL%var opts =  _ . extend (  {  }  , options , file )  ; %NWL%!opts . log && ( opts . log =  {  }  )  ; %NWL%opts . deps = absPaths ( opts . deps )  ; %NWL%opts . code = absPath ( opts . code )  ; %NWL%opts . tests = absPaths ( opts . tests )  ; %NWL%8
fileNames [ config [ key ]  . sizes [ sizeKey ]  ]  = config [ key ]  . sizes [ sizeKey ]  ;%NWL%}%NWL%}%NWL%config [ key ]  . fileNames = fileNames ;%NWL%}%NWL%if ( config [ key ]  . sizes =  =  = undefined )  { config [ key ]  . sizes = this . config . default . sizes ;  }%NWL%if ( config [ key ]  . fileNames =  =  = undefined )  { config [ key ]  . fileNames = this . config . default . fileNames ;  }%NWL%if ( config [ key ]  . imagePath =  =  = undefined )  { config [ key ]  . imagePath = this . config . default . imagePath ;  }%NWL%if ( config [ key ]  . imagePathSizeField =  =  = undefined )  { config [ key ]  . imagePathSizeField = this . config . default . imagePathSizeField ;  }%NWL%if ( config [ key ]  . lazy =  =  = undefined )  { config [ key ]  . lazy = this . config . default . lazy ;  }%NWL%if ( config [ key ]  . lazyPrePx =  =  = undefined )  { config [ key ]  . lazyPrePx = this . config . default . lazyPrePx ;  }%NWL%5
}%NWL%function wrapEach ( original , opName )  {%NWL%return wrapOp ( original , opName , function wrappedEach ( args , last , collectionName )  {%NWL%var segment = addMongoStatement ( tracer , collectionName , opName )%NWL%var callbackBatch = null%NWL%var callback = args [ last ]%NWL%var collection = this%NWL%logger . trace (  ' Tracing MongoDB %s . %s (  )  .  '  , collection , opName )%NWL%if ( this . db && this . db . serverConfig )  {%NWL%segment . host = this . db . serverConfig . host%NWL%segment . port = this . db . serverConfig . port%NWL%9
this . getByUserId = function ( userId , callback )  {%NWL%allocationsDB . findOne (  {%NWL%userId : userId%NWL%}  , function ( err , allocations )  {%NWL%if ( err ) return callback ( err , null )  ; %NWL%userDAO . getUserById ( userId , function ( err , user )  {%NWL%if ( err ) return callback ( err , null )  ; %NWL%allocations . userId = userId ; %NWL%allocations . userName = user . userName ; %NWL%allocations . firstName = user . firstName ; %NWL%allocations . lastName = user . lastName ; %NWL%8
to . miterLimit = from . miterLimit ; %NWL%to . fill = from . fill ; %NWL%to . fillColor = from . fillColor . duplicate (  )  ; %NWL%to . fillStyle = from . fillStyle ; %NWL%to . stroke = from . stroke ; %NWL%to . strokeColor = from . strokeColor . duplicate (  )  ; %NWL%to . strokeStyle = from . strokeStyle ; %NWL%to . shadowColor = from . shadowColor ; %NWL%to . shadowOffsetX = from . shadowOffsetX ; %NWL%to . shadowOffsetY = from . shadowOffsetY ; %NWL%to . shadowBlur = from . shadowBlur ; %NWL%0
VarURL = WWHFrame . WWHHelp . fGetBookIndexFileIndexURL ( VarFavoritesEntry . mBookIndex ,%NWL%VarFavoritesEntry . mFileIndex )  ; %NWL%WWHFrame . WWHHelp . fSetDocumentHREF ( VarURL , false )  ;%NWL%}%NWL%function WWHFavoritesEntry_Object ( ParamBookIndex ,%NWL%ParamFileIndex ,%NWL%ParamTitle )%NWL%{%NWL%this . mBookIndex = ParamBookIndex ; %NWL%this . mFileIndex = ParamFileIndex ; %NWL%this . mTitle  = ParamTitle ; %NWL%8
return ;%NWL%}%NWL%toggleSpinner ( true )  ; %NWL%practitioner . name = humanNameService . mapFromViewModel (  )  [ 0 ]  ; %NWL%practitioner . photo = attachmentService . getAll (  )  ; %NWL%practitioner . address = addressService . mapFromViewModel (  )  ; %NWL%practitioner . telecom = telecomService . mapFromViewModel (  )  ; %NWL%practitioner . identifier = identifierService . getAll (  )  ; %NWL%practitioner . qualification = qualificationService . getAll (  )  ; %NWL%practitioner . organization = vm . practitioner . organization ; %NWL%practitioner . role = vm . practitioner . role ; %NWL%9
C . lua_rawseti = F (  " lua_rawseti "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%C . lua_setmetatable = F (  " lua_setmetatable "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_setfenv = F (  " lua_setfenv "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_call = F (  " lua_call "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%C . lua_pcall = F (  " lua_pcall "  , int_t ,  [ lua_State , int_t , int_t , int_t ]  )  ; %NWL%C . lua_cpcall = F (  " lua_cpcall "  , int_t ,  [ lua_State , lua_CFunction , void_ptr_t ]  )  ; %NWL%C . lua_load = F (  " lua_load "  , int_t ,  [ lua_State , lua_Reader , void_ptr_t ,%NWL%const_char_ptr_t ]  )  ; %NWL%C . lua_dump = F (  " lua_dump "  , int_t ,  [ lua_State , lua_Writer , void_ptr_t ]  )  ; %NWL%C . lua_yield = F (  " lua_yield "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_resume = F (  " lua_resume "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%1
var vp = camera . viewProjectionMatrix ; %NWL%var vpRight = md . m44Right ( vp )  ; %NWL%var vpAt = md . m44At ( vp )  ; %NWL%var vpPos = md . m44Pos ( vp )  ; %NWL%var worldRight = md . v4ScalarMul ( vpRight , farPlane )  ; %NWL%var worldUp = md . m44Up ( vp )  ; %NWL%var worldAt = md . v4ScalarMul ( vpAt , farPlane )  ; %NWL%var worldPos = md . v4Add3 ( md . v4ScalarMul ( vpRight , posX )  , md . v4ScalarMul ( vpAt , posZ )  , vpPos )  ; %NWL%techniqueParameters . worldViewProjection = md . m44Build ( worldRight , worldUp , worldAt , worldPos , techniqueParameters . worldViewProjection )  ; %NWL%techniqueParameters . color =  ( this )  . color ; %NWL%techniqueParameters . fadeToColor =  ( this )  . fadeToColor ; %NWL%9
this . x = opts . x || 0 ; %NWL%this . y = opts . y || 0 ; %NWL%this . w = opts . w || 1 ; %NWL%this . h = opts . h || 1 ; %NWL%this . _webglInitted = false ;%NWL%}%NWL%Component . extend ( Sprite )  ; %NWL%Sprite . prototype . copy = function ( other )  {%NWL%this . visible = other . visible ; %NWL%this . blending = other . blending ; %NWL%this . layer = other . layer ; %NWL%8
config (  ' OPENBADGER_SECRET '  )%NWL%)  ; %NWL%module . exports . toBadgekitBadge = function toBadgekitBadge ( badge )  {%NWL%var newBadge =  {  }  ; %NWL%newBadge . id = badge . slug ; %NWL%newBadge . description = badge . strapline ; %NWL%newBadge . name = badge . name ; %NWL%newBadge . status = badge . archived ? ' archived '  :  ' published '  ; %NWL%newBadge . earnerDescription = badge . earnerDescription ; %NWL%newBadge . consumerDescription = badge . consumerDescription ; %NWL%newBadge . rubricUrl = badge . rubricUrl ; %NWL%6
clockRange : createPropertyDescriptor (  ' clockRange '  )  ,%NWL%clockStep : createPropertyDescriptor (  ' clockStep '  )  ,%NWL%multiplier : createPropertyDescriptor (  ' multiplier '  )%NWL%}  )  ; %NWL%DataSourceClock . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new DataSourceClock (  )  ;%NWL%}%NWL%result . startTime = this . startTime ; %NWL%result . stopTime = this . stopTime ; %NWL%result . currentTime = this . currentTime ; %NWL%8
events . EventEmitter . call ( this )  ; %NWL%options = options || {  }  ; %NWL%var self = this ,%NWL%handleExceptions = false ; %NWL%this . padLevels = options . padLevels || false ; %NWL%this . setLevels ( options . levels )  ; %NWL%if ( options . colors )  {%NWL%config . addColors ( options . colors )  ;%NWL%}%NWL%this . level   = options . level || ' info '  ; %NWL%this . emitErrs  = options . emitErrs || false ; %NWL%4
}%NWL%if ( self . bubbles && host . bubble && !self . stopped )  {%NWL%oldbubble = es . bubbling ; %NWL%es . bubbling = self . type ; %NWL%if ( es . type ! =  = self . type )  {%NWL%es . stopped = 0 ; %NWL%es . prevented = 0 ;%NWL%}%NWL%ret = host . bubble ( self , args , null , es )  ; %NWL%self . stopped = Math . max ( self . stopped , es . stopped )  ; %NWL%self . prevented = Math . max ( self . prevented , es . prevented )  ; %NWL%9
}%NWL%if ( typeof offset ! =  =  ' undefined '  )%NWL%binding . bindByName (  " offset "  , offset )  ; %NWL%params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%var requests =  [  ]  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%8
self . follow = !!options . follow%NWL%self . dot = !!options . dot%NWL%self . mark = !!options . mark%NWL%self . nodir = !!options . nodir%NWL%if ( self . nodir )%NWL%self . mark = true%NWL%self . sync = !!options . sync%NWL%self . nounique = !!options . nounique%NWL%self . nonull = !!options . nonull%NWL%self . nosort = !!options . nosort%NWL%self . nocase = !!options . nocase%NWL%0
}%NWL%}  ,%NWL%processed =  {%NWL%v1 : false ,%NWL%v2 : false%NWL%}  ,%NWL%process = function ( err )  {%NWL%if ( processed . v1 && processed . v2 )  {%NWL%tags . title = tags . v2 . title || tags . v1 . title ; %NWL%tags . album = tags . v2 . album || tags . v1 . album ; %NWL%tags . artist = tags . v2 . artist || tags . v1 . artist ; %NWL%8
exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%0
if ( !majorTick )  {%NWL%if ( kwArgs . fixUpper =  =  " major "  )  { kwArgs . fixUpper =  " minor "  ;  }%NWL%if ( kwArgs . fixLower =  =  " major "  )  { kwArgs . fixLower =  " minor "  ;  }%NWL%}%NWL%if ( !minorTick )  {%NWL%if ( kwArgs . fixUpper =  =  " minor "  )  { kwArgs . fixUpper =  " micro "  ;  }%NWL%if ( kwArgs . fixLower =  =  " minor "  )  { kwArgs . fixLower =  " micro "  ;  }%NWL%}%NWL%if ( !microTick )  {%NWL%if ( kwArgs . fixUpper =  =  " micro "  )  { kwArgs . fixUpper =  " none "  ;  }%NWL%if ( kwArgs . fixLower =  =  " micro "  )  { kwArgs . fixLower =  " none "  ;  }%NWL%9
}  ;%NWL%}  ; %NWL%defaultInstance = new exports . Swig (  )  ; %NWL%exports . setFilter = defaultInstance . setFilter ; %NWL%exports . setTag = defaultInstance . setTag ; %NWL%exports . setExtension = defaultInstance . setExtension ; %NWL%exports . parseFile = defaultInstance . parseFile ; %NWL%exports . precompile = defaultInstance . precompile ; %NWL%exports . compile = defaultInstance . compile ; %NWL%exports . compileFile = defaultInstance . compileFile ; %NWL%exports . render = defaultInstance . render ; %NWL%3
onComplete (  )  ;%NWL%}  ; %NWL%function clone ( a )  {%NWL%if ( null =  =  = a || " object " ! = typeof a )%NWL%return a ; %NWL%if ( a . hasOwnProperty (  " clone "  ) || typeof a [  " clone "  ]  =  =  =  " function "  )  {%NWL%return a . clone (  )  ;%NWL%}%NWL%var b =  {  }  ; %NWL%b . constructor = a . constructor ; %NWL%b . prototype = a . prototype ; %NWL%9
res . isEach = this . isEach ; %NWL%res . lastTag = this . lastTag ; %NWL%res . scriptType = this . scriptType ; %NWL%res . isAttrs = this . isAttrs ; %NWL%res . attrsNest = this . attrsNest . slice (  )  ; %NWL%res . inAttributeName = this . inAttributeName ; %NWL%res . attributeIsType = this . attributeIsType ; %NWL%res . attrValue = this . attrValue ; %NWL%res . indentOf = this . indentOf ; %NWL%res . indentToken = this . indentToken ; %NWL%res . innerModeForLine = this . innerModeForLine ; %NWL%0
PykCharts . oneD =  {  }  ; %NWL%PykCharts . oneD . processInputs = function ( chartObject , options )  {%NWL%var theme = new PykCharts . Configuration . Theme (  {  }  )%NWL%, stylesheet = theme . stylesheet%NWL%, functionality = theme . functionality%NWL%, oneDimensionalCharts = theme . oneDimensionalCharts ; %NWL%chartObject . selector = options . selector ? options . selector : stylesheet . selector ; %NWL%chartObject . chart_width = options . chart_width ? options . chart_width : stylesheet . chart_width ; %NWL%chartObject . interactive_enable = options . interactive_enable ? options . interactive_enable . toLowerCase (  )  : stylesheet . interactive_enable ; %NWL%chartObject . click_enable = options . click_enable ? options . click_enable . toLowerCase (  )  : stylesheet . click_enable ; %NWL%chartObject . mode = options . mode ? options . mode . toLowerCase (  )  : stylesheet . mode ; %NWL%8
}  ; %NWL%Rect . prototype . clone = function (  )  {%NWL%return new Rect ( this )  ;%NWL%}  ; %NWL%exports . event = require (  '  .  / gamejs / event '  )  ; %NWL%exports . font = require (  '  .  / gamejs / font '  )  ; %NWL%exports . http = require (  '  .  / gamejs / http '  )  ; %NWL%exports . image = require (  '  .  / gamejs / image '  )  ; %NWL%exports . audio = require (  '  .  / gamejs / audio '  )  ; %NWL%exports . graphics = require (  '  .  / gamejs / graphics '  )  ; %NWL%exports . logging = require (  '  .  / gamejs / logging '  )  ; %NWL%4
var Configuration = __dependency2__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%serverTokenEndpoint :  '  / users / sign_in '  ,%NWL%resourceName :  ' user '  ,%NWL%tokenAttributeName :  ' user_token '  ,%NWL%identificationAttributeName :  ' user_email '  ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint    = Configuration . serverTokenEndpoint ; %NWL%this . resourceName     = Configuration . resourceName ; %NWL%this . tokenAttributeName    = Configuration . tokenAttributeName ; %NWL%this . identificationAttributeName  = Configuration . identificationAttributeName ; %NWL%7
arguments [ 1 ]  = rpcCustomerID ; %NWL%arguments [ 2 ]  = rpcShopID ; %NWL%arguments [ 3 ]  = this ; %NWL%arguments [ 4 ]  = item ; %NWL%var self = this ; %NWL%var rpc = webinos . rpcHandler . createRPC ( this ,  " addItem "  , arguments )  ; %NWL%webinos . rpcHandler . executeRPC ( rpc ,%NWL%function ( params )  {%NWL%self . items = params . items ; %NWL%self . extras = params . extras ; %NWL%self . totalBill = params . totalBill ; %NWL%8
throw {%NWL%name :  " BoardError "  ,%NWL%message :  " Move invalid "%NWL%}  ;%NWL%}%NWL%}  ,%NWL%moveToCoords : function ( col , row )  {%NWL%var map =  {  ' a '  : 0 ,  ' b '  : 1 ,  ' c '  : 2 ,  ' 1 '  : 0 ,  ' 2 '  : 1 ,  ' 3 '  : 2 }  ; %NWL%var coords =  { row : null , col : null }  ; %NWL%coords . col = map [ col ]  ; %NWL%coords . row = map [ row ]  ; %NWL%9
profiler . start = function start ( title )  {%NWL%title = title || getProfileId (  )  ; %NWL%profiler . enabled = true ; %NWL%profiler . store . push ( title )  ; %NWL%worker . postMessage (  {%NWL%type :  ' start '  ,%NWL%title : title%NWL%}  )  ; %NWL%return title ;%NWL%}  ; %NWL%profiler . finish = function finish ( title )  {%NWL%0
var text = $ (  '  < div class =  " loading - text "  >  <  / div >  '  )%NWL%. appendTo ( widget )  ; %NWL%wrapper . on (%NWL%' click submit mousedown mouseup touchstart touchend '  ,%NWL%function ( e )  {%NWL%e . stopPropagation (  )  ;%NWL%}%NWL%)  ; %NWL%l . text = function ( t )  { text . text ( t )  ;  }  ; %NWL%l . show = function (  )  { wrapper . show (  )  ;  }  ; %NWL%l . hide = function (  )  { wrapper . hide (  )  ;  }  ; %NWL%9
return transformElem ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . putElement = _ . bind ( putElementFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%6
}  ; %NWL%return Binding ;%NWL%}  )  (  )  ; %NWL%Rivets . View =  ( function (  )  {%NWL%function View ( els , models , options )  {%NWL%var k , option , v , _base , _i , _len , _ref , _ref1 , _ref2 , _ref3 ; %NWL%this . els = els ; %NWL%this . models = models ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%9
try {%NWL%check ( req . body . giftId )  . notEmpty (  )  ; %NWL%check ( req . body . name )  . notEmpty (  )  ; %NWL%check ( req . body . categoryId )  . notEmpty (  )  ; %NWL%giftObj . giftId  = sanitize ( sanitize ( req . body . giftId )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . name   = sanitize ( sanitize ( req . body . name )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . categoryId = sanitize ( sanitize ( req . body . categoryId )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . brand   = sanitize ( sanitize ( req . body . brand || "  "  )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . unit   = sanitize ( sanitize ( req . body . unit || "  "  )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . price   = sanitize ( sanitize ( req . body . price || "  "  )  . trim (  )  )  . xss (  )  ; %NWL%giftObj . expireDate = sanitize ( sanitize ( req . body . expireDate || "  "  )  . trim (  )  )  . xss (  )  ; %NWL%7
parseBuffer (  )  ;%NWL%}  ;%NWL%}  ; %NWL%var parseAcknowledgment = exports . _parseAcknowledgment = function ( aBuffer )  {%NWL%var calculatedChecksum ; %NWL%var expectedPacketLength ; %NWL%var responsePacket ; %NWL%if ( aBuffer . length >  = spheroMinimumPacketSize )  {  /  / Don ' t bother until we get a minimum sized packet%NWL%responsePacket = Object . create ( spheroResponseTemplate )  ; %NWL%responsePacket . SOP1 = aBuffer . readUInt8 ( spheroResponseTemplate . SOP1 )  ; %NWL%responsePacket . SOP2 = aBuffer . readUInt8 ( spheroResponseTemplate . SOP2 )  ; %NWL%9
v = d . style ( node , p )  ; %NWL%return ( p =  =  " opacity "  ) ? + v :  ( isColor ? v : parseFloat ( v )  )  ;%NWL%}%NWL%if ( ! (  " end " in prop )  )  {%NWL%prop . end = getStyle ( this . node , p )  ;%NWL%} else if ( ! (  " start " in prop )  )  {%NWL%prop . start = getStyle ( this . node , p )  ;%NWL%}%NWL%if ( isColor )  {%NWL%prop . start = new d . Color ( prop . start )  ; %NWL%prop . end = new d . Color ( prop . end )  ; %NWL%9
air . KeyLocation = window . runtime . flash . ui . KeyLocation ; %NWL%air . Mouse = window . runtime . flash . ui . Mouse ; %NWL%air . ReferencesValidationSetting = window . runtime . flash . security . ReferencesValidationSetting ; %NWL%air . RevocationCheckSettings = window . runtime . flash . security . RevocationCheckSettings ; %NWL%air . SignatureStatus = window . runtime . flash . security . SignatureStatus ; %NWL%air . SignerTrustSettings = window . runtime . flash . security . SignerTrustSettings ; %NWL%air . XMLSignatureValidator = window . runtime . flash . security . XMLSignatureValidator ; %NWL%air . ByteArray = window . runtime . flash . utils . ByteArray ; %NWL%air . CompressionAlgorithm = window . runtime . flash . utils . CompressionAlgorithm ; %NWL%air . Endian = window . runtime . flash . utils . Endian ; %NWL%air . Timer = window . runtime . flash . utils . Timer ; %NWL%7
}  ; %NWL%proto . assertPassedFeatures = function assertPassedFeatures (  )  {%NWL%this . assertNoPartialOutput (  " failed "  , this . runOutput )  ; %NWL%this . assertPartialOutput (  " 3 scenarios (  "  + this . color . format (  " passed "  ,  " 3 passed "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertPassedScenario = function assertPassedScenario (  )  {%NWL%this . assertPartialOutput (  " 1 scenario (  "  + this . color . format (  " passed "  ,  " 1 passed "  )  +  "  )  "  , this . runOutput )  ; %NWL%this . assertSuccess (  )  ;%NWL%}  ; %NWL%proto . assertFailedScenario = function assertFailedScenario (  )  {%NWL%1
if ( this . scope =  =  = null )  {%NWL%this . scope = this ;%NWL%}%NWL%this . initLayer ( layers )  ; %NWL%var callbacks =  {%NWL%click : this . clickFeature ,%NWL%clickout : this . clickoutFeature%NWL%}  ; %NWL%if ( this . hover )  {%NWL%callbacks . over = this . overFeature ; %NWL%callbacks . out = this . outFeature ; %NWL%9
if ( result . styleClass && style . styleClass && result . styleClass ! =  = style . styleClass )  {%NWL%result . styleClass +  =  "  "  + style . styleClass ;  /  / $NON - NLS - 0$%NWL%} else {%NWL%result . styleClass = style . styleClass ;%NWL%}%NWL%var prop ; %NWL%if ( style . style )  {%NWL%if ( !result . style )  { result . style  =  {  }  ;  }%NWL%for ( prop in style . style )  {%NWL%if ( !result . style [ prop ]  )  {%NWL%result . style [ prop ]  = style . style [ prop ]  ; %NWL%3
docs . js . setUndoManager ( new UndoManager (  )  )  ; %NWL%docs . css = new EditSession ( document . getElementById (  " csstext "  )  . innerHTML )  ; %NWL%docs . css . setMode ( new CssMode (  )  )  ; %NWL%docs . css . setUndoManager ( new UndoManager (  )  )  ; %NWL%docs . html = new EditSession ( document . getElementById (  " htmltext "  )  . innerHTML )  ; %NWL%docs . html . setMode ( new HtmlMode (  )  )  ; %NWL%docs . html . setUndoManager ( new UndoManager (  )  )  ; %NWL%docs . python = new EditSession ( document . getElementById (  " pythontext "  )  . innerHTML )  ; %NWL%docs . python . setMode ( new PythonMode (  )  )  ; %NWL%docs . python . setUndoManager ( new UndoManager (  )  )  ; %NWL%docs . php = new EditSession ( document . getElementById (  " phptext "  )  . innerHTML )  ; %NWL%1
o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . globalAlpha  = o1 . globalAlpha ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%o2 . arcScaleY_  = o1 . arcScaleY_ ; %NWL%o2 . lineScale_  = o1 . lineScale_ ; %NWL%0
}%NWL%if ( options . user ! = null )  {%NWL%if ( PEER_CONNECTIONS [ options . user ]  =  = null )  {%NWL%PUBNUB . createP2PConnection ( options . user )  ;%NWL%}%NWL%var connection = PEER_CONNECTIONS [ options . user ]  ; %NWL%if ( options . stream )  {%NWL%connection . stream = options . stream ;%NWL%}%NWL%if ( options . callback )  {%NWL%connection . callback = options . callback ; %NWL%7
margin : 0 ,%NWL%sourceImage :  "  "  ,%NWL%imageSize : null ,%NWL%ctor : function (  )  {%NWL%this . _tileSize = cc . size ( 0 , 0 )  ; %NWL%this . imageSize = cc . size ( 0 , 0 )  ;%NWL%}  ,%NWL%rectForGID : function ( gid )  {%NWL%var rect = cc . rect ( 0 , 0 , 0 , 0 )  ; %NWL%rect . width = this . _tileSize . width ; %NWL%rect . height = this . _tileSize . height ; %NWL%9
state . aspriority = allVars [  ' aspriority '  ] || "  "  ; %NWL%state . asauthor = allVars [  ' asauthor '  ] || "  "  ; %NWL%state . asauto = allVars [  ' asauto '  ] || "  "  ; %NWL%state . asproduct = allVars [  ' asproduct '  ] || "  "  ; %NWL%if ( allVars [  ' asstatus '  ]  )  {%NWL%state . asstatus = allVars [  ' asstatus '  ]  . split (  '  ,  '  )  ;%NWL%} else {%NWL%state . asstatus =  [  ]  ;%NWL%}%NWL%state . bugid = allVars [  ' bugid '  ] || "  "  ; %NWL%state . addedversion = allVars [  ' addedversion '  ] || "  "  ; %NWL%0
if ( nextInterval && md . end + move > nextInterval . start )  {%NWL%move = nextInterval . start - md . end ;%NWL%}%NWL%if ( prevInterval && md . start + move < prevInterval . end )  {%NWL%move = prevInterval . end - md . start ;%NWL%}%NWL%if ( md . start + move < 0 )  {%NWL%move =  - md . start ;%NWL%}%NWL%this . start = md . start + move ; %NWL%this . end = md . end + move ; %NWL%9
this . findAncestors = _findAncestors ; %NWL%this . findDescendants = _findDescendants ; %NWL%this . findLineageList = _findLineageList ; %NWL%this . findParents = _findParents ; %NWL%this . findPerson = _findPerson ; %NWL%this . findOffspring = _findOffspring ; %NWL%this . findSpouse = _findSpouse ; %NWL%this . getFocus = function (  )  { return _focusPerson ;  }  ; %NWL%this . getPeopleCount = function (  )  { return _people . length ;  }  ; %NWL%this . makeBlankPerson = _blankPerson ; %NWL%this . append = _append ; %NWL%0
return this . accepts . reduce ( function ( args , accept )  {%NWL%args . push ( seq . values [ accept ]  )  ; %NWL%return args ;%NWL%}  ,  [  ]  )  ;%NWL%}  ; %NWL%Step . prototype . clone = function ( name , _module )  {%NWL%var step = new Step ( name , _module )  ; %NWL%step . accepts = clone ( this . accepts )  ; %NWL%step . promises = clone ( this . promises )  ; %NWL%step . description = this . description ; %NWL%step . timeout = this . timeout ; %NWL%9
: this . val )  ;%NWL%}  ; %NWL%Unit . prototype . toString = function (  )  {%NWL%var n = this . val ; %NWL%if (  ' px '  =  = this . type ) n = n . toFixed ( 0 )  ; %NWL%return n +  ( this . type || '  '  )  ;%NWL%}  ; %NWL%Unit . prototype . clone = function (  )  {%NWL%var clone = new Unit ( this . val , this . type )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%9
exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%exports . BADFLAGS =  ' EBADFLAGS '  ; %NWL%0
if ( animation . onBeforeStart )  {%NWL%animation . onBeforeStart . call ( animation . scope || this , element )  ; %NWL%animation . fireEvent (  ' animationstart '  , animation )  ; %NWL%this . fireEvent (  ' animationstart '  , this , animation )  ;%NWL%}%NWL%data [ elementId ]  = data ; %NWL%before = data . before ; %NWL%from = data . from ; %NWL%to = data . to ; %NWL%data . fromPropertyNames = fromPropertyNames =  [  ]  ; %NWL%data . toPropertyNames = toPropertyNames =  [  ]  ; %NWL%9
assertEquals ( start_a , Debug . sourcePosition ( a )  )  ; %NWL%assertEquals ( start_b , Debug . sourcePosition ( b )  )  ; %NWL%assertEquals ( start_c , Debug . sourcePosition ( c )  )  ; %NWL%assertEquals ( start_d , Debug . sourcePosition ( d )  )  ; %NWL%var script = Debug . findScript ( a )  ; %NWL%assertTrue ( script . data =  =  = Debug . findScript ( b )  . data )  ; %NWL%assertTrue ( script . data =  =  = Debug . findScript ( c )  . data )  ; %NWL%assertTrue ( script . data =  =  = Debug . findScript ( d )  . data )  ; %NWL%assertTrue ( script . source =  =  = Debug . findScript ( b )  . source )  ; %NWL%assertTrue ( script . source =  =  = Debug . findScript ( c )  . source )  ; %NWL%assertTrue ( script . source =  =  = Debug . findScript ( d )  . source )  ; %NWL%7
if ( me . matchManagerID =  =  = args [ 0 ]  )  {%NWL%sourceListener ( me )  ;%NWL%}%NWL%}  )  ; %NWL%this . onMatchRequestFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onMatchRequestFailed "  , function ( sourceListener , args )%NWL%{%NWL%if ( me . matchManagerID =  =  = args [ 0 ]  )  {%NWL%sourceListener ( me , args [ 1 ]  )  ;%NWL%}%NWL%}  )  ; %NWL%this . onInvitationReceived = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onInvitationReceived "  , function ( sourceListener , args )%NWL%4
this . toAbsolute = function ( base )  {%NWL%var base = new jscolor . URI ( base )  ; %NWL%var r = this ; %NWL%var t = new jscolor . URI ; %NWL%if ( base . scheme =  =  = null )  { return false ;  }%NWL%if ( r . scheme ! =  = null && r . scheme . toLowerCase (  )  =  =  = base . scheme . toLowerCase (  )  )  {%NWL%r . scheme = null ;%NWL%}%NWL%if ( r . scheme ! =  = null )  {%NWL%t . scheme = r . scheme ; %NWL%t . authority = r . authority ; %NWL%9
if ( this . onClick ) this . onClick ( e )  ;%NWL%}%NWL%this . clickClosure = this . clickClosure . bind ( this )  ; %NWL%this . onDownClosure = function ( e )  {%NWL%e = w . flash . events . normalizeEvent ( e )  ; %NWL%this . startTouchTime = Date . now (  )  ; %NWL%if ( this . onMouseDown )  {%NWL%this . onMouseDown ( e )%NWL%}%NWL%}%NWL%this . onDownClosure = this . onDownClosure . bind ( this )  ; %NWL%2
gesturechange : 1 ,%NWL%gestureend : 1 ,%NWL%MSPointerDown : 1 ,%NWL%MSPointerUp : 1 ,%NWL%MSPointerMove : 1%NWL%}  )  ;%NWL%}%NWL%if (  ( win && (  " ontouchstart " in win )  ) && ! ( Y . UA . chrome && Y . UA . chrome < 6 )  )  {%NWL%GESTURE_MAP . start =  " touchstart "  ; %NWL%GESTURE_MAP . end =  " touchend "  ; %NWL%GESTURE_MAP . move =  " touchmove "  ; %NWL%8
}%NWL%return copy ;%NWL%}  ; %NWL%domJSON . toJSON = function ( node , opts )  {%NWL%var copy , keys =  [  ]  , options =  {  }  , output =  {  }  ; %NWL%var timer = new Date (  )  . getTime (  )  ; %NWL%var requiring = required . slice (  )  ; %NWL%var ignoring = ignored . slice (  )  ; %NWL%options = extend (  {  }  , defaultsForToJSON , opts )  ; %NWL%options . absolutePaths = toShorthand ( options . absolutePaths )  ; %NWL%options . attributes = toShorthand ( options . attributes )  ; %NWL%9
Plugin . prototype . calibrate = function ( x , y )  {%NWL%this . calibrateX = x =  =  = undefined ? this . calibrateX : x ; %NWL%this . calibrateY = y =  =  = undefined ? this . calibrateY : y ;%NWL%}  ; %NWL%Plugin . prototype . invert = function ( x , y )  {%NWL%this . invertX = x =  =  = undefined ? this . invertX : x ; %NWL%this . invertY = y =  =  = undefined ? this . invertY : y ;%NWL%}  ; %NWL%Plugin . prototype . friction = function ( x , y )  {%NWL%this . frictionX = x =  =  = undefined ? this . frictionX : x ; %NWL%this . frictionY = y =  =  = undefined ? this . frictionY : y ; %NWL%2
}%NWL%}%NWL%if ( game . device . opera && game . Audio . webAudio ) this . formats . erase (  ' m4a '  )  ; %NWL%if ( this . formats . length =  =  = 0 ) game . Audio . enabled = false ; %NWL%if ( game . Audio . enabled && game . Audio . webAudio )  {%NWL%this . context = new AudioContext (  )  ; %NWL%this . gainNode = this . context . createGain ? this . context . createGain (  )  : this . context . createGainNode (  )  ; %NWL%this . gainNode . connect ( this . context . destination )  ;%NWL%}%NWL%this . musicVolume = game . Audio . musicVolume ; %NWL%this . soundVolume = game . Audio . soundVolume ; %NWL%9
Class . call ( this )  ; %NWL%this . width = opts . width || 512 ; %NWL%this . height = opts . height || 512 ; %NWL%this . invWidth = 1 / this . width ; %NWL%this . invHeight = 1 / this . height ; %NWL%this . depthOnly = opts . depthOnly ! = undefined ? !! opts . depthOnly : false ; %NWL%this . depthBuffer = opts . depthBuffer ! = undefined ? !! opts . depthBuffer : true ; %NWL%this . stencilBuffer = opts . stencilBuffer ! = undefined ? !! opts . stencilBuffer : true ; %NWL%this . generateMipmap = opts . generateMipmap ! = undefined ? !! opts . generateMipmap : true ; %NWL%this . flipY = opts . flipY ! = undefined ? !! opts . flipY : true ; %NWL%this . premultiplyAlpha = opts . premultiplyAlpha ! = undefined ? !! opts . premultiplyAlpha : false ; %NWL%5
this . url = url ; %NWL%this . scene = scene ;%NWL%}%NWL%function ready ( data )  {%NWL%var clone_data = CE . Core . extend (  {  }  , data )  ; %NWL%self . tile_h = data . tileheight ; %NWL%self . tile_w = data . tilewidth ; %NWL%self . width = data . width ; %NWL%self . height = data . height ; %NWL%self . tilesets = data . tilesets ; %NWL%self . layers = data . layers ; %NWL%7
return this . segments . join (  '  '  )  ;%NWL%}  ; %NWL%Selector . prototype . __defineGetter__ (  ' isPlaceholder '  , function (  )  {%NWL%return this . val && ~this . val . substr ( 0 , 2 )  . indexOf (  ' $ '  )  ;%NWL%}  )  ; %NWL%Selector . prototype . clone = function ( parent )  {%NWL%var clone = new Selector ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%clone . inherits = this . inherits ; %NWL%clone . val = this . val ; %NWL%7
var citeproc = new CSL . Engine ( sys , style , lang , forceLang )  ; %NWL%return citeproc ;%NWL%}  ; %NWL%citeprocnode . retrieveLocale = function ( language )  {%NWL%var fs = require (  ' fs '  )  ; %NWL%var localeFileName =  '  .  .  / csl - locales / locales -  '  + language +  '  . xml '  ;  /  / this ignores configured csl - locale dir?%NWL%return fs . readFileSync ( localeFileName ,  ' utf8 '  )  ;%NWL%}  ; %NWL%if ( typeof module ! =  =  ' undefined ' && " exports " in module )  {%NWL%exports . createEngine = citeprocnode . createEngine ; %NWL%exports . retrieveLocale = citeprocnode . retrieveLocale ; %NWL%9
objData . rockType = 1 ; %NWL%return ( new Evolb . Rock ( level , objData )  )  ;%NWL%}  ; %NWL%Evolb . Rock1 . prototype = Object . create ( Phaser . Sprite . prototype )  ; %NWL%Evolb . Rock1 . prototype . constructor = Evolb . Rock1 ; %NWL%Evolb . Rock2 = function ( level , objData )  {%NWL%objData . rockType = 2 ; %NWL%return ( new Evolb . Rock ( level , objData )  )  ;%NWL%}  ; %NWL%Evolb . Rock2 . prototype = Object . create ( Phaser . Sprite . prototype )  ; %NWL%Evolb . Rock2 . prototype . constructor = Evolb . Rock2 ; %NWL%4
port :   parseInt ( $server . find (  '  . address '  )  . val (  )  . split (  '  :  '  )  [ 1 ]  , 10 )  ,%NWL%version :  $server . find (  '  . version '  )  . val (  )  ,%NWL%langtype :  $server . find (  '  . langtype '  )  . val (  )  ,%NWL%packetver : $server . find (  '  . packetver '  )  . val (  )%NWL%}  )  ;%NWL%}%NWL%}%NWL%Audio . BGM . volume  = ui . find (  '  . bgmvol '  )  . val (  )  / 100 ; %NWL%Audio . BGM . play   = Audio . BGM . volume > 0 ? true : false ; %NWL%Audio . Sound . volume  = ui . find (  '  . soundvol '  )  . val (  )  / 100 ; %NWL%Audio . Sound . play  = Audio . Sound . volume > 0 ? true : false ; %NWL%8
{%NWL%this . _lastEmitTime = 0 ; %NWL%this . _shotCount = 0 ; %NWL%this . active = pc . checked ( options . active , true )  ; %NWL%this . emitting = pc . checked ( options . emitting , true )  ; %NWL%this . growXMin = pc . checked ( options . growXMin , 0 )  ; %NWL%this . growXMax = pc . checked ( options . growXMax , this . growXMin )  ; %NWL%this . growYMin = pc . checked ( options . growYMin , 0 )  ; %NWL%this . growYMax = pc . checked ( options . growYMax , this . growYMin )  ; %NWL%this . scaleXMin = pc . checked ( options . scaleXMin , 1 )  ; %NWL%this . scaleYMin = pc . checked ( options . scaleYMin , 1 )  ; %NWL%9
this . needsUpdate = true ;%NWL%}  ; %NWL%RenderTarget . prototype . toJSON = function ( json )  {%NWL%json = Class . prototype . toJSON . call ( this , json )  ; %NWL%json . width = this . width ; %NWL%json . height = this . height ; %NWL%json . invWidth = this . invWidth ; %NWL%json . invHeight = this . invHeight ; %NWL%json . generateMipmap = this . generateMipmap ; %NWL%json . flipY = this . flipY ; %NWL%json . premultiplyAlpha = this . premultiplyAlpha ; %NWL%4
hasProp =  {  }  . hasOwnProperty ; %NWL%BaseModel = require (  '  .  .  / BaseModel '  )  ; %NWL%Groups =  ( function ( superClass )  {%NWL%extend ( Groups , superClass )  ; %NWL%function Groups (  )  {%NWL%this . search = bind ( this . search , this )  ; %NWL%this . addProject = bind ( this . addProject , this )  ; %NWL%this . create = bind ( this . create , this )  ; %NWL%this . addMember = bind ( this . addMember , this )  ; %NWL%this . listMembers = bind ( this . listMembers , this )  ; %NWL%this . listProjects = bind ( this . listProjects , this )  ; %NWL%5
getWindowOptions_ : function (  )  {%NWL%var options =  {  }  ; %NWL%var sizes = this . getSizes (  )  ; %NWL%options . defaultWidth = sizes . default [ 0 ]  ; %NWL%options . defaultHeight = sizes . default [ 1 ]  ; %NWL%options . minWidth = sizes . minimum && sizes . minimum [ 0 ]  ; %NWL%options . minHeight = sizes . minimum && sizes . minimum [ 1 ]  ; %NWL%options . maxWidth = sizes . maximum && sizes . maximum [ 0 ]  ; %NWL%options . maxHeight = sizes . maximum && sizes . maximum [ 1 ]  ; %NWL%options . bounds = this . bounds ; %NWL%options . id = this . id ; %NWL%9
served : true ,%NWL%included : true ,%NWL%watched : true%NWL%}  )  ;%NWL%}%NWL%var bundle ; %NWL%function preprocessor ( config )  {%NWL%var bc = config . browserify || {  }  ; %NWL%bc . files = bc . files || [  ]  ; %NWL%bc . extensions = bc . extensions || [  ]  ; %NWL%bc . transform = bc . transform || [  ]  ; %NWL%8
if ( data . address . country )%NWL%result . country = data . address . country ; %NWL%if ( data . address . city && data . address . city ! =  '  -  ' && data . address . city ! =  ' NaN '  )%NWL%result . city = data . address . city ; %NWL%if ( data . address . region && data . address . region ! =  '  -  ' && data . address . region ! =  ' NaN '  )%NWL%result . region = data . address . region ;%NWL%}%NWL%if ( data . latitude )%NWL%result . latitude = data . latitude ; %NWL%if ( data . longitude )%NWL%result . longitude = data . longitude ; %NWL%8
on : function ( node , subscription , notifier , filter )  {%NWL%var handles =  [  ]  ; %NWL%handles . push ( Event . _attach (  [  " contextmenu "  , function ( e )  {%NWL%e . preventDefault (  )  ; %NWL%var id = Y . stamp ( node )  ,%NWL%data = eventData [ id ]  ; %NWL%if ( data )  {%NWL%e . clientX = data . clientX ; %NWL%e . clientY = data . clientY ; %NWL%e . pageX = data . pageX ; %NWL%e . pageY = data . pageY ; %NWL%7
this . askForModuleName (  )  ;%NWL%}  ; %NWL%Generator . prototype . writing = function writing (  )  {%NWL%var config = this . getConfig (  )%NWL%, markupFile = this . name%NWL%, styleFile ; %NWL%if ( ! (  /  [  .  ] tpl [  .  ] html$ /  )  . test ( this . name )  )  {%NWL%markupFile +  =  '  . tpl . html '  ;%NWL%}%NWL%config . lowerCamel = config . lowerCamel . replace (  / TplHtml$ /  ,  '  '  )  ; %NWL%config . ctrlName = config . ctrlName . replace (  / TplHtml$ /  ,  '  '  )  ; %NWL%9
}%NWL%}%NWL%}%NWL%function Analyzer ( config )  {%NWL%config = _ . merge ( _ . clone ( Analyzer . DEFAULT_CONFIG , true )  , config )  ; %NWL%this . __items__ = new HashMap (  )  ; %NWL%this . __forbidden__ = new HashMap (  )  ; %NWL%this . debug = config . debug ; %NWL%this . cache = config . cache ; %NWL%this . levels = config . levels ; %NWL%this . visitConstructors = config . visitConstructors ; %NWL%7
this . name = null ; %NWL%this . uuid = null ; %NWL%this . phonegap = null ; %NWL%var me = this ; %NWL%this . getInfo (%NWL%function ( res )  {%NWL%var info = JSON . parse ( res )  ; %NWL%console . log (  " GotDeviceInfo :  :  "  + info . version )  ; %NWL%me . available = true ; %NWL%me . platform = info . platform ; %NWL%me . version = info . version ; %NWL%9
listeners [ key ]  . splice ( index , 1 )  ;%NWL%}%NWL%}%NWL%}%NWL%return this ;%NWL%}  ; %NWL%proto . off = proto . removeListener ; %NWL%proto . addListeners = function addListeners ( evt , listeners )  {%NWL%return this . manipulateListeners ( false , evt , listeners )  ;%NWL%}  ; %NWL%proto . removeListeners = function removeListeners ( evt , listeners )  {%NWL%7
exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%0
this . root . type =  ' b '  ;%NWL%}  ; %NWL%RBTreeList . prototype . deleteNode = function ( node )  {%NWL%this . size -  -  ; %NWL%var successor ; %NWL%if ( !node . left || !node . right )%NWL%successor = node ; %NWL%else {%NWL%successor = this . successor ( node )  ; %NWL%node . key = successor . key ; %NWL%node . item = successor . item ; %NWL%9
timeLimit : 1000%NWL%}%NWL%for ( var p in options )  { this . _options [ p ]  = options [ p ]  ;  }%NWL%this . _features =  {%NWL%" Room "  : 4 ,%NWL%" Corridor "  : 4%NWL%}%NWL%this . _featureAttempts = 20 ; %NWL%this . _walls =  {  }  ; %NWL%this . _digCallback = this . _digCallback . bind ( this )  ; %NWL%this . _canBeDugCallback = this . _canBeDugCallback . bind ( this )  ; %NWL%9
$interval (  ( function (  )  {%NWL%return deferred . reject (  )  ;%NWL%}  )  , timeout , 1 )  ; %NWL%return deferred . promise ;%NWL%}%NWL%}  ; %NWL%util . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . registerHandler "  ; %NWL%util . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . unregisterHandler "  ; %NWL%util . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . send "  ; %NWL%util . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . publish "  ; %NWL%util . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : util . login "  ; %NWL%6
nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%0
if ( !utils . isProduction )  {%NWL%hbs . handlebars . logger . level = 0 ;%NWL%}%NWL%coreHelpers . asset  = require (  '  .  / asset '  )  ; %NWL%coreHelpers . author  = require (  '  .  / author '  )  ; %NWL%coreHelpers . body_class  = require (  '  .  / body_class '  )  ; %NWL%coreHelpers . content  = require (  '  .  / content '  )  ; %NWL%coreHelpers . date  = require (  '  .  / date '  )  ; %NWL%coreHelpers . encode  = require (  '  .  / encode '  )  ; %NWL%coreHelpers . excerpt  = require (  '  .  / excerpt '  )  ; %NWL%coreHelpers . foreach = require (  '  .  / foreach '  )  ; %NWL%3
$scope . ons . screen . presentPage (  ' playModalNav . html '  )  ;%NWL%}%NWL%$scope . openSortModal = function (  )  {%NWL%$scope . ons . screen . presentPage (  ' sortModalNav . html '  )  ;%NWL%}%NWL%}  )%NWL%mediaApp . controller (  ' PlayMediaCtrl '  , function ( $scope , SettingsService )  {%NWL%console . log (  " Kind "  + this . kind )  ; %NWL%$scope . kind = SettingsService . get (  ' kind '  )  ; %NWL%$scope . title = SettingsService . get (  ' title '  )  ; %NWL%$scope . artist = SettingsService . get (  ' artist '  )  ; %NWL%8
}%NWL%this . value = value || [  ]  ;%NWL%}%NWL%module . exports = exports = Fast ; %NWL%Fast . array = require (  '  .  / array '  )  ; %NWL%Fast [  ' function '  ]  = Fast . fn = require (  '  .  / function '  )  ; %NWL%Fast . object = require (  '  .  / object '  )  ; %NWL%Fast . string = require (  '  .  / string '  )  ; %NWL%Fast . apply = Fast [  ' function '  ]  . apply ; %NWL%Fast . bind = Fast [  ' function '  ]  . bind ; %NWL%Fast . partial = Fast [  ' function '  ]  . partial ; %NWL%8
if ( isSkippable )  {%NWL%skipButton . css (  " display "  ,  " block "  )  ;%NWL%}%NWL%else {%NWL%skipButton . css (  " display "  ,  " none "  )  ;%NWL%}%NWL%}  ; %NWL%scope . onClickSkip = function onClickSkip (  )  {%NWL%adsManager . skip (  )  ;%NWL%}  ; %NWL%scope . onContentPauseRequested = function onContentPauseRequested (  )  {%NWL%7
options = extend (  { keys : true , values : true }  , this . options , options )%NWL%options . keyEncoding  = options . keyEncoding || options . encoding%NWL%options . valueEncoding = options . valueEncoding || options . encoding%NWL%if ( isDefined ( options . start )  )%NWL%options . start = this . _codec . encodeKey ( options . start , options )%NWL%if ( isDefined ( options . end )  )%NWL%options . end = this . _codec . encodeKey ( options . end , options )%NWL%if ( isDefined ( options . gte )  )%NWL%options . gte = this . _codec . encodeKey ( options . gte , options )%NWL%if ( isDefined ( options . gt )  )%NWL%options . gt = this . _codec . encodeKey ( options . gt , options )%NWL%4
getDOMObjectPosition : function ( obj )  {%NWL%var info =  {%NWL%left : 0 ,%NWL%top : 0 ,%NWL%width : obj . width ? obj . width : obj . offsetWidth ,%NWL%height : obj . height ? obj . height : obj . offsetHeight%NWL%}  ; %NWL%if ( obj . style . width ! =  "  "  )%NWL%info . width = obj . style . width . replace (  " px "  ,  "  "  )  ; %NWL%if ( obj . style . height ! =  "  "  )%NWL%info . height = obj . style . height . replace (  " px "  ,  "  "  )  ; %NWL%8
mipmaps [ i ]  = byteArray ;%NWL%}%NWL%textures [ f ]  . pixels = mipmaps [ 0 ]  ; %NWL%if ( hasMipmap )  {%NWL%textures [ f ]  . mipmaps = mipmaps ;%NWL%}%NWL%}%NWL%if ( out )  {%NWL%out . width = textures [ 0 ]  . width ; %NWL%out . height = textures [ 0 ]  . height ; %NWL%out . format = textures [ 0 ]  . format ; %NWL%8
exports . FB_TOKEN = process . env . FB_TOKEN || null ; %NWL%exports . FB_REQ  = process . env . FB_REQ || ' search / request '  ; %NWL%exports . FB_RES  = process . env . FB_RES || ' search / response '  ; %NWL%if ( process . env . BONSAI_URL )  {%NWL%processBonsaiUrl ( exports , process . env . BONSAI_URL )  ;%NWL%}%NWL%else {%NWL%exports . ES_HOST  = process . env . ES_HOST || ' localhost '  ; %NWL%exports . ES_PORT  = process . env . ES_PORT || ' 9200 '  ; %NWL%exports . ES_USER  = process . env . ES_USER || null ; %NWL%exports . ES_PASS  = process . env . ES_PASS || null ; %NWL%0
load : onComplete ,%NWL%error : onError ,%NWL%handleAs :  " json "%NWL%}  )  ;  /  / dojo . Deferred%NWL%}  ,%NWL%create : function ( info )  {%NWL%var d = new dojo . Deferred (  )  ; %NWL%if ( info . onComplete ) d . addCallback ( info . onComplete )  ; %NWL%if ( info . onError ) d . addErrback ( info . onError )  ; %NWL%info . permissions = dojo . toJson ( info . permissions || [  ]  )  ; %NWL%info . groups = dojo . toJson ( info . groups || [  ]  )  ; %NWL%9
}  ,%NWL%cleanup : function (  )  {%NWL%this . serviceRequests . off ( null , null , this )  ; %NWL%app . off ( null , null , this )  ;%NWL%}  ,%NWL%serialize : function (  )  {%NWL%return { serviceRequests : this . serviceRequests . toJSON (  )  }%NWL%}  ,%NWL%initialize : function ( e )  {%NWL%this . serviceRequests  = e . serviceRequests ; %NWL%this . filters = e . filters ; %NWL%9
Y . one (  " body "  )  . focus (  )  ; %NWL%this . _swfReference . _swf . focus (  )  ; %NWL%var newfiles = ev . fileList ,%NWL%fileConfObjects =  [  ]  ,%NWL%parsedFiles =  [  ]  ,%NWL%swfRef = this . _swfReference ; %NWL%Y . each ( newfiles , function ( value )  {%NWL%var newFileConf =  {  }  ; %NWL%newFileConf . id = value . fileId ; %NWL%newFileConf . name = value . fileReference . name ; %NWL%newFileConf . size = value . fileReference . size ; %NWL%9
prop = keyProperties [ i ]  ; %NWL%conditions [ prop . mapsTo ]  = ids [ i ]  ;%NWL%}%NWL%if ( !options . hasOwnProperty (  " autoFetch "  )  )  {%NWL%options . autoFetch = opts . autoFetch ;%NWL%}%NWL%if ( !options . hasOwnProperty (  " autoFetchLimit "  )  )  {%NWL%options . autoFetchLimit = opts . autoFetchLimit ;%NWL%}%NWL%if ( !options . hasOwnProperty (  " cascadeRemove "  )  )  {%NWL%options . cascadeRemove = opts . cascadeRemove ; %NWL%4
try {%NWL%var params = stmt . newBindingParamsArray (  )  ,%NWL%binding = params . newBindingParams (  )  ; %NWL%binding . bindByName (  " requestName "  , requestName )  ; %NWL%params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%8
this . reject ( 500 )  ; %NWL%throw new Error (  " Value supplied for ' cookies ' argument must be an array .  "  )  ;%NWL%}%NWL%var seenCookies =  {  }  ; %NWL%cookies . forEach ( function ( cookie )  {%NWL%if ( !cookie . name || !cookie . value )  {%NWL%this . reject ( 500 )  ; %NWL%throw new Error (  " Each cookie to set must at least provide a ' name ' and ' value '  "  )  ;%NWL%}%NWL%cookie . name = cookie . name . replace ( controlCharsAndSemicolonRegEx ,  '  '  )  ; %NWL%cookie . value = cookie . value . replace ( controlCharsAndSemicolonRegEx ,  '  '  )  ; %NWL%9
img . set (  {%NWL%left : args . left ,%NWL%top : args . top ,%NWL%scaleX : args . scaleX ,%NWL%scaleY : args . scaleY ,%NWL%source : args . src%NWL%}  )  ; %NWL%img . setAngle ( args . angle )  ; %NWL%img . name = args . name ; %NWL%img . uid = args . uid ; %NWL%img . palette = args . palette ; %NWL%8
this . fillStyle = options [  ' fillStyle '  ]  ; %NWL%this . gridcolor = options [  ' gridcolor '  ]  ; %NWL%this . background = options [  ' background '  ]  ; %NWL%this . showdots = options [  ' showdots '  ]  ; %NWL%this . showshadow = options [  ' showshadow '  ]  ; %NWL%this . showgrid = options [  ' showgrid '  ]  ; %NWL%this . showline = options [  ' showline '  ]  ; %NWL%this . showfill = options [  ' showfill '  ]  ; %NWL%this . range = options [  ' range '  ]  ; %NWL%this . call = options [  ' call '  ]  ; %NWL%this . data = options [  ' data '  ]  ; %NWL%0
settings . tileoffset ? settings . tileoffset . y : 0%NWL%)  ; %NWL%this . numTiles = this . multiImage ? tileTextures . length : new Phaser . Point (%NWL%Phaser . Math . floor (  ( this . baseTexture . width - this . margin )  /  ( this . tileWidth - this . spacing )  )  ,%NWL%Phaser . Math . floor (  ( this . baseTexture . height - this . margin )  /  ( this . tileHeight - this . spacing )  )%NWL%)  ; %NWL%this . lastgid = this . firstgid +  ( this . multiImage ? tileTextures . length :  (  ( this . numTiles . x * this . numTiles . y ) || 1 )  )  - 1 ; %NWL%this . properties = utils . parseTiledProperties ( settings . properties )  ; %NWL%this . tileproperties =  {  }  ; %NWL%for ( var k in settings . tileproperties )  {%NWL%this . tileproperties [ k ]  = utils . parseTiledProperties ( settings . tileproperties [ k ]  )  ; %NWL%7
data : AssetGraph . resolvers . data (  )  ,%NWL%file : AssetGraph . resolvers . file (  )  ,%NWL%javascript : AssetGraph . resolvers . javascript (  )  ,%NWL%http : AssetGraph . resolvers . http (  )  ,%NWL%https : AssetGraph . resolvers . http (  )%NWL%}  ;%NWL%}%NWL%module . exports = AssetGraph ; %NWL%util . inherits ( AssetGraph , EventEmitter )  ; %NWL%AssetGraph . typeByExtension = AssetGraph . prototype . typeByExtension =  {  }  ; %NWL%AssetGraph . typeByContentType = AssetGraph . prototype . typeByContentType =  {  }  ; %NWL%9
if ( !vis && ( base . lastDim [ 0 ] ! =  = w || base . lastDim [ 1 ] ! =  = h )  )  {%NWL%base . setDimensions (  )  ;  /  / adjust panel sizes%NWL%base . gotoPage ( base . currentPage , base . playing , null ,  - 1 )  ;%NWL%}%NWL%if ( typeof ( stopTimer )  =  =  =  ' undefined '  )  { base . checkResize (  )  ;  }%NWL%}  , vis ? 2000 : 500 )  ;%NWL%}  ; %NWL%base . setDimensions = function (  )  {%NWL%base . $wrapper . find (  '  . anythingWindow ,  . anythingBase ,  . panel '  )  [ $ . fn . addBack ? ' addBack '  :  ' andSelf '  ]  (  )  . css (  { width :  '  '  , height :  '  '  }  )  ; %NWL%base . width = base . $el . width (  )  ; %NWL%base . height = base . $el . height (  )  ; %NWL%9
var RawControlFlow = require (  '  .  / control - flow '  )  ; %NWL%var promise   = require (  '  .  / promise '  )  ; %NWL%var util    = require (  '  .  / util '  )  ; %NWL%var assert   = require (  '  .  / assert '  )  ; %NWL%var should   = require (  ' should '  )  ; %NWL%var must    = require (  ' must '  )  ; %NWL%var sinon    = require (  ' sinon '  )  ; %NWL%var supertest   = require (  ' supertest '  )  ; %NWL%api . promise   = promise ; %NWL%api . promisify   = promise . promisify ; %NWL%api . promisifyAll  = promise . promisifyAll ; %NWL%9
}  ; %NWL%cubes . Measure = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . nonadditive = obj . nonadditive ; %NWL%2
mbean : SOCIAL . mbean ,%NWL%operation :  ' userInfo '  ,%NWL%arguments :  [ $scope . username ]%NWL%}  ,  {%NWL%method :  ' POST '  ,%NWL%success : function ( response )  {%NWL%$scope . isReply = true ; %NWL%value = JSON . parse ( response [  ' value '  ]  )  ; %NWL%$scope . id = value [  ' id '  ]  ; %NWL%$scope . name = value [  ' name '  ]  ; %NWL%$scope . screenName = value [  ' screenName '  ]  ; %NWL%8
var conf = require (  '  .  / config '  )  . conf ; %NWL%var time = require (  '  .  / utils '  )  . time ; %NWL%exports . OpenTok = require (  ' opentok '  )  ; %NWL%function TokBox ( settings , statsdClient )  {%NWL%this . credentials = settings . credentials ; %NWL%if ( settings . retryOnError =  =  = undefined )  {%NWL%settings . retryOnError = 3 ;%NWL%}%NWL%this . statsdClient = statsdClient ; %NWL%this . retryOnError = settings . retryOnError ; %NWL%this . tokenDuration = settings . tokenDuration ; %NWL%4
lodash . intersection = arrays . intersection ; %NWL%lodash . invert = objects . invert ; %NWL%lodash . invoke = collections . invoke ; %NWL%lodash . keys = objects . keys ; %NWL%lodash . map = collections . map ; %NWL%lodash . mapValues = objects . mapValues ; %NWL%lodash . max = collections . max ; %NWL%lodash . memoize = functions . memoize ; %NWL%lodash . merge = objects . merge ; %NWL%lodash . min = collections . min ; %NWL%lodash . omit = objects . omit ; %NWL%1
}%NWL%return ;%NWL%}%NWL%UIFanMenu . prototype . collapse = function (  )  {%NWL%var origin = this . getOriginElement (  )  ; %NWL%this . getWindow (  )  . ungrab ( this )  ; %NWL%if ( origin )  {%NWL%this . x = this . x + origin . x ; %NWL%this . y = this . y + origin . y ; %NWL%this . w = origin . w ; %NWL%this . h = origin . h ; %NWL%9
}  ; %NWL%self . checkIsHDDisplay = checkIsHDDisplay = function (  )  {%NWL%return global . devicePixelRatio ! =  = undefined && devicePixelRatio > 1 ? true : false ;%NWL%}  ; %NWL%self . checkIsTouchMode = checkIsTouchMode = function (  )  {%NWL%return isTouchMode ;%NWL%}  ; %NWL%self . checkIsExistsTapDelay = checkIsExistsTapDelay = function (  )  {%NWL%return false ;%NWL%}  ; %NWL%self . getBrowserInfo = getBrowserInfo = function (  )  {%NWL%1
arr . readUInt8 = BP . readUInt8%NWL%arr . readUInt16LE = BP . readUInt16LE%NWL%arr . readUInt16BE = BP . readUInt16BE%NWL%arr . readUInt32LE = BP . readUInt32LE%NWL%arr . readUInt32BE = BP . readUInt32BE%NWL%arr . readInt8 = BP . readInt8%NWL%arr . readInt16LE = BP . readInt16LE%NWL%arr . readInt16BE = BP . readInt16BE%NWL%arr . readInt32LE = BP . readInt32LE%NWL%arr . readInt32BE = BP . readInt32BE%NWL%arr . readFloatLE = BP . readFloatLE%NWL%0
if ( anchor =  = null ) continue ; %NWL%this . _updateAnchorNode ( node , anchor )  ;%NWL%}%NWL%}  ,%NWL%_updateAnchorNode : function ( node , anchor )%NWL%{%NWL%if ( anchor =  = null ) return ; %NWL%node . x = anchor . x ; %NWL%node . y = anchor . y ; %NWL%node . zIndex = anchor . zIndex ; %NWL%node . rotation = anchor . rotation ; %NWL%7
inGlobalTouch = false ; %NWL%$ ( window )  . bind (  " touchstart "  + eventClassName , function ( e )  {%NWL%inGlobalTouch = true ;%NWL%}  )  ; %NWL%$ ( window )  . bind (  " touchend "  + eventClassName , function ( e )  {%NWL%inGlobalTouch = false ;%NWL%}  )  ; %NWL%$this . bind (  " touchstart "  + eventClassName , function ( e )  {%NWL%var touch = e . originalEvent . targetTouches [ 0 ]  ; %NWL%startCoords . pageX = touch . pageX ; %NWL%startCoords . pageY = touch . pageY ; %NWL%9
events = events || {  }  ; %NWL%if ( ! (  ' data ' in events )  )%NWL%events . data = proxyEvent (  ' data '  )  ; %NWL%if ( ! (  ' end ' in events )  )%NWL%events . end = proxyEvent (  ' end '  )  ; %NWL%if ( ! (  ' error ' in events )  )%NWL%events . error = proxyEvent (  ' error '  )  ; %NWL%if ( ! (  ' close ' in events )  )%NWL%events . close = proxyEvent (  ' close '  )  ; %NWL%if ( ! (  ' fd ' in events )  )%NWL%events . fd = proxyEvent (  ' fd '  )  ; %NWL%2
control = bootstrap . getStatic ( locals . value )  ;%NWL%} else {%NWL%let tag =  ' textarea '  ; %NWL%if ( locals . type ! =  =  ' textarea '  )  {%NWL%tag =  ' input '  ; %NWL%attrs . type = locals . type ;%NWL%}%NWL%attrs . className = t . mixin (  {  }  , attrs . className )  ; %NWL%attrs . className [  ' form - control '  ]  = true ; %NWL%attrs . disabled = locals . disabled ; %NWL%attrs . placeholder = locals . placeholder ; %NWL%5
this . LARGE =  " large "  ; %NWL%this . XLARGE =  " xlarge "  ; %NWL%this . currentpopup = function (  )  {%NWL%return this . popups [ this . popups . length - 1 ]  ;%NWL%}  ; %NWL%this . popups =  [  ]  ;%NWL%}  ; %NWL%popupManager = new PopupManager (  )  ; %NWL%function Popup ( data )  {%NWL%this . title = data . title ; %NWL%this . subtitle = data . subtitle ; %NWL%9
}%NWL%if ( this . filename && options . nodeWebkitAppName )  {%NWL%console . log (  "  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  "  )  ; %NWL%console . log (  " WARNING : The nodeWebkitAppName option is deprecated "  )  ; %NWL%console . log (  " To get the path to the directory where Node Webkit stores the data "  )  ; %NWL%console . log (  " for your app , use the internal nw . gui module like this "  )  ; %NWL%console . log (  " require (  ' nw . gui '  )  . App . dataPath "  )  ; %NWL%console . log (  " See https :  /  / github . com / rogerwang / node - webkit / issues / 500 "  )  ; %NWL%console . log (  "  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  =  "  )  ; %NWL%this . filename = Persistence . getNWAppFilename ( options . nodeWebkitAppName , this . filename )  ; %NWL%this . tempFilename = Persistence . getNWAppFilename ( options . nodeWebkitAppName , this . tempFilename )  ; %NWL%9
clockStep : createPropertyDescriptor (  ' clockStep '  )  ,%NWL%multiplier : createPropertyDescriptor (  ' multiplier '  )%NWL%}  )  ; %NWL%DataSourceClock . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new DataSourceClock (  )  ;%NWL%}%NWL%result . startTime = this . startTime ; %NWL%result . stopTime = this . stopTime ; %NWL%result . currentTime = this . currentTime ; %NWL%result . clockRange = this . clockRange ; %NWL%7
}%NWL%if ( responseDoc ! =  = null && responseDoc ! =  = undefined )  {%NWL%var nameValue = responseDoc [  ' name '  ]  ; %NWL%if ( nameValue ! =  = null && nameValue ! =  = undefined )  {%NWL%var nameInstance = nameValue ; %NWL%result . name = nameInstance ;%NWL%}%NWL%var propertiesValue = responseDoc [  ' properties '  ]  ; %NWL%if ( propertiesValue ! =  = null && propertiesValue ! =  = undefined )  {%NWL%var propertiesInstance =  {  }  ; %NWL%result . properties = propertiesInstance ; %NWL%5
var skinMatricesArray = this . skeleton . getSubSkinMatrices ( this . __GUID__ , this . joints )  ; %NWL%material . shader . setUniformBySemantic ( _gl ,  ' SKIN_MATRIX '  , skinMatricesArray )  ;%NWL%}%NWL%return Renderable . prototype . render . call ( this , _gl , globalMaterial )  ;%NWL%}%NWL%}  )  ; %NWL%Mesh . POINTS = glenum . POINTS ; %NWL%Mesh . LINES = glenum . LINES ; %NWL%Mesh . LINE_LOOP = glenum . LINE_LOOP ; %NWL%Mesh . LINE_STRIP = glenum . LINE_STRIP ; %NWL%Mesh . TRIANGLES = glenum . TRIANGLES ; %NWL%6
y : 0 ,%NWL%width : 8 ,%NWL%height : 8 ,%NWL%radius : 0%NWL%}%NWL%}%NWL%}  ,%NWL%updatePlainBBox : function ( plain )  {%NWL%var attr = this . attr ; %NWL%plain . x = attr . x ; %NWL%plain . y = attr . y ; %NWL%9
this . pos = i ; %NWL%break ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%this . readUInt8 = function readUInt8 ( bigEndian )%NWL%{%NWL%return this . readInteger ( 1 , false , bigEndian )  ;%NWL%}  ; %NWL%this . readInt8 = function readInt8 ( bigEndian )%NWL%6
﻿stockModule . controller (  " cellEditorController "  , cellEditorController )  ; %NWL%function cellEditorController ( $scope )  {%NWL%' use strict '  ; %NWL%var self = this ; %NWL%self . keyUpEvent = $scope . keyUpEvent ; %NWL%self . column = $scope . column ; %NWL%self . item = $scope . item ; %NWL%self . today = new Date (  )  ; %NWL%self . datePickerOpen = false ; %NWL%self . openDatePicker = _openDatePicker ; %NWL%self . fireKeyUpEvent = _fireKeyUpEvent ; %NWL%9
baseOptions . headerRowHeight = 0 ;%NWL%}%NWL%else {%NWL%baseOptions . headerRowHeight = typeof ( baseOptions . headerRowHeight ) ! =  =  " undefined " ? baseOptions . headerRowHeight : 30 ;%NWL%}%NWL%baseOptions . rowHeight = baseOptions . rowHeight || 30 ; %NWL%baseOptions . minRowsToShow = typeof ( baseOptions . minRowsToShow ) ! =  =  " undefined " ? baseOptions . minRowsToShow : 10 ; %NWL%baseOptions . showGridFooter = baseOptions . showGridFooter =  =  = true ; %NWL%baseOptions . showColumnFooter = baseOptions . showColumnFooter =  =  = true ; %NWL%baseOptions . columnFooterHeight = typeof ( baseOptions . columnFooterHeight ) ! =  =  " undefined " ? baseOptions . columnFooterHeight : 30 ; %NWL%baseOptions . gridFooterHeight = typeof ( baseOptions . gridFooterHeight ) ! =  =  " undefined " ? baseOptions . gridFooterHeight : 30 ; %NWL%3
return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . registerHandler '  ; %NWL%wrapped . unregisterHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . unregisterHandler '  ; %NWL%wrapped . send . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . send '  ; %NWL%wrapped . publish . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . publish '  ; %NWL%wrapped . getConnectionState . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . getConnectionState '  ; %NWL%wrapped . isValidSession . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . isValidSession '  ; %NWL%wrapped . login . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . login '  ; %NWL%4
}%NWL%else%NWL%{%NWL%actor . x = actor . org_x ; %NWL%actor . y = actor . org_y ;%NWL%}%NWL%actor . rotation = actor . org_rotation ; %NWL%actor . scale_x = actor . org_scale_x ; %NWL%actor . scale_y = actor . org_scale_y ; %NWL%actor . depth = actor . org_depth ; %NWL%actor . opacity = actor . org_opacity ; %NWL%3
}  ,%NWL%translateBy : function ( offset )  {%NWL%this . left +  = offset . x ; %NWL%this . right +  = offset . x ; %NWL%this . top +  = offset . y ; %NWL%this . bottom +  = offset . y ; %NWL%return this ;%NWL%}  ,%NWL%round : function (  )  {%NWL%this . top = Math . round ( this . top )  ; %NWL%this . right = Math . round ( this . right )  ; %NWL%9
}%NWL%}  ,%NWL%restoreScrollPositions : function (  )%NWL%{%NWL%var elements = this . elementsToRestoreScrollPositionsFor (  )  ; %NWL%for ( var i = 0 ; i < elements . length ;  +  + i )  {%NWL%var container = elements [ i ]  ; %NWL%if ( container . _scrollTop )%NWL%container . scrollTop = container . _scrollTop ; %NWL%if ( container . _scrollLeft )%NWL%container . scrollLeft = container . _scrollLeft ; %NWL%8
var Base = __dependency1__ [  " default "  ]  ; %NWL%var Configuration = __dependency2__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%serverTokenEndpoint :  '  / token '  ,%NWL%serverTokenRevocationEndpoint : null ,%NWL%refreshAccessTokens : true ,%NWL%_refreshTokenTimeout : null ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint    = Configuration . serverTokenEndpoint ; %NWL%this . serverTokenRevocationEndpoint = Configuration . serverTokenRevocationEndpoint ; %NWL%this . refreshAccessTokens    = Configuration . refreshAccessTokens ; %NWL%8
if ( currentFileInfo && currentFileInfo . currentDirectory && ! / ^\ /  /  . test ( file )  )  {%NWL%href = less . modules . path . join ( currentFileInfo . currentDirectory , file )  ;%NWL%}%NWL%var path = less . modules . path . dirname ( href )  ; %NWL%var newFileInfo =  {%NWL%currentDirectory : path +  '  /  '  ,%NWL%filename : href%NWL%}  ; %NWL%if ( currentFileInfo )  {%NWL%newFileInfo . entryPath = currentFileInfo . entryPath ; %NWL%newFileInfo . rootpath = currentFileInfo . rootpath ; %NWL%9
model :  '  = model '%NWL%}  ,%NWL%controller : function ( $scope )  {%NWL%$scope . content =  [  ]  ; %NWL%$scope . theid = Math . random (  )  . toString ( 36 )  . substring ( 7 )  ; %NWL%$scope . wrapCol = function ( r )  {%NWL%var ret =  {  }  ; %NWL%ret . payload =  [  ]  ; %NWL%ret . theclass = r . theclass ; %NWL%ret . thestyle = r . thestyle ; %NWL%ret . width  = r . width ; %NWL%8
startTime : new Date (  )  ,%NWL%error : null%NWL%}  ; %NWL%function MockDownload ( params )  {%NWL%params = params || {  }  ; %NWL%this . id = params . id || ' 0 '  ; %NWL%this . totalBytes = params . totalBytes || DEFAULT_PARAMS . totalBytes ; %NWL%this . currentBytes = params . currentBytes || DEFAULT_PARAMS . currentBytes ; %NWL%this . url = params . url || DEFAULT_PARAMS . url ; %NWL%this . path = params . path || DEFAULT_PARAMS . path ; %NWL%this . state = params . state || DEFAULT_PARAMS . state ; %NWL%6
message = messageType + MESSAGE_DELIMITER + message ; %NWL%_log (  ' Sending message :  '  + message )  ; %NWL%_customMessageBus . broadcast ( message )  ;%NWL%}  ; %NWL%_log (  ' Initializing receiver '  )  ; %NWL%var castReceiverManager = cast . receiver . CastReceiverManager . getInstance (  )  ; %NWL%_customMessageBus = castReceiverManager . getCastMessageBus ( _config [  ' namespace '  ]  )  ; %NWL%_customMessageBus . onMessage = _onReceiveMessage ; %NWL%castReceiverManager . onReady = _onCastReceiverReady ; %NWL%castReceiverManager . onSenderConnected = _onSenderConnected ; %NWL%castReceiverManager . onSenderDisconnected = _onSenderDisconnected ; %NWL%9
}  ; %NWL%_ . inherits ( errors . ConnectionFault , ErrorAbstract )  ; %NWL%errors . NoConnections = function NoConnections ( msg )  {%NWL%ErrorAbstract . call ( this , msg || ' No Living connections '  , errors . NoConnections )  ;%NWL%}  ; %NWL%_ . inherits ( errors . NoConnections , ErrorAbstract )  ; %NWL%errors . Generic = function Generic ( msg )  {%NWL%ErrorAbstract . call ( this , msg || ' Generic Error '  , errors . Generic )  ;%NWL%}  ; %NWL%_ . inherits ( errors . Generic , ErrorAbstract )  ; %NWL%errors . RequestTimeout = function RequestTimeout ( msg )  {%NWL%2
var edge = new d3_geom_voronoiEdge ( lSite , null )  ; %NWL%edge . a = va ; %NWL%edge . b = vb ; %NWL%d3_geom_voronoiEdges . push ( edge )  ; %NWL%return edge ;%NWL%}%NWL%function d3_geom_voronoiSetEdgeEnd ( edge , lSite , rSite , vertex )  {%NWL%if ( !edge . a && !edge . b )  {%NWL%edge . a = vertex ; %NWL%edge . l = lSite ; %NWL%edge . r = rSite ; %NWL%9
}%NWL%Y . Array . each ( next , function ( u )  {%NWL%if ( merge )  {%NWL%output [ ns ]  . push ( u )  ;%NWL%} else {%NWL%output [ ns ]  =  [ u ]  ;%NWL%}%NWL%}  )  ;%NWL%}  )  ; %NWL%output . hash = incoming . hash ; %NWL%output . search = incoming . search ; %NWL%9
this . offsetX = e . offsetX ! =  = undefined ? e . offsetX : e . layerX ; %NWL%this . offsetY = e . offsetY ! =  = undefined ? e . offsetY : e . layerY ; %NWL%this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ; %NWL%this . button = e . button ; %NWL%this . keyCode = e . keyCode || 0 ; %NWL%this . charCode = e . charCode || ( type =  =  ' keypress ' ? e . keyCode : 0 )  ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%this . altKey = e . altKey ; %NWL%6
}  )  ; %NWL%entry . commentLength = data . view . getUint16 ( index + 32 , true )  ; %NWL%entry . directory =  (  ( data . view . getUint8 ( index + 38 ) & 0x10 )  =  = 0x10 )  ; %NWL%entry . offset = data . view . getUint32 ( index + 42 , true )  ; %NWL%filename = getString ( data . array . subarray ( index + 46 , index + 46 + entry . filenameLength )  )  ; %NWL%entry . filename =  (  ( entry . bitFlag & 0x0800 )  =  =  = 0x0800 ) ? decodeUTF8 ( filename )  : decodeASCII ( filename )  ; %NWL%if ( !entry . directory && entry . filename . charAt ( entry . filename . length - 1 )  =  =  "  /  "  )%NWL%entry . directory = true ; %NWL%comment = getString ( data . array . subarray ( index + 46 + entry . filenameLength + entry . extraFieldLength , index + 46%NWL%+ entry . filenameLength + entry . extraFieldLength + entry . commentLength )  )  ; %NWL%entry . comment =  (  ( entry . bitFlag & 0x0800 )  =  =  = 0x0800 ) ? decodeUTF8 ( comment )  : decodeASCII ( comment )  ; %NWL%5
lodash . isDate = objects . isDate ; %NWL%lodash . isElement = objects . isElement ; %NWL%lodash . isEmpty = objects . isEmpty ; %NWL%lodash . isEqual = objects . isEqual ; %NWL%lodash . isFinite = objects . isFinite ; %NWL%lodash . isFunction = objects . isFunction ; %NWL%lodash . isNaN = objects . isNaN ; %NWL%lodash . isNull = objects . isNull ; %NWL%lodash . isNumber = objects . isNumber ; %NWL%lodash . isObject = objects . isObject ; %NWL%lodash . isPlainObject = objects . isPlainObject ; %NWL%0
}%NWL%availableEntry . off = storedEntry . off || false ; %NWL%µb . assets . setHomeURL ( location , availableEntry . homeURL )  ; %NWL%if ( storedEntry . entryCount ! =  = undefined )  {%NWL%availableEntry . entryCount = storedEntry . entryCount ;%NWL%}%NWL%if ( storedEntry . entryUsedCount ! =  = undefined )  {%NWL%availableEntry . entryUsedCount = storedEntry . entryUsedCount ;%NWL%}%NWL%if ( availableEntry . title =  =  =  '  ' && storedEntry . title ! =  =  '  '  )  {%NWL%availableEntry . title = storedEntry . title ; %NWL%4
canvas . focus (  )  ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%qt . Button = function ( id , display , access , title , instance )  {%NWL%var t = this ; %NWL%t . id = id ; %NWL%t . display = display ; %NWL%t . access = access ; %NWL%t . title = title || '  '  ; %NWL%t . instance = instance || '  '  ; %NWL%9
}  )  ; %NWL%runner . on (  ' suite '  , function ( suite )  {%NWL%stats . suites = stats . suites || 0 ; %NWL%suite . root || stats . suites +  +  ;%NWL%}  )  ; %NWL%runner . on (  ' test end '  , function ( test )  {%NWL%stats . tests = stats . tests || 0 ; %NWL%stats . tests +  +  ;%NWL%}  )  ; %NWL%runner . on (  ' pass '  , function ( test )  {%NWL%stats . passes = stats . passes || 0 ; %NWL%2
}  ,%NWL%analogousScheme : function (  )  {%NWL%return this . schemeFromDegrees (  [ 0 , 30 , 60 , 90 , 120 , 150 ]  )  ;%NWL%}  ,%NWL%fromObject : function ( o )  {%NWL%if ( o . hasOwnProperty (  ' hue '  ) &&%NWL%o . hasOwnProperty (  ' saturation '  ) &&%NWL%o . hasOwnProperty (  ' value '  )  )  {%NWL%var hsv = factories . HSV (  )  ; %NWL%hsv . hue = o . hue ; %NWL%hsv . saturation = o . saturation ; %NWL%9
}%NWL%if ( !uvm ) uvm = undef ; %NWL%var prim =  {%NWL%material : mat ,%NWL%uvmapper : uvm||local_uvm%NWL%}  ; %NWL%if ( ptype =  =  =  " box " || ptype =  =  =  " cube "  )  {%NWL%prim . size = meshKit . getFloatNode ( proc ,  " size "  )  ; %NWL%obj . booleanAdd ( CubicVR . primitives . box ( prim )  , trans )  ;%NWL%} else if ( ptype =  =  =  " sphere "  )  {%NWL%prim . radius = meshKit . getFloatNode ( proc ,  " radius "  )  ; %NWL%7
if ( scope . svgXAxis =  =  = undefined || scope . svgXAxis =  =  = null )  {%NWL%scope . svgXAxis = scope . svg . append (  " g "  )  . attr (  " class "  ,  " axis "  )%NWL%. call ( xAxis )  ; %NWL%scope . svgXAxisLabel = scope . svg . append (  " g "  )%NWL%. attr (  " class "  ,  " axis - label "  )%NWL%. append (  " text "  )%NWL%. attr (  " text - anchor "  , scope . axis . x . labelPos )%NWL%. attr (  " x "  , xLabelPos )%NWL%. attr (  " y "  , scope . h + 34 )  ;%NWL%}%NWL%if ( scope . svgYAxis =  =  = undefined || scope . svgYAxis =  =  = null )  {%NWL%0
project . produceModule ( moduleNode )  ; %NWL%if ( log . error . count ! =  = 0 )  { log . throwControled (  " #log . error . count errors during compilation "  )  }  ; %NWL%return moduleNode ;%NWL%}  ; %NWL%module . exports . compileModule = compileModule ; %NWL%function Project ( filename , options )  {%NWL%this . recurseLevel = 0 ; %NWL%if ( !options ) options =  {  }  ; %NWL%if ( options . verbose =  =  = undefined ) options . verbose = 1 ; %NWL%if ( options . warning =  =  = undefined ) options . warning = 1 ; %NWL%if ( options . comments =  =  = undefined ) options . comments = 1 ; %NWL%8
this . endLabel = endLabel ;%NWL%}%NWL%QBasic . CodeGenerator = function ( prevGenerator )  {%NWL%prevGenerator = prevGenerator || {  }  ; %NWL%this . instructions = prevGenerator . instructions || [  ]  ; %NWL%this . instructions_start = prevGenerator . instructions ?%NWL%prevGenerator . instructions . length : 0 ; %NWL%this . data = prevGenerator . data || [  ]  ; %NWL%this . shared = prevGenerator . shared || {  }  ; %NWL%this . labels = prevGenerator . labels || [  ]  ; %NWL%this . labelMap = prevGenerator . labelMap || {  }  ; %NWL%8
str_number =  '  -  '  + Math . abs ( number . toFixed ( _getOption (  ' numFractionalDigits '  )  )  )  ;%NWL%}%NWL%return str_number ;%NWL%}%NWL%function _startAnimation ( options )  {%NWL%if ( typeof options =  =  ' undefined ' && false =  = _getOption (  ' animating '  )  ) return false ;  /  / if trying to resume from pause without first starting return false%NWL%if ( typeof options ! =  =  ' undefined '  )%NWL%{%NWL%if ( typeof options . easing =  =  ' function '  ) _setOption (  ' easing '  , options . easing )  ; %NWL%if ( typeof options . onAnimationStarted =  =  ' function '  ) _setOption (  ' onAnimationStarted '  , options . onAnimationStarted )  ; %NWL%if ( typeof options . onAnimationStopped =  =  ' function '  ) _setOption (  ' onAnimationStopped '  , options . onAnimationStopped )  ; %NWL%8
function update (  )  {%NWL%var i = numDiscs ,%NWL%disc = null ; %NWL%while ( i -  -  )  {%NWL%disc = discs [ i ]  ; %NWL%if ( disc . x + disc . velocityX + disc . radius > topContext . canvas . width ||%NWL%disc . x + disc . velocityX - disc . radius < 0 )%NWL%disc . velocityX =  - disc . velocityX ; %NWL%if ( disc . y + disc . velocityY + disc . radius > topContext . canvas . height ||%NWL%disc . y + disc . velocityY - disc . radius  < 0 )%NWL%disc . velocityY =  - disc . velocityY ; %NWL%7
self . cur +  +  ; %NWL%self . row +  +  ; %NWL%return true ;%NWL%}%NWL%}  ; %NWL%lineparser . followIdentifierLetter = this . followIdentifierLetter = function (  )  {%NWL%var c ; %NWL%c = self . data [ self . cur ]  ; %NWL%return ( c =  =  =  ' $ ' || c =  =  =  ' _ ' || (  ' a '  <  = c && c <  ' z '  ) || (  ' A '  <  = c && c <  =  ' Z '  ) || (  ' 0 '  <  = c && c <  =  ' 9 '  )  ) && c ;%NWL%}  ; %NWL%lineparser . digit = this . digit = function (  )  {%NWL%5
if ( !pattern )  {%NWL%throw new Error (  " must provide pattern "  )%NWL%}%NWL%if ( options . matchBase && - 1 =  =  = pattern . indexOf (  "  /  "  )  )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%9
exports . assert						 = require . resolve (  ' assert /  '  )  ; %NWL%exports . buffer						 = require . resolve (  ' buffer /  '  )  ; %NWL%exports . child_process				 = null ; %NWL%exports . cluster						 = null ; %NWL%exports . console						 = require . resolve (  ' console - browserify '  )  ; %NWL%exports . constants					 = require . resolve (  ' constants - browserify '  )  ; %NWL%exports . crypto						 = require . resolve (  ' crypto - browserify '  )  ; %NWL%exports . dgram						 = null ; %NWL%exports . dns							 = null ; %NWL%exports . domain						 = require . resolve (  ' domain - browser '  )  ; %NWL%exports . events						 = require . resolve (  ' events /  '  )  ; %NWL%0
} else {%NWL%var split = url . split (  ' ? '  )  ; %NWL%this . url = split [ 0 ]  ; %NWL%this . query = split . length > 1 ? normalizeQuery ( split [ 1 ]  )  : undefined ;%NWL%}%NWL%this . data = normalizeQuery ( stubData )  ; %NWL%this . method = method ; %NWL%this . andReturn = function ( options )  {%NWL%this . status = options . status || 200 ; %NWL%this . contentType = options . contentType ; %NWL%this . response = options . response ; %NWL%9
subtract : function ( c1 , c2 )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red - c2 . red ; %NWL%result . green = c1 . green - c2 . green ; %NWL%result . blue = c1 . blue - c2 . blue ; %NWL%return result ;%NWL%}  ,%NWL%multiply : function ( c1 , c2 )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red * c2 . red ; %NWL%result . green = c1 . green * c2 . green ; %NWL%9
}  ,%NWL%_copySpecialProperties : function ( uiCheckBox )  {%NWL%if ( uiCheckBox instanceof ccui . CheckBox )  {%NWL%this . loadTextureBackGround ( uiCheckBox . _backGroundFileName , uiCheckBox . _backGroundTexType )  ; %NWL%this . loadTextureBackGroundSelected ( uiCheckBox . _backGroundSelectedFileName , uiCheckBox . _backGroundSelectedTexType )  ; %NWL%this . loadTextureFrontCross ( uiCheckBox . _frontCrossFileName , uiCheckBox . _frontCrossTexType )  ; %NWL%this . loadTextureBackGroundDisabled ( uiCheckBox . _backGroundDisabledFileName , uiCheckBox . _backGroundDisabledTexType )  ; %NWL%this . loadTextureFrontCrossDisabled ( uiCheckBox . _frontCrossDisabledFileName , uiCheckBox . _frontCrossDisabledTexType )  ; %NWL%this . setSelected ( uiCheckBox . _isSelected )  ; %NWL%this . _checkBoxEventListener = uiCheckBox . _checkBoxEventListener ; %NWL%this . _checkBoxEventSelector = uiCheckBox . _checkBoxEventSelector ; %NWL%9
localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%addCustomOperation ( localElem )  ; %NWL%return onElemRestangularized ( localElem , false , route )  ;%NWL%}%NWL%function restangularizeCollection ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = true ; %NWL%localElem . post = _ . bind ( postFunction , localElem , null )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%0
return require (  "  .  / listener / mac "  )  ;%NWL%}%NWL%}  ; %NWL%function Project ( options )  {%NWL%var store ; %NWL%if ( options =  = null )  {%NWL%options =  {  }  ;%NWL%}%NWL%this . root = File . absolutePath ( options . root )  ; %NWL%this . namespace = options . namespace ; %NWL%this . watchfile = File . absolutePath ( options . watchfile )  ; %NWL%8
request = this . createRequest (  )  ; %NWL%cpmm . sendAsyncMessage (  " Contact : Remove "  ,  { id : aRecord . id ,%NWL%requestID : this . getRequestId ( request )  }  )  ; %NWL%return request ;%NWL%} else {%NWL%throw Components . results . NS_ERROR_NOT_IMPLEMENTED ;%NWL%}%NWL%}  ,%NWL%_setMetaData : function ( aNewContact , aRecord )  {%NWL%aNewContact . id = aRecord . id ; %NWL%aNewContact . published = aRecord . published ; %NWL%9
this . settings = settings ; %NWL%this . fileList =  [  ]  ; %NWL%this . json =  {  }  ; %NWL%this . appPrefix =  ' app :  /  /  '  ; %NWL%this . appURL = this . appPrefix + appDomain +  '  / resources /  '  ;%NWL%}  ; %NWL%Resources . prototype . getResources = function ( conf )  {%NWL%var operatorJSON =  {  }  ; %NWL%operatorJSON . default_contacts = this . addFile ( conf . default_contacts )  ; %NWL%operatorJSON . support_contacts = this . addFile ( conf . support_contacts )  ; %NWL%operatorJSON . network_type = this . addFile ( conf . network_type )  ; %NWL%8
var regexp =  /  (  [ 0 - 9 ]  +  )  [  ,  ]  +  (  [ 0 - 9 ]  +  )  [  ,  ]  +  (  [ 0 - 9 ]  +  )  /  ; %NWL%var array = regexp . exec ( c )  ; %NWL%for ( i = 1 ; i < 4 ; i +  +  ) hex +  =  (  ' 0 '  + parseInt ( array [ i ]  )  . toString ( 16 )  )  . slice (  - 2 )  ; %NWL%return ' # '  + hex ;%NWL%}%NWL%function parseOptions ( options , settings )  {%NWL%var options = options || '  '  ; %NWL%var s =  { sizex : 5 , sizey : 5 , tl : false , tr : false , bl : false , br : false , webkit : true , mozilla : true , transparent : false }  ; %NWL%if ( settings )  {%NWL%s . sizex = settings . sizex ; %NWL%s . sizey = settings . sizey ; %NWL%9
{%NWL%initialize : function ( options )  {%NWL%EventTarget . prototype . initialize . call ( this )  ; %NWL%Trace . sysout (  " firebug . initialize ; options :  "  , options )  ; %NWL%this . chromes = new Map (  )  ; %NWL%this . onToolboxCreated = this . onToolboxCreated . bind ( this )  ; %NWL%this . onToolboxReady = this . onToolboxReady . bind ( this )  ; %NWL%this . onToolboxDestroy = this . onToolboxDestroy . bind ( this )  ; %NWL%this . onToolboxClosed = this . onToolboxClosed . bind ( this )  ; %NWL%this . updateOption = this . updateOption . bind ( this )  ; %NWL%this . onToolRegistered = this . onToolRegistered . bind ( this )  ; %NWL%5
this . timer2Counter =  (  ( this . timer2Counter | 0 )  + 1 ) | 0 ; %NWL%if (  ( this . timer2Counter | 0 )  > 0xFFFF )  {%NWL%this . timer2Counter = this . timer2Reload | 0 ; %NWL%this . timer2ExternalTriggerCheck (  )  ; %NWL%this . timer3ClockUpTickCheck (  )  ;%NWL%}%NWL%}%NWL%}%NWL%GameBoyAdvanceTimer . prototype . timer3ClockUpTickCheck = function (  )  {%NWL%if ( this . timer3UseChainedClocks )  {%NWL%this . timer3Counter =  (  ( this . timer3Counter | 0 )  + 1 ) | 0 ; %NWL%0
exports . cp = common . wrap (  ' cp '  , _cp )  ; %NWL%var _rm = require (  '  .  / src / rm '  )  ; %NWL%exports . rm = common . wrap (  ' rm '  , _rm )  ; %NWL%var _mv = require (  '  .  / src / mv '  )  ; %NWL%exports . mv = common . wrap (  ' mv '  , _mv )  ; %NWL%var _mkdir = require (  '  .  / src / mkdir '  )  ; %NWL%exports . mkdir = common . wrap (  ' mkdir '  , _mkdir )  ; %NWL%var _test = require (  '  .  / src / test '  )  ; %NWL%exports . test = common . wrap (  ' test '  , _test )  ; %NWL%var _cat = require (  '  .  / src / cat '  )  ; %NWL%exports . cat = common . wrap (  ' cat '  , _cat )  ; %NWL%0
chartObject . clubdata_maximum_nodes = PykCharts [  ' boolean '  ]  ( chartObject . clubdata_enable ) && options . clubdata_maximum_nodes ? options . clubdata_maximum_nodes : oneDimensionalCharts . clubdata_maximum_nodes ; %NWL%chartObject . clubdata_always_include_data_points = PykCharts [  ' boolean '  ]  ( chartObject . clubdata_enable ) && options . clubdata_always_include_data_points ? options . clubdata_always_include_data_points :  [  ]  ; %NWL%chartObject . transition_duration = options . transition_duration ? options . transition_duration : functionality . transition_duration ; %NWL%chartObject . pointer_overflow_enable = options . pointer_overflow_enable ? options . pointer_overflow_enable . toLowerCase (  )  : stylesheet . pointer_overflow_enable ; %NWL%chartObject . background_color = options . background_color ? options . background_color : stylesheet . background_color ; %NWL%chartObject . chart_color = options . chart_color ? options . chart_color : stylesheet . chart_color ; %NWL%chartObject . highlight_color = options . highlight_color ? options . highlight_color : stylesheet . highlight_color ; %NWL%chartObject . fullscreen_enable = options . fullscreen_enable ? options . fullscreen_enable : stylesheet . fullscreen_enable ; %NWL%chartObject . loading_type = options . loading_type ? options . loading_type : stylesheet . loading_type ; %NWL%chartObject . loading_source = options . loading_source ? options . loading_source : stylesheet . loading_source ; %NWL%chartObject . tooltip_enable = options . tooltip_enable ? options . tooltip_enable . toLowerCase (  )  : stylesheet . tooltip_enable ; %NWL%3
exports . createWebSiteManagementClient = azureWebSite . createWebSiteManagementClient ; %NWL%exports . createWebSiteExtensionsClient = azureWebSite . createWebSiteExtensionsClient ; %NWL%exports . ScmService = azureWebSite . ScmService ; %NWL%exports . createScmService = azureWebSite . createScmService ; %NWL%var azureCompute = require (  ' azure - mgmt - compute '  )  ; %NWL%exports . ComputeManagementClient = azureCompute . ComputeManagementClient ; %NWL%exports . createComputeManagementClient = azureCompute . createComputeManagementClient ; %NWL%var resourceManagement = require (  ' azure - mgmt - resource '  )  ; %NWL%exports . ResourceManagementClient = resourceManagement . ResourceManagementClient ; %NWL%exports . createResourceManagementClient = resourceManagement . createResourceManagementClient ; %NWL%exports . createResourceIdentity = resourceManagement . createResourceIdentity ; %NWL%8
return ;%NWL%}%NWL%if ( lineData . prompt && match . start <  = prompt . index )  {%NWL%match . value = value = value . substr ( prompt . index - match . start )  ; %NWL%match . start = prompt . index ; %NWL%if ( match . start > column || !value )%NWL%return ; %NWL%return ;%NWL%}%NWL%match . command = prompt . command ; %NWL%match . args = prompt . args ; %NWL%9
sum +  = m1 [ x ]  [ z ]  * m2 [ z ]  [ y ]  ;%NWL%}%NWL%result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%8
]  , function ( messages , objects , lib , mProblemsExplorer , mSlideout )  {%NWL%var SlideoutViewMode = mSlideout . SlideoutViewMode ; %NWL%function ProblemsView ( options , slideout )  {%NWL%if ( slideout )  {%NWL%SlideoutViewMode . call ( this , slideout )  ;%NWL%}%NWL%var parentId = options . parentId ? options . parentId :  " orion . PropertyPanel . container "  ; %NWL%this . _parent = lib . node ( parentId )  ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . commandRegistry = options . commandRegistry ; %NWL%this . preferences = options . preferences ; %NWL%8
lodash . every = collections . every ; %NWL%lodash . find = collections . find ; %NWL%lodash . findIndex = arrays . findIndex ; %NWL%lodash . findKey = objects . findKey ; %NWL%lodash . findLast = collections . findLast ; %NWL%lodash . findLastIndex = arrays . findLastIndex ; %NWL%lodash . findLastKey = objects . findLastKey ; %NWL%lodash . has = objects . has ; %NWL%lodash . identity = utilities . identity ; %NWL%lodash . indexOf = arrays . indexOf ; %NWL%lodash . isArguments = objects . isArguments ; %NWL%3
day :   getValue ( $attrs . dayFormat ,   dtConfig . dayFormat )  ,%NWL%month :   getValue ( $attrs . monthFormat ,   dtConfig . monthFormat )  ,%NWL%year :   getValue ( $attrs . yearFormat ,   dtConfig . yearFormat )  ,%NWL%dayHeader :  getValue ( $attrs . dayHeaderFormat ,  dtConfig . dayHeaderFormat )  ,%NWL%dayTitle :  getValue ( $attrs . dayTitleFormat ,  dtConfig . dayTitleFormat )  ,%NWL%monthTitle : getValue ( $attrs . monthTitleFormat , dtConfig . monthTitleFormat )%NWL%}  ,%NWL%startingDay = getValue ( $attrs . startingDay ,   dtConfig . startingDay )  ,%NWL%yearRange =  getValue ( $attrs . yearRange ,   dtConfig . yearRange )  ; %NWL%this . minDate = dtConfig . minDate ? new Date ( dtConfig . minDate )  : null ; %NWL%this . maxDate = dtConfig . maxDate ? new Date ( dtConfig . maxDate )  : null ; %NWL%9
{%NWL%if ( qx . core . Environment . get (  " qx . debug "  )  )  {%NWL%this . __checkForPotentialClippedImage ( sourceid )  ;%NWL%}%NWL%if ( repeat =  =  " scale - x "  )%NWL%{%NWL%style . height = dimension . height =  = null ? null : dimension . height +  " px "  ;%NWL%}%NWL%else if ( repeat =  =  " scale - y "  )%NWL%{%NWL%style . width = dimension . width =  = null ? null : dimension . width +  " px "  ; %NWL%6
newItem . width = elem . width (  )  ; %NWL%newItem . height = elem . height (  )  ; %NWL%newItem . borderLeftWidth = elem . css (  ' borderLeftWidth '  ) || 0 ; %NWL%newItem . borderTopWidth = elem . css (  ' borderTopWidth '  ) || 0 ; %NWL%newItem . borderRightWidth = elem . css (  ' borderRightWidth '  ) || 0 ; %NWL%newItem . borderBottomWidth = elem . css (  ' borderBottomWidth '  ) || 0 ; %NWL%newItem . borderLeftColor = elem . css (  ' borderLeftColor '  )  ; %NWL%newItem . borderTopColor = elem . css (  ' borderTopColor '  )  ; %NWL%newItem . borderRightColor = elem . css (  ' borderRightColor '  )  ; %NWL%newItem . borderBottomColor = elem . css (  ' borderBottomColor '  )  ; %NWL%newItem . borderLeftStyle = elem . css (  ' borderLeftStyle '  )  ; %NWL%6
objects : require (  '  .  / gamejs / utils / objects '  )  ,%NWL%uri : require (  '  .  / gamejs / utils / uri '  )  ,%NWL%strings : require (  '  .  / gamejs / utils / strings '  )  ,%NWL%xml : require (  '  .  / gamejs / utils / xml '  )  ,%NWL%base64 : require (  '  .  / gamejs / utils / base64 '  )%NWL%}  ; %NWL%exports . display = require (  '  .  / gamejs / display '  )  ; %NWL%exports . pathfinding = require (  '  .  / gamejs / pathfinding '  )  ; %NWL%exports . tiledmap = require (  '  .  / gamejs / tiledmap '  )  ; %NWL%exports . time = require (  '  .  / gamejs / time '  )  ; %NWL%exports . pixelcollision = require (  '  .  / gamejs / pixelcollision '  )  ; %NWL%6
}%NWL%manager . ui . writeLine (  "  "  + dep +  "  "  + actualVersion )  ;%NWL%}  )  ;%NWL%}  ,%NWL%_bowerJSONForScenario : function ( bowerJSON , scenario )  {%NWL%if ( !scenario . dependencies )  { throw new Error (  " No dependencies specified for scenario "  + scenario . name )  ;  }%NWL%var pkgs = Object . keys ( scenario . dependencies )  ; %NWL%pkgs . forEach ( function ( pkg )  {%NWL%bowerJSON . dependencies [ pkg ]  = scenario . dependencies [ pkg ]  ; %NWL%if ( scenario . resolutions && scenario . resolutions [ pkg ]  )  {%NWL%bowerJSON . resolutions [ pkg ]  = scenario . resolutions [ pkg ]  ; %NWL%8
Configurer . init = function ( object , config )  {%NWL%object . configuration = config ; %NWL%config . apiEndpoint = angular . isUndefined ( config . apiEndpoint ) ? '  '  : config . apiEndpoint ; %NWL%object . setApiEndpoint = function ( apiEndpoint )  {%NWL%config . apiEndpoint = apiEndpoint ;%NWL%}  ; %NWL%config . accessToken = angular . isUndefined ( config . accessToken ) ? '  '  : config . accessToken ; %NWL%object . setAccessToken = function ( accessToken )  {%NWL%config . accessToken = accessToken ;%NWL%}  ; %NWL%config . clientId = angular . isUndefined ( config . clientId ) ? '  '  : config . clientId ; %NWL%2
this . angulurjs =  ( answers . uiselect =  =  = 2 )  ; %NWL%this . emberjs =  ( answers . uiselect =  =  = 1 )  ; %NWL%this . semanticui =  ( answers . ui =  =  = 2 )  ; %NWL%this . twitterbootstrap =  ( answers . ui =  =  = 1 )  ; %NWL%this . grunt =  ( answers . taskrunner =  =  = 2 )  ; %NWL%this . gulp =  ( answers . taskrunner =  =  = 1 )  ; %NWL%this . mysql =  ( answers . dbselect =  =  = 3 )  ; %NWL%this . sqlite =  ( answers . dbselect =  =  = 2 )  ; %NWL%this . mongodb =  ( answers . dbselect =  =  = 1 )  ; %NWL%this . mochaOption = answers . mochaOption ; %NWL%this . gruntOption = answers . gruntOption ; %NWL%9
this . touchStartY = 0 ; %NWL%this . lastTouchIdentifier = 0 ; %NWL%this . touchBoundary = 10 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { return FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onMouse = function (  )  { return FastClick . prototype . onMouse . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { return FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchEnd = function (  )  { return FastClick . prototype . onTouchEnd . apply ( self , arguments )  ;  }  ; %NWL%7
exports . NotFoundRoute = require (  "  .  / components / NotFoundRoute "  )  ; %NWL%exports . Redirect = require (  "  .  / components / Redirect "  )  ; %NWL%exports . Route = require (  "  .  / components / Route "  )  ; %NWL%exports . RouteHandler = require (  "  .  / components / RouteHandler "  )  ; %NWL%exports . HashLocation = require (  "  .  / locations / HashLocation "  )  ; %NWL%exports . HistoryLocation = require (  "  .  / locations / HistoryLocation "  )  ; %NWL%exports . RefreshLocation = require (  "  .  / locations / RefreshLocation "  )  ; %NWL%exports . StaticLocation = require (  "  .  / locations / StaticLocation "  )  ; %NWL%exports . TestLocation = require (  "  .  / locations / TestLocation "  )  ; %NWL%exports . ImitateBrowserBehavior = require (  "  .  / behaviors / ImitateBrowserBehavior "  )  ; %NWL%exports . ScrollToTopBehavior = require (  "  .  / behaviors / ScrollToTopBehavior "  )  ; %NWL%9
hierarchicalSync  : true ,%NWL%numberOfChanges  : true ,%NWL%extensions   :  {  }%NWL%}  )  ; %NWL%this . devID    = options . devID || common . makeID (  )  ; %NWL%this . devType    = options . devType ; %NWL%this . manufacturerName = options . manufacturerName ; %NWL%this . modelName   = options . modelName ; %NWL%this . oem     = options . oem ; %NWL%this . hardwareVersion  = options . hardwareVersion ; %NWL%this . firmwareVersion  = options . firmwareVersion ; %NWL%5
var _ = require (  ' lodash '  )  ; %NWL%var util = require (  ' util '  )  ; %NWL%var events = require (  ' events '  )  ; %NWL%module . exports = Waterlock ; %NWL%function Waterlock (  )  {%NWL%events . EventEmitter . call ( this )  ; %NWL%this . sails   = global . sails ; %NWL%this . engine  = _ . bind ( this . engine , this )  (  )  ; %NWL%this . config  = _ . bind ( this . config , this )  (  )  ; %NWL%this . methods  = _ . bind ( this . methods , this )  (  )  . collect (  )  ; %NWL%this . models  = _ . bind ( this . models , this )  (  )  ; %NWL%7
console . error (  ' THREE . DDSLoader . parse : Unsupported FourCC code '  , int32ToFourCC ( fourCC )  )  ; %NWL%return dds ;%NWL%}%NWL%}%NWL%dds . mipmapCount = 1 ; %NWL%if ( header [ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps ! =  = false )  {%NWL%dds . mipmapCount = Math . max ( 1 , header [ off_mipmapCount ]  )  ;%NWL%}%NWL%dds . isCubemap = header [ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false ; %NWL%dds . width = header [ off_width ]  ; %NWL%dds . height = header [ off_height ]  ; %NWL%9
}%NWL%function restangularizeElem ( parent , elem , route )  {%NWL%var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%4
return function ( value )  {%NWL%if ( typeof value =  =  =  " string "  )  {%NWL%value = value . replace (  ' # '  ,  ' 0x '  )  ;%NWL%}%NWL%color . setHex ( value )  ;%NWL%}  ;%NWL%}%NWL%function needsUpdate ( material , geometry )  {%NWL%return function (  )  {%NWL%material . shading =  + material . shading ;  /  / Ensure number%NWL%material . vertexColors =  + material . vertexColors ;  /  / Ensure number%NWL%9
this . relatedTarget = relatedTarget ; %NWL%this . offsetX = e . offsetX ! =  = undefined ? e . offsetX : e . layerX ; %NWL%this . offsetY = e . offsetY ! =  = undefined ? e . offsetY : e . layerY ; %NWL%this . clientX = e . clientX ! =  = undefined ? e . clientX : e . pageX ; %NWL%this . clientY = e . clientY ! =  = undefined ? e . clientY : e . pageY ; %NWL%this . screenX = e . screenX || 0 ; %NWL%this . screenY = e . screenY || 0 ; %NWL%this . button = e . button ; %NWL%this . keyCode = e . keyCode || 0 ; %NWL%this . charCode = e . charCode || ( type =  =  ' keypress ' ? e . keyCode : 0 )  ; %NWL%this . ctrlKey = e . ctrlKey ; %NWL%7
json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%json . colorSpread = this . colorSpread . toJSON ( json . colorSpread )  ; %NWL%json . time = this . time ; %NWL%json . _time = this . _time ; %NWL%2
this . viewingPagesByTab =  {  }  ; %NWL%this . lastMessage = Date . now (  )  ; %NWL%setTimeout ( function (  )  {%NWL%renderUsers (  )  ; %NWL%renderBar (  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%update : function ( msg )  {%NWL%this . avatar = msg . avatar || this . avatar ; %NWL%this . name = msg . name || this . name ; %NWL%this . color = msg . color || this . color ; %NWL%8
}%NWL%result . x = pixelWidth ; %NWL%result . y = pixelHeight ; %NWL%return result ;%NWL%}  ; %NWL%PerspectiveOffCenterFrustum . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new PerspectiveOffCenterFrustum (  )  ;%NWL%}%NWL%result . right = this . right ; %NWL%result . left = this . left ; %NWL%9
Parallax . prototype . scalar = function ( x , y )  {%NWL%this . scalarX = x =  =  = undefined ? this . scalarX : x ; %NWL%this . scalarY = y =  =  = undefined ? this . scalarY : y ;%NWL%}  ; %NWL%Parallax . prototype . limit = function ( x , y )  {%NWL%this . limitX = x =  =  = undefined ? this . limitX : x ; %NWL%this . limitY = y =  =  = undefined ? this . limitY : y ;%NWL%}  ; %NWL%Parallax . prototype . origin = function ( x , y )  {%NWL%this . originX = x =  =  = undefined ? this . originX : x ; %NWL%this . originY = y =  =  = undefined ? this . originY : y ; %NWL%2
invalidMessage :  "  "  ,%NWL%minimum :  "  "  ,%NWL%maximum :  "  "  ,%NWL%format :  '  '  ,%NWL%dateEditorType :  ' DateTextBox '  ,%NWL%getEditorProps : function ( inNode , inProps )  {%NWL%var constraints =  {  }  ; %NWL%if ( this . minimum )%NWL%constraints . min = this . convertValue ( this . minimum )  ; %NWL%if ( this . maximum )%NWL%constraints . max = this . convertValue ( this . maximum )  ; %NWL%8
if ( !_needsBackup )  {%NWL%return ;%NWL%}%NWL%var data = _this . data ; %NWL%data . name = _name ; %NWL%data . template = _template ; %NWL%data . author = butter . cornfield . username (  )  ; %NWL%data . description = _description ; %NWL%data . tags = _this . tags ; %NWL%data . thumbnail = _thumbnail ; %NWL%data . background = _background ; %NWL%4
return 0 ;%NWL%}  )  ; %NWL%for ( var i = 0 ; i < commits . length ; i +  +  )  {%NWL%for ( var j = 0 ; j < commits [ i ]  . Children . length ; j +  +  )  {%NWL%var range = commits [ i ]  . Children [ j ]  ; %NWL%var c = commits [ i ]  ; %NWL%range . AuthorName = c . AuthorName ; %NWL%range . AuthorEmail = c . AuthorEmail ; %NWL%range . CommitterName = c . CommitterName ; %NWL%range . CommitterEmail = c . CommitterEmail ; %NWL%range . Message = c . Message ; %NWL%6
this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  , fl )  ; %NWL%this . fillFileList (  ' over_list '  , fl )  ; %NWL%this . fillFileList (  ' out_list '  , fl )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%6
}  ; %NWL%Vector2d . prototype . clone = function (  )  {%NWL%return new Vector2d ( this . x , this . y )  ;%NWL%}  ; %NWL%Vector2d . prototype . unit = function (  )  {%NWL%return new Vector2d ( Math . cos ( this . x )  , Math . sin ( this . y )  )  ;%NWL%}  ; %NWL%Vector2d . prototype . normalize = function (  )  {%NWL%var normal = this . normalized ; %NWL%this . x = normal . x ; %NWL%this . y = normal . y ; %NWL%9
}  ; %NWL%transcribe = function ( same , pos )  {%NWL%if ( same . top )  {%NWL%css . top =  "  "  + pos . top +  " px "  ;%NWL%} else {%NWL%css . bottom =  "  "  + pos . bottom +  " px "  ;%NWL%}%NWL%if ( same . left )  {%NWL%return css . left =  "  "  + pos . left +  " px "  ;%NWL%} else {%NWL%return css . right =  "  "  + pos . right +  " px "  ; %NWL%8
if ( shift_nums [ character ] && e . shiftKey )  {  /  / Stupid Shift key bug created by using lowercase%NWL%character = shift_nums [ character ]  ; %NWL%if ( character =  = k ) kp +  +  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%if ( kp =  = keys . length &&%NWL%modifiers . ctrl . pressed =  = modifiers . ctrl . wanted &&%NWL%modifiers . shift . pressed =  = modifiers . shift . wanted &&%NWL%modifiers . alt . pressed =  = modifiers . alt . wanted &&%NWL%8
}  ; %NWL%self . getWrapperDom = getWrapperDom = function (  )  {%NWL%return wrapperDom ;%NWL%}  ; %NWL%self . getContentDom = getContentDom = function (  )  {%NWL%return contentDom ;%NWL%}  ; %NWL%self . getWrapperEl = getWrapperEl = function (  )  {%NWL%return wrapperEl ;%NWL%}  ; %NWL%self . getContentEl = getContentEl = function (  )  {%NWL%1
pr . config . minJsPathType =  ' RELATIVE_FILEDIR '  ; %NWL%pr . config . minJsPath = project . config . jsMinPath ;%NWL%}%NWL%_ . each ( project . files , function ( file )  {%NWL%var _file =  {  }  ; %NWL%_file . config =  {  }  ; %NWL%_file . id = file . id ; %NWL%_file . pid = file . pid ; %NWL%_file . name = file . name ; %NWL%_file . type = file . type ; %NWL%_file . input = file . input ; %NWL%6
lodash . indexOf = arrays . indexOf ; %NWL%lodash . isArguments = objects . isArguments ; %NWL%lodash . isArray = isArray ; %NWL%lodash . isBoolean = objects . isBoolean ; %NWL%lodash . isDate = objects . isDate ; %NWL%lodash . isElement = objects . isElement ; %NWL%lodash . isEmpty = objects . isEmpty ; %NWL%lodash . isEqual = objects . isEqual ; %NWL%lodash . isFinite = objects . isFinite ; %NWL%lodash . isFunction = objects . isFunction ; %NWL%lodash . isNaN = objects . isNaN ; %NWL%1
return this ;%NWL%}  ; %NWL%this . enable . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . enable "  ; %NWL%this . useDebug = function ( value )  {%NWL%if ( value =  = null )  {%NWL%value = DEFAULT_OPTIONS . debugEnabled ;%NWL%}%NWL%options . debugEnabled = value =  =  = true ; %NWL%return this ;%NWL%}  ; %NWL%this . useDebug . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : provider . useDebug "  ; %NWL%2
exports . test = common . wrap (  ' test '  , _test )  ; %NWL%var _cat = require (  '  .  / src / cat '  )  ; %NWL%exports . cat = common . wrap (  ' cat '  , _cat )  ; %NWL%var _to = require (  '  .  / src / to '  )  ; %NWL%String . prototype . to = common . wrap (  ' to '  , _to )  ; %NWL%var _toEnd = require (  '  .  / src / toEnd '  )  ; %NWL%String . prototype . toEnd = common . wrap (  ' toEnd '  , _toEnd )  ; %NWL%var _sed = require (  '  .  / src / sed '  )  ; %NWL%exports . sed = common . wrap (  ' sed '  , _sed )  ; %NWL%var _grep = require (  '  .  / src / grep '  )  ; %NWL%exports . grep = common . wrap (  ' grep '  , _grep )  ; %NWL%0
var RatioConst = 320 ; %NWL%var TextureWidth = 0 ; %NWL%var TextureHeight = 0 ; %NWL%var TextureBuffer ; %NWL%function Init (  )%NWL%{%NWL%TextureHandle = document . createElement (  " canvas "  )  ; %NWL%var img = new Image (  )  ; %NWL%img . onload = function (  )  {%NWL%TextureHandle . width = img . width ; %NWL%TextureHandle . height = img . height ; %NWL%9
{  }%NWL%else if ( setform =  = this . PLAIN )%NWL%{  }%NWL%else {%NWL%throw " MathContext (  ) Bad form value :  "  + setform ;%NWL%}%NWL%}%NWL%if (  ( ! ( this . isValidRound ( setroundingmode )  )  )  )%NWL%throw " MathContext (  )  : Bad roundingMode value :  "  + setroundingmode ; %NWL%this . digits = setdigits ; %NWL%this . form = setform ; %NWL%9
else if ( document . all )  { this . use_css = true ;  }%NWL%else if ( document . layers )  { this . use_layers = true ;  }%NWL%else { this . type =  " WINDOW "  ;  }%NWL%this . offsetX = 0 ; %NWL%this . offsetY = 0 ; %NWL%this . getXYPosition = PopupWindow_getXYPosition ; %NWL%this . populate = PopupWindow_populate ; %NWL%this . setUrl = PopupWindow_setUrl ; %NWL%this . setWindowProperties = PopupWindow_setWindowProperties ; %NWL%this . refresh = PopupWindow_refresh ; %NWL%this . showPopup = PopupWindow_showPopup ; %NWL%5
this . dz = 0 ; %NWL%this . buttons = 0 ; %NWL%this . buttonsDown = 0 ; %NWL%this . buttonsUp = 0 ; %NWL%this . isLocked = false ;%NWL%}  ; %NWL%gf . input . MouseData . prototype . clone = function (  )  {%NWL%var clone = new gf . input . MouseData (  )  ; %NWL%clone . screenX = this . screenX ; %NWL%clone . screenY = this . screenY ; %NWL%clone . dx = this . dx ; %NWL%8
client = new fakeGlobal . XMLHttpRequest (  )  ; %NWL%client . onreadystatechange = onreadystatechange ; %NWL%client . open (  " GET "  ,  " example . com / someApi "  )  ; %NWL%client . setRequestHeader (  " Content - Type "  ,  " application / json "  )  ; %NWL%client . send (  )  ; %NWL%request = mockAjax . requests . mostRecent (  )  ; %NWL%response =  { status : 200 , statusText :  " OK "  , responseText :  '  {  " foo "  :  " valid JSON , dammit .  "  }  '  , responseType :  ' json '  }  ; %NWL%request . respondWith ( response )  ; %NWL%sharedContext . responseCallback = success ; %NWL%sharedContext . status = response . status ; %NWL%sharedContext . statusText = response . statusText ; %NWL%9
this . row = row ; %NWL%this . tree = tree ; %NWL%this . settings = settings ; %NWL%this . id = this . row . data ( this . settings . nodeIdAttr )  ; %NWL%parentId = this . row . data ( this . settings . parentIdAttr )  ; %NWL%if ( parentId ! = null && parentId ! =  =  "  "  )  {%NWL%this . parentId = parentId ;%NWL%}%NWL%this . treeCell = $ ( this . row . children ( this . settings . columnElType )  [ this . settings . column ]  )  ; %NWL%this . expander = $ ( this . settings . expanderTemplate )  ; %NWL%this . indenter = $ ( this . settings . indenterTemplate )  ; %NWL%9
}%NWL%drawDisplay ( true )  ; %NWL%function drawDisplay ( animate )  {%NWL%var can = document . getElementById ( id )  ; %NWL%if ( can =  = null )  {%NWL%return ;%NWL%}%NWL%var ctx = can . getContext (  ' 2d '  )  ; %NWL%if ( zoom =  = true )  {%NWL%can . width = $ ( window )  . width (  )  ; %NWL%can . height = $ ( window )  . height (  )  ; %NWL%9
if ( input =  =  = null || input =  =  = undefined )  {%NWL%throw new Error (  " Led . RGB . color : invalid color (  "  + input +  "  )  "  )  ;%NWL%}%NWL%if ( typeof input =  =  =  " object "  )  {%NWL%if ( Array . isArray ( input )  )  {%NWL%update . red = input [ 0 ]  ; %NWL%update . green = input [ 1 ]  ; %NWL%update . blue = input [ 2 ]  ;%NWL%} else {%NWL%update . red = input . red ; %NWL%update . green = input . green ; %NWL%9
offset = item . writeBuffer ( buffer , offset )  ;%NWL%}  )  ; %NWL%return offset ;%NWL%}%NWL%Array . prototype . byteLength = function (  )  {%NWL%return this . reduce ( function ( p , c )  { return p + c . length }  , 0 )  ;%NWL%}%NWL%function Format ( depth , bpp , scanline_pad )  {%NWL%this . depth = depth || 0 ; %NWL%this . bpp = bpp || 0 ; %NWL%this . scanline_pad = scanline_pad || 0 ; %NWL%8
for ( var i = 0 ; i < handlers . length ;  +  + i )  {%NWL%handlers [ i ]  . apply ( this , args )  ;%NWL%}%NWL%}%NWL%return this ;%NWL%}  ; %NWL%function Animation ( item , transform , duration , ease , delay )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . item = item ; %NWL%this . translate = transform . translate && transform . translate . map ( parseFloat )  ; %NWL%this . rotate = transform . rotate && transform . rotate . map ( parseFloat )  ; %NWL%9
}  ,%NWL%EventBus : EventBus_ ,%NWL%getOptions : function (  )  {%NWL%return angular . extend (  {  }  , options )  ;%NWL%}%NWL%}  ; %NWL%stub . reconnect . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : EventBusWrapper . reconnect '  ; %NWL%stub . close . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : EventBusWrapper . close '  ; %NWL%stub . login . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : EventBusWrapper . login '  ; %NWL%stub . send . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : EventBusWrapper . send '  ; %NWL%stub . publish . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : EventBusWrapper . publish '  ; %NWL%6
User . prototype . getEmail = function (  )  {%NWL%return this . email || "  "  ;%NWL%}  ; %NWL%User . prototype . isActive = function (  )  {%NWL%return ( this . active ) ? ( this . active =  =  =  " Y "  )  : false ;%NWL%}  ; %NWL%User . prototype . scrapeFrom = function ( controller )  {%NWL%this . username = controller . getParam (  " username "  , this . username )  ; %NWL%this . password = controller . getParam (  " password "  ,  "  "  )  ; %NWL%this . name = controller . getParam (  " name "  , this . name )  ; %NWL%this . domain = controller . getParam (  " domain "  , this . domain )  ; %NWL%7
var zapp = zen ( hw )  ; %NWL%zapp . errorHandler = function (  )  { test . ok ( false ,  ' The errorHandler was executed '  )  ;  }  ; %NWL%zapp . resultHandler = function (  )  { test . ok ( true ,  ' The resultHandler was executed '  )  ;  }  ; %NWL%zapp (  )  ; %NWL%test . expect ( 2 )  ; %NWL%test . done (  )  ;%NWL%}  ,%NWL%' 4 . Zen should run errorHandler on last empty " next (  )  "  '  : function ( test )  {%NWL%var hw = function ( next )  { test . ok ( true ,  ' The handler was executed '  )  ; next (  )  }  ; %NWL%var zapp = zen ( hw )  ; %NWL%zapp . errorHandler = function (  )  { test . ok ( true ,  ' The errorHandler was executed '  )  ;  }  ; %NWL%2
if ( window . DroidGap )  {%NWL%this . available = true ; %NWL%this . uuid = window . DroidGap . getUuid (  )  ; %NWL%this . version = window . DroidGap . getOSVersion (  )  ; %NWL%this . gapVersion = window . DroidGap . getVersion (  )  ; %NWL%this . platform = window . DroidGap . getPlatform (  )  ; %NWL%this . name = window . DroidGap . getProductName (  )  ;%NWL%} else {%NWL%this . platform = DeviceInfo . platform ; %NWL%this . version  = DeviceInfo . version ; %NWL%this . name  = DeviceInfo . name ; %NWL%8
window . GetOrdinal = GetOrdinal ; %NWL%function IsEmail ( email )  {%NWL%var emailPattern =  / ^ [ a - zA - Z0 - 9 . _ -  ]  + @ [ a - zA - Z0 - 9 .  -  ]  + \ .  [ a - zA - Z ]  { 2 , 4 } $ /  ; %NWL%return emailPattern . test ( email )  ;%NWL%}%NWL%window . IsEmail = IsEmail ; %NWL%function Viewport ( args )  {%NWL%this . el     = $ (  ' # '  + args . id )  . removeClass (  ' desktop tablet mobile '  )  . addClass ( args . iface )  ; %NWL%this . iface    = args . iface ; %NWL%this . device    = args . device ; %NWL%this . deviceOs   = args . deviceOs ; %NWL%8
}  ; %NWL%LeafNode . prototype . split = function (  )  {%NWL%var tmp = new LeafNode ( this . order )  ; %NWL%var m = Math . ceil ( this . data . length / 2 )  ; %NWL%var k = this . data [ m - 1 ]  . key ; %NWL%for ( var i = 0 ; i < m ; i +  +  )  {%NWL%tmp . data [ i ]  = this . data . shift (  )  ;%NWL%}%NWL%tmp . parentNode = this . parentNode ; %NWL%tmp . nextNode = this ; %NWL%tmp . prevNode = this . prevNode ; %NWL%8
this . points =  [  { x : 0 , y : 80 }  ,  { x : 0 , y : 0 }  ,  { x : 80 , y : 0 }  ,  { x : 80 , y : 80 }  ]  ; %NWL%this . regSerializer ( this . fourJointToJson , this . fourJointFromJson )  ; %NWL%return this ;%NWL%}%NWL%UIFourJoint . prototype . fourJointToJson = function ( o )  {%NWL%o . points =  [  {  }  ,  {  }  ,  {  }  ,  {  }  ]  ; %NWL%o . points [ 0 ]  . x = this . points [ 0 ]  . x ; %NWL%o . points [ 0 ]  . y = this . points [ 0 ]  . y ; %NWL%o . points [ 1 ]  . x = this . points [ 1 ]  . x ; %NWL%o . points [ 1 ]  . y = this . points [ 1 ]  . y ; %NWL%o . points [ 2 ]  . x = this . points [ 2 ]  . x ; %NWL%6
return this . libs [ lib ]  . init . apply ( this . libs [ lib ]  ,  [ this . scope , args [ lib ]  ]  )  ;%NWL%}%NWL%args = args instanceof Array ? args : new Array ( args )  ; %NWL%return this . libs [ lib ]  . init . apply ( this . libs [ lib ]  , args )  ;%NWL%}%NWL%return function (  )  {  }  ;%NWL%}  ,%NWL%patch : function ( lib )  {%NWL%lib . scope = this . scope ; %NWL%lib . namespace = this . global . namespace ; %NWL%lib . rtl = this . rtl ; %NWL%8
if ( d . SC_is_reply )  {%NWL%entryHTML +  =  ' reply '  ;%NWL%}%NWL%if ( d . SC_is_retweet )  {%NWL%entryHTML +  =  ' retweet '  ; %NWL%d . retweeting_user = d . user ; %NWL%d . user = d . retweeted_status . user ; %NWL%d . id = d . retweeted_status . id ; %NWL%d . in_reply_to_status_id = d . retweeted_status . in_reply_to_status_id ; %NWL%d . isSent = d . isSent ; %NWL%d . text = d . retweeted_status . text ; %NWL%6
' use strict '  ; %NWL%return dcl ( Entity ,  {%NWL%declaredClass :  ' frozen / box2d / entities / Circle '  ,%NWL%radius : 1 ,%NWL%draw : dcl . superCall ( function ( sup )  {%NWL%return function ( ctx , scale )  {%NWL%scale = scale || this . scale || 1 ; %NWL%var ogLineWidth = ctx . lineWidth ; %NWL%ctx . lineWidth = this . lineWidth ; %NWL%ctx . fillStyle = this . fillStyle ; %NWL%ctx . strokeStyle = this . strokeStyle ; %NWL%8
_cameraR . projectionMatrix . copy ( projectionMatrix )  ;%NWL%}%NWL%_cameraL . matrixWorld . copy ( camera . matrixWorld )  . multiply ( eyeLeft )  ; %NWL%_cameraL . position . copy ( camera . position )  ; %NWL%_cameraL . near = camera . near ; %NWL%_cameraL . far = camera . far ; %NWL%renderer . render ( scene , _cameraL , _renderTargetL , true )  ; %NWL%_cameraR . matrixWorld . copy ( camera . matrixWorld )  . multiply ( eyeRight )  ; %NWL%_cameraR . position . copy ( camera . position )  ; %NWL%_cameraR . near = camera . near ; %NWL%_cameraR . far = camera . far ; %NWL%9
C . lua_getfield = F (  " lua_getfield "  , void_t ,  [ lua_State , int_t , const_char_ptr_t ]  )  ; %NWL%C . lua_rawget = F (  " lua_rawget "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_rawgeti = F (  " lua_rawgeti "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%C . lua_createtable = F (  " lua_createtable "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%C . lua_newuserdata = F (  " lua_newuserdata "  , void_ptr_t ,  [ lua_State , size_t ]  )  ; %NWL%C . lua_getmetatable = F (  " lua_getmetatable "  , int_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_getfenv = F (  " lua_getfenv "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_settable = F (  " lua_settable "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_setfield = F (  " lua_setfield "  , void_t ,  [ lua_State , int_t , const_char_ptr_t ]  )  ; %NWL%C . lua_rawset = F (  " lua_rawset "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_rawseti = F (  " lua_rawseti "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%2
return this . writeInteger ( value , 2 , bigEndian )  ;%NWL%}  ; %NWL%this . writeInt16 = function writeInt16 ( value , bigEndian )%NWL%{%NWL%return this . writeInteger ( value , 2 , bigEndian )  ;%NWL%}  ; %NWL%this . writeUInt32 = function writeUInt32 ( value , bigEndian )%NWL%{%NWL%return this . writeInteger ( value , 4 , bigEndian )  ;%NWL%}  ; %NWL%this . writeInt32 = function writeInt32 ( value , bigEndian )%NWL%2
this . raiseEvent ( o )  ; %NWL%o . event = null ;%NWL%}  )%NWL%}  )  ;%NWL%}  ,%NWL%_connectEvents : function ( o )  {%NWL%if ( o )  {%NWL%o . chart = this . chart ; %NWL%o . plot  = this ; %NWL%o . hAxis = this . hAxis || null ; %NWL%o . vAxis = this . vAxis || null ; %NWL%9
" Remove placemark "  : function (  )  {%NWL%placemarks . splice ( placemarks . indexOf ( m )  , 1 )  ; %NWL%map . removeLayer ( m )  ;%NWL%}  ,%NWL%" Edit info "  : function (  )  {%NWL%editPlacemark ( m )  ;%NWL%}%NWL%}  )  ; %NWL%m . on ( tevents . menu , m . pmMenu )  ; %NWL%m . icon = opt . icon ; %NWL%m . text = opt . text ; %NWL%9
}%NWL%}  ,%NWL%' __addDomElement '  :  {%NWL%enumerable : false ,%NWL%writable : false ,%NWL%value : function ( elementArg )  {%NWL%console . assert ( typeof elementArg =  =  =  ' object ' && elementArg . toString (  )  =  =  =  '  [ object HTMLCanvasElement ]  '  ,  " elementArg is a canvas "  , elementArg )  ; %NWL%set_element_property ( elementArg ,  ' position '  ,  ' absolute '  )  ; %NWL%if ( this . parent )  {%NWL%this . width = this . parent . width ; %NWL%this . height = this . parent . height ; %NWL%9
point =  ( points . length - 0 )  * t ; %NWL%intPoint = Math . floor ( point )  ; %NWL%weight = point - intPoint ; %NWL%intPoint +  = intPoint > 0 ? 0 :  ( Math . floor ( Math . abs ( intPoint )  / points . length )  + 1 )  * points . length ; %NWL%c [ 0 ]  =  ( intPoint - 1 ) % points . length ; %NWL%c [ 1 ]  =  ( intPoint ) % points . length ; %NWL%c [ 2 ]  =  ( intPoint + 1 ) % points . length ; %NWL%c [ 3 ]  =  ( intPoint + 2 ) % points . length ; %NWL%v . x = THREE . Curve . Utils . interpolate ( points [ c [ 0 ]  ]  . x , points [ c [ 1 ]  ]  . x , points [ c [ 2 ]  ]  . x , points [ c [ 3 ]  ]  . x , weight )  ; %NWL%v . y = THREE . Curve . Utils . interpolate ( points [ c [ 0 ]  ]  . y , points [ c [ 1 ]  ]  . y , points [ c [ 2 ]  ]  . y , points [ c [ 3 ]  ]  . y , weight )  ; %NWL%v . z = THREE . Curve . Utils . interpolate ( points [ c [ 0 ]  ]  . z , points [ c [ 1 ]  ]  . z , points [ c [ 2 ]  ]  . z , points [ c [ 3 ]  ]  . z , weight )  ; %NWL%8
}  ,%NWL%createElements : function (  )  {%NWL%this . node . innerHTML = SiteEditorTemplate ; %NWL%lib . processTextNodes ( this . node , messages )  ; %NWL%this . siteForm = lib . $ (  "  . siteForm "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name = lib . $ (  "  . siteConfigName "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name . id = this . id +  " _name "  ;  /  / $NON - NLS - 0$%NWL%this . nameInvalid = lib . $ (  "  . nameInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint = lib . $ (  "  . hostHint "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint . id = this . id +  " _hostHint "  ;  /  / $NON - NLS - 0$%NWL%this . hostInvalid = lib . $ (  "  . hostInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%4
return Binding ;%NWL%}  )  (  )  ; %NWL%Rivets . View =  ( function (  )  {%NWL%function View ( els , models , options )  {%NWL%var k , option , v , _base , _i , _len , _ref , _ref1 , _ref2 , _ref3 ; %NWL%this . els = els ; %NWL%this . models = models ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%8
transform : function ( v )  {%NWL%var vx = v . x , vy = v . y , vz = v . z , vw = v . w ? v . w : 1 . 0 ; %NWL%v . x = this . n11 * vx + this . n12 * vy + this . n13 * vz + this . n14 * vw ; %NWL%v . y = this . n21 * vx + this . n22 * vy + this . n23 * vz + this . n24 * vw ; %NWL%v . z = this . n31 * vx + this . n32 * vy + this . n33 * vz + this . n34 * vw ; %NWL%vw = this . n41 * vx + this . n42 * vy + this . n43 * vz + this . n44 * vw ; %NWL%if ( v . w )  {%NWL%v . w = vw ;%NWL%} else {%NWL%v . x = v . x / vw ; %NWL%v . y = v . y / vw ; %NWL%9
return secret ;%NWL%}  ;%NWL%}  )  . enclose ( function (  )  {%NWL%this . a =  ' a '  ;%NWL%}  )  . enclose (  {%NWL%bar : function bar (  )  {%NWL%this . b =  ' b '  ;%NWL%}%NWL%}  ,  {%NWL%baz : function baz (  )  {%NWL%this . c =  ' c '  ; %NWL%3
}%NWL%for ( var p in options )  { this . _options [ p ]  = options [ p ]  ;  }%NWL%this . _features =  {%NWL%" Room "  : 4 ,%NWL%" Corridor "  : 4%NWL%}%NWL%this . _featureAttempts = 20 ; %NWL%this . _walls =  {  }  ; %NWL%this . _digCallback = this . _digCallback . bind ( this )  ; %NWL%this . _canBeDugCallback = this . _canBeDugCallback . bind ( this )  ; %NWL%this . _isWallCallback = this . _isWallCallback . bind ( this )  ; %NWL%8
BaseParams =  ( function (  )  {%NWL%function BaseParams (  )  {%NWL%this . checkReqParamsOk = __bind ( this . checkReqParamsOk , this )  ; %NWL%this . getPostValue = __bind ( this . getPostValue , this )  ; %NWL%this . getTableName = __bind ( this . getTableName , this )  ; %NWL%this . getLimit = __bind ( this . getLimit , this )  ; %NWL%this . getOffset = __bind ( this . getOffset , this )  ; %NWL%this . getGroup = __bind ( this . getGroup , this )  ; %NWL%this . getSort = __bind ( this . getSort , this )  ; %NWL%this . getQuery = __bind ( this . getQuery , this )  ; %NWL%this . getFilter = __bind ( this . getFilter , this )  ; %NWL%2
ca . push ( joined )  ; %NWL%cert =  [  ]  ;%NWL%}%NWL%}%NWL%return ca ;%NWL%}%NWL%function createCredentialContext ( key , cert , ca )  {%NWL%var crypto = require (  ' crypto '  )  ; %NWL%var details =  {  }  ; %NWL%details . key = getCertData ( key )  ; %NWL%details . cert = getCertData ( cert )  ; %NWL%9
addressEquals : function ( address1 , address2 )  {%NWL%return (  ( address1 . firstName =  = address2 . firstName || !address1 . firstName && !address2 . firstName ) &&%NWL%( address1 . lastName =  = address2 . lastName || !address1 . lastName && !address2 . lastName )  &&%NWL%( address1 . companyName =  = address2 . companyName || !address1 . companyName && !address2 . companyName ) &&%NWL%( address1 . line1 =  = address2 . line1 || !address1 . line1 && !address2 . line1 ) &&%NWL%( address1 . line2 =  = address2 . line2 || !address1 . line2 && !address2 . line2 ) &&%NWL%( address1 . line3 =  = address2 . line3 || !address1 . line3 && !address2 . line3 ) &&%NWL%( address1 . city =  = address2 . city || !address1 . city && !address2 . city ) &&%NWL%( address1 . countrySubdivision =  = address2 . countrySubdivision || address1 . countrySubdivision && !address2 . countrySubdivision ) &&%NWL%( address1 . postalCode =  = address2 . postalCode || !address1 . postalCode && !address2 . postalCode ) &&%NWL%( address1 . country =  = address2 . country || !address1 . country && !address2 . country ) &&%NWL%3
texture . dataType =  ' image '  ; %NWL%texture . width = image . width ; %NWL%texture . height = image . height ; %NWL%return texture ;%NWL%}%NWL%raptorjs . textureFromDDS = function ( data )  {%NWL%texture = raptorjs . createObject (  ' texture '  )  ; %NWL%texture . data = data ; %NWL%texture . dataType =  ' COMPRESSED_RGBA '  ; %NWL%texture . width = data . width ; %NWL%texture . height = data . height ; %NWL%9
$ . ajax (  {%NWL%url :  '  / book / save /  '  ,%NWL%data :  {%NWL%the_book : JSON . stringify ( theBook )%NWL%}  ,%NWL%type :  ' POST '  ,%NWL%dataType :  ' json '  ,%NWL%success : function ( response , textStatus , jqXHR )  {%NWL%if ( jqXHR . status =  = 201 )  {%NWL%theBook . id = response . id ; %NWL%theBook . added = response . added ; %NWL%9
}%NWL%plane . x =  - up . x ; %NWL%plane . y =  - up . y ; %NWL%plane . z =  - up . z ; %NWL%plane . w =  - Cartesian3 . dot ( Cartesian3 . negate ( up , negateScratch )  , point )  ; %NWL%plane = planes [ 4 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 4 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x = direction . x ; %NWL%plane . y = direction . y ; %NWL%9
formObj . width2 . value =  " px "  ; %NWL%formObj . width . value  = swfwidth ;%NWL%}%NWL%if ( swfheight . indexOf (  ' % '  ) ! =  - 1 )  {%NWL%formObj . height2 . value =  " % "  ; %NWL%formObj . height . value  = swfheight . substring ( 0 , swfheight . length - 1 )  ;%NWL%} else {%NWL%formObj . height2 . value =  " px "  ; %NWL%formObj . height . value  = swfheight ;%NWL%}%NWL%formObj . file . value = swffile ; %NWL%1
assert . object ( options . log ,  ' options . log '  )  ; %NWL%assert . optionalFunc ( options . signRequest ,  ' options . signRequest '  )  ; %NWL%assert . optionalString ( options . socketPath ,  ' options . socketPath '  )  ; %NWL%assert . optionalString ( options . url ,  ' options . url '  )  ; %NWL%EventEmitter . call ( this )  ; %NWL%this . agent = options . agent ; %NWL%this . cert = options . cert ; %NWL%this . connectTimeout = options . connectTimeout || false ; %NWL%this . headers = options . headers || {  }  ; %NWL%this . log = options . log ; %NWL%this . key = options . key ; %NWL%5
test . equal ( motherOfAllDocuments . dbref . db , doc . dbref . db )  ; %NWL%test . done (  )  ;%NWL%}  )%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%shouldCorrectlyInsertAndUpdateDocumentWithNewScriptContext : function ( test )  {%NWL%var db = new Db ( MONGODB , new Server (  ' localhost '  , 27017 ,  { auto_reconnect : true }  )  ,  { native_parser :  ( process . env [  ' TEST_NATIVE '  ] ! = null )  }  )  ; %NWL%db . bson_deserializer = client . bson_deserializer ; %NWL%db . bson_serializer = client . bson_serializer ; %NWL%db . pkFactory = client . pkFactory ; %NWL%8
actualMap . names . join (  "  ,  "  )  +  " ! =  "  + expectedMap . names . join (  "  ,  "  )  )  ;%NWL%}%NWL%assert . equal ( actualMap . sources . length ,%NWL%expectedMap . sources . length ,%NWL%" sources length mismatch :  "  +%NWL%actualMap . sources . join (  "  ,  "  )  +  " ! =  "  + expectedMap . sources . join (  "  ,  "  )  )  ; %NWL%for ( var i = 0 ; i < actualMap . sources . length ; i +  +  )  {%NWL%assert . equal ( actualMap . sources [ i ]  ,%NWL%expectedMap . sources [ i ]  ,%NWL%" sources [  "  + i +  "  ] length mismatch :  "  +%NWL%actualMap . sources . join (  "  ,  "  )  +  " ! =  "  + expectedMap . sources . join (  "  ,  "  )  )  ; %NWL%0
}%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%7
el : $ (  ' #features '  )%NWL%}  )  ;%NWL%}%NWL%return App ;%NWL%}  )  ( Spine . Controller )  ; %NWL%App . FeatureList =  ( function ( _super )  {%NWL%__extends ( FeatureList , _super )  ; %NWL%function FeatureList (  )  {%NWL%this . reload = __bind ( this . reload , this )  ; %NWL%this . addAll = __bind ( this . addAll , this )  ; %NWL%this . addOne = __bind ( this . addOne , this )  ; %NWL%8
nums . appendChild ( scroller )  ; %NWL%scroller . innerHTML =  "  < div >  "  + firstNum +  "  <  / div >  "  ; %NWL%return nums ;%NWL%}%NWL%function frameHTML ( options )  {%NWL%if ( typeof options . parserfile =  =  " string "  )%NWL%options . parserfile =  [ options . parserfile ]  ; %NWL%if ( typeof options . basefiles =  =  " string "  )%NWL%options . basefiles =  [ options . basefiles ]  ; %NWL%if ( typeof options . stylesheet =  =  " string "  )%NWL%options . stylesheet =  [ options . stylesheet ]  ; %NWL%6
options . right_shift_px ! = null )  {%NWL%this . render_options = options ;%NWL%}%NWL%return this ;%NWL%}  ,%NWL%setNotes : function ( notes )  {%NWL%if ( !notes . first_note && !notes . last_note )%NWL%throw new Vex . RuntimeError (  " BadArguments "  ,%NWL%" Hairpin needs to have either first_note or last_note set .  "  )  ; %NWL%this . first_note = notes . first_note ; %NWL%this . last_note = notes . last_note ; %NWL%9
plane . z = direction . z ; %NWL%plane . w =  - Cartesian3 . dot ( direction , nearCenter )  ; %NWL%Cartesian3 . multiplyByScalar ( direction , f , point )  ; %NWL%Cartesian3 . add ( position , point , point )  ; %NWL%plane = planes [ 5 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 5 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x =  - direction . x ; %NWL%plane . y =  - direction . y ; %NWL%plane . z =  - direction . z ; %NWL%8
}  )  . forEach ( function ( key )  {%NWL%options [ key ]  = utils . fromDecimal ( options [ key ]  )  ;%NWL%}  )  ; %NWL%return options ;%NWL%}  ; %NWL%var outputTransactionFormatter = function ( tx )  {%NWL%tx . blockNumber = utils . toDecimal ( tx . blockNumber )  ; %NWL%tx . transactionIndex = utils . toDecimal ( tx . transactionIndex )  ; %NWL%tx . gas = utils . toDecimal ( tx . gas )  ; %NWL%tx . gasPrice = utils . toBigNumber ( tx . gasPrice )  ; %NWL%tx . value = utils . toBigNumber ( tx . value )  ; %NWL%9
return false ;%NWL%}%NWL%var state = cx . state ; %NWL%if ( state . context )  {%NWL%cx . marked =  " def "  ; %NWL%if ( inList ( state . localVars )  ) return ; %NWL%state . localVars =  { name : varname , next : state . localVars }  ;%NWL%} else {%NWL%if ( inList ( state . globalVars )  ) return ; %NWL%if ( parserConfig . globalVars )%NWL%state . globalVars =  { name : varname , next : state . globalVars }  ; %NWL%6
this . material = defaultValue ( this . material , source . material )  ; %NWL%this . height = defaultValue ( this . height , source . height )  ; %NWL%this . extrudedHeight = defaultValue ( this . extrudedHeight , source . extrudedHeight )  ; %NWL%this . granularity = defaultValue ( this . granularity , source . granularity )  ; %NWL%this . stRotation = defaultValue ( this . stRotation , source . stRotation )  ; %NWL%this . rotation = defaultValue ( this . rotation , source . rotation )  ; %NWL%this . fill = defaultValue ( this . fill , source . fill )  ; %NWL%this . outline = defaultValue ( this . outline , source . outline )  ; %NWL%this . outlineColor = defaultValue ( this . outlineColor , source . outlineColor )  ; %NWL%this . outlineWidth = defaultValue ( this . outlineWidth , source . outlineWidth )  ; %NWL%this . closeTop = defaultValue ( this . closeTop , source . closeTop )  ; %NWL%0
}%NWL%}  ; %NWL%Vector . prototype =  {%NWL%getMagnitude : function (  )  {%NWL%return Math . sqrt ( Math . pow ( this . x , 2 )  +%NWL%Math . pow ( this . y , 2 )  )  ;%NWL%}  ,%NWL%setMagnitude : function ( m )  {%NWL%var uv = this . normalize (  )  ; %NWL%this . x = uv . x * m ; %NWL%this . y = uv . y * m ; %NWL%9
if ( !this . err )  {%NWL%this . err = element . getAttribute (  ' err '  )  ;%NWL%}  ; %NWL%if ( !this . equals )  {%NWL%this . equals = element . getAttribute (  ' equals '  )  ;%NWL%}  ; %NWL%if ( !this . callback )  {%NWL%this . callback = element . getAttribute (  ' callback '  )  ;%NWL%}  ; %NWL%if ( !this . realname )  {%NWL%this . realname = element . getAttribute (  ' realname '  )  ; %NWL%1
that . picture . mediumUri = opts . mediumPictureUri ;%NWL%}%NWL%if ( opts . largePictureUri )  {%NWL%that . picture . largeUri = opts . largePictureUri ;%NWL%}%NWL%that . profilePath =  '  / user /  '  + tenantAlias +  '  /  '  + resourceId ; %NWL%that . resourceType =  ' user '  ; %NWL%that . notificationsUnread = opts . notificationsUnread ; %NWL%that . notificationsLastRead = opts . notificationsLastRead ; %NWL%that . acceptedTC = opts . acceptedTC ; %NWL%that . lastModified = opts . lastModified ; %NWL%7
var Promise = require (  ' promise '  )  ; %NWL%var ert = require (  ' ert '  )  ; %NWL%var pathToRegexp = require (  ' path - to - regexp '  )  ; %NWL%module . exports = ConnectRoles ; %NWL%function ConnectRoles ( options )  {%NWL%options = options || {  }  ; %NWL%this . functionList =  [  ]  ; %NWL%this . failureHandler = options . failureHandler || defaultFailureHandler ; %NWL%this . async = options . async || false ; %NWL%this . userProperty = options . userProperty || ' user '  ; %NWL%this . matchRelativePaths = options . matchRelativePaths || false ; %NWL%8
mAcceleration . timestamp = eventData . timeStamp || Date . now (  )  ; %NWL%var tmpX = mAcceleration . x ; %NWL%if ( w . orientation =  =  = cc . UIInterfaceOrientationLandscapeRight )  {%NWL%mAcceleration . x =  - mAcceleration . y ; %NWL%mAcceleration . y = tmpX ;%NWL%} else if ( w . orientation =  =  = cc . UIInterfaceOrientationLandscapeLeft )  {%NWL%mAcceleration . x = mAcceleration . y ; %NWL%mAcceleration . y =  - tmpX ;%NWL%} else if ( w . orientation =  =  = cc . UIInterfaceOrientationPortraitUpsideDown )  {%NWL%mAcceleration . x =  - mAcceleration . x ; %NWL%mAcceleration . y =  - mAcceleration . y ; %NWL%9
return field . watch . listener . apply ( this , args )  ;%NWL%}  )  ;%NWL%}%NWL%}  )  ; %NWL%$scope . $watch (  ' result '  , function ( newValue )  {%NWL%angular . forEach ( $scope . fields , function ( field , index )  {%NWL%if ( field . hideExpression )  {%NWL%field . hide = $parse ( field . hideExpression )  ( $scope . result )  ;%NWL%}%NWL%if ( field . requiredExpression )  {%NWL%field . required = $parse ( field . requiredExpression )  ( $scope . result )  ; %NWL%7
' submit '  ,%NWL%' submit_on_enter '  ,%NWL%' update_field_display '  ,%NWL%' validate '  ,%NWL%' validate_all '%NWL%)  ; %NWL%options = options || {  }  ; %NWL%this . is_valid = false ; %NWL%this . prefill = options . prefill || false ; %NWL%this . hide_on_submit = options . hide_on_submit || false ; %NWL%this . reload_on_save = options . reload_on_save || false ; %NWL%8
win . y = y ; %NWL%win . addEventListener (  ' move '  , function (  )  {%NWL%if ( win . displayState ! = air . NativeWindowDisplayState . MINIMIZED && win . width > 100 && win . height > 100 )  {%NWL%state . x = win . x ; %NWL%state . y = win . y ;%NWL%}%NWL%}  )  ; %NWL%win . addEventListener (  ' resize '  , function (  )  {%NWL%if ( win . displayState ! = air . NativeWindowDisplayState . MINIMIZED && win . width > 100 && win . height > 100 )  {%NWL%state . width = win . width ; %NWL%state . height = win . height ; %NWL%3
var resultNode = document . createElement ( tagName || " div "  )  ; %NWL%resultNode . id = id ; %NWL%if ( type )%NWL%resultNode . setAttribute (  " type "  , type )  ; %NWL%document . body . appendChild ( resultNode )  ; %NWL%return resultNode ;%NWL%}%NWL%window . testDivTemplate = ensureNodeExistsAndIsEmpty (  " testDivTemplate "  )  ; %NWL%window . testScriptTemplate = ensureNodeExistsAndIsEmpty (  " testScriptTemplate "  ,  " script "  ,  " text / html "  )  ; %NWL%window . testTextAreaTemplate = ensureNodeExistsAndIsEmpty (  " testTextAreaTemplate "  ,  " textarea "  )  ; %NWL%window . templateOutput = ensureNodeExistsAndIsEmpty (  " templateOutput "  )  ; %NWL%7
tile . blendMode =  ( props . blendMode || this . properties . blendMode ) ? PIXI . blendModes [  ( props . blendMode || this . properties . blendMode )  ]  : PIXI . blendModes . NORMAL ; %NWL%tile . mass = 0 ;  /  / props . mass || 0 ; %NWL%tile . mass = props . mass || 0 ; %NWL%tile . setTexture ( texture )  ; %NWL%tile . setPosition ( position [ 0 ]  , position [ 1 ]  )  ; %NWL%tile . show (  )  ; %NWL%if ( interactive )  {%NWL%tile . click = this . onTileEvent . bind ( this ,  ' click '  , tile )  ; %NWL%tile . mousedown = this . onTileEvent . bind ( this ,  ' mousedown '  , tile )  ; %NWL%tile . mouseup = this . onTileEvent . bind ( this ,  ' mouseup '  , tile )  ; %NWL%tile . mousemove = this . onTileEvent . bind ( this ,  ' mousemove '  , tile )  ; %NWL%7
exports . getRandomOnScreenCel = GameWorldModelIso . prototype . getRandomOnScreenCel ; %NWL%exports . getRandomOnScreenCellWorldValues = GameWorldModelIso . prototype . getRandomOnScreenCellWorldValues ; %NWL%exports . getVisibleCellFromWorldCell = GameWorldModelIso . prototype . getVisibleCellFromWorldCell ; %NWL%exports . getWorldCellFromVisibleCell = GameWorldModelIso . prototype . getWorldCellFromVisibleCell ; %NWL%exports . getWorldCellFromScreenCoord = GameWorldModelIso . prototype . getWorldCellFromScreenCoord ; %NWL%exports . getCell = GameWorldModelIso . prototype . getCell ; %NWL%exports . rightFloor = GameWorldModelIso . prototype . rightFloor ; %NWL%exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%exports . getWorldCellFromVisibleCellPos = GameWorldModelIso . prototype . getWorldCellFromVisibleCellPos ; %NWL%exports . getWorldCellDrawDimensions = GameWorldModelIso . prototype . getWorldCellDrawDimensions ; %NWL%exports . getCellCenter = GameWorldModelIso . prototype . getCellCenter ; %NWL%0
}  ,  " has "  )  ; %NWL%match . hasOwn = createPropertyMatcher ( function ( actual , property )  {%NWL%return actual . hasOwnProperty ( property )  ;%NWL%}  ,  " hasOwn "  )  ; %NWL%match . bool = match . typeOf (  " boolean "  )  ; %NWL%match . number = match . typeOf (  " number "  )  ; %NWL%match . string = match . typeOf (  " string "  )  ; %NWL%match . object = match . typeOf (  " object "  )  ; %NWL%match . func = match . typeOf (  " function "  )  ; %NWL%match . array = match . typeOf (  " array "  )  ; %NWL%match . regexp = match . typeOf (  " regexp "  )  ; %NWL%5
this . type = type ; %NWL%this . key = key ; %NWL%this . keypath = keypath ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%this . bind = __bind ( this . bind , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%this . set = __bind ( this . set , this )  ; %NWL%this . formattedValue = __bind ( this . formattedValue , this )  ; %NWL%4
if ( arr0 . length && arr1 . length )  {%NWL%var anchorPoint0 = new b2Vec2 ( Physics . toMeter ( p0 . x )  , Physics . toMeter ( p0 . y )  )  ; %NWL%var anchorPoint1 = new b2Vec2 ( Physics . toMeter ( p1 . x )  , Physics . toMeter ( p1 . y )  )  ; %NWL%if ( element . isUIDistanceJoint )  {%NWL%rJointDef = new b2DistanceJointDef (  )  ; %NWL%rJointDef . Initialize ( arr0 [ 0 ]  , arr1 [ 0 ]  , anchorPoint0 , anchorPoint1 )  ; %NWL%if ( element . frequencyHz )  {%NWL%rJointDef . frequencyHz = element . frequencyHz ;%NWL%}%NWL%if ( element . dampingRatio )  {%NWL%rJointDef . dampingRatio = element . dampingRatio ; %NWL%7
}  ; %NWL%proto . show = function vp_show (  )  {%NWL%this . _player . hidden = false ;%NWL%}  ; %NWL%proto . hide = function vp_hide (  )  {%NWL%this . _player . hidden = true ;%NWL%}  ; %NWL%proto . load = function vp_load ( url )  {%NWL%this . _player . src = url ;%NWL%}  ; %NWL%proto . release = function vp_release (  )  {%NWL%1
}  ,%NWL%enumerable : true%NWL%}  ,%NWL%bl :  {%NWL%get : function (  )  {%NWL%return this . _bl ;%NWL%}  ,%NWL%set : function ( blValue )  {%NWL%var locBl = this . _bl ; %NWL%locBl . vertices = blValue . vertices ; %NWL%locBl . colors = blValue . colors ; %NWL%9
this . rangeY = pc . checked ( options . rangeY , 1 )  ; %NWL%this . fadeInTime = pc . checked ( options . fadeInTime , 0 )  ; %NWL%this . fadeOutTime = pc . checked ( options . fadeOutTime , 0 )  ; %NWL%this . angleMin = pc . checked ( options . angleMin , 0 )  ; %NWL%this . angleMax = pc . checked ( options . angleMax , 359 )  ; %NWL%this . thrustMin = pc . checked ( options . thrustMin , 1 )  ; %NWL%this . thrustMax = pc . checked ( options . thrustMax , this . thrustMin )  ; %NWL%this . thrustTime = pc . checked ( options . thrustTime , 100 )  ; %NWL%this . burst = pc . checked ( options . burst , 1 )  ; %NWL%this . delay = pc . checked ( options . delay , 25 )  ; %NWL%this . lifeMin = pc . checked ( options . lifeMin , 100 )  ; %NWL%7
pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . strict = options . strict ! =  = false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%3
nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%nl . lang . value = dom . getAttrib ( n ,  ' lang '  )  ; %NWL%nl . usemap . value = dom . getAttrib ( n ,  ' usemap '  )  ; %NWL%0
this . debug = options . debug ;%NWL%}%NWL%this . apiKeyName = options . apiKeyName ! = null ? options . apiKeyName :  ' api_key '  ; %NWL%if ( options . apiKey ! = null )  {%NWL%this . api_key = options . apiKey ;%NWL%}%NWL%if ( options . api_key ! = null )  {%NWL%this . api_key = options . api_key ;%NWL%}%NWL%if ( options . verbose ! = null )  {%NWL%this . verbose = options . verbose ; %NWL%0
OAUTH_CONFIG . AccessTokenUrl ,%NWL%consumerKey ,%NWL%consumerSecret ,%NWL%OAUTH_CONFIG . Version ,%NWL%null ,%NWL%OAUTH_CONFIG . Method%NWL%)  ; %NWL%this . accessKey = options . accessKey ; %NWL%this . accessSecret = options . accessSecret ; %NWL%this . _token = options . _token ; %NWL%this . _token_secret = options . _token_secret ; %NWL%7
if ( Number (  "  - 1234 . 5678e90 "  ) ! =  =  - Number (  " 1234 . 5678e90 "  )  )  {%NWL%$ERROR (  ' #6 : Number (  "  - 1234 . 5678e90 "  )  =  =  =  - Number (  " 1234 . 5678e90 "  )  '  )  ;%NWL%}%NWL%if ( Number (  "  - 1234 . 5678E90 "  ) ! =  =  - Number (  " 1234 . 5678E90 "  )  )  {%NWL%$ERROR (  ' #6 : Number (  "  - 1234 . 5678E90 "  )  =  =  =  - Number (  " 1234 . 5678E90 "  )  '  )  ;%NWL%}%NWL%if ( Number (  "  - 1234 . 5678e - 90 "  ) ! =  =  - Number (  " 1234 . 5678e - 90 "  )  )  {%NWL%$ERROR (  ' #6 : Number (  "  - 1234 . 5678e - 90 "  )  =  =  =  - Number (  " 1234 . 5678e - 90 "  )  '  )  ;%NWL%}%NWL%if ( Number (  "  - 1234 . 5678E - 90 "  ) ! =  =  - Number (  " 1234 . 5678E - 90 "  )  )  {%NWL%$ERROR (  ' #6 : Number (  "  - 1234 . 5678E - 90 "  )  =  =  =  - Number (  " 1234 . 5678E - 90 "  )  '  )  ; %NWL%1
var _x = _tx * this . _zCharWidth * this . _trackingX ; %NWL%var _y = _ty * this . _zCharHeight * this . _trackingY ; %NWL%var _glyph = document . createElement (  ' div '  )  ; %NWL%var _sty = _glyph . style ; %NWL%_sty . position =  ' absolute '  ; %NWL%_sty . width =  '  '  + this . _zCharWidth +  ' px '  ; %NWL%_sty . height =  '  '  + this . _zCharHeight +  ' px '  ; %NWL%_sty . top =  '  '  + _y +  ' px '  ; %NWL%if ( ua . clipnest )  {%NWL%_sty . width = this . img . width +  ' px '  ; %NWL%_sty . height = this . img . height +  ' px '  ; %NWL%9
MockXMLHttpRequest . triggerReadyStateChange = function ( options )  {%NWL%if ( lastInstance )  {%NWL%lastInstance . status = options . status ; %NWL%if ( lastInstance . onreadystatechange )  {%NWL%lastInstance . onreadystatechange (  )  ;%NWL%}%NWL%if ( options . status =  =  = 200 )  {%NWL%lastInstance . response = options . response ; %NWL%lastInstance . onload (  )  ;%NWL%} else {%NWL%lastInstance . statusText = options . statusText ; %NWL%2
req ; %NWL%options =  {%NWL%host : this . host ,%NWL%port : this . port ,%NWL%path : this . path ,%NWL%method : this . method ,%NWL%headers :  {  ' Content - Type '  :  ' application / json '  }%NWL%}  ; %NWL%if ( this . ssl )  {%NWL%options . ca = this . ssl . ca ; %NWL%options . key = this . ssl . key ; %NWL%9
"  .  .  /  .  .  / RectangularValueIndicator "  ,%NWL%"  .  .  / DefaultPropertiesMixin "%NWL%]  ,%NWL%function ( lang , declare , Color , RectangularGauge , LinearScaler , RectangularScale , RectangularValueIndicator , DefaultPropertiesMixin )  {%NWL%return declare (  " dojox . dgauges . components . grey . HorizontalLinearGauge "  ,  [ RectangularGauge , DefaultPropertiesMixin ]  ,  {%NWL%borderColor :  [ 148 , 152 , 161 ]  ,%NWL%fillColor :  [ 148 , 152 , 161 ]  ,%NWL%indicatorColor :  [ 63 , 63 , 63 ]  ,%NWL%constructor : function (  )  {%NWL%this . borderColor = new Color ( this . borderColor )  ; %NWL%this . fillColor = new Color ( this . fillColor )  ; %NWL%9
function BaseParams (  )  {%NWL%this . checkReqParamsOk = __bind ( this . checkReqParamsOk , this )  ; %NWL%this . getPostValue = __bind ( this . getPostValue , this )  ; %NWL%this . getTableName = __bind ( this . getTableName , this )  ; %NWL%this . getLimit = __bind ( this . getLimit , this )  ; %NWL%this . getOffset = __bind ( this . getOffset , this )  ; %NWL%this . getGroup = __bind ( this . getGroup , this )  ; %NWL%this . getSort = __bind ( this . getSort , this )  ; %NWL%this . getQuery = __bind ( this . getQuery , this )  ; %NWL%this . getFilter = __bind ( this . getFilter , this )  ; %NWL%this . setReq = __bind ( this . setReq , this )  ; %NWL%1
vec3 . lerp ( this . scale , c1 . scale , c2 . scale , w )  ; %NWL%quat . slerp ( this . rotation , c1 . rotation , c2 . rotation , w )  ;%NWL%}  ; %NWL%TransformClip . prototype . blend2D =  ( function (  )  {%NWL%var q1 = quat . create (  )  ; %NWL%var q2 = quat . create (  )  ; %NWL%return function ( c1 , c2 , c3 , f , g )  {%NWL%var a = 1 - f - g ; %NWL%this . position [ 0 ]  = c1 . position [ 0 ]  * a + c2 . position [ 0 ]  * f + c3 . position [ 0 ]  * g ; %NWL%this . position [ 1 ]  = c1 . position [ 1 ]  * a + c2 . position [ 1 ]  * f + c3 . position [ 1 ]  * g ; %NWL%this . position [ 2 ]  = c1 . position [ 2 ]  * a + c2 . position [ 2 ]  * f + c3 . position [ 2 ]  * g ; %NWL%8
spec . destWidth ,%NWL%spec . destHeight%NWL%)  ;%NWL%}  ; %NWL%slice . loop = options && options . loop ; %NWL%slice . frameDelay =  ( options && options . frameDelay ! =  = undefined ) ? options . frameDelay : 4 ; %NWL%slice . numberOfFrames =  ( options && options . numberOfFrames ) || 1 ; %NWL%slice . numberOfRows =  ( options && options . numberOfRows ) || 1 ; %NWL%slice . numberOfColumns =  ( options && options . numberOfColumns ) ? options . numberOfColumns : slice . numberOfFrames ; %NWL%slice . autoPlay =  ( options && options . autoPlay ! =  = undefined ) ? options . autoPlay : true ; %NWL%slice . resetOnComplete =  ( options && options . resetOnComplete ! =  = undefined ) ? options . resetOnComplete : true ; %NWL%9
module . exports = ElasticSearchCall ; %NWL%function ElasticSearchCall ( params , options , cb )  {%NWL%var self = this%NWL%self . host = options . host || ' localhost '  ; %NWL%self . port = options . port || 80 ; %NWL%self . secure = options . secure || false ; %NWL%self . defaultMethod = options . defaultMethod || ' GET '  ; %NWL%self . auth = options . auth || false ; %NWL%self . params = params || {  }  ; %NWL%self . path =  [ options . pathPrefix || '  '  , options . path || '  '  ]  . join (  '  '  )  ; %NWL%self . timeout = options . timeout || false ; %NWL%5
deliver : function (  )  {  }  ,%NWL%close : function (  )  {  }  ,%NWL%}%NWL%function Expression ( delegate )  {%NWL%this . scopeIdent = delegate . scopeIdent ; %NWL%this . indexIdent = delegate . indexIdent ; %NWL%if ( !delegate . expression )%NWL%throw Error (  ' No expression found .  '  )  ; %NWL%this . expression = delegate . expression ; %NWL%getFn ( this . expression )  ;  /  / forces enumeration of path dependencies%NWL%this . filters = delegate . filters ; %NWL%4
function _applyInnerProperties ( properties )  {%NWL%var apply =  {  }  ; %NWL%if ( properties . padding )  {%NWL%if ( typeof properties . padding =  =  =  ' object '  )  {%NWL%if ( _ . isArray ( properties . padding )  )  {%NWL%var ln = properties . padding . length ; %NWL%if ( ln =  =  = 1 )  {%NWL%apply . top = properties . padding [ 0 ]  ; %NWL%apply . right = apply . right ; %NWL%apply . bottom = apply . bottom ; %NWL%apply . left = apply . left ; %NWL%8
IN . old_mouse_y = 0 . 0 ; %NWL%IN . StartupMouse = function (  )%NWL%{%NWL%IN . m_filter = Cvar . RegisterVariable (  ' m_filter '  ,  ' 1 '  )  ; %NWL%if ( COM . CheckParm (  '  - nomouse '  ) ! = null )%NWL%return ; %NWL%if ( VID . mainwindow . pointerLockElement ! = null )%NWL%{%NWL%IN . movementX =  ' movementX '  ; %NWL%IN . movementY =  ' movementY '  ; %NWL%IN . pointerLockElement =  ' pointerLockElement '  ; %NWL%8
}  ; %NWL%ST . Models . Startup = Backbone . Model . extend (  {%NWL%url : function (  )  {%NWL%return " https :  /  / api . angel . co / 1 / startups /  "  + this . get (  " id "  )  +  " ?callback = ? "  ;%NWL%}%NWL%}  )  ; %NWL%ST . Collections . PaginatedCollection = Backbone . Collection . extend (  {%NWL%initialize : function ( attributes , options )  {%NWL%options =  ( options || {  }  )  ; %NWL%options . page = options . page || 1 ; %NWL%options . pages = options . pages || 1 ; %NWL%9
app . get (  "  / hosts "  , function ( req , res )  {%NWL%res . render (  ' host '  ,  {%NWL%hosts : hosts ,%NWL%host : null%NWL%}  )  ;%NWL%}  )  ; %NWL%app . post (  "  / hosts / add "  , function ( req , res , next )  {%NWL%var host =  {  }  ; %NWL%try {%NWL%host . host = req . body . host ; %NWL%host . name = req . body . name ; %NWL%9
}  ; %NWL%function update_current_modifiers ( key )  {%NWL%current_keys . ctrl = key . ctrl ; %NWL%current_keys . alt = key . alt ; %NWL%current_keys . shift = key . shift ; %NWL%current_keys . meta = key . meta ;%NWL%}  ; %NWL%function same_modifiers ( key1 , key2 )  {%NWL%return key1 . ctrl =  =  = key2 . ctrl%NWL%&& key1 . alt =  =  = key2 . alt%NWL%&& key1 . shift =  =  = key2 . shift%NWL%9
if ( mockHandler . proxy )  {%NWL%_ajax (  {%NWL%global : false ,%NWL%url : mockHandler . proxy ,%NWL%type : mockHandler . proxyType ,%NWL%data : mockHandler . data ,%NWL%dataType : requestSettings . dataType =  =  =  " script " ? " text / plain "  : requestSettings . dataType ,%NWL%complete : function ( xhr , txt )  {%NWL%mockHandler . responseXML = xhr . responseXML ; %NWL%mockHandler . responseText = xhr . responseText ; %NWL%mockHandler . status = xhr . status ; %NWL%8
}%NWL%else if ( addrstr )  {%NWL%var obj = addrstr ; %NWL%this . set ( obj )  ;%NWL%}%NWL%}  ; %NWL%SAddress . mainver = 42 ; %NWL%SAddress . testver = 43 ; %NWL%SAddress . prototype . set = function ( obj )  {%NWL%this . payloadPubkey = obj . payloadPubkey || this . payloadPubkey ; %NWL%this . scanPubkey = obj . scanPubkey || this . scanPubkey ; %NWL%9
var _ = require (  ' underscore '  )  ,%NWL%async = require (  ' async '  )  ,%NWL%fs = require (  ' fs '  )  ,%NWL%fu = require (  '  .  / fileUtil '  )  ,%NWL%resources = require (  '  .  / util / resources '  )  ; %NWL%function Context ( options , config , plugins , libraries , event )  {%NWL%this . _package = options . package ; %NWL%this . _platform = options . platform ; %NWL%this . _plugins = plugins ; %NWL%this . mode = options . mode ; %NWL%this . module = options . module ; %NWL%9
contentElement : null ,%NWL%contentWrapperElement : null ,%NWL%options :  {%NWL%scroll :  ' vertial '  ,%NWL%scrollbar :  ' vertical '  ,%NWL%momentum : true ,%NWL%bounce : true%NWL%}  ,%NWL%initialize : function ( contentElement , contentWrapperElement , options )  {%NWL%this . contentElement = document . id ( contentElement )  ; %NWL%this . contentWrapperElement = document . id ( contentWrapperElement )  ; %NWL%9
this . minSize = other . minSize ; %NWL%this . maxSize = other . maxSize ; %NWL%this . sizeTween . copy ( other . sizeTween )  ; %NWL%this . alphaTween . copy ( other . alphaTween )  ; %NWL%this . colorTween . copy ( other . colorTween )  ; %NWL%this . velocity . copy ( other . velocity )  ; %NWL%this . velocitySpread . copy ( other . velocitySpread )  ; %NWL%this . acceleration . copy ( other . acceleration )  ; %NWL%this . accelerationSpread . copy ( other . accelerationSpread )  ; %NWL%this . angularVelocity = other . angularVelocity ; %NWL%this . angularVelocitySpread = other . angularVelocitySpread ; %NWL%0
destroyed :  ' dispose '  ,%NWL%' click li [ data - filename ]  '  :  ' _fileClicked '  ,%NWL%' click button . close '  :  ' _deleteClicked '  ,%NWL%' dblclick li [ data - filename ]  '  :  ' _fileChosen '%NWL%}  ,%NWL%className :  " fileBrowser "  ,%NWL%initialize : function (  )  {%NWL%this . render = this . render . bind ( this )  ; %NWL%this . storageInterface . on (  " change : currentProvider "  , this . render )  ; %NWL%this . template = JST [  ' tantaman . web . widgets / FileBrowser '  ]  ; %NWL%this . renderListing = this . renderListing . bind ( this )  ; %NWL%7
url : null ,%NWL%bounds : null ,%NWL%size : null ,%NWL%position : null ,%NWL%isLoading : false ,%NWL%initialize : function ( layer , position , bounds , url , size )  {%NWL%this . layer = layer ; %NWL%this . position = position . clone (  )  ; %NWL%this . bounds = bounds . clone (  )  ; %NWL%this . url = url ; %NWL%this . size = size . clone (  )  ; %NWL%7
this . addText ( DB . getMessage ( 317 + MapPreferences . miss )  , this . TYPE . INFO )  ; %NWL%MapPreferences . miss = !MapPreferences . miss ; %NWL%MapPreferences . save (  )  ; %NWL%return ; %NWL%case ' camera '  : %NWL%this . addText ( DB . getMessage ( 319 + CameraPreferences . smooth )  , this . TYPE . INFO )  ; %NWL%CameraPreferences . smooth = !CameraPreferences . smooth ; %NWL%CameraPreferences . save (  )  ; %NWL%return ; %NWL%case ' fog '  : %NWL%MapPreferences . fog = !MapPreferences . fog ; %NWL%1
contenthandler : Aloha . settings . contentHandler . insertHtml ,%NWL%command :  ' insertHtml '%NWL%}  )  ;%NWL%}%NWL%Engine . execCommand ( commandId , showUi , value , range )  ; %NWL%if ( Aloha . getSelection (  )  . getRangeCount (  )  )  {%NWL%range = Aloha . getSelection (  )  . getRangeAt ( 0 )  ; %NWL%var startnode = range . commonAncestorContainer ; %NWL%var rangeObject = new window . GENTICS . Utils . RangeObject (  )  ; %NWL%rangeObject . startContainer = range . startContainer ; %NWL%rangeObject . startOffset = range . startOffset ; %NWL%9
}  )  ;%NWL%}  ,%NWL%init : function (  )  {%NWL%var $this = this , tpl = UI . components . htmleditor . template ; %NWL%this . CodeMirror = this . options . CodeMirror || CodeMirror ; %NWL%this . buttons  =  {  }  ; %NWL%tpl = tpl . replace (  / \ {  : lblPreview\ }  / g , this . options . lblPreview )  ; %NWL%tpl = tpl . replace (  / \ {  : lblCodeview\ }  / g , this . options . lblCodeview )  ; %NWL%this . htmleditor = UI . $ ( tpl )  ; %NWL%this . content  = this . htmleditor . find (  '  . @ - htmleditor - content '  )  ; %NWL%this . toolbar  = this . htmleditor . find (  '  . @ - htmleditor - toolbar '  )  ; %NWL%9
}  ,%NWL%" connection :  : end "  : function ( data )  {%NWL%var self = this ; %NWL%if ( data . proposedRank >  = self . proposedRank )  {%NWL%self . proposedRank = self . proposedRank - 1 ; %NWL%self . emit (  ' hook :  : rank :  : accepting '  , self . proposedRank )  ;%NWL%}%NWL%}  ,%NWL%" hook :  : disconnected "  : function ( data )  {%NWL%var self = this ; %NWL%self . clientCount = self . clientCount - 1 ; %NWL%4
break ; %NWL%case " select - one "  : %NWL%case " select - multiple "  : %NWL%this . values = new Array (  )  ; %NWL%for ( var i = 0 ; i < element . options . length ;  +  + i )  {%NWL%if ( element . options [ i ]  . selected&& ( !this . exclude||element . options [ i ]  . value! = this . exclude )  )  {%NWL%this . values [ this . values . length ]  = element . options [ i ]  . value ;%NWL%}%NWL%}%NWL%this . min = element . min||element . getAttribute (  ' min '  )  ; %NWL%this . max = element . max||element . getAttribute (  ' max '  )  ; %NWL%9
this . assert = function (  )  { log ( arguments ,  ' assert '  )  ;  }  ; %NWL%this . clear = function (  )  { log ( arguments ,  ' clear '  )  ;  }  ; %NWL%this . count = function (  )  { log ( arguments ,  ' count '  )  ;  }  ; %NWL%this . debug = function (  )  { log ( arguments ,  ' debug '  )  ;  }  ; %NWL%this . dir = function (  )  { log ( arguments ,  ' dir '  )  ;  }  ; %NWL%this . dirxml = function (  )  { log ( arguments ,  ' dirxml '  )  ;  }  ; %NWL%this . error = function (  )  { log ( arguments ,  ' error '  )  ;  }  ; %NWL%this . exception = function (  )  { log ( arguments ,  ' exception '  )  ;  }  ; %NWL%this . group = function (  )  { log ( arguments ,  ' group '  )  ;  }  ; %NWL%this . groupCollapsed = function (  )  { log ( arguments ,  ' groupCollapsed '  )  ;  }  ; %NWL%this . groupEnd = function (  )  { log ( arguments ,  ' groupEnd '  )  ;  }  ; %NWL%0
size = l . preferred ( that )  ; %NWL%minSize = that . minimumSize (  )  ; %NWL%maxSize = that . maximumSize (  )  ; %NWL%size . width +  = margin . left + margin . right ; %NWL%size . height +  = margin . top + margin . bottom ; %NWL%if ( size . width < minSize . width || size . height < minSize . height )  {%NWL%size . width = Math . max ( size . width , minSize . width )  ; %NWL%size . height = Math . max ( size . height , minSize . height )  ;%NWL%} else if ( size . width > maxSize . width || size . height > maxSize . height )  {%NWL%size . width = Math . min ( size . width , maxSize . width )  ; %NWL%size . height = Math . min ( size . height , maxSize . height )  ; %NWL%9
}%NWL%}%NWL%}  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%8
if ( helper . isString ( options . autoWatch )  )  {%NWL%options . autoWatch = options . autoWatch =  =  =  ' true '  ;%NWL%}%NWL%if ( helper . isString ( options . colors )  )  {%NWL%options . colors = options . colors =  =  =  ' true '  ;%NWL%}%NWL%if ( helper . isString ( options . logLevel )  )  {%NWL%options . logLevel = constant [  ' LOG_ '  + options . logLevel . toUpperCase (  )  ] || constant . LOG_DISABLE ;%NWL%}%NWL%if ( helper . isString ( options . singleRun )  )  {%NWL%options . singleRun = options . singleRun =  =  =  ' true '  ; %NWL%1
}  ; %NWL%Runner . prototype . runMocha_ = function ( specs , done )  {%NWL%var Mocha = require (  ' mocha '  )  ,%NWL%mocha = new Mocha ( this . config_ . mochaOpts )  ,%NWL%self = this ; %NWL%mocha . suite . on (  ' pre - require '  , function (  )  {%NWL%var mochaAdapters = require (  ' selenium - webdriver / testing '  )  ; %NWL%global . after = mochaAdapters . after ; %NWL%global . afterEach = mochaAdapters . afterEach ; %NWL%global . before = mochaAdapters . before ; %NWL%global . beforeEach = mochaAdapters . beforeEach ; %NWL%7
function CrudApi ( dbProvider , clientApi , crudOperation )  {%NWL%this . dbProvider = dbProvider ; %NWL%crudOperations = crudOperation ; %NWL%this . clientApi = clientApi ; %NWL%this . crudOperation = crudOperation ; %NWL%this . actionEnd = __bind ( this . actionEnd , this )  ; %NWL%this . actionProcess = __bind ( this . actionProcess , this )  ; %NWL%this . tryAction = __bind ( this . tryAction , this )  ; %NWL%this . getTree = __bind ( this . getTree , this )  ; %NWL%this . removeAll = __bind ( this . removeAll , this )  ; %NWL%this . remove = __bind ( this . remove , this )  ; %NWL%5
}  )  ;%NWL%}  )  ; %NWL%controls =  {%NWL%progress :  {%NWL%init : function (  )  {%NWL%this . duration = null ; %NWL%this . seeking = false ; %NWL%this . progressBar = dijit . byId (  " progress "  )  ; %NWL%dojo . connect ( this . progressBar . sliderHandle ,  " mousedown "  , this ,  " startDrag "  )  ; %NWL%this . timeNode = dojo . byId (  " timeNode "  )  ; %NWL%this . durNode = dojo . byId (  " durNode "  )  ; %NWL%9
base . Textures = base . Textures ; %NWL%base . Textures_obj = base . Textures_obj ; %NWL%base . Images = base . Images ; %NWL%base . globalAmbient =  [ 0 . 1 , 0 . 1 , 0 . 1 ]  ; %NWL%base . setGlobalAmbient = function ( c )  {%NWL%base . globalAmbient = c ;%NWL%}  ; %NWL%base . setGlobalDepthAlpha = GLCore . setDepthAlpha ; %NWL%base . setDefaultFilter = GLCore . setDefaultFilter ; %NWL%base . setSoftShadows = GLCore . setSoftShadows ; %NWL%base . setQuality = GLCore . setQuality ; %NWL%8
this . use_layers = false ; %NWL%if ( document . getElementById )  { this . use_gebi = true ;  }%NWL%else if ( document . all )  { this . use_css = true ;  }%NWL%else if ( document . layers )  { this . use_layers = true ;  }%NWL%else { this . type =  " WINDOW "  ;  }%NWL%this . offsetX = 0 ; %NWL%this . offsetY = 0 ; %NWL%this . getXYPosition = PopupWindow_getXYPosition ; %NWL%this . populate = PopupWindow_populate ; %NWL%this . setUrl = PopupWindow_setUrl ; %NWL%this . setWindowProperties = PopupWindow_setWindowProperties ; %NWL%7
var context = canvas_qr . getContext (  ' 2d '  )  ; %NWL%var nheight = image . height ; %NWL%var nwidth = image . width ; %NWL%if ( image . width * image . height > qrcode . maxImgSize )%NWL%{%NWL%var ir = image . width / image . height ; %NWL%nheight = Math . sqrt ( qrcode . maxImgSize / ir )  ; %NWL%nwidth = ir * nheight ;%NWL%}%NWL%canvas_qr . width = nwidth ; %NWL%canvas_qr . height = nheight ; %NWL%9
{%NWL%args [ 0 ]  +  =  " %o "  ;%NWL%}%NWL%}%NWL%Function . apply . call ( log , console , args )  ;%NWL%}  ; %NWL%console . log = bind ( wrap , window , console . log )  ; %NWL%console . debug = bind ( wrap , window , console . debug )  ; %NWL%console . info = bind ( wrap , window , console . info )  ; %NWL%console . warn = bind ( wrap , window , console . warn )  ; %NWL%console . error = bind ( wrap , window , console . error )  ; %NWL%6
}%NWL%var t =  {%NWL%length : newTicks . length ,%NWL%offset : newTicks . offset ,%NWL%noChange : true%NWL%}  ; %NWL%if ( newTicks . color )  {%NWL%t . color = newTicks . color ;%NWL%}%NWL%if ( newTicks . font )  {%NWL%t . font = newTicks . font ; %NWL%7
}%NWL%if ( options . my [ 1 ]  =  =  =  " bottom "  )  {%NWL%position . top -  = elemHeight ;%NWL%} else if ( options . my [ 1 ]  =  =  =  " center "  )  {%NWL%position . top -  = elemHeight / 2 ;%NWL%}%NWL%position . left +  = myOffset [ 0 ]  ; %NWL%position . top +  = myOffset [ 1 ]  ; %NWL%if ( !$ . support . offsetFractions )  {%NWL%position . left = round ( position . left )  ; %NWL%position . top = round ( position . top )  ; %NWL%9
}  ; %NWL%module . exports = function ( client , callback )  {%NWL%var test = application . test ,%NWL%res =  [  ]  ; %NWL%for ( var i = 0 ; i < 10 ; i +  +  )  {%NWL%var obj =  {  }  ; %NWL%obj . name = test . randomItem ( test . names )  ; %NWL%obj . city = test . randomItem ( test . cities )  ; %NWL%obj . birth = test . random ( 1 , 500 )  +  '  '  + test . randomItem (  [  ' BC '  ,  ' AD '  ]  )  ; %NWL%obj . age = test . random ( 25 , 90 )  ; %NWL%obj . school = test . randomItem ( test . schools )  ; %NWL%6
RtmpChunk . prototype . inheritPrevious = function ( Previous )  {%NWL%if ( this . format =  =  = 0 || ! Previous )  {%NWL%return ;%NWL%}%NWL%this . messageStreamId = Previous . messageStreamId ; %NWL%if ( this . format =  =  = 3 )  {%NWL%this . timestamp = Previous . timestamp ;%NWL%}%NWL%if ( this . format =  =  = 2 || this . format =  =  = 3 )  {%NWL%this . messageLen = Previous . messageLen ; %NWL%this . messageType = Previous . messageType ; %NWL%4
function PostEffects (  )  {%NWL%}%NWL%PostEffects . prototype . updateShader = function ( sm )  {%NWL%var shader = sm . get (  " shaders / posteffects . cgfx "  )  ; %NWL%if ( shader ! =  = this . shader )  {%NWL%this . shader = shader ; %NWL%this . bicolor . technique = shader . getTechnique (  " bicolor "  )  ; %NWL%this . copy . technique = shader . getTechnique (  " copy "  )  ; %NWL%this . copyFiltered . technique = shader . getTechnique (  " copyFiltered "  )  ; %NWL%this . fadein . technique = shader . getTechnique (  " fadein "  )  ; %NWL%this . modulate . technique = shader . getTechnique (  " modulate "  )  ; %NWL%6
locTweenData . x +  = locBoneData . x ; %NWL%locTweenData . y +  = locBoneData . y ; %NWL%locTweenData . skewX +  = locBoneData . skewX ; %NWL%locTweenData . skewY +  = locBoneData . skewY ; %NWL%locTweenData . scaleX +  = locBoneData . scaleX ; %NWL%locTweenData . scaleY +  = locBoneData . scaleY ; %NWL%locTweenData . scaleX -  = 1 ; %NWL%locTweenData . scaleY -  = 1 ;%NWL%}%NWL%locWorldInfo . x = locTweenData . x + this . _position . x ; %NWL%locWorldInfo . y = locTweenData . y + this . _position . y ; %NWL%9
flex : inSliding . flex ,%NWL%height : inSliding . domStyles . height ,%NWL%peekHeight : inSliding . peekHeight ,%NWL%fixedHeight : inSliding . fixedHeight%NWL%}  ;%NWL%}  ,%NWL%uncacheSliding : function ( inSliding , inIndex )  {%NWL%var s = this . slidingCache [ inIndex ]  ; %NWL%if ( s )  {%NWL%inSliding . flex = s . flex ; %NWL%inSliding . peekHeight = s . peekHeight ; %NWL%9
context . lineWidth = 0 . 5 ; %NWL%drawVerticalLine ( x )  ; %NWL%drawHorizontalLine ( y )  ; %NWL%context . restore (  )  ;%NWL%}%NWL%canvas . onmousedown = function ( e )  {%NWL%var loc = windowToCanvas ( e . clientX , e . clientY )  ; %NWL%e . preventDefault (  )  ;  /  / prevent cursor change%NWL%saveDrawingSurface (  )  ; %NWL%mousedown . x = loc . x ; %NWL%mousedown . y = loc . y ; %NWL%9
CALL_FORWARD_ACTION_QUERY_STATUS : 2 ,%NWL%CALL_FORWARD_ACTION_REGISTRATION : 3 ,%NWL%CALL_FORWARD_ACTION_ERASURE : 4%NWL%}  ; %NWL%suiteSetup ( function (  )  {%NWL%realMozSettings = window . navigator . mozSettings ; %NWL%window . navigator . mozSettings = MockNavigatorSettings ; %NWL%realSIMSlotManager = window . SIMSlotManager ; %NWL%window . SIMSlotManager = MockSIMSlotManager ; %NWL%realSettingsHelper = window . SettingsHelper ; %NWL%window . SettingsHelper = MockSettingsHelper ; %NWL%8
Mustache ,%NWL%_ ,%NWL%calc ,%NWL%worldCursor ,%NWL%sceneModel ,%NWL%geometryGraph ,%NWL%GeomVertexMV )  {%NWL%var EditingModel = GeomVertexMV . EditingModel . extend (  {%NWL%initialize : function ( options )  {%NWL%this . DOMView = EditingDOMView ; %NWL%this . SceneView = EditingSceneView ; %NWL%9
VMM . Lib . addClass ( $timeline ,  " vco - right - to - left "  )  ;%NWL%}%NWL%slider		 = new VMM . Slider ( $slider , config )  ; %NWL%timenav		 = new VMM . Timeline . TimeNav ( $navigation )  ; %NWL%if ( !has_width )  {%NWL%config . width = VMM . Lib . width ( $timeline )  ;%NWL%} else {%NWL%VMM . Lib . width ( $timeline , config . width )  ;%NWL%}%NWL%if ( !has_height )  {%NWL%config . height = VMM . Lib . height ( $timeline )  ; %NWL%5
this . centerLonLat = null ; %NWL%if (  ( this . left =  = null ) || ( bounds . left < this . left )  )  {%NWL%this . left = bounds . left ;%NWL%}%NWL%if (  ( this . bottom =  = null ) || ( bounds . bottom < this . bottom )  )  {%NWL%this . bottom = bounds . bottom ;%NWL%}%NWL%if (  ( this . right =  = null ) || ( bounds . right > this . right )  )  {%NWL%this . right = bounds . right ;%NWL%}%NWL%if (  ( this . top =  = null ) || ( bounds . top > this . top )  )  {%NWL%7
this . active = false ; %NWL%this . queue =  [  ]  ;%NWL%}  ; %NWL%$ . SeamlessConnection . prototype . send = function ( pm )  {%NWL%if ( this . active && this . target )  {%NWL%pm = pm || {  }  ; %NWL%if ( !pm . hasOwnProperty (  ' data '  )  )  {%NWL%pm =  { data : pm }  ;%NWL%}%NWL%pm . target = this . target ; %NWL%pm . url = this . url ; %NWL%9
this . type = options . type ;%NWL%}%NWL%if ( options . taxonomy )  {%NWL%this . taxonomy = options . taxonomy ;%NWL%}%NWL%}%NWL%this . on (  ' add '  , _ . bind ( this . addModel , this )  )  ;%NWL%}  ,%NWL%addModel : function ( model )  {%NWL%model . type = this . type ; %NWL%model . taxonomy = this . taxonomy ; %NWL%9
}  ; %NWL%PageTestLogSchema . methods . hasWarning = function (  )  {%NWL%return this . warnings && this . warnings . length > 0 ;%NWL%}  ; %NWL%PageTestLogSchema . methods . created_at_format = function (  )  {%NWL%return moment ( this . created_at )  . format (  " DD - MM - YY HH : mm "  )  ;%NWL%}  ; %NWL%exports . PluginTest = db . model (  ' PluginTest '  , PluginTestSchema )  ; %NWL%exports . PageTestLog = db . model (  ' PageTestLog '  , PageTestLogSchema )  ; %NWL%exports . TestUrlsSet = db . model (  ' TestUrlsSet '  , TestUrlsSetSchema )  ; %NWL%exports . TestingProgress = db . model (  ' TestingProgress '  , TestingProgressSchema )  ; %NWL%7
if ( this . left > aabb . left )  {%NWL%this . left = aabb . left ;%NWL%}%NWL%if ( this . right < aabb . right )  {%NWL%this . right = aabb . right ;%NWL%}%NWL%if ( this . top > aabb . top )  {%NWL%this . top = aabb . top ;%NWL%}%NWL%if ( this . bottom < aabb . bottom )  {%NWL%this . bottom = aabb . bottom ; %NWL%1
if ( !date ) return new Date (  )  ; %NWL%if ( typeof date =  =  =  ' string '  ) return new Date ( date )  ; %NWL%return date ;%NWL%}  ; %NWL%var Stat = function ( opts )  {%NWL%this . uid = opts . uid || 0 ; %NWL%this . gid = opts . gid || 0 ; %NWL%this . mode = opts . mode || 0 ; %NWL%this . size = opts . size || 0 ; %NWL%this . mtime = toDate ( opts . mtime )  ; %NWL%this . atime = toDate ( opts . atime )  ; %NWL%9
setPaths : function ( data )  {%NWL%if ( data . workersDir )  {%NWL%this . workersDir = this . _qualifyURL ( data . workersDir )  ; %NWL%PooledWorker . prototype . workersDir = this . workersDir ;%NWL%}%NWL%if ( data . externalsDir )  {%NWL%this . externalsDir = this . _qualifyURL ( data . externalsDir )  ; %NWL%PooledWorker . prototype . externalsDir = this . externalsDir ;%NWL%}%NWL%if ( data . imagesDir )  {%NWL%this . imagesDir = this . _qualifyURL ( data . imagesDir )  ; %NWL%2
tabIndex :  "  - 1 "  ,%NWL%dropDown : this . dropDown%NWL%}  )  ; %NWL%messages . id = dijit . getUniqueId ( this . editor . id )  ; %NWL%this . _uniqueId = messages . id ; %NWL%this . dropDown . set (  ' content '  , dropDown . title +%NWL%"  < div style =  ' border - bottom : 1px black solid ; padding - bottom : 2pt ; margin - bottom : 4pt '  >  <  / div >  "  +%NWL%dojo . string . substitute ( this . _template , messages )  )  ; %NWL%dropDown . startup (  )  ; %NWL%this . _anchorInput = dijit . byId ( this . _uniqueId +  " _anchorInput "  )  ; %NWL%this . _textInput = dijit . byId ( this . _uniqueId +  " _textInput "  )  ; %NWL%9
assert . ok = ok ; %NWL%assert . deepEqual = function deepEqual ( actual , expected , message )  {%NWL%expect ( actual )  . to . eql ( expected , message )  ;%NWL%}  ; %NWL%assert . notDeepEqual = function notDeepEqual ( actual , expected , message )  {%NWL%expect ( actual )  . to . not . eql ( expected , message )  ;%NWL%}  ; %NWL%assert . strictEqual = function strictEqual ( actual , expected , message )  {%NWL%expect ( actual )  . to . equal ( expected , message )  ;%NWL%}  ; %NWL%assert . notStrictEqual = function notStrictEqual ( actual , expected , message )  {%NWL%1
this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if (  / \bglob\b /  . test ( process . env . NODE_DEBUG || '  '  )  )%NWL%this . debug = true%NWL%if ( this . debug )%NWL%this . log = console . error%NWL%this . silent = !!options . silent%NWL%0
ev = document . createEvent (  ' Events '  )  ; %NWL%ev . initEvent ( na , true , true )  ; %NWL%ev . keyCode = o . keyCode ; %NWL%ev . charCode = o . charCode ;%NWL%}%NWL%} else {%NWL%ev = document . createEvent (  ' UIEvents '  )  ; %NWL%if ( ev . initUIEvent )%NWL%ev . initUIEvent ( na , true , true , window , 1 )  ; %NWL%ev . keyCode = o . keyCode ; %NWL%ev . charCode = o . charCode ; %NWL%2
sa . m = Main . get ( key )  . change ; %NWL%for ( var i in player . activeList )  {%NWL%var obj = ActiveList . get ( i )  ; %NWL%if ( !obj )  { delete player . activeList [ i ]  ; ERROR ( 2 ,  ' no act '  )  ; continue ;  }%NWL%if ( player . activeList [ i ] ! =  = ActiveList . SEEN )  { 		 /  / Need to Init%NWL%sa . i = sa . i || {  }  ; %NWL%sa . i [ obj . id ]  = Send . init ( obj )  ; %NWL%player . activeList [ i ]  = ActiveList . SEEN ;%NWL%} else {%NWL%if ( !obj . change . $isEmpty (  ) || LOOP100 )  {%NWL%sa . u = sa . u || {  }  ; %NWL%5
this . lastSentDocData = docData ;%NWL%} else {%NWL%log ( DEBUG ,  ' No updates to send / should not happen '  )  ;%NWL%}%NWL%}%NWL%}%NWL%var range = this . getRange ? this . getRange (  )  : null ; %NWL%if ( range )  {%NWL%range = expandRange ( range )  ; %NWL%range . start = range . start . jsmirrorId ; %NWL%range . end = range . end . jsmirrorId ; %NWL%9
result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%6
this . app . settings . pictureSizes = sinon . createStubInstance ( this . Setting )  ; %NWL%this . app . settings . isoModes = sinon . createStubInstance ( this . Setting )  ; %NWL%this . app . settings . recorderProfiles = sinon . createStubInstance ( this . Setting )  ; %NWL%this . app . settings . flashModes = sinon . createStubInstance ( this . Setting )  ; %NWL%this . app . settings . whiteBalance = sinon . createStubInstance ( this . Setting )  ; %NWL%this . app . settings . hdr = sinon . createStubInstance ( this . Setting )  ; %NWL%this . app . settings . flashModesPicture = sinon . createStubInstance ( this . Setting )  ; %NWL%this . app . settings . timer = sinon . createStubInstance ( this . Setting )  ; %NWL%this . settings = this . app . settings ; %NWL%this . notification = this . app . views . notification ; %NWL%this . storage = this . app . storage ; %NWL%8
}%NWL%}  ,%NWL%{%NWL%init : function (  )  {%NWL%if ( !this . params ) return ; %NWL%var params = this . params ; %NWL%this . drug = params . drug ; %NWL%this . dose = params . dose ; %NWL%this . doseUnit = params . doseUnit ; %NWL%this . strength = params . strength ; %NWL%this . strengthUnit = params . strengthUnit ; %NWL%6
} else {%NWL%entitySchemata . push ( s )  ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%$scope . relationSchemaOptions = relationSchemata ; %NWL%$scope . entitySchemaOptions = entitySchemata ; %NWL%var search = $location . search (  )  ; %NWL%$scope . relationSchema = search . relationSchema || relationSchemata [ 0 ]  . name ; %NWL%$scope . sourceSchema = $location . search (  )  . sourceSchema || entitySchemata [ 0 ]  . name ; %NWL%$scope . targetSchema = $location . search (  )  . targetSchema || entitySchemata [ 0 ]  . name ; %NWL%9
children%NWL%}  )  ;%NWL%}%NWL%export function select ( locals )  {%NWL%const config = new SelectConfig ( locals . config || {  }  )  ; %NWL%const attrs = t . mixin (  {  }  , locals . attrs )  ; %NWL%attrs . className = t . mixin (  {  }  , attrs . className )  ; %NWL%attrs . className [  ' form - control '  ]  = true ; %NWL%attrs . multiple = locals . isMultiple ; %NWL%attrs . disabled = locals . disabled ; %NWL%attrs . value = locals . value ; %NWL%9
function GalleryController (%NWL%$scope , $window , $location , $anchorScroll , $http , gallery , galleries )  {%NWL%this . $scope = $scope ; %NWL%this . $window = $window ; %NWL%this . $location = $location ; %NWL%this . $anchorScroll = $anchorScroll ; %NWL%this . $http = $http ; %NWL%this . changeGallery = this . changeGallery . bind ( this )  ; %NWL%this . changePhoto = this . changePhoto . bind ( this )  ; %NWL%this . onKeyup = this . onKeyup . bind ( this )  ; %NWL%this . parseSearch = this . parseSearch . bind ( this )  ; %NWL%7
this . model . unset (  ' body '  )  ; %NWL%if ( activity . isInsight (  )  )  {%NWL%this . setInsight (  )  ;%NWL%} else {%NWL%this . setNote (  )  ;%NWL%}%NWL%}%NWL%}  ,%NWL%setComment : function (  )  {%NWL%this . text = t (  " comments . delete . alert . text "  )  ; %NWL%this . title = t (  " comments . delete . alert . title "  )  ; %NWL%9
this . m00_ = m00 ; %NWL%this . m10_ = m10 ; %NWL%this . m01_ = m01 ; %NWL%this . m11_ = m11 ; %NWL%this . m02_ = m02 ; %NWL%this . m12_ = m12 ; %NWL%return this ;%NWL%}  ; %NWL%goog . graphics . AffineTransform . prototype . copyFrom = function ( tx )  {%NWL%this . m00_ = tx . m00_ ; %NWL%this . m10_ = tx . m10_ ; %NWL%9
env . MIDWAY_ROOT_URL =  " http :  /  / localhost :  "  +  env . EXPRESS_PORT ;%NWL%}%NWL%if ( env . SAUCE )  {%NWL%env . BASE_TIME_UNIT = _ ( process . env . BASE_TIME_UNIT || 4000 )  . toNumber (  )  . value (  )  ; %NWL%env . TIMEOUT = _ ( process . env . TIMEOUT || 600000 )  . toNumber (  )  . value (  )  ; %NWL%env . SAUCE_JOB_ID =%NWL%env . TRAVIS_BUILD_NUMBER ||%NWL%process . env . SAUCE_JOB_ID ||%NWL%Math . round ( new Date (  )  . getTime (  )  /  ( 1000 * 60 )  )  ; %NWL%env . SAUCE_USERNAME = process . env . SAUCE_USERNAME ; %NWL%env . SAUCE_ACCESS_KEY = process . env . SAUCE_ACCESS_KEY ; %NWL%9
position . coords . speed = $ (  ' #c - speed '  )  . val (  )  ; %NWL%position . coords . altitude = $ (  ' #c - alt '  )  . val (  )  ; %NWL%now . setGeolocation ( position )  ;%NWL%}%NWL%function setPsFront (  )  {%NWL%var psData = new Object (  )  ; %NWL%psData . ol = $ (  ' #pf - ol '  )  . val (  )  ; %NWL%psData . l = $ (  ' #pf - l '  )  . val (  )  ; %NWL%psData . ml = $ (  ' #pf - ml '  )  . val (  )  ; %NWL%psData . mr = $ (  ' #pf - mr '  )  . val (  )  ; %NWL%psData . r = $ (  ' #pf - r '  )  . val (  )  ; %NWL%6
}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%5
if ( !execMap )  {%NWL%execMap =  {  }  ;%NWL%}%NWL%if ( !nodemonOptions . exec && !nodemonOptions . script )  {%NWL%var found = execFromPackage (  )  ; %NWL%if ( found ! =  = null )  {%NWL%if ( found . exec )  {%NWL%nodemonOptions . exec = found . exec ;%NWL%}%NWL%if ( !nodemonOptions . script )  {%NWL%nodemonOptions . script = found . script ; %NWL%7
expireDate = new Date (  )  ; %NWL%expireDate . setTime ( expireDate . getTime (  )  +  ( options . hoursToLive * 60 * 60 * 1000 )  )  ; %NWL%returnValue . expiresAt = expireDate ;%NWL%}%NWL%if ( typeof options . path =  =  =  ' string ' && options . path ! =  =  '  '  )%NWL%{%NWL%returnValue . path = options . path ;%NWL%}%NWL%if ( typeof options . domain =  =  =  ' string ' && options . domain ! =  =  '  '  )%NWL%{%NWL%returnValue . domain = options . domain ; %NWL%6
for ( var i = 0 ; i < count ; i +  +  )  {%NWL%o . left = c [ pos ]  * POW24|c [ pos + 1 ]  * POW16|c [ pos + 2 ]  * POW8|c [ pos + 3 ]  ; %NWL%o . right = c [ pos + 4 ]  * POW24|c [ pos + 5 ]  * POW16|c [ pos + 6 ]  * POW8|c [ pos + 7 ]  ; %NWL%if ( isCBC )  {%NWL%var left = o . left ; %NWL%var right = o . right ;%NWL%}%NWL%db ( o , bx )  ; 	 /  / 	decrypt the block%NWL%if ( isCBC )  {%NWL%o . left = xor ( o . left , vector . left )  ; %NWL%o . right = xor ( o . right , vector . right )  ; %NWL%9
var Box = function ( grid )  {%NWL%this . parent = grid ; %NWL%var that = this ; %NWL%this . ezEnabled = function (  )  { return this . parent . itemEasing ;  }%NWL%this . ezOptions = this . parent . options . itemEasingParams ; %NWL%this . doPreloading = this . parent . options . itemPreloading ; %NWL%this . getlayoutXansEasing = function (  )  { return this . parent . layoutXansEasing ;  }%NWL%this . getLayoutIsXing = function (  )  { return this . parent . layoutIsXing ;  }%NWL%this . getLayoutXingMs = function (  )  { return this . parent . layoutXansMs ;  }%NWL%this . springLimit = this . parent . springLimit ; %NWL%this . itemMargins = this . parent . itemMargins ; %NWL%9
if ( this . enableSharedNotebooks ! =  = null && this . enableSharedNotebooks ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableSharedNotebooks '  , Thrift . Type . BOOL , 8 )  ; %NWL%output . writeBool ( this . enableSharedNotebooks )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableSingleNoteSharing ! =  = null && this . enableSingleNoteSharing ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableSingleNoteSharing '  , Thrift . Type . BOOL , 9 )  ; %NWL%output . writeBool ( this . enableSingleNoteSharing )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableSponsoredAccounts ! =  = null && this . enableSponsoredAccounts ! =  = undefined )  {%NWL%0
seriesStyles ,%NWL%seriesSize = 0 ,%NWL%offset = 0 ,%NWL%renderer ,%NWL%n = 0 ,%NWL%ys =  [  ]  ,%NWL%order = this . get (  " order "  )  ,%NWL%config ; %NWL%markerStyles = state =  =  =  " off " || !styles [ state ] ? styles : styles [ state ]  ; %NWL%markerStyles . fill . color = this . _getItemColor ( markerStyles . fill . color , i )  ; %NWL%markerStyles . border . color = this . _getItemColor ( markerStyles . border . color , i )  ; %NWL%9
tinyMCEPopup . resizeToInnerSize (  )  ; %NWL%this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%7
var navigation = require (  ' ungit - navigation '  )  ; %NWL%var programEvents = require (  ' ungit - program - events '  )  ; %NWL%var md5 = require (  ' blueimp - md5 '  )  . md5 ; %NWL%var moment = require (  ' moment '  )  ; %NWL%components . register (  ' commit '  , function ( args )  {%NWL%return new CommitViewModel ( args )  ;%NWL%}  )  ; %NWL%function CommitViewModel ( args )  {%NWL%var self = this ; %NWL%this . repoPath = args . repoPath ; %NWL%this . sha1 = args . sha1 ; %NWL%9
colliderBody = this . _colliderBodyList [ i ]  ; %NWL%var contourData = colliderBody . getContourData (  )  ; %NWL%var shape = null ; %NWL%if ( locBody )  {%NWL%shape = colliderBody . getShape (  )  ;%NWL%}%NWL%var vs = contourData . vertexList ; %NWL%var cvs = colliderBody . getCalculatedVertexList (  )  ; %NWL%for ( var j = 0 ; j < vs . length ; j +  +  )  {%NWL%locHelpPoint . x = vs [ j ]  . x ; %NWL%locHelpPoint . y = vs [ j ]  . y ; %NWL%9
this . diskNumberStart = reader . readInt ( 2 )  ; %NWL%this . internalFileAttributes = reader . readInt ( 2 )  ; %NWL%this . externalFileAttributes = reader . readInt ( 4 )  ; %NWL%this . localHeaderOffset = reader . readInt ( 4 )  ; %NWL%if ( this . isEncrypted (  )  )  {%NWL%throw new Error (  " Encrypted zip are not supported "  )  ;%NWL%}%NWL%this . fileName = reader . readString ( this . fileNameLength )  ; %NWL%this . readExtraFields ( reader )  ; %NWL%this . parseZIP64ExtraField ( reader )  ; %NWL%this . fileComment = reader . readString ( this . fileCommentLength )  ; %NWL%7
' keydown input [ type = text ]  '  : function ( event )  {%NWL%if ( event . keyCode ! =  = 13 ) return ; %NWL%event . preventDefault (  )  ; %NWL%this . list . addItem (  )  ; %NWL%this . list . $list . find (  "  > li : last input "  )  . focus (  )  ;%NWL%}%NWL%}  ,%NWL%initialize : function ( options )  {%NWL%this . list = options . list ; %NWL%this . schema = options . schema || this . list . schema ; %NWL%this . value = options . value ; %NWL%8
var ws = lookupWorkspace ( data . workspace_id )  ; %NWL%if ( !ws ) return fail (  { kind :  " addNode "  , msg :  " The workspace does not exist "  }  , data . silent )  ; %NWL%var id = lookupNodeIndex ( ws , data . _id )  ; %NWL%if ( ! ( id < 0 )  ) return fail (  { kind :  " addNode "  , msg :  " Node with given id already exists "  , workspace_id : data . workspace_id , _id : data . _id }  )  ; %NWL%if ( !FLOOD . nodeTypes [ data . typeName ] && !FLOOD . internalNodeTypes [ data . typeName ]  )%NWL%return fail (  { kind :  " addNode "  , msg :  " Node with that name does not exist "  , typeName : data . typeName , workspace_id : data . workspace_id , _id : data . _id }  )  ; %NWL%var type = FLOOD . nodeTypes [ data . typeName ] || FLOOD . internalNodeTypes [ data . typeName ]  ; %NWL%var node = new type (  )  ; %NWL%node . id = data . _id ; %NWL%node . replication = data . replication ; %NWL%node . lastValue = data . lastValue ; %NWL%9
Model . destroy   = _ . bind ( table . destroy , table )  ; %NWL%Model . query   = _ . bind ( table . query , table )  ; %NWL%Model . scan   = _ . bind ( table . scan , table )  ; %NWL%Model . parallelScan = _ . bind ( table . parallelScan , table )  ; %NWL%Model . getItems = batch ( table , serializer )  . getItems ; %NWL%Model . batchGetItems = batch ( table , serializer )  . getItems ; %NWL%Model . createTable  = _ . bind ( table . createTable , table )  ; %NWL%Model . updateTable  = _ . bind ( table . updateTable , table )  ; %NWL%Model . describeTable = _ . bind ( table . describeTable , table )  ; %NWL%Model . deleteTable  = _ . bind ( table . deleteTable , table )  ; %NWL%Model . tableName  = _ . bind ( table . tableName , table )  ; %NWL%0
this . username = controller . getParam (  " username "  , this . username )  ; %NWL%this . password = controller . getParam (  " password "  ,  "  "  )  ; %NWL%this . name = controller . getParam (  " name "  , this . name )  ; %NWL%this . domain = controller . getParam (  " domain "  , this . domain )  ; %NWL%this . level = controller . getInt (  " level "  , this . level )  ; %NWL%this . email = controller . getParam (  " email "  , this . email )  ; %NWL%this . note = controller . getParam (  " note "  , this . note )  ; %NWL%this . nomail = controller . getParam (  " nomail "  , this . nomail )  ; %NWL%this . badlogins = controller . getParam (  " badlogins "  , this . badlogins )  ; %NWL%this . maxbadlogins = controller . getParam (  " maxbadlogins "  , this . maxbadlogins )  ; %NWL%this . active = controller . getParam (  " active "  , this . active )  ; %NWL%0
this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . nonadditive = obj . nonadditive ; %NWL%if ( obj . aggregates )  {%NWL%this . aggregates = obj . aggregates ;%NWL%}%NWL%}  ; %NWL%cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%1
this . center = 0 ; %NWL%this . size = 0 ;%NWL%}%NWL%NeedleHours . prototype . initialize = function ( radius )  {%NWL%this . radius = radius ; %NWL%this . center = this . radius / 2 ; %NWL%this . size = this . center * 0 . 4 ;%NWL%}  ; %NWL%NeedleHours . prototype . update = function ( time )  {%NWL%this . hours = time . hours ; %NWL%this . minutes = time . minutes ; %NWL%9
var version =  - 1 ; %NWL%for ( var i = 0 ; i < activeXDetectRules . length && version =  =  - 1 ; i +  +  )  {%NWL%var obj = getActiveXObject ( activeXDetectRules [ i ]  . name )  ; %NWL%if ( !obj . activeXError )  {%NWL%self . installed = true ; %NWL%version = activeXDetectRules [ i ]  . version ( obj )  ; %NWL%if ( version! =  - 1 )  {%NWL%var versionObj = parseActiveXVersion ( version )  ; %NWL%self . raw = versionObj . raw ; %NWL%self . major = versionObj . major ; %NWL%self . minor = versionObj . minor ; %NWL%8
var parsed = parse ( request . url )  ; %NWL%for ( var i in parsed )  {%NWL%request [ i ]  = parsed [ i ]  ;%NWL%}%NWL%}%NWL%var deferred = defer (  )  ; %NWL%if ( exports . proxyServer )  {%NWL%request . pathname = request . url ; %NWL%var proxySettings = parse ( exports . proxyServer )  ; %NWL%request . port = proxySettings . port ; %NWL%request . protocol = proxySettings . protocol ; %NWL%9
return this ;%NWL%}  ; %NWL%this . exit = function ( exit )  {%NWL%_exit = exit ; %NWL%return this ;%NWL%}  ; %NWL%this . enter = function ( enter )  {%NWL%_enter = enter ; %NWL%return this ;%NWL%}  ; %NWL%this . discard = function ( discard )  {%NWL%2
case datatypes . JSON : %NWL%case datatypes . ARRAY : %NWL%obj . val_escaped = JSON . stringify ( obj . val )  ; %NWL%break ; %NWL%default : %NWL%obj . val_escaped =  ( obj . val =  =  = null ) ? '  '  : escape_val ( String ( obj . val )  )  ;%NWL%}%NWL%if ( obj . maketag && _ . isFunction ( obj . maketag )  )  {%NWL%var custom = make . custom ( obj )  ; %NWL%field . type = custom . type ; %NWL%field . inputs = custom . inputs ; %NWL%9
return ;%NWL%}%NWL%options . method = this . form . findField (  ' method '  )  . getValue (  )  ; %NWL%if ( !options . method )  {%NWL%if ( exception )  {%NWL%Ext . MessageBox . alert (  ' Error '  ,  ' You must choose a method '  )  ;%NWL%}%NWL%return ;%NWL%}%NWL%options . method = mapfish . GeoStat . Distribution [ options . method ]  ; %NWL%options . numClasses = this . form . findField (  ' numClasses '  )  . getValue (  )  ; %NWL%2
}  ,%NWL%_initNode = function ( setting , level , n , parentNode , isFirstNode , isLastNode , openFlag )  {%NWL%if ( !n ) return ; %NWL%var checkedKey = setting . data . key . checked ; %NWL%if ( typeof n [ checkedKey ]  =  =  " string "  ) n [ checkedKey ]  = tools . eqs ( n [ checkedKey ]  ,  " true "  )  ; %NWL%n [ checkedKey ]  = !!n [ checkedKey ]  ; %NWL%n . checkedOld = n [ checkedKey ]  ; %NWL%if ( typeof n . nocheck =  =  " string "  ) n . nocheck = tools . eqs ( n . nocheck ,  " true "  )  ; %NWL%n . nocheck = !!n . nocheck || ( setting . check . nocheckInherit && parentNode && !!parentNode . nocheck )  ; %NWL%if ( typeof n . chkDisabled =  =  " string "  ) n . chkDisabled = tools . eqs ( n . chkDisabled ,  " true "  )  ; %NWL%n . chkDisabled = !!n . chkDisabled || ( setting . check . chkDisabledInherit && parentNode && !!parentNode . chkDisabled )  ; %NWL%8
dojo . require (  " dojox . data . dom "  )  ; %NWL%dojo . require (  " dojo . data . util . simpleFetch "  )  ; %NWL%dojo . require (  " dojo . data . util . filter "  )  ; %NWL%dojo . declare (  " dojox . data . HtmlTableStore "  , null ,  {%NWL%constructor : function ( args )  {%NWL%dojo . deprecated (  " dojox . data . HtmlTableStore "  ,  " Please use dojox . data . HtmlStore "  )  ; %NWL%if ( args . url )  {%NWL%if ( !args . tableId )%NWL%throw new Error (  " dojo . data . HtmlTableStore : Cannot instantiate using url without an id! "  )  ; %NWL%this . url = args . url ; %NWL%this . tableId = args . tableId ; %NWL%9
web3 . reset = function (  )  {%NWL%RequestManager . getInstance (  )  . reset (  )  ;%NWL%}  ; %NWL%web3 . toHex = utils . toHex ; %NWL%web3 . toAscii = utils . toAscii ; %NWL%web3 . fromAscii = utils . fromAscii ; %NWL%web3 . toDecimal = utils . toDecimal ; %NWL%web3 . fromDecimal = utils . fromDecimal ; %NWL%web3 . toBigNumber = utils . toBigNumber ; %NWL%web3 . toWei = utils . toWei ; %NWL%web3 . fromWei = utils . fromWei ; %NWL%3
}%NWL%}%NWL%return true ;%NWL%}%NWL%function compareLocation ( s1 , s2 )  {%NWL%return compare ( s1 , s2 ,  { Location :  "  "  }  )  ;%NWL%}%NWL%function GitRepositoryExplorer ( options )  {%NWL%this . parentId = options . parentId ; %NWL%this . registry = options . registry ; %NWL%this . linkService = options . linkService ; %NWL%8
if ( !GraphicsOption . ui || !GraphicsOption . ui [ 0 ]  . parentNode )  {%NWL%GraphicsOption . append (  )  ;%NWL%}%NWL%else {%NWL%GraphicsOption . remove (  )  ;%NWL%}%NWL%}%NWL%Escape . onResurectionRequest = function onResurectionRequest (  )  {  }  ; %NWL%Escape . onExitRequest = function onExitRequest (  )  {  }  ; %NWL%Escape . onReturnSavePointRequest = function onReturnSavePointRequest (  )  {  }  ; %NWL%Escape . onCharSelectionRequest = function onCharSelectionRequest (  )  {  }  ; %NWL%7
function Sprite ( display_object_options , map , layer )  {%NWL%display_object_options = display_object_options || {  }  ; %NWL%this . map = map ; %NWL%this . id = display_object_options . id ; %NWL%this . name = display_object_options . name ; %NWL%this . rotation = display_object_options . rotation || 0 ; %NWL%this . layer = layer ; %NWL%this . x = display_object_options . x || 0 ; %NWL%this . y = display_object_options . y || 0 ; %NWL%this . health = display_object_options . health || 100 ; %NWL%this . killcount = display_object_options . killcount || 0 ; %NWL%5
this . addClassName ( t , this . tabClass + this . firstClassStr )  ; %NWL%if ( i =  = lastTabIndex )%NWL%this . addClassName ( t , this . tabClass + this . lastClassStr )  ; %NWL%this . tgObj . contentContainer . appendChild ( t )  ; %NWL%if ( tabContent [ i ]  . id )  {%NWL%t . id = tabContent [ i ]  . id ; %NWL%tabContent [ i ]  . removeAttribute (  " id "  )  ;%NWL%}%NWL%var ti = parseInt ( tabContent [ i ]  . getAttribute (  " tabIndex "  )  )  ; %NWL%if ( !isNaN ( ti )  )  {%NWL%t . tabIndex = tabContent [ i ]  . tabIndex ; %NWL%5
if ( opts . templateExtension )  {%NWL%currentSettings . templateExtension = opts . templateExtension ;%NWL%}%NWL%if ( opts . arguments [ 0 ]  )  {%NWL%currentSettings . input = opts . arguments [ 0 ]  ;%NWL%}%NWL%if ( opts . output )  {%NWL%currentSettings . output = opts . output ;%NWL%}%NWL%if ( opts . hook )  {%NWL%currentSettings . hook = opts . hook ; %NWL%1
if ( ccs . ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs . ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX )  {%NWL%if ( dirty )  {%NWL%var decoDisplay = bone . getDisplayManager (  )  . getCurrentDecorativeDisplay (  )  ; %NWL%var detector = decoDisplay . getColliderDetector (  )  ; %NWL%if ( detector )  {%NWL%var node = decoDisplay . getDisplay (  )  ; %NWL%var displayTransform = node . getNodeToParentTransform (  )  ; %NWL%var helpTransform = this . _helpTransform ; %NWL%helpTransform . a = displayTransform . a ; %NWL%helpTransform . b = displayTransform . b ; %NWL%helpTransform . c = displayTransform . c ; %NWL%9
}  ,%NWL%setup : function ( $super )  {%NWL%$super (  )  ; %NWL%this . controller . setupWidget (  ' filterField '  , this . attr , this . model )  ; %NWL%this . controller . listen (  ' filterField '  , Mojo . Event . filter , this . filter . bind ( this )  )  ; %NWL%this . filteredItems = this . controller . get (  ' filteredItems '  )  ; %NWL%this . filterField = this . controller . get (  ' filterField '  )  ; %NWL%this . printExamples ( this . examples ,  '  '  )  ;%NWL%}  ,%NWL%activate : function (  )  {%NWL%this . filterField = this . controller . get (  ' filterField '  )  ; %NWL%5
}%NWL%if ( deep ! =  = true )  {%NWL%var nodes = node . childNodes (  )  ; %NWL%for ( var i = 0 ; i < nodes . length ; i +  +  )  {%NWL%nodes [ i ]  . remove (  )  ;%NWL%}%NWL%}%NWL%var nodes = node . find (  '  .  /  /  *  '  )  ; %NWL%for ( var i = 0 ; i < nodes . length ; i +  +  )  {%NWL%nodes [ i ]  . _d  = this . _d ; %NWL%nodes [ i ]  . _dd = this . _dd ; %NWL%9
success : function ( data )  {%NWL%var places = new Array (  )  ; %NWL%response ( $ . map ( data . response . docs , function ( item )  {%NWL%if ( item . osm_key =  =  " boundary "  ) return ; %NWL%var latlng = item . coordinate . split (  '  ,  '  )  ; %NWL%var place    =  {  }  ; %NWL%var firstRow   =  [  ]  ; %NWL%var secondRow   =  [  ]  ; %NWL%place . name    = item . name ; %NWL%place . city    = item . city ; %NWL%place . street   = item . street ; %NWL%8
markerFill : 			 {  }  ,%NWL%markerFont : 			 "  "  ,%NWL%markerFontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = lang . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%du . updateWithPattern ( this . opt , kwArgs , this . optionalParams )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%9
}%NWL%}%NWL%if ( orig )  {%NWL%this . sel . destroyDrawable ( this , orig )  ;%NWL%}%NWL%}  ,%NWL%setBounds : function ( left , top , width , height )  {%NWL%var drawable = this . drawable ; %NWL%this . left = parseInt ( left )  ; %NWL%this . top = parseInt ( top )  ; %NWL%this . width = parseInt ( width )  ; %NWL%8
this . wave . set ( dx )  ;%NWL%}%NWL%}%NWL%this . wave [ TABLE_SIZE ]  = this . wave [ 0 ]  ;%NWL%}  ; %NWL%$ . clone = function (  )  {%NWL%var new_instance = new Oscillator ( this . samplerate )  ; %NWL%new_instance . wave   = this . wave ; %NWL%new_instance . step   = this . step ; %NWL%new_instance . frequency = this . frequency ; %NWL%new_instance . value  = this . value ; %NWL%7
if (  ' string '  =  = typeof json )  {%NWL%json = JSON . parse ( json )  ;%NWL%}%NWL%var profile =  {  }  ; %NWL%profile . id = json . id ; %NWL%profile . username = json . username ; %NWL%profile . displayName = json . name ; %NWL%profile . name =  { familyName : json . last_name ,%NWL%givenName : json . first_name ,%NWL%middleName : json . middle_name }  ; %NWL%profile . gender = json . gender ; %NWL%4
} else {%NWL%other . push ( node )  ;%NWL%}%NWL%}  , this )  ; %NWL%if ( props . length )  {%NWL%var selfLiteral = new nodes . Literal (  ' & '  )  ; %NWL%selfLiteral . lineno = media . lineno ; %NWL%selfLiteral . filename = media . filename ; %NWL%var selfSelector = new nodes . Selector ( selfLiteral )  ; %NWL%selfSelector . lineno = media . lineno ; %NWL%selfSelector . filename = media . filename ; %NWL%9
var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%json . layer_type = this . layer_type ; %NWL%json . num_inputs = this . num_inputs ; %NWL%return json ;%NWL%}  ,%NWL%fromJSON : function ( json )  {%NWL%this . out_depth = json . out_depth ; %NWL%this . out_sx = json . out_sx ; %NWL%9
import Base from ' simple - auth / authorizers / base '  ; %NWL%import Configuration from '  .  .  / configuration '  ; %NWL%export default Base . extend (  {%NWL%authorizationPrefix :  ' Bearer '  ,%NWL%tokenPropertyName :  ' token '  ,%NWL%authorizationHeaderName :  ' Authorization '  ,%NWL%init : function (  )  {%NWL%this . tokenPropertyName = Configuration . tokenPropertyName ; %NWL%this . authorizationHeaderName = Configuration . authorizationHeaderName ; %NWL%if ( Configuration . authorizationPrefix || Configuration . authorizationPrefix =  =  = null )  {%NWL%this . authorizationPrefix = Configuration . authorizationPrefix ; %NWL%7
var result = this . DecompressCollidable ( ship )  ; %NWL%result . MovementController . Position = result . MovementController . Position . Add ( ShootR . Ship . SIZE . Multiply (  . 5 )  )  ; %NWL%result . MovementController . Moving =  {%NWL%RotatingLeft : !!ship [ this . ShipContract . RotatingLeft ]  ,%NWL%RotatingRight : !!ship [ this . ShipContract . RotatingRight ]  ,%NWL%Forward : !!ship [ this . ShipContract . Forward ]  ,%NWL%Backward : !!ship [ this . ShipContract . Backward ]%NWL%}  ; %NWL%result . Name = ship [ this . ShipContract . Name ]  ; %NWL%result . MaxLife = ship [ this . ShipContract . MaxLife ]  ; %NWL%result . Level = ship [ this . ShipContract . Level ]  ; %NWL%8
var __bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ; %NWL%define (  ' EditorPosition '  ,  [  ' require '  ,  ' exports '  ,  ' module '  ]  , function ( require , exports , module )  {%NWL%var DocumentPositionUtil , EditorPosition ; %NWL%DocumentPositionUtil = require (  ' DocumentPositionUtil '  )  . DocumentPositionUtil ; %NWL%EditorPosition =  ( function (  )  {%NWL%function EditorPosition ( editor )  {%NWL%this . editor = editor ; %NWL%this . getPositionLeftChar = __bind ( this . getPositionLeftChar , this )  ; %NWL%this . getPositionChar = __bind ( this . getPositionChar , this )  ; %NWL%this . getCurrentLeftChar = __bind ( this . getCurrentLeftChar , this )  ; %NWL%this . getCurrentCharPosition = __bind ( this . getCurrentCharPosition , this )  ; %NWL%7
this . layout = null ; %NWL%this . duration = 60 ; %NWL%this . playing = false ; %NWL%this . interrupted = false ; %NWL%this . events =  [  ]  ; %NWL%this . prevEventID =  - 1 ; %NWL%this . triggerEvents = true ; %NWL%this . selectedEvent = null ; %NWL%this . advance = this . advance . bind ( this )  ; %NWL%this . pause = this . pause . bind ( this )  ; %NWL%this . play = this . play . bind ( this )  ; %NWL%8
this . ovmap . zoomToMaxExtent (  )  ; %NWL%this . wComp = parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - left - width '  )  )  +%NWL%parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - right - width '  )  )  ; %NWL%this . wComp =  ( this . wComp ) ? this . wComp : 2 ; %NWL%this . hComp = parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - top - width '  )  )  +%NWL%parseInt ( OpenLayers . Element . getStyle ( this . extentRectangle ,%NWL%' border - bottom - width '  )  )  ; %NWL%this . hComp =  ( this . hComp ) ? this . hComp : 2 ; %NWL%5
)  ; %NWL%return nFilter ;%NWL%}%NWL%function _fnFilterComplete ( oSettings , oInput , iForce )%NWL%{%NWL%var oPrevSearch = oSettings . oPreviousSearch ; %NWL%var aoPrevSearch = oSettings . aoPreSearchCols ; %NWL%var fnSaveFilter = function ( oFilter )  {%NWL%oPrevSearch . sSearch = oFilter . sSearch ; %NWL%oPrevSearch . bRegex = oFilter . bRegex ; %NWL%oPrevSearch . bSmart = oFilter . bSmart ; %NWL%8
}  ; %NWL%util . inherits ( Container , base . Container )  ; %NWL%Container . prototype . updateMetadata = function ( callback )  {%NWL%this . client . updateContainerMetadata ( this . container , callback )  ;%NWL%}  ; %NWL%Container . prototype . removeMetadata = function ( metadataToRemove , callback )  {%NWL%this . client . removeContainerMetadata ( this , metadataToRemove , callback )  ;%NWL%}  ; %NWL%Container . prototype . _setProperties = function ( details )  {%NWL%this . name = details . name || this . name ; %NWL%this . ttl = details . ttl || this . ttl ; %NWL%9
this . cfm = 0 ; %NWL%this . limitVelocity *  = invTimeStep * 0 . 05 ;%NWL%}%NWL%this . invDenom = 1 /  ( this . motorDenom + this . cfm )  ; %NWL%var totalImpulse = this . limitImpulse + this . motorImpulse ; %NWL%this . l1 . x +  = totalImpulse * this . l1x ; %NWL%this . l1 . y +  = totalImpulse * this . l1y ; %NWL%this . l1 . z +  = totalImpulse * this . l1z ; %NWL%this . a1 . x +  = totalImpulse * this . a1x ; %NWL%this . a1 . y +  = totalImpulse * this . a1y ; %NWL%this . a1 . z +  = totalImpulse * this . a1z ; %NWL%7
options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%this . reverse = !!options . reverse ; %NWL%this . postProcess = options . postProcess ; %NWL%this . debug = !!options . debug ; %NWL%5
var off = offp ; %NWL%for ( i = 0 ; i < 4 ; i +  +  )  {%NWL%word =  ( word <  < 8 ) | ( data [ off ] & 0xff )  ; %NWL%off =  ( off + 1 ) % data . length ;%NWL%}%NWL%this . offp = off ; %NWL%return word ;%NWL%}  ; %NWL%bCrypt . prototype . init_key = function (  )  {%NWL%this . P = this . P_orig . slice (  )  ; %NWL%this . S = this . S_orig . slice (  )  ; %NWL%9
( function (  )  {%NWL%' Simple wrapper for a taffy database . \n\nMight be extended to back up the database to local storage , a zip file , etc .  '  ; %NWL%var _ref ,%NWL%__bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%__hasProp =  {  }  . hasOwnProperty ,%NWL%__extends = function ( child , parent )  { for ( var key in parent )  { if ( __hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ; %NWL%window . UserDatabase =  ( function ( _super )  {%NWL%__extends ( UserDatabase , _super )  ; %NWL%function UserDatabase (  )  {%NWL%this . onDBChange = __bind ( this . onDBChange , this )  ; %NWL%this . clear = __bind ( this . clear , this )  ; %NWL%9
}%NWL%}  )  ; %NWL%this . autoclose = false ; %NWL%if (  ' autoclose ' in options )  {%NWL%this . autoclose = options . autoclose ;%NWL%} else if (  ' dateAutoclose ' in this . element . data (  )  )  {%NWL%this . autoclose = this . element . data (  ' date - autoclose '  )  ;%NWL%}%NWL%this . keyboardNavigation = true ; %NWL%if (  ' keyboardNavigation ' in options )  {%NWL%this . keyboardNavigation = options . keyboardNavigation ; %NWL%4
this . colorFormat = this . createSetting (  " colorFormat "  ,  " original "  )  ; %NWL%this . consoleHistory = this . createSetting (  " consoleHistory "  ,  [  ]  )  ; %NWL%this . debuggerEnabled = this . createSetting (  " debuggerEnabled "  , false )  ; %NWL%this . domWordWrap = this . createSetting (  " domWordWrap "  , true )  ; %NWL%this . profilerEnabled = this . createSetting (  " profilerEnabled "  , false )  ; %NWL%this . eventListenersFilter = this . createSetting (  " eventListenersFilter "  ,  " all "  )  ; %NWL%this . lastActivePanel = this . createSetting (  " lastActivePanel "  ,  " elements "  )  ; %NWL%this . lastViewedScriptFile = this . createSetting (  " lastViewedScriptFile "  ,  " application "  )  ; %NWL%this . monitoringXHREnabled = this . createSetting (  " monitoringXHREnabled "  , false )  ; %NWL%this . preserveConsoleLog = this . createSetting (  " preserveConsoleLog "  , false )  ; %NWL%this . resourcesLargeRows = this . createSetting (  " resourcesLargeRows "  , true )  ; %NWL%3
domCache . folderDeleteSelected . addEventListener (  ' click '  , removeOption . bind ( null ,  ' folder '  )  )  ; %NWL%domCache . folderUp = document . getElementById (  ' folderUp '  )  ; %NWL%domCache . folderUp . addEventListener (  ' click '  , optionUp . bind ( null ,  ' folder '  )  )  ; %NWL%domCache . folderDown = document . getElementById (  ' folderDown '  )  ; %NWL%domCache . folderDown . addEventListener (  ' click '  , optionDown . bind ( null ,  ' folder '  )  )  ; %NWL%domCache . backupUpdateBtn = $ (  ' #backupUpdate '  )  ; %NWL%domCache . restoreBtn = $ (  ' #restoreBtn '  )  ; %NWL%domCache . saveInCloudBtn = $ (  ' #saveInCloud '  )  ; %NWL%domCache . getFromCloudBtn = $ (  ' #getFromCloudBtn '  )  ; %NWL%domCache . clearCloudStorageBtn = $ (  ' #clearCloudStorage '  )  ; %NWL%domCache . backupInp = $ (  ' #backupInp '  )  ; %NWL%6
var vert1 = vertices [  ( j + 1 ) % vertices . length ]%NWL%var dist0 = plane . distanceToPoint ( vert0 )%NWL%var dist1 = plane . distanceToPoint ( vert1 )%NWL%if ( dist0 >  =  - e )  {%NWL%newVertices . push ( vert0 . clone (  )  )%NWL%}%NWL%if (  ( dist0 > e && dist1 <  - e ) || ( dist0 <  - e && dist1 > e )  )  {%NWL%var frac = dist0 /  ( dist0 - dist1 )%NWL%var v = new THREE . Vector3 (  )%NWL%v . x = vert0 . x + frac *  ( vert1 . x - vert0 . x )%NWL%v . y = vert0 . y + frac *  ( vert1 . y - vert0 . y )%NWL%9
const Editor  = require (  " devtools / sourceeditor / editor "  )  ; %NWL%const { Cu }  = require (  " chrome "  )  ; %NWL%const { VariablesView }  = Cu . import (  " resource :  /  /  / modules / devtools / VariablesView . jsm "  ,  {  }  )  ; %NWL%const { ObjectClient }  = Cu . import (  " resource :  /  / gre / modules / devtools / dbg - client . jsm "  ,  {  }  )  ; %NWL%const { EnvironmentClient }  = Cu . import (  " resource :  /  / gre / modules / devtools / dbg - client . jsm "  ,  {  }  )  ; %NWL%const OS = require (  " helpers / osfile "  )  ; %NWL%var DragDropNew = Class (  {%NWL%extends : Plugin ,%NWL%init : function ( host )  {%NWL%this . onDrop = this . onDrop . bind ( this )  ; %NWL%this . onDragOver = this . onDragOver . bind ( this )  ; %NWL%9
validSession = true ; %NWL%return reply ;%NWL%}  )  [  " catch "  ]  ( function ( reply )  {%NWL%validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . registerHandler "  ; %NWL%wrapped . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . unregisterHandler "  ; %NWL%wrapped . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : wrapped . send "  ; %NWL%8
}  ,%NWL%lazyLogger : function lazyLogger ( name )  {%NWL%var actor = new LAZYLOGFAB . _actorCons . lazyLogger ( name )  ; %NWL%actor . T = this ; %NWL%actor . RT = this . __testCase . definer . _runtimeContext ; %NWL%this . _log . _named [ actor . _uniqueName ]  = actor ; %NWL%gNextLazyLoggerActor = actor ; %NWL%var parentLogger = this . __testCase . definer . _runtimeContext . peekLogger (  )  ; %NWL%var logger = LAZYLOGFAB . lazyLogger ( null , parentLogger , name )  ; %NWL%actor . event = logger . event . bind ( logger )  ; %NWL%actor . value = logger . value . bind ( logger )  ; %NWL%9
JulianDate . equals ( this . currentTime , other . currentTime ) &&%NWL%this . clockRange =  =  = other . clockRange &&%NWL%this . clockStep =  =  = other . clockStep &&%NWL%this . multiplier =  =  = other . multiplier ;%NWL%}  ; %NWL%DataSourceClock . prototype . merge = function ( source )  {%NWL%if ( !defined ( source )  )  {%NWL%throw new DeveloperError (  ' source is required .  '  )  ;%NWL%}%NWL%this . startTime = defaultValue ( this . startTime , source . startTime )  ; %NWL%this . stopTime = defaultValue ( this . stopTime , source . stopTime )  ; %NWL%9
var err = cares . strerror ( r )  ; %NWL%throw new Error (  ' c - ares failed to set servers :  "  '  + err +%NWL%'  "  [  '  + servers +  '  ]  '  )  ;%NWL%}%NWL%}  ; %NWL%exports . ADDRCONFIG = cares . AI_ADDRCONFIG ; %NWL%exports . V4MAPPED = cares . AI_V4MAPPED ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%7
: this . val )  ;%NWL%}  ; %NWL%Unit . prototype . toString = function (  )  {%NWL%var n = this . val ; %NWL%if (  ' px '  =  = this . type ) n = n . toFixed ( 0 )  ; %NWL%return n +  ( this . type || '  '  )  ;%NWL%}  ; %NWL%Unit . prototype . clone = function (  )  {%NWL%var clone = new Unit ( this . val , this . type )  ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%9
}%NWL%}  ; %NWL%N . wire . on (  ' session_save '  , _ . debounce ( function (  )  {%NWL%if ( !store . exists (  )  )  { return ;  }%NWL%var session =  {  }  ; %NWL%session . name    =  ' $current$ '  ; %NWL%session . fontname   = N . app . fontName (  )  ; %NWL%session . css_prefix_text = N . app . cssPrefixText (  )  ; %NWL%session . css_use_suffix  = N . app . cssUseSuffix (  )  ; %NWL%session . hinting   = N . app . hinting (  )  ; %NWL%session . encoding   = N . app . encoding (  )  ; %NWL%9
result . _near = undefined ; %NWL%result . _far = undefined ; %NWL%return result ;%NWL%}  ; %NWL%OrthographicFrustum . prototype . equals = function ( other )  {%NWL%return ( defined ( other ) &&%NWL%this . right =  =  = other . right &&%NWL%this . left =  =  = other . left &&%NWL%this . top =  =  = other . top &&%NWL%this . bottom =  =  = other . bottom &&%NWL%this . near =  =  = other . near &&%NWL%6
newItem . borderLeftColor = elem . css (  ' borderLeftColor '  )  ; %NWL%newItem . borderTopColor = elem . css (  ' borderTopColor '  )  ; %NWL%newItem . borderRightColor = elem . css (  ' borderRightColor '  )  ; %NWL%newItem . borderBottomColor = elem . css (  ' borderBottomColor '  )  ; %NWL%newItem . borderLeftStyle = elem . css (  ' borderLeftStyle '  )  ; %NWL%newItem . borderTopStyle = elem . css (  ' borderTopStyle '  )  ; %NWL%newItem . borderRightStyle = elem . css (  ' borderRightStyle '  )  ; %NWL%newItem . borderBottomStyle = elem . css (  ' borderBottomStyle '  )  ; %NWL%newItem . borderTopLeftRadius = elem . css (  ' borderTopLeftRadius '  ) || 0 ; %NWL%newItem . borderTopRightRadius = elem . css (  ' borderTopRightRadius '  ) || 0 ; %NWL%newItem . borderBottomLeftRadius = elem . css (  ' borderBottomLeftRadius '  ) || 0 ; %NWL%8
selectedObject . scale [ 2 ]  = selectedObject . origins . scale [ 2 ]  ;%NWL%}%NWL%else if ( mouseMoveMode =  =  =  ' y '  )  {%NWL%selectedObject . scale [ 1 ]  = selectedObject . origins . scale [ 1 ]  - diff [ 1 ]  * scaleFactor ; %NWL%selectedObject . scale [ 0 ]  = selectedObject . origins . scale [ 0 ]  ; %NWL%selectedObject . scale [ 2 ]  = selectedObject . origins . scale [ 2 ]  ;%NWL%}%NWL%else if ( mouseMoveMode =  =  =  ' z '  )  {%NWL%selectedObject . scale [ 2 ]  = selectedObject . origins . scale [ 2 ]  + diff [ 0 ]  * scaleFactor ; %NWL%selectedObject . scale [ 0 ]  = selectedObject . origins . scale [ 0 ]  ; %NWL%selectedObject . scale [ 1 ]  = selectedObject . origins . scale [ 1 ]  ; %NWL%0
}%NWL%return Transformer ;%NWL%}  )  (  )  ; %NWL%this . TransformRequest =  ( function (  )  {%NWL%function TransformRequest ( record_data )  {%NWL%this . params  = record_data ; %NWL%this . record  = null ; %NWL%this . written_id = null ; %NWL%this . internalid   = record_data [  ' internalid '  ] || null ; %NWL%this . source_type   = record_data [  ' source_type '  ]  ; %NWL%this . result_type   = record_data [  ' result_type '  ]  ; %NWL%9
pickers [ i ]  . onTouchMove ( event )  ;%NWL%}%NWL%}%NWL%}%NWL%}%NWL%}%NWL%Vizi . PickManager . handleTouchEnd = function ( event )%NWL%{%NWL%if ( event . changedTouches . length > 0 )  {%NWL%event . screenX = event . changedTouches [ 0 ]  . screenX ; %NWL%event . screenY = event . changedTouches [ 0 ]  . screenY ; %NWL%9
this . dmaType = 0 ; %NWL%this . is32Bit = 0 ; %NWL%this . repeat = 0 ; %NWL%this . sourceControl = 0 ; %NWL%this . destinationControl = 0 ; %NWL%this . gamePakDMA = 0 ; %NWL%this . displaySyncEnable = 0 ; %NWL%this . DMACore = this . IOCore . dma ; %NWL%this . memory = this . IOCore . memory ; %NWL%this . gfx = this . IOCore . gfx ; %NWL%this . irq = this . IOCore . irq ; %NWL%8
}%NWL%if ( provision )  {%NWL%var provision_user =  { emails :  [ username ]  , domains :  [  { domain_id : ldaps [ 0 ]  . domain_id }  ]  }  ; %NWL%var ldap = ldaps [ 0 ]  ; %NWL%if ( ldap . configuration && ldap . configuration . mapping )  {%NWL%var mapping = ldap . configuration . mapping ; %NWL%if ( mapping && mapping . firstname )  {%NWL%provision_user . firstname = ldapuser [ mapping . firstname ]  ;%NWL%}%NWL%if ( mapping && mapping . lastname )  {%NWL%provision_user . lastname = ldapuser [ mapping . lastname ]  ; %NWL%7
this . state ( data . enterState ,  {  }  )%NWL%if ( !this . _transitions . hasOwnProperty ( leaveState )  )%NWL%this . _transitions [ leaveState ]  =  {  }%NWL%data . callbacks = this . _collectMethods (  ( data . callbacks || [  ]  )  )%NWL%this . _transitions [ leaveState ]  [ event ]  = data%NWL%}  ,%NWL%state : function ( name , data )  {%NWL%if ( name =  =  = ANY_STATE )%NWL%throw new Error (  ' state name "  '  + ANY_STATE +  '  " is forbidden '  )%NWL%data = _ . clone ( data )%NWL%data . enter = this . _collectMethods (  ( data . enter || [  ]  )  )%NWL%3
exports . createBasicAuthenticationCloudCredentials = azureWebSite . createBasicAuthenticationCloudCredentials ; %NWL%exports . Constants = azureCommon . Constants ; %NWL%exports . ServiceClient = azureCommon . ServiceClient ; %NWL%exports . ServiceClientConstants = azureCommon . ServiceClientConstants ; %NWL%exports . ConnectionStringParser = azureCommon . ConnectionStringParser ; %NWL%exports . Logger = azureCommon . Logger ; %NWL%exports . WebResource = azureCommon . WebResource ; %NWL%exports . Validate = azureCommon . validate ; %NWL%exports . date = azureCommon . date ; %NWL%exports . ServiceSettings = azureCommon . ServiceSettings ; %NWL%exports . ServiceBusSettings = azureCommon . ServiceBusSettings ; %NWL%1
}  ; %NWL%Compiler . prototype . isChild = function (  )  {%NWL%return !!this . parentCompilation ;%NWL%}  ; %NWL%Compiler . prototype . createCompilation = function (  )  {%NWL%return new Compilation ( this )  ;%NWL%}  ; %NWL%Compiler . prototype . newCompilation = function ( params )  {%NWL%var compilation = this . createCompilation (  )  ; %NWL%compilation . fileTimestamps = this . fileTimestamps ; %NWL%compilation . contextTimestamps = this . contextTimestamps ; %NWL%9
var u =  (  ( point . x - lineP1 . x )  *  ( lineP2 . x - lineP1 . x )%NWL%+  ( point . y - lineP1 . y )  *  ( lineP2 . y - lineP1 . y )  )%NWL%/ denominator ; %NWL%if ( onSegmentOnly )  {%NWL%if ( ! ( 0 <  = u && u <  = 1 )  )  {%NWL%return undefined ;%NWL%}%NWL%}%NWL%pointOfIntersection = new Object (  )  ; %NWL%pointOfIntersection . x = lineP1 . x + u *  ( lineP2 . x - lineP1 . x )  ; %NWL%pointOfIntersection . y = lineP1 . y + u *  ( lineP2 . y - lineP1 . y )  ; %NWL%9
return { id : id }  ;%NWL%}%NWL%var data =  {%NWL%nodeType : node . nodeType ,%NWL%id : this . rememberNode ( node )%NWL%}  ; %NWL%switch ( data . nodeType )  {%NWL%case Node . DOCUMENT_TYPE_NODE : %NWL%var docType = node ; %NWL%data . name = docType . name ; %NWL%data . publicId = docType . publicId ; %NWL%9
C . lua_pushlstring = F (  " lua_pushlstring "  , void_t ,  [ lua_State , const_char_ptr_t , size_t ]  )  ; %NWL%C . lua_pushstring = F (  " lua_pushstring "  , void_t ,  [ lua_State , const_char_ptr_t ]  )  ; %NWL%C . lua_pushcclosure = F (  " lua_pushcclosure "  , void_t ,  [ lua_State , lua_CFunction , int_t ]  )  ; %NWL%C . lua_pushboolean = F (  " lua_pushboolean "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushlightuserdata = F (  " lua_pushlightuserdata "  , void_t ,  [ lua_State , void_ptr_t ]  )  ; %NWL%C . lua_pushthread = F (  " lua_pushthread "  , int_t ,  [ lua_State ]  )  ; %NWL%C . lua_gettable = F (  " lua_gettable "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_getfield = F (  " lua_getfield "  , void_t ,  [ lua_State , int_t , const_char_ptr_t ]  )  ; %NWL%C . lua_rawget = F (  " lua_rawget "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_rawgeti = F (  " lua_rawgeti "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%C . lua_createtable = F (  " lua_createtable "  , void_t ,  [ lua_State , int_t , int_t ]  )  ; %NWL%9
define (  [  ' dojo / _base / declare '  ,  ' dijit / _WidgetBase '  ,  ' dijit / _TemplatedMixin '  ,%NWL%' dojo / text! .  /  .  .  /  .  .  / templates / CreationOAuth2Item . html '  ,  ' dojo / dom - construct '  ,  ' dojo / topic '  ,  ' dojo / json '  ,%NWL%' dojo / dom - class '  ,  ' dojo / on '  ,  ' explorer / services - service '  ,  ' explorer / ExplorerContainer '  ,  ' dojo / Evented '  ]  ,%NWL%function ( declare , WidgetBase , TemplatedMixin , template , domConstruct , topic , JSON ,%NWL%domClass , on , servicesService , ExplorerContainer , Evented )  {%NWL%return declare (  ' CreationOAuth2ItemWidget '  ,  [ WidgetBase , TemplatedMixin ]  ,  {%NWL%templateString : template ,%NWL%constructor : function ( obj )  {%NWL%this . name = obj . name ; %NWL%this . clientId = obj . clientId ; %NWL%this . clientSecret = obj . clientSecret ; %NWL%8
this . y = a . y ; %NWL%break ; %NWL%case 2 :  /  /  ( x , y )  ,  ( width , height )%NWL%this . x = a . x ; %NWL%this . y = a . y ; %NWL%this . width = b . x ; %NWL%this . height = b . y ; %NWL%break ; %NWL%case 3 :  /  /  ( x , y )  , width , height%NWL%this . x = a . x ; %NWL%this . y = a . y ; %NWL%3
var p  = gl . createProgram (  )  ; %NWL%gl . attachShader ( p , Shaders . getVertexShader ( gl )  )  ; %NWL%gl . attachShader ( p , Shaders . getRenderShader_4Byte ( gl )  )  ; %NWL%gl . linkProgram ( p )  ; %NWL%p . textureWd = gl . getUniformLocation ( p ,  " u_texw "  )  ; %NWL%p . textureHt = gl . getUniformLocation ( p ,  " u_texh "  )  ; %NWL%p . texture = gl . getUniformLocation ( p ,  " u_data "  )  ; %NWL%p . visTileWd = gl . getUniformLocation ( p ,  " u_visTileWd "  )  ; %NWL%p . visTileHt = gl . getUniformLocation ( p ,  " u_visTileHt "  )  ; %NWL%p . visibleTileWd = gl . getUniformLocation ( p ,  " u_visibleTileWd "  )  ; %NWL%p . visibleTileHt = gl . getUniformLocation ( p ,  " u_visibleTileHt "  )  ; %NWL%7
CocoonJS . Social = function ( nativeExtensionName , extensionName )%NWL%{%NWL%if ( typeof nativeExtensionName ! =  =  ' string '  ) throw " The given native extension name '  "  + nativeExtensionName +  "  ' is not a string .  "  ; %NWL%if ( typeof extensionName ! =  =  ' string '  ) throw " The given extension name '  "  + extensionName +  "  ' is not a string .  "  ; %NWL%this . nativeExtensionName = nativeExtensionName ; %NWL%this . extensionName = extensionName ; %NWL%this . nativeExtensionObjectAvailable = CocoonJS . nativeExtensionObjectAvailable && typeof window . ext [ nativeExtensionName ] ! =  =  ' undefined '  ; %NWL%this . onRequestInitializationSucceed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestInitializationSucceed "  )  ; %NWL%this . onRequestInitializationFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestInitializationFailed "  )  ; %NWL%this . onRequestLoginSucceed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestLoginSucceed "  )  ; %NWL%this . onRequestLoginFailed = new CocoonJS . EventHandler ( this . nativeExtensionName , this . extensionName ,  " onRequestLoginFailed "  )  ; %NWL%7
}%NWL%}%NWL%function handleMouseDown ( ev , gridpos , datapos , neighbor , plot )  {%NWL%if ( neighbor )  {%NWL%var si = neighbor . seriesIndex ; %NWL%var pi = neighbor . pointIndex ; %NWL%var ins =  [ si , pi , neighbor . data , plot . series [ si ]  . gridData [ pi ]  [ 2 ]  ]  ; %NWL%if ( plot . series [ ins [ 0 ]  ]  . highlightMouseDown && ! ( ins [ 0 ]  =  = plot . plugins . bubbleRenderer . highlightedSeriesIndex && ins [ 1 ]  =  = plot . series [ ins [ 0 ]  ]  . _highlightedPoint )  )  {%NWL%var evt = jQuery . Event (  ' jqplotDataHighlight '  )  ; %NWL%evt . which = ev . which ; %NWL%evt . pageX = ev . pageX ; %NWL%9
if ( e . nodeName =  =  ' DD ' && dom . hasClass ( e ,  ' wp - caption - dd '  )  )  {%NWL%caption = e . innerHTML ; %NWL%return ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%f . img_cap . value = caption ; %NWL%f . img_title . value = ed . dom . getAttrib ( el ,  ' title '  )  ; %NWL%f . img_alt . value = ed . dom . getAttrib ( el ,  ' alt '  )  ; %NWL%f . border . value = ed . dom . getAttrib ( el ,  ' border '  )  ; %NWL%f . vspace . value = ed . dom . getAttrib ( el ,  ' vspace '  )  ; %NWL%9
fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function (  )  {  }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%9
oConn . releaseObject ( o )  ; %NWL%YAHOO . log (  ' File upload iframe destroyed . Id is :  '  + frameId ,  ' info '  ,  ' Connection '  )  ;%NWL%}  , 100 )  ;%NWL%}  ; %NWL%YE . addListener ( io ,  " load "  , uploadCallback )  ;%NWL%}%NWL%YCM . setForm = _setForm ; %NWL%YCM . resetFormState = _resetFormState ; %NWL%YCM . createFrame = _createFrame ; %NWL%YCM . appendPostData = _appendPostData ; %NWL%YCM . uploadFile = _uploadFile ; %NWL%6
commoner . customOptions . forEach ( function ( customOption )  {%NWL%options . option . apply ( options , customOption )  ;%NWL%}  )  ; %NWL%options . parse ( process . argv . slice ( 0 )  )  ; %NWL%var pfe = new PreferredFileExtension ( options . extension || " js "  )  ; %NWL%commoner . preferredFileExtension = pfe ; %NWL%commoner . watch = options . watch ; %NWL%commoner . ignoreDependencies = !options . followRequires ; %NWL%commoner . relativize = options . relativize ; %NWL%commoner . sourceCharset = normalizeCharset ( options . sourceCharset )  ; %NWL%commoner . outputCharset = normalizeCharset ( options . outputCharset )  ; %NWL%9
this . texture . frame . width = this . canvas . width ; %NWL%this . texture . frame . height = this . canvas . height ; %NWL%this . _width = this . canvas . width ; %NWL%this . _height = this . canvas . height ; %NWL%this . requiresUpdate =  true ;%NWL%}  ; %NWL%sprite . _renderWebGL = Adapter . engine . Text . prototype . _renderWebGL ; %NWL%sprite . touchmove = sprite . mousemove = function ( data )  {%NWL%var point =  { x : 0 , y : 0 }  ; %NWL%point . x = data . global . x - this . position . x ; %NWL%point . y = data . global . y - this . position . y ; %NWL%9
healthMax : 10 ,%NWL%health : 10 ,%NWL%fallDistance : 0 ,%NWL%maxFallDistance : 10000 ,%NWL%bounciness : 0 . 2 ,%NWL%init : function ( x , y , settings )%NWL%{%NWL%this . parent ( x , y , settings )  ; %NWL%this . setupAnimation (  )  ; %NWL%this . energy = this . energyMax ; %NWL%this . air = this . airMax ; %NWL%9
constructor [ key ]  = value ;%NWL%}%NWL%}%NWL%delete params . $statics ;%NWL%}%NWL%if ( hasOwn ( params ,  ' $implements '  )  )  {%NWL%cache . $implements = params . $implements ; %NWL%delete params . $implements ;%NWL%}%NWL%if ( hasOwn ( params ,  ' $abstracts '  )  )  {%NWL%cache . $abstracts = params . $abstracts ; %NWL%6
}%NWL%}  ,%NWL%getConnections : function ( req , res )  {%NWL%return function (  )  {%NWL%return req . redisConnections ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%app . getConfig = myUtils . getConfig ; %NWL%if ( !nosave )  {%NWL%app . saveConfig = myUtils . saveConfig ; %NWL%8
' use strict '  ; %NWL%requireApp (  ' email / js / alameda . js '  )  ; %NWL%requireApp (  ' email / test / config . js '  )  ; %NWL%suite (  ' message_reader '  , function (  )  {%NWL%var subject , MessageReader , evt ; %NWL%function MockMailHeader (  )  {  }%NWL%MockMailHeader . prototype =  {%NWL%makeCopy : function (  )  {%NWL%var copy = new MockMailHeader (  )  ; %NWL%copy . isRead = this . isRead ; %NWL%copy . isStarred = this . isStarred ; %NWL%9
case " httpOnly "  : comparator = compareTo . bind ( null , WebInspector . Cookie . prototype . httpOnly )  ; break ; %NWL%case " secure "  : comparator = compareTo . bind ( null , WebInspector . Cookie . prototype . secure )  ; break ; %NWL%default : compareTo . bind ( null , WebInspector . Cookie . prototype . name )  ;%NWL%}%NWL%cookies . sort ( comparator )  ;%NWL%}  ,%NWL%_createGridNode : function ( cookie )%NWL%{%NWL%var data =  {  }  ; %NWL%data . name = cookie . name (  )  ; %NWL%data . value = cookie . value (  )  ; %NWL%9
for ( var j = 0 ; j < numLineNotes ; j +  +  )  {%NWL%debugCtx . strokeStyle =  " #0000ff "  ; %NWL%debugCtx . strokeRect ( this . pixelMap [ i ]  . notes [ j ]  . start_x , this . pixelMap [ i ]  . y - 10 ,%NWL%this . pixelMap [ i ]  . notes [ j ]  . end_x - this . pixelMap [ i ]  . notes [ j ]  . start_x , this . pixelMap [ i ]  . height + 30 )  ;%NWL%}%NWL%}%NWL%}%NWL%TabPlayer . prototype . clearDebugRectangles = function (  )  {%NWL%var debugCanvas = $ ( this . tabDiv . sel +  '  . debugCanvas '  )  [ 0 ]  ; %NWL%debugCanvas . width = this . tabDiv . width ; %NWL%debugCanvas . height = this . tabDiv . height ; %NWL%9
air . Event = window . runtime . flash . events . Event ; %NWL%air . EventDispatcher = window . runtime . flash . events . EventDispatcher ; %NWL%air . FileListEvent = window . runtime . flash . events . FileListEvent ; %NWL%air . HTTPStatusEvent = window . runtime . flash . events . HTTPStatusEvent ; %NWL%air . IOErrorEvent = window . runtime . flash . events . IOErrorEvent ; %NWL%air . InvokeEvent = window . runtime . flash . events . InvokeEvent ; %NWL%air . NetStatusEvent = window . runtime . flash . events . NetStatusEvent ; %NWL%air . OutputProgressEvent = window . runtime . flash . events . OutputProgressEvent ; %NWL%air . ProgressEvent = window . runtime . flash . events . ProgressEvent ; %NWL%air . SecurityErrorEvent = window . runtime . flash . events . SecurityErrorEvent ; %NWL%air . StatusEvent = window . runtime . flash . events . StatusEvent ; %NWL%0
timerHTML :  '  < div class =  " timer "  >  < span class =  " mask "  >  < span class =  " rotator "  >  <  / span >  <  / span >  < span class =  " pause "  >  <  / span >  <  / div >  '  ,%NWL%captionHTML :  '  < div class =  " orbit - caption "  >  <  / div >  '  ,%NWL%directionalNavHTML :  '  < div class =  " slider - nav "  >  < span class =  " right "  >  <  / span >  < span class =  " left "  >  <  / span >  <  / div >  '  ,%NWL%bulletHTML :  '  < ul class =  " orbit - bullets "  >  <  / ul >  '  ,%NWL%init : function ( element , options )  {%NWL%var $imageSlides ,%NWL%imagesLoadedCount = 0 ,%NWL%self = this ; %NWL%this . clickTimer = $ . proxy ( this . clickTimer , this )  ; %NWL%this . addBullet = $ . proxy ( this . addBullet , this )  ; %NWL%this . resetAndUnlock = $ . proxy ( this . resetAndUnlock , this )  ; %NWL%8
var department = require (  '  .  / department '  )  ; %NWL%var identity =  ( function (  )  {%NWL%' use strict '  ; %NWL%var Identity = function (  )  {%NWL%var identity =  {  }  ; %NWL%identity . sex = sex (  )  ; %NWL%identity . firstName = firstName ( identity . sex )  ; %NWL%identity . lastName = lastName (  )  ; %NWL%identity . emailAddress = emailAddress ( identity . firstName , identity . lastName )  ; %NWL%identity . phoneNumber = phoneNumber (  )  ; %NWL%identity . street = street (  )  ; %NWL%5
return rv ;%NWL%}  ,%NWL%setCssText : function ( val )  {%NWL%var sheet =  { cssRules :  [  ]  }  ; %NWL%var parser = new CSSParser ( val )  ; %NWL%var token = parser . getToken ( true , true )  ; %NWL%if ( token . isAtRule (  " @ - mozkeyframes "  )  )  {%NWL%if ( parser . parseKeyframesRule ( token , sheet )  )  {%NWL%var newRule = sheet . cssRules [ 0 ]  ; %NWL%this . cssRules = newRule . cssRules ; %NWL%this . name = newRule . name ; %NWL%9
this . _onNewInstance = __bind ( this . _onNewInstance , this )  ; %NWL%this . _trackViewBinding = __bind ( this . _trackViewBinding , this )  ; %NWL%this . _hookSync = __bind ( this . _hookSync , this )  ; %NWL%this . _hookEvents = __bind ( this . _hookEvents , this )  ; %NWL%this . _trackObjects = __bind ( this . _trackObjects , this )  ; %NWL%this . off = __bind ( this . off , this )  ; %NWL%this . on = __bind ( this . on , this )  ; %NWL%this . routers = __bind ( this . routers , this )  ; %NWL%this . views = __bind ( this . views , this )  ; %NWL%this . models = __bind ( this . models , this )  ; %NWL%this . collections = __bind ( this . collections , this )  ; %NWL%0
if ( options . manifest )  {%NWL%async = options . manifest . async ; %NWL%extend ( this , options . manifest )  ;%NWL%}%NWL%ok ( dependencyRegistry ,  '  " dependencyRegistry " is required '  )  ; %NWL%this . _uniqueId = nextId +  +  ; %NWL%if ( options . dirname )  {%NWL%this . dirname = options . dirname ;%NWL%}%NWL%if ( options . filename )  {%NWL%this . filename = options . filename ; %NWL%7
if ( typeof parsedResponse . access_token =  =  =  ' string '  )%NWL%accessToken . access_token = parsedResponse . access_token ; %NWL%if ( typeof parsedResponse . refresh_token =  =  =  ' string '  )%NWL%accessToken . refresh_token = parsedResponse . refresh_token ; %NWL%if ( typeof parsedResponse . expires_in ! =  =  ' undefined '  )%NWL%accessToken . expires_in = parsedResponse . expires_in ;%NWL%} catch ( e )  {%NWL%console . error ( e )  ; %NWL%accessToken . access_token = response . match (  / access_token =  (  [ ^& ]  *  )  /  ) ? response . match (  / access_token =  (  [ ^& ]  *  )  /  )  [ 1 ]  : false ; %NWL%accessToken . refresh_token = response . match (  / refresh_token =  (  [ ^& ]  *  )  /  ) ? response . match (  / refresh_token =  (  [ ^& ]  *  )  /  )  [ 1 ]  : false ; %NWL%accessToken . expires_in = response . match (  / expires_in =  (  [ ^& ]  *  )  /  ) ? response . match (  / expires_in =  (  [ ^& ]  *  )  /  )  [ 1 ]  : false ; %NWL%8
return ( results ) ? ( decodeURIComponent ( results [ 1 ] || 0 )  )  : null ;%NWL%}%NWL%EC . readHashFromURL = function (  )  {%NWL%var results = new RegExp (  ' # (  [ ^ |^?|^&|^ =  ]  *  )  '  )  . exec ( window . location . href )  ; %NWL%return ( results ) ? ( decodeURIComponent ( results [ 0 ]  )  )  : null ;%NWL%}%NWL%EC . Core = C ; %NWL%EC . Log = Log ; %NWL%EC . debug = Log . debug ; %NWL%EC . info = Log . info ; %NWL%EC . warn = Log . warn ; %NWL%8
function ( i , str )  {%NWL%$elm . off ( str )  ;%NWL%}%NWL%)  ; %NWL%return this ;%NWL%}  ; %NWL%MovingTarget . prototype . refresh = function (  )  {%NWL%var tb = getTopBottom ( this . scroller . elm , this . elm , this . offset_t , this . offset_b )  ; %NWL%var pos = findPosition ( this . scroller . elm , tb . top , tb . bottom )  ; %NWL%this . top = tb . top ; %NWL%this . bottom = tb . bottom ; %NWL%9
this . type   = tagName =  =  =  ' input ' ? ( opts . type || ' text '  )  : null ; %NWL%this . disabled  = opts . disabled  || false ; %NWL%this . value   = opts . value  || '  '  ; %NWL%this . label   = opts . label  || '  '  ; %NWL%this . placeholder  = opts . placeholder || '  '  ; %NWL%this . className  = className ; %NWL%this . tagName   = tagName ; %NWL%this . onChange  = opts . onChange  || function (  )  {  }  ; %NWL%this . onClick   = opts . onClick  || function (  )  {  }  ; %NWL%this . onKeyPress  = opts . onKeyPress || function (  )  {  }  ; %NWL%this . onKeyUp   = opts . onKeyUp  || function (  )  {  }  ; %NWL%8
this . url = split [ 0 ]  ; %NWL%var normalizeQuery = function ( query )  {%NWL%return query ? query . split (  ' & '  )  . sort (  )  . join (  ' & '  )  : undefined ;%NWL%}  ; %NWL%this . query = normalizeQuery ( split [ 1 ]  )  ; %NWL%this . data = normalizeQuery ( stubData )  ; %NWL%this . andReturn = function ( options )  {%NWL%this . status = options . status || 200 ; %NWL%this . contentType = options . contentType ; %NWL%this . responseXML = options . responseXML ; %NWL%this . responseText = options . responseText ; %NWL%8
WebDeveloper . Overlay . getSelectedTab ( function ( tab )%NWL%{%NWL%if ( WebDeveloper . Overlay . isValidTab ( tab )  )%NWL%{%NWL%var feature = featureItem . attr (  " id "  )  ; %NWL%var display = !chrome . extension . getBackgroundPage (  )  . WebDeveloper . Storage . isFeatureOnTab ( feature , tab )  ; %NWL%var locale  =  {  }  ; %NWL%locale . addHorizontalLineGuide = WebDeveloper . Locales . getString (  " addHorizontalLineGuide "  )  ; %NWL%locale . addVerticalLineGuide  = WebDeveloper . Locales . getString (  " addVerticalLineGuide "  )  ; %NWL%locale . nextPosition    = WebDeveloper . Locales . getString (  " nextPosition "  )  ; %NWL%locale . positionLabel    = WebDeveloper . Locales . getString (  " positionLabel "  )  ; %NWL%7
} else {%NWL%this . stream = stream ;%NWL%}%NWL%this . offset = offset ; %NWL%this . cache = 0 ; %NWL%this . left = CHAR_BIT ;%NWL%}%NWL%Mad . Bit . prototype . clone = function (  )  {%NWL%var c = new Mad . Bit ( this . stream , this . offset )  ; %NWL%c . cache = this . cache ; %NWL%c . left = this . left ; %NWL%9
state :  { preload : preload , create : create , update : update , render : render }  ,%NWL%}%NWL%var game = new Phaser . Game ( cfg )  ; %NWL%var filter ; %NWL%function preload (  )  {%NWL%game . load . image (  ' phaser '  ,  '  / phaser - examples / examples / assets / sprites / phaser2 . png '  )  ;%NWL%}%NWL%function create (  )  {%NWL%background = game . add . sprite ( 0 , 0 )  ; %NWL%background . width = game . width ; %NWL%background . height = game . height ; %NWL%9
" signalstrength "  :  {  " GetInfo "  : true ,  " SetInfo "  : false ,  " GetNotification "  : true ,  " GetInfoModeSync "  : false }  ,%NWL%" registrationstatus "  :  {  " GetInfo "  : true ,  " SetInfo "  : false ,  " GetNotification "  : true ,  " GetInfoModeSync "  : true }  ,%NWL%" networkmode "  :  {  " GetInfo "  : true ,  " SetInfo "  : false ,  " GetNotification "  : true ,  " GetInfoModeSync "  : true }  ,%NWL%" currentnetwork "  :  {  " GetInfo "  : true ,  " SetInfo "  : false ,  " GetNotification "  : true ,  " GetInfoModeSync "  : false }  ,%NWL%" locationarea "  :  {  " GetInfo "  : false ,  " SetInfo "  : false ,  " GetNotification "  : true ,  " GetInfoModeSync "  : false }  ,%NWL%" cellid "  :  {  " GetInfo "  : false ,  " SetInfo "  : false ,  " GetNotification "  : true ,  " GetInfoModeSync "  : false }%NWL%}%NWL%}  ; %NWL%var SysInfoService = function (  )  {%NWL%this . GetInfo 			 = __GetInfo ; %NWL%this . SetInfo 			 = __SetInfo ; %NWL%9
xmin :   - 100 ,%NWL%xmax :  100 ,%NWL%ymin :   - 100 ,%NWL%ymax :  100 ,%NWL%nx :  10 ,%NWL%ny :  10%NWL%}  )  ; %NWL%this . xmin = options . xmin ; %NWL%this . ymin = options . ymin ; %NWL%this . xmax = options . xmax ; %NWL%this . ymax = options . ymax ; %NWL%7
n_off = l + 1 ; %NWL%for ( i = 1 ; i < n_off ;  +  + i )%NWL%if ( off [ i - 1 ]  . maxv . compareTo ( off [ i ]  . minv )  >  = 0 )%NWL%off [ i - 1 ]  . maxv = off [ i ]  . minv ; %NWL%for ( i = 1 , l = 0 ; i < n_off ;  +  + i )  {%NWL%if ( off [ l ]  . maxv . block =  = off [ i ]  . minv . block )%NWL%off [ l ]  . maxv = off [ i ]  . maxv ; %NWL%else {%NWL%+  + l ; %NWL%off [ l ]  . minv = off [ i ]  . minv ; %NWL%off [ l ]  . maxv = off [ i ]  . maxv ; %NWL%9
var realGC = gc ; %NWL%var realUneval = uneval ; %NWL%function tryEnsureSanity (  )  {%NWL%try {%NWL%delete this . Math ; %NWL%delete this . Function ; %NWL%delete this . gc ; %NWL%delete this . uneval ; %NWL%this . Math = realMath ; %NWL%this . eval = realEval ; %NWL%this . Function = realFunction ; %NWL%8
mode =  " subscribe "  ,%NWL%topic = topicUri . href ,%NWL%verify = this . verify ,%NWL%lease_seconds =  '  '  ,  /  / TODO%NWL%secret =  '  '  ,  /  / TODO%NWL%verify_token =  '  '  ;  /  / TODO%NWL%var requestBody =  [%NWL%" hub . callback =  "  + querystring . escape ( callback )  ,%NWL%" hub . mode =  "  + querystring . escape ( mode )  ,%NWL%" hub . topic =  "  + querystring . escape ( topic )  ,%NWL%" hub . verify =  "  + querystring . escape ( verify )  ,%NWL%7
client . open (  " GET "  ,  " example . com / someApi "  )  ; %NWL%client . setRequestHeader (  " Content - Type "  ,  " text / plain "  )  ; %NWL%client . send (  )  ; %NWL%request = mockAjax . requests . mostRecent (  )  ; %NWL%response =  { status : 200 , statusText :  " OK "  , contentType :  " text / html "  , responseText :  " OK! "  }  ; %NWL%request . respondWith ( response )  ; %NWL%sharedContext . responseCallback = success ; %NWL%sharedContext . status = response . status ; %NWL%sharedContext . statusText = response . statusText ; %NWL%sharedContext . contentType = response . contentType ; %NWL%sharedContext . responseText = response . responseText ; %NWL%7
var LUA_INTEGER = lua_Integer ; %NWL%C . lua_newstate = F (  " lua_newstate "  , lua_State ,  [ lua_Alloc , void_ptr_t ]  )  ; %NWL%C . lua_close = F (  " lua_close "  , void_t ,  [ lua_State ]  )  ; %NWL%C . lua_newthread = F (  " lua_newthread "  , lua_State ,  [ lua_State ]  )  ; %NWL%C . lua_atpanic = F (  " lua_atpanic "  , lua_CFunction ,  [ lua_State , lua_CFunction ]  )  ; %NWL%C . lua_gettop = F (  " lua_gettop "  , int_t ,  [ lua_State ]  )  ; %NWL%C . lua_settop = F (  " lua_settop "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_pushvalue = F (  " lua_pushvalue "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_remove = F (  " lua_remove "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_insert = F (  " lua_insert "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%C . lua_replace = F (  " lua_replace "  , void_t ,  [ lua_State , int_t ]  )  ; %NWL%6
}%NWL%this . invDenom = 1 /  ( this . motorDenom + this . cfm )  ; %NWL%var totalImpulse = this . limitImpulse + this . motorImpulse ; %NWL%this . l1 . x +  = totalImpulse * this . l1x ; %NWL%this . l1 . y +  = totalImpulse * this . l1y ; %NWL%this . l1 . z +  = totalImpulse * this . l1z ; %NWL%this . a1 . x +  = totalImpulse * this . a1x ; %NWL%this . a1 . y +  = totalImpulse * this . a1y ; %NWL%this . a1 . z +  = totalImpulse * this . a1z ; %NWL%this . l2 . x -  = totalImpulse * this . l2x ; %NWL%this . l2 . y -  = totalImpulse * this . l2y ; %NWL%4
if ( entries . length > 0 )  {%NWL%selection = this . _valueSet ; %NWL%labeler = valueType =  =  " item " ?%NWL%function ( v )  { var l = database . getObject ( v ,  " label "  )  ; %NWL%return l ! = null ? l : v ;  }  : %NWL%function ( v )  { return v ;  }%NWL%for ( i = 0 ; i < entries . length ; i +  +  )  {%NWL%entry = entries [ i ]  ; %NWL%entry . actionLabel = entry . selectionLabel = labeler ( entry . value )  ; %NWL%entry . image = this . _imageExpression . evaluateSingleOnItem ( entry . value , database )  . value ; %NWL%entry . tooltip = this . _tooltipExpression . evaluateSingleOnItem ( entry . value , database )  . value ; %NWL%9
self . orderByColumn =  '  '  ; %NWL%self . orderByReverse = false ; %NWL%self . filter =  "  "  ; %NWL%self . filterText =  "  "  ; %NWL%self . initialize = _initialize ; %NWL%self . toggleAddMode = _toggleAddMode ; %NWL%self . toggleEditMode = _toggleEditMode ; %NWL%self . createItem = _createItem ; %NWL%self . readItem = _readItem ; %NWL%self . updateItem = _updateItem ; %NWL%self . deleteItemWithConfirmation = _deleteItemWithConfirmation ; %NWL%4
cv . p1y = this . p1y ; %NWL%cv . c1x = this . c1x ; %NWL%cv . c1y = this . c1y ; %NWL%return cv ;%NWL%}%NWL%self . prototype . getBoundary = function (  )  {%NWL%var rect =  {  }  ; %NWL%var xRange = this . getRange ( this . p0x , this . c0x , this . p1x , this . c1x )  ; %NWL%var yRange = this . getRange ( this . p0y , this . c0y , this . p1y , this . c1y )  ; %NWL%rect . x = xRange . min ; %NWL%rect . y = yRange . min ; %NWL%9
this . connected = false ; %NWL%this . poolSize = this . options . poolSize =  = null ? 5 : this . options . poolSize ; %NWL%this . disableDriverBSONSizeCheck = this . options . disableDriverBSONSizeCheck ! = null ? this . options . disableDriverBSONSizeCheck : false ; %NWL%this . _used = false ; %NWL%this . replicasetInstance = null ; %NWL%this . ssl = this . options . ssl =  = null ? false : this . options . ssl ; %NWL%this . sslValidate = this . options . sslValidate =  = null ? false : this . options . sslValidate ; %NWL%this . sslCA = Array . isArray ( this . options . sslCA ) ? this . options . sslCA : null ; %NWL%this . sslCert = this . options . sslCert ; %NWL%this . sslKey = this . options . sslKey ; %NWL%this . sslPass = this . options . sslPass ; %NWL%8
r_sum +  = sumFactor * pr ; %NWL%g_sum +  = sumFactor * pg ; %NWL%b_sum +  = sumFactor * pb ; %NWL%a_sum +  = sumFactor * pa ; %NWL%stack = stackStart ; %NWL%for ( i = 0 ; i < radiusPlus1 ; i +  +  )%NWL%{%NWL%stack . r = pr ; %NWL%stack . g = pg ; %NWL%stack . b = pb ; %NWL%stack . a = pa ; %NWL%7
" use strict "  ; %NWL%var AxisType = Enums . AxisType ; %NWL%function Axis ( opts )  {%NWL%opts || ( opts =  {  }  )  ; %NWL%this . name = opts . name ! = undefined ? opts . name :  " unknown "  ; %NWL%this . negButton = opts . negButton ! = undefined ? opts . negButton :  "  "  ; %NWL%this . posButton = opts . posButton ! = undefined ? opts . posButton :  "  "  ; %NWL%this . altNegButton = opts . altNegButton ! = undefined ? opts . altNegButton :  "  "  ; %NWL%this . altPosButton = opts . altPosButton ! = undefined ? opts . altPosButton :  "  "  ; %NWL%this . gravity = opts . gravity ! = undefined ? opts . gravity : 3 ; %NWL%this . sensitivity = opts . sensitivity ! = undefined ? opts . sensitivity : 3 ; %NWL%9
this . lights =  [  ]  ; %NWL%for ( var i = 0 ; i < lights . length ;  +  + i )  {%NWL%var l = lights [ i ]  ; %NWL%this . lights . push (  { direction : lite . normalize ( l . direction )  , color : lite . toStdColor ( l . color )  }  )  ;%NWL%}%NWL%this . ambient = lite . toStdColor ( ambient . color ? ambient . color :  " white "  )  ; %NWL%this . ambient = lite . scaleColor ( ambient . intensity , this . ambient )  ; %NWL%this . ambient = lite . scaleColor ( this . ambient . a , this . ambient )  ; %NWL%this . ambient . a = 1 ; %NWL%this . specular = lite . toStdColor ( specular ? specular :  " white "  )  ; %NWL%this . specular = lite . scaleColor ( this . specular . a , this . specular )  ; %NWL%7
self . timeout = details . timeout ; %NWL%self . halfClosed = details . halfClosed ; %NWL%self . nodes = details . nodes || [  ]  ; %NWL%self . virtualIps = details . virtualIps || [  ]  ; %NWL%self . sourceAddresses = details . sourceAddresses ; %NWL%self . httpsRedirect = details . httpsRedirect ; %NWL%self . connectionLogging = details . connectionLogging ; %NWL%self . contentCaching = details . contentCaching ; %NWL%self . nodeCount = details . nodeCount || ( details . nodes ? details . nodes . length : 0 )  ; %NWL%self . created = details . created ; %NWL%self . updated = details . updated ; %NWL%0
dateField : init%NWL%}%NWL%}  )  ; %NWL%$ . extend ( Tapestry ,  {%NWL%DateField :  {%NWL%firstDay : 0 ,%NWL%localized : false ,%NWL%initLocalization : function ( loc )  {%NWL%this . months = loc . months ; %NWL%this . days = loc . days ; %NWL%this . firstDay = loc . firstDay ; %NWL%8
}%NWL%function PinnedHomeIcon ( identifier )  {%NWL%return {%NWL%identifier : identifier ,%NWL%type :  ' homeIcon '%NWL%}  ;%NWL%}%NWL%function BaseCollection ( props )  {%NWL%this . id = props . id || null ; %NWL%this . name = props . name || '  '  ; %NWL%this . nonTranslatable = props . nonTranslatable || null ; %NWL%8
function augment ( arr )  {%NWL%arr . _isBuffer = true%NWL%arr . write = BP . write%NWL%arr . toString = BP . toString%NWL%arr . toLocaleString = BP . toString%NWL%arr . toJSON = BP . toJSON%NWL%arr . copy = BP . copy%NWL%arr . slice = BP . slice%NWL%arr . readUInt8 = BP . readUInt8%NWL%arr . readUInt16LE = BP . readUInt16LE%NWL%arr . readUInt16BE = BP . readUInt16BE%NWL%2
return t =  =  = Object ( t ) ? t :  { down : t , up : t }  ;%NWL%}%NWL%function Headroom ( elem , options )  {%NWL%options = extend ( options , Headroom . options )  ; %NWL%this . lastKnownScrollY = 0 ; %NWL%this . elem    = elem ; %NWL%this . debouncer   = new Debouncer ( this . update . bind ( this )  )  ; %NWL%this . tolerance   = normalizeTolerance ( options . tolerance )  ; %NWL%this . classes    = options . classes ; %NWL%this . offset    = options . offset ; %NWL%this . scroller   = options . scroller ; %NWL%8
log . info ( options . start . toString (  )  ,  '  -  '  , options . end . toString (  )  )  ; %NWL%hbase . getAggregateAccountPayments ( options )%NWL%. nodeify ( function ( err , resp )  {%NWL%if ( err )  {%NWL%errorResponse ( err )  ;%NWL%} else {%NWL%if ( options . descending ) resp . reverse (  )  ; %NWL%if ( !options . accounts )  {%NWL%resp . forEach ( function ( row )  {%NWL%row . receiving_counterparties = row . receiving_counterparties . length ; %NWL%row . sending_counterparties  = row . sending_counterparties . length ; %NWL%9
} else {%NWL%other = other . convertTo ( this . unit . usedUnits (  )  )  ; %NWL%if ( env . strictUnits && other . unit . toString (  ) ! =  = unit . toString (  )  )  {%NWL%throw new Error (  " Incompatible units . Change the units or use the unit function . Bad units :  '  "  + unit . toString (  )  +%NWL%"  ' and '  "  + other . unit . toString (  )  +  "  '  .  "  )  ;%NWL%}%NWL%value = tree . operate ( env , op , this . value , other . value )  ;%NWL%}%NWL%} else if ( op =  =  =  '  *  '  )  {%NWL%unit . numerator = unit . numerator . concat ( other . unit . numerator )  . sort (  )  ; %NWL%unit . denominator = unit . denominator . concat ( other . unit . denominator )  . sort (  )  ; %NWL%9
this . uniqueId = state . uniqueId ; %NWL%this . name = state . name ; %NWL%this . active = state . active ; %NWL%this . width = state . width ; %NWL%this . height = state . height ; %NWL%this . x = state . x ; %NWL%this . y = state . y ; %NWL%this . zIndex = state . zIndex ; %NWL%this . minimized = state . minimized ; %NWL%this . maximized = state . maximized ; %NWL%this . pinned = state . pinned ; %NWL%0
firstTabStop =  {%NWL%start : value . length + start ,%NWL%end : value . length + start%NWL%}  ;%NWL%}%NWL%var range = this . ace . getSelectionRange (  )  ; %NWL%range . start = this . ace . indexToPosition ( start )  ; %NWL%range . end = this . ace . indexToPosition ( end )  ; %NWL%this . ace . session . replace ( range , value )  ; %NWL%range . start = this . ace . indexToPosition ( firstTabStop . start )  ; %NWL%range . end = this . ace . indexToPosition ( firstTabStop . end )  ; %NWL%9
this . empty = true ;%NWL%} else {%NWL%this . top =  - this . halfHeight + this . y ; %NWL%this . bottom = this . halfHeight + this . y ;%NWL%}%NWL%return this ;%NWL%}  ; %NWL%proto . set = function ( aabb )  {%NWL%this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%8
. mousedown ( function (  )  {%NWL%jQuery ( this )  . parent (  )  . mousedown (  )  ;%NWL%}  )%NWL%. mousemove ( function (  )  {%NWL%jQuery ( this )  . parent (  )  . mousemove (  )  ; %NWL%return false ;%NWL%}  )%NWL%}  , o )  ; %NWL%o . data = sanitize ( o . data , true )  ; %NWL%o . x . data = sanitize ( o . x . data , true )  ; %NWL%o . y . data = sanitize ( o . y . data , true )  ; %NWL%9
json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%json . colorSpread = this . colorSpread . toJSON ( json . colorSpread )  ; %NWL%json . time = this . time ; %NWL%json . _time = this . _time ; %NWL%json . duration = this . duration ; %NWL%1
parseIntentsDocument (  )  ;%NWL%}%NWL%} catch ( err )  {%NWL%if ( !!console && !!console . log ) console . log ( err )  ;%NWL%}%NWL%}  ; %NWL%addEventListener ( window ,  " message "  , handler , false )  ; %NWL%var loadIntentData = function ( data )  {%NWL%var intent = new Intent (  )  ; %NWL%intent . _id  = data . _id ; %NWL%intent . action = data . action ; %NWL%9
}%NWL%this . isResolved = promise . isResolved = function (  )  {%NWL%return fired =  = 0 ;%NWL%}  ; %NWL%this . isRejected = promise . isRejected = function (  )  {%NWL%return fired =  = 1 ;%NWL%}  ; %NWL%this . isFulfilled = promise . isFulfilled = function (  )  {%NWL%return fired >  = 0 ;%NWL%}  ; %NWL%this . isCanceled = promise . isCanceled = function (  )  {%NWL%1
this . black = black || 0 ; %NWL%this . current_input_masks = current_input_masks || 0 ; %NWL%this . height_px = height_px || 0 ; %NWL%this . width_px = width_px || 0 ; %NWL%this . height_mm = height_mm || 0 ; %NWL%this . width_mm = width_mm || 0 ; %NWL%this . maps_min = maps_min || 0 ; %NWL%this . maps_max = maps_max || 0 ; %NWL%this . root_visual = root_visual || 0 ; %NWL%this . backing_stores = backing_stores || 0 ; %NWL%this . save_unders = save_unders || 0 ; %NWL%0
' use strict '  ; %NWL%angular . module (  ' material . components . tabs '  )%NWL%. controller (  ' $mdTabs '  , MdTabsController )  ; %NWL%function MdTabsController ( $scope , $element , $mdUtil )  {%NWL%var tabsList = $mdUtil . iterator (  [  ]  , false )  ; %NWL%var self = this ; %NWL%self . $element = $element ; %NWL%self . contentArea = angular . element ( $element [ 0 ]  . querySelector (  '  . md - tabs - content '  )  )  ; %NWL%self . inRange = tabsList . inRange ; %NWL%self . indexOf = tabsList . indexOf ; %NWL%self . itemAt = tabsList . itemAt ; %NWL%8
coreHelpers . ghost_foot = require (  '  .  / ghost_foot '  )  ; %NWL%coreHelpers . ghost_head = require (  '  .  / ghost_head '  )  ; %NWL%coreHelpers . is = require (  '  .  / is '  )  ; %NWL%coreHelpers . has = require (  '  .  / has '  )  ; %NWL%coreHelpers . meta_description = require (  '  .  / meta_description '  )  ; %NWL%coreHelpers . meta_title = require (  '  .  / meta_title '  )  ; %NWL%coreHelpers . navigation = require (  '  .  / navigation '  )  ; %NWL%coreHelpers . page_url = require (  '  .  / page_url '  )  ; %NWL%coreHelpers . pageUrl = require (  '  .  / page_url '  )  . deprecated ; %NWL%coreHelpers . pagination = require (  '  .  / pagination '  )  ; %NWL%coreHelpers . plural = require (  '  .  / plural '  )  ; %NWL%0
var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red * f ; %NWL%result . green = c1 . green * f ; %NWL%result . blue = c1 . blue * f ; %NWL%return result ;%NWL%}  ,%NWL%divideFactor : function ( c1 , f )  {%NWL%var result = new Flog . RayTracer . Color ( 0 , 0 , 0 )  ; %NWL%result . red = c1 . red / f ; %NWL%result . green = c1 . green / f ; %NWL%result . blue = c1 . blue / f ; %NWL%8
return weekCalc ;%NWL%}%NWL%else if ( weekCalc =  =  =  ' local '  )  {%NWL%return weekCalc ;%NWL%}%NWL%else if ( weekCalc =  =  =  ' iso ' || weekCalc =  =  =  ' ISO '  )  {%NWL%return ' ISO '  ;%NWL%}%NWL%}  )  ( options . weekNumberCalculation )  ; %NWL%t . defaultAllDayEventDuration = moment . duration ( options . defaultAllDayEventDuration )  ; %NWL%t . defaultTimedEventDuration = moment . duration ( options . defaultTimedEventDuration )  ; %NWL%9
p . plotsHt = gl . getUniformLocation ( p ,  " u_plotsHt "  )  ; %NWL%p . oneDPlotHt = gl . getUniformLocation ( p ,  " u_1dPlotHt "  )  ; %NWL%p . pixOffsets = gl . getUniformLocation ( p ,  " u_pixOffsets "  )  ; %NWL%p . texIdx = gl . getUniformLocation ( p ,  " u_texIdx "  )  ; %NWL%p . containerPos = gl . getUniformLocation ( p ,  " u_containerPos "  )  ; %NWL%p . pixOrigin = gl . getUniformLocation ( p ,  " u_pixOrigin "  )  ; %NWL%p . zm = gl . getUniformLocation ( p ,  " u_zm "  )  ; %NWL%p . transformation = gl . getUniformLocation ( p ,  " u_trans "  )  ; %NWL%p . loV = gl . getUniformLocation ( p ,  " u_loV "  )  ; %NWL%p . hiV = gl . getUniformLocation ( p ,  " u_hiV "  )  ; %NWL%p . histColor = gl . getUniformLocation ( p ,  " u_histColor "  )  ; %NWL%8
soundalert (  )  ;%NWL%}  )  ;%NWL%}%NWL%}%NWL%function getBase64ImageById ( id , ftype )  {%NWL%return getBase64Image ( document . getElementById ( id , ftype )  )  ;%NWL%}%NWL%function getBase64Image ( img , ftype )  {%NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%canvas . width = img . width ; %NWL%canvas . height = img . height ; %NWL%9
}  ; %NWL%console . warn = function (  )  {%NWL%err = Array . prototype . slice . call ( arguments , 0 )  . join (  "  "  )  ;%NWL%}  ; %NWL%monologue . on (  " Some . Topic "  , function (  )  {%NWL%throw new Error (  " Oopsies "  )  ;%NWL%}  )  . catch (  )  . logError (  )  ; %NWL%monologue . emit (  " Some . Topic "  ,  " Hai *  *  "  )  ; %NWL%err . should . be . ok ;  /  / jshint ignore : line%NWL%console . log = _log ; %NWL%console . warn = _warn ; %NWL%9
function AmazonMwsClient ( accessKeyId , secretAccessKey , merchantId , options )  {%NWL%this . host = options . host || ' mws . amazonservices . com '  ; %NWL%this . port = options . port || 443 ; %NWL%this . conn = options . conn || https ; %NWL%this . creds = crypto . createCredentials ( options . creds || {  }  )  ; %NWL%this . appName = options . appName || ' mws - js '  ; %NWL%this . appVersion = options . appVersion || ' 0 . 1 . 0 '  ; %NWL%this . appLanguage = options . appLanguage || ' JavaScript '  ; %NWL%this . accessKeyId = accessKeyId || null ; %NWL%this . secretAccessKey = secretAccessKey || null ; %NWL%this . merchantId = merchantId || null ; %NWL%8
o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . globalAlpha  = o1 . globalAlpha ; %NWL%o2 . arcScaleX_  = o1 . arcScaleX_ ; %NWL%o2 . arcScaleY_  = o1 . arcScaleY_ ; %NWL%o2 . lineScale_  = o1 . lineScale_ ; %NWL%0
return oValue ;%NWL%}  ; %NWL%function fWheelEvent_init ( oEvent , sType , oValue )  {%NWL%fMouseEvent_init ( oEvent , sType , oValue )  ; %NWL%if ( oValue )  {%NWL%if (  " deltaX " in oValue )%NWL%oEvent . deltaX	 = oValue . deltaX ; %NWL%if (  " deltaY " in oValue )%NWL%oEvent . deltaY	 = oValue . deltaY ; %NWL%if (  " deltaZ " in oValue )%NWL%oEvent . deltaZ	 = oValue . deltaZ ; %NWL%6
var h = a . style . height || ( parseInt ( a . height )  > 1 ? parseInt ( a . height )  +  ' px '  :  ' 100px '  )  ; %NWL%var id =  ' iframe '  + Math . random (  )  . toString (  )  . substring ( 2 )  ; %NWL%self . scripts [ id ]  = t ; %NWL%var img =  '  < img id =  "  '  + id +  '  " src =  "  '  + self . url +  ' pixel . gif " class =  " elrte - protected elrte - iframe " style =  " width :  '  + w +  '  ; height :  '  + h +  '  "  >  '  ; %NWL%return img ;%NWL%}  )%NWL%. replace ( this . vimeoRegExp , function ( t , n , a )  {%NWL%a = self . parseAttrs ( a )  ; %NWL%delete a . frameborder ; %NWL%a . width =  =  ' 1 ' && delete a . width ; %NWL%a . height =  =  ' 1 ' && delete a . height ; %NWL%9
}%NWL%}  ; %NWL%Drupal . ahah = function ( base , element_settings )  {%NWL%this . element = element_settings . element ; %NWL%this . selector = element_settings . selector ; %NWL%this . event = element_settings . event ; %NWL%this . keypress = element_settings . keypress ; %NWL%this . url = element_settings . url ; %NWL%this . wrapper =  ' # '  + element_settings . wrapper ; %NWL%this . effect = element_settings . effect ; %NWL%this . method = element_settings . method ; %NWL%4
parseCode : function (  )  {%NWL%var tok = this . expect (  ' code '  )%NWL%, node = new nodes . Code ( tok . val , tok . buffer , tok . escape )%NWL%, block%NWL%, i = 1 ; %NWL%node . line = this . line (  )  ; %NWL%while ( this . lookahead ( i ) && ' newline '  =  = this . lookahead ( i )  . type )  +  + i ; %NWL%block =  ' indent '  =  = this . lookahead ( i )  . type ; %NWL%if ( block )  {%NWL%this . skip ( i - 1 )  ; %NWL%node . block = this . block (  )  ; %NWL%5
mocks . getMockFunction (  )  . mockImplementation ( mockTimers . runTimersRepeatedly )  ; %NWL%window . mockClearTimers =%NWL%mocks . getMockFunction (  )  . mockImplementation ( mockTimers . clearTimers )  ; %NWL%window . mockGetTimersCount =%NWL%mocks . getMockFunction (  )  . mockImplementation ( mockTimers . getTimersCount )  ;%NWL%}  ; %NWL%module . exports . uninstallMockTimers = function ( window )  {%NWL%window . setTimeout = window . _originalTimeouts . setTimeout ; %NWL%window . clearTimeout = window . _originalTimeouts . clearTimeout ; %NWL%window . setInterval = window . _originalTimeouts . setInterval ; %NWL%window . clearInterval = window . _originalTimeouts . clearInterval ; %NWL%7
this . specificity =  ' month '  ;%NWL%}%NWL%}%NWL%}%NWL%this . prefill = function (  )  {%NWL%if ( this . specificity =  =  ' year '  )  {%NWL%this . year = this . minyear ;%NWL%}%NWL%if ( this . specificity =  =  ' month '  )  {%NWL%this . year = this . minyear ; %NWL%this . month = this . minmonth ; %NWL%6
dojo . _hasResource [  " dojox . drawing . manager . StencilUI "  ]  = true ; %NWL%dojo . provide (  " dojox . drawing . manager . StencilUI "  )  ;%NWL%( function (  )  {%NWL%var surface , surfaceNode ; %NWL%dojox . drawing . manager . StencilUI = dojox . drawing . util . oo . declare (%NWL%function ( options )  {%NWL%surface = options . surface ; %NWL%this . canvas = options . canvas ; %NWL%this . defaults = dojox . drawing . defaults . copy (  )  ; %NWL%this . mouse = options . mouse ; %NWL%this . keys = options . keys ; %NWL%7
toRange . end = toRange . start ;%NWL%} else if ( caret =  =  ' end '  )  {%NWL%toRange . start = toRange . end ;%NWL%}%NWL%element . focus (  )  ; %NWL%try {%NWL%if ( element . createTextRange )  {%NWL%var range = element . createTextRange (  )  ; %NWL%if ( win . navigator . userAgent . toLowerCase (  )  . indexOf (  " msie "  )  >  = 0 )  {%NWL%toRange . start = element . value . substr ( 0 , toRange . start )  . replace (  / \r / g ,  '  '  )  . length ; %NWL%toRange . end = element . value . substr ( 0 , toRange . end )  . replace (  / \r / g ,  '  '  )  . length ; %NWL%9
}%NWL%}%NWL%return ( currVal )%NWL%}%NWL%function createSortingHat ( myGraph )  {%NWL%var sorter =  [  ]%NWL%for ( var i = 0 ; i < myGraph . links . length ; i +  +  )  {%NWL%var link = myGraph . links [ i ]%NWL%var aGuy =  {  }%NWL%aGuy . min = Math . min ( link . source . row , link . target . row )%NWL%aGuy . max = Math . max ( link . source . row , link . target . row )%NWL%9
}  )  ; %NWL%this . __defineGetter__ (  " height "  , function (  )  {%NWL%return videoContent . height ;%NWL%}  )  ;%NWL%}  ; %NWL%AudioContentInternal = function ( audioContentInitDict )  {%NWL%ContentInternal . call ( this , audioContentInitDict )  ; %NWL%this . album   = audioContentInitDict . album || null ; %NWL%this . genres   = audioContentInitDict . genres || null ; %NWL%this . artists  = audioContentInitDict . artists || null ; %NWL%this . composers  = audioContentInitDict . composers || null ; %NWL%7
var WebappOptimize = function (  )  {%NWL%this . config = null ; %NWL%this . webapp = null ; %NWL%this . win = null ; %NWL%this . locales = null ; %NWL%this . numOfFiles = 0 ;%NWL%}  ; %NWL%WebappOptimize . prototype . RE_HTML =  / \ . html$ /  ; %NWL%WebappOptimize . prototype . setOptions = function ( options )  {%NWL%this . config = options . config ; %NWL%this . webapp = options . webapp ; %NWL%9
var h = this . node . appendChild ( dojo . doc . createElement (  ' h1 '  )  )  ; %NWL%dojo . addClass ( h ,  " handle "  )  ; %NWL%this . node . id =  " downloadDiv "  ; %NWL%h . innerHTML =  " download? "  ; %NWL%var form = this . node . appendChild ( dojo . byId (  " downloadForm "  )  )  ; %NWL%dojo . style ( form ,  " visibility "  ,  " visible "  )  ; %NWL%dojo . style ( this . node ,  " zIndex "  ,  " 100 "  )  ; %NWL%new dojo . dnd . Moveable ( this . node ,  { handle : h }  )  ; %NWL%this . closeNode = dojo . byId (  " closeNode "  )  ; %NWL%dojo . connect ( this . closeNode ,  " onclick "  , this ,  " hide "  )  ; %NWL%this . submitNode = dojo . byId (  " submitNode "  )  ; %NWL%8
oauthAccessToken : oauthAccessToken ,%NWL%oauthAccessSecret : oauthAccessSecret ,%NWL%oauthRedirect : oauth . oauthRedirect%NWL%}  )  , results )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%OAuth1Authentication . prototype . restore = function ( data )  {%NWL%var options = clone ( this . api . options )  ; %NWL%options . oauthAccessToken = data . oauthAccessToken ; %NWL%options . oauthAccessSecret = data . oauthAccessSecret ; %NWL%9
if ( m . blending ! =  = undefined && THREE [ m . blending ] ! =  = undefined )  {%NWL%mpars . blending = THREE [ m . blending ]  ;%NWL%}%NWL%if ( m . transparent ! =  = undefined )  {%NWL%mpars . transparent = m . transparent ;%NWL%}%NWL%if ( m . opacity ! =  = undefined && m . opacity < 1 . 0 )  {%NWL%mpars . transparent = true ;%NWL%}%NWL%if ( m . depthTest ! =  = undefined )  {%NWL%mpars . depthTest = m . depthTest ; %NWL%4
suite (  ' GeneralSettingsGroupView '  , function (  )  {%NWL%var groupView ; %NWL%var stubSettingsView ; %NWL%var container ; %NWL%var app ; %NWL%setup ( function (  )  {%NWL%container =  { stub :  ' container '  }  ; %NWL%app =  { stub :  ' app '  }  ; %NWL%window . SoundFeedbackSettings =  { stub :  ' SoundFeedbackSettings '  }  ; %NWL%window . VibrationFeedbackSettings =  { stub :  ' VibrationFeedbackSettings '  }  ; %NWL%window . IMEngineSettings =  { stub :  ' IMEngineSettings '  }  ; %NWL%8
if ( typeof func ! =  =  " function "  )  {%NWL%throw new Error (  " AutoForm before hook must be a function , not "  + typeof func )  ;%NWL%}%NWL%hooksList . before [ type ]  =  ( !replace && hooksList . before [ type ]  ) ? hooksList . before [ type ]  :  [  ]  ; %NWL%hooksList . before [ type ]  . push ( func )  ;%NWL%}  )  ; %NWL%hooks . after && _ . each ( hooks . after , function autoFormAfterHooksEach ( func , type )  {%NWL%if ( typeof func ! =  =  " function "  )  {%NWL%throw new Error (  " AutoForm after hook must be a function , not "  + typeof func )  ;%NWL%}%NWL%hooksList . after [ type ]  =  ( !replace && hooksList . after [ type ]  ) ? hooksList . after [ type ]  :  [  ]  ; %NWL%3
insobject . gid = parseInt ( objects [ i ]  . attributes . getNamedItem (  " gid "  )  . nodeValue )  ; %NWL%insobject . tile = this . getTile ( insobject . gid )  ; %NWL%insobject . width = insobject . tile . width ; %NWL%insobject . height = insobject . tile . height ; %NWL%insobject . hastile = true ;%NWL%} else {%NWL%insobject . width = parseInt ( objects [ i ]  . attributes . getNamedItem (  " width "  )  . nodeValue )  ; %NWL%insobject . height = parseInt ( objects [ i ]  . attributes . getNamedItem (  " height "  )  . nodeValue )  ; %NWL%insobject . hastile = false ;%NWL%}%NWL%insobject . x = parseInt ( objects [ i ]  . attributes . getNamedItem (  " x "  )  . nodeValue )  ; %NWL%0
fail ( options )  ;%NWL%} else {%NWL%success ( options )  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%function normaliseRules ( options , ready )  {%NWL%rules . watch . add ( options . watch )  ; %NWL%rules . ignore . add ( options . ignore )  ; %NWL%options . watch = rules . rules . watch ; %NWL%options . ignore = rules . rules . ignore ; %NWL%9
Cancel : null ,%NWL%Ban : function (  )  {%NWL%var ban =  { banned : user . id , bannedname : user . name , reason : $ (  ' #ban - reason '  )  . val (  )  }  ,%NWL%durationtype = $ (  ' input [ name = duration - type ]  : checked '  )  . val (  )  ,%NWL%m = durationtype . match (  / ^ (  [ a - z ]  +  )  ( \d +  ) $ /  )  ; %NWL%if ( m )  {%NWL%ban . nb = m [ 2 ]  ; %NWL%ban . unit = m [ 1 ]  ;%NWL%} else {%NWL%ban . nb = $ (  ' #ban_nb '  )  . val (  )  ; %NWL%ban . unit = $ (  ' #ban_unit '  )  . val (  )  ; %NWL%9
}  )  ; %NWL%var _p = cc . RenderTexture . prototype ; %NWL%if ( cc . _renderType =  = cc . _RENDER_TYPE_WEBGL )  {%NWL%_p . ctor = _p . _ctorForWebGL ; %NWL%_p . cleanup = _p . _cleanupForWebGL ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForWebGL ; %NWL%_p . begin = _p . _beginForWebGL ; %NWL%_p . _beginWithClear = _p . _beginWithClearForWebGL ; %NWL%_p . end = _p . _endForWebGL ; %NWL%_p . clearRect = _p . _clearRectForWebGL ; %NWL%_p . clearDepth = _p . _clearDepthForWebGL ; %NWL%3
if ( options . heartbeatInterval ) queen . heartbeatInterval = options . heartbeatInterval ;%NWL%}  ; %NWL%module . exports . protocol = require (  '  .  .  / protocol . js '  )  ; %NWL%var WEB_ROOT = module . exports . WEB_ROOT = path . resolve ( path . dirname ( module . filename )  ,  '  .  .  /  .  .  / static '  )  ; %NWL%function getApi ( queen )  {%NWL%var api = queen . getWorkforce . bind ( queen )  ; %NWL%api . on = queen . emitter . on . bind ( queen . emitter )  ; %NWL%api . removeListener = queen . emitter . removeListener . bind ( queen . emitter )  ; %NWL%api . kill = queen . kill ; %NWL%api . getWorkerProvider = queen . getWorkerProvider . bind ( queen )  ; %NWL%api . acquireWebSocketEndpoint = queen . acquireWebSocketEndpoint . bind ( queen )  ; %NWL%9
this . onError ( new Error (  " Unexpected "  + toknam ( token )  +  ( value ? (  "  (  "  + JSON . stringify ( value )  +  "  )  "  )  :  "  "  )  +  " in state "  + toknam ( this . state )  )  )  ;%NWL%}  ; %NWL%proto . push = function (  )  {%NWL%this . stack . push (  { value : this . value , key : this . key , mode : this . mode }  )  ;%NWL%}  ; %NWL%proto . pop = function (  )  {%NWL%var value = this . value ; %NWL%var parent = this . stack . pop (  )  ; %NWL%this . value = parent . value ; %NWL%this . key = parent . key ; %NWL%this . mode = parent . mode ; %NWL%8
var Action = module . exports = function Action ( options )  {%NWL%options = options || {  }  ; %NWL%this . optionStrings = options . optionStrings || [  ]  ; %NWL%this . dest = options . dest ; %NWL%this . nargs = options . nargs ! =  = undefined ? options . nargs : null ; %NWL%this . constant = options . constant ! =  = undefined ? options . constant : null ; %NWL%this . defaultValue = options . defaultValue ; %NWL%this . type = options . type ! =  = undefined ? options . type : null ; %NWL%this . choices = options . choices ! =  = undefined ? options . choices : null ; %NWL%this . required = options . required ! =  = undefined ? options . required : false ; %NWL%this . help = options . help ! =  = undefined ? options . help : null ; %NWL%4
Object . keys ( this )  . forEach (  ( name )  =  >  {%NWL%if ( name in object )%NWL%this . setOption ( name , object [ name ]  )  ;%NWL%}  )  ; %NWL%this . modules = object . modules || this . modules ; %NWL%if ( typeof object . sourceMaps =  =  =  ' boolean ' ||%NWL%typeof object . sourceMaps =  =  =  ' string '  )  {%NWL%this . sourceMaps = object . sourceMaps ;%NWL%}%NWL%if ( object . sourceRoot ! =  = undefined )%NWL%this . sourceRoot = object . sourceRoot ; %NWL%7
c3_chart_internal_fn . addHiddenTargetIds = function ( targetIds )  {%NWL%this . hiddenTargetIds = this . hiddenTargetIds . concat ( targetIds )  ;%NWL%}  ; %NWL%c3_chart_internal_fn . removeHiddenTargetIds = function ( targetIds )  {%NWL%this . hiddenTargetIds = this . hiddenTargetIds . filter ( function ( id )  { return targetIds . indexOf ( id )  < 0 ;  }  )  ;%NWL%}  ; %NWL%c3_chart_internal_fn . addHiddenLegendIds = function ( targetIds )  {%NWL%this . hiddenLegendIds = this . hiddenLegendIds . concat ( targetIds )  ;%NWL%}  ; %NWL%c3_chart_internal_fn . removeHiddenLegendIds = function ( targetIds )  {%NWL%this . hiddenLegendIds = this . hiddenLegendIds . filter ( function ( id )  { return targetIds . indexOf ( id )  < 0 ;  }  )  ; %NWL%4
}%NWL%function handleMouseDown ( ev , gridpos , datapos , neighbor , plot )  {%NWL%if ( neighbor )  {%NWL%var si = neighbor . seriesIndex ; %NWL%var pi = neighbor . pointIndex ; %NWL%var ins =  [ si , pi , neighbor . data , plot . series [ si ]  . gridData [ pi ]  [ 2 ]  ]  ; %NWL%if ( plot . series [ ins [ 0 ]  ]  . highlightMouseDown && ! ( ins [ 0 ]  =  = plot . plugins . bubbleRenderer . highlightedSeriesIndex && ins [ 1 ]  =  = plot . series [ ins [ 0 ]  ]  . _highlightedPoint )  )  {%NWL%var evt = jQuery . Event (  ' jqplotDataHighlight '  )  ; %NWL%evt . which = ev . which ; %NWL%evt . pageX = ev . pageX ; %NWL%evt . pageY = ev . pageY ; %NWL%8
p . texture = gl . getUniformLocation ( p ,  " u_data "  )  ; %NWL%p . visTileWd = gl . getUniformLocation ( p ,  " u_visTileWd "  )  ; %NWL%p . visTileHt = gl . getUniformLocation ( p ,  " u_visTileHt "  )  ; %NWL%p . visibleTileWd = gl . getUniformLocation ( p ,  " u_visibleTileWd "  )  ; %NWL%p . visibleTileHt = gl . getUniformLocation ( p ,  " u_visibleTileHt "  )  ; %NWL%p . visXPos = gl . getUniformLocation ( p ,  " u_visXPos "  )  ; %NWL%p . visYPos = gl . getUniformLocation ( p ,  " u_visYPos "  )  ; %NWL%p . binCnts = gl . getUniformLocation ( p ,  " u_binCnts "  )  ; %NWL%p . xBinPixWd = gl . getUniformLocation ( p ,  " u_xBinPixWd "  )  ; %NWL%p . yBinPixWd = gl . getUniformLocation ( p ,  " u_yBinPixWd "  )  ; %NWL%p . cols = gl . getUniformLocation ( p ,  " u_cols "  )  ; %NWL%6
_proxyCheck : function ( query )  {%NWL%var index =  - 1 ; %NWL%this . _proxies . forEach ( function ( proxy , key )  {%NWL%if ( _ . isEqual ( query , proxy )  ) index = key ;%NWL%}  )  ; %NWL%return index ;%NWL%}  ,%NWL%_makeRequest : function ( $deferred , $url , $options , callback )  {%NWL%$options . debug = $options . debug || this . _debug ; %NWL%$options . cookies = $options . cookies && this . _cookies ? _ . extend (  {  }  , this . _cookies , $options . cookies )  : $options . cookies || _ . extend (  {  }  , this . _cookies )  ; %NWL%$options . headers = $options . headers && this . _headers ? _ . extend (  {  }  , this . _headers , $options . headers )  : $options . headers || _ . extend (  {  }  , this . _headers )  ; %NWL%9
$ (  ' #upload '  )  . removeClass (  ' active '  )  ;%NWL%}%NWL%}%NWL%function sketchUpload ( $event )%NWL%{%NWL%if ( $ (  ' #upload - sketch '  )  . val (  )  . length > 3 )%NWL%{%NWL%var upload_data =  {  }  ; %NWL%upload_data . name = $ (  '  . upload - info #upload - sketch '  )  . val (  )%NWL%upload_data . author = $ (  '  . upload - info #upload - author '  )  . val (  ) || undefined ; %NWL%upload_data . email = $ (  '  . upload - info #upload - email '  )  . val (  ) || undefined ; %NWL%9
}%NWL%if ( params . units )  {%NWL%GEO . units = params . units ; %NWL%radiusUnitsNode . value = GEO . units ;%NWL%}%NWL%if ( params . meters )  {%NWL%GEO . meters = parseFloat ( params . meters )  ; %NWL%if ( GEO . units =  =  =  " km "  ) radiusValueNode . value = parseInt ( GEO . meters )  / 1000 ;%NWL%}%NWL%if ( params . miles )  {%NWL%GEO . miles = parseFloat ( params . miles )  ; %NWL%6
}  )  ; %NWL%$scope . $on (  ' $stateChangeSuccess '  , function (  )  {%NWL%$scope . loading = false ; %NWL%i18nNotifications . getCurrent (  )  ;%NWL%}  )  ;%NWL%}  ]  )  ; %NWL%app . controller (  ' HeaderCtrl '  , function ( $scope , $state , security , breadcrumbs , notifications , httpRequestTracker )  {%NWL%$scope . location = $state ; %NWL%$scope . menuOpen = false ; %NWL%$scope . isAuthenticated = security . isAuthenticated ; %NWL%$scope . isAdmin = security . isAdmin ; %NWL%9
" dismax "  : 0 ,%NWL%" highlight "  : 0 ,%NWL%" only_newest_similar "  : self . groupBySimilar (  )  ,%NWL%" rows "  : 30%NWL%}  )  ;%NWL%}%NWL%self . news . $promise . then ( function ( result )  {%NWL%self . results = result . response . docs ; %NWL%self . start = result . response . docs . length ; %NWL%self . numFound = result . response . numFound ; %NWL%self . maxScore = result . response . maxScore ; %NWL%9
data . source2 = attrs . map . src ;%NWL%}%NWL%}%NWL%if ( name =  =  " img " && !data . poster )  {%NWL%data . poster = attrs . map . src ;%NWL%}%NWL%}%NWL%}  )  . parse ( html )  ; %NWL%data . source1 = data . source1 || data . src || data . data ; %NWL%data . source2 = data . source2 || '  '  ; %NWL%data . poster = data . poster || '  '  ; %NWL%9
if ( data . imagesDir )  {%NWL%this . imagesDir = this . _qualifyURL ( data . imagesDir )  ;%NWL%}%NWL%if ( data . soundsDir )  {%NWL%this . soundsDir = this . _qualifyURL ( data . soundsDir )  ;%NWL%}%NWL%if ( data . redirectUrl )  {%NWL%this . redirectUrl = data . redirectUrl ;%NWL%}%NWL%if ( data . jshintFile )  {%NWL%this . jshintFile = this . _qualifyURL ( data . jshintFile )  ; %NWL%1
get containerName (  )  {%NWL%return this . container instanceof cloudfiles . Container ? this . container . name : this . container ;%NWL%}  ,%NWL%_setProperties : function ( details )  {%NWL%this . metadata =  {  }  ; %NWL%this . container = details . container || null ; %NWL%this . name = details . name || null ; %NWL%this . etag = details . etag || null ; %NWL%this . hash = details . hash || null ; %NWL%this . bytes = details . bytes || null ; %NWL%this . local = details . local || null ; %NWL%5
this . frames . push ( frame )  ; %NWL%this . emit ( gesture . state , this )  ;%NWL%}%NWL%Gesture . prototype . translation = function (  )  {%NWL%return vec3 . subtract ( vec3 . create (  )  , this . lastGesture . startPosition , this . lastGesture . position )  ;%NWL%}%NWL%_ . extend ( Gesture . prototype , EventEmitter . prototype )  ; %NWL%var CircleGesture = function ( data )  {%NWL%this . center = data . center ; %NWL%this . normal = data . normal ; %NWL%this . progress = data . progress ; %NWL%8
}%NWL%this . dom ( this . $stage . $window )  . bindDomEvent (  ' pointermove '  , this . $moveHandler )  ; %NWL%this . dom ( this . $stage . $window )  . bindDomEvent (  ' pointerup '  , this . $upHandler )  ; %NWL%this . _updateColorAndPaletteCursor ( pos )  ; %NWL%this . _triggerColorChange (  )  ;%NWL%}  ,%NWL%_updateColorAndPaletteCursor : function ( pos )  {%NWL%pos . x = pos . x < 0 ? 0 : pos . x ; %NWL%pos . x = pos . x > this . $ . paletteSize ? this . $ . paletteSize : pos . x ; %NWL%pos . y = pos . y < 0 ? 0 : pos . y ; %NWL%pos . y = pos . y > this . $ . paletteSize ? this . $ . paletteSize : pos . y ; %NWL%8
if ( typeof settings . userAddress ! =  =  ' undefined '  )  {%NWL%this . userAddress = settings . userAddress ;%NWL%}%NWL%if ( typeof settings . href ! =  =  ' undefined '  )  {%NWL%this . href = settings . href ;%NWL%}%NWL%if ( typeof settings . storageApi ! =  =  ' undefined '  )  {%NWL%this . storageApi = settings . storageApi ;%NWL%}%NWL%if ( typeof settings . token ! =  =  ' undefined '  )  {%NWL%this . token = settings . token ; %NWL%1
generateHslGradient : function ( color , fillPattern , lumFrom , lumTo )  {%NWL%color = new Color ( color )  ; %NWL%var hsl   = color . toHsl (  )  ,%NWL%colorFrom = colorX . fromHsl ( hsl . h , hsl . s , lumFrom )  ,%NWL%colorTo  = colorX . fromHsl ( hsl . h , hsl . s , lumTo )  ; %NWL%colorFrom . a = colorTo . a = color . a ; 	 /  / add missing opacity%NWL%return Theme . generateGradient ( fillPattern , colorFrom , colorTo )  ; 	 /  / Object%NWL%}%NWL%}  )  ; %NWL%Theme . defaultMarkers = SimpleTheme . defaultMarkers ; %NWL%Theme . defaultColors = SimpleTheme . defaultColors ; %NWL%9
}%NWL%function Screen ( window , colormap , white , black , current_input_masks , width_px , height_px , width_mm , height_mm , maps_min , maps_max , root_visual , backing_stores , save_unders , root_depth , depths )  {%NWL%this . window = window || 0 ; %NWL%this . colormap = colormap || 0 ; %NWL%this . white = white || 0 ; %NWL%this . black = black || 0 ; %NWL%this . current_input_masks = current_input_masks || 0 ; %NWL%this . height_px = height_px || 0 ; %NWL%this . width_px = width_px || 0 ; %NWL%this . height_mm = height_mm || 0 ; %NWL%this . width_mm = width_mm || 0 ; %NWL%2
chartObject . subtitle_text = options . subtitle_text ; %NWL%chartObject . subtitle_size =  " subtitle_size " in options ? options . subtitle_size : stylesheet . subtitle_size ; %NWL%chartObject . subtitle_color = options . subtitle_color ? options . subtitle_color : stylesheet . subtitle_color ; %NWL%chartObject . subtitle_weight = options . subtitle_weight ? options . subtitle_weight . toLowerCase (  )  : stylesheet . subtitle_weight ; %NWL%chartObject . subtitle_family = options . subtitle_family ? options . subtitle_family . toLowerCase (  )  : stylesheet . subtitle_family ;%NWL%}%NWL%chartObject . real_time_charts_refresh_frequency = options . real_time_charts_refresh_frequency ? options . real_time_charts_refresh_frequency : functionality . real_time_charts_refresh_frequency ; %NWL%chartObject . real_time_charts_last_updated_at_enable = options . real_time_charts_last_updated_at_enable ? options . real_time_charts_last_updated_at_enable . toLowerCase (  )  : functionality . real_time_charts_last_updated_at_enable ; %NWL%if ( options . credit_my_site_name || options . credit_my_site_url )  {%NWL%chartObject . credit_my_site_name = options . credit_my_site_name ? options . credit_my_site_name :  "  "  ; %NWL%chartObject . credit_my_site_url = options . credit_my_site_url ? options . credit_my_site_url :  "  "  ; %NWL%9
this . z = snabbtjs . option_or_default ( config . z , 0 )  ; %NWL%this . bx = snabbtjs . option_or_default ( config . bx , 0 )  ; %NWL%this . by = snabbtjs . option_or_default ( config . by , 0 )  ; %NWL%this . bz = snabbtjs . option_or_default ( config . bz , 0 )  ; %NWL%this . skew_x = snabbtjs . option_or_default ( config . skew_x , 0 )  ; %NWL%this . skew_y = snabbtjs . option_or_default ( config . skew_y , 0 )  ; %NWL%this . offset_x = snabbtjs . option_or_default ( config . offset_x , 0 )  ; %NWL%this . offset_y = snabbtjs . option_or_default ( config . offset_y , 0 )  ; %NWL%this . offset_z = snabbtjs . option_or_default ( config . offset_z , 0 )  ; %NWL%this . sx = snabbtjs . option_or_default ( config . sx , 1 )  ; %NWL%this . sy = snabbtjs . option_or_default ( config . sy , 1 )  ; %NWL%9
if ( this . qhosts )  {%NWL%this . b . enableN1ql ( this . qhosts )  ;%NWL%}%NWL%this . mock = this ;%NWL%}%NWL%util . inherits ( MockHarness , Harness )  ; %NWL%function RealHarness (  )  {%NWL%Harness . call ( this )  ; %NWL%this . connstr = config . connstr ; %NWL%this . bucket = config . bucket ; %NWL%this . qhosts = config . qhosts ; %NWL%8
this . l1 . x +  = totalImpulse * this . l1x ; %NWL%this . l1 . y +  = totalImpulse * this . l1y ; %NWL%this . l1 . z +  = totalImpulse * this . l1z ; %NWL%this . a1 . x +  = totalImpulse * this . a1x ; %NWL%this . a1 . y +  = totalImpulse * this . a1y ; %NWL%this . a1 . z +  = totalImpulse * this . a1z ; %NWL%this . l2 . x -  = totalImpulse * this . l2x ; %NWL%this . l2 . y -  = totalImpulse * this . l2y ; %NWL%this . l2 . z -  = totalImpulse * this . l2z ; %NWL%this . a2 . x -  = totalImpulse * this . a2x ; %NWL%this . a2 . y -  = totalImpulse * this . a2y ; %NWL%1
if ( has (  " config - deferredInstrumentation "  ) && Error . captureStackTrace )  {%NWL%Error . captureStackTrace ( deferred , Deferred )  ; %NWL%Error . captureStackTrace ( promise , Deferred )  ;%NWL%}%NWL%this . isResolved = promise . isResolved = function (  )  {%NWL%return fulfilled =  =  = RESOLVED ;%NWL%}  ; %NWL%this . isRejected = promise . isRejected = function (  )  {%NWL%return fulfilled =  =  = REJECTED ;%NWL%}  ; %NWL%this . isFulfilled = promise . isFulfilled = function (  )  {%NWL%4
xmlRequestFrame . document . close (  )  ; %NWL%xmlRequestFrame . document . forms [ 0 ]  . action = theForm . action ; %NWL%var count = __theFormPostCollection . length ; %NWL%var element ; %NWL%for ( var i = 0 ; i < count ; i +  +  )  {%NWL%element = __theFormPostCollection [ i ]  ; %NWL%if ( element )  {%NWL%var fieldElement = xmlRequestFrame . document . createElement (  " INPUT "  )  ; %NWL%fieldElement . type =  " hidden "  ; %NWL%fieldElement . name = element . name ; %NWL%fieldElement . value = element . value ; %NWL%9
appFrameWindow : null%NWL%}  )  ; %NWL%isc . OBClassicWindow . addMethods (  {%NWL%updateTabInformation : function ( windowId , tabId , recordId , command , obManualURL , title )  {%NWL%if ( this . ignoreTabInfoUpdate )  {%NWL%this . ignoreTabInfoUpdate = false ; %NWL%return ;%NWL%}%NWL%this . windowId = windowId || '  '  ; %NWL%this . tabId = tabId || '  '  ; %NWL%this . recordId = recordId || '  '  ; %NWL%8
this . value [ 1 ]  = v1 . value [ 1 ]  * v2 . value [ 1 ]  ; %NWL%return this ;%NWL%}  ; %NWL%vector2 . prototype . multiplyScalar = function ( s )  {%NWL%this . value [ 0 ]  *  = s ; %NWL%this . value [ 1 ]  *  = s ; %NWL%return this ;%NWL%}  ,%NWL%vector2 . prototype . negate = function (  )  {%NWL%this . value [ 0 ]  =  - this . value [ 0 ]  ; %NWL%this . value [ 1 ]  =  - this . value [ 1 ]  ; %NWL%9
element . press = on ( node ,  ' touchstart '  , _press )  ; %NWL%element . move = on ( node ,  ' touchmove '  , _move )  ; %NWL%element . release = on ( node ,  ' touchend '  , _release )  ;%NWL%} else {%NWL%element . press = touch . press ( node , _press )  ; %NWL%element . move = touch . move ( node , _move )  ; %NWL%element . release = touch . release ( node , _release )  ;%NWL%}%NWL%if ( has (  " touch "  )  )  {%NWL%var _cancel = lang . hitch ( this ,  " _cancel "  , element )  ; %NWL%element . cancel = on ( node ,  ' touchcancel '  , _cancel )  ; %NWL%1
function ExchangeAggregation ( options )  {%NWL%var self  = this ; %NWL%var logOpts =  {%NWL%scope :  ' exchange - aggregation '  ,%NWL%file  : options . logFile ,%NWL%level : options . logLevel%NWL%}  ; %NWL%this . hbase  = options . hbase ; %NWL%this . log   = new Logger ( logOpts )  ; %NWL%this . base  = options . base ; %NWL%this . counter  = options . counter ; %NWL%7
this . instance . orderInFrontOf ( win . instance ? win . instance : win )  ;%NWL%}  ,%NWL%sendToBack : function (  )  {%NWL%this . instance . orderToBack (  )  ;%NWL%}  ,%NWL%sendBehind : function ( win )  {%NWL%this . instance . orderInBackOf ( win . instance ? win . instance : win )  ;%NWL%}  ,%NWL%resize : function ( width , height )  {%NWL%this . width = this . instance . width = width ; %NWL%this . height = this . instance . height = height ; %NWL%9
Virtual . track = function ( model , event )  {%NWL%var _ref ; %NWL%return ( _ref = Backbone . Virtual . _dependencies ) ! = null ? _ref . push (  {%NWL%model : model ,%NWL%event : event%NWL%}  )  : void 0 ;%NWL%}  ; %NWL%function Virtual ( options )  {%NWL%this . remove = __bind ( this . remove , this )  ; %NWL%this . add = __bind ( this . add , this )  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%8
exports . shallow = base . shallow ; %NWL%exports . clone = base . clone ; %NWL%exports . mkhash = base . mkhash ; %NWL%exports . forEach = base . forEach ; %NWL%exports . cache = cache . cache ; %NWL%exports . lock = lock . lock ; %NWL%exports . async = async ; %NWL%exports . populateConfig = cfg . populateConfig ; %NWL%exports . baseConfig = cfg . baseConfig ; %NWL%exports . b64encode = b64 . b64encode ; %NWL%exports . b64decode = b64 . b64decode ; %NWL%9
lodash . identity = utilities . identity ; %NWL%lodash . indexOf = arrays . indexOf ; %NWL%lodash . isArguments = objects . isArguments ; %NWL%lodash . isArray = isArray ; %NWL%lodash . isBoolean = objects . isBoolean ; %NWL%lodash . isDate = objects . isDate ; %NWL%lodash . isElement = objects . isElement ; %NWL%lodash . isEmpty = objects . isEmpty ; %NWL%lodash . isEqual = objects . isEqual ; %NWL%lodash . isFinite = objects . isFinite ; %NWL%lodash . isFunction = objects . isFunction ; %NWL%2
}%NWL%}  ,%NWL%onMouseUp : function ( e )  {%NWL%dojox . layout . dnd . PlottedDnd . superclass . onMouseUp . call ( this , e )  ; %NWL%this . containerSource = false ; %NWL%if ( !dojo . isIE && this . mouseDown )  {%NWL%this . setDndItemSelectable ( e . target , true )  ;%NWL%}%NWL%var m = dojo . dnd . manager (  )  ; %NWL%m . OFFSET_X = this . GC_OFFSET_X ; %NWL%m . OFFSET_Y = this . GC_OFFSET_Y ; %NWL%9
defaults :  {%NWL%metric : null ,%NWL%base : null ,%NWL%clock : null%NWL%}  ,%NWL%init : function ( options )  {%NWL%this . config = _ . extend (  {  }  , this . defaults , options )  ; %NWL%this . metric = this . config . metric ; %NWL%this . base = this . config . base ; %NWL%this . clock = this . config . clock ; %NWL%this . collection = this . config . collection ; %NWL%7
name = name +  '  '  ; %NWL%return Path . join ( this . namePrefix , name )  + this . nameSuffix ;%NWL%}%NWL%}  ; %NWL%function LocalFileStore ( options )  {%NWL%if ( !options . root )  {%NWL%throw ' LocalFileStore Error : expected root '  ;%NWL%}%NWL%this . root = options . root ; %NWL%if ( options . namePrefix )  {%NWL%this . namePrefix = options . namePrefix ; %NWL%8
}%NWL%}  ; %NWL%function wrapSharedExpression ( exprFn )  {%NWL%var wrapped = exprFn ; %NWL%if ( wrapped . sharedGetter )  {%NWL%wrapped = function ( self , locals )  {%NWL%return exprFn ( self , locals )  ;%NWL%}  ; %NWL%wrapped . constant = exprFn . constant ; %NWL%wrapped . literal = exprFn . literal ; %NWL%wrapped . assign = exprFn . assign ; %NWL%8
}  ; %NWL%Agent . prototype . fillFromAgent = function ( d )  {%NWL%var call , msg , _i , _len , _ref , _results ; %NWL%this . setName ( d . name )  ; %NWL%this . setState ( d . state )  ; %NWL%this . setStatus ( d . status )  ; %NWL%this . setUsername ( d . username )  ; %NWL%this . setExtension ( d . extension )  ; %NWL%this . busy_delay_time = d . busy_delay_time ; %NWL%this . class_answered = d . class_answered ; %NWL%this . contact = d . contact ; %NWL%8
}  ,%NWL%set y ( y )  {%NWL%centerPos . y = y ; %NWL%dirty = true ;%NWL%}  ,%NWL%get y (  )  {%NWL%return centerPos . y ;%NWL%}  ,%NWL%set pos ( pos )  {%NWL%centerPos . x = pos . x ; %NWL%centerPos . y = pos . y ; %NWL%9
exports . ScrollToTopBehavior = require (  "  .  / behaviors / ScrollToTopBehavior "  )  ; %NWL%exports . History = require (  "  .  / History "  )  ; %NWL%exports . Navigation = require (  "  .  / Navigation "  )  ; %NWL%exports . State = require (  "  .  / State "  )  ; %NWL%exports . createRoute = require (  "  .  / Route "  )  . createRoute ; %NWL%exports . createDefaultRoute = require (  "  .  / Route "  )  . createDefaultRoute ; %NWL%exports . createNotFoundRoute = require (  "  .  / Route "  )  . createNotFoundRoute ; %NWL%exports . createRedirect = require (  "  .  / Route "  )  . createRedirect ; %NWL%exports . createRoutesFromReactChildren = require (  "  .  / createRoutesFromReactChildren "  )  ; %NWL%exports . create = require (  "  .  / createRouter "  )  ; %NWL%exports . run = require (  "  .  / runRouter "  )  ; %NWL%9
function normalizeTolerance ( t )  {%NWL%return t =  =  = Object ( t ) ? t :  { down : t , up : t }  ;%NWL%}%NWL%function Headroom ( elem , options )  {%NWL%options = extend ( options , Headroom . options )  ; %NWL%this . lastKnownScrollY = 0 ; %NWL%this . elem    = elem ; %NWL%this . debouncer   = new Debouncer ( this . update . bind ( this )  )  ; %NWL%this . tolerance   = normalizeTolerance ( options . tolerance )  ; %NWL%this . classes    = options . classes ; %NWL%this . offset    = options . offset ; %NWL%9
}%NWL%this . preloadImg = img ;%NWL%}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . forms [ 0 ]  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%9
getValue : function (  )  {%NWL%if ( this . disabledByDependency || this . parentJFormSection . disabledByDependency )  {%NWL%return null ;%NWL%}%NWL%var address =  {  }  ,%NWL%self = this ; %NWL%address . addressLine1 = self . component . find (  '  : input [ id *  = addressLine1 ]  '  )  . val (  )  ; %NWL%address . addressLine2 = self . component . find (  '  : input [ id *  = addressLine2 ]  '  )  . val (  )  ; %NWL%address . city = self . component . find (  '  : input [ id *  = city ]  '  )  . val (  )  ; %NWL%address . state = self . component . find (  '  : input [ id *  = state ]  '  )  . val (  )  ; %NWL%address . zip = self . component . find (  '  : input [ id *  = zip ]  '  )  . val (  )  ; %NWL%6
}  )  ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%readSettingsResult = function ( result )  {%NWL%var settings =  {  }  ; %NWL%return when ( _ . map ( result . models , function ( member )  {%NWL%if ( !settings . hasOwnProperty ( member . attributes . key )  )  {%NWL%var val =  {  }  ; %NWL%val . value = member . attributes . value ; %NWL%val . type = member . attributes . type ; %NWL%9
var Node = require ( __dirname )  ; %NWL%module . exports = Node . define (  {%NWL%type :  ' COLUMN '  ,%NWL%constructor : function ( config )  {%NWL%Node . call ( this )  ; %NWL%this . name = config . name ; %NWL%this . property = config . property || config . name ; %NWL%this . alias = config . alias ; %NWL%this . star = config . star ; %NWL%this . asArray = config . asArray ; %NWL%this . aggregator = config . aggregator ; %NWL%5
markerFill : 			 {  }  ,%NWL%markerFont : 			 "  "  ,%NWL%markerFontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = dojo . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%this . animate = this . opt . animate ; %NWL%8
} else {%NWL%delete form_data [ field ]  ;%NWL%}%NWL%}%NWL%}%NWL%if ( !has_constraints )  {%NWL%alert (  " Please add at least one constraint before querying! "  )  ; %NWL%return ;%NWL%}%NWL%form_data . display_start = this . display_start ; %NWL%form_data . display_length = this . display_length ; %NWL%9
if ( hints . video =  =  = true )  {%NWL%hints . video = defaultConstraints ;%NWL%}%NWL%if ( hints . audio =  =  = true )  {%NWL%hints . audio = defaultConstraints ;%NWL%}%NWL%if ( typeof audioConstraints =  =  =  ' boolean ' && hints . audio )  {%NWL%hints . audio = audioConstraints ;%NWL%}%NWL%if ( typeof videoConstraints =  =  =  ' boolean ' && hints . video )  {%NWL%hints . video = videoConstraints ; %NWL%7
preProcessTags ,%NWL%preProcessUsers ; %NWL%replaceImage = function ( markdown , image )  {%NWL%var regex = new RegExp (  '  (  /  ) ? '  + image . originalPath ,  ' gm '  )  ; %NWL%return markdown . replace ( regex , image . newPath )  ;%NWL%}  ; %NWL%preProcessPosts = function ( data , image )  {%NWL%_ . each ( data . posts , function ( post )  {%NWL%post . markdown = replaceImage ( post . markdown , image )  ; %NWL%if ( post . html )  {%NWL%post . html = replaceImage ( post . html , image )  ; %NWL%8
client_credentials : clientCredentialsGrant ,%NWL%password : passwordCredentialsGrant ,%NWL%authorization_code : authorizationCodeGrant%NWL%}  ; %NWL%function OAuth ( spi , options )  {%NWL%options = _ . extend (  {  }  , applyModuleDefaults ( options )  )  ; %NWL%this . spi = spi ; %NWL%this . validGrantTypes = options . validGrantTypes ; %NWL%this . tokenLifetime = options . tokenLifetime ; %NWL%this . passwordCheck = options . passwordCheck ; %NWL%this . beforeCreateToken = options . beforeCreateToken ; %NWL%7
}%NWL%bb10_utils . exec ( cmd , args , options , function ( error , stdout , stderr )  {%NWL%var err = error ,%NWL%result =  {  }  ,%NWL%name =  / modelname :  :  (  .  * ? )  ( \r? ) \n /  . exec ( stdout )  ,%NWL%pin =  / devicepin :  : 0x (  .  * ? )  ( \r? ) \n /  . exec ( stdout )  ; %NWL%if ( name && name . length > 0 )  {%NWL%result . name = name [ 1 ]  ;%NWL%}%NWL%if ( pin && pin . length > 0 )  {%NWL%result . pin = pin [ 1 ]  ; %NWL%7
return proxyResult%NWL%}  ,%NWL%_initNode = function ( setting , level , n , parentNode , isFirstNode , isLastNode , openFlag )  {%NWL%if ( !n ) return ; %NWL%var checkedKey = setting . data . key . checked ; %NWL%if ( typeof n [ checkedKey ]  =  =  " string "  ) n [ checkedKey ]  = tools . eqs ( n [ checkedKey ]  ,  " true "  )  ; %NWL%n [ checkedKey ]  = !!n [ checkedKey ]  ; %NWL%n . checkedOld = n [ checkedKey ]  ; %NWL%if ( typeof n . nocheck =  =  " string "  ) n . nocheck = tools . eqs ( n . nocheck ,  " true "  )  ; %NWL%n . nocheck = !!n . nocheck || ( setting . check . nocheckInherit && parentNode && !!parentNode . nocheck )  ; %NWL%if ( typeof n . chkDisabled =  =  " string "  ) n . chkDisabled = tools . eqs ( n . chkDisabled ,  " true "  )  ; %NWL%8
Random . integer = function integer ( min , max , dim )  {%NWL%min =  ( min ! =  = undefined ) ? min : 0 ; %NWL%max =  ( max ! =  = undefined ) ? max : 1 ; %NWL%if ( dim ! =  = undefined )  {%NWL%var result =  [  ]  ; %NWL%for ( var i = 0 ; i < dim ; i +  +  ) result . push ( _randomInteger ( min , max )  )  ; %NWL%return result ;%NWL%}%NWL%else return _randomInteger ( min , max )  ;%NWL%}  ; %NWL%Random . range = function range ( min , max , dim )  {%NWL%0
this . lastTouchIdentifier = 0 ; %NWL%this . touchBoundary = 10 ; %NWL%this . layer = layer ; %NWL%if ( !layer || !layer . nodeType )  {%NWL%throw new TypeError (  ' Layer must be a document node '  )  ;%NWL%}%NWL%this . onClick = function (  )  { return FastClick . prototype . onClick . apply ( self , arguments )  ;  }  ; %NWL%this . onMouse = function (  )  { return FastClick . prototype . onMouse . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchStart = function (  )  { return FastClick . prototype . onTouchStart . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchMove = function (  )  { return FastClick . prototype . onTouchMove . apply ( self , arguments )  ;  }  ; %NWL%this . onTouchEnd = function (  )  { return FastClick . prototype . onTouchEnd . apply ( self , arguments )  ;  }  ; %NWL%6
this . container . setAttribute (  ' class '  , this . container . normal )  ; %NWL%this . setAttribute (  ' class '  , this . normal )  ;%NWL%}  ; %NWL%outerElement . enable = outerElement . enable . bind ( outerElement )  ; %NWL%outerElement . disable = function (  )  {%NWL%if ( this . disabled ) return ; %NWL%this . disabled = true ; %NWL%this . container . setAttribute (  ' class '  , this . container . normal +  ' bb - bb10 - input - container - disabled '  )  ; %NWL%this . setAttribute (  ' class '  , this . normal +  ' bb - bb10 - input - disabled '  )  ;%NWL%}  ; %NWL%outerElement . disable = outerElement . disable . bind ( outerElement )  ; %NWL%3
return self%NWL%}%NWL%, fail : function ( fn )  {%NWL%var self = this%NWL%self . _fail = self . _fail || [  ]%NWL%self . _fail . push ( fn )%NWL%return self%NWL%}%NWL%, always : function ( fn )  {%NWL%var self = this%NWL%self . _always = self . _always || [  ]%NWL%4
}%NWL%localStorage . tlds = JSON . stringify ( tlds )  ;%NWL%}%NWL%)  ;%NWL%}  )  ; %NWL%$ . getJSON (  '  .  .  / data / trackers . json '  , function ( data )  {%NWL%var siteCount = data . length ; %NWL%var servicesUpdate =  {  }  ; %NWL%for ( var i = 0 ; i < siteCount ; i +  +  ) servicesUpdate [ data [ i ]  . domain ]  = true ; %NWL%services = servicesUpdate ; %NWL%localStorage . services = JSON . stringify ( services )  ; %NWL%1
if ( this . root_ . key =  = key )  {%NWL%return ;%NWL%}%NWL%var node = new SplayTree . Node ( key , value )  ; %NWL%if ( key > this . root_ . key )  {%NWL%node . left = this . root_ ; %NWL%node . right = this . root_ . right ; %NWL%this . root_ . right = null ;%NWL%} else {%NWL%node . right = this . root_ ; %NWL%node . left = this . root_ . left ; %NWL%6
return new Tabletop ( options )  ;%NWL%}%NWL%if ( typeof ( options )  =  =  =  ' string '  )  {%NWL%options =  { key : options }  ;%NWL%}%NWL%this . callback = options . callback ; %NWL%this . wanted = options . wanted || [  ]  ; %NWL%this . key = options . key ; %NWL%this . simpleSheet = !!options . simpleSheet ; %NWL%this . parseNumbers = !!options . parseNumbers ; %NWL%this . wait = !!options . wait ; %NWL%8
self . paragraph = parent =  =  = undefined ? undefined : parent . paragraph ; %NWL%e = styleParseUtils . getPropertiesElement (  " paragraph - properties "  , element , e )  ; %NWL%if ( e ! =  = null )  {%NWL%self . paragraph = new odf . ParagraphProperties ( e , styleParseUtils ,%NWL%self . paragraph )  ;%NWL%}%NWL%}%NWL%if ( family =  =  =  " text " || family =  =  =  " paragraph "%NWL%|| family =  =  =  " table - cell " || family =  =  =  " graphic "%NWL%|| family =  =  =  " presentation " || family =  =  =  " chart "  )  {%NWL%self . text = parent =  =  = undefined ? undefined : parent . text ; %NWL%0
$addEntity :  [  ' $entity '  , function ( $entity )  {%NWL%if ( !$entity . ng2D )  {%NWL%$entity . $add (  ' ng2D '  )  ;%NWL%}%NWL%}  ]  ,%NWL%$update :  [  ' $entity '  ,  ' ng2DViewPort '  , function ( $entity , ng2DViewPort )  {%NWL%var ng3D = $entity . ng3D ; %NWL%var ng2D = $entity . ng2D ; %NWL%var basis = $entity . ngParallax . basis ; %NWL%ng2D . x = ng2DViewPort . lookAt . x + basis *  ( ng3D . x - ng2DViewPort . lookAt . x )  ; %NWL%ng2D . y = ng2DViewPort . lookAt . y + basis *  ( ng3D . y - ng2DViewPort . lookAt . y )  ; %NWL%9
res . jsonp ( poll )  ;%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%exports . update = function ( req , res )  {%NWL%console . log (  ' req . body '  , req . body )  ; %NWL%Poll . findById ( req . body . _id )  . populate (  ' choices invitees '  )  . exec ( function ( err , thisPoll )  {%NWL%thisPoll . name = req . body . name ; %NWL%thisPoll . updated = new Date (  )  ; %NWL%thisPoll . eventDate = req . body . eventDate ; %NWL%thisPoll . location = req . body . location ; %NWL%7
var Collision = require (  '  .  .  / symbol / collision_tile '  )  ; %NWL%var BufferSet = require (  '  .  .  / data / buffer / buffer_set '  )  ; %NWL%var createBucket = require (  '  .  .  / data / create_bucket '  )  ; %NWL%module . exports = WorkerTile ; %NWL%function WorkerTile ( params )  {%NWL%this . id = params . id ; %NWL%this . uid = params . uid ; %NWL%this . zoom = params . zoom ; %NWL%this . maxZoom = params . maxZoom ; %NWL%this . tileSize = params . tileSize ; %NWL%this . source = params . source ; %NWL%5
proto . scale = function ( scale )  {   /  / cc . kmQuaternionScale%NWL%this . x *  = scale ; %NWL%this . y *  = scale ; %NWL%this . z *  = scale ; %NWL%this . w *  = scale ; %NWL%return this ;%NWL%}  ; %NWL%proto . assignFrom = function ( quaternion )  {   /  /  = cc . kmQuaternionAssign%NWL%this . x = quaternion . x ; %NWL%this . y = quaternion . y ; %NWL%this . z = quaternion . z ; %NWL%8
dojo . require (  " dojox . dtl . _Templated "  )  ; %NWL%dojo . require (  " dijit . _Widget "  )  ; %NWL%dojo . declare (  " dojox . data . demos . widgets . FlickrViewList "  ,%NWL%[ dijit . _Widget , dojox . dtl . _Templated ]  ,%NWL%{%NWL%store : null ,%NWL%items : null ,%NWL%templateString : dojo . cache (  " dojox "  ,  " data / demos / widgets / templates / FlickrViewList . html "  )  ,%NWL%fetch : function ( request )  {%NWL%request . onComplete = dojo . hitch ( this ,  " onComplete "  )  ; %NWL%request . onError = dojo . hitch ( this ,  " onError "  )  ; %NWL%9
if ( !mediaStream ) throw ' MediaStream is mandatory .  '  ; %NWL%this . start = function ( timeSlice )  {%NWL%var Recorder = IsChrome ? window . StereoRecorder : window . MediaRecorderWrapper ; %NWL%if ( this . mimeType . indexOf (  ' video '  ) ! =  - 1 )  {%NWL%Recorder = IsChrome ? window . WhammyRecorder : window . MediaRecorderWrapper ;%NWL%}%NWL%if ( this . mimeType =  =  =  ' image / gif '  ) Recorder = window . GifRecorder ; %NWL%mediaRecorder = new Recorder ( mediaStream )  ; %NWL%mediaRecorder . ondataavailable = this . ondataavailable ; %NWL%mediaRecorder . onstop = this . onstop ; %NWL%mediaRecorder . onStartedDrawingNonBlankFrames = this . onStartedDrawingNonBlankFrames ; %NWL%8
}%NWL%}  ,%NWL%configureAttribute : function ( key , map , init )  {%NWL%this . setAttributeConfig ( key , map , init )  ;%NWL%}  ,%NWL%resetAttributeConfig : function ( key )  {%NWL%this . _configs = this . _configs || {  }  ; %NWL%this . _configs [ key ]  . resetConfig (  )  ;%NWL%}  ,%NWL%subscribe : function ( type , callback )  {%NWL%this . _events = this . _events || {  }  ; %NWL%6
} else if ( element . attachEvent )  {%NWL%if ( element [ eventName ]  )  {%NWL%return element [ eventName ]  +  +  ;%NWL%}%NWL%} else {%NWL%throw new Error (  " Attempt to fire custom event "  + eventName +  " on something which isn ' t a DOMElement "  )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%__customevents . bind = CustomEvents . bind ; %NWL%__customevents . fire = CustomEvents . fire ; %NWL%9
chart . y = function ( _ )  {%NWL%if ( !arguments . length ) return lines . y ; %NWL%lines . y ( _ )  ; %NWL%lines2 . y ( _ )  ; %NWL%return chart ;%NWL%}  ; %NWL%chart . margin = function ( _ )  {%NWL%if ( !arguments . length ) return margin ; %NWL%margin . top = typeof _ . top ! =  ' undefined ' ? _ . top : margin . top ; %NWL%margin . right = typeof _ . right ! =  ' undefined ' ? _ . right : margin . right ; %NWL%margin . bottom = typeof _ . bottom ! =  ' undefined ' ? _ . bottom : margin . bottom ; %NWL%8
_browser . ie = false ; %NWL%_browser . safari = Object . prototype . toString . call ( window . HTMLElement )  . indexOf (  ' Constructor '  )  > 0 ; %NWL%_browser . supported =  ( _browser . chrome || _browser . ff || _browser . opera )  ; %NWL%var _queue =  [  ]  ; %NWL%_readyCb = function (  )  {%NWL%}  ; %NWL%_ready = _stop = false ; %NWL%var init = function (  )  {%NWL%_opt = merge ( _def , opt )  ; %NWL%_opt . bgColor = hexToRgb ( _opt . bgColor )  ; %NWL%_opt . textColor = hexToRgb ( _opt . textColor )  ; %NWL%9
o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%o2 . strokeStyle  = o1 . strokeStyle ; %NWL%o2 . globalAlpha  = o1 . globalAlpha ; %NWL%0
var distance = param . distance || 0 ; %NWL%var distsquared = distance * distance ; %NWL%planetGroup . position . set ( Math . sqrt ( distsquared / 2 )  , 0 ,  - Math . sqrt ( distsquared / 2 )  )  ; %NWL%planetOrbitGroup . add ( planetGroup )  ; %NWL%this . planetGroup = planetGroup ; %NWL%var size = param . size || 1 ; %NWL%this . planetGroup . scale . set ( size , size , size )  ; %NWL%var map = param . map ; %NWL%this . createGlobe ( map )  ; %NWL%this . animateOrbit = param . animateOrbit ; %NWL%this . period = param . period ; %NWL%9
this . maxX = maxX || 0 ; %NWL%this . minY = minY || 0 ; %NWL%this . maxY = maxY || 0 ; %NWL%this . minZ = minZ || 0 ; %NWL%this . maxZ = maxZ || 0 ; %NWL%this . parent = null ;%NWL%}  ; %NWL%OIMO . Proxy . prototype =  {%NWL%constructor : OIMO . Proxy ,%NWL%init : function ( minX , maxX , minY , maxY , minZ , maxZ )  {%NWL%this . minX = minX || 0 ; %NWL%0
( function (  )  {%NWL%function create ( window )  {%NWL%if ( window =  = null )  {%NWL%window = require (  ' jsdom '  )  . jsdom (  )  . createWindow (  )  ; %NWL%window . XMLHttpRequest = require (  " xmlhttprequest "  )  . XMLHttpRequest ; %NWL%window . XMLHttpRequest . prototype . withCredentials = false ; %NWL%if ( window . location =  = null )  {%NWL%window . location = require (  ' location '  )  ;%NWL%}%NWL%if ( window . navigator =  = null )  {%NWL%window . navigator = require (  ' navigator '  )  ; %NWL%7
var params = this . params ; %NWL%this . drug = params . drug ; %NWL%this . dose = params . dose ; %NWL%this . doseUnit = params . doseUnit ; %NWL%this . strength = params . strength ; %NWL%this . strengthUnit = params . strengthUnit ; %NWL%this . route = params . route ; %NWL%this . frequency = params . frequency|| "  "  ; %NWL%this . instructions = params . notes || "  "  ; %NWL%this . cui = params . cui ; %NWL%this . rdf = params . rdf ; %NWL%1
air . DockIcon = window . runtime . flash . desktop . DockIcon ; %NWL%air . InteractiveIcon = window . runtime . flash . desktop . InteractiveIcon ; %NWL%air . NotificationType = window . runtime . flash . desktop . NotificationType ; %NWL%air . SystemTrayIcon = window . runtime . flash . desktop . SystemTrayIcon ; %NWL%air . NativeApplication = window . runtime . flash . desktop . NativeApplication ; %NWL%air . NativeMenu = window . runtime . flash . display . NativeMenu ; %NWL%air . NativeMenuItem = window . runtime . flash . display . NativeMenuItem ; %NWL%air . Screen = window . runtime . flash . display . Screen ; %NWL%air . Loader  = window . runtime . flash . display . Loader ; %NWL%air . Bitmap = window . runtime . flash . display . Bitmap ; %NWL%air . BitmapData = window . runtime . flash . display . BitmapData ; %NWL%5
return compoundColumn ( parents . concat ( this . getDbKey (  )  )  )  ;%NWL%}  ; %NWL%exports . inheritBase = function ( Type , filename )  {%NWL%util . inherits ( Type , DBBase )  ; %NWL%Type . _name = Type . meta . name ; %NWL%Type . _filename = filename ; %NWL%Type . _lookupByName = Type . meta . hasOwnProperty (  ' lookupByName '  ) ? Type . meta . lookupByName : false ; %NWL%Type . prefix = function (  )  { return Type . meta . prefix ;  }  ; %NWL%Type . dataPrefix = function (  )  { return Type . meta . dataPrefix || '  '  ;  }  ; %NWL%Type . getCanonicalName = function (  )  { return Type . meta . cname ;  }  ; %NWL%Type . parents = function (  )  { return Type . meta . parents ;  }  ; %NWL%7
}  )  ;%NWL%}  )  ; %NWL%var T = !!graph . getNode ( this . root )  . visited ; %NWL%graph . eachNode ( function ( node )  {%NWL%node . eachAdjacency ( function ( adj )  {%NWL%var nodeTo = adj . nodeTo ; %NWL%if ( !!nodeTo . visited =  =  = T )  {%NWL%$ . each ( property , function ( p )  {%NWL%var vp = node . getPos ( p )  , up = nodeTo . getPos ( p )  ; %NWL%dpos . x = vp . x - up . x ; %NWL%dpos . y = vp . y - up . y ; %NWL%9
sCurrentController :  '  '  ,%NWL%sCurrentAction :  '  '%NWL%}  ; %NWL%GCore = function ( oParams )  {%NWL%GCore . p_oParams = oParams ; %NWL%GCore . DESIGN_PATH = GCore . p_oParams . sDesignPath ; %NWL%GCore . iActiveView = GCore . p_oParams . iActiveView ; %NWL%GCore . aoViews = GCore . p_oParams . aoViews ; %NWL%GCore . iActiveLanguage = GCore . p_oParams . iActiveLanguage ; %NWL%GCore . aoLanguages = GCore . p_oParams . aoLanguages ; %NWL%GCore . aoVatValues = GCore . p_oParams . aoVatValues ; %NWL%6
this . proximityUUID +  =  '  -  '  ; %NWL%this . proximityUUID +  = this . iBeaconID . substring ( 20 , 32 )  ; %NWL%this . major = BC . Tools . ConvertHexStringToInt ( this . iBeaconID . substring ( 32 , 36 )  )  ; %NWL%this . minor = BC . Tools . ConvertHexStringToInt ( this . iBeaconID . substring ( 36 , 40 )  )  ; %NWL%this . txPower = arg . txPower ; %NWL%this . proximity =  - 1 ; %NWL%if ( isEmpty ( arg . accuracy )  )  {%NWL%this . calculateAccuracy (  )  ;%NWL%} else {%NWL%this . accuracy = arg . accuracy ; %NWL%this . proximity = arg . proximity ; %NWL%4
max_health : 0 ,%NWL%health : 0 ,%NWL%level : 1%NWL%}  ; %NWL%self . affects =  {%NWL%}  ; %NWL%self . init = function ( config )%NWL%{%NWL%self . short_description = config . short_description || '  '  ; %NWL%self . keywords    = config . keywords || [  ]  ; %NWL%self . description   = config . description || '  '  ; %NWL%8
json . maxLife = this . maxLife ; %NWL%json . minSize = this . minSize ; %NWL%json . maxSize = this . maxSize ; %NWL%json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%0
}%NWL%sprite . mousedown = sprite . touchstart = function ( data )  {%NWL%var point =  { x : 0 , y : 0 }  ; %NWL%point . x = data . global . x - this . position . x ; %NWL%point . y = data . global . y - this . position . y ; %NWL%this . handlePointerDown ( point )  ; %NWL%return ;%NWL%}%NWL%sprite . mouseup = sprite . touchend = sprite . mouseupoutside = sprite . touchendoutside = function ( data )  {%NWL%var point =  { x : 0 , y : 0 }  ; %NWL%point . x = data . global . x - this . position . x ; %NWL%4
if ( o . type =  =  =  " onplotreset "  )  {%NWL%delete this . angles ;%NWL%}%NWL%return ;%NWL%}%NWL%if ( !o . shape || o . type ! =  =  " onmouseover "  )  { return ;  }%NWL%var aroundRect =  { type :  " rect "  }  , position =  [  " after "  ,  " before "  ]  ; %NWL%switch ( o . element )  {%NWL%case " marker "  : %NWL%aroundRect . x = o . cx ; %NWL%aroundRect . y = o . cy ; %NWL%9
var tpos = this . transformPoint ( actor . org_x + this . x , actor . org_y + this . y )  ; %NWL%actor . x = tpos . x ; %NWL%actor . y = tpos . y ;%NWL%}%NWL%else%NWL%{%NWL%actor . x = actor . org_x ; %NWL%actor . y = actor . org_y ;%NWL%}%NWL%actor . rotation = actor . org_rotation ; %NWL%actor . scale_x = actor . org_scale_x ; %NWL%6
else%NWL%{%NWL%this . onLoaded (  )  ;%NWL%}%NWL%}  ; %NWL%proto . onLoaded = function onLoaded (  )%NWL%{%NWL%this . loaded = true ; %NWL%this . dispatchEvent (  { type :  ' loaded '  , content : this }  )  ;%NWL%}  ; %NWL%proto . onError = function onError (  )%NWL%5
cc . _addEventListener ( w , _deviceEventType , _t . didAccelerate . bind ( _t )  , false )  ;%NWL%}  ; %NWL%_p . didAccelerate = function ( eventData )  {%NWL%var _t = this , w = window ; %NWL%if ( !_t . _accelEnabled )%NWL%return ; %NWL%var mAcceleration = _t . _acceleration ; %NWL%if ( _t . _accelDeviceEvent =  = window . DeviceMotionEvent )  {%NWL%var eventAcceleration = eventData [  " accelerationIncludingGravity "  ]  ; %NWL%mAcceleration . x = _t . _accelMinus * eventAcceleration . x * 0 . 1 ; %NWL%mAcceleration . y = _t . _accelMinus * eventAcceleration . y * 0 . 1 ; %NWL%9
lodash . select = collections . filter ; %NWL%lodash . tail = arrays . rest ; %NWL%lodash . unique = arrays . uniq ; %NWL%lodash . unzip = arrays . zip ; %NWL%mixin ( lodash )  ; %NWL%lodash . clone = objects . clone ; %NWL%lodash . cloneDeep = objects . cloneDeep ; %NWL%lodash . contains = collections . contains ; %NWL%lodash . escape = utilities . escape ; %NWL%lodash . every = collections . every ; %NWL%lodash . find = collections . find ; %NWL%7
beforeCreateToken : function ( hash , options , cb )  { cb (  )  ;  }%NWL%}  ; %NWL%function applyModuleDefaults ( options )  {%NWL%if ( !options )  {%NWL%return DefaultOptions ;%NWL%}%NWL%if ( !options . validGrantTypes )  {%NWL%options . validGrantTypes = DefaultOptions . validGrantTypes ;%NWL%}%NWL%if ( !options . beforeCreateToken )  {%NWL%options . beforeCreateToken = DefaultOptions . beforeCreateToken ; %NWL%7
}%NWL%return config ;%NWL%}  ,%NWL%_getRoot = function ( node , subscriber )  {%NWL%return subscriber . _extra . root || ( node . get ( NODE_TYPE )  =  =  = 9 ) ? node : node . get ( OWNER_DOCUMENT )  ;%NWL%}  ,%NWL%_normTouchFacade = function ( touchFacade , touch , params )  {%NWL%touchFacade . pageX = touch . pageX ; %NWL%touchFacade . pageY = touch . pageY ; %NWL%touchFacade . screenX = touch . screenX ; %NWL%touchFacade . screenY = touch . screenY ; %NWL%7
for ( var i = 0 ; i < _filterChain . length ; i +  +  )  {%NWL%_lastInChain =  ( i =  = _filterChain . length - 1 )  ; %NWL%var f = _filterChain [ i ]  ; %NWL%f . func . apply ( this , f . args || [  ]  )  ;%NWL%}%NWL%return _canvas ;%NWL%}  ; %NWL%var _resize = function ( width , height )  {%NWL%if ( width =  = _width && height =  = _height )  { return ;  }%NWL%_canvas . width = _width = width ; %NWL%_canvas . height = _height = height ; %NWL%9
}  ; %NWL%DocumentContext . prototype . completeColumnGroup = function (  )  {%NWL%var saved = this . snapshots . pop (  )  ; %NWL%this . calculateBottomMost ( saved )  ; %NWL%this . endingCell = null ; %NWL%this . x = saved . x ; %NWL%this . y = saved . bottomMost . y ; %NWL%this . page = saved . bottomMost . page ; %NWL%this . availableWidth = saved . availableWidth ; %NWL%this . availableHeight = saved . bottomMost . availableHeight ; %NWL%this . lastColumnWidth = saved . lastColumnWidth ; %NWL%5
for ( var i = this . tryEntries . length - 1 ; i >  = 0 ;  -  - i )  {%NWL%var entry = this . tryEntries [ i ]  ; %NWL%if ( entry . finallyLoc =  =  = finallyLoc )  {%NWL%return this . complete ( entry . completion , entry . afterLoc )  ;%NWL%}%NWL%}%NWL%}  ,%NWL%" catch "  : function ( tryLoc )  {%NWL%for ( var i = this . tryEntries . length - 1 ; i >  = 0 ;  -  - i )  {%NWL%var entry = this . tryEntries [ i ]  ; %NWL%if ( entry . tryLoc =  =  = tryLoc )  {%NWL%2
if ( humanNameService . getAll (  )  . length =  =  = 0 )  {%NWL%logError (  " Person must have at least one name entry .  "  )  ; %NWL%return ;%NWL%}%NWL%toggleSpinner ( true )  ; %NWL%person . address = addressService . mapFromViewModel (  )  [ 0 ]  ; %NWL%person . identifier = identifierService . getAll (  )  ; %NWL%person . name = humanNameService . mapFromViewModel (  )  [ 0 ]  ; %NWL%person . patient = vm . person . patient ; %NWL%person . photo = attachmentService . getAll (  )  ; %NWL%person . relationship = vm . person . relationship ; %NWL%8
}  )  ; %NWL%line . appendChild ( button . domNode )  ; %NWL%dialog . containerNode . appendChild ( line )  ; %NWL%dialog . startup (  )  ; %NWL%return dialog ;%NWL%}  ,%NWL%makeUserStore : function ( callback )  {%NWL%lucid . admin . users . list ( dojo . hitch ( this , function ( data )  {%NWL%for ( var i = 0 ; i < data . length ; i +  +  )  {%NWL%data [ i ]  . permissions = dojo . toJson ( data [ i ]  . permissions )  ; %NWL%data [ i ]  . groups = dojo . toJson ( data [ i ]  . groups )  ; %NWL%9
clone . ambient = this . ambient ; %NWL%clone . point = this . point ; %NWL%clone . fog = this . fog ; %NWL%clone . global = this . global ; %NWL%clone . directional = this . directional ; %NWL%clone . color =  ( this . color && this . color . slice (  )  )  ; %NWL%clone . direction =  ( this . direction && this . direction . slice (  )  )  ; %NWL%clone . origin =  ( this . origin && this . origin . slice (  )  )  ; %NWL%clone . frustum =  ( this . frustum && this . frustum . slice (  )  )  ; %NWL%clone . frustumNear = this . frustumNear ; %NWL%clone . center =  ( this . center && this . center . slice (  )  )  ; %NWL%5
dimension . filterRange ( interval )  ;%NWL%} else {%NWL%dimension . filterAll (  )  ;%NWL%}%NWL%}  )  ; %NWL%table . data = dimensions . species . top ( Infinity )  ; %NWL%barChart . data = groups . species . all (  )  ;%NWL%}  )  ; %NWL%d3 . tsv ( tsvPath , function type ( d )  {%NWL%d . petalLength =  + d . petalLength ; %NWL%d . petalWidth =  + d . petalWidth ; %NWL%9
this . message = msg%NWL%this . stack =  ( new Error (  )  )  . stack ;%NWL%}%NWL%ServiceError . prototype = new Error (  )%NWL%ServiceError . prototype . constructor = ServiceError%NWL%ServiceError . prototype . name =  ' ServiceError '%NWL%module . exports . ServiceError = ServiceError%NWL%function Router ( hosts , options )  {%NWL%var self = this%NWL%self . hosts = hosts || {  }%NWL%self . options = options || {  }%NWL%9
var log = require (  '  .  / log '  )  ; %NWL%var debug = log . debug ; %NWL%function ASTBase ( parent , name )  {%NWL%this . parent = parent ; %NWL%this . name = name ; %NWL%this . lexer = parent . lexer ; %NWL%if ( this . lexer )  {%NWL%this . sourceLineNum = this . lexer . sourceLineNum ; %NWL%this . column = this . lexer . token . column ; %NWL%this . indent = this . lexer . indent ; %NWL%this . lineInx = this . lexer . lineInx ; %NWL%7
canHaveType : true ,%NWL%onTagged : function ( doclet , tag )  {%NWL%doclet . exceptions = doclet . exceptions || [  ]  ; %NWL%doclet . exceptions . push ( tag . value )  ;%NWL%}  ,%NWL%synonyms :  [  ' exception '  ]%NWL%}  ,%NWL%tutorial :  {%NWL%mustHaveValue : true ,%NWL%onTagged : function ( doclet , tag )  {%NWL%doclet . tutorials = doclet . tutorials || [  ]  ; %NWL%2
return null ;%NWL%}%NWL%if ( goog . isFunction ( fn )  )  {%NWL%fn =  { fn : fn }  ;%NWL%}%NWL%if ( fn . fn )%NWL%fn . fn = goog . bind ( fn . fn , opt_handler || this )  ; %NWL%if ( fn . init )%NWL%fn . init = goog . bind ( fn . init , opt_handler || this )  ; %NWL%if ( fn . dispose )%NWL%fn . dispose = goog . bind ( fn . dispose , opt_handler || this )  ; %NWL%8
var%NWL%str =  ( value =  =  = undefined || value =  =  = TO_DELETE ) ? '  '  : String ( value )  ; %NWL%return CHECK_IS_ARRAY ( value )  =  =  = true || str . trim (  ) ! =  =  '  '  ;%NWL%}  ; %NWL%cls . regex = regex = function ( params )  {%NWL%var%NWL%pattern = params . pattern ,%NWL%str = String ( params . value )  ; %NWL%return str =  =  = str . match ( pattern )  [ 0 ]  ;%NWL%}  ; %NWL%cls . size = size = function ( params )  {%NWL%4
function addBlankCriteriaRow (  )  {%NWL%addCriteriaRow ( $ (  ' #advancedsearch - entity - type '  )  . val (  )  , null , $ (  ' #advancedsearch - criteria - container '  )  )  ;%NWL%}%NWL%function clear (  )  {%NWL%criteriaUI . list (  )  . forEach ( function ( ui )  {%NWL%ui . remove (  )  ;%NWL%}  )  ;%NWL%}%NWL%function onAdvancedSearchDialogRequest ( eventChannel , data )  {%NWL%_UIObjectState . fileId = data . fileId ; %NWL%_UIObjectState . contextId = data . contextId ; %NWL%9
this . once = once || false ;%NWL%}  ; %NWL%Import . prototype . __proto__ = Node . prototype ; %NWL%Import . prototype . clone = function ( parent )  {%NWL%var clone = new Import (  )  ; %NWL%clone . path = this . path . nodeName ? this . path . clone ( parent , clone )  : this . path ; %NWL%clone . once = this . once ; %NWL%clone . mtime = this . mtime ; %NWL%clone . lineno = this . lineno ; %NWL%clone . column = this . column ; %NWL%clone . filename = this . filename ; %NWL%6
}%NWL%if ( query . tags )  {%NWL%if ( query . tags instanceof Array )  {%NWL%content . tags = query . tags . join (  "  ,  "  )  ;%NWL%} else {%NWL%content . tags = query . tags ;%NWL%}%NWL%primaryKey . push (  " tags "  + content . tags )  ; %NWL%if ( query [  " tag_mode "  ] && ( query . tag_mode . toLowerCase (  )  =  =  =  " any " ||%NWL%query . tag_mode . toLowerCase (  )  =  =  =  " all "  )  )  {%NWL%content . tag_mode = query . tag_mode ; %NWL%5
cb = options ; %NWL%options =  {  }  ;%NWL%}%NWL%options = options || {  }  ; %NWL%options . resSetPath = options . resSetPath || ' locales / __lng__ / __ns__ . json '  ; %NWL%options . sendMissing = options . sendMissing || options . saveMissing || false ; %NWL%options . detectLngFromPath = options . detectLngFromPath =  =  = undefined ? false : options . detectLngFromPath ; %NWL%options . forceDetectLngFromPath = options . forceDetectLngFromPath ! =  = true ? false : options . forceDetectLngFromPath ; %NWL%options . detectLngFromHeaders = options . detectLngFromHeaders ! =  = false ? true : options . detectLngFromHeaders ; %NWL%options . supportedLngs = options . supportedLngs || [  ]  ; %NWL%options . ignoreRoutes = options . ignoreRoutes || [  ]  ; %NWL%9
var featureResponseInstance =  {  }  ; %NWL%result . features . push ( featureResponseInstance )  ; %NWL%var nameValue = valueValue [  ' name '  ]  ; %NWL%if ( nameValue ! =  = null && nameValue ! =  = undefined )  {%NWL%var nameInstance = nameValue ; %NWL%featureResponseInstance . name = nameInstance ;%NWL%}%NWL%var propertiesValue = valueValue [  ' properties '  ]  ; %NWL%if ( propertiesValue ! =  = null && propertiesValue ! =  = undefined )  {%NWL%var propertiesInstance =  {  }  ; %NWL%featureResponseInstance . properties = propertiesInstance ; %NWL%5
o . queue = function ( key , options )  { this . embed . queue ( key , options )  ;  }  ; %NWL%o . setVolume = function ( volume )  { this . embed . rdio_setVolume ( volume )  ;  }  ; %NWL%o . setMute = function ( mute )  { this . embed . rdio_setMute ( mute )  ;  }  ; %NWL%o . playQueuedTrack = function ( position , offset )  { this . embed . rdio_playQueuedTrack ( position , offset )  ;  }  ; %NWL%o . moveQueuedSource = function ( from , to )  { this . embed . rdio_moveQueuedSource ( from , to )  ;  }  ; %NWL%o . clearQueue = function (  )  { this . embed . rdio_clearQueue (  )  ;  }  ; %NWL%o . setCurrentPosition = function ( sourceIndex )  { this . embed . rdio_setCurrentPosition ( sourceIndex )  ;  }  ; %NWL%o . removeFromQueue = function ( sourceIndex )  { this . embed . rdio_removeFromQueue ( sourceIndex )  ;  }  ; %NWL%o . sendState = function (  )  { this . embed . rdio_sendState (  )  ;  }  ; %NWL%o . startFrequencyAnalyzer = function ( options )  { this . embed . rdio_startFrequencyAnalyzer ( options )  ;  }  ; %NWL%o . stopFrequencyAnalyzer = function (  )  { this . embed . rdio_stopFrequencyAnalyzer (  )  ;  }  ; %NWL%5
dataDb :  "  "%NWL%}  ,%NWL%loadConfiguration : function ( callback )  {%NWL%chrome . storage . sync . get (  [  ' sitemapDb '  ,  ' dataDb '  ,  ' storageType '  ]  , function ( items )  {%NWL%this . storageType = items . storageType || this . defaults . storageType ; %NWL%if ( this . storageType =  =  =  ' local '  )  {%NWL%this . sitemapDb = this . defaults . sitemapDb ; %NWL%this . dataDb = this . defaults . dataDb ;%NWL%}%NWL%else {%NWL%this . sitemapDb = items . sitemapDb || this . defaults . sitemapDb ; %NWL%4
return !!dir ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%Project . prototype . _restoreNode = function ( node , flattened , jsonKey )  {%NWL%var deps ; %NWL%if ( node . missing )  {%NWL%return ;%NWL%}%NWL%node . dependencies = node . dependencies || {  }  ; %NWL%node . dependants = node . dependants || {  }  ; %NWL%9
let tLocation = location ? ` in $ { t ( location )  } ` :  '  '  ; %NWL%const type = getCheckerDisplay ( fn ,  { short : true }  )  ; %NWL%const stringType = typeof type ! =  =  ' object ' ? type : JSON . stringify ( type )  ; %NWL%return new Error ( `Required $ { t ( name )  } not specified$ { tLocation }  . Must be $ { t ( stringType )  } ` )  ;%NWL%} else {%NWL%return fn ( val , name , location , obj )  ;%NWL%}%NWL%}%NWL%specifiedChecker . type = fn . type ; %NWL%specifiedChecker . shortType = fn . shortType ; %NWL%specifiedChecker . notOptional = fn . notOptional ; %NWL%8
for ( var p in this . properties )  {%NWL%if ( p =  =  " width " || p =  =  " height "  )  {%NWL%this . node . display =  " block "  ;%NWL%}%NWL%var prop = this . properties [ p ]  ; %NWL%prop = pm [ p ]  = _mixin (  {  }  ,  ( d . isObject ( prop ) ? prop :  { end : prop }  )  )  ; %NWL%if ( d . isFunction ( prop . start )  )  {%NWL%prop . start = prop . start (  )  ;%NWL%}%NWL%if ( d . isFunction ( prop . end )  )  {%NWL%prop . end = prop . end (  )  ; %NWL%7
define (  [%NWL%' math / rectangle '%NWL%]  ,%NWL%function (%NWL%Rectangle%NWL%)  {%NWL%' use strict '  ; %NWL%var Sprite = function ( rect , texture )  {%NWL%this . texture = texture ; %NWL%this . x   = rect . x ; %NWL%this . y   = rect . y ; %NWL%9
return stack . reduce ( function ( previous , current )  {%NWL%return current . bind ( el , function next ( args )  {%NWL%return previous . apply ( el , Array . prototype . slice . call ( args )  . slice ( 2 , args . length )  )  ;%NWL%}  , el )  ;%NWL%}  , wrapped . bind ( el , el )  )  . apply ( el , arguments )  ;%NWL%}  ;%NWL%}%NWL%function sanitizeStructure ( struct )  {%NWL%struct . prototype = struct . prototype || Object . create ( HTMLElement . prototype )  ; %NWL%struct . features = struct . features || [  ]  ; %NWL%struct . interceptors = struct . interceptors || [  ]  ; %NWL%9
exports . Media = require (  '  .  / media '  )  ; %NWL%exports . Params = require (  '  .  / params '  )  ; %NWL%exports . Keyframes = require (  '  .  / keyframes '  )  ; %NWL%exports . Charset = require (  '  .  / charset '  )  ; %NWL%exports . Import = require (  '  .  / import '  )  ; %NWL%exports . Function = require (  '  .  / function '  )  ; %NWL%exports . Property = require (  '  .  / property '  )  ; %NWL%exports . Selector = require (  '  .  / selector '  )  ; %NWL%exports . Expression = require (  '  .  / expression '  )  ; %NWL%exports . true = new exports . Boolean ( true )  ; %NWL%exports . false = new exports . Boolean ( false )  ; %NWL%9
delete res . $apply ; %NWL%delete res . $merge ; %NWL%delete res . $unset ; %NWL%res . $set = arguments [ i ]  . $set ; %NWL%continue ;%NWL%}%NWL%else if ( arguments [ i ]  . $merge )  {%NWL%delete res . $set ; %NWL%delete res . $apply ; %NWL%delete res . $unset ; %NWL%res . $merge = arguments [ i ]  . $merge ; %NWL%3
lodash . partial = functions . partial ; %NWL%lodash . partialRight = functions . partialRight ; %NWL%lodash . pick = objects . pick ; %NWL%lodash . pluck = collections . pluck ; %NWL%lodash . property = utilities . property ; %NWL%lodash . pull = arrays . pull ; %NWL%lodash . range = arrays . range ; %NWL%lodash . reject = collections . reject ; %NWL%lodash . remove = arrays . remove ; %NWL%lodash . rest = arrays . rest ; %NWL%lodash . shuffle = collections . shuffle ; %NWL%3
NotImplemented (  " font : really really long text "  )  ;%NWL%}%NWL%if ( g_mVB_Pos_font =  = null )  {%NWL%g_mVB_Pos_font = MakeGlFloatBuffer ( gl ,  [  ]  , gl . DYNAMIC_DRAW )  ; %NWL%g_mVB_Tex_font = MakeGlFloatBuffer ( gl ,  [  ]  , gl . DYNAMIC_DRAW )  ; %NWL%g_mVB_Pos2_font =  [ this . kMaxVerticesPerString * 2 ]  ; %NWL%g_mVB_Tex2_font =  [ this . kMaxVerticesPerString * 2 ]  ;%NWL%}%NWL%this . mVB_Pos = g_mVB_Pos_font ; %NWL%this . mVB_Tex = g_mVB_Tex_font ; %NWL%this . mVB_Pos2 = g_mVB_Pos2_font ; %NWL%8
exports . MetricsClient = azureMonitoring . MetricsClient ; %NWL%exports . createMetricsClient = azureMonitoring . createMetricsClient ; %NWL%exports . RoleEnvironment = require (  '  .  / serviceruntime / roleenvironment '  )  ; %NWL%var azureCommon = require (  ' azure - common '  )  ; %NWL%exports . createCertificateCloudCredentials = azureCommon . createCertificateCloudCredentials ; %NWL%exports . createBasicAuthenticationCloudCredentials = azureWebSite . createBasicAuthenticationCloudCredentials ; %NWL%exports . Constants = azureCommon . Constants ; %NWL%exports . ServiceClient = azureCommon . ServiceClient ; %NWL%exports . ServiceClientConstants = azureCommon . ServiceClientConstants ; %NWL%exports . ConnectionStringParser = azureCommon . ConnectionStringParser ; %NWL%exports . Logger = azureCommon . Logger ; %NWL%4
throw new Error (  " Must specify a build directory "  )  ;%NWL%}%NWL%if ( !! context . buildDir )  {%NWL%context . buildDir = path . resolve ( process . cwd (  )  , context . buildDir )  ;%NWL%}%NWL%context . cacheDir = argv . cacheDir ||%NWL%env (  " FILESYSTEM_CACHE "  ) ||%NWL%context . cacheDir ||%NWL%path . resolve ( __dirname ,  "  .  .  "  ,  " cache "  )  ; %NWL%if ( !! context . cacheDir )  {%NWL%context . cacheDir = path . resolve ( process . cwd (  )  , context . cacheDir )  ; %NWL%3
if ( t . settings [  " syntax_selection_allow "  ] && t . settings [  " syntax_selection_allow "  ]  . length > 0 )%NWL%t . syntax_list = t . settings [  " syntax_selection_allow "  ]  . replace (  /  / g ,  "  "  )  . split (  "  ,  "  )  ; %NWL%if ( t . settings [  ' syntax '  ]  )%NWL%t . allready_used_syntax [ t . settings [  ' syntax '  ]  ]  = true ;%NWL%}  ; %NWL%EditArea . prototype . init = function (  )  {%NWL%var t = this , a , s = t . settings ; %NWL%t . textarea			 = _$ (  " textarea "  )  ; %NWL%t . container			 = _$ (  " container "  )  ; %NWL%t . result			 = _$ (  " result "  )  ; %NWL%t . content_highlight	 = _$ (  " content_highlight "  )  ; %NWL%7
coreHelpers . date  = require (  '  .  / date '  )  ; %NWL%coreHelpers . encode  = require (  '  .  / encode '  )  ; %NWL%coreHelpers . excerpt  = require (  '  .  / excerpt '  )  ; %NWL%coreHelpers . foreach = require (  '  .  / foreach '  )  ; %NWL%coreHelpers . ghost_foot = require (  '  .  / ghost_foot '  )  ; %NWL%coreHelpers . ghost_head = require (  '  .  / ghost_head '  )  ; %NWL%coreHelpers . is = require (  '  .  / is '  )  ; %NWL%coreHelpers . has = require (  '  .  / has '  )  ; %NWL%coreHelpers . meta_description = require (  '  .  / meta_description '  )  ; %NWL%coreHelpers . meta_title = require (  '  .  / meta_title '  )  ; %NWL%coreHelpers . navigation = require (  '  .  / navigation '  )  ; %NWL%0
goog . math . Vec2 . prototype . squaredMagnitude = function (  )  {%NWL%return this . x * this . x + this . y * this . y ;%NWL%}  ; %NWL%goog . math . Vec2 . prototype . scale = function ( s )  {%NWL%this . x *  = s ; %NWL%this . y *  = s ; %NWL%return this ;%NWL%}  ; %NWL%goog . math . Vec2 . prototype . invert = function (  )  {%NWL%this . x =  - this . x ; %NWL%this . y =  - this . y ; %NWL%9
var conf = config . loadEnv ( stex , env )  ; %NWL%var knexConfig =  conf . get (  " db "  )  ; %NWL%if ( typeof knexConfig =  =  =  ' undefined '  )  {%NWL%return {  }  ;%NWL%}%NWL%var dbMigrateConfig   =  {  }  ; %NWL%dbMigrateConfig . driver  = knexConfig . client ; %NWL%dbMigrateConfig . user  = knexConfig . connection . user ; %NWL%dbMigrateConfig . database = knexConfig . connection . database ; %NWL%if ( knexConfig . connection . host )  {%NWL%dbMigrateConfig . host = knexConfig . connection . host ; %NWL%7
]%NWL%}%NWL%]  ; %NWL%this . prompt ( prompts , function ( props )  {%NWL%var hasMod = function ( mod )  { return props . modules . indexOf ( mod ) ! =  =  - 1 ;  }  ; %NWL%this . resourceModule = hasMod (  ' resourceModule '  )  ; %NWL%this . cookiesModule = hasMod (  ' cookiesModule '  )  ; %NWL%this . sanitizeModule = hasMod (  ' sanitizeModule '  )  ; %NWL%this . restangularModule = hasMod (  ' restangularModule '  )  ; %NWL%this . touchModule = hasMod (  ' touchModule '  )  ; %NWL%this . ngStorageModule = hasMod (  ' ngStorageModule '  )  ; %NWL%5
for ( prop in style . style )  {%NWL%if ( !result . style [ prop ]  )  {%NWL%result . style [ prop ]  = style . style [ prop ]  ;%NWL%}%NWL%}%NWL%}%NWL%if ( style . attributes )  {%NWL%if ( !result . attributes )  { result . attributes  =  {  }  ;  }%NWL%for ( prop in style . attributes )  {%NWL%if ( !result . attributes [ prop ]  )  {%NWL%result . attributes [ prop ]  = style . attributes [ prop ]  ; %NWL%2
this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%9
var lmin = new BABYLON . Vector2 ( this . elements [ 0 ]  . x , this . elements [ 0 ]  . y )  ; %NWL%var lmax = new BABYLON . Vector2 ( this . elements [ 0 ]  . x , this . elements [ 0 ]  . y )  ; %NWL%this . elements . forEach ( function ( point )  {%NWL%if ( point . x < lmin . x )  {%NWL%lmin . x = point . x ;%NWL%}%NWL%else if ( point . x > lmax . x )  {%NWL%lmax . x = point . x ;%NWL%}%NWL%if ( point . y < lmin . y )  {%NWL%lmin . y = point . y ; %NWL%4
dojo . require (  " dojox . xml . parser "  )  ; %NWL%dojo . require (  " dojo . data . util . simpleFetch "  )  ; %NWL%dojo . require (  " dojo . data . util . filter "  )  ; %NWL%dojo . declare (  " dojox . data . HtmlTableStore "  , null ,  {%NWL%constructor : function ( args )  {%NWL%dojo . deprecated (  " dojox . data . HtmlTableStore "  ,  " Please use dojox . data . HtmlStore "  )  ; %NWL%if ( args . url )  {%NWL%if ( !args . tableId )%NWL%throw new Error (  " dojo . data . HtmlTableStore : Cannot instantiate using url without an id! "  )  ; %NWL%this . url = args . url ; %NWL%this . tableId = args . tableId ; %NWL%9
if ( this . root_ . key =  = key )  {%NWL%return ;%NWL%}%NWL%var node = new SplayTree . Node ( key , value )  ; %NWL%if ( key > this . root_ . key )  {%NWL%node . left = this . root_ ; %NWL%node . right = this . root_ . right ; %NWL%this . root_ . right = null ;%NWL%} else {%NWL%node . right = this . root_ ; %NWL%node . left = this . root_ . left ; %NWL%6
module . exports = function ( req , res , next )  {%NWL%var projectJSON = JSON . parse ( res . locals . project . data )  ; %NWL%projectJSON . name = res . locals . project . name ; %NWL%projectJSON . projectID = res . locals . project . id ; %NWL%projectJSON . description = res . locals . project . description ; %NWL%projectJSON . template = res . locals . project . template ; %NWL%projectJSON . thumbnail = res . locals . project . thumbnail ; %NWL%projectJSON . publishUrl = utils . embedShellURL ( req . session . user . username , res . locals . project . id )  ; %NWL%projectJSON . iframeUrl = utils . embedURL ( req . session . user . username , res . locals . project . id )  ; %NWL%projectJSON . makeid = res . locals . project . makeid ; %NWL%projectJSON . background = res . locals . project . background ; %NWL%2
minHeight : 100 ,%NWL%showing : true ,%NWL%label :  " name "  ,%NWL%constructor : function ( node , kwArgs )  {%NWL%this . domNode = dom . byId ( node )  ; %NWL%lang . mixin ( this , kwArgs )  ; %NWL%this . xaxis = lang . mixin ( lang . mixin (  {  }  , _xaxis )  , kwArgs . xaxis )  ; %NWL%if ( this . xaxis . labelFunc =  =  " seriesLabels "  )  {%NWL%this . xaxis . labelFunc = lang . hitch ( this ,  " seriesLabels "  )  ;%NWL%}%NWL%this . yaxis = lang . mixin ( lang . mixin (  {  }  , _yaxis )  , kwArgs . yaxis )  ; %NWL%6
var request = parseMessage ( message )  ; %NWL%$ (  ' input#shout - box '  )  . val (  '  '  )  ; %NWL%if ( request [  ' type '  ]  =  =  =  ' join '  )  {%NWL%logMessageToConsole (  ' join channel :  '  + request [  ' message '  ]  )  ;%NWL%} else if ( request [  ' type '  ]  =  =  =  ' leave '  )  {%NWL%logMessageToConsole (  ' leave channel :  '  + request [  ' message '  ]  )  ;%NWL%} else {%NWL%mockResponse =  {  }  ; %NWL%mockResponse . user = you ; %NWL%mockResponse . message = request [  ' message '  ]  ; %NWL%mockResponse . type = request [  ' type '  ]  ; %NWL%9
browser . android = browser . isAndroid = browser . os =  =  = SC . OS . android ; %NWL%browser . opera = browser . name =  =  = SC . BROWSER . opera ? browser . version :  ' 0 '  ; %NWL%browser . isOpera = browser . name =  =  = SC . BROWSER . opera ; %NWL%browser . msie = browser . name =  =  = SC . BROWSER . ie ? browser . version :  ' 0 '  ; %NWL%browser . isIE = browser . engine =  =  = SC . ENGINE . trident ; %NWL%browser . isIE8OrLower = browser . name =  =  = SC . BROWSER . ie && browser . version <  = 8 ; %NWL%browser . mozilla = browser . engine =  =  = SC . ENGINE . gecko ? browser . version :  ' 0 '  ; %NWL%browser . isMozilla = browser . engine =  =  = SC . ENGINE . gecko ; %NWL%browser . webkit = browser . engine =  =  = SC . ENGINE . webkit ? browser . engineVersion :  ' 0 '  ; %NWL%browser . isWebkit = browser . engine =  =  = SC . ENGINE . webkit ; %NWL%browser . chrome = browser . name =  =  = SC . BROWSER . chrome ? browser . version :  ' 0 '  ; %NWL%1
return eventBus . readyState (  )  ;%NWL%}  ,%NWL%EventBus : EventBusOriginal ,%NWL%getOptions : function (  )  {%NWL%return angular . extend (  {  }  , options )  ;%NWL%}%NWL%}  ; %NWL%EventBusStub . reconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . reconnect "  ; %NWL%EventBusStub . close . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . close "  ; %NWL%EventBusStub . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . login "  ; %NWL%EventBusStub . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . send "  ; %NWL%7
this . name = options . name || ' HttpClient '  ; %NWL%this . passphrase = options . passphrase ; %NWL%this . pfx = options . pfx ; %NWL%if ( options . rejectUnauthorized ! =  = undefined )  {%NWL%this . rejectUnauthorized = options . rejectUnauthorized ;%NWL%} else {%NWL%this . rejectUnauthorized = true ;%NWL%}%NWL%this . retry = cloneRetryOptions ( options . retry )  ; %NWL%this . signRequest = options . signRequest || false ; %NWL%this . socketPath = options . socketPath || false ; %NWL%9
top : null ,%NWL%centerLonLat : null ,%NWL%initialize : function ( left , bottom , right , top )  {%NWL%if ( left ! = null )  {%NWL%this . left = OpenLayers . Util . toFloat ( left )  ;%NWL%}%NWL%if ( bottom ! = null )  {%NWL%this . bottom = OpenLayers . Util . toFloat ( bottom )  ;%NWL%}%NWL%if ( right ! = null )  {%NWL%this . right = OpenLayers . Util . toFloat ( right )  ; %NWL%4
w : this . _vp . w - 80 ,%NWL%h : this . _vp . h - 60 - this . _lastTitleSize . h%NWL%}  ; 	 /  / New viewport%NWL%var viewportAspect = nvp . w / nvp . h ,%NWL%imageAspect = size . w / size . h ; %NWL%if ( imageAspect >  = viewportAspect )  {%NWL%ns . h = nvp . w / imageAspect ; %NWL%ns . w = nvp . w ;%NWL%} else {%NWL%ns . w = imageAspect * nvp . h ; %NWL%ns . h = nvp . h ; %NWL%7
_fromCSS : function ( css )  {%NWL%var color = null ; %NWL%for ( var i = 0 , j = this . _stringParsers . length ; i < j ; i +  +  )  {%NWL%color = this . _stringParsers [ i ]  ( css )  ; %NWL%if ( color ) return color ;%NWL%}%NWL%}  ,%NWL%_fromRGB : function ( RGB )  {%NWL%var newRGB = factories . RGB (  )  ; %NWL%newRGB . red = RGB . red ; %NWL%newRGB . green = RGB . green ; %NWL%9
select . enable = select . enable . bind ( select )  ; %NWL%select . disable = function (  )  {%NWL%if ( !select . enabled ) return ; %NWL%this . dropdown . onclick = null ; %NWL%this . dropdown . removeAttribute ( inEvent )  ; %NWL%this . dropdown . removeAttribute ( outEvent )  ; %NWL%this . dropdown . setAttribute (  ' class '  , normal +  ' pb - dropdown - disabled '  )  ; %NWL%this . enabled = false ; %NWL%this . setAttribute (  ' disabled '  ,  ' disabled '  )  ;%NWL%}  ; %NWL%select . disable = select . disable . bind ( select )  ; %NWL%0
this . missing_value = obj . missing_value ; %NWL%this . nonadditive = obj . nonadditive ; %NWL%if ( obj . aggregates )  {%NWL%this . aggregates = obj . aggregates ;%NWL%}%NWL%}  ; %NWL%cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%0
height : 8 ,%NWL%radius : 0%NWL%}%NWL%}%NWL%}  ,%NWL%updatePlainBBox : function ( plain )  {%NWL%var attr = this . attr ; %NWL%plain . x = attr . x ; %NWL%plain . y = attr . y ; %NWL%plain . width = attr . width ; %NWL%plain . height = attr . height ; %NWL%7
THREE . MeshLambertMaterial . prototype = Object . create ( THREE . Material . prototype )  ; %NWL%THREE . MeshLambertMaterial . prototype . constructor = THREE . MeshLambertMaterial ; %NWL%THREE . MeshLambertMaterial . prototype . clone = function (  )  {%NWL%var material = new THREE . MeshLambertMaterial (  )  ; %NWL%THREE . Material . prototype . clone . call ( this , material )  ; %NWL%material . color . copy ( this . color )  ; %NWL%material . emissive . copy ( this . emissive )  ; %NWL%material . wrapAround = this . wrapAround ; %NWL%material . wrapRGB . copy ( this . wrapRGB )  ; %NWL%material . map = this . map ; %NWL%material . lightMap = this . lightMap ; %NWL%7
' orion / webui / Slideout '%NWL%]  , function ( messages , objects , lib , mProblemsExplorer , mSlideout )  {%NWL%var SlideoutViewMode = mSlideout . SlideoutViewMode ; %NWL%function ProblemsView ( options , slideout )  {%NWL%if ( slideout )  {%NWL%SlideoutViewMode . call ( this , slideout )  ;%NWL%}%NWL%var parentId = options . parentId ? options . parentId :  " orion . PropertyPanel . container "  ; %NWL%this . _parent = lib . node ( parentId )  ; %NWL%this . serviceRegistry = options . serviceRegistry ; %NWL%this . commandRegistry = options . commandRegistry ; %NWL%9
var Carousel = function ( element , options )  {%NWL%var self = this ; %NWL%var $container = $ ( element )  ; %NWL%this . items =  [  ]  ; %NWL%this . xOrigin =  ( options . xOrigin =  =  = null ) ? $container . width (  )  * 0 . 5 : options . xOrigin ; %NWL%this . yOrigin =  ( options . yOrigin =  =  = null ) ? $container . height (  )  * 0 . 1 : options . yOrigin ; %NWL%this . xRadius =  ( options . xRadius =  =  = null ) ? $container . width (  )  / 2 . 3 : options . xRadius ; %NWL%this . yRadius =  ( options . yRadius =  =  = null ) ? $container . height (  )  / 6  : options . yRadius ; %NWL%this . farScale = options . farScale ; %NWL%this . rotation = this . destRotation = Math . PI / 2 ;  /  / start with the first item positioned in front%NWL%this . speed = options . speed ; %NWL%8
Node . call ( this )  ; %NWL%this . cond = cond ; %NWL%this . trueExpr = trueExpr ; %NWL%this . falseExpr = falseExpr ;%NWL%}  ; %NWL%Ternary . prototype . __proto__ = Node . prototype ; %NWL%Ternary . prototype . clone = function ( parent )  {%NWL%var clone = new Ternary (  )  ; %NWL%clone . cond = this . cond . clone ( parent , clone )  ; %NWL%clone . trueExpr = this . trueExpr . clone ( parent , clone )  ; %NWL%clone . falseExpr = this . falseExpr . clone ( parent , clone )  ; %NWL%8
json . alpha = this . alpha ; %NWL%return json ;%NWL%}  ; %NWL%GUITexture . prototype . fromJSON = function ( json )  {%NWL%GUIElement . prototype . fromJSON . call ( this , json )  ; %NWL%this . texture = json . texture ? Assets . get ( json . texture )  : undefined ; %NWL%this . color . fromJSON ( json . color )  ; %NWL%this . position . fromJSON ( json . position )  ; %NWL%this . x = json . x ; %NWL%this . y = json . y ; %NWL%this . w = json . w ; %NWL%8
connection . update ( this , callback )  ;%NWL%} else {%NWL%connection . save ( this , callback )  ;%NWL%}%NWL%}  ; %NWL%this . save = persistUtil . bind (  ' save '  , this . save , this )  ; %NWL%this . update = function ( connection , props , callback )  {%NWL%copyValuesIntoObject ( props , this )  ; %NWL%this . save ( connection , callback )  ;%NWL%}  ; %NWL%this . update = persistUtil . bind (  ' update '  , this . update , this )  ; %NWL%5
( function (  )  {%NWL%var __bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ; %NWL%window . ClientServer =  ( function (  )  {%NWL%function ClientServer ( options )  {%NWL%this . onDBChange = __bind ( this . onDBChange , this )  ; %NWL%this . removePeerFromClientBrowserResourceRequests = __bind ( this . removePeerFromClientBrowserResourceRequests , this )  ; %NWL%this . onResourceChange = __bind ( this . onResourceChange , this )  ; %NWL%this . recordResourceRequest = __bind ( this . recordResourceRequest , this )  ; %NWL%this . getContentsForPath = __bind ( this . getContentsForPath , this )  ; %NWL%this . parsePath = __bind ( this . parsePath , this )  ; %NWL%this . serveFile = __bind ( this . serveFile , this )  ; %NWL%4
this . _lookups =  {  }  ; %NWL%this . strictImports = strictImports ;%NWL%}  ; %NWL%tree . Ruleset . prototype =  {%NWL%eval : function ( env )  {%NWL%var selectors = this . selectors && this . selectors . map ( function ( s )  { return s . eval ( env )  }  )  ; %NWL%var ruleset = new ( tree . Ruleset )  ( selectors , this . rules . slice ( 0 )  , this . strictImports )  ; %NWL%var rules ; %NWL%ruleset . originalRuleset = this ; %NWL%ruleset . root = this . root ; %NWL%ruleset . allowImports = this . allowImports ; %NWL%9
this . ports =  [  ]  ; %NWL%this . name = options [  " name "  ] ! = null ? options [  " name "  ]  :  " replica - set - foo "  ; %NWL%this . host = options [  " host "  ] ! = null ? options [  " host "  ]  :  " 127 . 0 . 0 . 1 "  ; %NWL%this . retries = options [  " retries "  ] ! = null ? options [  " retries "  ]  : 60 ; %NWL%this . config =  {  " _id "  : this . name ,  " version "  : 1 ,  " members "  :  [  ]  }  ; %NWL%this . durable = options [  " durable "  ] ! = null ? options [  " durable "  ]  : false ; %NWL%this . auth = options [  ' auth '  ] ! = null ? options [  ' auth '  ]  : false ; %NWL%this . path = path . resolve (  " data "  )  ; %NWL%this . killNodeWaitTime = options [  ' kill_node_wait_time '  ] ! = null ? options [  ' kill_node_wait_time '  ]  : 20000 ; %NWL%this . tags = options [  ' tags '  ] ! = null ? options [  ' tags '  ]  :  [  ]  ; %NWL%this . ssl = options [  ' ssl '  ] ! = null ? options [  ' ssl '  ]  : false ; %NWL%6
scale = 1 ; %NWL%if ( imageAspectRatio >  = elementAspectRatio )  {%NWL%scale = elementHeight / image . height ;%NWL%} else {%NWL%scale = elementWidth / image . width ;%NWL%}%NWL%imageDimensions . width = image . width * scale ; %NWL%imageDimensions . height = image . height * scale ;%NWL%} else {%NWL%imageDimensions . width = image . width ; %NWL%imageDimensions . height = image . height ; %NWL%9
if ( args . enableGiftSubscriptions ! =  = undefined )  {%NWL%this . enableGiftSubscriptions = args . enableGiftSubscriptions ;%NWL%}%NWL%if ( args . enableSupportTickets ! =  = undefined )  {%NWL%this . enableSupportTickets = args . enableSupportTickets ;%NWL%}%NWL%if ( args . enableSharedNotebooks ! =  = undefined )  {%NWL%this . enableSharedNotebooks = args . enableSharedNotebooks ;%NWL%}%NWL%if ( args . enableSingleNoteSharing ! =  = undefined )  {%NWL%this . enableSingleNoteSharing = args . enableSingleNoteSharing ; %NWL%1
lodash . isElement = objects . isElement ; %NWL%lodash . isEmpty = objects . isEmpty ; %NWL%lodash . isEqual = objects . isEqual ; %NWL%lodash . isFinite = objects . isFinite ; %NWL%lodash . isFunction = objects . isFunction ; %NWL%lodash . isNaN = objects . isNaN ; %NWL%lodash . isNull = objects . isNull ; %NWL%lodash . isNumber = objects . isNumber ; %NWL%lodash . isObject = objects . isObject ; %NWL%lodash . isPlainObject = objects . isPlainObject ; %NWL%lodash . isRegExp = objects . isRegExp ; %NWL%0
this . poolSize = this . options . poolSize =  = null ? 5 : this . options . poolSize ; %NWL%this . disableDriverBSONSizeCheck = this . options . disableDriverBSONSizeCheck ! = null ? this . options . disableDriverBSONSizeCheck : false ; %NWL%this . _used = false ; %NWL%this . replicasetInstance = null ; %NWL%this . emitOpen = this . options . emitOpen || true ; %NWL%this . ssl = this . options . ssl =  = null ? false : this . options . ssl ; %NWL%this . sslValidate = this . options . sslValidate =  = null ? false : this . options . sslValidate ; %NWL%this . sslCA = Array . isArray ( this . options . sslCA ) ? this . options . sslCA : null ; %NWL%this . sslCert = this . options . sslCert ; %NWL%this . sslKey = this . options . sslKey ; %NWL%this . sslPass = this . options . sslPass ; %NWL%8
options = options ? options :  { jobName :  '  '  ,%NWL%cronTime :  '  *  *  *  *  *  *  '  ,%NWL%enabled : true ,%NWL%module :  '  '  ,%NWL%method :  '  '  ,%NWL%events :  '  '  ,%NWL%args :  '  '%NWL%}%NWL%this . jobName = options . jobName ; %NWL%this . fn = options . fn ; %NWL%this . enabled = options . enabled ; %NWL%8
}%NWL%if ( schema . sort && !schema . sort . mSubpopulateWrapped )  {%NWL%var sortOrig = schema . sort ; %NWL%schema . sort = function sortWrapped ( sort )  {%NWL%return wrapSchema ( sortOrig . call ( schema , sort )  )  ;%NWL%}  ; %NWL%schema . sort . mSubpopulateWrapped = true ;%NWL%}%NWL%if ( schema . skip && !schema . sort . mSubpopulateWrapped )  {%NWL%var skipOrig = schema . skip ; %NWL%schema . skip = function skipWrapped ( skip )  {%NWL%3
this . addListener ( domWindow ,  ' resize '  ,  ' windowresized '  )  ; %NWL%this . addListener (  ' #close '  ,  ' click '  , window . close . bind ( domWindow )  )  ;%NWL%( domWindow || {  }  )  . onerror = A . console . logError ; %NWL%return this ;%NWL%}  . bind ( controller )  )  ;%NWL%}  ,%NWL%getSizes : function (  )  {%NWL%var sizes = this . sizes || {  }  ; %NWL%sizes . default = sizes . default || this . size || [ 400 , 300 ]  ; %NWL%sizes . minimum = sizes . minimum || this . size ; %NWL%sizes . maximum = sizes . maximum || this . size ; %NWL%9
var node = _ . extend (  {  }  , this . config )  ; %NWL%var options = node . options ; %NWL%var padding = node . guide . padding ; %NWL%var innerLeft = options . left + padding . l ; %NWL%var innerTop = options . top + padding . t ; %NWL%var innerWidth = this . W ; %NWL%var innerHeight = this . H ; %NWL%node . x = this . xScale ; %NWL%node . y = this . yScale ; %NWL%node . x . scaleObj = this . xScale ; %NWL%node . y . scaleObj = this . yScale ; %NWL%9
}%NWL%var spriteParameters = this . spriteParameters ; %NWL%spriteParameters . v3Location  = v3Location ; %NWL%spriteParameters . size   =  ( this . scale * archetype . size )  * screenScale ; %NWL%spriteParameters . offsetX  = archetype . offsetX ; %NWL%spriteParameters . offsetY  =  ( archetype . offsetY | 0 )  +  ( this . screenSpace ? screenScale : 0 )  ; %NWL%spriteParameters . blendStyle  = additive ? SimpleSprite . prototype . blendStyle . ADD : SimpleSprite . prototype . blendStyle . NORMAL ; %NWL%spriteParameters . texture  = this . path ; %NWL%spriteParameters . v4color  = archetype . color ; %NWL%spriteParameters . angle   = rotationAmount ; %NWL%spriteParameters . uvRectangle = archetype . uvRectangle ; %NWL%4
var POS = require (  ' lib / utilities / global '  )  ; %NWL%var LayoutView = require (  '  .  / layout '  )  ; %NWL%var StatusView = require (  '  .  / views / status '  )  ; %NWL%var GatewaysView = require (  '  .  / views / gateways '  )  ; %NWL%var Buttons = require (  ' lib / components / buttons / view '  )  ; %NWL%var polyglot = require (  ' lib / utilities / polyglot '  )  ; %NWL%var CheckoutRoute = Route . extend (  {%NWL%initialize : function ( options )  {%NWL%options = options || {  }  ; %NWL%this . container = options . container ; %NWL%this . collection = options . collection ; %NWL%9
var OpmlStore = declare (  " dojox . data . OpmlStore "  , null ,  {%NWL%constructor : function ( keywordParameters )  {%NWL%this . _xmlData = null ; %NWL%this . _arrayOfTopLevelItems =  [  ]  ; %NWL%this . _arrayOfAllItems =  [  ]  ; %NWL%this . _metadataNodes = null ; %NWL%this . _loadFinished = false ; %NWL%this . url = keywordParameters . url ; %NWL%this . _opmlData = keywordParameters . data ;  /  / XML DOM Document%NWL%if ( keywordParameters . label )  {%NWL%this . label = keywordParameters . label ; %NWL%7
var newh = Math . max (  ( oldh + dh )  , 1 )  ; %NWL%var ratiodh =  ( newh / oldh )  ; %NWL%var ratiodw =  ( neww / oldw )  ; %NWL%for ( var e = 0 ; e < this . pathpoints . length ; e +  +  )  {%NWL%var pp = this . pathpoints [ e ]  ; %NWL%pp . P . x =   (  (  ( pp . P . x  - this . maxes . xmin )  * ratiodw )  + this . maxes . xmin )  ; %NWL%pp . H1 . x =  (  (  ( pp . H1 . x - this . maxes . xmin )  * ratiodw )  + this . maxes . xmin )  ; %NWL%pp . H2 . x =  (  (  ( pp . H2 . x - this . maxes . xmin )  * ratiodw )  + this . maxes . xmin )  ; %NWL%pp . P . y =   (  (  ( pp . P . y  - this . maxes . ymin )  * ratiodh )  + this . maxes . ymin )  ; %NWL%pp . H1 . y =  (  (  ( pp . H1 . y - this . maxes . ymin )  * ratiodh )  + this . maxes . ymin )  ; %NWL%pp . H2 . y =  (  (  ( pp . H2 . y - this . maxes . ymin )  * ratiodh )  + this . maxes . ymin )  ; %NWL%9
entryHTML +  =  ' favorited '  ;%NWL%}%NWL%if ( d . SC_is_reply )  {%NWL%entryHTML +  =  ' reply '  ;%NWL%}%NWL%if ( d . SC_is_retweet )  {%NWL%entryHTML +  =  ' retweet '  ; %NWL%d . retweeting_user = d . user ; %NWL%d . user = d . retweeted_status . user ; %NWL%d . id = d . retweeted_status . id ; %NWL%d . in_reply_to_status_id = d . retweeted_status . in_reply_to_status_id ; %NWL%8
json . sizeTween = this . sizeTween . toJSON ( json . sizeTween )  ; %NWL%json . alphaTween = this . alphaTween . toJSON ( json . alphaTween )  ; %NWL%json . colorTween = this . colorTween . toJSON ( json . colorTween )  ; %NWL%json . velocity = this . velocity . toJSON ( json . velocity )  ; %NWL%json . velocitySpread = this . velocitySpread . toJSON ( json . velocitySpread )  ; %NWL%json . acceleration = this . acceleration . toJSON ( json . acceleration )  ; %NWL%json . accelerationSpread = this . accelerationSpread . toJSON ( json . accelerationSpread )  ; %NWL%json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%7
lodash . isEmpty = objects . isEmpty ; %NWL%lodash . isEqual = objects . isEqual ; %NWL%lodash . isFinite = objects . isFinite ; %NWL%lodash . isFunction = objects . isFunction ; %NWL%lodash . isNaN = objects . isNaN ; %NWL%lodash . isNull = objects . isNull ; %NWL%lodash . isNumber = objects . isNumber ; %NWL%lodash . isObject = objects . isObject ; %NWL%lodash . isPlainObject = objects . isPlainObject ; %NWL%lodash . isRegExp = objects . isRegExp ; %NWL%lodash . isString = objects . isString ; %NWL%0
break ;%NWL%}%NWL%}%NWL%return aCookie ;%NWL%}%NWL%coomanPlus . cookieObject = function ( aCookie , sel , updated )%NWL%{%NWL%this . aCookie			 = aCookie ; %NWL%this . name					 = aCookie . name ; %NWL%this . value				 = aCookie . value ; %NWL%this . isDomain			 = aCookie . isDomain ; %NWL%8
position = this . position ; %NWL%graph . window . xMin = position . xMin ; %NWL%graph . window . xMax = position . xMax ; %NWL%if ( graph . window . xMin =  =  = null )  {%NWL%position . xMin = graph . dataDomain (  )  [ 0 ]  ;%NWL%}%NWL%if ( graph . window . xMax =  =  = null )  {%NWL%position . xMax = graph . dataDomain (  )  [ 1 ]  ;%NWL%}%NWL%position . xMin = graph . window . xMin ; %NWL%position . xMax = graph . window . xMax ; %NWL%9
}  )  ; %NWL%resource . _dequeue (  )  ;%NWL%}  ; %NWL%Loader . prototype . _runMiddleware = function ( resource , fns , cb )  {%NWL%var self = this ; %NWL%async . eachSeries ( fns , function ( fn , next )  {%NWL%fn . call ( self , resource , next )  ;%NWL%}  , cb . bind ( this , resource )  )  ;%NWL%}  ; %NWL%Loader . LOAD_TYPE = Resource . LOAD_TYPE ; %NWL%Loader . XHR_READY_STATE = Resource . XHR_READY_STATE ; %NWL%9
self . removeItem = function ( uid )%NWL%{%NWL%self . items = self . items . filter ( function ( i )  { return i ! =  = uid ;  }  )  ;%NWL%}  ; %NWL%self . addNpc = function ( uid )%NWL%{%NWL%self . npcs . push ( uid )%NWL%}  ; %NWL%self . removeNpc = function ( uid )%NWL%{%NWL%self . npcs = self . npcs . filter ( function ( i )  { return i ! =  = uid ;  }  )  ; %NWL%2
newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%newTexture . wrapU = this . wrapU ; %NWL%newTexture . wrapV = this . wrapV ; %NWL%newTexture . coordinatesIndex = this . coordinatesIndex ; %NWL%newTexture . coordinatesMode = this . coordinatesMode ; %NWL%newTexture . uOffset = this . uOffset ; %NWL%newTexture . vOffset = this . vOffset ; %NWL%newTexture . uScale = this . uScale ; %NWL%newTexture . vScale = this . vScale ; %NWL%newTexture . uAng = this . uAng ; %NWL%0
this . message = configuration . message || null ; %NWL%this . error = false ; %NWL%this . time = null ; %NWL%index =  - 1 ;%NWL%}%NWL%util . inherits ( VoltMessageManager , EventEmitter )  ; %NWL%function VoltConnection ( configuration )  {%NWL%EventEmitter . call ( this )  ; %NWL%this . config = configuration ; %NWL%this . onConnect = this . onConnect . bind ( this )  ; %NWL%this . onError = this . onError . bind ( this )  ; %NWL%9
}%NWL%}%NWL%}  )  ;%NWL%}  ; %NWL%HttpProxy . prototype . _forwardRequest = function ( req )  {%NWL%var self = this ,%NWL%outgoing = new ( this . forward . base )  ,%NWL%forwardProxy ; %NWL%outgoing . host  = this . forward . host ; %NWL%outgoing . port  = this . forward . port ,%NWL%outgoing . agent  = this . forward . agent ; %NWL%8
switch ( button )  {%NWL%case 0 : %NWL%syncing = false ; %NWL%transaction . abort (  )  ; %NWL%break ; %NWL%case 1 : %NWL%conflictService_ . ourName = ourName ; %NWL%conflictService_ . theirName = theirName ; %NWL%conflictService_ . ours = mergeFailure . ours ; %NWL%conflictService_ . theirs = mergeFailure . theirs ; %NWL%conflictService_ . ancestor = mergeFailure . ancestor ; %NWL%8
var EPSLN = 1 . 0e - 10 ; %NWL%var gN = require (  '  .  .  / common / gN '  )  ; %NWL%var MAX_ITER = 20 ; %NWL%exports . init = function (  )  {%NWL%this . temp = this . b / this . a ; %NWL%this . es = 1 - Math . pow ( this . temp , 2 )  ;  /  / devait etre dans tmerc . js mais n y est pas donc je commente sinon retour de valeurs nulles%NWL%this . e = Math . sqrt ( this . es )  ; %NWL%this . e0 = e0fn ( this . es )  ; %NWL%this . e1 = e1fn ( this . es )  ; %NWL%this . e2 = e2fn ( this . es )  ; %NWL%this . e3 = e3fn ( this . es )  ; %NWL%7
if ( queryParam (  ' timeBack '  ) ! = null )  {%NWL%config . timeBack = queryParam (  ' timeBack '  )  ;%NWL%}%NWL%if ( queryParam (  ' from '  ) ! = null && queryParam (  ' until '  ) ! = null )  {%NWL%config . from = queryParam (  ' from '  )  ; %NWL%config . until = queryParam (  ' until '  )  ; %NWL%config . hoursBack = null ; %NWL%config . timeBack = null ;%NWL%}%NWL%if ( queryParam (  ' columns '  ) ! = null )  {%NWL%config . columns = queryParam (  ' columns '  )  ; %NWL%1
moveCursor : this . canvas && this . canvas . moveCursor%NWL%}  ;%NWL%}  ,%NWL%_restoreEditingProps : function (  )  {%NWL%if ( !this . _savedProps )  {%NWL%return ;%NWL%}%NWL%this . hoverCursor = this . _savedProps . overCursor ; %NWL%this . hasControls = this . _savedProps . hasControls ; %NWL%this . borderColor = this . _savedProps . borderColor ; %NWL%this . lockMovementX = this . _savedProps . lockMovementX ; %NWL%8
function has ( x , y )  {%NWL%for ( var i = 0 ; i < x . length ; i +  +  ) if ( x [ i ]  =  = y ) return true ; %NWL%return false ;%NWL%}%NWL%h . makeEvent = function ( o )  {%NWL%var evt ; %NWL%if ( has ( events . key , o . type )  )  {%NWL%if ( typeof Event =  =  =  ' function '  )  {%NWL%evt = new Event ( o . type )  ; %NWL%evt . keyCode = o . keyCode || 0 ; %NWL%evt . charCode = o . charCode || 0 ; %NWL%9
style . width = w ; %NWL%style . height = h ; %NWL%style . x = left ; %NWL%style . y = top ; %NWL%if ( fillColors )%NWL%{%NWL%style . fill . color = fillColors [ i % fillColors . length ]  ;%NWL%}%NWL%if ( borderColors )%NWL%{%NWL%style . border . color = borderColors [ i % borderColors . length ]  ; %NWL%6
return ( setHeader . apply ( this , arguments )  )  ;%NWL%}%NWL%httpPlug . OutgoingMessage . prototype . gjsRemoveHeader = function ( name )  {%NWL%return ( removeHeader . apply ( this , arguments )  )  ;%NWL%}%NWL%var http = function (  )  {  }  ; %NWL%http . agent = require ( __dirname +  '  / js / agent '  )  ; %NWL%http . log = require ( __dirname +  '  / js / log '  )  ; %NWL%http . littleFs = require ( __dirname +  '  / js / littleFs '  )  ; %NWL%http . error = require ( __dirname +  '  / js / error '  )  ; %NWL%http . site = require ( __dirname +  '  / js / site '  )  ; %NWL%6
groups . namespace = ns ; %NWL%groups . id = id ; %NWL%return groups ;%NWL%}%NWL%var d3_transitionPrototype =  [  ]  ,%NWL%d3_transitionId = 0 ,%NWL%d3_transitionInheritId ,%NWL%d3_transitionInherit ; %NWL%d3_transitionPrototype . call = d3_selectionPrototype . call ; %NWL%d3_transitionPrototype . empty = d3_selectionPrototype . empty ; %NWL%d3_transitionPrototype . node = d3_selectionPrototype . node ; %NWL%8
this . ery = 0 ; %NWL%this . cx = 0 ; %NWL%this . cy = 0 ; %NWL%this . ix = 0 ; %NWL%this . iy = 0 ; %NWL%this . mx = 0 ; %NWL%this . my = 0 ; %NWL%this . vx = 0 ; %NWL%this . vy = 0 ; %NWL%this . onMouseMove = this . onMouseMove . bind ( this )  ; %NWL%this . onDeviceOrientation = this . onDeviceOrientation . bind ( this )  ; %NWL%9
debug (  ' Using the '  + Proto . model . modelName +  ' model for default ( restful ) CRUD on this service .  .  .  '  )  ; %NWL%Proto . db = Proto . model . connection ; %NWL%Static . db = Proto . db ; %NWL%Static . model = Proto . model ;%NWL%} else {%NWL%debug ( util . inspect ( Proto )  )  ; %NWL%throw new Error (  ' Unknown model type passed to Service . extend (  )  , set environment variable DEBUG = Services for more information .  '  )  ;%NWL%}%NWL%} else if ( !!Proto . db )  {%NWL%debug (  ' Setting db adapter for service .  .  .  '  )  ; %NWL%Static . db = Proto . db ; %NWL%3
_naturalHeight : data ( 0 , true , true )  ,%NWL%source : accessor ( getSource , setSource , true )  ,%NWL%_source : data (  '  '  , true , true )  ,%NWL%_absoluteUrl : data (  '  '  , true , true )%NWL%}  )  ; %NWL%var rendererAttributes = this . _renderAttributes ; %NWL%rendererAttributes . height =  ' height '  ; %NWL%rendererAttributes . width =  ' width '  ; %NWL%rendererAttributes . naturalHeight =  ' _naturalHeight '  ; %NWL%rendererAttributes . naturalWidth =  ' _naturalWidth '  ; %NWL%rendererAttributes . absoluteUrl =  ' _absoluteUrl '  ; %NWL%8
return false ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%$scope . getIsConsoleVisible = function getIsConsoleVisible (  )  {%NWL%if ( !$scope . fileParsable )  {%NWL%return false ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%$scope . toggleShelf = function toggleShelf (  )  {%NWL%4
}  ; %NWL%scale . copy = function (  )  {%NWL%return d3_scale_linear ( domain , range , interpolate , clamp )  ;%NWL%}  ; %NWL%return rescale (  )  ;%NWL%}  ; %NWL%function d3_scale_linearRebind ( scale , linear )  {%NWL%scale . range = d3 . rebind ( scale , linear . range )  ; %NWL%scale . rangeRound = d3 . rebind ( scale , linear . rangeRound )  ; %NWL%scale . interpolate = d3 . rebind ( scale , linear . interpolate )  ; %NWL%scale . clamp = d3 . rebind ( scale , linear . clamp )  ; %NWL%7
var wsServerStatus ; %NWL%var Dictate = function ( cfg )  {%NWL%var config = cfg || {  }  ; %NWL%config . server = config . server || SERVER ; %NWL%config . serverStatus = config . serverStatus || SERVER_STATUS ; %NWL%config . referenceHandler = config . referenceHandler || REFERENCE_HANDLER ; %NWL%config . contentType = config . contentType || CONTENT_TYPE ; %NWL%config . interval = config . interval || INTERVAL ; %NWL%config . recorderWorkerPath = config . recorderWorkerPath || RECORDER_WORKER_PATH ; %NWL%config . onReadyForSpeech = config . onReadyForSpeech || function (  )  {  }  ; %NWL%config . onEndOfSpeech = config . onEndOfSpeech || function (  )  {  }  ; %NWL%9
self . conn = null ;%NWL%}%NWL%sys . inherits ( Connection , events . EventEmitter )  ; %NWL%Connection . prototype . socketRemote = function ( opts , callback )  {%NWL%var self = this ; %NWL%if ( !opts . host || !opts . port )  {%NWL%callback ( new Error (  ' please provide a host and a port as argument! '  )  )  ; %NWL%return ;%NWL%}%NWL%self . host = opts . host ; %NWL%self . port = opts . port ; %NWL%9
localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%9
markup +  =  "  >  "  ; %NWL%for ( var i = 0 ; i < this . children . length ; i +  +  )  {%NWL%markup +  = this . children [ i ]  . toMarkup (  )  ;%NWL%}%NWL%markup +  =  "  <  / span >  "  ; %NWL%return markup ;%NWL%}  ; %NWL%function documentFragment ( children , height , depth , maxFontSize )  {%NWL%this . children = children || [  ]  ; %NWL%this . height = height || 0 ; %NWL%this . depth = depth || 0 ; %NWL%9
this . maxZ = maxZ || 0 ; %NWL%this . parent = null ;%NWL%}  ; %NWL%OIMO . Proxy . prototype =  {%NWL%constructor : OIMO . Proxy ,%NWL%init : function ( minX , maxX , minY , maxY , minZ , maxZ )  {%NWL%this . minX = minX || 0 ; %NWL%this . maxX = maxX || 0 ; %NWL%this . minY = minY || 0 ; %NWL%this . maxY = maxY || 0 ; %NWL%this . minZ = minZ || 0 ; %NWL%0
this . shadowDistance = config . shadowDistance || 20 ; %NWL%this . shadowNearMultiplier = config . shadowNearMultiplier || 2 . 0 ; %NWL%this . shadowMapQuality = config . shadowMapQuality || 1 . 0 ; %NWL%this . maxNumerOfLights = typeof ( config . maxNumerOfLights )  =  =  =  ' number ' ? config . maxNumerOfLights : 1 ; %NWL%this . enableDebugContext = typeof ( config . enableDebugContext )  =  =  =  ' boolean ' ? config . enableDebugContext  : false ; %NWL%this . preserveDrawingBuffer = config . preserveDrawingBuffer || false ; %NWL%this . alpha = typeof ( config . alpha )  =  =  =  ' boolean ' ? config . alpha : true ; %NWL%this . depth = typeof ( config . depth )  =  =  =  ' boolean ' ? config . depth : true ; %NWL%this . stencil = typeof ( config . stencil )  =  =  =  ' boolean ' ? config . stencil : false ; %NWL%this . antialias = typeof ( config . antialias )  =  =  =  ' boolean ' ? config . antialias : true ; %NWL%this . premultipliedAlpha = typeof ( config . premultipliedAlpha )  =  =  =  ' boolean ' ? config . premultipliedAlpha : true ; %NWL%6
return str . replace (  / ^\s + |\s + $ / g ,  '  '  )%NWL%}%NWL%var BP = Buffer . prototype%NWL%function augment ( arr )  {%NWL%arr . _isBuffer = true%NWL%arr . write = BP . write%NWL%arr . toString = BP . toString%NWL%arr . toLocaleString = BP . toString%NWL%arr . toJSON = BP . toJSON%NWL%arr . copy = BP . copy%NWL%arr . slice = BP . slice%NWL%5
AES_CFB_prototype . reset = AES_reset ; %NWL%AES_CFB_prototype . encrypt = AES_Encrypt_finish ; %NWL%AES_CFB_prototype . decrypt = AES_Decrypt_finish ; %NWL%function AES_CFB_Encrypt ( options )  {%NWL%AES_CFB . call ( this , options )  ;%NWL%}%NWL%var AES_CFB_Encrypt_prototype = AES_CFB_Encrypt . prototype ; %NWL%AES_CFB_Encrypt_prototype . BLOCK_SIZE = 16 ; %NWL%AES_CFB_Encrypt_prototype . reset = AES_reset ; %NWL%AES_CFB_Encrypt_prototype . process = AES_Encrypt_process ; %NWL%AES_CFB_Encrypt_prototype . finish = AES_Encrypt_finish ; %NWL%9
localChanges : localChanges ,%NWL%remoteChanges : remoteChanges ,%NWL%conflicts : conflicts%NWL%}  )  ;%NWL%}%NWL%else {%NWL%Zotero . debug (  " Rejecting promise for queue "  + this . name )  ; %NWL%var e = this . _error ; %NWL%this . _error = false ; %NWL%e . libraryID = this . libraryID ; %NWL%e . type = this . type ; %NWL%9
lodash . omit = objects . omit ; %NWL%lodash . once = functions . once ; %NWL%lodash . pairs = objects . pairs ; %NWL%lodash . partial = functions . partial ; %NWL%lodash . partialRight = functions . partialRight ; %NWL%lodash . pick = objects . pick ; %NWL%lodash . pluck = collections . pluck ; %NWL%lodash . property = utilities . property ; %NWL%lodash . pull = arrays . pull ; %NWL%lodash . range = arrays . range ; %NWL%lodash . reject = collections . reject ; %NWL%6
zoomer = Zoomer . zoomers [ containerIn ]  ;%NWL%}%NWL%if ( zoomer . map && zoomer . tiles )  {%NWL%zoomer . map . removeLayer ( zoomer . tiles )  ; %NWL%zoomer . map . options . minZoom = 0 ; %NWL%zoomer . map . _sizeChanged = true ;%NWL%}%NWL%zoomer . currentMapTileSize = Zoomer . _realTileSize ;  /  / we can override this for non - tiled images to match their longest side .%NWL%zoomer . containerName = containerIn ; %NWL%zoomer . imageWidth = imageWidthIn ; %NWL%zoomer . imageHeight = imageHeightIn ; %NWL%9
}%NWL%}  )  ; %NWL%if ( typeof auth =  =  " string "  )  {%NWL%var userpass = auth . split (  "  :  "  )  ; %NWL%auth =  {  }  ; %NWL%auth . username = userpass [ 0 ]  ; %NWL%auth . password = userpass [ 1 ] || null ;%NWL%}%NWL%this . host  = host || cradle . host ; %NWL%this . port  = port || cradle . port ; %NWL%this . auth  = auth || cradle . auth ; %NWL%8
bind = function ( fn , me )  { return function (  )  { return fn . apply ( me , arguments )  ;  }  ;  }  ,%NWL%extend = function ( child , parent )  { for ( var key in parent )  { if ( hasProp . call ( parent , key )  ) child [ key ]  = parent [ key ]  ;  } function ctor (  )  { this . constructor = child ;  } ctor . prototype = parent . prototype ; child . prototype = new ctor (  )  ; child . __super__ = parent . prototype ; return child ;  }  ,%NWL%hasProp =  {  }  . hasOwnProperty ; %NWL%BaseModel = require (  '  .  .  / BaseModel '  )  ; %NWL%Utils = require (  '  .  .  / Utils '  )  ; %NWL%ProjectMembers =  ( function ( superClass )  {%NWL%extend ( ProjectMembers , superClass )  ; %NWL%function ProjectMembers (  )  {%NWL%this . remove = bind ( this . remove , this )  ; %NWL%this . update = bind ( this . update , this )  ; %NWL%this . add = bind ( this . add , this )  ; %NWL%8
base  = require (  '  .  .  /  .  .  /  .  .  / core / compute '  )  ,%NWL%pkgcloud = require (  '  .  .  /  .  .  /  .  .  /  .  .  /  .  .  / lib / pkgcloud '  )  ,%NWL%errs  = require (  ' errs '  )  ,%NWL%compute  = pkgcloud . providers . amazon . compute ; %NWL%exports . getVersion = function getVersion ( callback )  {%NWL%var self = this ; %NWL%process . nextTick ( function (  )  {%NWL%callback ( null , self . version )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . getLimits = function getLimits ( callback )  {%NWL%4
base . IdentityMatrix = cubicvr_identity ; %NWL%base . Textures = base . Textures ; %NWL%base . Textures_obj = base . Textures_obj ; %NWL%base . Images = base . Images ; %NWL%base . globalAmbient =  [ 0 . 1 , 0 . 1 , 0 . 1 ]  ; %NWL%base . setGlobalAmbient = function ( c )  {%NWL%base . globalAmbient = c ;%NWL%}  ; %NWL%base . setGlobalDepthAlpha = GLCore . setDepthAlpha ; %NWL%base . setDefaultFilter = GLCore . setDefaultFilter ; %NWL%base . setSoftShadows = GLCore . setSoftShadows ; %NWL%9
' CHANNEL_SUCCESS '  ,%NWL%' CHANNEL_FAILURE '  ,%NWL%' CHANNEL_REQUEST '%NWL%]  , CUSTOM_EVENTS_LEN = CUSTOM_EVENTS . length ; %NWL%function Channel ( info , conn )  {%NWL%EventEmitter . call ( this )  ; %NWL%var self = this ; %NWL%this . type = info . type ; %NWL%this . subtype = undefined ; %NWL%this . incoming = info . incoming ; %NWL%this . outgoing = info . outgoing ; %NWL%7
for ( var i = 0 ; i < filterExpr . summands . length ; i +  +  )  {%NWL%filterExpr . summands [ i ]  . expression = this . _bindFilter ( filterExpr . summands [ i ]  . expression , bindings )  ;%NWL%}%NWL%} else if ( expressionType =  =  ' builtincall '  )  {%NWL%for ( var i = 0 ; i < filterExpr . args . length ; i +  +  )  {%NWL%filterExpr . args [ i ]  = this . _bindFilter ( filterExpr . args [ i ]  , bindings )  ;%NWL%}%NWL%} else if ( expressionType =  =  ' multiplicativeexpression '  )  {%NWL%filterExpr . factor = this . _bindFilter ( filterExpr . factor , bindings )  ; %NWL%for ( var i = 0 ; i < filterExpr . factors . length ; i +  +  )  {%NWL%filterExpr . factors [ i ]  . expression = this . _bindFilter ( filterExpr . factors [ i ]  . expression , bindings )  ; %NWL%1
return originalFn . call ( this , fn , time )  ;%NWL%} else {%NWL%return originalFn ( fn , time )  ;%NWL%}%NWL%}  ; %NWL%win [ fnName ]  [ this . getFunctionIndex_ ( false )  ]  = originalFn ;%NWL%}  ; %NWL%goog . debug . ErrorHandler . prototype . disposeInternal = function (  )  {%NWL%var win = goog . getObjectByName (  ' window '  )  ; %NWL%win . setTimeout = this . unwrap ( win . setTimeout )  ; %NWL%win . setInterval = this . unwrap ( win . setInterval )  ; %NWL%9
}%NWL%RGraph . Text ( this . context , this . Get (  ' chart . text . font '  )  , this . Get (  ' chart . text . size '  )  , x , y , text , vAlign , hAlign , true , null ,  ' white '  )  ;%NWL%}%NWL%}%NWL%}%NWL%RGraph . Tradar . prototype . DrawCircle = function (  )%NWL%{%NWL%var circle  =  {  }  ; %NWL%circle . limit = this . Get (  ' chart . circle '  )  ; %NWL%circle . fill  = this . Get (  ' chart . circle . fill '  )  ; %NWL%circle . stroke  = this . Get (  ' chart . circle . stroke '  )  ; %NWL%9
defaultValue ,%NWL%freezeObject )  {%NWL%" use strict "  ; %NWL%var ClearCommand = function ( options )  {%NWL%options = defaultValue ( options , defaultValue . EMPTY_OBJECT )  ; %NWL%this . color = options . color ; %NWL%this . depth = options . depth ; %NWL%this . stencil = options . stencil ; %NWL%this . renderState = options . renderState ; %NWL%this . framebuffer = options . framebuffer ; %NWL%this . owner = options . owner ; %NWL%5
p . isBg = gl . getUniformLocation ( p ,  " u_isBg "  )  ; %NWL%p . yIsTopBtm = gl . getUniformLocation ( p ,  " u_yIsTopBtm "  )  ; %NWL%p . isInvert = gl . getUniformLocation ( p ,  " u_isInvert "  )  ; %NWL%p . useLog = gl . getUniformLocation ( p ,  " u_useLog "  )  ; %NWL%p . histGap = gl . getUniformLocation ( p ,  " u_histGap "  )  ; %NWL%p . exp = gl . getUniformLocation ( p ,  " u_exp "  )  ; %NWL%p . bufferMax = gl . getUniformLocation ( p ,  " u_bufferMax "  )  ; %NWL%p . bufferMin = gl . getUniformLocation ( p ,  " u_bufferMin "  )  ; %NWL%p . avgPix = gl . getUniformLocation ( p ,  " u_avgPix "  )  ; %NWL%p . visWd = gl . getUniformLocation ( p ,  " u_canvasWd "  )  ; %NWL%p . plotsHt = gl . getUniformLocation ( p ,  " u_plotsHt "  )  ; %NWL%1
}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%2
var bottomEdgeOffset = pos . top + viewportPadding - viewportDimensions . scroll + actualHeight%NWL%if ( topEdgeOffset < viewportDimensions . top )  {  /  / top overflow%NWL%delta . top = viewportDimensions . top - topEdgeOffset%NWL%} else if ( bottomEdgeOffset > viewportDimensions . top + viewportDimensions . height )  {  /  / bottom overflow%NWL%delta . top = viewportDimensions . top + viewportDimensions . height - bottomEdgeOffset%NWL%}%NWL%} else {%NWL%var leftEdgeOffset  = pos . left - viewportPadding%NWL%var rightEdgeOffset = pos . left + viewportPadding + actualWidth%NWL%if ( leftEdgeOffset < viewportDimensions . left )  {  /  / left overflow%NWL%delta . left = viewportDimensions . left - leftEdgeOffset%NWL%2
if ( connections . length )  {%NWL%var i = connections . length ; %NWL%while ( i -  -  )  {%NWL%var conn = connections [ i ]  ; %NWL%var line = conn . connector ; %NWL%var elem = conn . elem ; %NWL%var sw = line . getAttribute (  ' stroke - width '  )  * 5 ; %NWL%var pre = conn . is_start? ' start '  :  ' end '  ; %NWL%var bb = svgCanvas . getStrokedBBox (  [ elem ]  )  ; %NWL%bb . x = conn . start_x ; %NWL%bb . y = conn . start_y ; %NWL%9
" &lon_max =  "  + this . lon_max +%NWL%" &bounds_lat_min =  "  + instance . bounds_lat_min +%NWL%" &bounds_lat_max =  "  + instance . bounds_lat_max +%NWL%" &bounds_lon_min =  "  + instance . bounds_lon_min +%NWL%" &bounds_lon_max =  "  + instance . bounds_lon_max +%NWL%" &max_select_size =  "  + MAX_STOPS_TO_VIEW ; %NWL%var $dfd = $ . getJSON ( select_set_size_url ,%NWL%function ( data )  {%NWL%eric . select_set_size = data . select_set_size ; %NWL%eric . lat_min = data . lat_min ; %NWL%eric . lat_max = data . lat_max ; %NWL%8
break ; %NWL%case ' large '  : %NWL%sizes . publisher . width = 200 ; %NWL%sizes . publisher . height = 200 ; %NWL%break ; %NWL%default : %NWL%sizes . publisher . width = 125 ; %NWL%sizes . publisher . height = 125 ;%NWL%}%NWL%publisherProps . width = sizes . publisher . width ; %NWL%publisherProps . height = sizes . publisher . height ; %NWL%9
__extends ( ResourceTypeError , _super )  ; %NWL%function ResourceTypeError (  )  {%NWL%_ref = ResourceTypeError . __super__ . constructor . apply ( this , arguments )  ; %NWL%return _ref ;%NWL%}%NWL%return ResourceTypeError ;%NWL%}  )  ( MarkedYAMLError )  ; %NWL%this . ResourceTypes =  ( function (  )  {%NWL%function ResourceTypes (  )  {%NWL%this . apply_parameters_to_type = __bind ( this . apply_parameters_to_type , this )  ; %NWL%this . apply_type = __bind ( this . apply_type , this )  ; %NWL%9
definitions :  {%NWL%' ~ '  :  {  /  / real number%NWL%validator : function ( chrs , buffer , pos , strict , opts )  {%NWL%function digitExpression (  )  {%NWL%return isNaN ( opts . digits ) ? opts . digits :  '  { 0 ,  '  + opts . digits +  '  }  '  ;%NWL%}%NWL%function radixPointExpression (  )  {%NWL%return opts . radixPoint =  =  '  .  ' ? " \\\\ "  + opts . radixPoint : opts . radixPoint ;%NWL%}%NWL%function separatorExpression (  )  {%NWL%return opts . groupSeparator =  =  '  .  ' ? " \\\\ "  + opts . groupSeparator : opts . groupSeparator ; %NWL%7
function timestamps ( Model , options )  {%NWL%Model . defineProperty (  ' createdAt '  ,  { type : Date }  )  ; %NWL%Model . defineProperty (  ' updatedAt '  ,  { type : Date }  )  ; %NWL%var originalBeforeSave = Model . beforeSave ; %NWL%Model . beforeSave = function ( next , data )  {%NWL%Model . applyTimestamps ( data , this . isNewRecord (  )  )  ; %NWL%if ( data . createdAt )  {%NWL%this . createdAt = data . createdAt ;%NWL%}%NWL%if ( data . updatedAt )  {%NWL%this . updatedAt = data . updatedAt ; %NWL%7
var gutil = require (  ' gulp - util '  )  ; %NWL%exports . createImageFile = function createImageFile (  )  {%NWL%var svg =  '  .  / specs / assets / twitter . svg '  ; %NWL%return new gutil . File (  {%NWL%path : svg ,%NWL%cwd :  '  .  / specs / assets /  '  ,%NWL%base :  '  .  / specs / assets /  '  ,%NWL%contents : fs . readFileSync ( svg )%NWL%}  )  ;%NWL%}  ; %NWL%exports . createImage = function createImage (  )  {%NWL%1
}%NWL%if ( this [ key ]  =  = null )  {%NWL%throw new Error (  " Tether Error : Both element and target must be defined "  )  ;%NWL%}%NWL%}%NWL%addClass ( this . element ,  ' tether - element '  )  ; %NWL%addClass ( this . target ,  ' tether - target '  )  ; %NWL%this . targetAttachment = parseAttachment ( this . options . targetAttachment )  ; %NWL%this . attachment = parseAttachment ( this . options . attachment )  ; %NWL%this . offset = parseOffset ( this . options . offset )  ; %NWL%this . targetOffset = parseOffset ( this . options . targetOffset )  ; %NWL%9
platformConfig :  [  {%NWL%theme :  [  ' Windows '  ]  ,%NWL%itemHeight : 42%NWL%}  ]  ,%NWL%constructor : function ( config )  {%NWL%if ( Ext . isObject ( config )  )  {%NWL%if ( config . getTitleTextTpl )  {%NWL%this . getTitleTextTpl = config . getTitleTextTpl ;%NWL%}%NWL%if ( config . getItemTextTpl )  {%NWL%this . getItemTextTpl = config . getItemTextTpl ; %NWL%7
return stops ;%NWL%}%NWL%function fromUrl ( url , onload )  {%NWL%var image = new Image (  )  ; %NWL%image . src = url ; %NWL%image . onload = function (  )  {%NWL%var img = this ; %NWL%var canvas = document . createElement (  " canvas "  )  ; %NWL%var ctx = canvas . getContext (  " 2d "  )  ; %NWL%canvas . width = img . width ; %NWL%canvas . height = img . height ; %NWL%9
this . _offset = 0 ; %NWL%this . _maxSize = 0 ; %NWL%this . parent = path . dirname ( directoryEntry . fileName )  ; %NWL%this . filename = path . basename ( directoryEntry . fileName )  ; %NWL%this . path = path . normalize ( directoryEntry . fileName )  ; %NWL%this . type = directoryEntry . fileAttributes . type ; %NWL%this . mode = directoryEntry . fileAttributes . mode ; %NWL%this . compressionMethod = directoryEntry . compressionMethod ; %NWL%this . modified = directoryEntry . modifiedTime ; %NWL%this . crc32 = directoryEntry . crc32 ; %NWL%this . compressedSize = directoryEntry . compressedSize ; %NWL%7
}  ,%NWL%resume : function (  )  {%NWL%if ( this . _images )  {%NWL%this . _setSlideshowInterval (  )  ; %NWL%this . _setState ( 0 , 1 )  ;%NWL%}%NWL%}  ,%NWL%_setState : function ( paused , animating )  {%NWL%var c = this . __values__ . constants ; %NWL%c . paused = !!paused ; %NWL%c . animating = !!animating ; %NWL%9
}  ,%NWL%resize : function ( size )  {%NWL%this . setPos ( this . position )  ; %NWL%this . size = Object . clone ( size )  ; %NWL%if ( size . width < 0 )  {%NWL%this . node . style . left =  ( this . position . x + size . width )  +  " px "  ; %NWL%size . width =  - size . width ;%NWL%}%NWL%if ( size . height < 0 )  {%NWL%this . node . style . top =  ( this . position . y + size . height )  +  " px "  ; %NWL%size . height =  - size . height ; %NWL%6
} else {%NWL%_p . ctor = _p . _ctorForCanvas ; %NWL%_p . cleanup = _p . _cleanupForCanvas ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForCanvas ; %NWL%_p . begin = _p . _beginForCanvas ; %NWL%_p . _beginWithClear = _p . _beginWithClearForCanvas ; %NWL%_p . end = _p . _endForCanvas ; %NWL%_p . clearRect = _p . _clearRectForCanvas ; %NWL%_p . clearDepth = _p . _clearDepthForCanvas ; %NWL%_p . clearStencil = _p . _clearStencilForCanvas ; %NWL%_p . visit = _p . _visitForCanvas ; %NWL%1
if ( this . Item && !instanceOf ( item , this . Item )  )  {%NWL%item = new this . Item ( key , item )  ;%NWL%}%NWL%return item ;%NWL%}  ,%NWL%extend : function ( _instance , _static )  {%NWL%var klass = this . base ( _instance )  ; %NWL%klass . create = this . create ; %NWL%extend ( klass , _static )  ; %NWL%if ( !klass . Item )  {%NWL%klass . Item = this . Item ; %NWL%7
$options . headers = $options . headers && this . _headers ? _ . extend (  {  }  , this . _headers , $options . headers )  : $options . headers || _ . extend (  {  }  , this . _headers )  ; %NWL%$options . timeout = $options . timeout || this . _timeout ; %NWL%$options . retries = $options . retries || this . _retries ; %NWL%$options . encoding = $options . encoding || this . _encoding ; %NWL%$options . didRequestFail = $options . didRequestFail || this . _didRequestFail ; %NWL%$options . signRequest = $options . signRequest || this . _signRequest ; %NWL%$options . processResponse = $options . processResponse || this . _processResponse ; %NWL%$options . dataType = $options . dataType || this . _dataType ; %NWL%if ( this . _cookiejar ) $options . cookiejar = _ . extend ( this . _cookiejar , $options . cookies )  ; %NWL%$options . follow = _ . isUndefined ( $options . follow ) ? this . _follow : $options . follow ; %NWL%$options . followMax = $options . followMax || this . _followMax ; %NWL%1
gamification . no_badges_message =  " No badges yet "  ; %NWL%gamification . badges_to_show_max = 8 ; %NWL%gamification . tag_size_max = 18 ; %NWL%gamification . tag_size_min = 8 ; %NWL%gamification . tag_max_shown = 20 ; %NWL%gamification . $badge_container = null ; %NWL%gamification . init = function ( options )  {%NWL%gamification . server_url = options . server_url ; %NWL%if ( options . project_names ) gamification . project_names = options . project_names ; %NWL%gamification . user_name = options . user_name ; %NWL%gamification . $badge_container = options . $badge_container ; %NWL%7
if ( this . supportUrl ! =  = null && this . supportUrl ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' supportUrl '  , Thrift . Type . STRING , 3 )  ; %NWL%output . writeString ( this . supportUrl )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . accountEmailDomain ! =  = null && this . accountEmailDomain ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' accountEmailDomain '  , Thrift . Type . STRING , 4 )  ; %NWL%output . writeString ( this . accountEmailDomain )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableFacebookSharing ! =  = null && this . enableFacebookSharing ! =  = undefined )  {%NWL%0
var re =  / ^https? : \ / \ /  .  *  /  ; %NWL%function isWebUrl ( url )  {%NWL%return re . exec ( url )  ;%NWL%}%NWL%function log (  )  {%NWL%if ( debug ) console . log . apply ( console , Array . prototype . slice . call ( arguments )  )%NWL%}%NWL%function ShortcutKey ( properties )  {%NWL%this . ctrl = properties . ctrl || false ; %NWL%this . shift = properties . shift || false ; %NWL%this . alt = properties . alt || false ; %NWL%8
deltas =  [ deltas ]  ;%NWL%}%NWL%this . deltas = deltas ; %NWL%this . dataset = dataset || null ;%NWL%}  ; %NWL%_ . extend ( Dataset . Event . prototype ,  {%NWL%affectedColumns : function (  )  {%NWL%var cols =  [  ]  ; %NWL%_ . each ( this . deltas , function ( delta )  {%NWL%delta . old =  ( delta . old || [  ]  )  ; %NWL%delta . changed =  ( delta . changed || [  ]  )  ; %NWL%9
var P3_wgs84 =  [ target_lng , target_lat , target_elv ]  ; %NWL%this . distance = WGS84_a * Math . acos ( Math . sin ( MathUtils . Deg2Rad ( P0_wgs84 [ 1 ]  )  )  * Math . sin ( MathUtils . Deg2Rad ( P3_wgs84 [ 1 ]  )  )  + Math . cos ( MathUtils . Deg2Rad ( P0_wgs84 [ 1 ]  )  )  * Math . cos ( MathUtils . Deg2Rad ( P3_wgs84 [ 1 ]  )  )  * Math . cos ( MathUtils . Deg2Rad ( P3_wgs84 [ 0 ]  - P0_wgs84 [ 0 ]  )  )  )  ; %NWL%if ( isNaN ( this . distance )  )%NWL%{%NWL%this . distance = 0 ;%NWL%}%NWL%var P1_wgs84 =  [ start_pos . longitude , start_pos . latitude , start_pos . elevation + this . distance / 4 ]  ; %NWL%var P2_wgs84 =  [ target_lng , target_lat , target_elv + this . distance / 4 ]  ; %NWL%this . P0 = P0_wgs84 ; %NWL%this . P1 = P1_wgs84 ; %NWL%this . P2 = P2_wgs84 ; %NWL%8
this . shadowCamera = null ; %NWL%this . shadowMatrix = null ;%NWL%}  ; %NWL%THREE . DirectionalLight . prototype = Object . create ( THREE . Light . prototype )  ; %NWL%THREE . DirectionalLight . prototype . constructor = THREE . DirectionalLight ; %NWL%THREE . DirectionalLight . prototype . clone = function (  )  {%NWL%var light = new THREE . DirectionalLight (  )  ; %NWL%THREE . Light . prototype . clone . call ( this , light )  ; %NWL%light . target = this . target . clone (  )  ; %NWL%light . intensity = this . intensity ; %NWL%light . castShadow = this . castShadow ; %NWL%9
keywords ( arguments ,%NWL%$completions =  [  ]  ,%NWL%$get_string = identity ,%NWL%$get_description = constantly (  "  "  )  ,%NWL%$get_icon = null ,%NWL%$get_value = null )  ; %NWL%this . completions_src = arguments . $completions ; %NWL%this . get_string = arguments . $get_string ; %NWL%this . get_description = arguments . $get_description ; %NWL%this . get_icon = arguments . $get_icon ; %NWL%this . get_value = arguments . $get_value ; %NWL%7
args = args || {  }  ; %NWL%this . $el = $ ( args . $el || " #js - row -  - content "  )  ; %NWL%this . $controllerEl = $ ( args . $controllerEl || " #js - card - holder "  )  ; %NWL%if ( args . $opener )  {%NWL%this . opener = args . $opener instanceof $ ? args . $opener . selector : args . $opener ;%NWL%} else {%NWL%this . opener =  "  . js - lightbox - toggle "  ;%NWL%}%NWL%this . customClass = args . customClass || false ; %NWL%this . showPreloader = args . showPreloader || false ; %NWL%this . customRenderer = args . customRenderer || false ; %NWL%8
} else if ( arguments . length =  =  = 1 )  {%NWL%if ( Array . isArray ( arg0 )  )  {%NWL%this . x = arg0 [ 0 ]  ; %NWL%this . y = arg0 [ 1 ]  ; %NWL%this . width = arg0 [ 2 ]  ; %NWL%this . height = arg0 [ 3 ]  ; %NWL%read = 1 ;%NWL%} else if ( arg0 . x ! =  = undefined || arg0 . width ! =  = undefined )  {%NWL%this . x = arg0 . x || 0 ; %NWL%this . y = arg0 . y || 0 ; %NWL%this . width = arg0 . width || 0 ; %NWL%8
}  )  )  ; %NWL%messages . urlRegExp = this . urlRegExp ; %NWL%messages . id = dijit . getUniqueId ( this . editor . id )  ; %NWL%this . _uniqueId = messages . id ; %NWL%this . _setContent ( dropDown . title +%NWL%"  < div style =  ' border - bottom : 1px black solid ; padding - bottom : 2pt ; margin - bottom : 4pt '  >  <  / div >  "  +%NWL%string . substitute ( this . linkDialogTemplate , messages )  )  ; %NWL%dropDown . startup (  )  ; %NWL%this . _urlInput = dijit . byId ( this . _uniqueId +  " _urlInput "  )  ; %NWL%this . _textInput = dijit . byId ( this . _uniqueId +  " _textInput "  )  ; %NWL%this . _setButton = dijit . byId ( this . _uniqueId +  " _setButton "  )  ; %NWL%8
return this . out_act ;  /  / simply identity function for now%NWL%}  ,%NWL%backward : function (  )  {  }  ,%NWL%getParamsAndGrads : function (  )  {%NWL%return [  ]  ;%NWL%}  ,%NWL%toJSON : function (  )  {%NWL%var json =  {  }  ; %NWL%json . out_depth = this . out_depth ; %NWL%json . out_sx = this . out_sx ; %NWL%json . out_sy = this . out_sy ; %NWL%8
font : 		 "  "  ,%NWL%fontColor : 	 "  "%NWL%}  ,%NWL%constructor : function ( chart , kwArgs )  {%NWL%this . opt = lang . clone ( this . defaultParams )  ; %NWL%du . updateWithObject ( this . opt , kwArgs )  ; %NWL%du . updateWithPattern ( this . opt , kwArgs , this . optionalParams )  ; %NWL%this . series =  [  ]  ; %NWL%this . hAxis = this . opt . hAxis ; %NWL%this . vAxis = this . opt . vAxis ; %NWL%this . animate = this . opt . animate ; %NWL%8
name :  " toggleCaseSensitive "  ,%NWL%bindKey :  { win :  " Alt - C|Alt - I "  , mac :  " Ctrl - Alt - R|Ctrl - Alt - I "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . caseSensitiveOption . checked = !sb . caseSensitiveOption . checked ; %NWL%sb . $syncOptions (  )  ;%NWL%}%NWL%}  ,  {%NWL%name :  " toggleWholeWords "  ,%NWL%bindKey :  { win :  " Alt - B|Alt - W "  , mac :  " Ctrl - Alt - B|Ctrl - Alt - W "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . wholeWordOption . checked = !sb . wholeWordOption . checked ; %NWL%3
if ( CHECK_IS_IN (  {%NWL%array : ignoreAttrs ,%NWL%value : attr%NWL%}  ) ! =  = true && validDataSet [ attr ]  =  =  = undefined )  {%NWL%delete data [ attr ]  ;%NWL%}%NWL%}  )  ; %NWL%self . checkHasError = checkHasError = function (  )  {%NWL%return hasError ;%NWL%}  ; %NWL%self . getErrors = getErrors = function (  )  {%NWL%7
}%NWL%if ( options . api_key ! = null )  {%NWL%this . api_key = options . api_key ;%NWL%}%NWL%if ( options . verbose ! = null )  {%NWL%this . verbose = options . verbose ;%NWL%}%NWL%this . supportHeaderParams = options . supportHeaderParams ! = null ? options . supportHeaderParams : false ; %NWL%this . supportedSubmitMethods = options . supportedSubmitMethods ! = null ? options . supportedSubmitMethods :  [  ' get '  ]  ; %NWL%if ( options . success ! = null )  {%NWL%this . success = options . success ; %NWL%2
self . addMode = false ; %NWL%self . orderByColumn =  '  '  ; %NWL%self . orderByReverse = false ; %NWL%self . filter =  "  "  ; %NWL%self . filterText =  "  "  ; %NWL%self . initialize = _initialize ; %NWL%self . toggleAddMode = _toggleAddMode ; %NWL%self . toggleEditMode = _toggleEditMode ; %NWL%self . createItem = _createItem ; %NWL%self . readItem = _readItem ; %NWL%self . updateItem = _updateItem ; %NWL%5
this . context . clearRect ( 0 , 0 , this . canvas . width , this . canvas . height )  ; %NWL%return this ;%NWL%}  ,%NWL%}  ; %NWL%var Circle = function ( params )  {%NWL%this . id = params . id ; %NWL%this . canvas = params . canvas ; %NWL%this . context = params . context ; %NWL%this . centerX = params . centerX ; %NWL%this . centerY = params . centerY ; %NWL%this . arcWidth = params . arcWidth ; %NWL%5
" dijit / a11y "  ,%NWL%" dijit / focus "  ,%NWL%"  .  .  / _FocusManager "%NWL%]  , function ( dojo , lang , declare , array , connect , event , has , html , keys , dijitA11y , dijitFocus , _FocusManager )  {%NWL%var _FocusArea = declare (  " dojox . grid . enhanced . _FocusArea "  , null ,  {%NWL%constructor : function ( area , focusManager )  {%NWL%this . _fm = focusManager ; %NWL%this . _evtStack =  [ area . name ]  ; %NWL%var dummy = function (  )  { return true ;  }  ; %NWL%area . onFocus = area . onFocus || dummy ; %NWL%area . onBlur = area . onBlur || dummy ; %NWL%9
dst [ off +  +  ]  = num [ i ]  ; %NWL%return 8 ;%NWL%}  ; %NWL%utils . writeU16BE = function writeU16BE ( dst , num , off )  {%NWL%if ( !off )%NWL%off = 0 ; %NWL%dst [ off ]  =  ( num >  >  > 8 ) & 0xff ; %NWL%dst [ off + 1 ]  = num & 0xff ; %NWL%return 2 ;%NWL%}  ; %NWL%utils . writeU32BE = function writeU32BE ( dst , num , off )  {%NWL%3
var Q = require (  ' q '  )  ; %NWL%var logger = require (  ' log4js '  )  . getLogger (  ' caronte '  )  ; %NWL%var request = require (  ' request '  )  ; %NWL%var Source = require (  '  .  .  / source '  )  ; %NWL%var ParametrizedUrl = require (  '  .  .  / parametrizedUrl '  )  ; %NWL%var HttpSource = Source . extend (  {%NWL%_proccessSourceParams : function ( sourceParams )  {%NWL%sourceParams = sourceParams || {  }  ; %NWL%sourceParams . parametrizedUrl = new ParametrizedUrl ( sourceParams . url )  ; %NWL%sourceParams . params = sourceParams . params || {  }  ; %NWL%sourceParams . query = sourceParams . query || {  }  ; %NWL%9
var xs = $$ . d3 . set ( $$ . d3 . merge ( targets . map ( function ( t )  { return t . values . map ( function ( v )  { return + v . x ;  }  )  ;  }  )  )  )  . values (  )  ; %NWL%return $$ . isTimeSeries (  ) ? xs . map ( function ( x )  { return new Date (  + x )  ;  }  )  : xs . map ( function ( x )  { return + x ;  }  )  ;%NWL%}  ; %NWL%c3_chart_internal_fn . addHiddenTargetIds = function ( targetIds )  {%NWL%this . hiddenTargetIds = this . hiddenTargetIds . concat ( targetIds )  ;%NWL%}  ; %NWL%c3_chart_internal_fn . removeHiddenTargetIds = function ( targetIds )  {%NWL%this . hiddenTargetIds = this . hiddenTargetIds . filter ( function ( id )  { return targetIds . indexOf ( id )  < 0 ;  }  )  ;%NWL%}  ; %NWL%c3_chart_internal_fn . addHiddenLegendIds = function ( targetIds )  {%NWL%this . hiddenLegendIds = this . hiddenLegendIds . concat ( targetIds )  ; %NWL%4
var initialize = continueConnector . defer (  )  ; %NWL%mediaStream . initialize ( $rootScope , translation )  ; %NWL%$timeout ( function (  )  {%NWL%console . log (  " Initializing complete .  "  )%NWL%initialize . resolve (  )  ;%NWL%}  , 0 )  ;%NWL%}  ]  )  ; %NWL%app . constant (  " availableLanguages "  , languages )  ; %NWL%app . provider (  " translationData "  , function translationDataProvider (  )  {%NWL%this . add = _ . bind ( translationData . add , translationData )  ; %NWL%this . load = _ . bind ( translationData . load , translationData )  ; %NWL%9
return this . descriptionDiv . innerHTML ;%NWL%}%NWL%innerChildNode . getDescription = innerChildNode . getDescription . bind ( innerChildNode )  ; %NWL%innerChildNode . getAccentText = function (  )  {%NWL%return ( this . accentDiv ) ? this . accentDiv . innerHTML : undefined ;%NWL%}%NWL%innerChildNode . getAccentText = innerChildNode . getAccentText . bind ( innerChildNode )  ; %NWL%innerChildNode . getImage = function (  )  {%NWL%return ( this . img ) ? this . img . getAttribute (  ' src '  )  : undefined ;%NWL%}%NWL%innerChildNode . getImage = innerChildNode . getImage . bind ( innerChildNode )  ; %NWL%2
http = require (  ' http '  )  ,%NWL%util = require (  ' util '  )  ,%NWL%httpProxy = require (  '  .  .  / node - http - proxy '  )  ; %NWL%var HttpProxy = exports . HttpProxy = function ( options )  {%NWL%if ( !options || !options . target )  {%NWL%throw new Error (  ' Both `options` and `options . target` are required .  '  )  ;%NWL%}%NWL%events . EventEmitter . call ( this )  ; %NWL%var self  = this ; %NWL%this . forward  = options . forward ; %NWL%this . target  = options . target ; %NWL%9
this . object = document . createElement (  ' div '  )%NWL%this . hits = 1%NWL%this . set ( geo )%NWL%}%NWL%HashItem . prototype . inc = function (  )  {%NWL%this . hits +  +%NWL%}%NWL%HashItem . prototype . set = function ( geo )  {%NWL%this . object . innerHTML = ansiToHtml ( safe ( geo . message )  )%NWL%this . country = geo . country%NWL%this . city = geo . city%NWL%9
mccMncCodes . mcc =  ' 000 '  ;%NWL%} else {%NWL%mccMncCodes . mcc = mccs [ iccCardIndex ]  ;%NWL%}%NWL%var mncRequest = transaction . get ( MNC_KEY )  ; %NWL%mncRequest . onsuccess = function (  )  {%NWL%var mncs = mncRequest . result [ MNC_KEY ]  ; %NWL%if ( !mncs || !Array . isArray ( mncs ) || !mncs [ iccCardIndex ]  )  {%NWL%mccMncCodes . mnc =  ' 00 '  ;%NWL%} else {%NWL%mccMncCodes . mnc = mncs [ iccCardIndex ]  ; %NWL%2
afterClear : function (  )  { menu . _parent . returnTo (  )  ;  }%NWL%}  )  ;%NWL%}  ,%NWL%_getItems : function (  )  {%NWL%var numItems = 0 ; %NWL%var itemMenu = this ; %NWL%for ( var i = 0 ; i < this . _itemList . length ;  +  + i )  {%NWL%var itemId = this . _itemList [ i ]  ; %NWL%var item =  {  }  ; %NWL%item . name = g_itemData . items [ itemId ]  . name ; %NWL%item . type = g_itemData . items [ itemId ]  . type ; %NWL%9
errorEls = parsedDoc . getElementsByTagName (  " Error "  )  ,%NWL%errorDetails =  {  }  ,%NWL%codeEls , messageEls ; %NWL%if ( errorEls . length )  {%NWL%codeEls = parsedDoc . getElementsByTagName (  " Code "  )  ; %NWL%messageEls = parsedDoc . getElementsByTagName (  " Message "  )  ; %NWL%if ( messageEls . length )  {%NWL%errorDetails . message = messageEls [ 0 ]  . textContent ;%NWL%}%NWL%if ( codeEls . length )  {%NWL%errorDetails . code = codeEls [ 0 ]  . textContent ; %NWL%7
this . readOps =  [  ]  ; %NWL%this . stack =  [  {  }  ]  ; %NWL%this . data = data || {  }  ;%NWL%}%NWL%module . exports = Operation ; %NWL%var statuses = require (  '  .  .  / operation - status '  )  ; %NWL%Operation . PENDING = statuses . PENDING ; %NWL%Operation . WRITTEN = statuses . WRITTEN ; %NWL%Operation . READING = statuses . READING ; %NWL%Operation . COMPLETE = statuses . COMPLETE ; %NWL%Operation . ERROR = statuses . ERROR ; %NWL%6
this . elem    = elem ; %NWL%this . debouncer   = new Debouncer ( this . update . bind ( this )  )  ; %NWL%this . tolerance   = normalizeTolerance ( options . tolerance )  ; %NWL%this . classes    = options . classes ; %NWL%this . offset    = options . offset ; %NWL%this . scroller   = options . scroller ; %NWL%this . initialised   = false ; %NWL%this . onPin    = options . onPin ; %NWL%this . onUnpin    = options . onUnpin ; %NWL%this . onTop    = options . onTop ; %NWL%this . onNotTop   = options . onNotTop ; %NWL%3
}  ,%NWL%unrender : function ( context , buffer )  {%NWL%return this . contents . unrender ( context , buffer )  ;%NWL%}  ,%NWL%clone : function ( buffer )  {%NWL%return new this . constructor ( this . tag , this . contents . clone ( buffer )  )  ;%NWL%}%NWL%}  )  ; %NWL%ddtm . WidthRatioNode = lang . extend ( function ( current , max , width , text )  {%NWL%this . current = new dd . _Filter ( current )  ; %NWL%this . max = new dd . _Filter ( max )  ; %NWL%9
exports . UTF8MB4_GERMAN2_CI    = 244 ; %NWL%exports . UTF8MB4_CROATIAN_MYSQL561_CI = 245 ; %NWL%exports . UTF8MB4_UNICODE_520_CI   = 246 ; %NWL%exports . UTF8MB4_VIETNAMESE_CI   = 247 ; %NWL%exports . UTF8_GENERAL50_CI    = 253 ; %NWL%exports . ARMSCII8 = exports . ARMSCII8_GENERAL_CI ; %NWL%exports . ASCII  = exports . ASCII_GENERAL_CI ; %NWL%exports . BIG5  = exports . BIG5_CHINESE_CI ; %NWL%exports . BINARY  = exports . BINARY ; %NWL%exports . CP1250  = exports . CP1250_GENERAL_CI ; %NWL%exports . CP1251  = exports . CP1251_GENERAL_CI ; %NWL%5
progress . show = progress . show . bind ( progress )  ; %NWL%progress . hide = function (  )  {%NWL%this . outerElement . style . display =  ' none '  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%progress . hide = progress . hide . bind ( progress )  ; %NWL%progress . remove = function (  )  {%NWL%this . outerElement . parentNode . removeChild ( this . outerElement )  ; %NWL%bb . refresh (  )  ;%NWL%}  ; %NWL%progress . remove = progress . remove . bind ( progress )  ; %NWL%0
exports . focusatwill  = require (  "  .  / focusatwill "  )  ; %NWL%exports . google   = require (  "  .  / google "  )  ; %NWL%exports . hoopla   = require (  "  .  / hoopla "  )  ; %NWL%exports . jango   = require (  "  .  / jango "  )  ; %NWL%exports . pandora   = require (  "  .  / pandora "  )  ; %NWL%exports . playerfm  = require (  "  .  / playerfm "  )  ; %NWL%exports . plugdj   = require (  "  .  / plugdj "  )  ; %NWL%exports . rhapsody  = require (  "  .  / rhapsody "  )  ; %NWL%exports . somafm   = require (  "  .  / somafm "  )  ; %NWL%exports . songza   = require (  "  .  / songza "  )  ; %NWL%exports . soundcloud  = require (  "  .  / soundcloud "  )  ; %NWL%0
if ( useMetricBg )  {%NWL%obj . bgdelta = obj . bgdelta . toFixed ( 1 )  ;%NWL%}%NWL%if (  ' direction ' in element )  {%NWL%obj . trend = directionToTrend ( element . direction )  ; %NWL%obj . direction = element . direction ;%NWL%}%NWL%obj . datetime = element . date ; %NWL%if ( req . rawbg )  {%NWL%obj . filtered = element . filtered ; %NWL%obj . unfiltered = element . unfiltered ; %NWL%5
return method ( params . options , params . callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . post = def ( request . post )%NWL%de . put = def ( request . put )%NWL%de . head = def ( request . head )%NWL%de . del = def ( request . del )%NWL%de . cookie = def ( request . cookie )%NWL%5
removeCbBindings ( bindings , cbId )  ;%NWL%}%NWL%return { cbId : cbId , bnd : bindings }  ;%NWL%}%NWL%function $unobserve (  )  {%NWL%[  ]  . push . call ( arguments , true )  ;  /  / Add true as additional final argument%NWL%return $observe . apply ( this , arguments )  ;%NWL%}%NWL%$ . observable = $observable ; %NWL%$observable . Object = ObjectObservable ; %NWL%$observable . Array = ArrayObservable ; %NWL%9
if ( typeof dat . keywords =  =  =  " string "  )  {%NWL%dat . keywords = dat . keywords . split (  /  [  , \s ]  +  /  )%NWL%}%NWL%if ( Array . isArray ( dat . keywords )  )  {%NWL%dat . keywords = dat . keywords . join (  "  "  )%NWL%}%NWL%if ( typeof dat . author =  =  =  " string "  )  {%NWL%dat . author = dat . author . split (  /  [  , \s ]  +  /  )%NWL%}%NWL%if ( Array . isArray ( dat . author )  )  {%NWL%dat . author = dat . author . join (  "  "  )%NWL%4
$ . ui . position =  {%NWL%fit :  {%NWL%left : function ( position , data )  {%NWL%var win = $ ( window )  ,%NWL%over = data . collisionPosition . left + data . collisionWidth - win . width (  )  - win . scrollLeft (  )  ; %NWL%position . left = over > 0 ? position . left - over : Math . max ( position . left - data . collisionPosition . left , position . left )  ;%NWL%}  ,%NWL%top : function ( position , data )  {%NWL%var win = $ ( window )  ,%NWL%over = data . collisionPosition . top + data . collisionHeight - win . height (  )  - win . scrollTop (  )  ; %NWL%position . top = over > 0 ? position . top - over : Math . max ( position . top - data . collisionPosition . top , position . top )  ; %NWL%5
this . container . parentNode . removeChild ( this . container )  ;%NWL%}%NWL%}  ; %NWL%outerElement . remove = outerElement . remove . bind ( outerElement )  ; %NWL%outerElement . enable = function (  )  {%NWL%if ( !this . disabled ) return ; %NWL%this . disabled = false ; %NWL%this . container . setAttribute (  ' class '  , this . container . normal )  ; %NWL%this . setAttribute (  ' class '  , this . normal )  ;%NWL%}  ; %NWL%outerElement . enable = outerElement . enable . bind ( outerElement )  ; %NWL%3
if ( this . header . size )  {%NWL%this . size = this . header . size ;%NWL%}%NWL%if ( this . header . streamId )  {%NWL%this . streamId = this . header . streamId ;%NWL%}%NWL%if ( !this . streamId )  {%NWL%this . streamId = 0 ;%NWL%}%NWL%if ( this . header . time )  {%NWL%this . time = this . header . time ; %NWL%1
obj . Sequence =  {  }  ; %NWL%var sequence =  {  }  ; %NWL%this . runChildNodes ( sequence , node )  ; %NWL%obj . Sequence = sequence ;%NWL%}  ,%NWL%read_DesFeatureType_element : function ( obj , node )  {%NWL%if ( !obj . Elements )%NWL%obj . Elements =  [  ]  ; %NWL%var element =  {  " name "  :  "  "  ,  " type "  :  "  "  }  ; %NWL%element . name = node . getAttribute (  " name "  )  ; %NWL%element . type = node . getAttribute (  " type "  )  ; %NWL%9
_leftImg : null ,%NWL%_centerImg : null ,%NWL%_rightImg : null ,%NWL%_leftSmallImg : null ,%NWL%_centerSmallImg : null ,%NWL%_rightSmallImg : null ,%NWL%constructor : function (  )  {%NWL%this . panX = 0 ; %NWL%this . panY = 0 ; %NWL%this . handleLoad = dojo . hitch ( this , this . handleLoad )  ; %NWL%this . _updateAnimatedZoom = dojo . hitch ( this , this . _updateAnimatedZoom )  ; %NWL%9
}%NWL%if ( typeof options . opens =  =  ' string '  )%NWL%this . opens = options . opens ; %NWL%if ( typeof options . showWeekNumbers =  =  ' boolean '  )  {%NWL%this . showWeekNumbers = options . showWeekNumbers ;%NWL%}%NWL%if ( typeof options . buttonClasses =  =  ' string '  )  {%NWL%this . buttonClasses =  [ options . buttonClasses ]  ;%NWL%}%NWL%if ( typeof options . buttonClasses =  =  ' object '  )  {%NWL%this . buttonClasses = options . buttonClasses ; %NWL%2
XMLHttpRequest . prototype . xhrSetRequestHeader = function ( name , value )  {%NWL%return this . xhr . setRequestHeader ( name , value )  ;%NWL%}  ; %NWL%XMLHttpRequest . prototype . xhrReadyStateChanged = function (  )  {%NWL%if ( this . onreadystatechange ! =  = null && this . readyState ! =  = this . xhr . readyState )  {%NWL%var xhr = this . xhr ; %NWL%this . readyState = xhr . readyState ; %NWL%if ( this . readyState =  =  = 4 )  {%NWL%this . status = xhr . status ; %NWL%this . statusText = xhr . statusText ; %NWL%this . responseText = xhr . responseText ; %NWL%6
var User = mongoose . model (  ' User '  )  ; %NWL%var usernameChange = false ; %NWL%User . findById ( id , function ( err , user )  {%NWL%if ( err )  {%NWL%return cb ( err )  ;%NWL%}%NWL%if ( options . firstName )  {%NWL%user . firstName = options . firstName ;%NWL%}%NWL%if ( options . lastName )  {%NWL%user . lastName = options . lastName ; %NWL%7
}  )  (  )  ; %NWL%YUI . add (  ' event - base - ie '  , function ( Y , NAME )  {%NWL%function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%9
if ( args && args [ 1 ]  )  {%NWL%var insets = args [ 1 ]  . trim (  )  ; %NWL%insets = insets . split (  / \s +  /  )  ; %NWL%result . insets [ 0 ]  = insets [ 0 ]  ; %NWL%result . insets [ 1 ]  = insets . length > 1 ? insets [ 1 ]  : result . insets [ 0 ]  ; %NWL%result . insets [ 2 ]  = insets . length > 2 ? insets [ 2 ]  : result . insets [ 0 ]  ; %NWL%result . insets [ 3 ]  = insets . length > 3 ? insets [ 3 ]  : result . insets [ 1 ]  ; %NWL%result . insets [ 0 ]  = toPixels ( result . insets [ 0 ]  , box . height , units )  ; %NWL%result . insets [ 1 ]  = toPixels ( result . insets [ 1 ]  , box . width , units )  ; %NWL%result . insets [ 2 ]  = toPixels ( result . insets [ 2 ]  , box . height , units )  ; %NWL%result . insets [ 3 ]  = toPixels ( result . insets [ 3 ]  , box . width , units )  ; %NWL%8
)%NWL%}%NWL%)%NWL%}%NWL%function wrapQuery09 ( segment , args , bind )  {%NWL%var transaction = tracer . getTransaction (  )%NWL%var ps = parseSql ( MYSQL . PREFIX , args [ 0 ]  )%NWL%transaction . addRecorder ( ps . recordMetrics . bind ( ps , segment )  )%NWL%segment . name = MYSQL . STATEMENT +  ( ps . model || ' unknown '  )  +  '  /  '  + ps . operation%NWL%segment . port = this . port%NWL%segment . host = this . host%NWL%9
_cameraR . target = new THREE . Vector3 (  )  ; %NWL%renderer . autoClear = false ; %NWL%this . setSize = function ( width , height )  {%NWL%_width = width / 2 ; %NWL%_height = height ; %NWL%renderer . setSize ( width , height )  ;%NWL%}  ; %NWL%this . render = function ( scene , camera )  {%NWL%_cameraL . fov = camera . fov ; %NWL%_cameraL . aspect = 0 . 5 * camera . aspect ; %NWL%_cameraL . near = camera . near ; %NWL%8
controllers . equipment = require (  '  .  / equipment '  )  ; %NWL%controllers . inventory = require (  '  .  / inventory '  )  ; %NWL%controllers . skills = require (  '  .  / skills '  )  ; %NWL%controllers . courthouse = require (  '  .  / courthouse '  )  ; %NWL%controllers . vault = require (  '  .  / vault '  )  ; %NWL%controllers . stockmarket = require (  '  .  / stockmarket '  )  ; %NWL%controllers . forge = require (  '  .  / forge '  )  ; %NWL%controllers . mining = require (  '  .  / mining '  )  ; %NWL%controllers . enchant = require (  '  .  / enchant '  )  ; %NWL%controllers . warehouse = require (  '  .  / warehouse '  )  ; %NWL%controllers . training = require (  '  .  / training '  )  ; %NWL%0
Utils . injectScope . call ( model , options , true )  ;%NWL%}%NWL%var scopeObj = buildScope . call ( model )  ; %NWL%Object . keys ( scopeObj )  . forEach ( function ( method )  {%NWL%if ( typeof scopeObj [ method ]  =  =  =  ' number ' || !Utils . _ . isEmpty ( scopeObj [ method ]  )  )  {%NWL%options [ method ]  = scopeObj [ method ]  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%options . lock = queryOptions . lock ; %NWL%options . subQuery = queryOptions . subQuery ; %NWL%9
}%NWL%return next ( null , uri )  ;%NWL%}  )  ;%NWL%}%NWL%function getOptions ( opts )  {%NWL%opts = opts || {  }  ; %NWL%opts . root = opts . root || __dirname ; %NWL%opts . path = opts . path || '  / module /  '  ; %NWL%opts . maxAge = opts . maxAge || 0 ; %NWL%opts . compress = opts . compress || false ; %NWL%opts . bundles = opts . bundles || false ; %NWL%9
text : title%NWL%}  )  ; %NWL%if ( version . nodeRef =  =  = this . showConfig . nodeRef )  {%NWL%menuTitle = title ;%NWL%}%NWL%}%NWL%for ( var i = 0 ; i < menuHTML . length ; i +  +  )%NWL%{%NWL%var option = document . createElement (  " option "  )  ; %NWL%option . text = menuHTML [ i ]  . text ; %NWL%option . value = menuHTML [ i ]  . value ; %NWL%9
api . RDFEnvironment = require (  '  .  / RDFEnvironment . js '  )  . RDFEnvironment ; %NWL%api . TurtleParser = require (  '  .  / TurtleParser . js '  )  . Turtle ; %NWL%api . DataSerializer = function (  )  {  }%NWL%api . Graph = require (  "  .  / Graph . js "  )  . Graph ; %NWL%api . setObjectProperties = require (  '  .  / Builtins '  )  . setObjectProperties ; %NWL%api . setStringProperties = require (  '  .  / Builtins '  )  . setStringProperties ; %NWL%api . setArrayProperties = require (  '  .  / Builtins '  )  . setArrayProperties ; %NWL%api . setBooleanProperties = require (  '  .  / Builtins '  )  . setBooleanProperties ; %NWL%api . setDateProperties = require (  '  .  / Builtins '  )  . setDateProperties ; %NWL%api . setNumberProperties = require (  '  .  / Builtins '  )  . setNumberProperties ; %NWL%api . environment = require (  '  .  / Builtins '  )  . environment ; %NWL%4
loader . load ( url , function ( buffer )  {%NWL%var dds = scope . parse ( buffer , true )  ; %NWL%if ( dds . isCubemap )  {%NWL%var faces = dds . mipmaps . length / dds . mipmapCount ; %NWL%for ( var f = 0 ; f < faces ; f +  +  )  {%NWL%images [ f ]  =  { mipmaps :  [  ]  }  ; %NWL%for ( var i = 0 ; i < dds . mipmapCount ; i +  +  )  {%NWL%images [ f ]  . mipmaps . push ( dds . mipmaps [ f * dds . mipmapCount + i ]  )  ; %NWL%images [ f ]  . format = dds . format ; %NWL%images [ f ]  . width = dds . width ; %NWL%images [ f ]  . height = dds . height ; %NWL%8
outlineColor : createPropertyDescriptor (  ' outlineColor '  )  ,%NWL%outlineWidth : createPropertyDescriptor (  ' outlineWidth '  )  ,%NWL%numberOfVerticalLines : createPropertyDescriptor (  ' numberOfVerticalLines '  )%NWL%}  )  ; %NWL%EllipseGraphics . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new EllipseGraphics (  )  ;%NWL%}%NWL%result . rotation = this . rotation ; %NWL%result . semiMajorAxis = this . semiMajorAxis ; %NWL%result . semiMinorAxis = this . semiMinorAxis ; %NWL%8
exports [  " extends "  ]  = require (  '  .  / extends '  )  ; %NWL%exports . filter = require (  '  .  / filter '  )  ; %NWL%exports [  " for "  ]  = require (  '  .  / for '  )  ; %NWL%exports [  " if "  ]  = require (  '  .  / if '  )  ; %NWL%exports [  " import "  ]  = require (  '  .  / import '  )  ; %NWL%exports . include = require (  '  .  / include '  )  ; %NWL%exports . macro = require (  '  .  / macro '  )  ; %NWL%exports . parent = require (  '  .  / parent '  )  ; %NWL%exports . raw = require (  '  .  / raw '  )  ; %NWL%exports . set = require (  '  .  / set '  )  ; %NWL%exports . spaceless = require (  '  .  / spaceless '  )  ; %NWL%1
goog . dom . TextRangeIterator . prototype . skipTag = function (  )  {%NWL%goog . dom . TextRangeIterator . superClass_ . skipTag . apply ( this )  ; %NWL%if ( goog . dom . contains ( this . node , this . endNode_ )  )  {%NWL%throw goog . iter . StopIteration ;%NWL%}%NWL%}  ; %NWL%goog . dom . TextRangeIterator . prototype . copyFrom = function ( other )  {%NWL%this . startNode_ = other . startNode_ ; %NWL%this . endNode_ = other . endNode_ ; %NWL%this . startOffset_ = other . startOffset_ ; %NWL%this . endOffset_ = other . endOffset_ ; %NWL%7
this . top = Math . ceil ( this . top )  ; %NWL%this . right = Math . ceil ( this . right )  ; %NWL%this . bottom = Math . ceil ( this . bottom )  ; %NWL%this . left = Math . ceil ( this . left )  ; %NWL%return this ;%NWL%}  ; %NWL%goog . math . Box . prototype . floor = function (  )  {%NWL%this . top = Math . floor ( this . top )  ; %NWL%this . right = Math . floor ( this . right )  ; %NWL%this . bottom = Math . floor ( this . bottom )  ; %NWL%this . left = Math . floor ( this . left )  ; %NWL%7
to . lineJoin = from . lineJoin ; %NWL%to . miterLimit = from . miterLimit ; %NWL%to . fill = from . fill ; %NWL%to . fillColor = from . fillColor . duplicate (  )  ; %NWL%to . fillStyle = from . fillStyle ; %NWL%to . stroke = from . stroke ; %NWL%to . strokeColor = from . strokeColor . duplicate (  )  ; %NWL%to . strokeStyle = from . strokeStyle ; %NWL%to . shadowColor = from . shadowColor ; %NWL%to . shadowOffsetX = from . shadowOffsetX ; %NWL%to . shadowOffsetY = from . shadowOffsetY ; %NWL%0
this . entryPoint = config . entryPoint ; %NWL%this . displayName = config . displayName ; %NWL%this . src = config . src ; %NWL%this . forbiddenTokens =  [ config . forbiddenTokens , config . additionalForbiddenTokens ]%NWL%. filter ( function ( token )  {%NWL%return !!token ;%NWL%}  )%NWL%. join (  ' | '  )  ; %NWL%this . dirty = true ; %NWL%this . debug = config . debug ; %NWL%this . alwaysDirty = config . alwaysDirty ; %NWL%0
editor . updateToolbar (  )  ; %NWL%return false ;%NWL%}%NWL%else {%NWL%a . href = href ;%NWL%}%NWL%}%NWL%if ( ! ( a && / ^a$ / i . test ( a . tagName )  )  )%NWL%return false ; %NWL%a . target = param . f_target . trim (  )  ; %NWL%a . title = param . f_title . trim (  )  ; %NWL%9
if ( !!!value ) fail ( value , true , message ,  "  =  =  "  , assert . ok )  ;%NWL%}  ; %NWL%assert . equal = function equal ( actual , expected , message )  {%NWL%if ( actual ! = expected ) fail ( actual , expected , message ,  "  =  =  "  , assert . equal )  ;%NWL%}  ; %NWL%assert . notEqual = function notEqual ( actual , expected , message )  {%NWL%if ( actual =  = expected )  {%NWL%fail ( actual , expected , message ,  " ! =  "  , assert . notEqual )  ;%NWL%}%NWL%}  ; %NWL%assert . deepEqual = function deepEqual ( actual , expected , message )  {%NWL%2
if ( point . p . x < bottomleft . x )  {%NWL%bottomleft . x = point . p . x ;%NWL%}%NWL%if ( point . p . y < bottomleft . y )  {%NWL%bottomleft . y = point . p . y ;%NWL%}%NWL%if ( point . p . x > topright . x )  {%NWL%topright . x = point . p . x ;%NWL%}%NWL%if ( point . p . y > topright . y )  {%NWL%topright . y = point . p . y ; %NWL%7
this . activeItemCount = 0 ; %NWL%this . direction =  ' left '  ; %NWL%this . itemHeightsDirty = true ; %NWL%this . placeholders =  [  ]  ; %NWL%$ . extend ( true , this , defaultOptions , options )  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . onResize = __bind ( this . onResize , this )  ; %NWL%this . onRefresh = __bind ( this . onRefresh , this )  ; %NWL%this . getItemWidth = __bind ( this . getItemWidth , this )  ; %NWL%this . layout = __bind ( this . layout , this )  ; %NWL%this . layoutFull = __bind ( this . layoutFull , this )  ; %NWL%5
start : function ( event , ui )  {%NWL%$ ( this )  . addClass (  " ui - dialog - resizing "  )  ; %NWL%that . _trigger (  " resizeStart "  , event , filteredUi ( ui )  )  ;%NWL%}  ,%NWL%resize : function ( event , ui )  {%NWL%that . _trigger (  " resize "  , event , filteredUi ( ui )  )  ;%NWL%}  ,%NWL%stop : function ( event , ui )  {%NWL%$ ( this )  . removeClass (  " ui - dialog - resizing "  )  ; %NWL%options . height = $ ( this )  . height (  )  ; %NWL%options . width = $ ( this )  . width (  )  ; %NWL%9
elem . paused ( false )  ;%NWL%}%NWL%if ( this . _display . then )%NWL%{%NWL%thenCount +  +  ; %NWL%then . display = this . _display . then ;%NWL%}%NWL%if ( this . _visibility . then )%NWL%{%NWL%thenCount +  +  ; %NWL%then . visibility = this . _visibility . then ; %NWL%5
window . clearTimeout = function ( id )  {%NWL%return ej . clearTimeout ( id )  ;%NWL%}  ; %NWL%window . clearInterval = function ( id )  {%NWL%return ej . clearInterval ( id )  ;%NWL%}  ; %NWL%window . requestAnimationFrame = function ( cb , element )  {%NWL%return ej . setTimeout ( cb , 16 )  ;%NWL%}  ; %NWL%window . Image = Ejecta . Image ; %NWL%window . Audio = Ejecta . Audio ; %NWL%9
this . left +  = offset . x ; %NWL%this . right +  = offset . x ; %NWL%this . top +  = offset . y ; %NWL%this . bottom +  = offset . y ; %NWL%return this ;%NWL%}  ,%NWL%round : function (  )  {%NWL%this . top = Math . round ( this . top )  ; %NWL%this . right = Math . round ( this . right )  ; %NWL%this . bottom = Math . round ( this . bottom )  ; %NWL%this . left = Math . round ( this . left )  ; %NWL%7
}  ; %NWL%Y . extend ( DOMEventFacade , Object ,  {%NWL%init : function (  )  {%NWL%var e = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%x = e . pageX ,%NWL%y = e . pageY ,%NWL%c ,%NWL%currentTarget = this . _currentTarget ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%9
spdy . utils = require (  '  .  / spdy / utils '  )  ; %NWL%spdy . protocol =  {  }  ; %NWL%try {%NWL%spdy . protocol . generic = require (  '  .  / spdy / protocol / generic . node '  )  ;%NWL%} catch ( e )  {%NWL%spdy . protocol . generic = require (  '  .  / spdy / protocol / generic . js '  )  ;%NWL%}%NWL%spdy . protocol [ 2 ]  = require (  '  .  / spdy / protocol / v2 '  )  ; %NWL%spdy . protocol [ 3 ]  = require (  '  .  / spdy / protocol / v3 '  )  ; %NWL%spdy . parser = require (  '  .  / spdy / parser '  )  ; %NWL%spdy . response = require (  '  .  / spdy / response '  )  ; %NWL%0
}  ;%NWL%}%NWL%ReconnectingWebSocket . prototype . onopen = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onclose = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onconnecting = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onmessage = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . prototype . onerror = function ( event )  {  }  ; %NWL%ReconnectingWebSocket . debugAll = false ; %NWL%ReconnectingWebSocket . CONNECTING = WebSocket . CONNECTING ; %NWL%ReconnectingWebSocket . OPEN = WebSocket . OPEN ; %NWL%ReconnectingWebSocket . CLOSING = WebSocket . CLOSING ; %NWL%8
describe (  ' initilization '  , function (  )  {%NWL%it (  ' assigns serverTokenEndpoint from the configuration object '  , function (  )  {%NWL%Configuration . serverTokenEndpoint =  ' serverTokenEndpoint '  ; %NWL%expect ( Devise . create (  )  . serverTokenEndpoint )  . to . eq (  ' serverTokenEndpoint '  )  ;%NWL%}  )  ; %NWL%it (  ' assigns resourceName from the configuration object '  , function (  )  {%NWL%Configuration . resourceName =  ' resourceName '  ; %NWL%expect ( Devise . create (  )  . resourceName )  . to . eq (  ' resourceName '  )  ;%NWL%}  )  ; %NWL%it (  ' assigns tokenAttributeName from the configuration object '  , function (  )  {%NWL%Configuration . tokenAttributeName =  ' tokenAttributeName '  ; %NWL%2
}%NWL%}  ; %NWL%if ( typeof module =  =  =  ' object ' && module . exports )  {%NWL%module . exports = exports = MinPubSub ;%NWL%} else if ( typeof define =  =  =  ' function ' && define . amd )  {%NWL%define ( function (  )  {%NWL%return MinPubSub ;%NWL%}  )  ;%NWL%} else if ( typeof context =  =  =  ' object '  )  {%NWL%context . publish = MinPubSub . publish ; %NWL%context . subscribe = MinPubSub . subscribe ; %NWL%9
this . getKeyId = function ( key )  {%NWL%return this . suite . hash ( key . toBencode (  )  )  ;%NWL%}%NWL%this . makeBlind = function ( cddc , mkc , reference )  {%NWL%var out , serial , mk , pub , keylength , tmp , payload , hash , hashnumber , blind ; %NWL%mk = mkc . mint_key ; %NWL%pub = mk . public_mint_key ; %NWL%payload = new oc . c . Payload (  )  ; %NWL%payload . protocol_version = cddc . cdd . protocol_version ; %NWL%payload . issuer_id = this . suite . hash ( cddc . cdd . issuer_public_master_key . toBencode (  )  )  ; %NWL%payload . cdd_location = cddc . cdd . cdd_location ; %NWL%8
this . rating    = contentInitDict . rating || 0 ;%NWL%}  ; %NWL%Content = function ( contentInitDict )  {%NWL%var content =  {  }  ; %NWL%content . editableAttributes = contentInitDict . editableAttributes || [  ]  ; %NWL%content . id     = contentInitDict . id || Math . uuid ( null , 16 )  ; %NWL%content . name     = contentInitDict . name || "  "  ; %NWL%content . type     = contentInitDict . type || " IMAGE "  ; %NWL%content . mimeType    = contentInitDict . mimeType || "  "  ; %NWL%content . title     = contentInitDict . title || "  "  ; %NWL%content . contentURI   = contentInitDict . contentURI || "  "  ; %NWL%6
Backbone . sync = function ( method , model , options )  {%NWL%if ( typeof redisClient =  =  ' undefined '  )  {%NWL%throw new Error (  " redis client must be configured! "  )  ;%NWL%}%NWL%options || ( options =  {  }  )  ; %NWL%options . channel = model . getChannel (  )  ; %NWL%options . type = model . type ; %NWL%options . indexProps = model . indexProps || ( model . model && model . model . prototype . indexProps ? model . model . prototype . indexProps :  [  ]  )  ; %NWL%options . extKeys = model . extKeys || ( model . model && model . model . prototype . extKeys ? model . model . prototype . extKeys :  [  ]  )  ; %NWL%if ( typeof model =  =  = Backbone . Collection && model . extKey )  {%NWL%options . extKey = model . extKey ; %NWL%6
dojo . declare (  " dojox . layout . dnd . PlottedDnd "  ,  [ dojo . dnd . Source ]  ,  {%NWL%GC_OFFSET_X : dojo . dnd . manager (  )  . OFFSET_X ,%NWL%GC_OFFSET_Y : dojo . dnd . manager (  )  . OFFSET_Y ,%NWL%constructor : function ( node , params )  {%NWL%this . childBoxes 		 = null ; %NWL%this . dropIndicator		 = new dojox . layout . dnd . DropIndicator (  " dndDropIndicator "  ,  " div "  )  ; %NWL%this . withHandles 		 = params . withHandles ; %NWL%this . handleClasses	 	 = params . handleClasses ; %NWL%this . opacity 			 = params . opacity ; %NWL%this . allowAutoScroll	 = params . allowAutoScroll ;  /  / MODIF MYS%NWL%this . dom     = params . dom ; %NWL%6
throw new Error ( s +  ' is an invalid search scope '  )  ;%NWL%}%NWL%} else {%NWL%self . _scope = s ;%NWL%}%NWL%}  )  ; %NWL%this . baseObject = options . baseObject || new DN (  [  {  }  ]  )  ; %NWL%this . scope = options . scope || ' base '  ; %NWL%this . derefAliases = options . derefAliases || Protocol . NEVER_DEREF_ALIASES ; %NWL%this . sizeLimit = options . sizeLimit || 0 ; %NWL%this . timeLimit = options . timeLimit || 0 ; %NWL%9
paymentMethod . authorizeCapturePaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . authorizeCapturePaymentEditorView )  ; %NWL%paymentMethod . voidPaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . voidPaymentEditorView )  ; %NWL%paymentMethod . refundPaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult [ i ]  . refundPaymentEditorView )  ; %NWL%paymentMethods . push ( paymentMethod )  ;%NWL%}%NWL%} else {%NWL%paymentMethods = genericModelBuilder . transform ( jsonResult , Constructor )  ; %NWL%paymentMethods . dialogEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult . dialogEditorView )  ; %NWL%paymentMethods . authorizeCapturePaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult . authorizeCapturePaymentEditorView )  ; %NWL%paymentMethods . voidPaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult . voidPaymentEditorView )  ; %NWL%paymentMethods . refundPaymentEditorView = dialogEditorViewDisplayBuilder . transform ( jsonResult . refundPaymentEditorView )  ; %NWL%8
function save (  )  {%NWL%var practitioner = practitionerService . initializeNewPractitioner (  )  ; %NWL%if ( humanNameService . getAll (  )  . length =  =  = 0 )  {%NWL%logError (  " Practitioner must have at least one name entry .  "  )  ; %NWL%return ;%NWL%}%NWL%toggleSpinner ( true )  ; %NWL%practitioner . name = humanNameService . mapFromViewModel (  )  [ 0 ]  ; %NWL%practitioner . photo = attachmentService . getAll (  )  ; %NWL%practitioner . address = addressService . mapFromViewModel (  )  ; %NWL%practitioner . telecom = telecomService . mapFromViewModel (  )  ; %NWL%9
if ( !this . get (  ' tag '  )  )  {%NWL%throw new Error (  ' need a Tag! '  )  ;%NWL%}%NWL%}  ,%NWL%getID : function (  )  {%NWL%return this . get (  ' tag '  )  . get (  ' id '  )  ;%NWL%}  ,%NWL%initialize : function (  )  {%NWL%this . validateAtInit (  )  ; %NWL%this . gitVisuals = this . get (  ' gitVisuals '  )  ; %NWL%this . gitEngine = this . get (  ' gitEngine '  )  ; %NWL%9
rect . tiles =  [  ]  ; %NWL%this . emit (  ' rect '  , rect )  ; %NWL%this . readHextileTile ( rect , cb )  ;%NWL%}%NWL%RfbClient . prototype . readHextileTile = function ( rect , cb )%NWL%{%NWL%var tile =  {  }  ; %NWL%var stream = this . pack_stream ; %NWL%var cli = this ; %NWL%tile . x = rect . tilex ; %NWL%tile . y = rect . tiley ; %NWL%9
}  )  ;%NWL%}%NWL%Engine . execCommand ( commandId , showUi , value , range )  ; %NWL%if ( Aloha . getSelection (  )  . getRangeCount (  )  )  {%NWL%range = Aloha . getSelection (  )  . getRangeAt ( 0 )  ; %NWL%var startnode = range . commonAncestorContainer ; %NWL%var rangeObject = new window . GENTICS . Utils . RangeObject (  )  ; %NWL%rangeObject . startContainer = range . startContainer ; %NWL%rangeObject . startOffset = range . startOffset ; %NWL%rangeObject . endContainer = range . endContainer ; %NWL%rangeObject . endOffset = range . endOffset ; %NWL%7
if ( typeof options . noResults =  =  =  " string " && options . noResults ! =  =  "  "  )  {%NWL%if ( bool )  {%NWL%$ ( options . noResults )  . hide (  )  ;%NWL%} else {%NWL%$ ( options . noResults )  . show (  )  ;%NWL%}%NWL%}%NWL%return this ;%NWL%}  ; %NWL%this . loader = function ( bool )  {%NWL%if ( typeof options . loader =  =  =  " string " && options . loader ! =  =  "  "  )  {%NWL%0
minPadding : 5 ,%NWL%maxPerRow : 3 ,%NWL%baseClass :  " mblImageThumbView "  ,%NWL%selectedIndex :  - 1 ,%NWL%cache : null ,%NWL%postCreate : function (  )  {%NWL%this . inherited ( arguments )  ; %NWL%var _this = this ; %NWL%var hoverCls =  " mblThumbHover "  ; %NWL%this . addThumb = dojo . hitch ( this , this . addThumb )  ; %NWL%this . handleImgLoad = dojo . hitch ( this , this . handleImgLoad )  ; %NWL%9
plane . z = up . z ; %NWL%plane . w =  - Cartesian3 . dot ( up , point )  ; %NWL%Cartesian3 . multiplyByScalar ( up , t , point )  ; %NWL%Cartesian3 . add ( nearCenter , point , point )  ; %NWL%plane = planes [ 3 ]  ; %NWL%if ( !defined ( plane )  )  {%NWL%plane = planes [ 3 ]  = new Cartesian4 (  )  ;%NWL%}%NWL%plane . x =  - up . x ; %NWL%plane . y =  - up . y ; %NWL%plane . z =  - up . z ; %NWL%8
for ( var i = 0 ; i < 256 ; i +  +  )  {%NWL%name +  =  ' 11 '  ;%NWL%}%NWL%this . http = this . post (  '  / api / stores '  )  ; %NWL%this . http . send (  {%NWL%' name '  : name%NWL%}  )  ; %NWL%this . http . end ( function ( err )  {%NWL%if ( err ) return done ( err )  ; %NWL%this . req = this . http . req ; %NWL%this . res = this . http . res ; %NWL%9
}  ,%NWL%onTouchMove : function ( e )  {%NWL%e . stop (  )  ; %NWL%var z = this . camera . position . z ,%NWL%sign = Math . abs ( z )  / z ,%NWL%pos = this . pos ; %NWL%surface . rotation . y +  =  -  ( pos . x - e . x )  / 100 ; %NWL%surface . rotation . x +  = sign *  ( pos . y - e . y )  / 100 ; %NWL%surface . update (  )  ; %NWL%pos . x = e . x ; %NWL%pos . y = e . y ; %NWL%9
}%NWL%function ArrayBufferIndex ( value )  {%NWL%this . Value = value ;%NWL%}%NWL%ArrayBufferIndex . prototype = new DataDescriptor ( undefined , 5 )  ; %NWL%function Type ( options )  {%NWL%this . name  = options . name%NWL%this . size  = options . size ; %NWL%this . cast  = options . cast ; %NWL%this . set  = options . set ; %NWL%this . get  = options . get ; %NWL%7
self . prototype . drawWithEndPoints = function ( ctx )  {%NWL%this . drawEdge ( ctx , 0 , 0 )  ; %NWL%this . drawEndPointsOfPath ( ctx , 0 , 0 )  ;%NWL%}%NWL%self . prototype . drawWithDifference = function ( ctx , dx , dy )  {%NWL%this . drawEdge ( ctx , dx , dy )  ; %NWL%this . drawEndPointsOfPath ( ctx , dx , dy )  ;%NWL%}%NWL%self . prototype . setupContext = function ( ctx )  {%NWL%ctx . lineWidth = this . lineWidth ; %NWL%ctx . lineCap = this . lineCap ; %NWL%9
fileEntry . fileName = fileEntry . extraField =  '  '  ; %NWL%fileEntry . entryLength = 30 + fileEntry . fileNameLength + fileEntry . extraFieldLength ; %NWL%if ( fileEntry . entryLength > structures . maxFileEntrySize )  {%NWL%throw new Error (  ' File entry unexpectedly large :  '  + fileEntry . entryLength +  '  ( max :  '  + structures . maxFileEntrySize +  '  )  '  )  ;%NWL%}%NWL%if ( fileEntry . fileNameLength > 0 )  {%NWL%fileEntry . fileName = buffer . slice ( index , index + fileEntry . fileNameLength )  . toString (  )  ; %NWL%index +  = fileEntry . fileNameLength ;%NWL%}%NWL%if ( fileEntry . extraFieldLength > 0 )  {%NWL%fileEntry . extraField = buffer . slice ( index , index + fileEntry . extraFieldLength )  . toString (  )  ; %NWL%6
this . destroyItem . apply ( this , arguments )  ;%NWL%}  ,%NWL%craft : function ( o , cb )  {%NWL%log (  ' item . craft '  )  ; %NWL%if ( !cb )%NWL%warning (  ' item . craft called with no callback! '  )  ; %NWL%var opt = copy ( o )  ; %NWL%if ( o . attr )%NWL%opt . attr = stringify ( o . attr )  ; %NWL%if ( o . affects )%NWL%opt . affects = stringify ( o . affects )  ; %NWL%8
' libraryID '  : library . libraryID ,%NWL%' itemKey '  : itemKey ,%NWL%' content '  :  ' json '%NWL%}  ; %NWL%return library . ajaxRequest ( urlconfig )%NWL%. then ( function ( response )  {%NWL%var resultOb = J ( response . data )  ; %NWL%var entry = J ( response . data )  . find (  " entry "  )  . eq ( 0 )  ; %NWL%var item = new Zotero . Item (  )  ; %NWL%item . libraryType = library . libraryType ; %NWL%item . libraryID = library . libraryID ; %NWL%9
}  ; %NWL%Y . extend ( IEEventFacade , Y . DOM2EventFacade , proto )  ; %NWL%Y . extend ( IELazyFacade , Y . DOM2EventFacade , proto )  ; %NWL%IELazyFacade . prototype . init = function (  )  {%NWL%var e   = this . _event ,%NWL%overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%9
nb0 . c1y =  ( nb0 . c0y + y )  * t ; %NWL%nb1 . c0y =  ( nb1 . c1y + y )  * t ; %NWL%nb0 . p1y =  ( nb0 . c1y + nb1 . c0y )  * t ; %NWL%nb1 . p0y = nb0 . p1y ; %NWL%return { b0 : nb0 , b1 : nb1 }  ;%NWL%}%NWL%self . prototype . duplicate = function (  )  {%NWL%var cv = new an . Curve (  )  ; %NWL%cv . p0x = this . p0x ; %NWL%cv . p0y = this . p0y ; %NWL%cv . c0x = this . c0x ; %NWL%8
if ( this . startTime . valueOf (  )  =  =  = this . endTime . valueOf (  )  )  {%NWL%this . disabled = true ; %NWL%return false ;%NWL%}%NWL%else {%NWL%this . disabled = false ;%NWL%}%NWL%scale . range (  [ this . config . startAngle , this . config . endAngle ]  )  ; %NWL%this . timeScale = scale ; %NWL%this . domain = scale . domain (  )  ; %NWL%this . range = scale . range (  )  ; %NWL%9
__bind = function ( fn , me )  {%NWL%return function (  )  {%NWL%return fn . apply ( me , arguments )  ;%NWL%}  ;%NWL%}  ; %NWL%_ = require (  ' underscore '  )  ; %NWL%Utils = require (  '  .  .  / utils / utils '  )  . Utils ; %NWL%BaseParams =  ( function (  )  {%NWL%function BaseParams (  )  {%NWL%this . checkReqParamsOk = __bind ( this . checkReqParamsOk , this )  ; %NWL%this . getPostValue = __bind ( this . getPostValue , this )  ; %NWL%9
}%NWL%if ( options . my [ 1 ]  =  =  =  " bottom "  )  {%NWL%position . top -  = elemHeight ;%NWL%} else if ( options . my [ 1 ]  =  =  =  " center "  )  {%NWL%position . top -  = elemHeight / 2 ;%NWL%}%NWL%position . left +  = myOffset [ 0 ]  ; %NWL%position . top +  = myOffset [ 1 ]  ; %NWL%if ( !supportsOffsetFractions (  )  )  {%NWL%position . left = round ( position . left )  ; %NWL%position . top = round ( position . top )  ; %NWL%9
init : function ( element , options )  {%NWL%var $imageSlides ,%NWL%imagesLoadedCount = 0 ,%NWL%self = this ; %NWL%this . clickTimer = $ . proxy ( this . clickTimer , this )  ; %NWL%this . addBullet = $ . proxy ( this . addBullet , this )  ; %NWL%this . resetAndUnlock = $ . proxy ( this . resetAndUnlock , this )  ; %NWL%this . stopClock = $ . proxy ( this . stopClock , this )  ; %NWL%this . startTimerAfterMouseLeave = $ . proxy ( this . startTimerAfterMouseLeave , this )  ; %NWL%this . clearClockMouseLeaveTimer = $ . proxy ( this . clearClockMouseLeaveTimer , this )  ; %NWL%this . rotateTimer = $ . proxy ( this . rotateTimer , this )  ; %NWL%4
this . y = y || 0 ; %NWL%this . z = z || 0 ; %NWL%this . w = w || 0 ;%NWL%}%NWL%}  ; %NWL%cc . kmQuaternion = cc . math . Quaternion ; %NWL%var proto = cc . math . Quaternion . prototype ; %NWL%proto . conjugate = function ( quaternion )  {   /  /  = cc . kmQuaternionConjugate%NWL%this . x =  - quaternion . x ; %NWL%this . y =  - quaternion . y ; %NWL%this . z =  - quaternion . z ; %NWL%8
THREE . DirectionalLight . prototype . clone = function (  )  {%NWL%var light = new THREE . DirectionalLight (  )  ; %NWL%THREE . Light . prototype . clone . call ( this , light )  ; %NWL%light . target = this . target . clone (  )  ; %NWL%light . intensity = this . intensity ; %NWL%light . castShadow = this . castShadow ; %NWL%light . onlyShadow = this . onlyShadow ; %NWL%light . shadowCameraNear = this . shadowCameraNear ; %NWL%light . shadowCameraFar = this . shadowCameraFar ; %NWL%light . shadowCameraLeft = this . shadowCameraLeft ; %NWL%light . shadowCameraRight = this . shadowCameraRight ; %NWL%4
this . top =  - this . halfHeight + this . y ; %NWL%this . bottom = this . halfHeight + this . y ;%NWL%}%NWL%return this ;%NWL%}  ; %NWL%proto . set = function ( aabb )  {%NWL%this . empty = aabb . empty ; %NWL%this . x = aabb . x ; %NWL%this . y = aabb . y ; %NWL%this . width  = aabb . width ; %NWL%this . height = aabb . height ; %NWL%6
getNewOffsetFromTouchPoint : function ( touchPoint )  {%NWL%var xDelta = touchPoint . x - this . startTouchPoint . x ,%NWL%yDelta = touchPoint . y - this . startTouchPoint . y ,%NWL%newOffset = this . offset . copy (  )  ; %NWL%if ( xDelta =  = 0 && yDelta =  = 0 )  {%NWL%return newOffset ;%NWL%}%NWL%if ( this . horizontal )%NWL%newOffset . x = this . startOffset . x + xDelta ; %NWL%if ( this . vertical )%NWL%newOffset . y = this . startOffset . y + yDelta ; %NWL%8
result . onScrollingStop (  )  ;%NWL%}%NWL%} else {%NWL%scrollToIntv = setTimeout ( function (  )  {%NWL%result . onScrollingStop (  )  ;%NWL%}  , 200 )  ;%NWL%}%NWL%}  ; %NWL%result . scrollToIndex = originalScrollModel . scrollToIndex ; %NWL%result . scrollToItem = originalScrollModel . scrollToItem ; %NWL%result . scrollIntoView = originalScrollModel . scrollIntoView ; %NWL%8
engines . dot = fromStringRenderer (  ' dot '  )  ; %NWL%engines . dot . renderSync = function ( str , options )  {%NWL%var engine = requires . dot || ( requires . dot = require (  ' dot '  )  )  ; %NWL%try {%NWL%var tmpl = cache ( options ) || cache ( options , engine . compile ( str , options && options . _def )  )  ; %NWL%return tmpl ( options )  ;%NWL%} catch ( err )  {%NWL%throw err ;%NWL%}%NWL%}  ; %NWL%engines . ractive = fromStringRenderer (  ' ractive '  )  ; %NWL%0
cfg . openid = cfg . openid [ 0 ]  ;%NWL%}%NWL%if ( typeof cfg . account =  =  =  " object " && cfg . account ! =  = null && typeof cfg . account . homePage =  =  =  " undefined " && typeof cfg . account . name =  =  =  " undefined "  )  {%NWL%if ( cfg . account . length =  =  = 0 )  {%NWL%delete cfg . account ;%NWL%}%NWL%else {%NWL%if ( cfg . account . length > 1 )  {%NWL%this . degraded = true ;%NWL%}%NWL%cfg . account = cfg . account [ 0 ]  ; %NWL%0
"  .  / array "  ,%NWL%"  .  .  / on "  ,%NWL%"  .  .  / aspect "  ,%NWL%"  .  .  / request / watch "  ,%NWL%"  .  .  / request / xhr "  ,%NWL%"  .  .  / request / util "%NWL%]  , function ( dojo , has , require , ioq ,  dom , domForm , Deferred , config , json , lang , array , on , aspect , watch , _xhr , util )  {%NWL%dojo . _xhrObj = _xhr . _create ; %NWL%var cfg = dojo . config ; %NWL%dojo . objectToQuery = ioq . objectToQuery ; %NWL%dojo . queryToObject = ioq . queryToObject ; %NWL%9
lodash . times = utilities . times ; %NWL%lodash . toArray = collections . toArray ; %NWL%lodash . transform = objects . transform ; %NWL%lodash . union = arrays . union ; %NWL%lodash . uniq = arrays . uniq ; %NWL%lodash . values = objects . values ; %NWL%lodash . where = collections . where ; %NWL%lodash . without = arrays . without ; %NWL%lodash . wrap = functions . wrap ; %NWL%lodash . xor = arrays . xor ; %NWL%lodash . zip = arrays . zip ; %NWL%3
}%NWL%if ( file . tmb )  {%NWL%info . tmb = file . tmb ;%NWL%} else if ( info . mime . indexOf (  ' image /  '  )  =  =  = 0 && tmb )  {%NWL%info . tmb = 1 ;%NWL%}%NWL%if ( file . dirs && file . dirs . length )  {%NWL%info . dirs = true ;%NWL%}%NWL%if ( file . dim )  {%NWL%info . dim = file . dim ; %NWL%2
add_labels : labelList . getAdded ( oldLabelIds , newLabelIds )  ,%NWL%delete_labels : labelList . getDeleted ( oldLabelIds , newLabelIds )%NWL%}  ; %NWL%var options =  {%NWL%wait : true ,%NWL%}  ; %NWL%if ( typeof noAlert =  =  =  " string " || !noAlert )  {%NWL%var successAlertEl = notificationEl . find (  "  . alert - success "  )  ; %NWL%var errorAlertEl = notificationEl . find (  "  . alert - danger "  )  ; %NWL%options . success = this . getAnimatorClosure ( successAlertEl )  ; %NWL%options . error = this . getAnimatorClosure ( errorAlertEl )  ; %NWL%9
self . remove = remove = function (  )  {%NWL%layer . remove (  )  ;%NWL%}  ; %NWL%self . die = die = function (  )  {%NWL%isDead = true ; %NWL%dieSound . play (  )  ; %NWL%animationLoop . remove (  )  ; %NWL%animationLoop = undefined ; %NWL%onDie (  )  ;%NWL%}  ; %NWL%self . jump = jump = function (  )  {%NWL%0
if ( element . addEventListener )  {%NWL%element . addEventListener ( eventName , handler , false )  ;%NWL%} else {%NWL%handlerWrapper = function ( event )  {%NWL%if ( ! (  " target " in event )  )  {%NWL%event . target = event . srcElement ;%NWL%}%NWL%event . preventDefault = event . preventDefault || function (  )  {%NWL%this . returnValue = false ;%NWL%}  ; %NWL%event . stopPropagation = event . stopPropagation || function (  )  {%NWL%7
return declare (  ' CreationOAuth2ItemWidget '  ,  [ WidgetBase , TemplatedMixin ]  ,  {%NWL%templateString : template ,%NWL%constructor : function ( obj )  {%NWL%this . name = obj . name ; %NWL%this . clientId = obj . clientId ; %NWL%this . clientSecret = obj . clientSecret ; %NWL%this . authUrl = obj . authUrl ; %NWL%this . tokenUrl = obj . tokenUrl ; %NWL%this . type = obj . type ; %NWL%this . grantType = obj . grantType ; %NWL%this . authentication = obj . authentication ; %NWL%3
Model . count = persistUtil . bind (  ' count '  , Model . count , Model )  ; %NWL%Model . orderBy = function (  )  {%NWL%var query = this . using ( null )  ; %NWL%return query . orderBy . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . orderBy = persistUtil . bind (  ' orderBy '  , Model . orderBy , Model )  ; %NWL%Model . limit = function (  )  {%NWL%var query = this . using ( null )  ; %NWL%return query . limit . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . limit = persistUtil . bind (  ' limit '  , Model . limit , Model )  ; %NWL%0
}%NWL%}  ; %NWL%EventBusStub . reconnect . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . reconnect "  ; %NWL%EventBusStub . close . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . close "  ; %NWL%EventBusStub . login . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . login "  ; %NWL%EventBusStub . send . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . send "  ; %NWL%EventBusStub . publish . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . publish "  ; %NWL%EventBusStub . registerHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . registerHandler "  ; %NWL%EventBusStub . unregisterHandler . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . unregisterHandler "  ; %NWL%EventBusStub . readyState . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . readyState "  ; %NWL%EventBusStub . getOptions . displayName =  "  "  + CONSTANTS . MODULE +  "  /  "  + CONSTANTS . COMPONENT +  "  : EventBusStub . getOptions "  ; %NWL%2
return ;%NWL%}%NWL%if ( loaded )  {%NWL%q . url . shift (  )  ; %NWL%if ( q . varName )  {%NWL%q . varName . shift (  )  ;%NWL%}%NWL%} else {%NWL%q . url =  ( lang . isString ( q . url )  ) ? [ q . url ]  : q . url ; %NWL%if ( q . varName )  {%NWL%q . varName =  ( lang . isString ( q . varName )  ) ? [ q . varName ]  : q . varName ; %NWL%8
if ( args . currentTime ! =  = undefined )  {%NWL%this . currentTime = args . currentTime ;%NWL%}%NWL%if ( args . authenticationToken ! =  = undefined )  {%NWL%this . authenticationToken = args . authenticationToken ;%NWL%}%NWL%if ( args . expiration ! =  = undefined )  {%NWL%this . expiration = args . expiration ;%NWL%}%NWL%if ( args . user ! =  = undefined )  {%NWL%this . user = args . user ; %NWL%1
exports . child_process				 = null ; %NWL%exports . cluster						 = null ; %NWL%exports . console						 = require . resolve (  ' console - browserify '  )  ; %NWL%exports . constants					 = require . resolve (  ' constants - browserify '  )  ; %NWL%exports . crypto						 = require . resolve (  ' crypto - browserify '  )  ; %NWL%exports . dgram						 = null ; %NWL%exports . dns							 = null ; %NWL%exports . domain						 = require . resolve (  ' domain - browser '  )  ; %NWL%exports . events						 = require . resolve (  ' events /  '  )  ; %NWL%exports . fs							 = null ; %NWL%exports . http						 = require . resolve (  ' http - browserify '  )  ; %NWL%2
client = new fakeGlobal . XMLHttpRequest (  )  ; %NWL%client . onreadystatechange = onreadystatechange ; %NWL%client . open (  " GET "  ,  " example . com / someApi "  )  ; %NWL%client . setRequestHeader (  " Content - Type "  ,  " text / plain "  )  ; %NWL%client . send (  )  ; %NWL%request = mockAjax . requests . mostRecent (  )  ; %NWL%response =  { contentType :  " text / html "  , response :  "  (  . _ )  { response "  , responseText :  "  (  . _ )  {  "  , responseType :  " text "  }  ; %NWL%request . responseTimeout ( response )  ; %NWL%sharedContext . responseCallback = error ; %NWL%sharedContext . status = response . status ; %NWL%sharedContext . statusText = response . statusText ; %NWL%9
max . y = max . y ! =  = undefined ? Math . max ( max . y , y )  : y ; %NWL%min . y = min . y ! =  = undefined ? Math . min ( min . y , y )  : y ; %NWL%y_ok = true ;%NWL%}%NWL%if ( typeof ( cmds [ j ]  . prevZ ) ! =  =  ' undefined '%NWL%&& typeof ( cmds [ j ]  . extrude ) ! =  =  ' undefined '%NWL%&& cmds [ j ]  . extrude%NWL%&& !isNaN ( cmds [ j ]  . prevZ )  )  {%NWL%var z = cmds [ j ]  . prevZ ; %NWL%max . z = max . z ! =  = undefined ? Math . max ( max . z , z )  : z ; %NWL%min . z = min . z ! =  = undefined ? Math . min ( min . z , z )  : z ; %NWL%1
defaultInstance = new exports . Swig (  )  ; %NWL%exports . setFilter = defaultInstance . setFilter ; %NWL%exports . setTag = defaultInstance . setTag ; %NWL%exports . setExtension = defaultInstance . setExtension ; %NWL%exports . parseFile = defaultInstance . parseFile ; %NWL%exports . precompile = defaultInstance . precompile ; %NWL%exports . compile = defaultInstance . compile ; %NWL%exports . compileFile = defaultInstance . compileFile ; %NWL%exports . render = defaultInstance . render ; %NWL%exports . renderFile = defaultInstance . renderFile ; %NWL%exports . run = defaultInstance . run ; %NWL%1
}%NWL%wrappedContent = wrappedContent . concat ( fieldHTMLs )  ;%NWL%}%NWL%return tag ( tagName ,  {%NWL%classes : field . classes (  )%NWL%}  , wrappedContent . join (  '  '  )  )  ;%NWL%}  ;%NWL%}  ; %NWL%exports . div = wrapWith (  ' div '  )  ; %NWL%exports . p = wrapWith (  ' p '  )  ; %NWL%exports . li = wrapWith (  ' li '  )  ; %NWL%8
}%NWL%data . cid = view . cid ; %NWL%data . isLoading = false ;  /  / set when a view is registered , but not serialized%NWL%data . options = Agent . serializeObject ( view . options )  ; %NWL%data . ui = Agent . serializeUI ( view . ui )  ; %NWL%data . el = Agent . serializeElement ( view . el ,  ' el '  , false )  ; %NWL%data . events = Agent . serializeEventsHash ( view . events )  ; %NWL%data . _events = Agent . serializeEvents ( view . _events )  ; %NWL%data . modelEvents = Agent . serializeEventsHash ( view . modelEvents )  ; %NWL%data . collectionEvents = Agent . serializeEventsHash ( view . collectionEvents )  ; %NWL%data . triggers = Agent . serializeEventsHash ( view . triggers )  ; %NWL%6
}  ; %NWL%Rivets . config =  {%NWL%preloadData : true ,%NWL%handler : function ( context , ev , binding )  {%NWL%return this . call ( context , ev , binding . view . models )  ;%NWL%}%NWL%}  ; %NWL%Rivets . formatters =  {  }  ; %NWL%Rivets . factory = function ( exports )  {%NWL%exports . binders = Rivets . binders ; %NWL%exports . formatters = Rivets . formatters ; %NWL%9
air . NetStreamInfo = window . runtime . flash . net . NetStreamInfo ; %NWL%air . NetStreamPlayOptions = window . runtime . flash . net . NetStreamPlayOptions ; %NWL%air . NetStreamPlayTransitions = window . runtime . flash . net . NetStreamPlayTransitions ; %NWL%air . SharedObject = window . runtime . flash . net . SharedObject ; %NWL%air . SharedObjectFlushStatus = window . runtime . flash . net . SharedObjectFlushStatus ; %NWL%air . Capabilities = window . runtime . flash . system . Capabilities ; %NWL%air . System = window . runtime . flash . system . System ; %NWL%air . Security = window . runtime . flash . system . Security ; %NWL%air . Updater = window . runtime . flash . desktop . Updater ; %NWL%air . Clipboard = window . runtime . flash . desktop . Clipboard ; %NWL%air . ClipboardFormats = window . runtime . flash . desktop . ClipboardFormats ; %NWL%8
dragElId :  " moduleProxy "%NWL%}  )  ; %NWL%this . isTarget = false ;%NWL%}  ; %NWL%Y . extend ( Y . WireModuleProxy , YAHOO . util . DDProxy ,  {%NWL%startDrag : function ( e )  {%NWL%Y . WireModuleProxy . superclass . startDrag . call ( this , e )  ; %NWL%var del = this . getDragEl (  )  ,%NWL%lel = this . getEl (  )  ; %NWL%del . innerHTML = lel . innerHTML ; %NWL%del . className = lel . className ; %NWL%9
context . fillStyle = fillStyleSelect . value ;%NWL%}  ; %NWL%editCheckbox . onchange = function ( e )  {%NWL%if ( editCheckbox . checked )  {%NWL%startEditing (  )  ;%NWL%}%NWL%else {%NWL%stopEditing (  )  ;%NWL%}%NWL%}  ; %NWL%context . strokeStyle = strokeStyleSelect . value ; %NWL%0
argMap =  {%NWL%' undefined '  : void 0 ,%NWL%' null '  : null ,%NWL%' true '  : true ,%NWL%' false '  : false%NWL%}  ; %NWL%Backbone . ViewModel =  ( function ( _super )  {%NWL%__extends ( ViewModel , _super )  ; %NWL%function ViewModel ( attributes , options )  {%NWL%this . onVirtual = __bind ( this . onVirtual , this )  ; %NWL%this . createVirtual = __bind ( this . createVirtual , this )  ; %NWL%9
var copystate =  {  }  ; %NWL%testcase . setStateFromFields (  )  ; %NWL%if ( state . key! =  - 100 ) copystate . key = state . key ; %NWL%if ( state . disabled ) copystate . disabled = true ; %NWL%if ( state . search ) copystate . search = true ; %NWL%if ( state . subfolder ) copystate . subfolder = true ; %NWL%if ( state . page ! = 1 ) copystate . page = state . page ; %NWL%copystate . elems = state . elems ; %NWL%if ( state . nameordesc . length ) copystate . nameordesc = state . nameordesc ; %NWL%if ( state . asname . length ) copystate . asname = state . asname ; %NWL%if ( state . asdescription . length ) copystate . asdescription = state . asdescription ; %NWL%8
p . oneDPlotHt = gl . getUniformLocation ( p ,  " u_1dPlotHt "  )  ; %NWL%p . pixOffsets = gl . getUniformLocation ( p ,  " u_pixOffsets "  )  ; %NWL%p . texIdx = gl . getUniformLocation ( p ,  " u_texIdx "  )  ; %NWL%p . containerPos = gl . getUniformLocation ( p ,  " u_containerPos "  )  ; %NWL%p . pixOrigin = gl . getUniformLocation ( p ,  " u_pixOrigin "  )  ; %NWL%p . zm = gl . getUniformLocation ( p ,  " u_zm "  )  ; %NWL%p . transformation = gl . getUniformLocation ( p ,  " u_trans "  )  ; %NWL%p . loV = gl . getUniformLocation ( p ,  " u_loV "  )  ; %NWL%p . hiV = gl . getUniformLocation ( p ,  " u_hiV "  )  ; %NWL%p . histColor = gl . getUniformLocation ( p ,  " u_histColor "  )  ; %NWL%p . visType = gl . getUniformLocation ( p ,  " u_visType "  )  ; %NWL%2
return info ;%NWL%}  ; %NWL%Viewport . prototype . overrideScreenInfo = function ( width , height , orientation )  {%NWL%this . screenInfo =  { width : width , height : height , orientation : orientation }  ;%NWL%}  ; %NWL%function EventHandler ( args )  {%NWL%this . el = $ (  ' # '  + args . id )  ; %NWL%this . dragTolerance = args . dragTolerance || 3 ; %NWL%this . mouse   = args . mouse ; %NWL%this . onClick   = args . onClick ; %NWL%this . onDrag   = args . onDrag ; %NWL%8
$ ( document )  . trigger (  ' api - load - complete '  )  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%function parse ( xml )  {%NWL%var docinfo = $ (  ' docs '  , xml )  ; %NWL%var guid = 0 ;  /  / TODO upgrade guid to a combo of fn name and params - like Jorn ' s browser%NWL%jquerydocs . version = docinfo . attr (  ' version '  )  ; %NWL%jquerydocs . timestamp = docinfo . attr (  ' timestamp '  )  ; %NWL%jquerydocs . startdoc = docinfo . attr (  ' startdoc '  )  ; %NWL%8
years :  "  {  { amount }  } y "%NWL%}%NWL%}%NWL%}  ; %NWL%function Age ( $el , settings )  {%NWL%if ( settings =  = null )  {%NWL%settings =  {  }  ;%NWL%}%NWL%this . text = __bind ( this . text , this )  ; %NWL%this . interval = __bind ( this . interval , this )  ; %NWL%this . format = __bind ( this . format , this )  ; %NWL%8
}  ,%NWL%create : function CacheManager (  )  {%NWL%var enyoApp = enyo . application ; %NWL%this . eventCache =  {  }  ; %NWL%this . timestampCache =  {  }  ; %NWL%this . hiddenCalendars =  {  }  ; %NWL%this . queries =  { active :  {  }  , canceled :  {  }  }  ; %NWL%this . activeQueries =  [  ]  ; %NWL%this . nextWorkerId = 0 ; %NWL%this . databaseChanged = enyo . bind ( this , this . databaseChanged )  ; %NWL%this . getDays = enyo . bind ( this , this . getDays )  ; %NWL%9
entityX =  ( curObject . x - MapSurface . x ) | 0 ; %NWL%entityY =  ( curObject . y - MapSurface . y ) | 0 ; %NWL%curObject . sprite . position ( entityX , entityY )  ; %NWL%curObject . sprite . canvasUpdate ( MapSurface . front )  ;%NWL%}%NWL%}  /  / end for%NWL%Player . update (  )  ; %NWL%MapSurface . update (  )  ; %NWL%if ( debug . output && Scene . ticker . currentTick % 20 =  =  = 0 )  {%NWL%debug . fps . innerHTML = ticker . fps ; %NWL%debug . load . innerHTML = ticker . load ; %NWL%9
this . hostname = opts . hostname ||%NWL%( global . location ? location . hostname :  ' localhost '  )  ; %NWL%this . port = opts . port || ( global . location && location . port ?%NWL%location . port :%NWL%( this . secure ? 443 : 80 )  )  ; %NWL%this . query = opts . query || {  }  ; %NWL%if (  ' string '  =  = typeof this . query ) this . query = parseqs . decode ( this . query )  ; %NWL%this . upgrade = false ! =  = opts . upgrade ; %NWL%this . path =  ( opts . path || '  / engine . io '  )  . replace (  / \ / $ /  ,  '  '  )  +  '  /  '  ; %NWL%this . forceJSONP = !!opts . forceJSONP ; %NWL%this . jsonp = false ! =  = opts . jsonp ; %NWL%7
var Validate = require (  '  .  / Validate '  )  ; %NWL%var log = require (  '  .  / log '  )  ; %NWL%var debug = log . debug ; %NWL%var Environment = require (  '  .  / Environment '  )  ; %NWL%var Producer_js = require (  '  .  / Producer_js '  )  ; %NWL%function Project ( filename , options )  {%NWL%this . recurseLevel = 0 ; %NWL%var DEFAULT_TARGET =  " js "  ; %NWL%if ( !options ) options =  {  }  ; %NWL%if ( options . verbose =  =  = undefined ) options . verbose = 1 ; %NWL%if ( options . warning =  =  = undefined ) options . warning = 1 ; %NWL%9
if ( oldValue )  {%NWL%this . system . app . scene . removeModel ( oldValue )  ; %NWL%this . entity . removeChild ( oldValue . getGraph (  )  )  ; %NWL%delete oldValue . _entity ;%NWL%}%NWL%if ( newValue )  {%NWL%var componentData = this . data ; %NWL%var meshInstances = newValue . meshInstances ; %NWL%for ( var i = 0 ; i < meshInstances . length ; i +  +  )  {%NWL%meshInstances [ i ]  . castShadow = componentData . castShadows ; %NWL%meshInstances [ i ]  . receiveShadow = componentData . receiveShadows ; %NWL%9
Modernizr . testStyles  = injectElementWithStyles ; %NWL%return Modernizr ;%NWL%}  )  ( this , this . document )  ;%NWL%;%NWL%( function ( exports )  {%NWL%var MOUSE_ID = 1 ; %NWL%function Pointer ( identifier , type , event )  {%NWL%this . screenX = event . screenX || 0 ; %NWL%this . screenY = event . screenY || 0 ; %NWL%this . pageX = event . pageX || 0 ; %NWL%this . pageY = event . pageY || 0 ; %NWL%7
stopped : 0 ,%NWL%prevented : 0 ,%NWL%bubbling : null ,%NWL%type : self . type ,%NWL%defaultTargetOnly : self . defaultTargetOnly%NWL%}  ; %NWL%subs = self . getSubs (  )  ; %NWL%ons = subs [ 0 ]  ; %NWL%afters = subs [ 1 ]  ; %NWL%self . stopped =  ( self . type ! =  = es . type ) ? 0 : es . stopped ; %NWL%self . prevented =  ( self . type ! =  = es . type ) ? 0 : es . prevented ; %NWL%9
return util . login ( username , password )  . then ( function ( reply )  {%NWL%validSession = true ; %NWL%return reply ;%NWL%}  )  [  ' catch '  ]  ( function ( reply )  {%NWL%validSession = false ; %NWL%return reply ;%NWL%}  )  ;%NWL%}%NWL%}  ; %NWL%wrapped . registerHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . registerHandler '  ; %NWL%wrapped . unregisterHandler . displayName =  '  '  + CONSTANTS . MODULE +  '  /  '  + CONSTANTS . COMPONENT +  '  : wrapped . unregisterHandler '  ; %NWL%9
function copyEventProps ( evt )  {%NWL%var props = lang . delegate ( evt ,  {%NWL%bubbles : true%NWL%}  )  ; %NWL%if ( has (  " ios "  )  >  = 6 )  {%NWL%props . touches = evt . touches ; %NWL%props . altKey = evt . altKey ; %NWL%props . changedTouches = evt . changedTouches ; %NWL%props . ctrlKey = evt . ctrlKey ; %NWL%props . metaKey = evt . metaKey ; %NWL%props . shiftKey = evt . shiftKey ; %NWL%5
this . removePeerFromClientBrowserResourceRequests = __bind ( this . removePeerFromClientBrowserResourceRequests , this )  ; %NWL%this . onResourceChange = __bind ( this . onResourceChange , this )  ; %NWL%this . recordResourceRequest = __bind ( this . recordResourceRequest , this )  ; %NWL%this . getContentsForPath = __bind ( this . getContentsForPath , this )  ; %NWL%this . parsePath = __bind ( this . parsePath , this )  ; %NWL%this . serveFile = __bind ( this . serveFile , this )  ; %NWL%this . sendFailure = __bind ( this . sendFailure , this )  ; %NWL%this . sendEventTo = __bind ( this . sendEventTo , this )  ; %NWL%this . setUpReceiveEventCallbacks = __bind ( this . setUpReceiveEventCallbacks , this )  ; %NWL%this . channelConnectionOnData = __bind ( this . channelConnectionOnData , this )  ; %NWL%this . channelOnConnectionClose = __bind ( this . channelOnConnectionClose , this )  ; %NWL%0
}%NWL%if ( isNew )  {%NWL%self . setPropertyOrDefault ( colDef ,  ' filter '  )  ; %NWL%self . setPropertyOrDefault ( colDef ,  ' filters '  , defaultFilters )  ;%NWL%} else if ( self . filters . length =  =  = defaultFilters . length )  {%NWL%self . filters . forEach ( function ( filter , index )  {%NWL%if ( typeof ( defaultFilters [ index ]  . placeholder ) ! =  =  ' undefined '  )  {%NWL%filter . placeholder = defaultFilters [ index ]  . placeholder ;%NWL%}%NWL%if ( typeof ( defaultFilters [ index ]  . flags ) ! =  =  ' undefined '  )  {%NWL%filter . flags = defaultFilters [ index ]  . flags ; %NWL%7
comp = items [ i ]  ; %NWL%if ( !comp . rendered )  {%NWL%if ( me . collapseFirst )  {%NWL%comp . collapseFirst = me . collapseFirst ;%NWL%}%NWL%if ( me . hideCollapseTool )  {%NWL%comp . hideCollapseTool = me . hideCollapseTool ; %NWL%comp . titleCollapse = true ;%NWL%}%NWL%else if ( me . titleCollapse )  {%NWL%comp . titleCollapse = me . titleCollapse ; %NWL%3
}%NWL%}%NWL%if ( protoData . cType =  =  ' combobox '  )  {%NWL%var myStore =  Ext . create (  ' Ext . data . Store '  , Ext . clone ( protoData . config . store )  )  ; %NWL%configurator . store = myStore ;%NWL%}%NWL%var newField = Ext . create ( protoData . cType , configurator )  ; %NWL%newField . config = protoData . config ; %NWL%newField . protoId = protoData . protoId ; %NWL%newField . configFields = Ext . getStore (  " MTFieldsStore "  )  . findRecord (  " id "  , protoData . protoId )  . get (  " configFields "  )  ; %NWL%newField . cType = protoData . cType ; %NWL%7
return false ;%NWL%}  ,%NWL%merge : function ( tamperResponse )  {%NWL%this . elapsedTime = tamperResponse . millis - this . millis ; %NWL%this . status = tamperResponse . status ; %NWL%this . statusText = tamperResponse . statusText ; %NWL%this . contentSize = tamperResponse . contentSize ; %NWL%this . mimeType = tamperResponse . mimeType ; %NWL%this . responseHeaders = tamperResponse . responseHeaders ; %NWL%for ( var header in tamperResponse . requestHeaders )  {%NWL%this . requestHeaders [ header ]  = tamperResponse . requestHeaders [ header ]  ; %NWL%4
env . addReporter ( htmlReporter )  ; %NWL%var specFilter = new jasmine . HtmlSpecFilter (  {%NWL%filterString : function (  )  { return queryString . getParam (  " spec "  )  ;  }%NWL%}  )  ; %NWL%env . specFilter = function ( spec )  {%NWL%return specFilter . matches ( spec . getFullName (  )  )  ;%NWL%}  ; %NWL%window . setTimeout = window . setTimeout ; %NWL%window . setInterval = window . setInterval ; %NWL%window . clearTimeout = window . clearTimeout ; %NWL%window . clearInterval = window . clearInterval ; %NWL%7
result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%6
suffix = m [ 3 ]  ;%NWL%}%NWL%}%NWL%if ( scriptUrl )  {%NWL%scriptOptions . base = scriptOptions . base || scriptUrl ; %NWL%scriptOptions . packaged = true ;%NWL%}%NWL%scriptOptions . suffix = scriptOptions . suffix || suffix ; %NWL%scriptOptions . workerPath = scriptOptions . workerPath || scriptOptions . base ; %NWL%scriptOptions . modePath = scriptOptions . modePath || scriptOptions . base ; %NWL%scriptOptions . themePath = scriptOptions . themePath || scriptOptions . base ; %NWL%8
_in = inIn [ i ] || 0 . 001 ; %NWL%out [ i ]  = Math . pow ( x , Math . log ( Math . abs ( _in / srclo )  )  / y )  * dstlo ; %NWL%x +  = x_slope ; %NWL%y +  = y_slope ;%NWL%}%NWL%this . _srclo = next_srclo ; %NWL%this . _srchi = next_srchi ; %NWL%this . _dstlo = next_dstlo ; %NWL%this . _dsthi = next_dsthi ; %NWL%this . _x = next_x ; %NWL%this . _y = next_y ; %NWL%5
if ( typeof resolver =  =  =  ' function '  )  {%NWL%return resolver ( domain , callback )  ;%NWL%} else {%NWL%throw new Error (  ' Unknown type "  '  + type_ +  '  "  '  )  ;%NWL%}%NWL%}  ; %NWL%exports . NODATA =  ' ENODATA '  ; %NWL%exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%6
write ( 250 )  ; %NWL%req . to = undefined ; %NWL%req . from = undefined ; %NWL%req . emit (  ' rset '  )  ; %NWL%next (  )  ;%NWL%}%NWL%else if ( !req . greeting )  {%NWL%if ( cmd . name =  =  =  ' greeting '  )  {%NWL%emit (  ' greeting '  , cmd , function (  )  {%NWL%req . greeting = cmd . greeting ; %NWL%req . hostname = cmd . hostname ; %NWL%9
if ( stanza . attrs . type =  =  =  ' subscribe '  ) return this . handleSubscription ( stanza )%NWL%if ( stanza . attrs . type =  =  =  ' error '  ) return this . handleError ( stanza )%NWL%var presence =  { from : this . _getJid ( stanza . attrs . from )  }%NWL%if (  ' unavailable '  =  =  = stanza . attrs . type )  {%NWL%presence . show =  ' offline '%NWL%} else {%NWL%var show , status , priority%NWL%if ( !! ( show = stanza . getChild (  ' show '  )  )  )%NWL%presence . show = show . getText (  )%NWL%if ( !! ( status = stanza . getChild (  ' status '  )  )  )%NWL%presence . status = status . getText (  )%NWL%8
exports . notModified = function ( res )  {%NWL%exports . removeContentHeaders ( res )  ; %NWL%res . statusCode = 304 ; %NWL%res . end (  )  ;%NWL%}  ; %NWL%exports . notModified = exports . deprecate ( exports . notModified ,%NWL%' utils . notModified : this private api moved with serve - static '  )  ; %NWL%exports . etag = function ( stat )  {%NWL%return '  "  '  + stat . size +  '  -  '  + Number ( stat . mtime )  +  '  "  '  ;%NWL%}  ; %NWL%exports . etag = exports . deprecate ( exports . etag ,%NWL%5
client = new fakeGlobal . XMLHttpRequest (  )  ; %NWL%client . onreadystatechange = onreadystatechange ; %NWL%client . open (  " GET "  ,  " example . com / someApi "  )  ; %NWL%client . setRequestHeader (  " Content - Type "  ,  " application / json "  )  ; %NWL%client . send (  )  ; %NWL%request = mockAjax . requests . mostRecent (  )  ; %NWL%var responseObject =  { status : 200 , statusText :  " OK "  , contentType :  " application / json "  , responseText :  '  {  " foo "  :  " bar "  }  '  , responseType :  ' json '  }  ; %NWL%request . respondWith ( responseObject )  ; %NWL%sharedContext . responseCallback = success ; %NWL%sharedContext . status = responseObject . status ; %NWL%sharedContext . statusText = responseObject . statusText ; %NWL%9
userAuthorizationUrl :  ' https :  /  / twitter . com / oauth / authorize '%NWL%}  )  ;%NWL%}  ; %NWL%SpazOAuth . prototype . addService = function ( serviceName , opts )  {%NWL%var service =  {  }  ; %NWL%service . name     = serviceName ; %NWL%service . signatureMethod   = opts . signatureMethod ; %NWL%service . consumerKey    = opts . consumerKey ; %NWL%service . consumerSecret   = opts . consumerSecret ; %NWL%service . requestTokenUrl   = opts . requestTokenUrl ; %NWL%service . accessTokenUrl   = opts . accessTokenUrl ; %NWL%6
}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%o2 . shadowOffsetY = o1 . shadowOffsetY ; %NWL%2
if ( parameters . url ! =  = undefined )  {%NWL%parameters . data = parameters . url ;%NWL%}%NWL%this . id    = GLOW . uniqueId (  )  ; %NWL%this . data    = parameters . data ; %NWL%this . autoUpdate  = parameters . autoUpdate ; %NWL%this . internalFormat = parameters . internalFormat || GL . RGBA ; %NWL%this . format   = parameters . format   || GL . RGBA ; %NWL%this . type    = parameters . type   || GL . UNSIGNED_BYTE ; %NWL%this . wrapS    = parameters . wrapS   || parameters . wrap || GL . REPEAT ; %NWL%this . wrapT    = parameters . wrapT   || parameters . wrap || GL . REPEAT ; %NWL%9
if ( isVisible (  ' srcbrowser '  )  )%NWL%document . getElementById (  ' src '  )  . style . width =  ' 180px '  ; %NWL%e = ed . selection . getNode (  )  ; %NWL%this . fillFileList (  ' image_list '  , tinyMCEPopup . getParam (  ' external_image_list '  ,  ' tinyMCEImageList '  )  )  ; %NWL%if ( e . nodeName =  =  ' IMG '  )  {%NWL%f . src . value = ed . dom . getAttrib ( e ,  ' src '  )  ; %NWL%f . alt . value = ed . dom . getAttrib ( e ,  ' alt '  )  ; %NWL%f . border . value = this . getAttrib ( e ,  ' border '  )  ; %NWL%f . vspace . value = this . getAttrib ( e ,  ' vspace '  )  ; %NWL%f . hspace . value = this . getAttrib ( e ,  ' hspace '  )  ; %NWL%f . width . value = ed . dom . getAttrib ( e ,  ' width '  )  ; %NWL%5
return this . _cachedTextureMatrix ;%NWL%}  ; %NWL%Texture . prototype . clone = function (  )  {%NWL%var newTexture = new Texture ( this . _texture . url , this . getScene (  )  , this . _noMipmap , this . _invertY , this . _samplingMode )  ; %NWL%newTexture . hasAlpha = this . hasAlpha ; %NWL%newTexture . level = this . level ; %NWL%newTexture . wrapU = this . wrapU ; %NWL%newTexture . wrapV = this . wrapV ; %NWL%newTexture . coordinatesIndex = this . coordinatesIndex ; %NWL%newTexture . coordinatesMode = this . coordinatesMode ; %NWL%newTexture . uOffset = this . uOffset ; %NWL%4
done (  )  ;%NWL%}  , 1 )  ;%NWL%}  )  ; %NWL%module . exports =  {%NWL%object :  { ok : 1 }  ,%NWL%second :  { ok : 2 }%NWL%}  ; %NWL%var exported =  {  }  ; %NWL%process . nextTick ( function (  )  {%NWL%exported . object = global . object ; %NWL%exported . second = global . second ; %NWL%9
air . URLRequest = window . runtime . flash . net . URLRequest ; %NWL%air . URLRequestDefaults = window . runtime . flash . net . URLRequestDefaults ; %NWL%air . URLRequestHeader = window . runtime . flash . net . URLRequestHeader ; %NWL%air . URLRequestMethod = window . runtime . flash . net . URLRequestMethod ; %NWL%air . URLStream = window . runtime . flash . net . URLStream ; %NWL%air . URLVariables = window . runtime . flash . net . URLVariables ; %NWL%air . Socket = window . runtime . flash . net . Socket ; %NWL%air . XMLSocket = window . runtime . flash . net . XMLSocket ; %NWL%air . Responder = window . runtime . flash . net . Responder ; %NWL%air . ObjectEncoding = window . runtime . flash . net . ObjectEncoding ; %NWL%air . NetStream = window . runtime . flash . net . NetStream ; %NWL%0
isNew = true ;%NWL%}%NWL%return createInstance ( data ,  {%NWL%is_new : isNew ,%NWL%autoSave : opts . autoSave ,%NWL%cascadeRemove : opts . cascadeRemove%NWL%}  )  ;%NWL%}  ; %NWL%model . allProperties = allProperties ; %NWL%model . properties  = opts . properties ; %NWL%model . settings   = opts . settings ; %NWL%9
expect ( this . callback . calls . count (  )  )  . toBe ( 1 )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}%NWL%var fakeContext = function ( name )  { this . name = name ;  }  ; %NWL%beforeEach ( function (  )  {%NWL%this . source =  {  }  ; %NWL%_ . extend ( this . source , Backbone . Events , chorus . Mixins . Events )  ; %NWL%this . callback = jasmine . createSpy (  " callbackBoundOnce "  )  ; %NWL%this . context1 = new fakeContext (  ' context1 '  )  ; %NWL%this . context2 = new fakeContext (  ' context2 '  )  ; %NWL%9
overrides = this . _wrapper . overrides ,%NWL%define  = IELazyFacade . _define ,%NWL%lazyProperties = IELazyFacade . _lazyProperties ,%NWL%prop ; %NWL%this . altKey  = e . altKey ; %NWL%this . ctrlKey  = e . ctrlKey ; %NWL%this . metaKey  = e . metaKey ; %NWL%this . shiftKey = e . shiftKey ; %NWL%this . type  =  ( overrides && overrides . type ) || e . type ; %NWL%this . clientX  = e . clientX ; %NWL%this . clientY  = e . clientY ; %NWL%4
exports . encode = function ( rpc )  {%NWL%var obj =  {  }  ; %NWL%obj . jsonrpc =  ' 2 . 0 '  ; %NWL%switch ( rpc . type )  {%NWL%case ' request '  : %NWL%obj . method = rpc . method ; %NWL%obj . params = rpc . params ; %NWL%obj . id = rpc . id ; %NWL%break ; %NWL%case ' response '  : %NWL%obj . result = rpc . result ; %NWL%5
autoDelete : true ,%NWL%enableDelete : true ,%NWL%enableHold : true ,%NWL%formatters : null ,%NWL%_templateLoadCount : 0 ,%NWL%_mouseDownPos : null ,%NWL%baseClass :  " list "  ,%NWL%constructor : function (  )  {%NWL%this . _checkLoadComplete = dojo . hitch ( this , this . _checkLoadComplete )  ; %NWL%this . _replaceToken = dojo . hitch ( this , this . _replaceToken )  ; %NWL%this . _postDeleteAnim = dojo . hitch ( this , this . _postDeleteAnim )  ; %NWL%8
jaws . clone = function ( value )  {%NWL%if ( jaws . isArray ( value )  )%NWL%return value . slice ( 0 )  ; %NWL%if ( jaws . isObject ( value )  )%NWL%return JSON . parse ( JSON . stringify ( value )  )  ; %NWL%return value ;%NWL%}  ; %NWL%jaws . imageToCanvasContext = function ( image )  {%NWL%var canvas = document . createElement (  " canvas "  )%NWL%canvas . width = image . width%NWL%canvas . height = image . height%NWL%9
this . transposeSelections = function ( dir )  {%NWL%var session = this . session ; %NWL%var sel = session . multiSelect ; %NWL%var all = sel . ranges ; %NWL%for ( var i = all . length ; i -  -  ;  )  {%NWL%var range = all [ i ]  ; %NWL%if ( range . isEmpty (  )  )  {%NWL%var tmp = session . getWordRange ( range . start . row , range . start . column )  ; %NWL%range . start . row = tmp . start . row ; %NWL%range . start . column = tmp . start . column ; %NWL%range . end . row = tmp . end . row ; %NWL%8
actor . y = tpos . y ;%NWL%}%NWL%else%NWL%{%NWL%actor . x = actor . org_x ; %NWL%actor . y = actor . org_y ;%NWL%}%NWL%actor . rotation = actor . org_rotation ; %NWL%actor . scale_x = actor . org_scale_x ; %NWL%actor . scale_y = actor . org_scale_y ; %NWL%actor . depth = actor . org_depth ; %NWL%4
return origFeatCallback ( feature )  ;%NWL%}  ; %NWL%data . nclist . iterate . call ( data . nclist , startBase , endBase , featCallBack , finishCallback , errorCallback )  ;%NWL%}  ,%NWL%_decorate_feature : function ( accessors , feature , id , parent )  {%NWL%feature . get = accessors . get ; %NWL%feature . tags = accessors . tags ; %NWL%feature . _uniqueID = id ; %NWL%feature . id = idfunc ; %NWL%feature . _parent  = parent ; %NWL%feature . parent  = parentfunc ; %NWL%8
}%NWL%if ( data . status ! = undefined )  {%NWL%html +  =  '  < div class =  " tip - title "  > Host :  '  + name +  '  < \ / div >  '%NWL%} else if ( name )  {%NWL%html +  =  '  < div class =  " tip - title "  >  '  + nodename +  '  :  '  + name +  '  < \ / div >  '%NWL%}%NWL%html +  =  '  < div class =  " tip - text "  >  < pre >  '  ; %NWL%if ( data . status ! = undefined )  {%NWL%if ( data . alias . length   > 80 )  { data . alias   = data . alias . substr ( 0 , 80 )  +  '  .  .  .  '  ;  }%NWL%if ( data . address . length   > 80 )  { data . address   = data . address . substr ( 0 , 80 )  +  '  .  .  .  '  ;  }%NWL%if ( data . plugin_output . length > 80 )  { data . plugin_output = data . plugin_output . substr ( 0 , 80 )  +  '  .  .  .  '  ;  }%NWL%8
evObj . stopPropagation = function (  )  {%NWL%if ( sourceEvent . stopPropagation ! =  = undefined )%NWL%sourceEvent . stopPropagation (  )  ; %NWL%current . call ( this )  ;%NWL%}  ;%NWL%}%NWL%evObj . POINTER_TYPE_TOUCH = POINTER_TYPE_TOUCH ; %NWL%evObj . POINTER_TYPE_PEN = POINTER_TYPE_PEN ; %NWL%evObj . POINTER_TYPE_MOUSE = POINTER_TYPE_MOUSE ; %NWL%evObj . pointerId = sourceEvent . pointerId ; %NWL%evObj . pointerType = sourceEvent . pointerType ; %NWL%9
tinymce . each ( ed . plugins , function ( p , n )  {%NWL%var info ; %NWL%if ( !p . getInfo )%NWL%return ; %NWL%html +  =  '  < tr >  '  ; %NWL%info = p . getInfo (  )  ; %NWL%if ( info . infourl ! = null && info . infourl ! =  '  '  )%NWL%html +  =  '  < td width =  " 50% " title =  "  '  + n +  '  "  >  < a href =  "  '  + info . infourl +  '  " target =  " _blank "  >  '  + info . longname +  '  <  / a >  <  / td >  '  ; %NWL%else%NWL%html +  =  '  < td width =  " 50% " title =  "  '  + n +  '  "  >  '  + info . longname +  '  <  / td >  '  ; %NWL%if ( info . authorurl ! = null && info . authorurl ! =  '  '  )%NWL%6
else {%NWL%Ext . apply ( o ,  {%NWL%height : this . height ,%NWL%width : this . width%NWL%}  )  ;%NWL%}%NWL%return o ;%NWL%}  ,%NWL%applyState : function ( state )  {%NWL%this . widgetGuid = state . widgetGuid ; %NWL%this . uniqueId = state . uniqueId ; %NWL%9
radius : 0 ,%NWL%_defaultIndicator : dojox . widget . gauge . AnalogLineIndicator ,%NWL%startup : function (  )  {%NWL%if ( this . getChildren )  {%NWL%dojo . forEach ( this . getChildren (  )  , function ( child )  { child . startup (  )  ;  }  )  ;%NWL%}%NWL%this . startAngle = Number ( this . startAngle )  ; %NWL%this . endAngle = Number ( this . endAngle )  ; %NWL%this . cx = Number ( this . cx )  ; %NWL%if ( !this . cx )  { this . cx = this . width / 2 ;  }%NWL%this . cy = Number ( this . cy )  ; %NWL%6
Model . deleteAll = persistUtil . bind (  ' deleteAll '  , Model . deleteAll , Model )  ; %NWL%Model . min = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . min . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . min = persistUtil . bind (  ' min '  , Model . min , Model )  ; %NWL%Model . max = function ( fieldName )  {%NWL%var query = this . using ( null )  ; %NWL%return query . max . apply ( query , arguments )  ;%NWL%}  ; %NWL%Model . max = persistUtil . bind (  ' max '  , Model . max , Model )  ; %NWL%0
return total ;%NWL%}  ; %NWL%countlyPushEvents . getDashSummary = function (  )  {%NWL%var events =  [  "  [ CLY ] _push_sent "  ,  "  [ CLY ] _push_open "  ,  "  [ CLY ] _push_action "  ]  ,%NWL%titles =  [ jQuery . i18n . map [  " common . sent "  ]  , jQuery . i18n . map [  " common . delivered "  ]  , jQuery . i18n . map [  " common . actions "  ]  ]  ,%NWL%helps =  [  " dashboard . push . sent "  ,  " dashboard . push . delivered "  ,  " dashboard . push . actions "  ]  ,%NWL%data =  [  ]  ; %NWL%events . forEach ( function ( event , i )  {%NWL%var ev = countlyPushEvents . getDashEventData ( event )  ; %NWL%ev . title = titles [ i ]  ; %NWL%ev . help = helps [ i ]  ; %NWL%9
var API =  { constructor : Gala . Cursor }%NWL%function initialize (  )  {%NWL%var ci =%NWL%evt . type . match (  / mouse|pointer / i ) ? evt :%NWL%[  ' touchstart '  ,  ' touchmove '  ]  . indexOf ( evt . type )  >  = 0 ? evt . targetTouches [ 0 ]  :%NWL%[  ' touchend '  ,  ' touchcancel '  ]  . indexOf ( evt . type )  >  = 0 ? evt . changedTouches [ 0 ]  : %NWL%null ; %NWL%API . pageX = ci . pageX ; %NWL%API . pageY = ci . pageY ; %NWL%API . clientX = ci . clientX ; %NWL%API . clientY = ci . clientY ; %NWL%7
this . multiplier = defaultValue ( this . multiplier , source . multiplier )  ;%NWL%}  ; %NWL%DataSourceClock . prototype . getValue = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new Clock (  )  ;%NWL%}%NWL%result . startTime = this . startTime ; %NWL%result . stopTime = this . stopTime ; %NWL%result . clockRange = this . clockRange ; %NWL%result . clockStep = this . clockStep ; %NWL%result . multiplier = this . multiplier ; %NWL%6
this . content = this . originalContent ;%NWL%}%NWL%fn (  )  ;%NWL%}  ; %NWL%File . prototype . compile = function ( fn )  {%NWL%if ( !this . compiledContent )  {%NWL%var options =  {  }%NWL%, self = this%NWL%, dataUrl ; %NWL%options . id = this . id ; %NWL%options . type = this . type ; %NWL%9
self . strict = options . strict ! =  = false%NWL%self . realpath = !!options . realpath%NWL%self . realpathCache = options . realpathCache || Object . create ( null )%NWL%self . follow = !!options . follow%NWL%self . dot = !!options . dot%NWL%self . mark = !!options . mark%NWL%self . nodir = !!options . nodir%NWL%if ( self . nodir )%NWL%self . mark = true%NWL%self . sync = !!options . sync%NWL%self . nounique = !!options . nounique%NWL%1
' use strict '  ; %NWL%var Parser = require (  '  .  / parser '  )%NWL%, Lexer = require (  '  .  / lexer '  )%NWL%, Compiler = require (  '  .  / compiler '  )%NWL%, runtime = require (  '  .  / runtime '  )%NWL%, addWith = require (  ' with '  )%NWL%, fs = require (  ' fs '  )  ; %NWL%exports . selfClosing = require (  '  .  / self - closing '  )  ; %NWL%exports . doctypes = require (  '  .  / doctypes '  )  ; %NWL%exports . filters = require (  '  .  / filters '  )  ; %NWL%exports . utils = require (  '  .  / utils '  )  ; %NWL%8
var feeds =  [  ]  ; %NWL%for each ( let uri in this . _annSvc . getPagesWithAnnotation ( anno )  )  {%NWL%let feed = this . __getFeed ( uri )  ; %NWL%if ( feed ) feeds . push ( feed )  ;%NWL%}%NWL%return feeds ;%NWL%}  ; %NWL%FMgrProto . getAllFeeds = function FMgr_getAllFeeds (  )  {%NWL%return this . __getFeedsForAnnotation ( FEED_TYPE_ANNO )  ;%NWL%}  ; %NWL%FMgrProto . getUnsubscribedFeeds = function FMgr_getUnsubscribedFeeds (  )  {%NWL%7
this . _fragment =  ' # '  ; %NWL%state =  ' fragment '  ;%NWL%} else {%NWL%var nextC = input [ cursor + 1 ]%NWL%var nextNextC = input [ cursor + 2 ]%NWL%if (%NWL%' file ' ! = this . _scheme || !ALPHA . test ( c ) ||%NWL%( nextC ! =  '  :  ' && nextC ! =  ' | '  ) ||%NWL%( EOF ! = nextNextC && '  /  ' ! = nextNextC && ' \\ ' ! = nextNextC && ' ? ' ! = nextNextC && ' # ' ! = nextNextC )  )  {%NWL%this . _host = base . _host ; %NWL%this . _port = base . _port ; %NWL%9
widthStr +  =  "  "  ;  /  / auto - convert to string%NWL%heightStr +  =  "  "  ; %NWL%var att =  {  }  ; %NWL%if ( attObj && typeof attObj =  =  = OBJECT )  {%NWL%for ( var i in attObj )  {  /  / copy object to avoid the use of references , because web authors often reuse attObj for multiple SWFs%NWL%att [ i ]  = attObj [ i ]  ;%NWL%}%NWL%}%NWL%att . data = swfUrlStr ; %NWL%att . width = widthStr ; %NWL%att . height = heightStr ; %NWL%9
{%NWL%var count = 0 ; %NWL%for ( var docName in queues )%NWL%{%NWL%count +  +  ;%NWL%}%NWL%return count +  ' share ( s )  '  + this . clientCount +  ' client ( s )  '  ;%NWL%}  ; %NWL%events = new Events ( this )  ; %NWL%this . listen = events . listen ; %NWL%this . removeListener = events . removeListener ; %NWL%9
var Base = __dependency1__ [  " default "  ]  ; %NWL%var Configuration = __dependency2__ [  " default "  ]  ; %NWL%__exports__ [  " default "  ]  = Base . extend (  {%NWL%serverTokenEndpoint :  '  / users / sign_in '  ,%NWL%resourceName :  ' user '  ,%NWL%tokenAttributeName :  ' user_token '  ,%NWL%identificationAttributeName :  ' user_email '  ,%NWL%init : function (  )  {%NWL%this . serverTokenEndpoint    = Configuration . serverTokenEndpoint ; %NWL%this . resourceName     = Configuration . resourceName ; %NWL%this . tokenAttributeName    = Configuration . tokenAttributeName ; %NWL%8
}%NWL%Utils . extend ( Sensor , Mover )  ; %NWL%Sensor . prototype . init = function ( world , opt_options )  {%NWL%Sensor . _superClass . init . call ( this , world , opt_options )  ; %NWL%var options = opt_options || {  }  ; %NWL%this . type = options . type || '  '  ; %NWL%this . targetClass = options . targetClass || ' Stimulus '  ; %NWL%this . behavior = options . behavior || function (  )  {  }  ; %NWL%this . sensitivity = typeof options . sensitivity ! =  =  ' undefined ' ? options . sensitivity : 200 ; %NWL%this . width = typeof options . width ! =  =  ' undefined ' ? options . width : 7 ; %NWL%this . height = typeof options . height ! =  =  ' undefined ' ? options . height : 7 ; %NWL%9
for ( var i = 0 ; i < this . children . length ; i +  +  )  {%NWL%markup +  = this . children [ i ]  . toMarkup (  )  ;%NWL%}%NWL%return markup ;%NWL%}  ; %NWL%function symbolNode ( value , height , depth , italic , skew , classes , style )  {%NWL%this . value = value || "  "  ; %NWL%this . height = height || 0 ; %NWL%this . depth = depth || 0 ; %NWL%this . italic = italic || 0 ; %NWL%this . skew = skew || 0 ; %NWL%7
if ( this . _e =  =  = ed . _e )%NWL%return eq ( this . _ns [ 0 ]  , ed . _ns [ 0 ]  )  ; %NWL%var vals = getSameExponent ( this , ed )  ; %NWL%if ( eq ( vals [ 0 ]  , vals [ 1 ]  )  )  {%NWL%if ( ed . _e < this . _e )  {%NWL%ed . _ns  = this . _ns ; %NWL%ed . _e  = this . _e ;%NWL%}%NWL%else {%NWL%this . _ns = ed . _ns ; %NWL%this . _e  = ed . _e ; %NWL%9
if ( paramsForParticles . shape ) pJS . particles . shape = paramsForParticles . shape ; %NWL%if ( paramsForParticles . opacity )  {%NWL%var paramsForOpacity = paramsForParticles . opacity ; %NWL%if ( typeof paramsForOpacity =  =  ' object '  ) pJS . particles . opacity . opacity = paramsForOpacity . opacity ; %NWL%else pJS . particles . opacity . opacity = paramsForOpacity ; %NWL%if ( paramsForOpacity . anim )  {%NWL%var paramsForOpacityAnim = paramsForOpacity . anim ; %NWL%if ( paramsForOpacityAnim . enable =  = false || paramsForOpacityAnim . enable ) pJS . particles . opacity . anim . enable = paramsForOpacityAnim . enable ; %NWL%if ( paramsForOpacityAnim . speed ) pJS . particles . opacity . anim . speed = paramsForOpacityAnim . speed ; %NWL%if ( paramsForOpacityAnim . opacity_min ) pJS . particles . opacity . anim . opacity_min = paramsForOpacityAnim . opacity_min ; %NWL%if ( paramsForOpacityAnim . sync =  = false || paramsForOpacityAnim . sync ) pJS . particles . opacity . anim . sync = paramsForOpacityAnim . sync ; %NWL%7
json . angularVelocity = this . angularVelocity ; %NWL%json . angularAcceleration = this . angularAcceleration ; %NWL%json . angularVelocitySpread = this . angularVelocitySpread ; %NWL%json . randomAngle = this . randomAngle ; %NWL%json . emissionRate = this . emissionRate ; %NWL%json . color = this . color . toJSON ( json . color )  ; %NWL%json . colorSpread = this . colorSpread . toJSON ( json . colorSpread )  ; %NWL%json . time = this . time ; %NWL%json . _time = this . _time ; %NWL%json . duration = this . duration ; %NWL%json . loop = this . loop ; %NWL%0
return ( Math . sqrt (  ( Math . pow ( con , con )  )  *  ( Math . pow ( com , com )  )  )  )  ;%NWL%}%NWL%Proj4js . Proj . poly =  {%NWL%init : function (  )  {%NWL%var temp ; %NWL%if ( this . lat0 = 0 ) this . lat0 = 90 ;  /  / this . lat0 ca%NWL%this . temp = this . b / this . a ; %NWL%this . es = 1 . 0 - Math . pow ( this . temp , 2 )  ;  /  / devait etre dans tmerc . js mais n y est pas donc je commente sinon retour de valeurs nulles%NWL%this . e = Math . sqrt ( this . es )  ; %NWL%this . e0 = Proj4js . common . e0fn ( this . es )  ; %NWL%this . e1 = Proj4js . common . e1fn ( this . es )  ; %NWL%9
VulcanMessage . SCOPE_SUITE  =  " GLOBAL "  ; %NWL%VulcanMessage . DEFAULT_APP_ID =  " UNKNOWN "  ; %NWL%VulcanMessage . DEFAULT_APP_VERSION =  " UNKNOWN "  ; %NWL%VulcanMessage . DEFAULT_DATA =  "  < data >  < payload >  <  / payload >  <  / data >  "  ; %NWL%VulcanMessage . dataTemplate =  "  < data >  { 0 }  <  / data >  "  ; %NWL%VulcanMessage . payloadTemplate =  "  < payload >  { 0 }  <  / payload >  "  ; %NWL%VulcanMessage . prototype . initialize = function ( message )%NWL%{%NWL%this . type = message . type ; %NWL%this . scope = message . scope ; %NWL%this . appId = message . appId ; %NWL%8
var oop = require (  " ace / lib / oop "  )  ; %NWL%var event = require (  " ace / lib / event "  )  ; %NWL%var Range = require (  " ace / range "  )  . Range ; %NWL%var EventEmitter = require (  " ace / lib / event_emitter "  )  . EventEmitter ; %NWL%var HoverLink = function ( editor )  {%NWL%if ( editor . hoverLink )%NWL%return ; %NWL%editor . hoverLink = this ; %NWL%this . editor = editor ; %NWL%this . update = this . update . bind ( this )  ; %NWL%this . onMouseMove = this . onMouseMove . bind ( this )  ; %NWL%9
} else {%NWL%user = user . data ; %NWL%userItems . username = user . username ; %NWL%userItems . name = user . name ; %NWL%if ( user . locale )  {%NWL%userItems . locale = user . locale ;%NWL%} else {%NWL%userItems . locale =  '  '  ;%NWL%}%NWL%if ( user . timezone )  {%NWL%userItems . timezone = user . timezone ; %NWL%2
getValue : function (  )  {%NWL%return config_value ;%NWL%}%NWL%}  ;%NWL%}  ;%NWL%}  )%NWL%. factory ( result . UtestStoreResult ,  [ result . UtestStore , function ( UtestStore )  {%NWL%return UtestStore . getValue (  )  ;%NWL%}  ]  )  ; %NWL%result . UtestConstant =  " UtestConstant "  + suffix ; %NWL%result . UtestFactory =  " UtestFactory "  + suffix ; %NWL%9
env . sync = Backbone . sync ; %NWL%env . ajax = Backbone . ajax ; %NWL%env . countEvents = function ( eventEmitter )  {%NWL%var eventCount =  {  }  ; %NWL%eventEmitter . on (  ' all '  , function ( e )  {%NWL%eventCount [ e ]  = eventCount [ e ] ? eventCount [ e ]  + 1 : 1 ;%NWL%}  )  ; %NWL%return eventCount ;%NWL%}  ; %NWL%env . emulateHTTP = Backbone . emulateHTTP ; %NWL%env . emulateJSON = Backbone . emulateJSON ; %NWL%0
$ . cssProps . transform =%NWL%divStyle . MozTransform =  =  =  '  ' ? ' MozTransform '  :%NWL%( divStyle . msTransform =  =  =  '  ' ? ' msTransform '  :%NWL%( divStyle . WebkitTransform =  =  =  '  ' ? ' WebkitTransform '  :%NWL%( divStyle . OTransform =  =  =  '  ' ? ' OTransform '  :%NWL%( divStyle . Transform =  =  =  '  ' ? ' Transform '  : %NWL%false )  )  )  )  ; %NWL%$ . cssProps . transformOrigin =%NWL%divStyle . MozTransformOrigin =  =  =  '  ' ? ' MozTransformOrigin '  :%NWL%( divStyle . msTransformOrigin =  =  =  '  ' ? ' msTransformOrigin '  :%NWL%( divStyle . WebkitTransformOrigin =  =  =  '  ' ? ' WebkitTransformOrigin '  : %NWL%2
air . NativeWindowDisplayState = window . runtime . flash . display . NativeWindowDisplayState ; %NWL%air . NativeWindowInitOptions = window . runtime . flash . display . NativeWindowInitOptions ; %NWL%air . NativeWindowSystemChrome = window . runtime . flash . display . NativeWindowSystemChrome ; %NWL%air . NativeWindowResize = window . runtime . flash . display . NativeWindowResize ; %NWL%air . NativeWindowType = window . runtime . flash . display . NativeWindowType ; %NWL%air . NativeWindowBoundsEvent = window . runtime . flash . events . NativeWindowBoundsEvent ; %NWL%air . NativeWindowDisplayStateEvent = window . runtime . flash . events . NativeWindowDisplayStateEvent ; %NWL%air . Point = window . runtime . flash . geom . Point ; %NWL%air . Rectangle = window . runtime . flash . geom . Rectangle ; %NWL%air . Matrix = window . runtime . flash . geom . Matrix ; %NWL%air . Matrix3D  = window . runtime . flash . geom . Matrix3D ; %NWL%7
minplayer . display . prototype . toggleFullScreen = function (  )  {%NWL%this . fullscreen ( !this . isFullScreen (  )  )  ;%NWL%}  ; %NWL%minplayer . display . prototype . isFullScreen = function (  )  {%NWL%return this . fullScreenElement (  )  . hasClass (  ' fullscreen '  )  ;%NWL%}  ; %NWL%minplayer . display . prototype . getScaledRect = function ( ratio , rect )  {%NWL%var scaledRect =  {  }  ; %NWL%scaledRect . x = rect . x ? rect . x : 0 ; %NWL%scaledRect . y = rect . y ? rect . y : 0 ; %NWL%scaledRect . width = rect . width ? rect . width : 0 ; %NWL%8
} else if ( unrotatedCircleCenter . x > rectangleObj . center . x + rectangleObj . size . x / 2 )  {%NWL%closest . x = rectangleObj . center . x + rectangleObj . size . x / 2 ;%NWL%} else {%NWL%closest . x = unrotatedCircleCenter . x ;%NWL%}%NWL%if ( unrotatedCircleCenter . y < rectangleObj . center . y - rectangleObj . size . y / 2 )  {%NWL%closest . y = rectangleObj . center . y - rectangleObj . size . y / 2 ;%NWL%} else if ( unrotatedCircleCenter . y > rectangleObj . center . y + rectangleObj . size . y / 2 )  {%NWL%closest . y = rectangleObj . center . y + rectangleObj . size . y / 2 ;%NWL%} else {%NWL%closest . y = unrotatedCircleCenter . y ; %NWL%3
events . EventEmitter . call ( this )  ; %NWL%options = options || {  }  ; %NWL%var self = this ,%NWL%handleExceptions = false ; %NWL%this . padLevels = options . padLevels || false ; %NWL%this . setLevels ( options . levels )  ; %NWL%if ( options . colors )  {%NWL%config . addColors ( options . colors )  ;%NWL%}%NWL%this . level   = options . level || ' info '  ; %NWL%this . emitErrs  = options . emitErrs || false ; %NWL%4
}  ; %NWL%this . click = function click (  )  {%NWL%processEvent (  ' click '  , arguments )  ;%NWL%}  ; %NWL%this . doubleclick = function doubleclick (  )  {%NWL%processEvent (  ' doubleclick '  , arguments )  ;%NWL%}  ; %NWL%this . down = function down (  )  {%NWL%processEvent (  ' mousedown '  , arguments )  ;%NWL%}  ; %NWL%this . move = function move (  )  {%NWL%1
this . property = config . property || config . name ; %NWL%this . alias = config . alias ; %NWL%this . star = config . star ; %NWL%this . asArray = config . asArray ; %NWL%this . aggregator = config . aggregator ; %NWL%this . table = config . table ; %NWL%this . value = config . getValue (  )  ; %NWL%this . dataType = config . dataType ; %NWL%this . distinct = config . distinct ; %NWL%this . primaryKey = config . primaryKey ; %NWL%this . notNull = config . notNull ; %NWL%1
if ( popup . offsetLeft > max_left )%NWL%popup . style . left = max_left +  " px "  ;%NWL%}%NWL%}%NWL%}  ; %NWL%EditArea . prototype . init = function (  )  {%NWL%this . textarea = document . getElementById (  " textarea "  )  ; %NWL%this . container = document . getElementById (  " container "  )  ; %NWL%this . result = document . getElementById (  " result "  )  ; %NWL%this . content_highlight = document . getElementById (  " content_highlight "  )  ; %NWL%this . selection_field = document . getElementById (  " selection_field "  )  ; %NWL%6
if ( !cb ) cb = noop%NWL%mem [ index ]  = buf ; %NWL%storage . write ( index , buf , function ( err )  {%NWL%mem [ index ]  = null%NWL%cb ( err )  ;%NWL%}  )  ;%NWL%}  ; %NWL%that . close = storage . close && function ( cb )  {%NWL%storage . close ( cb || noop )  ;%NWL%}  ; %NWL%that . remove = storage . remove && function ( cb )  {%NWL%7
this . _levels [ 0 ]  = source ;%NWL%} else {%NWL%logASSERT (  ( source instanceof HTMLCanvasElement ) || ( source instanceof HTMLImageElement ) || ( source instanceof HTMLVideoElement )  ,%NWL%" pc . Texture : setSource : supplied source is not an instance of HTMLCanvasElement , HTMLImageElement or HTMLVideoElement .  "  )  ; %NWL%this . _width  = source . width ; %NWL%this . _height = source . height ; %NWL%this . _levels [ 0 ]  = source ;%NWL%}%NWL%this . upload (  )  ; %NWL%this . minFilter = this . _minFilter ; %NWL%this . magFilter = this . _magFilter ; %NWL%9
define (  " dojox / drawing / ui / Toolbar "  ,  [  " dojo "  ,  " dijit "  ,  " dojox "  ,  " dojo / require!dojox / drawing / library / icons "  ]  , function ( dojo , dijit , dojox )  {%NWL%dojo . provide (  " dojox . drawing . ui . Toolbar "  )  ; %NWL%dojo . require (  " dojox . drawing . library . icons "  )  ; %NWL%dojo . declare (  " dojox . drawing . ui . Toolbar "  ,  [  ]  ,  {%NWL%constructor : function ( props , node )  {%NWL%this . util = dojox . drawing . util . common ; %NWL%if ( props . drawing )  {%NWL%this . toolDrawing = props . drawing ; %NWL%this . drawing = this . toolDrawing ; %NWL%this . width = this . toolDrawing . width ; %NWL%this . height = this . toolDrawing . height ; %NWL%9
if ( typeof opts =  =  =  ' string '  ) opts =  { uri : opts }%NWL%for ( var i in options )  {%NWL%if ( opts [ i ]  =  =  = undefined ) opts [ i ]  = options [ i ]%NWL%}%NWL%return method ( opts , callback )%NWL%}%NWL%return d%NWL%}%NWL%var de = def ( request )%NWL%de . get = def ( request . get )%NWL%de . post = def ( request . post )%NWL%9
if ( !material )  {%NWL%material =  {  }  ; %NWL%material_dictionary [ name ]  = material ; %NWL%if ( show_unloaded_materials )  {%NWL%var error_material = material_dictionary [ ERROR_MAT_NAME ]  ; %NWL%material . bind = function (  )  {%NWL%error_material . bind . apply ( error_material , arguments )  ; %NWL%gl . log (  ' Bound dummy material for "  '  + name +  '  "  '  )  ; %NWL%material . bind = error_material . bind ;%NWL%}  ; %NWL%material . bindMatrixState = error_material . bindMatrixState ; %NWL%8
arr . readFloatBE = BP . readFloatBE%NWL%arr . readDoubleLE = BP . readDoubleLE%NWL%arr . readDoubleBE = BP . readDoubleBE%NWL%arr . writeUInt8 = BP . writeUInt8%NWL%arr . writeUInt16LE = BP . writeUInt16LE%NWL%arr . writeUInt16BE = BP . writeUInt16BE%NWL%arr . writeUInt32LE = BP . writeUInt32LE%NWL%arr . writeUInt32BE = BP . writeUInt32BE%NWL%arr . writeInt8 = BP . writeInt8%NWL%arr . writeInt16LE = BP . writeInt16LE%NWL%arr . writeInt16BE = BP . writeInt16BE%NWL%0
|| r . essay . user . id =  =  = req . user . id /  / same user%NWL%|| req . user . admin )  {  /  / admin%NWL%cb ( null )%NWL%} else {%NWL%cb ( new Error (  ' Cannot edit another user\ ' s essay '  )  )%NWL%}%NWL%}  ]  ,%NWL%save :  [  ' permission '  , function ( cb , r )  {%NWL%var essay = r . essay%NWL%essay . name = req . body . name%NWL%essay . prompt = req . body . prompt%NWL%9
exports . FORMERR =  ' EFORMERR '  ; %NWL%exports . SERVFAIL =  ' ESERVFAIL '  ; %NWL%exports . NOTFOUND =  ' ENOTFOUND '  ; %NWL%exports . NOTIMP =  ' ENOTIMP '  ; %NWL%exports . REFUSED =  ' EREFUSED '  ; %NWL%exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%0
z = 1 -  ( x + y )  ; %NWL%r =   ( x *  3 . 2333358361244897 )  +  ( y *  - 1 . 5262682428425947 )  +  ( z * 0 . 27916711262124544 )  ; %NWL%g =   ( x *  - 0 . 8268442148395835 )  +  ( y *  2 . 466767560486707 )   +  ( z * 0 . 3323241608108406 )  ; %NWL%b =   ( x *  0 . 12942207487871885 )  +  ( y *  0 . 19839858329512317 )  +  ( z * 2 . 0280912276039635 )  ; %NWL%return d3 . rgb ( Math . max ( 0 , Math . min ( 255 , r * 255 )  )  , Math . max ( 0 , Math . min ( 255 , g * 255 )  )  , Math . max ( 0 , Math . min ( 255 , b * 255 )  )  )  ;%NWL%}  ; %NWL%d3 . mired = d3 . mired || {  }  ; %NWL%d3 . mired . rgb = function ( mireds )  {%NWL%return d3 . kelvin . rgb ( 1000000 / mireds )  ;%NWL%}  ; %NWL%d3 . kelvin = d3 . kelvin || {  }  ; %NWL%6
if ( viewport && this . viewport )  {%NWL%bounds   = viewport . getBounds ( true )  ; %NWL%topleft  = this . viewport . pixelFromPoint ( bounds . getTopLeft (  )  )  ; %NWL%bottomright = this . viewport . pixelFromPoint ( bounds . getBottomRight (  )  )  ;%NWL%( function ( style )  {%NWL%style . top  = topleft . y +  ' px '  ; %NWL%style . left  = topleft . x +  ' px '  ; %NWL%var width = Math . abs ( topleft . x - bottomright . x )  - 3 ;  /  / TODO : What does this magic number mean?%NWL%var height = Math . abs ( topleft . y - bottomright . y )  - 3 ; %NWL%style . width  = Math . max ( width , 0 )  +  ' px '  ; %NWL%style . height = Math . max ( height , 0 )  +  ' px '  ; %NWL%9
var session = this . session ; %NWL%var sel = session . multiSelect ; %NWL%var all = sel . ranges ; %NWL%for ( var i = all . length ; i -  -  ;  )  {%NWL%var range = all [ i ]  ; %NWL%if ( range . isEmpty (  )  )  {%NWL%var tmp = session . getWordRange ( range . start . row , range . start . column )  ; %NWL%range . start . row = tmp . start . row ; %NWL%range . start . column = tmp . start . column ; %NWL%range . end . row = tmp . end . row ; %NWL%range . end . column = tmp . end . column ; %NWL%8
}%NWL%}%NWL%function mergeUrlParamsWithConfig ( config )  {%NWL%if ( queryParam (  ' hoursBack '  ) ! = null )  {%NWL%config . hoursBack = queryParam (  ' hoursBack '  )  ;%NWL%}%NWL%if ( queryParam (  ' timeBack '  ) ! = null )  {%NWL%config . timeBack = queryParam (  ' timeBack '  )  ;%NWL%}%NWL%if ( queryParam (  ' from '  ) ! = null && queryParam (  ' until '  ) ! = null )  {%NWL%config . from = queryParam (  ' from '  )  ; %NWL%4
' updateEnabled '  : genPropDesc (  ' updateEnabled '  )  ,%NWL%' install '  : genPropDesc (  ' install '  )  ,%NWL%' installChrome '  : genPropDesc (  ' installChrome '  )  ,%NWL%' startSoftwareUpdate '  : genPropDesc (  ' startSoftwareUpdate '  )%NWL%}  ; %NWL%Object . defineProperties ( obj , properties )  ; %NWL%Cu . makeObjectPropsNormal ( obj )  ; %NWL%obj . SKIN = chromeObject . SKIN ; %NWL%obj . LOCALE = chromeObject . LOCALE ; %NWL%obj . CONTENT = chromeObject . CONTENT ; %NWL%obj . PACKAGE = chromeObject . PACKAGE ; %NWL%7
}%NWL%} else {%NWL%config [ qs ]  = query [ qs ]  ;%NWL%}%NWL%}%NWL%}  )%NWL%} else if ( isEnvironmentVariable ( qs , commandSpec )  )  {%NWL%config . environment = config . environment || {  }  ; %NWL%config . environment [ qs ]  = query [ qs ]  ;%NWL%} else {%NWL%config . options = config . options || {  }  ; %NWL%7
vm . filter =  { search :  '  '  }  ; %NWL%vm . showFilter = false ; %NWL%vm . showFilterBtn = false ; %NWL%vm . showFilterBtnActive = false ; %NWL%vm . filterBtnLabel =  ' Show filter '  ; %NWL%vm . showFilterBtnClick = showFilterBtnClick ; %NWL%vm . clearFilter = clearFilter ; %NWL%vm . showPagination = true ; %NWL%vm . pageSize = pagination . getPageSize (  )  ; %NWL%vm . pageMinSize = config . pageMinSize ; %NWL%vm . pageMaxSize = config . pageMaxSize ; %NWL%9
if ( err )  {%NWL%return cb (  ' Could not open specified file '  )  ;%NWL%}%NWL%ID3Tag . parse ( handle , function ( err , tags )  {%NWL%cb ( err , tags )  ; %NWL%handle . close (  )%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%id3 . OPEN_FILE = Reader . OPEN_FILE ; %NWL%id3 . OPEN_URI = Reader . OPEN_URI ; %NWL%9
checkbox : false%NWL%}  , this )  ; %NWL%mExplorer . Explorer . call ( this , options . serviceRegistry , options . selection , renderer , options . commandRegistry )  ; %NWL%this . checkbox = false ; %NWL%this . showHistory = options . showHistory =  =  = undefined || options . showHistory ; %NWL%this . showTags = options . showTags ; %NWL%this . parentId = options . parentId ; %NWL%this . actionScopeId = options . actionScopeId ; %NWL%this . sectionActionScodeId = options . sectionActionScodeId ; %NWL%this . root = options . root ; %NWL%this . section = options . section ; %NWL%5
)  ; %NWL%test (%NWL%" object stamping "  ,%NWL%function (  )  {%NWL%var obj ; %NWL%obj = new TinCan . Statement (  )  ; %NWL%ok ( obj . id ! =  = null ,  " object property not null : id "  )  ; %NWL%ok ( obj . timestamp ! =  = null ,  " object property not null : timestamp "  )  ; %NWL%obj = new TinCan . Statement (  {  }  ,  { doStamp : false }  )  ; %NWL%ok ( obj . id =  =  = null ,  " object property null : id "  )  ; %NWL%ok ( obj . timestamp =  =  = null ,  " object property null : timestamp "  )  ; %NWL%9
}  ; %NWL%Parallax . prototype . invert = function ( x , y )  {%NWL%this . invertX = x =  =  = undefined ? this . invertX : x ; %NWL%this . invertY = y =  =  = undefined ? this . invertY : y ;%NWL%}  ; %NWL%Parallax . prototype . friction = function ( x , y )  {%NWL%this . frictionX = x =  =  = undefined ? this . frictionX : x ; %NWL%this . frictionY = y =  =  = undefined ? this . frictionY : y ;%NWL%}  ; %NWL%Parallax . prototype . scalar = function ( x , y )  {%NWL%this . scalarX = x =  =  = undefined ? this . scalarX : x ; %NWL%2
}%NWL%if ( !reduced )  {%NWL%reduced = JSON . parse ( JSON . stringify ( rows [ key ]  )  )  ; %NWL%continue ;%NWL%}%NWL%row = rows [ key ]  ; %NWL%if ( row . sort_open )  {%NWL%if ( row . sort_open < reduced . sort_open )  {%NWL%reduced . sort_open = row . sort_open ; %NWL%reduced . open_time = row . open_time ; %NWL%reduced . open   = row . open ; %NWL%8
console . debug (  " Empty Cell : Valid Jump for Red .  "  )  ; %NWL%var blackBtwInx = isThereAPieceBetween (%NWL%redPieces [ gSelectedPieceIndex ]  , cell )  ; %NWL%blackPieces [ blackBtwInx ]  . row =  - 1 ; %NWL%blackPieces [ blackBtwInx ]  . column =  - 1 ; %NWL%if ( !gSelectedPieceHasMoved )  {%NWL%gMoveCount +  = 1 ; %NWL%redMoveCount +  = 1 ;%NWL%}%NWL%redPieces [ gSelectedPieceIndex ]  . row = cell . row ; %NWL%redPieces [ gSelectedPieceIndex ]  . column = cell . column ; %NWL%9
if ( pcolor < 0 || pcolor > 15 ) return ; %NWL%if ( pbgcolor < 0 || pbgcolor > 15 ) return ; %NWL%if ( px < 0 || px >  = TERMINAL_SIZE_X ) return ; %NWL%if ( py < 0 || py >  = TERMINAL_SIZE_Y ) return ; %NWL%if ( terminal [ py * TERMINAL_SIZE_X + px ]  . character =  = pchar && terminal [ py * TERMINAL_SIZE_X + px ]  . color =  = pcolor && terminal [ py * TERMINAL_SIZE_X + px ]  . bgcolor =  = pbgcolor )  {%NWL%return ;%NWL%}%NWL%DrawTerminalChar ( px , py , pchar , pcolor , pbgcolor )  ; %NWL%terminal [ py * TERMINAL_SIZE_X + px ]  . character = pchar ; %NWL%terminal [ py * TERMINAL_SIZE_X + px ]  . color = pcolor ; %NWL%terminal [ py * TERMINAL_SIZE_X + px ]  . bgcolor = pbgcolor ; %NWL%9
var TGALoader =  ( function (  )  {%NWL%function TGALoader (  )  {%NWL%}%NWL%TGALoader . prototype . processBytes = function ( bytes )  {%NWL%var header = this . parseHeader ( bytes )  ; %NWL%if ( !this . isValidHeader ( header )  )  {%NWL%return ;%NWL%}%NWL%var offset = 18 ; %NWL%this . width = header . width ; %NWL%this . height = header . height ; %NWL%9
entry . previous = this . previous ; %NWL%entry . next = this ; %NWL%this . previous = entry ; %NWL%return this ;%NWL%}%NWL%Stack . prototype . insertAfter = function ( entry )%NWL%{%NWL%if ( this . next )%NWL%this . next . previous = entry ; %NWL%entry . previous = this ; %NWL%entry . next = this . next ; %NWL%0
"  .  .  /  .  .  / RectangularValueIndicator "  ,%NWL%"  .  .  / DefaultPropertiesMixin "%NWL%]  ,%NWL%function ( lang , declare , Color , RectangularGauge , LinearScaler , RectangularScale , RectangularValueIndicator , DefaultPropertiesMixin )  {%NWL%return declare (  " dojox . dgauges . components . black . HorizontalLinearGauge "  ,  [ RectangularGauge , DefaultPropertiesMixin ]  ,  {%NWL%borderColor :  " #000000 "  ,%NWL%fillColor :  " #000000 "  ,%NWL%indicatorColor :  " #A4A4A4 "  ,%NWL%constructor : function (  )  {%NWL%this . borderColor = new Color ( this . borderColor )  ; %NWL%this . fillColor = new Color ( this . fillColor )  ; %NWL%9
options [ i ]  = this . agentOptions [ i ]%NWL%}%NWL%}%NWL%if ( this . ca ) options . ca = this . ca%NWL%var poolKey =  '  '%NWL%if ( Agent ! =  = this . httpModule . Agent )  {%NWL%poolKey +  = Agent . name%NWL%}%NWL%if ( !this . httpModule . globalAgent )  {%NWL%options . host = this . host%NWL%options . port = this . port%NWL%9
if ( typeof entry =  =  =  ' string '  )  {%NWL%that . extra . push ( entry )  ;%NWL%} else if ( typeof entry =  =  =  ' object '  )  {%NWL%var subChatMessage = new ChatMessage ( entry )  ; %NWL%that . extra . push ( subChatMessage )  ;%NWL%}%NWL%}  )  ;%NWL%}%NWL%this . bold = json . bold ; %NWL%this . italic = json . italic ; %NWL%this . underlined = json . underlined ; %NWL%8
this . win = null ; %NWL%this . locales = null ; %NWL%this . numOfFiles = 0 ;%NWL%}  ; %NWL%WebappOptimize . prototype . RE_HTML =  / \ . html$ /  ; %NWL%WebappOptimize . prototype . setOptions = function ( options )  {%NWL%this . config = options . config ; %NWL%this . webapp = options . webapp ; %NWL%this . win = options . win ; %NWL%this . locales = options . locales ; %NWL%this . optimizeConfig = options . optimizeConfig ; %NWL%6
this . writeOps =  [  ]  ; %NWL%this . readOps =  [  ]  ; %NWL%this . stack =  [  {  }  ]  ; %NWL%this . data = data || {  }  ;%NWL%}%NWL%module . exports = Operation ; %NWL%var statuses = require (  '  .  .  / operation - status '  )  ; %NWL%Operation . PENDING = statuses . PENDING ; %NWL%Operation . WRITTEN = statuses . WRITTEN ; %NWL%Operation . READING = statuses . READING ; %NWL%Operation . COMPLETE = statuses . COMPLETE ; %NWL%7
parseMetaData : function ( meta )  {%NWL%if ( meta . columns ! =  = undefined && meta . columns ! =  = null )  {%NWL%this . store . options . fields = meta . columns ;%NWL%}%NWL%if ( meta . totalItems ! =  = undefined && meta . totalItems ! =  = null )  {%NWL%this . totalItems = meta . totalItems ;%NWL%}%NWL%if ( meta . totalPages ! =  = undefined && meta . totalPages ! =  = null )  {%NWL%this . totalPages = meta . totalPages ;%NWL%}%NWL%if ( meta . primaryKey ! =  = undefined && meta . primaryKey ! =  = null )  {%NWL%1
options =  {%NWL%host : this . host ,%NWL%port : this . port ,%NWL%path : this . path ,%NWL%method : this . method ,%NWL%headers :  {  ' Content - Type '  :  ' application / json '  }%NWL%}  ; %NWL%if ( this . ssl )  {%NWL%options . ca = this . ssl . ca ; %NWL%options . key = this . ssl . key ; %NWL%options . cert = this . ssl . cert ; %NWL%8
return result ;%NWL%}  ; %NWL%PerspectiveOffCenterFrustum . prototype . clone = function ( result )  {%NWL%if ( !defined ( result )  )  {%NWL%result = new PerspectiveOffCenterFrustum (  )  ;%NWL%}%NWL%result . right = this . right ; %NWL%result . left = this . left ; %NWL%result . top = this . top ; %NWL%result . bottom = this . bottom ; %NWL%result . near = this . near ; %NWL%6
}%NWL%window . removeEventListener (  ' resize '  , this . onWindowResize )  ; %NWL%cancelAnimationFrame ( this . raf )  ;%NWL%}%NWL%}  ; %NWL%Plugin . prototype . calibrate = function ( x , y )  {%NWL%this . calibrateX = x =  =  = undefined ? this . calibrateX : x ; %NWL%this . calibrateY = y =  =  = undefined ? this . calibrateY : y ;%NWL%}  ; %NWL%Plugin . prototype . invert = function ( x , y )  {%NWL%this . invertX = x =  =  = undefined ? this . invertX : x ; %NWL%6
this . filter = other . filter ; %NWL%this . format = other . format ; %NWL%this . wrap = other . wrap ; %NWL%return this ;%NWL%}  ; %NWL%RenderTarget . prototype . setWidth = function ( width )  {%NWL%this . width = width || this . width ; %NWL%this . needsUpdate = true ;%NWL%}  ; %NWL%RenderTarget . prototype . setHeight = function ( height )  {%NWL%this . height = height || this . height ; %NWL%6
document . getElementById (  " clearNotifications "  )  . checked = JSON . parse ( localStorage . clearNotifications )  ; %NWL%document . getElementById (  " notificationTimeout "  )  . value = localStorage . notificationTimeout ;%NWL%}%NWL%function saveOptions (  )%NWL%{%NWL%console . log (  " saving options "  )  ; %NWL%localStorage . broker = document . getElementById (  " broker "  )  . value ; %NWL%localStorage . port = document . getElementById (  " port "  )  . value ; %NWL%localStorage . username = document . getElementById (  " username "  )  . value ; %NWL%localStorage . password = document . getElementById (  " password "  )  . value ; %NWL%localStorage . reconnectTimeout = document . getElementById (  " reconnectTimeout "  )  . value ; %NWL%6
}%NWL%function ExactDecimal_eq ( ed )  {%NWL%if ( this =  =  = ed )%NWL%return true ; %NWL%if ( this . _e =  =  = ed . _e )%NWL%return eq ( this . _ns [ 0 ]  , ed . _ns [ 0 ]  )  ; %NWL%var vals = getSameExponent ( this , ed )  ; %NWL%if ( eq ( vals [ 0 ]  , vals [ 1 ]  )  )  {%NWL%if ( ed . _e < this . _e )  {%NWL%ed . _ns  = this . _ns ; %NWL%ed . _e  = this . _e ; %NWL%9
exports [ connectorName ]  = require (  "  .  / lib / connectors /  "  + connectors [ connectorName ]  )  ;%NWL%}%NWL%for ( var middlewareName in middleware )  {%NWL%exports [ middlewareName ]  = require (  "  .  / lib / middleware /  "  + middleware [ middlewareName ]  )  ;%NWL%}%NWL%exports . createSyntheticError = model . createSyntheticError ; %NWL%exports . Session = model . Session ; %NWL%exports . Request = model . Request ; %NWL%exports . Response = model . Response ; %NWL%exports . useOAuth = auth . useOAuth ; %NWL%exports . useNormalAuth = auth . useNormalAuth ; %NWL%9
, clearCanvas : function (  )  { clearCanvas (  )  }%NWL%, getSignature : function (  )  { return output }%NWL%, getSignatureString : function (  )  { return JSON . stringify ( output )  }%NWL%, getSignatureImage : function (  )  {%NWL%var tmpCanvas = document . createElement (  ' canvas '  )%NWL%, tmpContext = null%NWL%, data = null%NWL%tmpCanvas . style . position =  ' absolute '%NWL%tmpCanvas . style . top =  '  - 999em '%NWL%tmpCanvas . width = element . width%NWL%tmpCanvas . height = element . height%NWL%9
gDialog . marginBottom  = document . getElementById (  " marginBottom "  )  ; %NWL%gDialog . marginLeft   = document . getElementById (  " marginLeft "  )  ; %NWL%gDialog . marginRight  = document . getElementById (  " marginRight "  )  ; %NWL%gDialog . topInput   = document . getElementById (  " topInput "  )  ; %NWL%gDialog . bottomInput  = document . getElementById (  " bottomInput "  )  ; %NWL%gDialog . leftInput   = document . getElementById (  " leftInput "  )  ; %NWL%gDialog . rightInput   = document . getElementById (  " rightInput "  )  ; %NWL%gDialog . hLeftOption  = document . getElementById (  " hLeftOption "  )  ; %NWL%gDialog . hCenterOption  = document . getElementById (  " hCenterOption "  )  ; %NWL%gDialog . hRightOption  = document . getElementById (  " hRightOption "  )  ; %NWL%gDialog . fLeftOption  = document . getElementById (  " fLeftOption "  )  ; %NWL%0
if ( args . shardId ! =  = undefined )  {%NWL%this . shardId = args . shardId ;%NWL%}%NWL%if ( args . privilege ! =  = undefined )  {%NWL%this . privilege = args . privilege ;%NWL%}%NWL%if ( args . username ! =  = undefined )  {%NWL%this . username = args . username ;%NWL%}%NWL%if ( args . noteStoreUrl ! =  = undefined )  {%NWL%this . noteStoreUrl = args . noteStoreUrl ; %NWL%1
if ( !options . isClone )  {%NWL%validateIdIsUnique ( options . id )  ;%NWL%}%NWL%this . id = options . id ;%NWL%} else {%NWL%this . id = getNextId ( options . type )  ;%NWL%}%NWL%idsUsed . push ( this . id )  ; %NWL%if ( options . hasOwnProperty (  ' name '  )  )  {%NWL%validateIdOrName ( options . name )  ; %NWL%this . name = options . name ; %NWL%3
nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%selectByValue ( f ,  ' align '  , this . getAttrib ( n ,  ' align '  )  )  ; %NWL%selectByValue ( f ,  ' class_list '  , dom . getAttrib ( n ,  ' class '  )  , true , true )  ; %NWL%nl . style . value = dom . getAttrib ( n ,  ' style '  )  ; %NWL%nl . id . value = dom . getAttrib ( n ,  ' id '  )  ; %NWL%nl . dir . value = dom . getAttrib ( n ,  ' dir '  )  ; %NWL%0
caught : record . caught%NWL%}%NWL%this . applyChange ( record . forward )%NWL%}%NWL%ProgramState . prototype . applyChange = function ( change )  {%NWL%if ( !change )%NWL%throw ' invalid change '%NWL%var self = this%NWL%var changingScript = this . scripts [ change . script ]%NWL%this . currentScript = change . currentScript%NWL%this . currentLoc = change . currentLoc%NWL%9
this . offsetDistance = typeof options . offsetDistance ! =  =  ' undefined ' ? options . offsetDistance : 30 ; %NWL%this . offsetAngle = options . offsetAngle || 0 ; %NWL%this . opacity = typeof options . opacity ! =  =  ' undefined ' ? options . opacity : 0 . 75 ; %NWL%this . target = options . target || null ; %NWL%this . activated = !!options . activated ; %NWL%this . activatedColor = options . activatedColor || [ 255 , 255 , 255 ]  ; %NWL%this . borderRadius = typeof options . borderRadius ! =  =  ' undefined ' ? options . borderRadius : 100 ; %NWL%this . borderWidth = typeof options . borderWidth ! =  =  ' undefined ' ? options . borderWidth : 2 ; %NWL%this . borderStyle = options . borderStyle || ' solid '  ; %NWL%this . borderColor = options . borderColor || [ 255 , 255 , 255 ]  ; %NWL%this . onConsume = options . onConsume || null ; %NWL%3
if ( temp . length > 3 )%NWL%{%NWL%temp = temp . substring ( 0 , 3 )  ;%NWL%}%NWL%temp = returnValue . Drive [ temp . toUpperCase (  )  ]  ; %NWL%if ( !temp )  {%NWL%return error ( device . implementation . ERR_BAD_ARGUMENT_TYPE , msg . no_msg )  ;%NWL%}%NWL%var driveInfo = new Object (  )  ; %NWL%driveInfo . Key = returnValue . Key ; %NWL%driveInfo . Entity = returnValue . Entity ; %NWL%9
if ( options . socketOptions && typeof options . socketOptions . keepAlive =  =  ' number '  )  {%NWL%finalOptions . keepAlive = true ; %NWL%if ( typeof options . socketOptions . keepAlive =  =  ' number '  )  {%NWL%finalOptions . keepAliveInitialDelay = options . socketOptions . keepAlive ;%NWL%}%NWL%}%NWL%if ( options . socketOptions && typeof options . socketOptions . connectionTimeout =  =  ' number '  )  {%NWL%finalOptions . connectionTimeout = options . socketOptions . connectionTimeout ;%NWL%}%NWL%if ( options . socketOptions && typeof options . socketOptions . socketTimeout =  =  ' number '  )  {%NWL%finalOptions . socketTimeout = options . socketOptions . socketTimeout ; %NWL%7
]  , function ( UIList , $ , woodman , _ )  {%NWL%var logger = woodman . getLogger (  ' joshfire . framework . adapters . phone . ui . toolbar '  )  ; %NWL%var UIToolbar = UIList . extend (  {%NWL%tagName :  ' div '  ,%NWL%className :  ' joshfire - toolbar '  ,%NWL%initialize : function ( options )  {%NWL%options = options || {  }  ; %NWL%this . initializeLogId ( options )  ; %NWL%logger . log ( this . logid ,  ' initialize '  )  ; %NWL%this . maxOnScreen = options . maxOnScreen || 5 ; %NWL%this . margin = options . margin || 5 ; %NWL%9
if ( !importItem . isReady )  {%NWL%return ;%NWL%}%NWL%this . imports = this . imports . slice ( 1 )  ; %NWL%importItem . callback . apply ( null , importItem . args )  ;%NWL%}%NWL%if ( this . variableImports . length =  =  = 0 )  {%NWL%break ;%NWL%}%NWL%var variableImport = this . variableImports [ 0 ]  ; %NWL%this . variableImports = this . variableImports . slice ( 1 )  ; %NWL%3
this . x2 = this . x1 + proto . outerWidth ( true )  ; %NWL%this . y2 = this . y1 + proto . outerHeight ( true )  ;%NWL%}%NWL%this . proto = proto ;%NWL%}%NWL%else if (  " x1 " in proto )%NWL%{%NWL%this . x1 = proto . x1 ; %NWL%this . y1 = proto . y1 ; %NWL%this . x2 = proto . x2 ; %NWL%this . y2 = proto . y2 ; %NWL%7
)  ; %NWL%return nFilter ;%NWL%}%NWL%function _fnFilterComplete ( oSettings , oInput , iForce )%NWL%{%NWL%var oPrevSearch = oSettings . oPreviousSearch ; %NWL%var aoPrevSearch = oSettings . aoPreSearchCols ; %NWL%var fnSaveFilter = function ( oFilter )  {%NWL%oPrevSearch . sSearch = oFilter . sSearch ; %NWL%oPrevSearch . bRegex = oFilter . bRegex ; %NWL%oPrevSearch . bSmart = oFilter . bSmart ; %NWL%8
var coverartthumb , coverartfull , starred , title , album , publisher , avg_rating , downloads , identifier , source , date ; %NWL%var url = globals . archiveUrl +  ' details /  '  + song . identifier ; %NWL%coverartthumb =  ' images / albumdefault_50 . jpg '  ; %NWL%coverartfull =  ' images / albumdefault_160 . jpg '  ; %NWL%if ( parseInt ( song . avg_rating )  =  = 5 )  { starred = true ;  } else { starred = false ;  }%NWL%if ( typeof song . title =  =  ' undefined '  )  { title =  ' &nbsp ;  '  ;  } else { title = song . title . toString (  )  ;  }%NWL%if ( typeof song . identifier =  =  ' undefined '  )  { identifier =  ' &nbsp ;  '  ;  } else { identifier = song . identifier . toString (  )  ;  }%NWL%if ( typeof song . collection [ 0 ]  =  =  ' undefined '  )  { album =  ' &nbsp ;  '  ;  } else { album = song . collection [ 0 ]  . toString (  )  ;  }%NWL%if ( typeof song . source =  =  ' undefined '  )  { source =  ' &nbsp ;  '  ;  } else { source = song . source . toString (  )  ;  }%NWL%if ( typeof song . date =  =  ' undefined '  )  { date =  ' &nbsp ;  '  ;  } else { date = song . date . toString (  )  ;  }%NWL%if ( typeof song . publisher =  =  ' undefined '  )  { publisher =  ' &nbsp ;  '  ;  } else { publisher = song . publisher . toString (  )  ;  }%NWL%5
return factory ( el )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%builder . wrap (  ' attachedCallback '  , function ( next , el )  {%NWL%if ( !feature ( el )  . handlers )  {%NWL%feature ( el )  . handlers =  ( options . handlers || [  ]  )  . map ( function ( factory )  {%NWL%return factory ( el )  ;%NWL%}  )  ;%NWL%}%NWL%if ( !feature ( el )  . listeners )  {%NWL%feature ( el )  . listeners =  ( options . listeners || [  ]  )  . map ( function ( factory )  {%NWL%5
}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%if ( editor . $multiselectOnSessionChange )%NWL%return ; %NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%editor . $onMultiSelect = editor . $onMultiSelect . bind ( editor )  ; %NWL%editor . $onSingleSelect = editor . $onSingleSelect . bind ( editor )  ; %NWL%editor . $multiselectOnSessionChange = exports . onSessionChange . bind ( editor )  ; %NWL%editor . $checkMultiselectChange = editor . $checkMultiselectChange . bind ( editor )  ; %NWL%5
}%NWL%}%NWL%}%NWL%function oDatabase ( db )  {%NWL%this . name = db . name ; %NWL%this . version = db . version ; %NWL%this . objectstores = new Array (  )  ;  ;%NWL%}%NWL%function oObjectStore ( os )  {%NWL%this . name = os . name ; %NWL%this . keyPath = os . keyPath ; %NWL%9
}%NWL%this . update (  )  ;%NWL%}  ,%NWL%clone : function ( rootNode , newRootNode )  {%NWL%var skeleton = new Skeleton (  )  ; %NWL%skeleton . name = this . name ; %NWL%for ( var i = 0 ; i < this . joints . length ; i +  +  )  {%NWL%var newJoint = new Joint (  )  ; %NWL%newJoint . name = this . joints [ i ]  . name ; %NWL%newJoint . index = this . joints [ i ]  . index ; %NWL%newJoint . parentIndex = this . joints [ i ]  . parentIndex ; %NWL%8
return this . _passthroughRequest [ method ]  . apply ( this . _passthroughRequest , arguments )  ;%NWL%}%NWL%return FakeXMLHttpRequest . prototype [ method ]  . apply ( this , arguments )  ;%NWL%}%NWL%proto . abort = function abort (  )  {%NWL%return this . _passthroughCheck (  ' abort '  , arguments )  ;%NWL%}%NWL%proto . getResponseHeader = function getResponseHeader (  )  {%NWL%return this . _passthroughCheck (  ' getResponseHeader '  , arguments )  ;%NWL%}%NWL%proto . getAllResponseHeaders = function getAllResponseHeaders (  )  {%NWL%4
if ( this . enableTwitterSharing ! =  = null && this . enableTwitterSharing ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableTwitterSharing '  , Thrift . Type . BOOL , 11 )  ; %NWL%output . writeBool ( this . enableTwitterSharing )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enableLinkedInSharing ! =  = null && this . enableLinkedInSharing ! =  = undefined )  {%NWL%output . writeFieldBegin (  ' enableLinkedInSharing '  , Thrift . Type . BOOL , 12 )  ; %NWL%output . writeBool ( this . enableLinkedInSharing )  ; %NWL%output . writeFieldEnd (  )  ;%NWL%}%NWL%if ( this . enablePublicNotebooks ! =  = null && this . enablePublicNotebooks ! =  = undefined )  {%NWL%0
this . log ( Level . WARN , msg )  ;%NWL%}  ,%NWL%error : function ( msg )  {%NWL%this . log ( Level . ERROR , msg )  ;%NWL%}%NWL%}  ; %NWL%var exportBasicOptions = function ( exports , options )  {%NWL%exports . name = options . name ; %NWL%exports . version = options . version ; %NWL%if ( options . autoloads )  {%NWL%exports . autoloads = options . autoloads ; %NWL%7
else if ( typeof ( this . highlightColors )  =  =  ' string '  )  {%NWL%this . highlightColors =  [  ]  ; %NWL%for ( var i = 0 ; i < this . _dataColors . length ; i +  +  )  {%NWL%this . highlightColors . push ( this . highlightColors )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%function preInit ( target , data , options )  {%NWL%options = options || {  }  ; %NWL%options . axesDefaults = options . axesDefaults || {  }  ; %NWL%options . grid = options . grid || {  }  ; %NWL%9
]  ; %NWL%fs . writeFileSync (  '  . yo - rc . json '  , out . join (  ' \n '  )  )  ; %NWL%done (  )  ;%NWL%}  . bind ( this )  )  ;%NWL%}  )  ; %NWL%it (  ' every generator can be required without throwing '  , function (  )  {%NWL%this . all = require (  '  .  .  / all '  )  ; %NWL%this . app = require (  '  .  .  / app '  )  ; %NWL%this . collection = require (  '  .  .  / collection '  )  ; %NWL%this . model = require (  '  .  .  / model '  )  ; %NWL%this . router = require (  '  .  .  / router '  )  ; %NWL%6
}  )  ; %NWL%if ( this . _private . styleEnabled )  {%NWL%json . style = cy . style (  )  . json (  )  ;%NWL%}%NWL%json . zoomingEnabled = cy . _private . zoomingEnabled ; %NWL%json . userZoomingEnabled = cy . _private . userZoomingEnabled ; %NWL%json . zoom = cy . _private . zoom ; %NWL%json . minZoom = cy . _private . minZoom ; %NWL%json . maxZoom = cy . _private . maxZoom ; %NWL%json . panningEnabled = cy . _private . panningEnabled ; %NWL%json . userPanningEnabled = cy . _private . userPanningEnabled ; %NWL%4
localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%9
look :  { x : 0 , y : 0 , z : 0 }  ,%NWL%startPivot :  { x : 0 , y : 0 , z : 0 }  ,%NWL%endPivot :  { x : 0 , y : 0 , z : 0 }  ,%NWL%currentPivot :  { x : 0 , y : 0 , z : 0 }  ,%NWL%flightStartTime : null ,%NWL%flightDuration : null ,%NWL%__construct : function ( params ) 	 {%NWL%this . events = new BIMSURFER . Events ( this )  ; %NWL%if ( BIMSURFER . Util . isset ( params )  )  {%NWL%this . eye = params . eye || this . eye ; %NWL%this . look = params . look || this . look ; %NWL%9
x		 : exit . x ,%NWL%y		 : exit . y ,%NWL%}  ; %NWL%if ( tsids . length )  {%NWL%var ret = apiCallMethod (  ' get_signpost_info '  , tsids )  ; %NWL%for ( var i in ret )  {%NWL%var r = ret [ i ]  ; %NWL%if ( r . ok )  {%NWL%var key = slot_map [ i ]  ; %NWL%connections [ key ]  . label = r . label ; %NWL%connections [ key ]  . swf_file_versioned = r . swf_file_versioned ; %NWL%9
}%NWL%, applyAndWait : function ( thisValue , fn , args )  {  /  / like js fn . apply , but wait for results%NWL%var fiber = Fiber . current ; %NWL%if ( !fiber ) throw new Error (  ' wait . for can only be called inside a fiber '  )  ; %NWL%var fnName = fn . name ; %NWL%var resumeCallback = function ( err , data )  {%NWL%if ( fiber . callbackAlreadyCalled )%NWL%throw new Error (  " Callback for function "  + fnName +  " called twice . Wait . for already resumed the execution .  "  )  ; %NWL%fiber . callbackAlreadyCalled = true ; %NWL%fiber . err = err ;  /  / store err on fiber object%NWL%fiber . data = data ;  /  / store data on fiber object%NWL%9
exports . BADQUERY =  ' EBADQUERY '  ; %NWL%exports . ADNAME =  ' EADNAME '  ; %NWL%exports . BADFAMILY =  ' EBADFAMILY '  ; %NWL%exports . BADRESP =  ' EBADRESP '  ; %NWL%exports . CONNREFUSED =  ' ECONNREFUSED '  ; %NWL%exports . TIMEOUT =  ' ETIMEOUT '  ; %NWL%exports . EOF =  ' EOF '  ; %NWL%exports . FILE =  ' EFILE '  ; %NWL%exports . NOMEM =  ' ENOMEM '  ; %NWL%exports . DESTRUCTION =  ' EDESTRUCTION '  ; %NWL%exports . BADSTR =  ' EBADSTR '  ; %NWL%0
init : function (  )  {%NWL%var $this = this , tpl = UI . components . htmleditor . template ; %NWL%this . CodeMirror = this . options . CodeMirror || CodeMirror ; %NWL%this . buttons  =  {  }  ; %NWL%tpl = tpl . replace (  / \ {  : lblPreview\ }  / g , this . options . lblPreview )  ; %NWL%tpl = tpl . replace (  / \ {  : lblCodeview\ }  / g , this . options . lblCodeview )  ; %NWL%this . htmleditor = $ ( tpl )  ; %NWL%this . content  = this . htmleditor . find (  '  . uk - htmleditor - content '  )  ; %NWL%this . toolbar  = this . htmleditor . find (  '  . uk - htmleditor - toolbar '  )  ; %NWL%this . preview  = this . htmleditor . find (  '  . uk - htmleditor - preview '  )  . children (  )  . eq ( 0 )  ; %NWL%this . code   = this . htmleditor . find (  '  . uk - htmleditor - code '  )  ; %NWL%7
params . addParams ( binding )  ; %NWL%stmt . bindParameters ( params )  ; %NWL%while ( stmt . executeStep (  )  )  {%NWL%var request =  {  }  ; %NWL%request . uuid = stmt . row . uuid ; %NWL%request . requestName = stmt . row . requestName ; %NWL%request . favorite = stmt . row . favorite ; %NWL%request . requestUrl = stmt . row . requestUrl ; %NWL%request . requestMethod = stmt . row . requestMethod ; %NWL%request . request = stmt . row . request ; %NWL%request . curl = stmt . row . curl ; %NWL%4
this . dispatch ( PubNub . MESSAGE_RECEIVED , message )  ;%NWL%}  ,%NWL%onJoin : function ( user )  {%NWL%this . dispatch ( PubNub . USER_COUNT_CHANGED , this . socket . get_user_count (  )  )  ;%NWL%}  ,%NWL%onLeave : function ( user )  {%NWL%this . dispatch ( PubNub . USER_COUNT_CHANGED , this . socket . get_user_count (  )  )  ;%NWL%}%NWL%}  )  ; %NWL%PubNub . CONNECTED =  ' PubNub . CONNECTED '  ; %NWL%PubNub . DISCONNECTED =  ' PubNub . DISCONNECTED '  ; %NWL%9
downtime : parseInt ( stat . downtime / 1000 )  ,%NWL%responseTime : parseInt ( stat . responseTime )  ,%NWL%outages : stat . outages || [  ]  ,%NWL%begin : begin . valueOf (  )  ,%NWL%end : end . valueOf (  )%NWL%}  )%NWL%}  )  ;%NWL%}  ; %NWL%Check . methods . populateFromDirtyCheck = function ( dirtyCheck , pollerCollection )  {%NWL%this . url = dirtyCheck . url || this . url ; %NWL%this . maxTime = dirtyCheck . maxTime || this . maxTime ; %NWL%9
}%NWL%function sha256_hex ( data )  {%NWL%var result = sha256_bytes ( data )  ; %NWL%return bytes_to_hex ( result )  ;%NWL%}%NWL%function sha256_base64 ( data )  {%NWL%var result = sha256_bytes ( data )  ; %NWL%return bytes_to_base64 ( result )  ;%NWL%}%NWL%sha256_constructor . bytes = sha256_bytes ; %NWL%sha256_constructor . hex = sha256_hex ; %NWL%9
sandboxZombiesWatcherWorker . postMessage (  ' stop '  )  ; %NWL%sandboxZombiesWatcherWorker . onmessage = function onPauseMessage ( message )  {%NWL%if ( message . data =  =  =  ' stopped '  )  {%NWL%started = false ;%NWL%}%NWL%}  ;%NWL%}  ; %NWL%exports . isStarted = function isStarted (  )  {%NWL%return started ;%NWL%}  ; %NWL%exports . pause = function pause (  )  {%NWL%7
this . nickname =  ( operationId || errors . push (  ' Operations must have a nickname .  '  )  )  ; %NWL%this . operation = args ; %NWL%this . operations =  {  }  ; %NWL%this . parameters = args ! =  = null ? ( args . parameters || [  ]  )  :  {  }  ; %NWL%this . parent = parent ; %NWL%this . path =  ( path || errors . push (  ' Operation '  + this . nickname +  ' is missing path .  '  )  )  ; %NWL%this . produces = args . produces ; %NWL%this . responses =  ( args . responses || {  }  )  ; %NWL%this . scheme = scheme || parent . scheme || ' http '  ; %NWL%this . schemes = parent . schemes ; %NWL%this . security = args . security ; %NWL%6
debug (  ' Returning previously defined service '  + serviceName +  '  .  .  .  '  )  ; %NWL%return services [ serviceName ]  ;%NWL%}%NWL%debug (  ' Setting up '  + serviceName +  '  .  .  .  '  )  ; %NWL%Proto . _name = Static . _name = serviceName ; %NWL%if ( !!Proto . model )  {%NWL%if ( Proto . model . extend =  =  = Model . extend )  {%NWL%debug (  ' Using the '  + Proto . model . modelName +  ' model for default ( restful ) CRUD on this service .  .  .  '  )  ; %NWL%Proto . db = Proto . model . connection ; %NWL%Static . db = Proto . db ; %NWL%Static . model = Proto . model ; %NWL%9
ctx . save (  )  ; %NWL%ctx . translate ( 0 , 0 )  ; %NWL%this . ondraw ( ctx )  ; %NWL%ctx . restore (  )  ;%NWL%}%NWL%function SoundDevice ( options )  {%NWL%this . BG_SOUND =  ' _bgsound '  ; %NWL%this . sounds =  {  }  ; %NWL%this . destroyed = false ; %NWL%this . bg_sound_enabled = options . bg_sound_enabled ; %NWL%this . sfx_sound_enabled = options . sfx_sound_enabled ; %NWL%9
tile . mass = 0 ;  /  / props . mass || 0 ; %NWL%tile . mass = props . mass || 0 ; %NWL%tile . setTexture ( texture )  ; %NWL%tile . setPosition ( position [ 0 ]  , position [ 1 ]  )  ; %NWL%tile . show (  )  ; %NWL%if ( interactive )  {%NWL%tile . click = this . onTileEvent . bind ( this ,  ' click '  , tile )  ; %NWL%tile . mousedown = this . onTileEvent . bind ( this ,  ' mousedown '  , tile )  ; %NWL%tile . mouseup = this . onTileEvent . bind ( this ,  ' mouseup '  , tile )  ; %NWL%tile . mousemove = this . onTileEvent . bind ( this ,  ' mousemove '  , tile )  ; %NWL%tile . mouseout = this . onTileEvent . bind ( this ,  ' mouseout '  , tile )  ; %NWL%6
this . _lineWidth = width ;%NWL%}  ,%NWL%getLineWidth : function (  )  {%NWL%return this . _lineWidth ;%NWL%}  ,%NWL%setDrawColor : function ( color )  {%NWL%var locDrawColor = this . _drawColor ; %NWL%locDrawColor . r = color . r ; %NWL%locDrawColor . g = color . g ; %NWL%locDrawColor . b = color . b ; %NWL%locDrawColor . a = color . a ; %NWL%8
var symbol = this . legendSymbol ,%NWL%chart = this . chart ,%NWL%x ,%NWL%y ,%NWL%width ,%NWL%height ; %NWL%if ( symbol )  {%NWL%this . left = x = symbol . attr (  ' x '  )  ; %NWL%this . top = y = symbol . attr (  ' y '  )  ; %NWL%this . width = width = symbol . attr (  ' width '  )  ; %NWL%this . height = height = symbol . attr (  ' height '  )  ; %NWL%9
}%NWL%if ( !options . handler )  {%NWL%throw new Error (  ' No handler option passed to Waypoint constructor '  )%NWL%}%NWL%this . key =  ' waypoint -  '  + keyCounter%NWL%this . options = Waypoint . Adapter . extend (  {  }  , Waypoint . defaults , options )%NWL%this . element = this . options . element%NWL%this . adapter = new Waypoint . Adapter ( this . element )%NWL%this . callback = options . handler%NWL%this . axis = this . options . horizontal ? ' horizontal '  :  ' vertical '%NWL%this . enabled = this . options . enabled%NWL%6
Rivets . Binding =  ( function (  )  {%NWL%function Binding ( view , el , type , key , keypath , options )  {%NWL%var identifier , regexp , value , _ref ; %NWL%this . view = view ; %NWL%this . el = el ; %NWL%this . type = type ; %NWL%this . key = key ; %NWL%this . keypath = keypath ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%9
ItemInfo . remove (  )  ;%NWL%}%NWL%ItemInfo . append (  )  ; %NWL%ItemInfo . uid = item . ITID ; %NWL%ItemInfo . setItem ( item )  ; %NWL%return stopPropagation ( event )  ;%NWL%}%NWL%Trade . onConclude  = function onConclude (  )  {  }  ; %NWL%Trade . onTradeSubmit = function onTradeSubmit (  )  {  }  ; %NWL%Trade . reqAddItem  = function reqAddItem (  )  {  }  ; %NWL%Trade . onCancel   = function onCancel (  )  {  }  ; %NWL%7
var xp = this . _xaxis . series_u2p ; %NWL%var yp = this . _yaxis . series_u2p ; %NWL%var i , prevColor , ops , b , h , w , a , points ; %NWL%var o ; %NWL%var r = this . renderer ; %NWL%var opts =  ( options ! = undefined ) ? options :  {  }  ; %NWL%var shadow =  ( opts . shadow ! = undefined ) ? opts . shadow : this . shadow ; %NWL%var fill =  ( opts . fill ! = undefined ) ? opts . fill : this . fill ; %NWL%var fillAndStroke =  ( opts . fillAndStroke ! = undefined ) ? opts . fillAndStroke : this . fillAndStroke ; %NWL%r . bodyWidth =  ( opts . bodyWidth ! = undefined ) ? opts . bodyWidth : r . bodyWidth ; %NWL%r . tickLength =  ( opts . tickLength ! = undefined ) ? opts . tickLength : r . tickLength ; %NWL%9
attrs . $observe (  ' clearable '  , function ( clearable )  {%NWL%scope . clearable = angular . isDefined ( clearable )  ;%NWL%}  )  ; %NWL%attrs . $observe (  ' clearText '  , function ( clearText )  {%NWL%scope . clearText = ngxUtils . noUndefined (%NWL%clearText ,%NWL%ngxDictionary (  ' NGX_UI_RATING_CLEAR '  )%NWL%)  ;%NWL%}  )  ; %NWL%attrs . $observe (  ' changeOnHover '  , function ( changeOnHover )  {%NWL%scope . changeOnHover = angular . isDefined ( changeOnHover )  ; %NWL%1
this . _group = group || 0 ;%NWL%}  ,%NWL%updateShape : function ( shape )  {%NWL%if ( shape instanceof cp . Shape )  {%NWL%shape . collision_type = this . _collisionType ; %NWL%shape . group = this . _group ;%NWL%} else if ( shape instanceof Box2D . b2FilterData )  {%NWL%var filter = new Box2D . b2FilterData (  )  ; %NWL%filter . categoryBits = this . _categoryBits ; %NWL%filter . groupIndex = this . _groupIndex ; %NWL%filter . maskBits = this . _maskBits ; %NWL%8
var self = this ; %NWL%content = content . replace (  / ^\#\! .  *  /  ,  '  '  )  ; %NWL%function require ( path )  {%NWL%return Module . _load ( path , self )  ;%NWL%}%NWL%require . resolve = function ( request )  {%NWL%return Module . _resolveFilename ( request , self )  [ 1 ]  ;%NWL%}%NWL%require . paths = Module . _paths ; %NWL%require . main = process . mainModule ; %NWL%require . extensions = Module . _extensions ; %NWL%8
}  )  (  )  ; %NWL%YUI . add (  ' event - base - ie '  , function ( Y , NAME )  {%NWL%function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%9
return runInContext (  {%NWL%' _ '  : _%NWL%}  )  ;%NWL%}  )  ;%NWL%}%NWL%else if ( freeExports && freeModule )  {%NWL%freeExports . byKind = spotlight . byKind ; %NWL%freeExports . byName = spotlight . byName ; %NWL%freeExports . byValue = spotlight . byValue ; %NWL%freeExports . custom = spotlight . custom ; %NWL%freeExports . debug = spotlight . debug ; %NWL%6
else%NWL%message = String ( err || '  '  )%NWL%if ( err && err . errno && errno . errno [ err . errno ]  )%NWL%message +  =  '  (  '  + errno . errno [ err . errno ]  . description +  '  )  '%NWL%return message%NWL%}%NWL%function Logger ( config )  {%NWL%if ( ! ( this instanceof Logger )  )%NWL%return new Logger ( config )%NWL%this . verbose = config . verbose%NWL%this . quiet  = config . quiet%NWL%9
mongoose = require (  ' mongoose '  )  ,%NWL%url =  config . db . host ,%NWL%options =  {%NWL%user : config . db . username ,%NWL%pass : config . db . password%NWL%}  ; %NWL%db . tokens = require (  '  .  / mongodb / tokens '  )  ; %NWL%db . users = require (  '  .  / mongodb / users '  )  ; %NWL%db . contentTypes = require (  '  .  / mongodb / contentTypes '  )  ; %NWL%db . nodes = require (  '  .  / mongodb / nodes '  )  ; %NWL%db . content = require (  '  .  / mongodb / content '  )  ; %NWL%6
attrs :  { x : this . tx , y : this . ty }  ,%NWL%ms : animationDuration ,%NWL%easing : animationEasing ,%NWL%target : animationTarget%NWL%}  )  ;%NWL%}%NWL%}%NWL%}  ; %NWL%Tic . prototype . changeY = function ( y , easing , duration , target )  {%NWL%this . y1 = this . y1 + y ; %NWL%this . y2 = this . y2 + y ; %NWL%9
' video :  '  +  !!document . createElement (  ' video '  )%NWL%]  ; %NWL%for ( var i = 0 ; i < infodata . length ; i +  +  )  {%NWL%var el = document . createElement (  " div "  )  ; %NWL%var str = document . createTextNode ( infodata [ i ]  )  ; %NWL%el . appendChild ( str )  ; %NWL%info . appendChild ( el )  ;%NWL%}%NWL%}  ; %NWL%global . assert = global . chai . assert ; %NWL%global . expect = global . chai . expect ; %NWL%9
port : this . args . proxyPort%NWL%, executable : this . args . chromedriverExecutable%NWL%, deviceId : this . adb . curDeviceId%NWL%, enablePerformanceLogging : this . args . enablePerformanceLogging%NWL%}  ; %NWL%this . chromedriver = new Chromedriver ( chromeArgs , this . adb ,%NWL%this . onChromedriverExit . bind ( this )  )  ; %NWL%this . proxyTo = this . chromedriver . proxyTo . bind ( this . chromedriver )  ; %NWL%this . proxyHost = this . chromedriver . proxyHost ; %NWL%this . proxyPort = this . chromedriver . proxyPort ; %NWL%this . deleteSession = this . chromedriver . deleteSession . bind ( this . chromedriver )  ; %NWL%7
" lib / URI "  ,%NWL%" helper / CacheStorage "  ,%NWL%" require "%NWL%]  ,%NWL%function ( URI , CacheStorage , require )  {%NWL%function Cache (  )  {%NWL%this . timeout = 2 * 60 * 1000 ; %NWL%this . followings_before_id = null ; %NWL%this . intervall = null ; %NWL%this . followings = new CacheStorage (  " followings "  )  ; %NWL%this . profiles = new CacheStorage (  " profiles "  )  ; %NWL%9
this . locales = obj . locales ;%NWL%}  ; %NWL%cubes . Measure = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%0
}%NWL%fs = fse ; %NWL%fs . copy = require (  '  .  / copy '  )  . copy ; %NWL%var remove = require (  '  .  / remove '  )  ; %NWL%fs . remove = remove . remove ; %NWL%fs . removeSync = remove . removeSync ; %NWL%fs [  ' delete '  ]  = fs . remove%NWL%fs . deleteSync = fs . removeSync%NWL%var mkdir = require (  '  .  / mkdir '  )%NWL%fs . mkdirs = mkdir . mkdirs%NWL%fs . mkdirsSync = mkdir . mkdirsSync%NWL%9
throw ' Not implemented '  ;%NWL%}  ; %NWL%Aspect . prototype . invoke = function ( params )  {%NWL%var aspectData =  {  }  ; %NWL%aspectData . when = this . when ; %NWL%aspectData . method = params . methodName ; %NWL%aspectData . args = params . args ; %NWL%aspectData . exception = params . exception ; %NWL%aspectData . result = params . result ; %NWL%aspectData . resolveArgs = params . resolveArgs ; %NWL%aspectData . rejectArgs = params . rejectArgs ; %NWL%6
this . choice = 0 ; %NWL%this . element = components . element ; %NWL%this . element . classList . add (  ' gcli - in - complete '  )  ; %NWL%this . element . setAttribute (  ' tabindex '  ,  '  - 1 '  )  ; %NWL%this . element . setAttribute (  ' aria - live '  ,  ' polite '  )  ; %NWL%this . document = this . element . ownerDocument ; %NWL%this . inputter = components . inputter ; %NWL%this . inputter . onInputChange . add ( this . update , this )  ; %NWL%this . inputter . onAssignmentChange . add ( this . update , this )  ; %NWL%this . inputter . onChoiceChange . add ( this . update , this )  ; %NWL%this . autoResize = components . autoResize ; %NWL%1
if ( true =  = oRequest . comet )%NWL%return ; %NWL%xjxEc . submitRequest ( oRequest )  ;%NWL%}%NWL%xjxEc . prepareRequest = xajax . prepareRequest ; %NWL%xjxEc . stream_support = xjxEc . detectSupport (  )  ; %NWL%switch ( xjxEc . stream_support )%NWL%{%NWL%case " Internet Explorer "  : %NWL%xajax . prepareRequest = xjxEc . prepareRequestActiveX ; %NWL%xjxEc . submitRequest = xajax . submitRequest ; %NWL%4
}  )  ; %NWL%$scope . $watch (  " currentOrderBook "  , function (  )  {%NWL%$scope . loadOrderBookSummary (  )  ;%NWL%}  )  ; %NWL%$scope . loadOrderBookSummary = function (  )  {%NWL%if ( $scope . currentOrderBook )  {%NWL%var currencyPair = $scope . currentOrderBook . getCurrencyPair (  )  ; %NWL%$scope . currencyPairName = $scope . currencyPairToString ( currencyPair )  ; %NWL%var summary   = $scope . currentOrderBook . getSummary (  )  ; %NWL%$scope . highestBid = summary . highestBid ; %NWL%$scope . lowestAsk  = summary . lowestAsk ; %NWL%9
air . Keyboard = window . runtime . flash . ui . Keyboard ; %NWL%air . KeyLocation = window . runtime . flash . ui . KeyLocation ; %NWL%air . Mouse = window . runtime . flash . ui . Mouse ; %NWL%air . ReferencesValidationSetting = window . runtime . flash . security . ReferencesValidationSetting ; %NWL%air . RevocationCheckSettings = window . runtime . flash . security . RevocationCheckSettings ; %NWL%air . SignatureStatus = window . runtime . flash . security . SignatureStatus ; %NWL%air . SignerTrustSettings = window . runtime . flash . security . SignerTrustSettings ; %NWL%air . XMLSignatureValidator = window . runtime . flash . security . XMLSignatureValidator ; %NWL%air . ByteArray = window . runtime . flash . utils . ByteArray ; %NWL%air . CompressionAlgorithm = window . runtime . flash . utils . CompressionAlgorithm ; %NWL%air . Endian = window . runtime . flash . utils . Endian ; %NWL%8
obj . id =  ' E '  + level_data . next_sprite_id +  +  ; %NWL%while ( plane . lookupSprite ( obj . id , true )  )  {%NWL%obj . id =  ' E '  + level_data . next_sprite_id +  +  ;%NWL%}%NWL%obj . zIndex = plane . zIndex ; %NWL%obj . type = sprite_name ; %NWL%obj . width = parseInt ( sprite_def . Width , 10 )  ; %NWL%obj . height = parseInt ( sprite_def . Height , 10 )  ; %NWL%var new_pt = this . page . snap_box_to_grid ( Math . floor ( pt . x -  ( obj . width / 2 )  )  , Math . floor ( pt . y -  ( obj . height / 2 )  )  , sprite_def . Width , sprite_def . Height )  ; %NWL%obj . x = new_pt . x ; %NWL%obj . y = new_pt . y ; %NWL%9
this . b = this . c . openBucket ( this . bucket )  ; %NWL%if ( this . qhosts )  {%NWL%this . b . enableN1ql ( this . qhosts )  ;%NWL%}%NWL%this . mock = this ;%NWL%}%NWL%util . inherits ( MockHarness , Harness )  ; %NWL%function RealHarness (  )  {%NWL%Harness . call ( this )  ; %NWL%this . connstr = config . connstr ; %NWL%this . bucket = config . bucket ; %NWL%9
this . posButton = json . posButton ; %NWL%this . altNegButton = json . altNegButton ; %NWL%this . altPosButton = json . altPosButton ; %NWL%this . gravity = json . gravity ; %NWL%this . sensitivity = json . sensitivity ; %NWL%this . dead = json . dead ; %NWL%this . type = json . type ; %NWL%this . axis = json . axis ; %NWL%this . index = json . index ; %NWL%this . joyNum = json . joyNum ; %NWL%this . value = json . value ; %NWL%0
return commands ;%NWL%}%NWL%}  ; %NWL%CommandManager = new ( Registry . extend ( CommandManager )  )  (  )  ; %NWL%Aloha . execCommand = CommandManager . execCommand ; %NWL%Aloha . queryCommandEnabled = CommandManager . queryCommandEnabled ; %NWL%Aloha . queryCommandIndeterm = CommandManager . queryCommandIndeterm ; %NWL%Aloha . queryCommandState = CommandManager . queryCommandState ; %NWL%Aloha . queryCommandSupported = CommandManager . queryCommandSupported ; %NWL%Aloha . queryCommandValue = CommandManager . queryCommandValue ; %NWL%Aloha . querySupportedCommands = CommandManager . querySupportedCommands ; %NWL%4
Crafty . e (  " Level2 "  )  ;%NWL%}%NWL%}  ; %NWL%var player = Crafty . e (  " Player "  )  ; %NWL%Crafty . bind (  " EnterFrame "  , function ( frame )  {%NWL%spotEnemys ( frame . frame )  ; %NWL%Crafty . stage . elem . style . backgroundPosition =  " 0px "  + frame . frame +  " px "  ;%NWL%}  )  ; %NWL%Crafty . bind (  " UpdateStats "  , function (  )  {%NWL%player . heat . percent = Math . round ( player . heat . current / player . heat . max * 100 )  ; %NWL%player . hp . percent = Math . round ( player . hp . current / player . hp . max * 100 )  ; %NWL%9
}%NWL%}  , 1 )  ;%NWL%}  ; %NWL%this . onSuiteStarting = _status . onSuiteStarting ; %NWL%this . onSuiteCompleted = _status . onSuiteCompleted ; %NWL%this . onSuiteSetupStarting = _status . onSuiteSetupStarting ; %NWL%this . onSuiteSetupCompleted = _status . onSuiteSetupCompleted ; %NWL%this . onSuiteTeardownStarting = _status . onSuiteTeardownStarting ; %NWL%this . onSuiteTeardownCompleted = _status . onSuiteTeardownCompleted ; %NWL%this . onTestGroupStarting = _status . onTestGroupStarting ; %NWL%this . onTestGroupCompleted = _status . onTestGroupCompleted ; %NWL%3
_p . cleanup = _p . _cleanupForCanvas ; %NWL%_p . initWithWidthAndHeight = _p . _initWithWidthAndHeightForCanvas ; %NWL%_p . begin = _p . _beginForCanvas ; %NWL%_p . _beginWithClear = _p . _beginWithClearForCanvas ; %NWL%_p . end = _p . _endForCanvas ; %NWL%_p . clearRect = _p . _clearRectForCanvas ; %NWL%_p . clearDepth = _p . _clearDepthForCanvas ; %NWL%_p . clearStencil = _p . _clearStencilForCanvas ; %NWL%_p . visit = _p . _visitForCanvas ; %NWL%_p . draw = _p . _drawForCanvas ; %NWL%_p . setClearColor = _p . _setClearColorForCanvas ; %NWL%0
dir : nl . dir . value ,%NWL%lang : nl . lang . value ,%NWL%usemap : nl . usemap . value ,%NWL%longdesc : nl . longdesc . value%NWL%}  )  ; %NWL%args . onmouseover = args . onmouseout =  '  '  ; %NWL%if ( f . onmousemovecheck . checked )  {%NWL%if ( nl . onmouseoversrc . value )%NWL%args . onmouseover =  " this . src =  '  "  + nl . onmouseoversrc . value +  "  '  ;  "  ; %NWL%if ( nl . onmouseoutsrc . value )%NWL%args . onmouseout =  " this . src =  '  "  + nl . onmouseoutsrc . value +  "  '  ;  "  ; %NWL%8
}%NWL%this . current = name ; %NWL%$ . addClass ( handle . tab . el ,  ' tabSelected '  )  ; %NWL%handle . view . appendTo ( this . views )  ;%NWL%}%NWL%}  )  ; %NWL%var ConnectionView = Class ( View , function (  )  {%NWL%this . init = function ( conn )  {%NWL%this . conn = conn ; %NWL%conn . onSubscribed = bind ( this ,  ' onSubscribed '  )  ; %NWL%conn . onMessaged = bind ( this ,  ' onMessaged '  )  ; %NWL%9
localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%localElem . one = _ . bind ( one , localElem , localElem )  ; %NWL%localElem . all = _ . bind ( all , localElem , localElem )  ; %NWL%9
var light = new THREE . DirectionalLight (  )  ; %NWL%THREE . Light . prototype . clone . call ( this , light )  ; %NWL%light . target = this . target . clone (  )  ; %NWL%light . intensity = this . intensity ; %NWL%light . castShadow = this . castShadow ; %NWL%light . onlyShadow = this . onlyShadow ; %NWL%light . shadowCameraNear = this . shadowCameraNear ; %NWL%light . shadowCameraFar = this . shadowCameraFar ; %NWL%light . shadowCameraLeft = this . shadowCameraLeft ; %NWL%light . shadowCameraRight = this . shadowCameraRight ; %NWL%light . shadowCameraTop = this . shadowCameraTop ; %NWL%3
m_object . username = ud ; %NWL%m_object . regular = $ (  "  . xkit - mute - option . regular "  )  . hasClass (  " selected "  )  ; %NWL%m_object . photo = $ (  "  . xkit - mute - option . photo "  )  . hasClass (  " selected "  )  ; %NWL%m_object . quote = $ (  "  . xkit - mute - option . quote "  )  . hasClass (  " selected "  )  ; %NWL%m_object . link = $ (  "  . xkit - mute - option . link "  )  . hasClass (  " selected "  )  ; %NWL%m_object . chat = $ (  "  . xkit - mute - option . chat "  )  . hasClass (  " selected "  )  ; %NWL%m_object . audio = $ (  "  . xkit - mute - option . audio "  )  . hasClass (  " selected "  )  ; %NWL%m_object . video = $ (  "  . xkit - mute - option . video "  )  . hasClass (  " selected "  )  ; %NWL%m_object . asks = $ (  "  . xkit - mute - option . asks "  )  . hasClass (  " selected "  )  ; %NWL%m_object . reblogs = $ (  " #xkit - mute - hide - reblogs - checkbox "  )  . hasClass (  " selected "  )  ; %NWL%m_object . originals = $ (  " #xkit - mute - hide - originals - checkbox "  )  . hasClass (  " selected "  )  ; %NWL%9
$scope . user . repeatPassword =  '  '  ; %NWL%$scope . register = function (  )  {%NWL%$scope . registerForm . login . $dirty = true ; %NWL%$scope . registerForm . password . $dirty = true ; %NWL%$scope . registerForm . email . $dirty = true ; %NWL%$scope . registerForm . repeatPassword . $dirty = true ; %NWL%if ( $scope . registerForm . $valid && !$scope . registerForm . repeatPassword . $error . repeat )  {%NWL%var jsonUser =  {  }  ;  /  / create dedicated object to pass only specific fields%NWL%jsonUser . login = $scope . user . login ; %NWL%jsonUser . email = $scope . user . email ; %NWL%jsonUser . password = $scope . user . password ; %NWL%8
refn . writeObject ( rtn , 0 )  ; %NWL%objc . objc_setAssociatedObject ( val , objc . objcStorageKey , refn , 0 )  ;%NWL%}%NWL%return rtn ;%NWL%}%NWL%objc . createBlock = createBlock ; %NWL%objc . createUnwrapperFunction = createUnwrapperFunction ; %NWL%objc . createWrapperPointer = createWrapperPointer ; %NWL%objc . Struct = struct ; %NWL%objc . Callback = ffi . Callback ; %NWL%objc . ForeignFunction = ffi . ForeignFunction ; %NWL%9
}%NWL%self . can = true ;%NWL%}%NWL%function Display (  )  {%NWL%var display = new CanvasDisplay ; %NWL%if ( !display . can )%NWL%display = new StackedDisplay ; %NWL%this . element = display . element ; %NWL%this . rawRect = display . rawRect ; %NWL%this . resize = display . resize ; %NWL%this . copyRect = display . copyRect ; %NWL%7
this . scale . copy ( other . scale )  ; %NWL%this . bindPose . copy ( other . bindPose )  ; %NWL%return this ;%NWL%}  ; %NWL%MeshBone . prototype . toJSON = function ( json )  {%NWL%json || ( json =  {  }  )  ; %NWL%json . name = this . name ; %NWL%json . parentIndex = this . parentIndex ; %NWL%json . skinned = this . skinned ; %NWL%json . position = this . position . toJSON ( json . position )  ; %NWL%json . rotation = this . rotation . toJSON ( json . rotation )  ; %NWL%9
YUI . add (  ' event - base - ie '  , function ( Y , NAME )  {%NWL%function IEEventFacade (  )  {%NWL%Y . DOM2EventFacade . apply ( this , arguments )  ;%NWL%}%NWL%function IELazyFacade ( e )  {%NWL%var proxy = Y . config . doc . createEventObject ( e )  ,%NWL%proto = IELazyFacade . prototype ; %NWL%proxy . hasOwnProperty = function (  )  { return true ;  }  ; %NWL%proxy . init = proto . init ; %NWL%proxy . halt = proto . halt ; %NWL%proxy . preventDefault    = proto . preventDefault ; %NWL%8
air . SQLIndexSchema = window . runtime . flash . data . SQLIndexSchema ; %NWL%air . SQLMode = window . runtime . flash . data . SQLMode ; %NWL%air . SQLResult = window . runtime . flash . data . SQLResult ; %NWL%air . SQLSchema = window . runtime . flash . data . SQLSchema ; %NWL%air . SQLSchemaResult = window . runtime . flash . data . SQLSchemaResult ; %NWL%air . SQLStatement = window . runtime . flash . data . SQLStatement ; %NWL%air . SQLTableSchema = window . runtime . flash . data . SQLTableSchema ; %NWL%air . SQLTransactionLockType = window . runtime . flash . data . SQLTransactionLockType ; %NWL%air . SQLTriggerSchema = window . runtime . flash . data . SQLTriggerSchema ; %NWL%air . SQLUpdateEvent = window . runtime . flash . events . SQLUpdateEvent ; %NWL%air . SQLViewSchema = window . runtime . flash . data . SQLViewSchema ; %NWL%0
stroke :  " white "  ,%NWL%stroke_width :  " 1 . 5px "  ,%NWL%fill :  " black "  ,%NWL%stroke_opacity : 1 . 0 ,%NWL%fill_opacity : 1 . 0%NWL%}  )  ; %NWL%opts . stroke = enforce_function ( opts . stroke )  ; %NWL%opts . stroke_opacity = enforce_function ( opts . stroke_opacity )  ; %NWL%opts . stroke_width = enforce_function ( opts . stroke_width )  ; %NWL%opts . fill = enforce_function ( opts . fill )  ; %NWL%opts . fill_opacity = enforce_function ( opts . fill_opacity )  ; %NWL%6
afterClear : function (  )  { menu . _mainMenu . returnTo (  )  ;  }%NWL%}  )  ;%NWL%}  ,%NWL%_getItems : function (  )  {%NWL%var numItems = 0 ; %NWL%var itemMenu = this ; %NWL%g_player . forEachItemInInventory ( function ( itemId , amt )  {%NWL%if ( amt > 0 )  {%NWL%var item =  {  }  ; %NWL%item . name = g_itemData . items [ itemId ]  . name ; %NWL%item . type = g_itemData . items [ itemId ]  . type ; %NWL%9
supported : function (  )  {%NWL%return false ;%NWL%}  ,%NWL%setExtent : function ( extent , resolutionChanged )  {%NWL%this . extent = extent . clone (  )  ; %NWL%if ( resolutionChanged )  {%NWL%this . resolution = null ;%NWL%}%NWL%}  ,%NWL%setSize : function ( size )  {%NWL%this . size = size . clone (  )  ; %NWL%4
}  ,%NWL%_initNode = function ( setting , level , n , parentNode , isFirstNode , isLastNode , openFlag )  {%NWL%if ( !n ) return ; %NWL%var checkedKey = setting . data . key . checked ; %NWL%if ( typeof n [ checkedKey ]  =  =  " string "  ) n [ checkedKey ]  = tools . eqs ( n [ checkedKey ]  ,  " true "  )  ; %NWL%n [ checkedKey ]  = !!n [ checkedKey ]  ; %NWL%n . checkedOld = n [ checkedKey ]  ; %NWL%if ( typeof n . nocheck =  =  " string "  ) n . nocheck = tools . eqs ( n . nocheck ,  " true "  )  ; %NWL%n . nocheck = !!n . nocheck || ( setting . check . nocheckInherit && parentNode && !!parentNode . nocheck )  ; %NWL%if ( typeof n . chkDisabled =  =  " string "  ) n . chkDisabled = tools . eqs ( n . chkDisabled ,  " true "  )  ; %NWL%n . chkDisabled = !!n . chkDisabled || ( setting . check . chkDisabledInherit && parentNode && !!parentNode . chkDisabled )  ; %NWL%8
}%NWL%$ (  ' a . geocode . button '  )  . live (  ' click '  , function (  )  {%NWL%var address = new Object (  )  ; %NWL%var $this = $ ( this )  ; %NWL%var lat ; %NWL%var lng ; %NWL%var uid = $this . attr (  ' data - uid '  )  ; %NWL%address . line_1 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_1\\ ]  ]  '  )  . val (  )  ; %NWL%address . line_2 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_2\\ ]  ]  '  )  . val (  )  ; %NWL%address . line_3 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_3\\ ]  ]  '  )  . val (  )  ; %NWL%address . city = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ city\\ ]  ]  '  )  . val (  )  ; %NWL%7
this . fillFileList (  ' over_list '  ,  ' tinyMCEImageList '  )  ; %NWL%this . fillFileList (  ' out_list '  ,  ' tinyMCEImageList '  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%nl . height . value = dom . getAttrib ( n ,  ' height '  )  ; %NWL%nl . alt . value = dom . getAttrib ( n ,  ' alt '  )  ; %NWL%nl . title . value = dom . getAttrib ( n ,  ' title '  )  ; %NWL%nl . vspace . value = this . getAttrib ( n ,  ' vspace '  )  ; %NWL%nl . hspace . value = this . getAttrib ( n ,  ' hspace '  )  ; %NWL%nl . border . value = this . getAttrib ( n ,  ' border '  )  ; %NWL%8
return false ;%NWL%}  )  ;%NWL%}  ;%NWL%}  ; %NWL%that . request = router ( methods . request )  ; %NWL%that . upgrade = router ( methods . upgrade )  ; %NWL%that . get = router ( methods . get )  ; %NWL%that . put = router ( methods . put )  ; %NWL%that . del = router ( methods [  ' delete '  ]  )  ;  /  /  :  (%NWL%that . post = router ( methods . post )  ; %NWL%that . head = router ( methods . head )  ; %NWL%4
light . shadowDarkness = this . shadowDarkness ; %NWL%light . shadowMapWidth = this . shadowMapWidth ; %NWL%light . shadowMapHeight = this . shadowMapHeight ; %NWL%light . shadowCascade = this . shadowCascade ; %NWL%light . shadowCascadeOffset . copy ( this . shadowCascadeOffset )  ; %NWL%light . shadowCascadeCount = this . shadowCascadeCount ; %NWL%light . shadowCascadeBias = this . shadowCascadeBias . slice ( 0 )  ; %NWL%light . shadowCascadeWidth = this . shadowCascadeWidth . slice ( 0 )  ; %NWL%light . shadowCascadeHeight = this . shadowCascadeHeight . slice ( 0 )  ; %NWL%light . shadowCascadeNearZ = this . shadowCascadeNearZ . slice ( 0 )  ; %NWL%light . shadowCascadeFarZ  = this . shadowCascadeFarZ . slice ( 0 )  ; %NWL%6
var _ = require (  ' underscore '  )  ; %NWL%var GitCommands = require (  '  .  .  / git / commands '  )  ; %NWL%var Commands = require (  '  .  .  / commands '  )  ; %NWL%var SandboxCommands = require (  '  .  .  / sandbox / commands '  )  ; %NWL%var ParseWaterfall = function ( options )  {%NWL%options = options || {  }  ; %NWL%this . options = options ; %NWL%this . shortcutWaterfall = options . shortcutWaterfall || [%NWL%Commands . commands . getShortcutMap (  )%NWL%]  ; %NWL%this . instantWaterfall = options . instantWaterfall || [%NWL%7
goog . require (  ' goog . events . BrowserEvent '  )  ; %NWL%goog . require (  ' goog . events . EventType '  )  ; %NWL%goog . require (  ' goog . testing . events '  )  ; %NWL%goog . testing . messaging . MockMessageEvent = function (%NWL%data , opt_origin , opt_lastEventId , opt_source , opt_ports )  {%NWL%goog . testing . messaging . MockMessageEvent . base (%NWL%this ,  ' constructor '  , goog . events . EventType . MESSAGE )  ; %NWL%this . data = data ; %NWL%this . origin = opt_origin || null ; %NWL%this . lastEventId = opt_lastEventId || null ; %NWL%this . source = opt_source || null ; %NWL%8
setMuted ( self . _util . isAttributeSet ( aValue )  )  ;%NWL%}%NWL%}  ,%NWL%error :  {%NWL%get : function (  )  {%NWL%return impl . error ;%NWL%}%NWL%}%NWL%}  )  ; %NWL%self . _canPlaySrc = Popcorn . HTMLVimeoVideoElement . _canPlaySrc ; %NWL%self . canPlayType = Popcorn . HTMLVimeoVideoElement . canPlayType ; %NWL%9
return '  <  '  + this . nodeName +  '  '  + ns +  '  '  + attrList . join (  '  '  )  +  '  >  '  +%NWL%this . childNodes . join (  '  '  )  +  '  <  /  '  + this . nodeName +  '  >  '  ;%NWL%} else {%NWL%return '  <  '  + this . nodeName +  '  '  + attrList . join (  '  '  )  +  '  >  '  +%NWL%this . childNodes . join (  '  '  )  +  '  <  /  '  + this . nodeName +  '  >  '  ;%NWL%}%NWL%}  ,%NWL%cloneNode : function DOMElement_cloneNode (  )  {%NWL%var newNode = new DOMElement ( this . nodeName )  ; %NWL%newNode . childNodes = this . childNodes ; %NWL%newNode . attributes = this . attributes ; %NWL%9
} else {%NWL%this . virtualView = new virtualView . View (  {%NWL%el : $body%NWL%}  )  ; %NWL%this . addSubViews ( this . virtualView )  ;%NWL%}%NWL%} else if ( view =  =  =  ' #email '  )  {%NWL%if ( this . emailView )  {%NWL%this . emailView . render (  )  ;%NWL%} else {%NWL%this . emailView = new emailView . View (  {%NWL%1
engine . currentScene . add ( player )  ; %NWL%for ( var i = 0 ; i < numActors ; i +  +  )  {%NWL%var actor = new ex . Actor ( Math . random (  )  * width , Math . random (  )  * height ,  . 2 * 64 ,  . 2 * 48 )  ; %NWL%actor . addDrawing (  " default "  , blockSprite )  ; %NWL%actor . collisionType = 3 ; %NWL%actor . on (  ' update '  , function ( e )  {%NWL%if ( this . x < 0 )  {%NWL%this . dx = Math . abs ( this . dx )  ;%NWL%}%NWL%if ( this . y < 0 )  {%NWL%this . dy = Math . abs ( this . dy )  ; %NWL%7
} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function (  )  {  }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%fs . lchownSync = chownFixSync ( fs . lchownSync )%NWL%8
if (  / ^\d + $ /  . test ( subPart )  )  {%NWL%ref = new bible . Reference ( lastRef . bookid , lastRef . chapter1 , lastRef . verse1 , lastRef . chapter2 , lastRef . verse2 )  ; %NWL%ref . verse = ref . verse1 = parseInt ( subPart , 10 )  ;%NWL%}%NWL%else if (  / ^\d +  : \d + $ /  . test ( subPart )  )  {%NWL%ref = new bible . Reference ( lastRef . bookid , lastRef . chapter1 , lastRef . verse1 , lastRef . chapter2 , lastRef . verse2 )  ; %NWL%var miniParts = subPart . split (  '  :  '  )  ,%NWL%chapter = parseInt ( miniParts [ 0 ]  , 10 )  ,%NWL%verse = parseInt ( miniParts [ 1 ]  , 10 )  ; %NWL%ref . chapter = ref . chapter1 = chapter ; %NWL%ref . verse = ref . verse1 = verse ; %NWL%9
PubSub . prototype . publish = function ( channel , obj )  {%NWL%var cnl = this . channels [ channel ]  ; %NWL%var numChannels =  ( cnl =  =  = undefined ) ? 0 : cnl . length ; %NWL%for ( var i = 0 ; i < numChannels ; i +  +  )  {%NWL%cnl [ i ]  ( obj )  ;%NWL%}  ;%NWL%}  ; %NWL%function FilePackage ( file , receiving , params )  {%NWL%_this = this ; %NWL%this . name = file . name ; %NWL%this . size = file . size ; %NWL%9
this . cellHeight = cellHeight ;%NWL%}%NWL%else {%NWL%this . cellHeight = gameWorld . CellHeight ;%NWL%}%NWL%}  ; %NWL%GameWorldModelIso . prototype =  {%NWL%update : function ( cameraX , cameraY , canvasWidth , canvasHeight )  {%NWL%this . cameraX = Math . round ( cameraX )  ; %NWL%this . cameraY = Math . round ( cameraY )  ; %NWL%this . canvasWidth = Math . round ( canvasWidth )  ; %NWL%8
exports . stream						 = require . resolve (  ' stream - browserify '  )  ; %NWL%exports . _stream_duplex				 = require . resolve (  ' readable - stream / duplex . js '  )  ; %NWL%exports . _stream_passthrough			 = require . resolve (  ' readable - stream / passthrough . js '  )  ; %NWL%exports . _stream_readable			 = require . resolve (  ' readable - stream / readable . js '  )  ; %NWL%exports . _stream_transform			 = require . resolve (  ' readable - stream / transform . js '  )  ; %NWL%exports . _stream_writable			 = require . resolve (  ' readable - stream / writable . js '  )  ; %NWL%exports . string_decoder				 = require . resolve (  ' string_decoder /  '  )  ; %NWL%exports . sys							 = require . resolve (  ' util / util . js '  )  ; %NWL%exports . timers						 = require . resolve (  ' timers - browserify '  )  ; %NWL%exports . tls							 = null ; %NWL%exports . tty							 = require . resolve (  ' tty - browserify '  )  ; %NWL%0
var hw1 = function ( v1 , v2 , v3 , next )  { test . ok ( true ,  ' The handler was executed '  )  ; next (  )  ;  }  ; %NWL%var hw2 = function ( v1 , v2 , v3 , next )  {%NWL%test . ok ( arguments . length =  =  = 4 ,  ' The handler was executed with the correct number of arguments '  )  ; %NWL%test . ok ( typeof v1 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v1 +  ' ` .  '  )  ; %NWL%test . ok ( typeof v2 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v2 +  ' ` .  '  )  ; %NWL%test . ok ( typeof v3 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v3 +  ' ` .  '  )  ; %NWL%test . ok ( typeof next ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + next +  ' ` .  '  )  ;%NWL%}  ; %NWL%var zapp = zen ( hw1 , hw2 )  ; %NWL%zapp . errorHandler = function (  )  { test . ok ( false ,  ' The errorHandler was executed '  )  ;  }  ; %NWL%zapp . resultHandler = function (  )  { test . ok ( false ,  ' The resultHandler was executed '  )  ;  }  ; %NWL%9
" stroke "  :  " none "  ,%NWL%" fill "  : this . config . gaugeColor ,%NWL%pki :  [ this . config . max , this . config . min , this . config . max , this . params . widgetW , this . params . widgetH ,  this . params . dx , this . params . dy , this . config . gaugeWidthScale ]%NWL%}  )  ; %NWL%this . gauge . id = this . config . id +  "  - gauge "  ; %NWL%this . level = this . canvas . path (  )  . attr (  {%NWL%" stroke "  :  " none "  ,%NWL%" fill "  : getColorForPercentage (  ( this . config . value - this . config . min )  /  ( this . config . max - this . config . min )  , this . config . levelColors , this . config . levelColorsGradient )  ,%NWL%pki :  [ this . config . min , this . config . min , this . config . max , this . params . widgetW , this . params . widgetH ,  this . params . dx , this . params . dy , this . config . gaugeWidthScale ]%NWL%}  )  ; %NWL%this . level . id = this . config . id +  "  - level "  ; %NWL%4
if ( ipyVersion =  =  ' 1 '  )  {%NWL%oa . append_mime_type ( oa . convert_mime_types (  {  }  , content . data )  , elem , true )  ;%NWL%} else if ( ipyVersion =  =  ' 2 '  )  {%NWL%oa . append_mime_type ( content . data , elem )  ;%NWL%} else {%NWL%oa . append_mime_type ( content , elem )  ;%NWL%}%NWL%evaluation . payload = elem . html (  )  ; %NWL%if ( finalStuff ! =  = undefined )  {%NWL%finalStuff . payload = evaluation . payload ; %NWL%finalStuff . jsonres = evaluation . jsonres ; %NWL%9
init : function ( ed )  {%NWL%var f = document . forms [ 0 ]  , nl = f . elements , ed = tinyMCEPopup . editor , dom = ed . dom , n = ed . selection . getNode (  )  , fl = tinyMCEPopup . getParam (  ' external_image_list '  ,  ' tinyMCEImageList '  )  ; %NWL%tinyMCEPopup . resizeToInnerSize (  )  ; %NWL%this . fillClassList (  ' class_list '  )  ; %NWL%this . fillFileList (  ' src_list '  , fl )  ; %NWL%this . fillFileList (  ' over_list '  , fl )  ; %NWL%this . fillFileList (  ' out_list '  , fl )  ; %NWL%TinyMCE_EditableSelects . init (  )  ; %NWL%if ( n . nodeName =  =  ' IMG '  )  {%NWL%nl . src . value = dom . getAttrib ( n ,  ' src '  )  ; %NWL%nl . width . value = dom . getAttrib ( n ,  ' width '  )  ; %NWL%9
this . url = split [ 0 ]  ; %NWL%this . query = split . length > 1 ? normalizeQuery ( split [ 1 ]  )  : undefined ;%NWL%}%NWL%this . data = normalizeQuery ( stubData )  ; %NWL%this . method = method ; %NWL%this . andReturn = function ( options )  {%NWL%this . status = options . status || 200 ; %NWL%this . contentType = options . contentType ; %NWL%this . response = options . response ; %NWL%this . responseText = options . responseText ; %NWL%this . responseHeaders = options . responseHeaders ; %NWL%7
return dfd ;%NWL%}%NWL%dfd . ioArgs . xhr = rDfd . response . xhr ; %NWL%rDfd . then ( function (  )  {%NWL%dfd . resolve ( dfd )  ;%NWL%}  )  . otherwise ( function ( error )  {%NWL%ioArgs . error = error ; %NWL%if ( error . response )  {%NWL%error . status = error . response . status ; %NWL%error . responseText = error . response . text ; %NWL%error . xhr = error . response . xhr ; %NWL%8
this . attributes [  ' normal '  ]  =  { array : normalsBuffer , itemSize : 3 }  ; %NWL%this . attributes [  ' uv '  ]  =  { array : uvsBuffer , itemSize : 2 }  ;%NWL%}  ; %NWL%THREE . IndexedGeometry5 . prototype = Object . create ( THREE . BufferGeometry . prototype )  ; %NWL%THREE . IndexedGeometry5 . prototype . constructor = THREE . IndexedGeometry5 ; %NWL%THREE . TypedVector2 = function ( array , offset )  {%NWL%this . array = array ; %NWL%this . offset = offset ;%NWL%}  ; %NWL%THREE . TypedVector2 . prototype = Object . create ( THREE . Vector2 . prototype )  ; %NWL%THREE . TypedVector2 . prototype . constructor = THREE . TypedVector2 ; %NWL%4
f . barBackgroundHeight = 32 ; %NWL%f . assetTracker = null ; %NWL%f . progress = null ; %NWL%if ( parameters . backgroundColor )  {%NWL%f . backgroundColor = parameters . backgroundColor ;%NWL%}%NWL%if ( parameters . barBackgroundColor )  {%NWL%f . barBackgroundColor = parameters . barBackgroundColor ;%NWL%}%NWL%if ( parameters . barColor )  {%NWL%f . barColor = parameters . barColor ; %NWL%4
if ( state . disabled ) copystate . disabled = true ; %NWL%if ( state . search ) copystate . search = true ; %NWL%if ( state . subfolder ) copystate . subfolder = true ; %NWL%if ( state . page ! = 1 ) copystate . page = state . page ; %NWL%copystate . elems = state . elems ; %NWL%if ( state . nameordesc . length ) copystate . nameordesc = state . nameordesc ; %NWL%if ( state . asname . length ) copystate . asname = state . asname ; %NWL%if ( state . asdescription . length ) copystate . asdescription = state . asdescription ; %NWL%if ( state . aspriority . length ) copystate . aspriority = state . aspriority ; %NWL%if ( state . asauthor . length ) copystate . asauthor = state . asauthor ; %NWL%if ( state . asauto . length ) copystate . asauto = state . asauto ; %NWL%5
sum +  = m1 [ x ]  [ z ]  * m2 [ z ]  [ y ]  ;%NWL%}%NWL%result [ x ]  [ y ]  = sum ;%NWL%}%NWL%}%NWL%return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%8
}%NWL%if ( options . verbose ! = null )  {%NWL%this . verbose = options . verbose ;%NWL%}%NWL%this . supportHeaderParams = options . supportHeaderParams ! = null ? options . supportHeaderParams : false ; %NWL%this . supportedSubmitMethods = options . supportedSubmitMethods ! = null ? options . supportedSubmitMethods :  [  ' get '  ]  ; %NWL%if ( options . success ! = null )  {%NWL%this . success = options . success ;%NWL%}%NWL%this . failure = options . failure ! = null ? options . failure : function (  )  {  }  ; %NWL%this . progress = options . progress ! = null ? options . progress : function (  )  {  }  ; %NWL%9
html +  =  '  < img class =  " tip - icon " src =  "  '  + url_prefix +  ' themes /  '  + theme +  '  / images / logos /  '  + data . icon_image +  '  "  /  >  '  ;%NWL%}%NWL%if ( data . status ! = undefined )  {%NWL%html +  =  '  < div class =  " tip - title "  > Host :  '  + name +  '  < \ / div >  '%NWL%} else if ( name )  {%NWL%html +  =  '  < div class =  " tip - title "  >  '  + nodename +  '  :  '  + name +  '  < \ / div >  '%NWL%}%NWL%html +  =  '  < div class =  " tip - text "  >  < pre >  '  ; %NWL%if ( data . status ! = undefined )  {%NWL%if ( data . alias . length   > 80 )  { data . alias   = data . alias . substr ( 0 , 80 )  +  '  .  .  .  '  ;  }%NWL%if ( data . address . length   > 80 )  { data . address   = data . address . substr ( 0 , 80 )  +  '  .  .  .  '  ;  }%NWL%9
for ( i = 0 ; i < len ; i +  +  )  {%NWL%extend ( methods [ i ]  )  ;%NWL%}%NWL%}  ; %NWL%Router . prototype . runlist = function ( fns )  {%NWL%var runlist = this . every && this . every . before ? [ this . every . before ]  . concat ( _flatten ( fns )  )  : _flatten ( fns )  ; %NWL%if ( this . every && this . every . on )  {%NWL%runlist . push ( this . every . on )  ;%NWL%}%NWL%runlist . captures = fns . captures ; %NWL%runlist . source = fns . source ; %NWL%9
this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%this . missing_value = obj . missing_value ; %NWL%this . nonadditive = obj . nonadditive ; %NWL%if ( obj . aggregates )  {%NWL%this . aggregates = obj . aggregates ;%NWL%}%NWL%}  ; %NWL%cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%0
}%NWL%testing . before ( fileserver . start )  ; %NWL%testing . after ( fileserver . stop )  ; %NWL%testing . after ( function (  )  {%NWL%if ( seleniumServer )  {%NWL%seleniumServer . stop (  )  ;%NWL%}%NWL%}  )  ; %NWL%exports . suite = suite ; %NWL%exports . after = testing . after ; %NWL%exports . afterEach = testing . afterEach ; %NWL%9
var hrefParts = extractUrlParts ( originalHref , window . location . href )  ; %NWL%var href   = hrefParts . url ; %NWL%var newFileInfo =  {%NWL%currentDirectory : hrefParts . path ,%NWL%filename : href%NWL%}  ; %NWL%if ( currentFileInfo )  {%NWL%newFileInfo . entryPath = currentFileInfo . entryPath ; %NWL%newFileInfo . rootpath = currentFileInfo . rootpath ; %NWL%newFileInfo . rootFilename = currentFileInfo . rootFilename ; %NWL%newFileInfo . relativeUrls = currentFileInfo . relativeUrls ; %NWL%7
Params . prototype . __defineGetter__ (  ' length '  , function (  )  {%NWL%return this . nodes . length ;%NWL%}  )  ; %NWL%Params . prototype . __proto__ = Node . prototype ; %NWL%Params . prototype . push = function ( node )  {%NWL%this . nodes . push ( node )  ;%NWL%}  ; %NWL%Params . prototype . clone = function ( parent )  {%NWL%var clone = new Params ; %NWL%clone . lineno = this . lineno ; %NWL%clone . filename = this . filename ; %NWL%9
self . realpath = !!options . realpath%NWL%self . realpathCache = options . realpathCache || Object . create ( null )%NWL%self . follow = !!options . follow%NWL%self . dot = !!options . dot%NWL%self . mark = !!options . mark%NWL%self . nodir = !!options . nodir%NWL%if ( self . nodir )%NWL%self . mark = true%NWL%self . sync = !!options . sync%NWL%self . nounique = !!options . nounique%NWL%self . nonull = !!options . nonull%NWL%0
this . eventDeleteClicked = __bind ( this . eventDeleteClicked , this )  ; %NWL%this . eventMouseLeaveFile = __bind ( this . eventMouseLeaveFile , this )  ; %NWL%this . eventMouseEnterFile = __bind ( this . eventMouseEnterFile , this )  ; %NWL%this . eventSelectFile = __bind ( this . eventSelectFile , this )  ; %NWL%this . resetClicksOnFileList = __bind ( this . resetClicksOnFileList , this )  ; %NWL%this . setupConfirm = __bind ( this . setupConfirm , this )  ; %NWL%this . addOneRoute = __bind ( this . addOneRoute , this )  ; %NWL%this . addOneServerFile = __bind ( this . addOneServerFile , this )  ; %NWL%this . addAll = __bind ( this . addAll , this )  ; %NWL%this . showInitialSaveNotification = __bind ( this . showInitialSaveNotification , this )  ; %NWL%this . renderFileLists = __bind ( this . renderFileLists , this )  ; %NWL%0
console . log = function (  )  {%NWL%err = Array . prototype . slice . call ( arguments , 0 )  . join (  "  "  )  ;%NWL%}  ; %NWL%console . warn = undefined ; %NWL%monologue . on (  " Some . Topic "  , function (  )  {%NWL%throw new Error (  " Oopsies "  )  ;%NWL%}  )  . catch (  )  . logError (  )  ; %NWL%monologue . emit (  " Some . Topic "  ,  " Hai *  *  "  )  ; %NWL%err . should . be . ok ;  /  / jshint ignore : line%NWL%console . log = _log ; %NWL%console . warn = _warn ; %NWL%9
Thoth . FileAuth = require ( libPath +  '  / FileAuth '  )  . FileAuth ; %NWL%Thoth . Session = require ( corePath +  '  / Session '  )  . Session ; %NWL%Thoth . Store = require ( corePath +  '  / Store '  )  . Store ; %NWL%Thoth . WrapperStore = require ( corePath +  '  / WrapperStore '  )  . WrapperStore ; %NWL%Thoth . ApplicationStore = require ( corePath +  '  / ApplicationStore '  )  . ApplicationStore ; %NWL%Thoth . MemStore = require ( corePath +  '  / MemStore '  )  . MemStore ; %NWL%Thoth . DiskStore = require ( corePath +  '  / DiskStore '  )  . DiskStore ; %NWL%Thoth . Server = require ( corePath +  '  / Server '  )  . Server ; %NWL%Thoth . RPCHooks = require ( corePath +  '  / RPCHooks '  )  . RPCHooks ; %NWL%Thoth . Policies = require ( corePath +  '  / Policies '  )  . Policies ; %NWL%Thoth . PolicyModel = require ( corePath +  '  / PolicyModel '  )  . PolicyModel ; %NWL%1
var allVars = $ . getUrlVars (  )  ; %NWL%state . key = allVars [  ' key '  ] ?allVars [  ' key '  ]  :  - 100 ; %NWL%state . disabled =  ' true '  =  =  = allVars [  ' disabled '  ]  ; %NWL%state . search =  ' true '  =  =  = allVars [  ' search '  ]  ; %NWL%state . subfolder =  ' true '  =  =  = allVars [  ' subfolder '  ]  ; %NWL%state . page = allVars [  ' page '  ] ?allVars [  ' page '  ]  : 1 ; %NWL%state . elems = allVars [  ' elems '  ] ?allVars [  ' elems '  ]  : 50 ; %NWL%state . nameordesc = allVars [  ' nameordesc '  ] || "  "  ; %NWL%state . asname = allVars [  ' asname '  ] || "  "  ; %NWL%state . asdescription = allVars [  ' asdescription '  ] || "  "  ; %NWL%state . aspriority = allVars [  ' aspriority '  ] || "  "  ; %NWL%7
this . actionEnd = __bind ( this . actionEnd , this )  ; %NWL%this . actionProcess = __bind ( this . actionProcess , this )  ; %NWL%this . tryAction = __bind ( this . tryAction , this )  ; %NWL%this . getTree = __bind ( this . getTree , this )  ; %NWL%this . removeAll = __bind ( this . removeAll , this )  ; %NWL%this . remove = __bind ( this . remove , this )  ; %NWL%this . updateOne = __bind ( this . updateOne , this )  ; %NWL%this . insert = __bind ( this . insert , this )  ; %NWL%this . findOne = __bind ( this . findOne , this )  ; %NWL%this . query = __bind ( this . query , this )  ; %NWL%this . multiQuery = __bind ( this . multiQuery , this )  ; %NWL%0
allowInlineIncludes : params . allowInlineIncludes || false ,%NWL%rethrow : params . rethrow || false%NWL%}  ; %NWL%if ( id )  {%NWL%Twig . validateId ( id )  ;%NWL%}%NWL%if ( params . debug ! =  = undefined )  {%NWL%Twig . debug = params . debug ;%NWL%}%NWL%if ( params . trace ! =  = undefined )  {%NWL%Twig . trace = params . trace ; %NWL%7
Object . defineProperty ( global , name ,  { configurable : true , get : function (  )  {%NWL%log . warn (  ' %s is not supported anymore . \n Please use `karma . %s` instead .  '  , name , name )  ; %NWL%return constant [ name ]  ;%NWL%}  }  )  ;%NWL%}  )  ; %NWL%var Config = function (  )  {%NWL%var config = this ; %NWL%this . LOG_DISABLE = constant . LOG_DISABLE ; %NWL%this . LOG_ERROR = constant . LOG_ERROR ; %NWL%this . LOG_WARN = constant . LOG_WARN ; %NWL%this . LOG_INFO = constant . LOG_INFO ; %NWL%7
return previous . apply ( el , Array . prototype . slice . call ( args )  . slice ( 2 , args . length )  )  ;%NWL%}  , el )  ;%NWL%}  , wrapped . bind ( el , el )  )  . apply ( el , arguments )  ;%NWL%}  ;%NWL%}%NWL%function sanitizeStructure ( struct )  {%NWL%struct . prototype = struct . prototype || Object . create ( HTMLElement . prototype )  ; %NWL%struct . features = struct . features || [  ]  ; %NWL%struct . interceptors = struct . interceptors || [  ]  ; %NWL%struct . wrappers = struct . wrappers || [  ]  ; %NWL%struct . listeners = struct . listeners || [  ]  ; %NWL%7
this . _events [ type ]  = true ; %NWL%AttributeProvider . prototype . createEvent . apply ( this , arguments )  ;%NWL%}  ,%NWL%init : function ( el , attr )  {%NWL%_initElement . apply ( this , arguments )  ;%NWL%}%NWL%}  ; %NWL%var _initElement = function ( el , attr )  {%NWL%this . _queue = this . _queue || [  ]  ; %NWL%this . _events = this . _events || {  }  ; %NWL%this . _configs = this . _configs || {  }  ; %NWL%9
startTest (  )  ; %NWL%writeHeaderToLog ( SECTION +  " The equals operator (  =  =  )  "  )  ; %NWL%new TestCase ( SECTION ,   " void 0 = void 0 "  ,   true ,  void 0 =  = void 0 )  ; %NWL%new TestCase ( SECTION ,   " null =  = null "  ,    true ,  null =  = null )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = NaN "  ,    false ,  Number . NaN =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = 0 "  ,     false ,  Number . NaN =  = 0 )  ; %NWL%new TestCase ( SECTION ,   " 0 =  = NaN "  ,     false ,  0 =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " NaN =  = Infinity "  ,   false ,  Number . NaN =  = Number . POSITIVE_INFINITY )  ; %NWL%new TestCase ( SECTION ,   " Infinity =  = NaN "  ,   false ,  Number . POSITIVE_INFINITY =  = Number . NaN )  ; %NWL%new TestCase ( SECTION ,   " Number . MAX_VALUE =  = Number . MAX_VALUE "  ,  true ,  Number . MAX_VALUE =  = Number . MAX_VALUE )  ; %NWL%new TestCase ( SECTION ,   " Number . MIN_VALUE =  = Number . MIN_VALUE "  ,  true ,  Number . MIN_VALUE =  = Number . MIN_VALUE )  ; %NWL%9
contractMethods : function ( ev )  {%NWL%$ ( ev . currentTarget )  . removeClass (  ' expanded '  )  ; %NWL%$ (  '  . resource - submenu '  )  . fadeOut ( 200 )  ;%NWL%}  ,%NWL%render : function (  )  {%NWL%var that = this ,%NWL%resources = new ResourcesCollection (  )  ; %NWL%that . resources = resources ; 	 /  / assign to the view so we don ' t have to requery in method lists%NWL%resources . username = that . options . username ; %NWL%resources . apiname = that . options . apiname ; %NWL%resources . version = that . options . version ; %NWL%8
shadow . y = tank . y ; %NWL%shadow . rotation = tank . rotation ; %NWL%turret . x = tank . x ; %NWL%turret . y = tank . y ; %NWL%if ( pad1 . isDown ( Phaser . Gamepad . XBOX360_LEFT_BUMPER )  )  {%NWL%turretOffset -  = 3 ;%NWL%}%NWL%if ( pad1 . isDown ( Phaser . Gamepad . XBOX360_RIGHT_BUMPER )  )  {%NWL%turretOffset +  = 3 ;%NWL%}%NWL%turret . rotation = tank . rotation ; %NWL%2
}%NWL%return _results ;%NWL%}  )  (  )  ;%NWL%}%NWL%if ( $el . data (  " slider - range "  )  )  {%NWL%settings . range = $el . data (  " slider - range "  )  . split (  "  ,  "  )  ;%NWL%}%NWL%if ( $el . data (  " slider - step "  )  )  {%NWL%settings . step = $el . data (  " slider - step "  )  ;%NWL%}%NWL%settings . snap = $el . data (  " slider - snap "  )  ; %NWL%8
define (  ' EditorPosition '  ,  [  ' require '  ,  ' exports '  ,  ' module '  ]  , function ( require , exports , module )  {%NWL%var DocumentPositionUtil , EditorPosition ; %NWL%DocumentPositionUtil = require (  ' DocumentPositionUtil '  )  . DocumentPositionUtil ; %NWL%EditorPosition =  ( function (  )  {%NWL%function EditorPosition ( editor )  {%NWL%this . editor = editor ; %NWL%this . getPositionLeftChar = __bind ( this . getPositionLeftChar , this )  ; %NWL%this . getPositionChar = __bind ( this . getPositionChar , this )  ; %NWL%this . getCurrentLeftChar = __bind ( this . getCurrentLeftChar , this )  ; %NWL%this . getCurrentCharPosition = __bind ( this . getCurrentCharPosition , this )  ; %NWL%this . getAcePositionFromChars = __bind ( this . getAcePositionFromChars , this )  ; %NWL%6
this . position . copy ( other . position )  ; %NWL%this . positionSpread . copy ( other . positionSpread )  ; %NWL%this . positionRadius = other . positionRadius ; %NWL%this . speed = other . speed ; %NWL%this . speedSpread = other . speedSpread ; %NWL%this . worldSpace = other . worldSpace ; %NWL%this . minEmission = other . minEmission ; %NWL%this . maxEmission = other . maxEmission ; %NWL%this . minLife = other . minLife ; %NWL%this . maxLife = other . maxLife ; %NWL%this . minSize = other . minSize ; %NWL%2
}%NWL%}%NWL%smd . data = topojson . feature ( smd . data , smd . data . objects [ o ]  )  ;%NWL%}%NWL%return smd ;%NWL%}  ; %NWL%smd . drawCanvas = function (  )  {%NWL%var mapOffset = smd . options . mapOffset ; %NWL%smd . container = d3 . select ( smd . options . container )  ; %NWL%smd . width = parseFloat ( smd . container . style (  ' width '  )  )  ; %NWL%smd . height = parseFloat ( smd . container . style (  ' height '  )  )  ; %NWL%9
}%NWL%else {%NWL%var leftmost = current . right . left ; %NWL%var lmParent = current . right ; %NWL%while ( leftmost . left! = null )  {%NWL%lmParent = leftmost ; %NWL%leftmost = leftmost . left ;%NWL%}%NWL%lmParent . left = leftmost . right ; %NWL%leftmost . left = current . left ; %NWL%leftmost . right = current . right ; %NWL%9
var gDoDebug = false ; %NWL%function initDialog (  )%NWL%{%NWL%gDialog = new Object ; %NWL%gDialog . orientation  = document . getElementById (  " orientation "  )  ; %NWL%gDialog . portrait   = document . getElementById (  " portrait "  )  ; %NWL%gDialog . landscape   = document . getElementById (  " landscape "  )  ; %NWL%gDialog . printBG   = document . getElementById (  " printBG "  )  ; %NWL%gDialog . shrinkToFit  = document . getElementById (  " shrinkToFit "  )  ; %NWL%gDialog . marginGroup  = document . getElementById (  " marginGroup "  )  ; %NWL%gDialog . marginPage   = document . getElementById (  " marginPage "  )  ; %NWL%4
var file = files [ this . path ]%NWL%if ( !file )%NWL%return yield * next%NWL%switch ( this . method )  {%NWL%case ' HEAD '  : %NWL%case ' GET '  : %NWL%this . status = 200%NWL%this . response . lastModified = file . mtime%NWL%this . response . etag = file . md5%NWL%this . type = file . type%NWL%this . length = file . length%NWL%9
}  , false )  ; %NWL%self . clamp = function ( val , low , high )  {%NWL%' use strict '  ; %NWL%while ( val < low )  { val +  =  ( high - low )  ;  }%NWL%while ( val >  = high )  { val -  =  ( high - low )  ;  }%NWL%return val ;%NWL%}  ; %NWL%self . init = function ( params )  {%NWL%' use strict '  ; %NWL%self . width = params . width ; %NWL%self . height = params . height ; %NWL%9
this . selectors = selectors ; %NWL%this . rules = rules ; %NWL%this . _lookups =  {  }  ; %NWL%this . strictImports = strictImports ;%NWL%}  ; %NWL%tree . Ruleset . prototype =  {%NWL%eval : function ( env )  {%NWL%var selectors = this . selectors && this . selectors . map ( function ( s )  { return s . eval ( env )  }  )  ; %NWL%var ruleset = new ( tree . Ruleset )  ( selectors , this . rules . slice ( 0 )  , this . strictImports )  ; %NWL%ruleset . root = this . root ; %NWL%ruleset . allowImports = this . allowImports ; %NWL%9
WebInspector . Toolbox = function (  )%NWL%{%NWL%if ( !window . opener || !WebInspector . queryParam (  " toolbox "  )  )%NWL%return ; %NWL%WebInspector . zoomManager = new WebInspector . ZoomManager ( window . opener . InspectorFrontendHost )  ; %NWL%WebInspector . overridesSupport = window . opener . WebInspector . overridesSupport ; %NWL%WebInspector . settings = window . opener . WebInspector . settings ; %NWL%WebInspector . experimentsSettings = window . opener . WebInspector . experimentsSettings ; %NWL%WebInspector . targetManager = window . opener . WebInspector . targetManager ; %NWL%WebInspector . workspace = window . opener . WebInspector . workspace ; %NWL%WebInspector . cssWorkspaceBinding = window . opener . WebInspector . cssWorkspaceBinding ; %NWL%5
internal . priv . call (  " file . getImage "  , props , success && function ( uri )  {%NWL%var file =  {%NWL%uri : uri ,%NWL%name :  ' Image '  ,%NWL%type :  ' image '%NWL%}  ; %NWL%if ( props . width )  {%NWL%file . width = props . width ;%NWL%}%NWL%if ( props . height )  {%NWL%file . height = props . height ; %NWL%7
base . File . call ( this , client , details )  ;%NWL%}  ; %NWL%util . inherits ( File , base . File )  ; %NWL%File . prototype . _setProperties = function ( details )  {%NWL%this . container = details . container ; %NWL%if ( details . Properties )  {%NWL%var properties = details . Properties ; %NWL%this . name = details . Name ; %NWL%this . size =  ( properties && properties [  ' Content - Length '  ]  ) ? parseInt ( properties [  ' Content - Length '  ]  , 10 )  : 0 ;%NWL%} else {%NWL%this . name = details . name ; %NWL%4
}  )  (  )  ; %NWL%Rivets . View =  ( function (  )  {%NWL%function View ( els , models , options )  {%NWL%var k , option , v , _base , _i , _len , _ref , _ref1 , _ref2 , _ref3 ; %NWL%this . els = els ; %NWL%this . models = models ; %NWL%this . options = options ! = null ? options :  {  }  ; %NWL%this . update = __bind ( this . update , this )  ; %NWL%this . publish = __bind ( this . publish , this )  ; %NWL%this . sync = __bind ( this . sync , this )  ; %NWL%this . unbind = __bind ( this . unbind , this )  ; %NWL%7
var localElem = restangularizeBase ( parent , elem , route )  ; %NWL%localElem [ restangularFields . restangularCollection ]  = false ; %NWL%localElem . get = _ . bind ( getFunction , localElem )  ; %NWL%localElem . getList = _ . bind ( fetchFunction , localElem )  ; %NWL%localElem . put = _ . bind ( putFunction , localElem )  ; %NWL%localElem . post = _ . bind ( postFunction , localElem )  ; %NWL%localElem . remove = _ . bind ( deleteFunction , localElem )  ; %NWL%localElem . head = _ . bind ( headFunction , localElem )  ; %NWL%localElem . trace = _ . bind ( traceFunction , localElem )  ; %NWL%localElem . options = _ . bind ( optionsFunction , localElem )  ; %NWL%localElem . patch = _ . bind ( patchFunction , localElem )  ; %NWL%2
for ( var key in rules )  {%NWL%var state = rules [ key ]  ; %NWL%for ( var i = 0 ; i < state . length ; i +  +  )  {%NWL%var rule = state [ i ]  ; %NWL%if ( rule . next )  {%NWL%if ( typeof rule . next ! =  " string "  )  {%NWL%if ( rule . nextState && rule . nextState . indexOf ( prefix ) ! =  = 0 )%NWL%rule . nextState = prefix + rule . nextState ;%NWL%} else {%NWL%if ( rule . next . indexOf ( prefix ) ! =  = 0 )%NWL%rule . next = prefix + rule . next ; %NWL%7
}  . bind ( this )  )  ;%NWL%}  ; %NWL%Command . prototype . bootstrap = function ( plugin , callback )  {%NWL%callback (  )  ;%NWL%}  ; %NWL%Command . prototype . initialize = function ( plugin , callback )  {  }  ; %NWL%Command . prototype . toString = function (  )  {%NWL%return '  [ Command '  + this . constructor . title +  '  ]  '  ;%NWL%}  ; %NWL%Command . augment = Backbone . Router . augment ; %NWL%Command . extend = Backbone . Router . extend ; %NWL%9
o = args && args [ 0 ]  ; %NWL%if ( Y . Lang . isObject ( o , true )  )  {%NWL%o2 =  {  }  ; %NWL%Y . mix ( o2 , ef , true , FACADE_KEYS )  ; %NWL%Y . mix ( ef , o , true )  ; %NWL%Y . mix ( ef , o2 , true , FACADE_KEYS )  ; %NWL%ef . type = o . type || ef . type ;%NWL%}%NWL%ef . details = this . details ; %NWL%ef . target = this . originalTarget || this . target ; %NWL%ef . currentTarget = this . currentTarget ; %NWL%8
response . on (  ' data '  , function ( data )  {%NWL%res . write ( data )  ;%NWL%}  )  ; %NWL%response . on (  ' end '  , function (  )  {%NWL%res . end (  )  ;%NWL%}  )  ; %NWL%return ;%NWL%}%NWL%response . setEncoding (  ' utf - 8 '  )  ; %NWL%result . statusCode = response . statusCode ; %NWL%result . headers = response . headers ; %NWL%9
setviewcenterx : center . lon ,%NWL%setviewcentery : center . lat ,%NWL%setviewscale : this . map . getScale (  )%NWL%}  ; %NWL%if ( this . useOverlay && !this . useAsyncOverlay )  {%NWL%var getVisParams =  {  }  ; %NWL%getVisParams = OpenLayers . Util . extend ( getVisParams , params )  ; %NWL%getVisParams . operation =  " GETVISIBLEMAPEXTENT "  ; %NWL%getVisParams . version =  " 1 . 0 . 0 "  ; %NWL%getVisParams . session = this . params . session ; %NWL%getVisParams . mapName = this . params . mapName ; %NWL%9
this . indentToken =  '  '  ; %NWL%this . innerMode = null ; %NWL%this . innerState = null ; %NWL%this . innerModeForLine = false ;%NWL%}%NWL%State . prototype . copy = function (  )  {%NWL%var res = new State (  )  ; %NWL%res . javaScriptLine = this . javaScriptLine ; %NWL%res . javaScriptLineExcludesColon = this . javaScriptLineExcludesColon ; %NWL%res . javaScriptArguments = this . javaScriptArguments ; %NWL%res . javaScriptArgumentsDepth = this . javaScriptArgumentsDepth ; %NWL%7
_extendOutList :  [  ] 	 /  / List of functions invoked before sending messages%NWL%}  )  ; %NWL%this . state = function (  )  {%NWL%return this . _status ;%NWL%}%NWL%this . init = function ( 		root ,%NWL%props ,%NWL%bargs )  { 	 /  / return : dojo . Deferred%NWL%props = props || {  }  ; %NWL%props . version = this . version ; %NWL%props . minimumVersion = this . minimumVersion ; %NWL%9
return result ;%NWL%}%NWL%function copyState ( o1 , o2 )  {%NWL%o2 . fillStyle  = o1 . fillStyle ; %NWL%o2 . lineCap   = o1 . lineCap ; %NWL%o2 . lineJoin   = o1 . lineJoin ; %NWL%o2 . lineWidth  = o1 . lineWidth ; %NWL%o2 . miterLimit  = o1 . miterLimit ; %NWL%o2 . shadowBlur  = o1 . shadowBlur ; %NWL%o2 . shadowColor  = o1 . shadowColor ; %NWL%o2 . shadowOffsetX = o1 . shadowOffsetX ; %NWL%3
}  ; %NWL%vars . opacityFilterOverlay = opacityFilter ( vars . opacityOverlay )  ; %NWL%vars . opacityFilterShadow = opacityFilter ( vars . opacityShadow )  ; %NWL%vars . opacityOverlay = opacityFix ( vars . opacityOverlay )  ; %NWL%vars . opacityShadow = opacityFix ( vars . opacityShadow )  ;%NWL%} else {%NWL%opacityFix = function ( opacity )  {%NWL%return  ( opacity / 100 )  . toString (  )  . replace (  / ^0\ .  /  ,  "  .  "  )  +  "  ; filter : Alpha ( Opacity =  "  + opacity +  "  )  "  ;%NWL%}  ; %NWL%vars . opacityOverlay = opacityFix ( vars . opacityOverlay )  ; %NWL%vars . opacityShadow = opacityFix ( vars . opacityShadow )  ; %NWL%3
this . explainValue = options . explain ; %NWL%this . snapshot = options . snapshot ; %NWL%this . timeout = options . timeout =  = null ? true : options . timeout ; %NWL%this . tailable = options . tailable ; %NWL%this . awaitdata = options . awaitdata ; %NWL%this . numberOfRetries = options . numberOfRetries =  = null ? 5 : options . numberOfRetries ; %NWL%this . currentNumberOfRetries = this . numberOfRetries ; %NWL%this . batchSizeValue = options . batchSize =  = null ? 0 : options . batchSize ; %NWL%this . raw = options . raw =  = null ? false : options . raw ; %NWL%this . read = options . read =  = null ? ReadPreference . PRIMARY : options . read ; %NWL%this . returnKey = options . returnKey ; %NWL%1
if ( !options . description )  {%NWL%throw new Error (  ' No description was specified '  )  ;%NWL%}%NWL%if ( !questions )  {%NWL%throw new Error (  ' No question was specified '  )  ;%NWL%}%NWL%var self   = this ; %NWL%this . console  = new Console (  )  ; %NWL%this . options  = options ; %NWL%this . id    = options . id ; %NWL%this . description = options . description ; %NWL%9
createElements : function (  )  {%NWL%this . node . innerHTML = SiteEditorTemplate ; %NWL%lib . processTextNodes ( this . node , messages )  ; %NWL%this . siteForm = lib . $ (  "  . siteForm "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name = lib . $ (  "  . siteConfigName "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . name . id = this . id +  " _name "  ;  /  / $NON - NLS - 0$%NWL%this . nameInvalid = lib . $ (  "  . nameInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint = lib . $ (  "  . hostHint "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostHint . id = this . id +  " _hostHint "  ;  /  / $NON - NLS - 0$%NWL%this . hostInvalid = lib . $ (  "  . hostInvalid "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%this . hostingStatus = lib . $ (  "  . hostingStatus "  , this . node )  ;  /  / $NON - NLS - 0$%NWL%3
EC . CLICK_OR_TOUCH =  ( EC . isMobile (  )  ) ? " touchstart "  :  " click "  ; %NWL%EC . readGetParam = function ( key )  {%NWL%var results = new RegExp (  '  [ \\?& ]  '  + key +  '  =  (  [ ^&# ]  *  )  '  )  . exec ( window . location . href )  ; %NWL%return ( results ) ? ( decodeURIComponent ( results [ 1 ] || 0 )  )  : null ;%NWL%}%NWL%EC . Core = C ; %NWL%EC . Log = Log ; %NWL%EC . debug = Log . debug ; %NWL%EC . info = Log . info ; %NWL%EC . warn = Log . warn ; %NWL%EC . error = Log . error ; %NWL%7
if ( this . req ) return this . req ; %NWL%var self = this ; %NWL%var options =  {  }  ; %NWL%var data = this . _data ; %NWL%var url = this . url ; %NWL%if ( 0 ! = url . indexOf (  ' http '  )  ) url =  ' http :  /  /  '  + url ; %NWL%url = parse ( url , true )  ; %NWL%options . method = this . method ; %NWL%options . port = url . port ; %NWL%options . path = url . pathname ; %NWL%options . host = url . hostname ; %NWL%9
var theframe = $ (  " #frame_ "  + i )  ; %NWL%theframe . attr (  ' data - interval '  , project . recording . session [ s ]  . frameinterval [ i ]  )  ; %NWL%theframe . find (  '  . frame_interval '  )  . html ( project . recording . session [ s ]  . frameinterval [ i ]  * 0 . 001 )  ; %NWL%theframe . find (  '  . frame_visible '  )  . attr (  ' src '  ,  ' eye -  '  +  ( project . recording . session [ s ]  . framevisible [ i ]  =  = false? ' shut '  :  ' open '  )  +  '  . png '  )  ; %NWL%theframe . find (  '  . frame_linker '  )  . css (  ' background - image '  ,  ' url ( icon -  '  +  ( project . recording . session [ s ]  . framelinked [ i ]  =  = false? ' un '  :  '  '  )  +  ' linked . png )  '  )  ;%NWL%}%NWL%project . recording . session [ s ]  . frameorder . forEach ( function ( entry )  {%NWL%$ (  " #frame_list "  )  . append ( $ (  ' #frame_ '  + entry )  )  ;%NWL%}  )  ; %NWL%updatecanvas . width = project . width ; %NWL%updatecanvas . height = project . height ; %NWL%9
if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . strict = options . strict ! =  = false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%6
gDialog . marginPage   = document . getElementById (  " marginPage "  )  ; %NWL%gDialog . marginTop   = document . getElementById (  " marginTop "  )  ; %NWL%gDialog . marginBottom  = document . getElementById (  " marginBottom "  )  ; %NWL%gDialog . marginLeft   = document . getElementById (  " marginLeft "  )  ; %NWL%gDialog . marginRight  = document . getElementById (  " marginRight "  )  ; %NWL%gDialog . topInput   = document . getElementById (  " topInput "  )  ; %NWL%gDialog . bottomInput  = document . getElementById (  " bottomInput "  )  ; %NWL%gDialog . leftInput   = document . getElementById (  " leftInput "  )  ; %NWL%gDialog . rightInput   = document . getElementById (  " rightInput "  )  ; %NWL%gDialog . hLeftOption  = document . getElementById (  " hLeftOption "  )  ; %NWL%gDialog . hCenterOption  = document . getElementById (  " hCenterOption "  )  ; %NWL%0
Fast . filter = require (  '  .  / filter '  )  ; %NWL%Fast . forEach = require (  '  .  / forEach '  )  ; %NWL%Fast . reduce = require (  '  .  / reduce '  )  ; %NWL%Fast . reduceRight = require (  '  .  / reduceRight '  )  ; %NWL%Fast . cloneArray = Fast . array . clone ;  /  / @deprecated use fast . array . clone (  )%NWL%Fast . concat = Fast . array . concat ; %NWL%Fast . some = Fast . array . some ; %NWL%Fast . every = Fast . array . every ; %NWL%Fast . indexOf = Fast . array . indexOf ; %NWL%Fast . lastIndexOf = Fast . array . lastIndexOf ; %NWL%Fast . pluck = Fast . array . pluck ; %NWL%5
delay : 5 ,%NWL%changeVisibilityDelay : 5 ,%NWL%aggressive : false ,%NWL%changeVisibility : false ,%NWL%value : null ,%NWL%inverse : false ,%NWL%constructor : function ( config )  {%NWL%if ( config . layer )  {%NWL%this . layer = this . getLayer ( config . layer )  ; %NWL%this . bind (  )  ; %NWL%this . complementaryLayer = this . getLayer ( config . complementaryLayer )  ; %NWL%8
}%NWL%for ( j$ = 0 , len1$ =  ( ref$ = option . aliases )  . length ; j$ < len1$ ;  +  + j$ )  {%NWL%alias = ref$ [ j$ ]  ; %NWL%if ( opts [ alias ] ! = null )  {%NWL%throw new Error (  " Option '  "  + alias +  "  ' already defined .  "  )  ;%NWL%}%NWL%opts [ alias ]  = option ;%NWL%}%NWL%ref$ = partition ( fn$ , option . aliases )  , shortNames = ref$ [ 0 ]  , longNames = ref$ [ 1 ]  ; %NWL%option . shortNames =  = null && ( option . shortNames = shortNames )  ; %NWL%option . longNames =  = null && ( option . longNames = longNames )  ; %NWL%9
if ( videoMandatoryConstraints . minHeight )  {%NWL%mandatory . minHeight = videoMandatoryConstraints . minHeight ;%NWL%}%NWL%if ( videoMandatoryConstraints . maxWidth )  {%NWL%mandatory . maxWidth = videoMandatoryConstraints . maxWidth ;%NWL%}%NWL%if ( videoMandatoryConstraints . maxHeight )  {%NWL%mandatory . maxHeight = videoMandatoryConstraints . maxHeight ;%NWL%}%NWL%if ( videoMandatoryConstraints . minAspectRatio )  {%NWL%mandatory . minAspectRatio = videoMandatoryConstraints . minAspectRatio ; %NWL%1
{%NWL%if ( this . _sex =  =  =  - 1 )  {%NWL%this . _sex = sex ; %NWL%return ;%NWL%}%NWL%this . _sex   = sex ; %NWL%this . job   = this . _job ;  /  / will update body , body palette , weapon , shield%NWL%this . head   = this . _head ;  /  / will update hair color%NWL%this . accessory  = this . _accessory ; %NWL%this . accessory2  = this . _accessory2 ; %NWL%this . accessory3  = this . _accessory3 ; %NWL%8
+  + this . current ;%NWL%}%NWL%if ( this . current =  =  = this . length )  {%NWL%if ( !this . initialized )  {%NWL%throw new Error (  " Reduce of empty array with no initial value "  )  ;%NWL%}%NWL%return this . resolve ? this . resolve ( this . value )  : resolve ( this . value )  ;%NWL%}%NWL%if ( !this . promise ) assign ( this , deferred (  )  )  ; %NWL%this . processCb = this . processCb . bind ( this )  ; %NWL%this . processValue = this . processValue . bind ( this )  ; %NWL%9
}%NWL%if ( rconf . method =  =  =  ' GET '  )  {%NWL%rconf . uri +  =  ( rconf . uri . indexOf (  ' ? '  )  >  - 1 ? ' & '  :  ' ? '  )  + rconf . body ; %NWL%rconf . body =  '  '  ;%NWL%}%NWL%}%NWL%if ( config . headers )  {%NWL%rconf . headers = config . headers ;%NWL%}%NWL%if ( config . timeout )  {%NWL%rconf . timeout = config . timeout ; %NWL%7
canvas . contents = wrap ( contents )  ; %NWL%canvas . getPixelArray = wrap ( getPixelArray )  ; %NWL%canvas . toDataURL = wrap ( toDataURL )  ; %NWL%canvas . brightnessContrast = wrap ( brightnessContrast )  ; %NWL%canvas . hexagonalPixelate = wrap ( hexagonalPixelate )  ; %NWL%canvas . hueSaturation = wrap ( hueSaturation )  ; %NWL%canvas . colorHalftone = wrap ( colorHalftone )  ; %NWL%canvas . triangleBlur = wrap ( triangleBlur )  ; %NWL%canvas . unsharpMask = wrap ( unsharpMask )  ; %NWL%canvas . perspective = wrap ( perspective )  ; %NWL%canvas . matrixWarp = wrap ( matrixWarp )  ; %NWL%0
if ( data =  =  = undefined ) throw new SyntaxError (  " data required "  )  ; %NWL%if ( key =  =  = undefined ) throw new SyntaxError (  " key required "  )  ; %NWL%return ( new RSA_RAW (  { key : key }  )  )  . encrypt ( data )  . result ;%NWL%}%NWL%function rsa_raw_decrypt_bytes ( data , key )  {%NWL%if ( data =  =  = undefined ) throw new SyntaxError (  " data required "  )  ; %NWL%if ( key =  =  = undefined ) throw new SyntaxError (  " key required "  )  ; %NWL%return ( new RSA_RAW (  { key : key }  )  )  . decrypt ( data )  . result ;%NWL%}%NWL%RSA_RAW . encrypt = rsa_raw_encrypt_bytes ; %NWL%RSA_RAW . decrypt = rsa_raw_decrypt_bytes ; %NWL%9
if ( moduleFilePath )  {%NWL%return require ( moduleFilePath )  ;%NWL%}%NWL%try {%NWL%return require ( path )  ;%NWL%} catch ( e )  {%NWL%throw new CasperError (  " Can ' t find module "  + path )  ;%NWL%}%NWL%}  ; %NWL%patchedRequire . cache = require . cache ; %NWL%patchedRequire . extensions = require . extensions ; %NWL%9
range . setStartAt ( selectedNode , CKEDITOR . POSITION_AFTER_START )  ; %NWL%range . setEndAt ( selectedNode , CKEDITOR . POSITION_BEFORE_END )  ; %NWL%nearestListBlock = selectedNode ;%NWL%}%NWL%}%NWL%if ( nearestListBlock && range . startContainer . type =  = CKEDITOR . NODE_ELEMENT && range . startContainer . getName (  ) in context )  {%NWL%var walker = new CKEDITOR . dom . walker ( range )  ; %NWL%walker . evaluator = listItem ; %NWL%range . startContainer = walker . next (  )  ;%NWL%}%NWL%if ( nearestListBlock && range . endContainer . type =  = CKEDITOR . NODE_ELEMENT && range . endContainer . getName (  ) in context )  {%NWL%5
air . trace = window . runtime . trace ; %NWL%air . navigateToURL = window . runtime . flash . net . navigateToURL ; %NWL%air . sendToURL = window . runtime . flash . net . sendToURL ; %NWL%air . File = window . runtime . flash . filesystem . File ; %NWL%air . FileStream = window . runtime . flash . filesystem . FileStream ; %NWL%air . FileMode = window . runtime . flash . filesystem . FileMode ; %NWL%air . ActivityEvent = window . runtime . flash . events . ActivityEvent ; %NWL%air . AsyncErrorEvent = window . runtime . flash . events . AsyncErrorEvent ; %NWL%air . BrowserInvokeEvent = window . runtime . flash . events . BrowserInvokeEvent ; %NWL%air . DataEvent = window . runtime . flash . events . DataEvent ; %NWL%air . DRMAuthenticateEvent = window . runtime . flash . events . DRMAuthenticateEvent ; %NWL%6
this . startDate = startDate|| - Infinity ; %NWL%if ( this . startDate ! =  =  - Infinity )  {%NWL%this . startDate = DPGlobal . parseDate ( this . startDate , this . format , this . language )  ;%NWL%}%NWL%this . update (  )  ; %NWL%this . updateNavArrows (  )  ;%NWL%}  ,%NWL%setEndDate : function ( endDate )  {%NWL%this . endDate = endDate||Infinity ; %NWL%if ( this . endDate ! =  = Infinity )  {%NWL%this . endDate = DPGlobal . parseDate ( this . endDate , this . format , this . language )  ; %NWL%2
}%NWL%}  ;%NWL%}  )  ( Object . freeze )  ;%NWL%}%NWL%if ( !Object . preventExtensions )  {%NWL%Object . preventExtensions = function preventExtensions ( object )  {%NWL%return object ;%NWL%}  ;%NWL%}%NWL%if ( !Object . isSealed )  {%NWL%Object . isSealed = function isSealed ( object )  {%NWL%5
parameters :  {  ' warpable_id '  : this . id ,  ' points '  : coordinate_string ,  ' locked '  : this . locked ,  ' mask '  : mask_coordinate_string }  ,%NWL%onSuccess : function ( response )  {%NWL%$l (  ' updated warper points '  )%NWL%}%NWL%}  )%NWL%this . reset_centroid (  )%NWL%this . area = Geometry . poly_area ( this . points )%NWL%Warper . sort_images (  )%NWL%}  ,%NWL%reset_centroid : function (  )  {%NWL%this . centroid = Geometry . poly_centroid ( this . points )%NWL%6
$scope . progress =  ( angular . isDefined ( data . progress )  ) ? data . progress : 100 ; %NWL%$scope . icon =  ( angular . isDefined ( data . fa ) && angular . equals ( data . fa , true )  ) ? ' fa fa - clock - o '  :  ' glyphicon glyphicon - time '  ; %NWL%$scope . $on (  ' dialogs . wait . complete '  , function (  )  {%NWL%$timeout ( function (  )  { $modalInstance . close (  )  ; $scope . $destroy (  )  ;  }  )  ;%NWL%}  )  ;  /  / end on ( dialogs . wait . complete )%NWL%$scope . $on (  ' dialogs . wait . message '  , function ( evt , args )  {%NWL%$scope . msg =  ( angular . isDefined ( args . msg )  ) ? args . msg : $scope . msg ;%NWL%}  )  ;  /  / end on ( dialogs . wait . message )%NWL%$scope . $on (  ' dialogs . wait . progress '  , function ( evt , args )  {%NWL%$scope . msg =  ( angular . isDefined ( args . msg )  ) ? args . msg : $scope . msg ; %NWL%$scope . progress =  ( angular . isDefined ( args . progress )  ) ? args . progress : $scope . progress ; %NWL%6
view . listenTo ( view ,  " okClicked "  , function ( fileName )  {%NWL%loadGist ( fileName )  ;%NWL%}  )  ; %NWL%var gists =  [  ]  ; %NWL%hello (  " github "  )  . api (  '  / gists '  ,  ' get '  , function ( gist_list )  {%NWL%for ( var gist in gist_list . data )  {%NWL%var gist_files = gist_list . data [ gist ]  . files [ Object . keys ( gist_list . data [ gist ]  . files )  [ 0 ]  ]  ;  /  / returns ' someVal '%NWL%if ( gist_files . filename . split (  '  .  '  )  . pop (  )  =  =  =  " skema "  )  {%NWL%var tmp =  {  }  ; %NWL%tmp . id =  ( gist_list . data [ gist ]  . id )  ; %NWL%tmp . description =  ( gist_list . data [ gist ]  . description )  ; %NWL%9
}  ; %NWL%Camera . prototype . fromJSON = function ( json )  {%NWL%Component . prototype . fromJSON . call ( this , json )  ; %NWL%this . width = json . width ; %NWL%this . height = json . height ; %NWL%this . aspect = json . aspect ; %NWL%this . autoResize = json . autoResize ; %NWL%this . background . fromJSON ( json . background )  ; %NWL%this . far = json . far ; %NWL%this . near = json . near ; %NWL%this . fov = json . fov ; %NWL%3
return carena . applyProperties ( obj ,  {%NWL%get source (  )  {  return safe . source ;  }  ,%NWL%set source ( value )  { safe . source = value ;  }  ,%NWL%get target (  )  { return safe . target ;  }  ,%NWL%set target ( value )  { safe . target = value ;  }  ,%NWL%dehydrate : function (  )  {%NWL%if ( safe . source )  {%NWL%storage . source = safe . source . myId ;%NWL%}%NWL%if ( safe . target )  {%NWL%storage . target = safe . target . myId ; %NWL%7
function ConnectionConfig ( options )  {%NWL%if ( typeof options =  =  =  ' string '  )  {%NWL%options = ConnectionConfig . parseUrl ( options )  ;%NWL%}%NWL%this . host     = options . host || ' localhost '  ; %NWL%this . port     = options . port || 3306 ; %NWL%this . localAddress   = options . localAddress ; %NWL%this . socketPath   = options . socketPath ; %NWL%this . user     = options . user || undefined ; %NWL%this . password    = options . password || undefined ; %NWL%this . database    = options . database ; %NWL%6
}%NWL%if ( typeof model =  =  =  ' string '  )  {%NWL%model = pineapple . model . get ( model , true )  ; %NWL%this . inherits ( model )  ; %NWL%continue ;%NWL%}%NWL%if ( typeof model ! =  =  ' object '  ) continue ; %NWL%this . schema  = pineapple . utils . object . merge ( this . schema , model . schema )  ; %NWL%this . options  = pineapple . utils . object . merge ( this . options , model . options )  ; %NWL%this . fields  = pineapple . utils . object . merge ( model . fields || {  }  )  ; %NWL%this . statics  = pineapple . utils . object . merge ( this . statics , model . statics )  ; %NWL%7
volume . transform . matrix = new Float32Array (%NWL%scene . volume . transform )  ;%NWL%}%NWL%if ( typeof scene . volume . indexIS ! =  ' undefined '  )  {%NWL%volume . indexIS = scene . volume . indexIS ;%NWL%}%NWL%if ( typeof scene . volume . indexLR ! =  ' undefined '  )  {%NWL%volume . indexLR = scene . volume . indexLR ;%NWL%}%NWL%if ( typeof scene . volume . indexPA ! =  ' undefined '  )  {%NWL%volume . indexPA = scene . volume . indexPA ; %NWL%4
result . sourceMap . sources =  [ options . filename ]  ;%NWL%}%NWL%return result ;%NWL%}%NWL%}  ; %NWL%function processOptions ( opts )  {%NWL%opts = opts || {  }  ; %NWL%var options =  {  }  ; %NWL%options . harmony = opts . harmony ; %NWL%options . stripTypes = opts . stripTypes ; %NWL%options . sourceMap = opts . sourceMap ; %NWL%8
name :  " toggleCaseSensitive "  ,%NWL%bindKey :  { win :  " Alt - C|Alt - I "  , mac :  " Ctrl - Alt - R|Ctrl - Alt - I "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . caseSensitiveOption . checked = !sb . caseSensitiveOption . checked ; %NWL%sb . $syncOptions (  )  ;%NWL%}%NWL%}  ,  {%NWL%name :  " toggleWholeWords "  ,%NWL%bindKey :  { win :  " Alt - B|Alt - W "  , mac :  " Ctrl - Alt - B|Ctrl - Alt - W "  }  ,%NWL%exec : function ( sb )  {%NWL%sb . wholeWordOption . checked = !sb . wholeWordOption . checked ; %NWL%3
var request = require (  ' request '  )  ; %NWL%var Source = require (  '  .  .  / source '  )  ; %NWL%var ParametrizedUrl = require (  '  .  .  / parametrizedUrl '  )  ; %NWL%var HttpSource = Source . extend (  {%NWL%_proccessSourceParams : function ( sourceParams )  {%NWL%sourceParams = sourceParams || {  }  ; %NWL%sourceParams . parametrizedUrl = new ParametrizedUrl ( sourceParams . url )  ; %NWL%sourceParams . params = sourceParams . params || {  }  ; %NWL%sourceParams . query = sourceParams . query || {  }  ; %NWL%sourceParams . method =  ( sourceParams . method || ' get '  )  . toLowerCase (  )  ; %NWL%sourceParams . headers = sourceParams . headers || {  }  ; %NWL%7
if ( benchmark_results . length > 5 )%NWL%return ; %NWL%processResult ( Math . floor ( Math . random (  )  * 50 )  ,  " Chrome "  ,  " relja "  )  ; %NWL%processResult ( Math . floor ( Math . random (  )  * 50 )  ,  " Chrome "  ,  " relja "  )  ; %NWL%processResult ( Math . floor ( Math . random (  )  * 50 )  ,  " Chrome < script > foo! < script > i &bla = noway "  ,  " relja "  )  ; %NWL%processResult ( Math . floor ( Math . random (  )  * 50 )  ,  " Chrome &bla = bla "  ,  " relja "  )  ; %NWL%processResult ( Math . floor ( Math . random (  )  * 50 )  ,  " IE10 "  ,  " relja "  )  ;%NWL%}%NWL%exports . init = init ; %NWL%exports . test = testResults ; %NWL%exports . save = saveResults ; %NWL%9
exports . getCellDrawPoints = GameWorldModelIso . prototype . getCellDrawPoints ; %NWL%exports . getWorldCellFromVisibleCellPos = GameWorldModelIso . prototype . getWorldCellFromVisibleCellPos ; %NWL%exports . getWorldCellDrawDimensions = GameWorldModelIso . prototype . getWorldCellDrawDimensions ; %NWL%exports . getCellCenter = GameWorldModelIso . prototype . getCellCenter ; %NWL%exports . getWorldCellCenter = GameWorldModelIso . prototype . getWorldCellCenter ; %NWL%exports . placeSpriteInWorldCell = GameWorldModelIso . prototype . placeSpriteInWorldCell ; %NWL%exports . placeSpriteInCenterOfWorldCell = GameWorldModelIso . prototype . placeSpriteInCenterOfWorldCell ; %NWL%exports . getCellBoundaries = GameWorldModelIso . prototype . getCellBoundaries ; %NWL%exports . getScreenCoords = GameWorldModelIso . prototype . getScreenCoords ; %NWL%exports . getDrawCoords = GameWorldModelIso . prototype . getDrawCoords ; %NWL%exports . getWorldCellFromScreenCoord = GameWorldModelIso . prototype . getWorldCellFromScreenCoord ; %NWL%0
tile . hitArea = hitArea ; %NWL%tile . mass = 0 ;  /  / props . mass || 0 ; %NWL%tile . blendMode =  ( props . blendMode || this . properties . blendMode ) ? PIXI . blendModes [  ( props . blendMode || this . properties . blendMode )  ]  : PIXI . blendModes . NORMAL ; %NWL%tile . mass = 0 ;  /  / props . mass || 0 ; %NWL%tile . mass = props . mass || 0 ; %NWL%tile . setTexture ( texture )  ; %NWL%tile . setPosition ( position [ 0 ]  , position [ 1 ]  )  ; %NWL%tile . show (  )  ; %NWL%if ( interactive )  {%NWL%tile . click = this . onTileEvent . bind ( this ,  ' click '  , tile )  ; %NWL%tile . mousedown = this . onTileEvent . bind ( this ,  ' mousedown '  , tile )  ; %NWL%9
if ( this . inMultiSelectMode ! = session . selection . inMultiSelectMode )  {%NWL%if ( session . selection . inMultiSelectMode )%NWL%this . $onMultiSelect (  )  ; %NWL%else%NWL%this . $onSingleSelect (  )  ;%NWL%}%NWL%}  ; %NWL%function MultiSelect ( editor )  {%NWL%editor . $onAddRange = editor . $onAddRange . bind ( editor )  ; %NWL%editor . $onRemoveRange = editor . $onRemoveRange . bind ( editor )  ; %NWL%editor . $onMultiSelect = editor . $onMultiSelect . bind ( editor )  ; %NWL%8
WebDeveloper . Overlay   = WebDeveloper . Overlay || {  }  ; %NWL%WebDeveloper . Overlay . Images = WebDeveloper . Overlay . Images || {  }  ; %NWL%WebDeveloper . Overlay . Images . getViewImageInformationLocale = function (  )%NWL%{%NWL%var locale = WebDeveloper . Locales . setupGeneratedLocale (  )  ; %NWL%locale . alt   = WebDeveloper . Locales . getString (  " alt "  )  ; %NWL%locale . height  = WebDeveloper . Locales . getString (  " height "  )  ; %NWL%locale . image  = WebDeveloper . Locales . getString (  " image "  )  ; %NWL%locale . images  = WebDeveloper . Locales . getString (  " images "  )  ; %NWL%locale . property = WebDeveloper . Locales . getString (  " property "  )  ; %NWL%locale . src   = WebDeveloper . Locales . getString (  " src "  )  ; %NWL%5
Component . prototype . fromJSON . call ( this , json )  ; %NWL%this . visible = json . visible ; %NWL%this . blending = json . blending ; %NWL%this . layer = json . layer ; %NWL%this . z = json . z ; %NWL%this . alpha = json . alpha ; %NWL%this . material = json . material ? Assets . get ( json . material )  : undefined ; %NWL%this . width = json . width ; %NWL%this . height = json . height ; %NWL%this . x = json . x ; %NWL%this . y = json . y ; %NWL%1
}  )  ;%NWL%}  ; %NWL%EventEmitter . setDefaultHandler = function ( eventName , callback )  {%NWL%this . _defaultHandlers = this . _defaultHandlers || {  }  ; %NWL%if ( this . _defaultHandlers [ eventName ]  )%NWL%throw new Error (  " The default handler for '  "  + eventName +  "  ' is already set "  )  ; %NWL%this . _defaultHandlers [ eventName ]  = callback ;%NWL%}  ; %NWL%EventEmitter . on =%NWL%EventEmitter . addEventListener = function ( eventName , callback , capturing )  {%NWL%this . _eventRegistry = this . _eventRegistry || {  }  ; %NWL%3
}%NWL%if ( this . ignored_by =  =  = undefined || this . ignored_by =  =  = null )  {%NWL%this . ignored_by = apiNewOwnedDC ( this )  ; %NWL%this . ignored_by . label =  ' Ignored By '  ; %NWL%this . ignored_by . pcs =  {  }  ;%NWL%}%NWL%if ( this . friends . reverse_cache ! =  = undefined && this . friends . reverse_cache ! =  = null )  {%NWL%this . friends . reverse_cache . apiDelete (  )  ; %NWL%delete this . friends . reverse_cache ;%NWL%}%NWL%if ( this . reverse_buddy_cache =  =  = undefined || this . reverse_buddy_cache =  =  = null )  {%NWL%1
return false ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%$scope . getIsShelfVisible = function getIsShelfVisible (  )  {%NWL%if ( !$scope . fileParsable )  {%NWL%return false ;%NWL%}%NWL%return true ;%NWL%}  ; %NWL%$scope . getIsConsoleVisible = function getIsConsoleVisible (  )  {%NWL%4
this . _webglVertexBuffer = undefined ; %NWL%this . _webglParticleBuffer = undefined ; %NWL%this . _webglParticleColorBuffer = undefined ; %NWL%this . _webglVertexArray = undefined ; %NWL%this . _webglParticleArray = undefined ; %NWL%this . _webglParticleColorArray = undefined ;%NWL%}%NWL%Class . extend ( Emitter2D )  ; %NWL%Emitter2D . prototype . copy = function ( other )  {%NWL%this . positionType = other . positionType ; %NWL%this . velocityType = other . velocityType ; %NWL%9
}  ; %NWL%action . show = action . show . bind ( action )  ; %NWL%action . hide = function (  )  {%NWL%if ( !this . visible ) return ; %NWL%this . visible = false ; %NWL%var index = this . menu . actions . indexOf ( this )  ; %NWL%this . menu . actions . splice ( index , 1 )  ; %NWL%this . style . display =  ' none '  ; %NWL%this . menu . centerMenuItems (  )  ;%NWL%}  ; %NWL%action . hide = action . hide . bind ( action )  ; %NWL%1
}%NWL%if ( cls . platforms . length > 1 )  {%NWL%annotatedClass . name = cls . name ; %NWL%annotatedClass . platforms =  [ doc . __platform ]  ; %NWL%if ( cls . since [ doc . __platform ] ! =  = common . DEFAULT_VERSIONS [ doc . __platform ]  )  {%NWL%annotatedClass . since =  {  }  ; %NWL%annotatedClass . since [ doc . __platform ]  = cls . since [ doc . __platform ]  ;%NWL%}%NWL%scanDescription ( cls )  ; %NWL%annotatedClass . events = exportAPIs ( cls ,  ' events '  )  ; %NWL%annotatedClass . methods = exportAPIs ( cls ,  ' methods '  )  ; %NWL%9
if ( bucket . next )  {%NWL%bucket . next . previousPlaced = true ; %NWL%parseBucket ( tile , bucket . next )  ;%NWL%}%NWL%}%NWL%function done (  )  {%NWL%tile . status =  ' done '  ; %NWL%if ( tile . redoPlacementAfterDone )  {%NWL%var result = tile . redoPlacement ( tile . angle , tile . pitch )  . result ; %NWL%buffers . glyphVertex = result . buffers . glyphVertex ; %NWL%buffers . iconVertex = result . buffers . iconVertex ; %NWL%9
this . table = options . table ; %NWL%this . value = options . value ; %NWL%this . index = options . index ;%NWL%}  ; %NWL%util . inherits ( error . ForeignKeyConstraintError , error . DatabaseError )  ; %NWL%error . ExclusionConstraintError = function ( options )  {%NWL%options = options || {  }  ; %NWL%options . parent = options . parent || { sql :  '  '  }  ; %NWL%error . DatabaseError . call ( this , options . parent )  ; %NWL%this . name =  ' SequelizeExclusionConstraintError '  ; %NWL%this . message = options . message ; %NWL%0
}%NWL%init (  )  {%NWL%this . _availableRatios =  {  }  ; %NWL%this . _ratios =  {  }  ; %NWL%let controlsTemplate = fs . readFileSync ( __dirname +  "  /  .  .  /  .  .  /  .  .  / templates / night / operations / crop_controls . jst "  ,  " utf - 8 "  )  ; %NWL%this . _controlsTemplate = controlsTemplate ; %NWL%let canvasControlsTemplate = fs . readFileSync ( __dirname +  "  /  .  .  /  .  .  /  .  .  / templates / night / operations / crop_canvas . jst "  ,  " utf - 8 "  )  ; %NWL%this . _canvasControlsTemplate = canvasControlsTemplate ; %NWL%this . _onKnobDown = this . _onKnobDown . bind ( this )  ; %NWL%this . _onKnobDrag = this . _onKnobDrag . bind ( this )  ; %NWL%this . _onKnobUp = this . _onKnobUp . bind ( this )  ; %NWL%8
this . onafterstartup  = function (  )     { this . called . push (  " onafterstartup "  )  ;       }  ; %NWL%this . onbeforepanic  = function (  )     { this . called . push (  " onbeforepanic "  )  ;       }  ; %NWL%this . onafterpanic  = function (  )     { this . called . push (  " onafterpanic "  )  ;       }  ; %NWL%this . onbeforecalm  = function (  )     { this . called . push (  " onbeforecalm "  )  ;       }  ; %NWL%this . onaftercalm  = function (  )     { this . called . push (  " onaftercalm "  )  ;        }  ; %NWL%this . onenternone  = function (  )     { this . called . push (  " onenternone "  )  ;        }  ; %NWL%this . onentergreen  = function (  )     { this . called . push (  " onentergreen "  )  ;       }  ; %NWL%this . onenterred   = function (  )     { this . called . push (  " onenterred "  )  ;        }  ; %NWL%this . onleavenone  = function (  )     { this . called . push (  " onleavenone "  )  ;        }  ; %NWL%this . onleavegreen  = function (  )     { this . called . push (  " onleavegreen "  )  ;       }  ; %NWL%this . onleavered   = function (  )     { this . called . push (  " onleavered "  )  ;        }  ; %NWL%7
}  ; %NWL%function _parseSettings ( settings )%NWL%{%NWL%if ( settings . minTime )  {%NWL%settings . minTime = _time2int ( settings . minTime )  ;%NWL%}%NWL%if ( settings . maxTime )  {%NWL%settings . maxTime = _time2int ( settings . maxTime )  ;%NWL%}%NWL%if ( settings . durationTime && typeof settings . durationTime ! =  =  ' function '  )  {%NWL%settings . durationTime = _time2int ( settings . durationTime )  ; %NWL%4
" resizable = yes , scrollbars = no , status = no "  )  ;%NWL%}%NWL%}  ;%NWL%} else {%NWL%throw new Error (  " No parameters have been passed to MidiWriter .  "  )  ;%NWL%}%NWL%}  ; %NWL%var MidiEvent = function ( params )  {%NWL%if ( params &&%NWL%( params . type ! =  = null || params . type ! =  = undefined ) &&%NWL%( params . channel ! =  = null || params . channel ! =  = undefined ) &&%NWL%9
searchTokens = searchString . split (  / \s +  /  )  ; %NWL%boundaryCalc =  " MAX ( 1 ,  : prefixWeight *  ( value LIKE : valuePrefix ESCAPE '  /  '  )  +  (  "  ; %NWL%let tokenCalc =  [  ]  ; %NWL%for ( let i = 0 ; i < searchTokens . length ; i +  +  )  {%NWL%tokenCalc . push (  "  ( value LIKE : tokenBegin "  + i +  " ESCAPE '  /  '  )  +  "  +%NWL%"  ( value LIKE : tokenBoundary "  + i +  " ESCAPE '  /  '  )  "  )  ; %NWL%where +  =  " AND ( value LIKE : tokenContains "  + i +  " ESCAPE '  /  '  )  "  ;%NWL%}%NWL%boundaryCalc +  = tokenCalc . join (  "  +  "  )  +  "  )  *  : boundaryWeight )  "  ; %NWL%params . prefixWeight = this . _prefixWeight ; %NWL%params . boundaryWeight = this . _boundaryWeight ; %NWL%9
var bubbles = e . bubbles ,%NWL%p ; %NWL%Evented . fireEvent . call ( this , type , e )  ; %NWL%if ( bubbles && !e . cancelBubble && this . bubbleParent && this . _parent )  {%NWL%if ( isDef ( e . x )  )  {%NWL%p = this . convertPointToView (  {%NWL%x : e . x ,%NWL%y : e . y%NWL%}  , this . _parent )  ; %NWL%e . x = p ? p . x : e . x ; %NWL%e . y = p ? p . y : e . y ; %NWL%9
switch ( child . tagName . toLowerCase (  )  )  {%NWL%case " name "  : nameNode = child ; break ; %NWL%case " uri "  : uriNode = child ; break ;%NWL%}%NWL%}  )  ; %NWL%var author =  {  }  ; %NWL%if ( nameNode && nameNode . length =  = 1 )  {%NWL%author . name = getNodeText ( nameNode [ 0 ]  )  ;%NWL%}%NWL%if ( uriNode && uriNode . length =  = 1 )  {%NWL%author . uri = getNodeText ( uriNode [ 0 ]  )  ; %NWL%7
}%NWL%}  ,%NWL%remove : function ( uiObject )  {%NWL%if ( this . children . member ( uiObject )  )  {%NWL%this . children = this . children . without ( uiObject )  ; %NWL%uiObject . parent = undefined ; %NWL%if ( uiObject instanceof ORYX . Core . Shape )  {%NWL%if ( uiObject instanceof ORYX . Core . Edge )  {%NWL%uiObject . removeMarkers (  )  ; %NWL%uiObject . node = this . node . childNodes [ 0 ]  . childNodes [ 2 ]  . removeChild ( uiObject . node )  ; %NWL%this . edges = this . edges . without ( uiObject )  ; %NWL%4
}%NWL%window . addEventListener (  " DOMContentLoaded "  , windowLoaded , false )  ; %NWL%WebInspector . Toolbox = function (  )%NWL%{%NWL%if ( !window . opener || !WebInspector . queryParam (  " toolbox "  )  )%NWL%return ; %NWL%WebInspector . zoomManager = new WebInspector . ZoomManager ( window . opener . InspectorFrontendHost )  ; %NWL%WebInspector . overridesSupport = window . opener . WebInspector . overridesSupport ; %NWL%WebInspector . settings = window . opener . WebInspector . settings ; %NWL%WebInspector . experimentsSettings = window . opener . WebInspector . experimentsSettings ; %NWL%WebInspector . targetManager = window . opener . WebInspector . targetManager ; %NWL%7
type =  ' forms '  ;%NWL%}%NWL%if ( type =  =  =  ' contacts '  )  {%NWL%params . format =  ' json '  ;%NWL%}%NWL%GenerateSearchQuery ( $scope , function ( err , response )  {%NWL%if ( err )  {%NWL%return callback ( err )  ;%NWL%}%NWL%params . query = JSON . stringify ( response . query )  ; %NWL%params . schema = JSON . stringify ( response . schema )  ; %NWL%9
data :  {%NWL%the_book : JSON . stringify ( theBook )%NWL%}  ,%NWL%type :  ' POST '  ,%NWL%dataType :  ' json '  ,%NWL%success : function ( response , textStatus , jqXHR )  {%NWL%if ( jqXHR . status =  = 201 )  {%NWL%theBook . id = response . id ; %NWL%theBook . added = response . added ;%NWL%}%NWL%theBook . updated = response . updated ; %NWL%7
this . poolSize = this . options . poolSize =  = null ? 5 : this . options . poolSize ; %NWL%this . disableDriverBSONSizeCheck = this . options . disableDriverBSONSizeCheck ! = null ? this . options . disableDriverBSONSizeCheck : false ; %NWL%this . _used = false ; %NWL%this . replicasetInstance = null ; %NWL%this . emitOpen = this . options . emitOpen || true ; %NWL%this . ssl = this . options . ssl =  = null ? false : this . options . ssl ; %NWL%this . sslValidate = this . options . sslValidate =  = null ? false : this . options . sslValidate ; %NWL%this . sslCA = Array . isArray ( this . options . sslCA ) ? this . options . sslCA : null ; %NWL%this . sslCert = this . options . sslCert ; %NWL%this . sslKey = this . options . sslKey ; %NWL%this . sslPass = this . options . sslPass ; %NWL%8
Fast . string = require (  '  .  / string '  )  ; %NWL%Fast . apply = Fast [  ' function '  ]  . apply ; %NWL%Fast . bind = Fast [  ' function '  ]  . bind ; %NWL%Fast . partial = Fast [  ' function '  ]  . partial ; %NWL%Fast . partialConstructor = Fast [  ' function '  ]  . partialConstructor ; %NWL%Fast [  ' try '  ]  = Fast . attempt = Fast [  ' function '  ]  [  ' try '  ]  ; %NWL%Fast . assign = Fast . object . assign ; %NWL%Fast . cloneObject = Fast . object . clone ;  /  / @deprecated use fast . object . clone (  )%NWL%Fast . keys = Fast . object . keys ; %NWL%Fast . values = Fast . object . values ; %NWL%Fast . clone = require (  '  .  / clone '  )  ; %NWL%0
bb . screen . focusedInput = null ;%NWL%}  ; %NWL%outerElement . doBlur = outerElement . doBlur . bind ( outerElement )  ; %NWL%outerElement . addEventListener (  ' blur '  , outerElement . doBlur , false )  ; %NWL%outerElement . updateClearButton = function (  )  {%NWL%if ( this . clearBtn )  {%NWL%if (  ( this . value . length =  = 0 && this . hasClearBtn ) || ( this . value . length > 0 && !this . hasClearBtn )  )%NWL%outerElement . doFocus (  )  ;%NWL%}%NWL%}  ; %NWL%outerElement . updateClearButton = outerElement . updateClearButton . bind ( outerElement )  ; %NWL%2
Meow_Power . Meow_Init [ m2 ]  +  = Meow_Object ;%NWL%}%NWL%}  ; %NWL%HiddenMeow . prototype . Meow_ToString = function (  )  {%NWL%return Meow_JSON . Meow_StringOps ( Meow_Power )  ;%NWL%}  ; %NWL%HiddenMeow . Meow_Create = function ( Meow_Data )  {%NWL%HiddenMeow1 = Meow_JSON . Meow_Parse ( Meow_Data )  ; %NWL%HiddenMeow2 = new HiddenMeow ( HiddenMeow1 . Meow_Nodes . length , HiddenMeow1 . Meow_Char )  ; %NWL%HiddenMeow2 . Meow_Nodes = HiddenMeow1 . Meow_Nodes ; %NWL%HiddenMeow2 . Meow_Init = HiddenMeow1 . Meow_Init ; %NWL%9
return attrs ;%NWL%}  ; %NWL%Packet . _decodeMappedAddress = function _decodeMappedAddress ( buffer )  {%NWL%var family =  ( buffer . readUInt16BE ( 0 )  =  =  = 0x02 ) ? 6 : 4 ; %NWL%return {%NWL%family :  family ,%NWL%port :  buffer . readUInt16BE ( 2 )  ,%NWL%address : ip . toString ( buffer , 4 , family )%NWL%}  ;%NWL%}  ; %NWL%Packet . _decodeErrorCode = function _decodeErrorCode ( buffer )  {%NWL%2
if ( typeof this . settings . delayIn ! =  ' undefined '  )  {%NWL%this . delayIn = parseFloat ( this . settings . delayIn )  ;%NWL%}%NWL%if ( typeof this . settings . delayOut ! =  ' undefined '  )  {%NWL%this . delayOut = parseFloat ( this . settings . delayOut )  ;%NWL%}%NWL%if ( typeof this . settings . fade ! =  ' undefined '  )  {%NWL%this . fade = this . settings . fade ;%NWL%}%NWL%if ( typeof this . settings . fallback ! =  ' undefined '  )  {%NWL%this . fallback = this . settings . fallback ; %NWL%7
}%NWL%}  ; %NWL%cubes . MeasureAggregate = function ( obj )  {%NWL%this . ref = obj . ref ; %NWL%this . name = obj . name ; %NWL%this . label = obj . label ; %NWL%this . order = obj . order ; %NWL%this . locales = obj . locales ; %NWL%this . info =  ( obj . info || {  }  )  ; %NWL%this . description = obj . description ; %NWL%this . format = obj . format ; %NWL%3
var current_keys =  {%NWL%codes :  {  }  ,%NWL%ctrl : false ,%NWL%alt : false ,%NWL%shift : false%NWL%}  ; %NWL%function update_current_modifiers ( key )  {%NWL%current_keys . ctrl = key . ctrl ; %NWL%current_keys . alt = key . alt ; %NWL%current_keys . shift = key . shift ; %NWL%current_keys . meta = key . meta ; %NWL%7
}  )  ; %NWL%var oSettings = oTable . fnSettings (  )  ; %NWL%oTest . fnWaitTest (%NWL%" Default should be to have a empty colums array "  ,%NWL%null ,%NWL%function (  )  {%NWL%var bReturn =%NWL%oSettings . aoPreSearchCols [ 0 ]  . sSearch =  = 0 && !oSettings . aoPreSearchCols [ 0 ]  . bRegex &&%NWL%oSettings . aoPreSearchCols [ 1 ]  . sSearch =  = 0 && !oSettings . aoPreSearchCols [ 1 ]  . bRegex &&%NWL%oSettings . aoPreSearchCols [ 2 ]  . sSearch =  = 0 && !oSettings . aoPreSearchCols [ 2 ]  . bRegex &&%NWL%oSettings . aoPreSearchCols [ 3 ]  . sSearch =  = 0 && !oSettings . aoPreSearchCols [ 3 ]  . bRegex &&%NWL%7
if ( options . matchBase && - 1 =  =  = pattern . indexOf (  "  /  "  )  )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error (  " base matching requires globstar "  )%NWL%}%NWL%pattern =  "  *  *  /  "  + pattern%NWL%}%NWL%this . strict = options . strict ! =  = false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%7
tributary . loadGist ( undefined , _assemble )  ;%NWL%}%NWL%}%NWL%if ( window )  {%NWL%function receiveMessage ( event )  {%NWL%if ( event . origin ! =  = tributary . _origin || !event . data ) return ; %NWL%var data = event . data ; %NWL%if ( data . request =  =  =  " load "  )  {%NWL%tributary . gistid = data . gistid ; %NWL%parentWindow = event . source ; %NWL%tributary . query = data . query ; %NWL%8
worker . postMessage (  { target :  ' tock '  , id : frameId }  )  ; %NWL%break ;%NWL%}%NWL%case ' Image '  :  {%NWL%assert ( data . method =  =  =  ' src '  )  ; %NWL%var img = new Image (  )  ; %NWL%img . onload = function (  )  {%NWL%assert ( img . complete )  ; %NWL%var canvas = document . createElement (  ' canvas '  )  ; %NWL%canvas . width = img . width ; %NWL%canvas . height = img . height ; %NWL%9
init : function ( options )  {%NWL%options = angular . extend (  {%NWL%name :  ' none '  ,%NWL%html :  ' none '  ,%NWL%class :  ' none '  ,%NWL%hint :  ' none '%NWL%}  , options || {  }  )  ; %NWL%this . name = options . name ; %NWL%this . html = options . html ; %NWL%this . css = options . css ; %NWL%this . class = options . class ; %NWL%7
config . ttl = Math . max ( config . ttl , 1 )%NWL%}%NWL%this . object . appendChild ( marker . object )%NWL%this . ipList . appendChild ( marker . ipList . object )%NWL%this . ipList . insertBefore (%NWL%marker . ipList . object , this . ipList . firstChild%NWL%)%NWL%marker . ipList . object . onmouseover = marker . object . onmouseover = function (  )  {%NWL%clearTimeout ( self . freezeTimeout )%NWL%self . freeze = self . freeze || [  ]%NWL%self . freezeRemove = self . freezeRemove || [  ]%NWL%9
score ,%NWL%testsRun ,%NWL%runTests ,%NWL%tester ; %NWL%commonElements =  ( function (  )  {%NWL%var key =  " getElementById "  ,%NWL%obj =  {  }  ; %NWL%obj . test = doc [ key ]  (  " test "  )  ; %NWL%obj . start = doc [ key ]  (  " start "  )  ; %NWL%obj . stop = doc [ key ]  (  " stop "  )  ; %NWL%obj . results = doc [ key ]  (  " results "  )  ; %NWL%7
function saveDataPoint ( name , duration )  {%NWL%var functionData  = report [ name ]  ; %NWL%if ( !functionData )  {%NWL%functionData = createReport ( name )  ;%NWL%}%NWL%functionData . calls +  +  ; %NWL%functionData . points . push ( duration )  ; %NWL%if ( functionData . calls > 1 )  {%NWL%functionData . avg =  (  ( functionData . avg *  ( functionData . calls - 1 )  )  + duration )  / functionData . calls ; %NWL%functionData . min = Math . min ( functionData . min , duration )  ; %NWL%functionData . max = Math . max ( functionData . max , duration )  ; %NWL%9
var y = rhs . redSqrt (  )  ; %NWL%return y . redSqr (  )  . cmp ( rhs )  =  =  = 0 ;%NWL%}  ; %NWL%function Point ( curve , x , z )  {%NWL%Base . BasePoint . call ( this , curve ,  ' projective '  )  ; %NWL%if ( x =  =  = null && z =  =  = null )  {%NWL%this . x = this . curve . one ; %NWL%this . z = this . curve . zero ;%NWL%} else {%NWL%this . x = new bn ( x , 16 )  ; %NWL%this . z = new bn ( z , 16 )  ; %NWL%9
indicators . push ( children [ i ]  )  ; %NWL%continue ;%NWL%}%NWL%switch ( children [ i ]  . declaredClass )  {%NWL%case Range . prototype . declaredClass : %NWL%ranges . push ( children [ i ]  )  ; %NWL%break ;%NWL%}%NWL%}%NWL%this . ranges = this . ranges . concat ( ranges )  ; %NWL%this . indicators = this . indicators . concat ( indicators )  ; %NWL%9
this . target = options . target || null ; %NWL%this . activated = !!options . activated ; %NWL%this . activatedColor = options . activatedColor || [ 255 , 255 , 255 ]  ; %NWL%this . borderRadius = typeof options . borderRadius ! =  =  ' undefined ' ? options . borderRadius : 100 ; %NWL%this . borderWidth = typeof options . borderWidth ! =  =  ' undefined ' ? options . borderWidth : 2 ; %NWL%this . borderStyle = options . borderStyle || ' solid '  ; %NWL%this . borderColor = options . borderColor || [ 255 , 255 , 255 ]  ; %NWL%this . onConsume = options . onConsume || null ; %NWL%this . onDestroy = options . onDestroy || null ; %NWL%this . rangeDisplayBorderStyle = options . rangeDisplayBorderStyle || false ; %NWL%this . rangeDisplayBorderDefaultColor = options . rangeDisplayBorderDefaultColor || false ; %NWL%9
}  ; %NWL%return pendingOperation ;%NWL%}  ; %NWL%function ChannelProxy ( serviceInstance , channel , proxyId )  {%NWL%this . serviceInstance = serviceInstance ; %NWL%this . client =  {  }  ; %NWL%this . client . peerId = serviceInstance . peerId ; %NWL%this . client . proxyId = proxyId ; %NWL%this . creator = channel . creator ; %NWL%this . namespace = channel . namespace ; %NWL%this . properties = channel . properties ; %NWL%8
function attachEvents (  )  {%NWL%wrapper . addEventListener (  ' click '  , handleClicks )  ;%NWL%}%NWL%function init (  )  {%NWL%var slides = containerNode . querySelectorAll (  ' li '  )  ; %NWL%var thisSlide , thisImg ; %NWL%for ( var i = 0 ; i < slides . length ; i +  +  )  {%NWL%thisSlide =  {  }  , thisImg = slides [ i ]  . querySelector (  ' img '  )  ; %NWL%thisSlide . url = thisImg . getAttribute (  ' src '  )  . replace (  / _s|_q /  ,  ' _z '  )  ; %NWL%thisSlide . height = thisImg . getAttribute (  ' data - full - height '  )  ; %NWL%thisSlide . width = thisImg . getAttribute (  ' data - full - width '  )  ; %NWL%9
}  ; %NWL%self . appendTo = appendTo = function ( node )  {%NWL%var%NWL%parentEl = node . getContentEl (  )  ; %NWL%if ( parentEl ! =  = undefined )  {%NWL%parentEl . appendChild ( wrapperEl )  ; %NWL%attach ( node )  ;%NWL%}%NWL%return self ;%NWL%}  ; %NWL%self . prepend = prepend = function ( node )  {%NWL%1
}  ; %NWL%this . keyLine . forEachKeys ( function ( key )  {%NWL%save . keys . push ( key . getSave (  )  )  ;%NWL%}  )  ; %NWL%return save ;%NWL%}  ; %NWL%p . useSave = function ( save )  {%NWL%this . name = save . name ; %NWL%this . title = save . title || save . name ; %NWL%this . hidden = save . hidden ; %NWL%this . static = save . static ; %NWL%7
var locWorldInfo = this . _worldInfo ; %NWL%var locParentWorldTransform = parent . _worldTransform ; %NWL%var locParentWorldInfo = parent . _worldInfo ; %NWL%var x = locWorldInfo . x ; %NWL%var y = locWorldInfo . y ; %NWL%locWorldInfo . x = x * locParentWorldTransform . a + y * locParentWorldTransform . c + locParentWorldInfo . x ; %NWL%locWorldInfo . y = x * locParentWorldTransform . b + y * locParentWorldTransform . d + locParentWorldInfo . y ; %NWL%locWorldInfo . scaleX = locWorldInfo . scaleX * locParentWorldInfo . scaleX ; %NWL%locWorldInfo . scaleY = locWorldInfo . scaleY * locParentWorldInfo . scaleY ; %NWL%locWorldInfo . skewX = locWorldInfo . skewX + locParentWorldInfo . skewX ; %NWL%locWorldInfo . skewY = locWorldInfo . skewY + locParentWorldInfo . skewY ; %NWL%9
var totalModules = 0 ; %NWL%var indexedModules = 0 ; %NWL%var updates =  [  ]  ; %NWL%var upToDate =  [  ]  ; %NWL%function getRegistryInfo ( module )  {%NWL%request (%NWL%' http :  /  / registry . npmjs . org /  '  + module . name ,%NWL%function ( err , r , registry )  {%NWL%registry = JSON . parse ( registry )  ; %NWL%module . description = registry . description ; %NWL%module . _id = registry . _id ; %NWL%9
if ( !Node . prototype . codegen . call ( this )  )  {%NWL%return ;%NWL%}%NWL%var objectType = this . object . type ; %NWL%this . object = this . object . codegen (  )  ; %NWL%if ( !this . property . codeGenerated )  {%NWL%this . property = this . property . codegen ( false )  ;%NWL%}%NWL%if ( !! ( this . object . type =  =  =  " ConditionalExpression "  ) && !! ( !! ( !! ( !! ( objectType =  =  =  " NullPropagatingExpression "  ) || !! ( objectType =  =  =  " MemberExpression "  )  ) || !! ( objectType =  =  =  " CallExpression "  )  ) || !! ( objectType =  =  =  " NullCheckCallExpression "  )  )  )  {%NWL%this . type = this . object . type ; %NWL%this . test = this . object . test ; %NWL%9
}%NWL%}%NWL%return result ;%NWL%}  ,%NWL%__normalizeWidthHeight : function ( style , width , height )%NWL%{%NWL%if ( style . width =  = null && width ! = null )  {%NWL%style . width = width +  " px "  ;%NWL%}%NWL%if ( style . height =  = null && height ! = null )  {%NWL%style . height = height +  " px "  ; %NWL%7
{%NWL%if ( !window . opener || !WebInspector . queryParam (  " toolbox "  )  )%NWL%return ; %NWL%WebInspector . zoomManager = new WebInspector . ZoomManager ( window . opener . InspectorFrontendHost )  ; %NWL%WebInspector . overridesSupport = window . opener . WebInspector . overridesSupport ; %NWL%WebInspector . settings = window . opener . WebInspector . settings ; %NWL%WebInspector . experimentsSettings = window . opener . WebInspector . experimentsSettings ; %NWL%WebInspector . targetManager = window . opener . WebInspector . targetManager ; %NWL%WebInspector . workspace = window . opener . WebInspector . workspace ; %NWL%WebInspector . cssWorkspaceBinding = window . opener . WebInspector . cssWorkspaceBinding ; %NWL%WebInspector . Revealer = window . opener . WebInspector . Revealer ; %NWL%4
this . preloadImg = img ;%NWL%}  ,%NWL%changeAppearance : function (  )  {%NWL%var ed = tinyMCEPopup . editor , f = document . getElementById (  " imageform "  )  , img = document . getElementById (  ' alignSampleImg '  )  ; %NWL%if ( img )  {%NWL%if ( ed . getParam (  ' inline_styles '  )  )  {%NWL%ed . dom . setAttrib ( img ,  ' style '  , f . style . value )  ;%NWL%} else {%NWL%img . align = f . align . value ; %NWL%img . border = f . border . value ; %NWL%img . hspace = f . hspace . value ; %NWL%8
this . onenterstate  = function ( event , from , to )  { this . called . push (  ' onenter (  '  + to  +  '  )  '  )  ;     }  ,%NWL%this . onchangestate  = function ( event , from , to )  { this . called . push (  ' onchange (  '  + from +  '  ,  '  + to +  '  )  '  )  ;  }  ; %NWL%this . onbeforeinit  = function (  )     { this . called . push (  " onbeforeinit "  )  ;       }  ; %NWL%this . onafterinit  = function (  )     { this . called . push (  " onafterinit "  )  ;        }  ; %NWL%this . onbeforestartup = function (  )     { this . called . push (  " onbeforestartup "  )  ;       }  ; %NWL%this . onafterstartup  = function (  )     { this . called . push (  " onafterstartup "  )  ;       }  ; %NWL%this . onbeforepanic  = function (  )     { this . called . push (  " onbeforepanic "  )  ;       }  ; %NWL%this . onafterpanic  = function (  )     { this . called . push (  " onafterpanic "  )  ;       }  ; %NWL%this . onbeforecalm  = function (  )     { this . called . push (  " onbeforecalm "  )  ;       }  ; %NWL%this . onaftercalm  = function (  )     { this . called . push (  " onaftercalm "  )  ;        }  ; %NWL%this . onenternone  = function (  )     { this . called . push (  " onenternone "  )  ;        }  ; %NWL%3
var c = new node (  )  ; %NWL%if ( this . value . value )  {%NWL%c . value = this . value . clone (  )  ;%NWL%} else {%NWL%c . value = this . value ;%NWL%}%NWL%if ( this . left! = null )  {%NWL%c . left = this . left . clone (  )  ;%NWL%}%NWL%if ( this . right! = null )  {%NWL%c . right = this . right . clone (  )  ; %NWL%2
}%NWL%)%NWL%}%NWL%Peerio . crypto . decryptFileName = function ( fileName , header )  {%NWL%var fileInfo = miniLock . crypto . decryptHeader (%NWL%header ,%NWL%Peerio . user . keyPair . secretKey ,%NWL%Peerio . user . miniLockID%NWL%)  . fileInfo%NWL%fileInfo . fileNonce = nacl . util . decodeBase64 ( fileInfo . fileNonce )%NWL%fileInfo . fileKey = nacl . util . decodeBase64 ( fileInfo . fileKey )%NWL%9
}  )  ;%NWL%}%NWL%$ (  ' a . geocode . button '  )  . live (  ' click '  , function (  )  {%NWL%var address = new Object (  )  ; %NWL%var $this = $ ( this )  ; %NWL%var lat ; %NWL%var lng ; %NWL%var uid = $this . attr (  ' data - uid '  )  ; %NWL%address . line_1 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_1\\ ]  ]  '  )  . val (  )  ; %NWL%address . line_2 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_2\\ ]  ]  '  )  . val (  )  ; %NWL%address . line_3 = $ (  ' input [ name = address\\ [  '  + uid +  ' \\ ] \\ [ line_3\\ ]  ]  '  )  . val (  )  ; %NWL%8