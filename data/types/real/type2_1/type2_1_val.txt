var easydate = require (  ' easydate '  )  ; %NWL%var eachAsync = require (  ' each - async '  )  ; %NWL%var fsWriteStreamAtomic = require (  ' fs - write - stream - atomic '  )  ; %NWL%var getRes = require (  ' get - res '  )  ; %NWL%var logSymbols = require (  ' log - symbols '  )  ; %NWL%var memoizeAsync = require (  ' memoize - async '  )  ; %NWL%var mkdirp = require (  ' mkdirp '  )  ; %NWL%var rimraf = require (  ' rimraf '  )  ; %NWL%var screenshotStream = require (  ' screenshot - stream '  )  ; %NWL%var viewportList = require (  ' viewport - list '  )  ; %NWL%var protocolify = require (  ' protocolify '  )  ; %NWL%0
var util = require (  '  .  / util '  )  ; %NWL%var binarySearch = require (  '  .  / binary - search '  )  ; %NWL%var ArraySet = require (  '  .  / array - set '  )  . ArraySet ; %NWL%var base64VLQ = require (  '  .  / base64 - vlq '  )  ; %NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap ; %NWL%if ( typeof aSourceMap =  =  =  ' string '  )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace (  / ^\ ) \ ] \ }  '  /  ,  '  '  )  )  ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version '  )  ; %NWL%var sources = util . getArg ( sourceMap ,  ' sources '  )  ; %NWL%9
var canvasUtils =  {%NWL%appendImageToCanvas : function ( argObj )  {%NWL%var scale = argObj . scale || 1 . 0 ; %NWL%var zoom = argObj . zoom || 1 . 0 ; %NWL%var canvasData = argObj . canvasData ; %NWL%var imageSrc = argObj . imageSrc ; %NWL%var pageHeight = argObj . pageHeight * zoom ; %NWL%var imageHeight = argObj . imageHeight ; %NWL%var width = argObj . width ; %NWL%var top = argObj . top ; %NWL%var callback = argObj . callback ; %NWL%4
function updateSteps (  )  {%NWL%if ( updating ) return ; %NWL%updating = true ; %NWL%url_object . search = serialize ( pairs )  ; %NWL%updating = false ;%NWL%}%NWL%function serialize ( pairs )  {%NWL%var output =  '  '  , first = true ; %NWL%pairs . forEach ( function ( pair )  {%NWL%var name = encodeURIComponent ( pair . name )  ; %NWL%var value = encodeURIComponent ( pair . value )  ; %NWL%9
var div = dojo . doc . createElement (  " div "  )  ; %NWL%dojo . addClass ( icon ,  " dojoxLegendIcon "  )  ; %NWL%dojo . addClass ( text ,  " dojoxLegendText "  )  ; %NWL%div . style . width  = this . swatchSize +  " px "  ; %NWL%div . style . height = this . swatchSize +  " px "  ; %NWL%icon . appendChild ( div )  ; %NWL%if ( this . horizontal )  {%NWL%this . _tr . appendChild ( icon )  ; %NWL%this . _tr . appendChild ( text )  ;%NWL%} else {%NWL%var tr = dojo . doc . createElement (  " tr "  )  ; %NWL%0
var original = this . sourceMap . originalPositionFor (  {%NWL%source :  '  '  ,%NWL%line : line ,%NWL%column : column%NWL%}  )  ; %NWL%return [ original . line , original . column ]  ;%NWL%}  ; %NWL%VimView . prototype . generatedPosition = function ( line , column )  {%NWL%if ( !this . sourceMap )%NWL%return [ line , column ]  ; %NWL%var generated = this . sourceMap . generatedPositionFor (  {%NWL%0
list . forEach ( function ( item )  {%NWL%expect ( item )  . not . toBe ( addedItem )  ; %NWL%count +  +  ;%NWL%}  )  ; %NWL%expect ( count )  . toBe ( 0 )  ;%NWL%}  )  ; %NWL%it (  ' after added 3 items should contains them '  , function (  )  {%NWL%var list = new List (  )  ; %NWL%var e1 =  { name :  ' e1 '  }  ; %NWL%var e2 =  { name :  ' e2 '  }  ; %NWL%var e3 =  { name :  ' e3 '  }  ; %NWL%8
let operand = this . transformAny ( tree . operand )  ; %NWL%let memberExpression = this . transformAny ( tree . memberExpression )  ; %NWL%return this . createCommaExpressionBuilder (  )  . add ( operand )  .%NWL%add ( memberExpression )  .%NWL%build ( new MemberLookupExpression (%NWL%tree . location , getResult ( operand )  , getResult ( memberExpression )  )  )  ;%NWL%}%NWL%transformBinaryExpression ( tree )  {%NWL%if ( tree . operator . isAssignmentOperator (  )  )%NWL%return this . transformAssignmentExpression ( tree )  ; %NWL%let left = this . transformAny ( tree . left )  ; %NWL%0
!!result . success +  '  , status =  '  + result . status )  ; %NWL%return server . respond ( req , res , 200 ,  { success : !!result . success ,%NWL%status : result . status , match : result . match || null }  )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%exports . ingest = function ( req , res )  {%NWL%var code = req . body . code ; %NWL%var codeVer = req . body . version ; %NWL%var length = req . body . length ; %NWL%var track = req . body . track ; %NWL%7
dispatchListeners . length : %NWL%dispatchListeners ? 1 : 0 ; %NWL%invariant (%NWL%idsIsArr =  =  = listenersIsArr && IDsLen =  =  = listenersLen ,%NWL%' EventPluginUtils : Invalid `event` .  '%NWL%)  ;%NWL%}  ;%NWL%}%NWL%function forEachEventDispatch ( event , cb )  {%NWL%var dispatchListeners = event . _dispatchListeners ; %NWL%var dispatchIDs = event . _dispatchIDs ; %NWL%9
var fs = require (  ' fs '  )  ; %NWL%var projects = require (  '  .  .  / lib / projects '  )  ; %NWL%var screens = require (  '  .  .  / lib / screens '  )  ; %NWL%var components = require (  '  .  .  / lib / components '  )  ; %NWL%var elements = require (  '  .  .  / lib / elements '  )  ; %NWL%var users = require (  '  .  .  / lib / users '  )  ; %NWL%var utils = require (  '  .  .  / lib / utils '  )  ; %NWL%var exportProject = require (  '  .  .  / export '  )  ; %NWL%module . exports = function ( app , nconf , db )  {%NWL%var extractSharedEmail = utils . extractSharedEmail ( db )  ; %NWL%var confirmScaffoldExistence = utils . confirmScaffoldExistence ( db )  ; %NWL%9
var config = intern . config ; %NWL%var PAGE_URL = config . fxaContentRoot +  ' signup?context = fx_desktop_v1&service = sync '  ; %NWL%var SIGNIN_URL = config . fxaContentRoot +  ' signin '  ; %NWL%var AUTH_SERVER_ROOT = config . fxaAuthRoot ; %NWL%var TOO_YOUNG_YEAR = new Date (  )  . getFullYear (  )  - 13 ; %NWL%var OLD_ENOUGH_YEAR = TOO_YOUNG_YEAR - 1 ; %NWL%var client ; %NWL%var email ; %NWL%var PASSWORD =  ' 12345678 '  ; %NWL%var listenForFxaCommands = FxDesktopHelpers . listenForFxaCommands ; %NWL%var testIsBrowserNotifiedOfLogin = FxDesktopHelpers . testIsBrowserNotifiedOfLogin ; %NWL%9
}%NWL%}  ,%NWL%save : function (  )  {%NWL%return EditView . prototype . save . call ( this , this . presave (  )  )  ;%NWL%}  ,%NWL%presave : function (  )  {%NWL%var results = this . form . getValue (  )  ; %NWL%results . mapping = _ . map ( this . form . fields . mapping . editor . items , function ( itm )  {%NWL%var v = itm . getValue (  )  ; %NWL%var parsers = v . parser && v . parser . parsers ; %NWL%var type = v . parser && v . parser . type ; %NWL%9
return function compile ( req , res , next )  {%NWL%var compiler = req . body . compiler ; %NWL%var remote = compileObj . getRemote ( compiler )  ; %NWL%if ( remote )  {%NWL%proxy . web ( req , res ,  { target : remote }  , function ( e )  {%NWL%console . log (  " Proxy error :  "  , e )  ; %NWL%next ( e )  ;%NWL%}  )  ; %NWL%return ;%NWL%}%NWL%var source = req . body . source ; %NWL%1
return this . swappedColl ? sum : sum . neg (  )  ;%NWL%}  ; %NWL%Arbiter . prototype . totalKE = function (  )%NWL%{%NWL%var eCoef =  ( 1 - this . e )  /  ( 1 + this . e )  ; %NWL%var sum = 0 ; %NWL%var contacts = this . contacts ; %NWL%for ( var i = 0 , count = contacts . length ; i < count ; i +  +  )  {%NWL%var con = contacts [ i ]  ; %NWL%var jnAcc = con . jnAcc ; %NWL%var jtAcc = con . jtAcc ; %NWL%9
try {%NWL%if ( !doc . id )  {%NWL%var getId = getIdMap . get ( doc . docType )  ; %NWL%if ( !getId )  {%NWL%log . warn ( createDocMessage (  ' No idTemplate or getId ( doc ) method provided '  , doc )  )  ;%NWL%} else {%NWL%doc . id = getId ( doc )  ;%NWL%}%NWL%}%NWL%if ( !doc . aliases )  {%NWL%var getAliases = getAliasesMap . get ( doc . docType )  ; %NWL%2
return deferred . promise ;%NWL%}%NWL%exports . get = Method (  " get "  )  ; %NWL%exports . put = Method (  " put "  )  ; %NWL%exports . del = Method (  " del "  )  ; %NWL%var post = exports . post = Method (  " post "  )  ; %NWL%exports . invoke = function ( value , name )  {%NWL%var args = slice . call ( arguments , 2 )  ; %NWL%return post ( value , name , args )  ;%NWL%}  ; %NWL%var apply = exports . apply = Method (  " apply "  )  ; %NWL%5
var tok = this . expect (  ' each '  )%NWL%, node = new nodes . Each ( tok . code , tok . val , tok . key )  ; %NWL%node . line = this . line (  )  ; %NWL%node . block = this . block (  )  ; %NWL%return node ;%NWL%}  ,%NWL%parseExtends : function (  )  {%NWL%var path = require (  ' path '  )%NWL%, fs = require (  ' fs '  )%NWL%, dirname = path . dirname%NWL%, basename = path . basename%NWL%9
response = $ (  " #templates . repair - failure "  )  . clone (  )  ; %NWL%$ (  " #repair . result "  )  . empty (  )  . append ( response )  ; %NWL%$ (  " #repair . result "  )  . hide (  )  . slideDown (  )  ;%NWL%}  )  ; %NWL%exports . init = function init (  )  {%NWL%}  ;%NWL%}  ; %NWL%Require . modules [  " app / ui / find - user "  ]  = function ( exports , require )  {%NWL%var $ = require (  " jQuery "  )  ; %NWL%var bugzilla = require (  " bugzilla "  )  ; %NWL%var window = require (  " window "  )  ; %NWL%9
_callMethod ( message . id , object , object [ method ]  , params )  ;%NWL%} else {%NWL%_throwError ( message . id ,  " method not found "  )  ;%NWL%}%NWL%} else if (  " requestId " in message )  {%NWL%var request = _requestReferences [ message . requestId ]  ; %NWL%if ( request && method =  =  =  " cancel " && request . cancel )  {%NWL%request . cancel . apply ( request , params )  ;%NWL%}%NWL%} else if (  " responseId " in message )  {%NWL%var response = _responseReferences [ message . responseId ]  ; %NWL%5
options . error = function ( jqXHR , textStatus , errorThrown )  {%NWL%var errors = adapter . parseAjaxErrors ( jqXHR , textStatus , errorThrown )  ; %NWL%Ember . run ( null , reject , errors )  ;%NWL%}  ; %NWL%$ . ajax ( options )  ;%NWL%}  )  ;%NWL%}  ,%NWL%prepareParams : function ( params )  {%NWL%var serializer = this . serializer ; %NWL%var headers = this . get (  ' headers '  )  ; %NWL%var defaultData = this . get (  ' defaultData '  )  ; %NWL%9
var name =  ' name '  ; %NWL%var value =  ' value '  ; %NWL%URI . setHeader ( name , value )  ; %NWL%expect ( URI . headers )  . toEqual (  { Name :  [ value ]  }  )  ; %NWL%expect ( URI . getHeader ( name )  )  . toEqual (  [ value ]  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%describe (  "  . hasHeader "  , function (  )  {%NWL%it (  " returns true if the header exists "  , function (  )  {%NWL%expect ( URI . headers )  . toEqual (  {  }  )  ; %NWL%var name =  ' name '  ; %NWL%1
logutils . logger . error (  " In createJobAtInit (  )  : jobObj is null "  )  ; %NWL%return ;%NWL%}%NWL%var jobName = jobObj [  ' jobName '  ]  ; %NWL%if ( null =  = jobName )  {%NWL%logutils . logger . error (  " In createJobAtInit (  )  : jobName is null "  )  ; %NWL%assert ( 0 )  ;%NWL%}%NWL%var url = jobObj [  ' url '  ]  ; %NWL%var firstRunDelay = jobObj [  ' firstRunDelay '  ]  ; %NWL%var runCount = jobObj [  ' runCount '  ]  ; %NWL%3
cached = new data . constructor ( data )%NWL%cached . nodes = nodes%NWL%}%NWL%else cached . nodes . intact = true%NWL%}%NWL%return cached%NWL%}%NWL%function setAttributes ( node , tag , dataAttrs , cachedAttrs , namespace )  {%NWL%for ( var attrName in dataAttrs )  {%NWL%var dataAttr = dataAttrs [ attrName ]%NWL%var cachedAttr = cachedAttrs [ attrName ]%NWL%9
var MultiEntryPlugin = require (  "  .  / MultiEntryPlugin "  )  ; %NWL%var RecordIdsPlugin = require (  "  .  / RecordIdsPlugin "  )  ; %NWL%var APIPlugin = require (  "  .  / APIPlugin "  )  ; %NWL%var ConstPlugin = require (  "  .  / ConstPlugin "  )  ; %NWL%var RequireJsStuffPlugin = require (  "  .  / RequireJsStuffPlugin "  )  ; %NWL%var NodeStuffPlugin = require (  "  .  / NodeStuffPlugin "  )  ; %NWL%var CompatibilityPlugin = require (  "  .  / CompatibilityPlugin "  )  ; %NWL%var DefinePlugin = require (  "  .  / DefinePlugin "  )  ; %NWL%var MovedToPluginWarningPlugin = require (  "  .  / MovedToPluginWarningPlugin "  )  ; %NWL%var TemplatedPathPlugin = require (  "  .  / TemplatedPathPlugin "  )  ; %NWL%var WarnCaseSensitiveModulesPlugin = require (  "  .  / WarnCaseSensitiveModulesPlugin "  )  ; %NWL%0
if ( error ) return res . send ( 500 , err )%NWL%res . render (  ' project '  ,  {%NWL%supporting : result ,%NWL%project : project%NWL%}  )%NWL%}  )%NWL%}  )%NWL%}  )%NWL%app . get (  '  / projects /  : id / subscribe /  : type ( supporting|donating|contributing )  /  : state '  , ensureAuthenticated , function ( req , res )  {%NWL%var type = req . param (  ' type '  )%NWL%var id = req . param (  ' id '  )%NWL%9
var start = elem . getAttribute (  " marker - start "  )  ; %NWL%var mid = elem . getAttribute (  " marker - mid "  )  ; %NWL%var end = elem . getAttribute (  " marker - end "  )  ; %NWL%cur_line = elem ; %NWL%$ ( elem )%NWL%. data (  " start_off "  , !!start )%NWL%. data (  " end_off "  , !!end )  ; %NWL%if ( elem . tagName =  =  " line " && mid )  {%NWL%var x1 = elem . getAttribute (  ' x1 '  )  - 0 ; %NWL%var x2 = elem . getAttribute (  ' x2 '  )  - 0 ; %NWL%var y1 = elem . getAttribute (  ' y1 '  )  - 0 ; %NWL%8
callback : callback ,%NWL%errHandler : this . _handleError . bind ( this )  ,%NWL%rawEmitter : this . emit . bind ( this ,  ' raw '  )%NWL%}  )  ;%NWL%}%NWL%if ( watcher ) this . _watchers . push ( watcher )  ;%NWL%}  ; %NWL%NodeFsHandler . prototype . _handleFile =%NWL%function ( file , stats , initialAdd , target , callback )  {%NWL%var dirname = sysPath . dirname ( file )  ; %NWL%var basename = sysPath . basename ( file )  ; %NWL%9
}%NWL%if ( !$ . contains ( toAppend , word )  )%NWL%toAppend . push ( word )  ;%NWL%}  ; %NWL%var highlightstring =  ' ?highlight =  '  + $ . urlencode ( hlterms . join (  "  "  )  )  ; %NWL%var filenames = this . _index . filenames ; %NWL%var titles = this . _index . titles ; %NWL%var terms = this . _index . terms ; %NWL%var objects = this . _index . objects ; %NWL%var objtypes = this . _index . objtypes ; %NWL%var objnames = this . _index . objnames ; %NWL%5
return 1 ;%NWL%}%NWL%}%NWL%}  ,%NWL%outerHeight : function (  )  {%NWL%var ele = this [ 0 ]  ; %NWL%var cy = ele . _private . cy ; %NWL%var styleEnabled = cy . _private . styleEnabled ; %NWL%if ( ele && ele . _private . group =  =  =  ' nodes '  )  {%NWL%if ( styleEnabled )  {%NWL%var style = ele . _private . style ; %NWL%6
HashCollisionNode . prototype . iterate = function ( fn , reverse )  {%NWL%var entries = this . entries ; %NWL%for ( var ii = 0 , maxIndex = entries . length - 1 ; ii <  = maxIndex ; ii +  +  )  {%NWL%if ( fn ( entries [ reverse ? maxIndex - ii : ii ]  )  =  =  = false )  {%NWL%return false ;%NWL%}%NWL%}%NWL%}%NWL%BitmapIndexedNode . prototype . iterate =%NWL%HashArrayMapNode . prototype . iterate = function ( fn , reverse )  {%NWL%var nodes = this . nodes ; %NWL%1
var View = require (  '  .  / view '  )%NWL%var Backbone = require (  ' backbone '  )%NWL%var pad = require (  '  .  .  /  .  .  / strutils '  )  . pad%NWL%var log = require (  ' npmlog '  )%NWL%var Chars = require (  '  .  .  /  .  .  / chars '  )%NWL%var assert = require (  ' assert '  )%NWL%var Screen = require (  '  .  / screen '  )%NWL%var growl = require (  ' growl '  )%NWL%var constants = require (  '  .  / constants '  )%NWL%var TabWidth = constants . TabWidth%NWL%var TabStartLine = constants . TabStartLine%NWL%9
getSurface : function (  )  {%NWL%return this . _surface ;%NWL%}  ,%NWL%_surfaceSize : function (  )  {%NWL%var s = this . olLayer . map . getSize (  )  ; %NWL%this . _surface . setDimensions ( s . w , s . h )  ;%NWL%}  ,%NWL%moveTo : function ( event )  {%NWL%var s = dojo . style ( this . olLayer . map . layerContainerDiv )  ; %NWL%var left = parseInt ( s . left )  ; %NWL%var top = parseInt ( s . top )  ; %NWL%9
supr ( this ,  ' init '  , arguments )  ; %NWL%this . opts%NWL%. boolean (  ' no - template '  )%NWL%. describe (  ' no - template '  ,  ' copy no files other than manifest . json '  )%NWL%. describe (  ' local - template '  ,  ' path to local application template '  )%NWL%. describe (  ' git - template '  ,  ' path to git repository '  )%NWL%. describe (  ' skip - install '  ,  " don ' t autorun devkit install "  )  ;%NWL%}  ; %NWL%this . exec = function ( command , args , cb )  {%NWL%var fs = require (  ' fs '  )  ; %NWL%var ff = require (  ' ff '  )  ; %NWL%9
}%NWL%}%NWL%function AMDemodulator ( inRate , outRate , filterFreq , kernelLen )  {%NWL%var coefs = getLowPassFIRCoeffs ( inRate , filterFreq , kernelLen )  ; %NWL%var downsamplerI = new Downsampler ( inRate , outRate , coefs )  ; %NWL%var downsamplerQ = new Downsampler ( inRate , outRate , coefs )  ; %NWL%var sigRatio = inRate / outRate ; %NWL%var relSignalPower = 0 ; %NWL%function demodulateTuned ( samplesI , samplesQ )  {%NWL%var I = downsamplerI . downsample ( samplesI )  ; %NWL%var Q = downsamplerQ . downsample ( samplesQ )  ; %NWL%9
}  )  ; %NWL%var EndsWith = declare (  " dojox . grid . enhanced . plugins . filter . EndsWith "  , exprs . _BiOpExpr ,  {%NWL%_name :  " endsWith "  ,%NWL%_calculate : function ( left_operand , right_operand ,%NWL%datarow , getter )  {%NWL%var left_res = String ( left_operand . applyRow ( datarow , getter )  . getValue (  )  )  . toLowerCase (  )  ; %NWL%var right_res = String ( right_operand . applyRow ( datarow , getter )  . getValue (  )  )  . toLowerCase (  )  ; %NWL%return new exprs . BooleanExpr ( left_res . substring ( left_res . length - right_res . length )  =  = right_res )  ; 	 /  / _ConditionExpr%NWL%}%NWL%}  )  ; %NWL%var Matches = declare (  " dojox . grid . enhanced . plugins . filter . Matches "  , exprs . _BiOpExpr ,  {%NWL%1
}%NWL%setup (  )  ; %NWL%fs . mkdirSync ( tmp (  ' a '  )  , 0755 )  ; %NWL%fs . mkdirSync ( tmp (  ' a / b '  )  , 0755 )  ; %NWL%fs . symlinkSync (  '  .  .  '  , tmp (  ' a / d '  )  ,  ' dir '  )  ; %NWL%unlink . push ( tmp (  ' a / d '  )  )  ; %NWL%fs . symlinkSync (  '  .  .  '  , tmp (  ' a / b / e '  )  ,  ' dir '  )  ; %NWL%unlink . push ( tmp (  ' a / b / e '  )  )  ; %NWL%var abedabed = tmp (  ' abedabed '  . split (  '  '  )  . join (  '  /  '  )  )  ; %NWL%var abedabed_real = tmp (  '  '  )  ; %NWL%var abedabeda = tmp (  ' abedabeda '  . split (  '  '  )  . join (  '  /  '  )  )  ; %NWL%8
}  , next :  " start "  }  ,%NWL%{ defaultToken :  " comment "  }%NWL%]%NWL%}%NWL%}  ; %NWL%oop . inherits ( SassHighlightRules , ScssHighlightRules )  ; %NWL%exports . SassHighlightRules = SassHighlightRules ;%NWL%}  )  ; %NWL%ace . define (  ' ace / mode / scss_highlight_rules '  ,  [  ' require '  ,  ' exports '  ,  ' module '  ,  ' ace / lib / oop '  ,  ' ace / lib / lang '  ,  ' ace / mode / text_highlight_rules '  ]  , function ( require , exports , module )  {%NWL%var oop = require (  "  .  .  / lib / oop "  )  ; %NWL%var lang = require (  "  .  .  / lib / lang "  )  ; %NWL%9
if ( match [ 2 ] ! = null )  {%NWL%month = match [ 2 ]  - 1 ; %NWL%log (  ' sfDateToJsDate : month =  '  + month )  ;%NWL%}%NWL%if ( match [ 4 ] ! = null )  {%NWL%day = match [ 4 ]  ; %NWL%log (  ' sfDateToJsDate : day =  '  + day )  ;%NWL%}%NWL%if ( match [ 6 ] ! = null )  {%NWL%hour = match [ 6 ]  ; %NWL%log (  ' sfDateToJsDate : hour =  '  + hour )  ; %NWL%2
refreshOffset : function (  )  {%NWL%var offset = this . offset ; %NWL%this . setOffset ( offset . x , offset . y )  ;%NWL%}  ,%NWL%doRefresh : function (  )  {%NWL%this . refreshConstraint (  )  ; %NWL%this . getTranslatable (  )  . refresh (  )  ; %NWL%this . refreshOffset (  )  ;%NWL%}  ,%NWL%refresh : function (  )  {%NWL%var sizeMonitors = this . sizeMonitors ; %NWL%1
for ( j = 1 ; j < 6 ; j +  +  )  {%NWL%PE [ i ]  [ j ]  [ 0 ]  . css (  {  " opacity "  : 0 . 5 }  )  ; %NWL%PE [ i ]  [ j ]  [ 1 ]  . css (  {  " opacity "  : 0 . 5 }  )  ;%NWL%}%NWL%}%NWL%for ( var i = 0 ; i < 3 ; i +  +  )  {%NWL%for ( var j = 0 ; j < 4 ; j +  +  )%NWL%PE2 [ i ]  [ j ]  . css (  {  " opacity "  : 0 . 5 }  )  ;%NWL%}%NWL%for ( var i = 0 ; i < 3 ; i +  +  )  {%NWL%for ( var j = 0 ; j < 3 ; j +  +  )  {%NWL%5
var blogIndicesBySlug =  {  }  ; %NWL%var config = require (  " config3 "  )  ; %NWL%var connect = require (  " connect "  )  ; %NWL%var events = require (  " events "  )  ; %NWL%var fs = require (  " fs "  )  ; %NWL%var glob = require (  " glob "  )  ; %NWL%var httpErrors = require (  " httperrors "  )  ; %NWL%var log = require (  " bole "  )  ( __filename )  ; %NWL%var markdown = require (  " markdown - js "  )  . makeHtml ; %NWL%var middleware = require (  "  .  / middleware "  )  ; %NWL%var moment = require (  " moment "  )  ; %NWL%2
var input = document . createElement (  ' input '  )  ; %NWL%input . type =  ' text '  ; %NWL%input . id = this . id ; %NWL%input . name = this . options . field ; %NWL%input . value = value ; %NWL%input . setAttribute (  ' tabindex '  ,  " 0 "  )  ; %NWL%input . setAttribute (  ' style '  ,  ( this . options . style ? this . options . style :  ' width : 12em ;  '  )  )  ; %NWL%input . className = this . options . styleClass ; %NWL%parent . appendChild ( input )  ;%NWL%} else {%NWL%var div = document . createElement (  ' div '  )  ; %NWL%0
var now = new Date (  )  ; %NWL%return Math . ceil (  ( future . getFullYear (  )  - now . getFullYear (  )  )  * MONTHSINAYEAR + future . getMonth (  )  - now . getMonth (  )  )  ;%NWL%}  ,%NWL%daysBetween : function ( pastDate , futureDate )  {%NWL%var future = new Date ( futureDate )  ; %NWL%var past = new Date ( pastDate )  ; %NWL%return Math . abs ( Math . ceil (  ( future . getTime (  )  - past . getTime (  )  )  / ONEDAYMS )  )  ;%NWL%}  ,%NWL%monthsBetween : function ( pastDate , futureDate )  {%NWL%var future = new Date ( futureDate )  ; %NWL%var past = new Date ( pastDate )  ; %NWL%4
return numColumns ;%NWL%}  ; %NWL%TableEditor . GET_COLSPAN_PROP = function ( cell )  {%NWL%var colspan = jQuery ( cell )  . attr (  ' colspan '  )  ; %NWL%if ( typeof colspan =  =  =  ' undefined '  )  {%NWL%colspan = 1 ;%NWL%}%NWL%return parseInt ( colspan , 10 )  ;%NWL%}  ; %NWL%TableEditor . GET_ROWSPAN_PROP = function ( cell )  {%NWL%var rowspan = jQuery ( cell )  . attr (  ' rowspan '  )  ; %NWL%3
var sourceMap = aSourceMap ; %NWL%if ( typeof aSourceMap =  =  =  ' string '  )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace (  / ^\ ) \ ] \ }  '  /  ,  '  '  )  )  ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version '  )  ; %NWL%var sources = util . getArg ( sourceMap ,  ' sources '  )  ; %NWL%var names = util . getArg ( sourceMap ,  ' names '  ,  [  ]  )  ; %NWL%var sourceRoot = util . getArg ( sourceMap ,  ' sourceRoot '  , null )  ; %NWL%var sourcesContent = util . getArg ( sourceMap ,  ' sourcesContent '  , null )  ; %NWL%var mappings = util . getArg ( sourceMap ,  ' mappings '  )  ; %NWL%var file = util . getArg ( sourceMap ,  ' file '  , null )  ; %NWL%7
main . consumes =  [%NWL%" Plugin "  ,  " c9 "  ,  " menus "  ,  " commands "  ,  " clipboard . provider "  ,  " ui "  ,%NWL%" dialog . alert "  ,  " settings "%NWL%]  ; %NWL%main . provides =  [  " clipboard "  ]  ; %NWL%return main ; %NWL%function main ( options , imports , register )  {%NWL%var c9 = imports . c9 ; %NWL%var ui = imports . ui ; %NWL%var Plugin = imports . Plugin ; %NWL%var menus = imports . menus ; %NWL%7
SimplePerfTimers . prototype . toggleUnit = function (  )  {%NWL%this . persistance . Unit = this . persistance . Unit =  =  =  ' Imperial ' ? ' Metric '  :  ' Imperial '  ; %NWL%HookManager . trigger (  ' Message '  ,  { msg :  ' Switched SimplePerfTimers to '  + this . persistance . Unit +  " speed "  , ttl : 2 }  )  ; %NWL%this . save (  )  ;%NWL%}  ; %NWL%function appendToTable ( data )  {%NWL%$ (  ' #resultstable tr : first '  )  . before (  '  < tr style =  " text - align : right ;  "  >  < td style =  " text - align : center ;  "  >  '  + data [ 0 ]  +  '  <  / td >  < td >  '  + data [ 1 ]  +  '  <  / td >  < td >  '  + data [ 2 ]  +  '  <  / td >  < td >  '  + data [ 3 ]  +  '  <  / td >  < td >  '  + data [ 4 ]  +  '  <  / td >  <  / tr >  '  )  ;%NWL%}%NWL%SimplePerfTimers . prototype . update = function ( streams )  {%NWL%var throttle = streams . electrics . throttle . toFixed ( 2 )  ; %NWL%var brake  = streams . electrics . brake . toFixed ( 2 )  ; %NWL%9
var gitParser = require (  '  .  / git - parser '  )  ; %NWL%var winston = require (  ' winston '  )  ; %NWL%var usageStatistics = require (  '  .  / usage - statistics '  )  ; %NWL%var os = require (  ' os '  )  ; %NWL%var mkdirp = require (  ' mkdirp '  )  ; %NWL%var fileType = require (  '  .  / utils / file - type . js '  )  ; %NWL%var rimraf = require (  ' rimraf '  )  ; %NWL%exports . pathPrefix =  '  '  ; %NWL%exports . registerApi = function ( env )  {%NWL%var app = env . app ; %NWL%var server = env . server ; %NWL%9
InjectPromise = $__export (  " InjectPromise "  ,  ( function (  )  {%NWL%var InjectPromise = function InjectPromise ( token )  {%NWL%this . token = token ;%NWL%}  ; %NWL%return ( $traceurRuntime . createClass )  ( InjectPromise ,  {  }  ,  {  }  )  ;%NWL%}  (  )  )  )  ; %NWL%Object . defineProperty ( InjectPromise ,  " annotations "  ,  { get : function (  )  {%NWL%return [ new CONST (  )  ]  ;%NWL%}  }  )  ; %NWL%InjectLazy = $__export (  " InjectLazy "  ,  ( function (  )  {%NWL%var InjectLazy = function InjectLazy ( token )  {%NWL%1
}  ; %NWL%jfxr . Synth . HighPass . prototype . run = function ( sound , array , startSample , endSample )  {%NWL%var numSamples = array . length ; %NWL%var sampleRate = sound . sampleRate . value ; %NWL%var highPassCutoff = sound . highPassCutoff . value ; %NWL%var highPassCutoffSweep = sound . highPassCutoffSweep . value ; %NWL%if ( highPassCutoff <  = 0 && highPassCutoff + highPassCutoffSweep <  = 0 )  {%NWL%return ;%NWL%}%NWL%var highPassPrevIn = this . highPassPrevIn ; %NWL%var highPassPrevOut = this . highPassPrevOut ; %NWL%9
}%NWL%object . __defineGetter__ ( oldName , getter )  ;%NWL%}%NWL%function extractCallbackArgument ( args )%NWL%{%NWL%var lastArgument = args [ args . length - 1 ]  ; %NWL%return typeof lastArgument =  =  =  " function " ? lastArgument : undefined ;%NWL%}%NWL%var AuditCategory = declareInterfaceClass ( AuditCategoryImpl )  ; %NWL%var AuditResult = declareInterfaceClass ( AuditResultImpl )  ; %NWL%var Button = declareInterfaceClass ( ButtonImpl )  ; %NWL%8
TokenAssert . prototype . whitespaceBetween = function ( options )  {%NWL%options . atLeast = 1 ; %NWL%this . spacesBetween ( options )  ;%NWL%}  ; %NWL%TokenAssert . prototype . noWhitespaceBetween = function ( options )  {%NWL%options . exactly = 0 ; %NWL%this . spacesBetween ( options )  ;%NWL%}  ; %NWL%TokenAssert . prototype . spacesBetween = function ( options )  {%NWL%var token = options . token ; %NWL%var nextToken = options . nextToken ; %NWL%9
var lazypipe = require (  ' lazypipe '  )  ; %NWL%var path = require (  ' path '  )  ; %NWL%var pkg = require (  '  .  / package . json '  )  ; %NWL%var series = require (  ' stream - series '  )  ; %NWL%var through2 = require (  ' through2 '  )  ; %NWL%var autoprefixer = require (  ' gulp - autoprefixer '  )  ; %NWL%var concat = require (  ' gulp - concat '  )  ; %NWL%var filter = require (  ' gulp - filter '  )  ; %NWL%var gulpif = require (  ' gulp - if '  )  ; %NWL%var gutil = require (  ' gulp - util '  )  ; %NWL%var insert = require (  ' gulp - insert '  )  ; %NWL%5
if ( keepPosModals )%NWL%keepPosModals (  )  ;%NWL%}%NWL%function layContent ( header , body )  {%NWL%var curTab = $ (  "  . contentTab : visible "  )  ; %NWL%document . getElementsByTagName (  " body "  )  [ 0 ]  . style [  ' display '  ]  =  ' none '  ; %NWL%var curItem = curTab . attr (  " data - item "  )  ; %NWL%if ( curTab . hasClass (  " tab - conv "  )  )  {%NWL%var listItem = appcore . list [ appcore . listHash [ currentTab ]  ]  ; %NWL%var convHeader = curTab . find (  " #convHeader "  )  ; %NWL%var convFooter = curTab . find (  " #convFooter "  )  ; %NWL%9
}  )  ;%NWL%}  )  ; %NWL%describe (  ' transactionType (  )  '  , function (  )  {%NWL%it (  " should return a random transaction type "  , function (  )  {%NWL%var transactionType = faker . finance . transactionType (  )  ; %NWL%assert . ok ( transactionType )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%describe (  " currencyCode (  )  "  , function (  )  {%NWL%it (  " returns a random currency code with a format "  , function (  )  {%NWL%var currencyCode = faker . finance . currencyCode (  )  ; %NWL%4
this . _workerName =  ' createRectangleGeometry '  ;%NWL%}  ; %NWL%var textureMatrixScratch = new Matrix2 (  )  ; %NWL%var tangentRotationMatrixScratch = new Matrix3 (  )  ; %NWL%var nwScratch = new Cartographic (  )  ; %NWL%var quaternionScratch = new Quaternion (  )  ; %NWL%var centerScratch = new Cartographic (  )  ; %NWL%RectangleGeometry . createGeometry = function ( rectangleGeometry )  {%NWL%var rectangle = Rectangle . clone ( rectangleGeometry . _rectangle , rectangleScratch )  ; %NWL%var ellipsoid = rectangleGeometry . _ellipsoid ; %NWL%var surfaceHeight = rectangleGeometry . _surfaceHeight ; %NWL%9
( function ( define )  {  ' use strict '  ; %NWL%define ( function ( require )  {%NWL%var timed = require (  '  .  / lib / decorators / timed '  )  ; %NWL%var array = require (  '  .  / lib / decorators / array '  )  ; %NWL%var flow = require (  '  .  / lib / decorators / flow '  )  ; %NWL%var fold = require (  '  .  / lib / decorators / fold '  )  ; %NWL%var inspect = require (  '  .  / lib / decorators / inspect '  )  ; %NWL%var generate = require (  '  .  / lib / decorators / iterate '  )  ; %NWL%var progress = require (  '  .  / lib / decorators / progress '  )  ; %NWL%var withThis = require (  '  .  / lib / decorators / with '  )  ; %NWL%var unhandledRejection = require (  '  .  / lib / decorators / unhandledRejection '  )  ; %NWL%2
var ConstPlugin = require (  "  .  / ConstPlugin "  )  ; %NWL%var RequireJsStuffPlugin = require (  "  .  / RequireJsStuffPlugin "  )  ; %NWL%var NodeStuffPlugin = require (  "  .  / NodeStuffPlugin "  )  ; %NWL%var CompatibilityPlugin = require (  "  .  / CompatibilityPlugin "  )  ; %NWL%var DefinePlugin = require (  "  .  / DefinePlugin "  )  ; %NWL%var MovedToPluginWarningPlugin = require (  "  .  / MovedToPluginWarningPlugin "  )  ; %NWL%var TemplatedPathPlugin = require (  "  .  / TemplatedPathPlugin "  )  ; %NWL%var WarnCaseSensitiveModulesPlugin = require (  "  .  / WarnCaseSensitiveModulesPlugin "  )  ; %NWL%var LoaderPlugin = require (  "  .  / dependencies / LoaderPlugin "  )  ; %NWL%var CommonJsPlugin = require (  "  .  / dependencies / CommonJsPlugin "  )  ; %NWL%var AMDPlugin = require (  "  .  / dependencies / AMDPlugin "  )  ; %NWL%8
if ( typeof define =  =  =  ' function ' && define . amd && typeof __fbBatchedBridgeConfig =  =  =  ' undefined '  )  {%NWL%define (  [  ' tcomb '  ]  , factory )  ;%NWL%} else if ( typeof exports =  =  =  ' object '  )  {%NWL%module . exports = factory ( require (  ' tcomb '  )  )  ;%NWL%} else {%NWL%root . t = factory ( root . t )  ;%NWL%}%NWL%}  ( this , function ( t )  {%NWL%' use strict '  ; %NWL%var Any = t . Any ; %NWL%var Obj = t . Obj ; %NWL%9
var changedNode = e . target ; %NWL%var addedNodes , removedNodes ; %NWL%if ( e . type =  =  =  ' DOMNodeInserted '  )  {%NWL%addedNodes =  [ changedNode ]  ; %NWL%removedNodes =  [  ]  ;%NWL%} else {%NWL%addedNodes =  [  ]  ; %NWL%removedNodes =  [ changedNode ]  ;%NWL%}%NWL%var previousSibling = changedNode . previousSibling ; %NWL%var nextSibling = changedNode . nextSibling ; %NWL%9
return i ;%NWL%}%NWL%}%NWL%return - 1 ;%NWL%}%NWL%}  ; %NWL%function indicesToReferences ( model )  {%NWL%var i ; %NWL%var vertices = model . vertices ; %NWL%var skins = model . skins ; %NWL%var meshes = model . meshes ; %NWL%8
}%NWL%return "  "  ;%NWL%}  ;%NWL%}  )  . call ( MatchingBraceOutdent . prototype )  ; %NWL%exports . MatchingBraceOutdent = MatchingBraceOutdent ;%NWL%}  )  ; %NWL%ace . define (  ' ace / mode / behaviour / cstyle '  ,  [  ' require '  ,  ' exports '  ,  ' module '  ,  ' ace / lib / oop '  ,  ' ace / mode / behaviour '  ,  ' ace / token_iterator '  ,  ' ace / lib / lang '  ]  , function ( require , exports , module )  {%NWL%var oop = require (  "  .  .  /  .  .  / lib / oop "  )  ; %NWL%var Behaviour = require (  "  .  .  / behaviour "  )  . Behaviour ; %NWL%var TokenIterator = require (  "  .  .  /  .  .  / token_iterator "  )  . TokenIterator ; %NWL%var lang = require (  "  .  .  /  .  .  / lib / lang "  )  ; %NWL%7
index  =  ( Math . floor ( x )  + Math . floor ( y )  * Altitude . width )  * 5 ; %NWL%x  % = 1 . 0 ; %NWL%y  % = 1 . 0 ; %NWL%x1  = _cells [ index + 0 ]  +  ( _cells [ index + 1 ]  - _cells [ index + 0 ]  )  * x ; %NWL%x2  = _cells [ index + 2 ]  +  ( _cells [ index + 3 ]  - _cells [ index + 2 ]  )  * x ; %NWL%return -  ( x1 +  ( x2 - x1 )  * y )  ;%NWL%}  ; %NWL%Altitude . intersect = function intersectClosure (  )%NWL%{%NWL%var mat4  = glMatrix . mat4 ; %NWL%var vec3  = glMatrix . vec3 ; %NWL%9
if ( members . globals . length )  { generate (  ' Global '  , members . globals ,  ' global '  + helper . fileExtension )  ;  }%NWL%var files = find (  { kind :  ' file '  }  )  ,%NWL%packages = find (  { kind :  ' package '  }  )  ; %NWL%generate (  ' Index '  ,%NWL%packages . concat (%NWL%[  { kind :  ' mainpage '  , readme : opts . readme , longname :  ( opts . mainpagetitle ) ? opts . mainpagetitle :  ' Main Page '  }  ]%NWL%)  . concat ( files )  ,%NWL%' index '  + helper . fileExtension )  ; %NWL%var classes = taffy ( members . classes )  ; %NWL%var modules = taffy ( members . modules )  ; %NWL%var namespaces = taffy ( members . namespaces )  ; %NWL%8
executeAtStart : true ,%NWL%myFunction : function (  )  {  }%NWL%}  ; %NWL%var uhello = window . uhello =  {%NWL%name :  " uhello "  ,%NWL%type :  " HelloUnmanaged "  ,%NWL%htmlObject :  ' uhello '  ,%NWL%executeAtStart : true ,%NWL%myFunction : function (  )  {  }%NWL%}  ; %NWL%var mquery = window . mquery =  {%NWL%3
var celltype = tdElm . nodeName . toLowerCase (  )  ; %NWL%var align = ed . dom . getAttrib ( tdElm ,  ' align '  )  ; %NWL%var valign = ed . dom . getAttrib ( tdElm ,  ' valign '  )  ; %NWL%var width = trimSize ( getStyle ( tdElm ,  ' width '  ,  ' width '  )  )  ; %NWL%var height = trimSize ( getStyle ( tdElm ,  ' height '  ,  ' height '  )  )  ; %NWL%var bordercolor = convertRGBToHex ( getStyle ( tdElm ,  ' bordercolor '  ,  ' borderLeftColor '  )  )  ; %NWL%var bgcolor = convertRGBToHex ( getStyle ( tdElm ,  ' bgcolor '  ,  ' backgroundColor '  )  )  ; %NWL%var className = ed . dom . getAttrib ( tdElm ,  ' class '  )  ; %NWL%var backgroundimage = getStyle ( tdElm ,  ' background '  ,  ' backgroundImage '  )  . replace ( new RegExp (  " url\\ (  [  ' \ "  ] ? (  [ ^ ' \ "  ]  *  )  [  ' \ "  ] ?\\ )  "  ,  ' gi '  )  ,  " $1 "  )  ; %NWL%var id = ed . dom . getAttrib ( tdElm ,  ' id '  )  ; %NWL%var lang = ed . dom . getAttrib ( tdElm ,  ' lang '  )  ; %NWL%1
. argv ; %NWL%exports . run = function (  )  {%NWL%if ( argv . version )  {%NWL%return console . log (  " Sweet . js version :  "  + pkg . version )  ;%NWL%}%NWL%var infile = argv . _ [ 0 ]  ; %NWL%var outfile = argv . output ; %NWL%var watch = argv . watch ; %NWL%var tokens = argv . tokens ; %NWL%var ast = argv . ast ; %NWL%var sourcemap = argv . sourcemap ; %NWL%7
this . render_options . cp2 = 14 ; %NWL%this . render_options . y_shift = 0 . 5 ; %NWL%this . setFont (  { font :  " Times "  , size : 10 , style :  " bold italic "  }  )  ; %NWL%this . setNotes ( notes )  ;%NWL%}  ,%NWL%renderTie : function ( params )  {%NWL%if ( params . first_ys . length =  =  = 0 || params . last_ys . length =  =  = 0 )%NWL%throw new Vex . RERR (  " BadArguments "  ,  " No Y - values to render "  )  ; %NWL%var ctx = this . context ; %NWL%var first_x_px = params . first_x_px ; %NWL%var first_ys = params . first_ys ; %NWL%9
]  ;%NWL%}%NWL%function interpolationList ( start , end )  {%NWL%var list =  {%NWL%start :  [  ]  ,%NWL%end :  [  ]%NWL%}  ,%NWL%i =  - 1 , l ,%NWL%currStart , currEnd , currType ;%NWL%( start =  =  " none " || isAffine ( start )  ) && ( start =  "  "  )  ;%NWL%( end =  =  " none " || isAffine ( end )  ) && ( end =  "  "  )  ; %NWL%9
}  ,%NWL%visitLiteralArray : function ( ast )  {%NWL%var primitiveName =  (  " arrayFn "  + ast . expressions . length )  ; %NWL%return this . _addRecord ( RECORD_TYPE_PRIMITIVE_OP , primitiveName , _arrayFn ( ast . expressions . length )  , this . _visitAll ( ast . expressions )  , null , 0 )  ;%NWL%}  ,%NWL%visitLiteralMap : function ( ast )  {%NWL%return this . _addRecord ( RECORD_TYPE_PRIMITIVE_OP , _mapPrimitiveName ( ast . keys )  , ChangeDetectionUtil . mapFn ( ast . keys )  , this . _visitAll ( ast . values )  , null , 0 )  ;%NWL%}  ,%NWL%visitBinary : function ( ast )  {%NWL%var left = ast . left . visit ( this )  ; %NWL%var right = ast . right . visit ( this )  ; %NWL%9
}  ,%NWL%_loadComponents : function (  )  {%NWL%var value , minValue , maxValue ; %NWL%var startAngle = this . options . rotation ; %NWL%var maxDegrees = this . options . maxDegrees || 360 . 0 ; %NWL%var bar ; %NWL%var options = this . options ; %NWL%var radiusX = this . options . radiusX || this . options . radius ; %NWL%var radiusY = this . options . radiusY || this . options . radius ; %NWL%var data = this . options . data ; %NWL%var chartOptions = this . options . chartOptions ; %NWL%9
collapsible : false%NWL%}  )%NWL%}  )  ,%NWL%view : view%NWL%}  )  ; %NWL%var visible = new ol . dom . Input ( document . getElementById (  ' visible '  )  )  ; %NWL%visible . bindTo (  ' checked '  , layer ,  ' visible '  )  ; %NWL%var opacity = new ol . dom . Input ( document . getElementById (  ' opacity '  )  )  ; %NWL%opacity . bindTo (  ' value '  , layer ,  ' opacity '  )%NWL%. transform ( parseFloat , String )  ; %NWL%var hue = new ol . dom . Input ( document . getElementById (  ' hue '  )  )  ; %NWL%5
goog . require (  ' andrzejdus . utils . Looper '  )  ; %NWL%goog . require (  ' andrzejdus . utils . Utils '  )  ; %NWL%goog . require (  ' andrzejdus . utils . events . EventsManager '  )  ; %NWL%var andrzejdus = andrzejdus || {  }  ; %NWL%andrzejdus . parallaxer = andrzejdus . parallaxer || {  }  ;%NWL%( function ( namespace , undefined )  {%NWL%" use strict "  ; %NWL%var ParallaxerCore = function ( initialScrollPosition )  {%NWL%var ParallaxerCoreEvent = andrzejdus . parallaxer . ParallaxerCoreEvent ; %NWL%var Drawer = andrzejdus . parallaxer . Drawer ; %NWL%var DrawerObject = andrzejdus . parallaxer . DrawerObject ; %NWL%8
var cookieParser = require (  ' cookie - parser '  )  ; %NWL%var express = require (  ' express '  )  ; %NWL%var expressSession = require (  ' express - session '  )  ; %NWL%var fs = require (  ' fs - extra '  )  ; %NWL%var http = require (  ' http '  )  ; %NWL%var https = require (  ' https '  )  ; %NWL%var logger = require (  '  .  / logger . js '  )  ; %NWL%var socketio = require (  ' socket . io '  )  ; %NWL%var async = require (  '  .  / async . js '  )%NWL%var irc = require (  '  .  / irc . js '  )  ; %NWL%var users = require (  '  .  / users . js '  )  ; %NWL%6
nodeName +  =  ' _text '  ;%NWL%} else {%NWL%nodeName +  =  ' _ '  + element . getAttribute (  ' type '  )  . toLowerCase (  )  ;%NWL%}%NWL%if (  ( nodeName =  =  =  ' input_submit '  ) || ( nodeName =  =  =  ' input_reset '  )  )  {%NWL%nodeName =  ' input_button '  ;%NWL%}%NWL%var msgSubCode =  ' Input '  + nodeName . substr ( 6 , 1 )  . toUpperCase (  )  + nodeName . substr ( 7 )  . toLowerCase (  )  ;%NWL%}  /  / end if%NWL%var requiredName  = requiredNames [ nodeName ]  ; %NWL%var requiredValue = requiredValues [ nodeName ]  ; %NWL%9
exports . makeGTFS = function ( data , outputFolder )  {%NWL%var convertTime = function ( time )  {%NWL%return Math . floor ( time / 60 )  +  "  :  "  +  (  ( time%60 > 9 ) ? time%60 :  " 0 "  + time%60 )  +  "  : 00 "  ;%NWL%}  ; %NWL%var getProperty = function ( code )  {%NWL%return code +  '  '  + propertyDescription [ code ]  . text ;%NWL%}  ; %NWL%var trainsHeader = data . trainsHeader ; %NWL%var trains = data . trains ; %NWL%var stations = data . stations ; %NWL%var trainRoutes = data . trainRoutes ; %NWL%7
if ( loader ! =  = null )  {%NWL%texture = loader . load ( fullPath )  ;%NWL%} else {%NWL%texture = new THREE . Texture (  )  ; %NWL%loader = scope . imageLoader ; %NWL%loader . crossOrigin = scope . crossOrigin ; %NWL%loader . load ( fullPath , function ( image )  {%NWL%if ( THREE . Math . isPowerOfTwo ( image . width )  =  =  = false ||%NWL%THREE . Math . isPowerOfTwo ( image . height )  =  =  = false )  {%NWL%var width = nearest_pow2 ( image . width )  ; %NWL%var height = nearest_pow2 ( image . height )  ; %NWL%9
var ReactDOMImg = require (  "  .  / ReactDOMImg "  )  ; %NWL%var ReactDOMInput = require (  "  .  / ReactDOMInput "  )  ; %NWL%var ReactDOMOption = require (  "  .  / ReactDOMOption "  )  ; %NWL%var ReactDOMSelect = require (  "  .  / ReactDOMSelect "  )  ; %NWL%var ReactDOMTextarea = require (  "  .  / ReactDOMTextarea "  )  ; %NWL%var ReactInstanceHandles = require (  "  .  / ReactInstanceHandles "  )  ; %NWL%var ReactMount = require (  "  .  / ReactMount "  )  ; %NWL%var SelectEventPlugin = require (  "  .  / SelectEventPlugin "  )  ; %NWL%var ServerReactRootIndex = require (  "  .  / ServerReactRootIndex "  )  ; %NWL%var SimpleEventPlugin = require (  "  .  / SimpleEventPlugin "  )  ; %NWL%var ReactDefaultBatchingStrategy = require (  "  .  / ReactDefaultBatchingStrategy "  )  ; %NWL%0
if ( !val )  {%NWL%return ' Name is invalid '  ;%NWL%}%NWL%}%NWL%}%NWL%}  )  ; %NWL%var Collection = Backbone . Collection . extend (  {%NWL%model : this . Model%NWL%}  )  ; %NWL%this . collection = new Collection (  [  { name :  ' Tom '  }  ,  { name :  ' Thea '  }  ]  )  ; %NWL%var View = Backbone . View . extend (  {%NWL%6
if ( edge . edge . type . endsWith (  " Relation "  )  )  {%NWL%if ( edge . edge . informationflow . toLowerCase (  )  =  =  " true "  )  {%NWL%shape = this . createElement (  " Association_Unidirectional "  , edge . edge )  ;%NWL%} else {%NWL%shape = this . createElement (  " Association_Undirected "  , edge . edge )  ;%NWL%}%NWL%} else {%NWL%shape = this . createElement (  " SequenceFlow "  , edge . edge )  ;%NWL%}%NWL%var from 	 = edge . from . shape ; %NWL%var to 		 = edge . to . shape ; %NWL%9
var atomStore = dojox . data . tests . stores . AtomReadStore . getBlog1Store (  )  ; %NWL%var d = new doh . Deferred (  )  ; %NWL%function completedAll ( items )  {%NWL%t . is ( 1 , items . length )  ; %NWL%var summary = atomStore . getValues ( items [ 0 ]  ,  " summary "  )  ; %NWL%t . assertTrue ( dojo . isArray ( summary )  )  ; %NWL%var content = atomStore . getValues ( items [ 0 ]  ,  " content "  )  ; %NWL%t . assertTrue ( dojo . isArray ( content )  )  ; %NWL%var published = atomStore . getValues ( items [ 0 ]  ,  " published "  )  ; %NWL%t . assertTrue ( dojo . isArray ( published )  )  ; %NWL%var updated = atomStore . getValues ( items [ 0 ]  ,  " updated "  )  ; %NWL%4
var LRU = require (  ' lru - cache '  )  ; %NWL%var Negotiator = require (  ' negotiator '  )  ; %NWL%var semver = require (  ' semver '  )  ; %NWL%var cors = require (  '  .  / plugins / cors '  )  ; %NWL%var errors = require (  '  .  / errors '  )  ; %NWL%var utils = require (  '  .  / utils '  )  ; %NWL%var DEF_CT =  ' application / octet - stream '  ; %NWL%var maxSatisfying = semver . maxSatisfying ; %NWL%var BadRequestError = errors . BadRequestError ; %NWL%var InternalError = errors . InternalError ; %NWL%var InvalidArgumentError = errors . InvalidArgumentError ; %NWL%8
var webSocketFunctions = require (  "  .  .  / utils / webSocketFunctions "  )  ; %NWL%var webSocketEncoding = require (  "  .  .  / utils / webSocketEncoding "  )  ; %NWL%var listenerFunctions = require (  '  .  .  / utils / listenerFunctions '  )  ; %NWL%var PlayerLayout = require (  "  .  / data / PlayerLayout "  )  ; %NWL%var MuseumUser = require (  "  .  / user / MuseumUser "  )  ; %NWL%var MuseumClient = require (  "  .  / user / MuseumClient "  )  ; %NWL%var MessageEncoder = require (  "  .  / utils / MessageEncoder "  )  ; %NWL%var MessageIds = require (  "  .  / constants / MessageIds "  )  ; %NWL%var HttpGetRequest = require (  "  .  .  / utils / loading / HttpGetRequest "  )  ; %NWL%var HttpPostRequest = require (  "  .  .  / utils / loading / HttpPostRequest "  )  ; %NWL%var WebSocketRequest = require (  "  .  .  / utils / loading / WebSocketRequest "  )  ; %NWL%8
var trainsHeader = data . trainsHeader ; %NWL%var trains = data . trains ; %NWL%var stations = data . stations ; %NWL%var trainRoutes = data . trainRoutes ; %NWL%var trainTypes = data . trainTypes ; %NWL%var specialLines = data . specialLines ; %NWL%var trainAttributesTrainNumbers = data . trainAttributesTrainNumbers ; %NWL%var trainAttributesProperties = data . trainAttributesProperties ; %NWL%var trainAttributesDaysValid = data . trainAttributesDaysValid ; %NWL%var trainAttributesBorderCrossings = data . trainAttributesBorderCrossings ; %NWL%var trainOperatorsList1 = data . trainOperatorsList1 ; %NWL%0
var fs = require (  ' fs '  )%NWL%, http = require (  ' http '  )%NWL%, path = require (  ' path '  )%NWL%, connect = require (  ' connect '  )%NWL%, utils = connect . utils%NWL%, normalizeType = require (  '  .  / utils '  )  . normalizeType%NWL%, normalizeTypes = require (  '  .  / utils '  )  . normalizeTypes%NWL%, statusCodes = http . STATUS_CODES%NWL%, send = connect . static . send%NWL%, crc = require (  ' crc '  )%NWL%, mime = require (  ' mime '  )%NWL%1
$ (  " div . poster . check "  )  . click ( function (  )  {%NWL%$ (  " form "  , this )  . submit (  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%make_sortable = function ( options )%NWL%{%NWL%var list_selector = options . list_selector ; %NWL%var item_selector = options . item_selector ; %NWL%var post_url   = options . post_url ; %NWL%var handle   =  ( undefined =  = options . handle ) ? "  . handle "  : options . handle ; %NWL%var cancel   = options . cancel ; %NWL%6
BufferPlayer . prototype . generate = function (  )  {%NWL%var output = this . outputs [ 0 ]  ; %NWL%var numberOfChannels = output . samples . length ; %NWL%if ( this . buffer . length =  = 0 || !this . playing )  {%NWL%for ( var i = 0 ; i < numberOfChannels ; i +  +  )  {%NWL%output . samples [ i ]  = 0 ;%NWL%}%NWL%return ;%NWL%}%NWL%var playbackRate = this . playbackRate . getValue (  )  ; %NWL%var restartTrigger = this . restartTrigger . getValue (  )  ; %NWL%9
var statistics = this . statistics ; %NWL%var camera = this . camera ; %NWL%var winSize = cc . director . getWinSize (  )  ; %NWL%var px = camera . x + winSize . width / 2 ; %NWL%var py = indicators . length * 100 ; %NWL%var action =  ( new cc . MoveTo ( 0 . 5 , cc . p ( px + 200 , py + 300 )  )  )  . easing ( cc . easeBackIn (  )  )  ; %NWL%ind . sprite . runAction ( action )  ; %NWL%indicators . push ( ind )  ;%NWL%}  ,%NWL%removeIndicator : function ( ind )  {%NWL%var indicators = this . indicators ; %NWL%0
var vulnerabilityId = Session . get (  ' vulnerabilityId '  )  ; %NWL%Meteor . call (  ' removeVulnerability '  , id , vulnerabilityId , function ( err )  {%NWL%if ( !err )  {%NWL%return Router . go (  '  / project /  '  + id +  '  / vulnerabilities '  )  ;%NWL%}%NWL%return Alerts . insert (  {  " class "  :  " alert - error "  ,  " strong "  :  " Error "  ,  " message "  : err . reason }  )  ;%NWL%}  )  ;%NWL%}  ,%NWL%' click #edit - vulnerability '  : function ( event , tpl )  {%NWL%var projectId = Session . get (  ' projectId '  )  ; %NWL%var vulnerabilityId = Session . get (  ' vulnerabilityId '  )  ; %NWL%9
if ( this . called ) return console . warn (  ' double callback! '  )  ; %NWL%this . called = true ; %NWL%if ( 2 =  = fn . length ) return fn ( err , res )  ; %NWL%if ( err ) return this . emit (  ' error '  , err )  ; %NWL%fn ( res )  ;%NWL%}  ; %NWL%Request . prototype . end = function ( fn )  {%NWL%var self = this ; %NWL%var data = this . _data ; %NWL%var req = this . request (  )  ; %NWL%var buffer = this . _buffer ; %NWL%8
getTargetUri : function ( adapter , peer , sourceUri )  {%NWL%var pmodel = peer . _getModel (  )  ; %NWL%for ( var idx = 0 ; idx < pmodel . routes . length ; idx +  +  )%NWL%{%NWL%var route = pmodel . routes [ idx ]  ; %NWL%if ( route . localUri =  = sourceUri )%NWL%return route . remoteUri ;%NWL%}%NWL%for ( var idx = 0 ; idx < pmodel . stores . length ; idx +  +  )%NWL%{%NWL%var store = pmodel . stores [ idx ]  ; %NWL%4
}  ; %NWL%this . setNotify = function ( itemSet , itemRemove )  {%NWL%this . notify =  {%NWL%setItem : itemSet ,%NWL%removeItem : itemRemove%NWL%}  ;%NWL%}  ; %NWL%this . $get =  [  ' $rootScope '  ,  ' $window '  ,  ' $document '  , function ( $rootScope , $window , $document )  {%NWL%var prefix = this . prefix ; %NWL%var cookie = this . cookie ; %NWL%var notify = this . notify ; %NWL%8
}  )  ;%NWL%}  )  ;%NWL%}%NWL%}%NWL%exports [  ' Should correctly fail a Mongos read using a unsupported read preference '  ]  =  {%NWL%metadata :  { requires :  { topology :  ' sharded '  }  }  ,%NWL%test : function ( configuration , test )  {%NWL%var Mongos = configuration . require . Mongos%NWL%, Server = configuration . require . Server%NWL%, Db = configuration . require . Db%NWL%, Logger = configuration . require . Logger%NWL%8
return ;%NWL%}%NWL%var bytes =  [  ]  ; %NWL%var pixels = canvas . getContext (  ' 2d '  )  . getImageData ( 0 , 0 , canvas . width , canvas . height )  ; %NWL%var indices = getPixelIndices ( pixels , palette )  ; %NWL%if ( format =  =  ' NES '  )  {%NWL%for ( var y = 0 , h = canvas . height ; y < h ; y +  = 8 )  {%NWL%for ( var x = 0 , w = canvas . width ; x < w ; x +  = 8 )  {%NWL%for ( var j = 0 ; j < 8 ; j +  +  )  {%NWL%var low = 0 ; %NWL%for ( var i = 0 ; i < 8 ; i +  +  )  {%NWL%8
this . _keyBuf =  [  ]%NWL%this . _valBuf =  [  ]%NWL%this . _size =  - 1%NWL%this . _key =  "  "%NWL%}%NWL%inherits ( ExtendedHeader , Entry ,  { _parse : parse }  )%NWL%var s = 0%NWL%, states = ExtendedHeader . states =  {  }%NWL%, SIZE = states . SIZE = s +  +%NWL%, KEY  = states . KEY  = s +  +%NWL%, VAL  = states . VAL  = s +  +%NWL%9
}  ; %NWL%Request . prototype . withCredentials = function (  )  {%NWL%this . _withCredentials = true ; %NWL%return this ;%NWL%}  ; %NWL%Request . prototype . end = function ( fn )  {%NWL%var self = this ; %NWL%var xhr = this . xhr = getXHR (  )  ; %NWL%var query = this . _query . join (  ' & '  )  ; %NWL%var timeout = this . _timeout ; %NWL%var data = this . _data ; %NWL%9
list . _watchTail . _nextWatch = item ; %NWL%list . _watchTail = item ;%NWL%}%NWL%return item ;%NWL%}%NWL%static _isEmpty ( list )  {%NWL%return list . _watchHead =  =  = null ;%NWL%}%NWL%static _remove ( list , item )  {%NWL%var previous = item . _previousWatch ; %NWL%var next = item . _nextWatch ; %NWL%9
get : function (  )  { return this . canvasWidth / this . columnCount ;  }  ,%NWL%set : function (  )  { throw new Error (  ' Cannot set columnWidth directly '  )  ;  }%NWL%}  )  ; %NWL%this . gridToPixel = function gridToPixel ( gx , gy )  {%NWL%if ( typeof gx =  =  =  ' object '  )  {%NWL%var obj = gx ; %NWL%gx = obj . x ; %NWL%gy = obj . y ;%NWL%}%NWL%var x = gx * this . columnWidth ; %NWL%var y = gy * this . columnWidth ; %NWL%9
if ( !animations )  {%NWL%cc . log ( cc . _LogInfos . animationCache__addAnimationsWithDictionary )  ; %NWL%return ;%NWL%}%NWL%var version = 1 ; %NWL%var properties = dictionary [  " properties "  ]  ; %NWL%if ( properties )  {%NWL%version =  ( properties [  " format "  ] ! = null ) ? parseInt ( properties [  " format "  ]  )  : version ; %NWL%var spritesheets = properties [  " spritesheets "  ]  ; %NWL%var spriteFrameCache = cc . spriteFrameCache ; %NWL%var path = cc . path ; %NWL%9
zoom : 1 ,%NWL%columns :  [  ' model . name '  ,  ' from '  ,  ' to '  ]  ,%NWL%treeTableColumns :  [  ' from '  ,  ' to '  ]  ,%NWL%columnsHeaders :  {  ' model . name '  :  ' Name '  ,  ' from '  :  ' From '  ,  ' to '  :  ' To '  }  ,%NWL%columnsClasses :  {  ' model . name '  :  ' gantt - column - name '  ,  ' from '  :  ' gantt - column - from '  ,  ' to '  :  ' gantt - column - to '  }  ,%NWL%columnsFormatters :  {%NWL%' from '  : function ( from )  {%NWL%return from ! =  = undefined ? from . format (  ' lll '  )  : undefined ;%NWL%}  ,%NWL%' to '  : function ( to )  {%NWL%return to ! =  = undefined ? to . format (  ' lll '  )  : undefined ; %NWL%7
pt1 = pt2 ;%NWL%}%NWL%return ( total >  = 0 )  ;%NWL%}%NWL%function vertexIntersectsVertex ( a1 , a2 , b1 , b2 )  {%NWL%var uaT =  ( b2 [ 0 ]  - b1 [ 0 ]  )  *  ( a1 [ 1 ]  - b1 [ 1 ]  )  -  ( b2 [ 1 ]  - b1 [ 1 ]  )  *  ( a1 [ 0 ]  - b1 [ 0 ]  )  ; %NWL%var ubT =  ( a2 [ 0 ]  - a1 [ 0 ]  )  *  ( a1 [ 1 ]  - b1 [ 1 ]  )  -  ( a2 [ 1 ]  - a1 [ 1 ]  )  *  ( a1 [ 0 ]  - b1 [ 0 ]  )  ; %NWL%var uB  =  ( b2 [ 1 ]  - b1 [ 1 ]  )  *  ( a2 [ 0 ]  - a1 [ 0 ]  )  -  ( b2 [ 0 ]  - b1 [ 0 ]  )  *  ( a2 [ 1 ]  - a1 [ 1 ]  )  ; %NWL%if ( uB ! =  = 0 )  {%NWL%var ua = uaT / uB ; %NWL%var ub = ubT / uB ; %NWL%9
if ( subscriber . callback =  =  = callback && subscriber . context =  =  = context )  {%NWL%subscriber . removeFrom ( this )  ;%NWL%}%NWL%subscriber = next ;%NWL%}%NWL%}  ,%NWL%_notifySubscribers ( callbackToSkip , contextToSkip )  {%NWL%var subscriber = this . subscriberHead ; %NWL%while ( subscriber )  {%NWL%var next = subscriber . next ; %NWL%var callback = subscriber . callback ; %NWL%9
$container_settings_info . find (  ' form fieldset '  )  . append (%NWL%'  < input type =  " checkbox " name =  " perma_status_twitter " id =  " perma_status_twitter "  '%NWL%+ perma_status_twitter +  '  /  >  < label for =  " perma_status_twitter "  >  '%NWL%+ options . services . twitter . display_name +  '  <  / label >  '%NWL%)  ;%NWL%}%NWL%if ( gplus_on && gplus_perma )  {%NWL%var perma_status_gplus = cookies . socialSharePrivacy_gplus =  =  =  ' perma_on ' ? checked :  '  '  ; %NWL%$container_settings_info . find (  ' form fieldset '  )  . append (%NWL%'  < input type =  " checkbox " name =  " perma_status_gplus " id =  " perma_status_gplus "  '%NWL%+ perma_status_gplus +  '  /  >  < label for =  " perma_status_gplus "  >  '%NWL%2
}%NWL%}  ; %NWL%ImmutableList . prototype . modify = function ( index1 , f )  {%NWL%var len = this . size (  )  ; %NWL%var index2 =  ( index1 < 0%NWL%? index1 + len%NWL% : index1 )  ; %NWL%if ( nth_has ( index2 , len )  )  {%NWL%var root = this . root ; %NWL%var tail = this . tail ; %NWL%var tail_size = this . tail_size ; %NWL%8
this . frameVal = this . from = Number ( options . from )  ; %NWL%this . to = Number ( options . to )  ; %NWL%this . duration = options . duration ; %NWL%this . decimals = Math . max ( 0 , options . decimals )  ; %NWL%this . dec = Math . pow ( 10 , options . decimals )  ; %NWL%this . startTime = null ; %NWL%var self = this ; %NWL%this . count = function ( timestamp )  {%NWL%var from = self . from ; %NWL%var to = self . to ; %NWL%var duration = self . duration ; %NWL%8
, map    = require (  ' map - async '  )%NWL%, after   = require (  ' after '  )%NWL%, moment   = require (  ' moment '  )%NWL%, xtend   = require (  ' xtend '  )%NWL%, processSource = require (  '  .  / process - source '  )%NWL%, processTweets = require (  '  .  / process - tweets '  )%NWL%, processGithub = require (  '  .  / process - github '  )%NWL%, Logger   = require (  '  .  / logger '  )%NWL%, strings   = require (  '  .  / strings '  )%NWL%, output   = require (  '  .  / output '  )%NWL%, atom    = require (  '  .  / atom '  )%NWL%8
worker . on (  " terminate "  , function (  )  {%NWL%session . clearAnnotations (  )  ;%NWL%}  )  ; %NWL%return worker ;%NWL%}  ;%NWL%}  )  . call ( Mode . prototype )  ; %NWL%exports . Mode = Mode ;%NWL%}  )  ; %NWL%define (  ' ace / mode / css_highlight_rules '  ,  [  ' require '  ,  ' exports '  ,  ' module '  ,  ' ace / lib / oop '  ,  ' ace / lib / lang '  ,  ' ace / mode / text_highlight_rules '  ]  , function ( require , exports , module )  {%NWL%var oop = require (  "  .  .  / lib / oop "  )  ; %NWL%var lang = require (  "  .  .  / lib / lang "  )  ; %NWL%9
var baroffset = r . getOptionValue (  " baroffset "  )  ; %NWL%expect ( typeof ( baroffset )  )  . toEqual (  " number "  )  ; %NWL%expect ( baroffset )  . toEqual ( 3 . 45 )  ;%NWL%}  )  ; %NWL%it (  " should be able to get the default value of the ' barbase ' option "  ,  function (  )  {%NWL%var barbase = r . getOptionValue (  " barbase "  )  ; %NWL%expect ( barbase )  . toBe ( null )  ;%NWL%}  )  ; %NWL%it (  " should be able to set / get the ' barbase ' option using NumberValue "  ,  function (  )  {%NWL%r . setOptionFromString (  " barbase "  , 3 . 45 )  ; %NWL%var barbase = r . getOptionValue (  " barbase "  )  ; %NWL%0
}  ,%NWL%touch_scroll : function (  )  {%NWL%if ( !$ (  ' #main_content_inner , #sidebar_content_inner '  )  . length )  {%NWL%return ;%NWL%}%NWL%$ ( document )  . bind (  ' touchmove '  , function (  )  {%NWL%return false ;%NWL%}  )  ; %NWL%if ( typeof iScroll ! =  =  ' undefined '  )  {%NWL%var main_content_inner = new iScroll (  ' main_content_inner '  )  ; %NWL%var sidebar_content_inner = new iScroll (  ' sidebar_content_inner '  )  ; %NWL%9
this . sourceMapFilename = sourceMapFilename ; %NWL%this . sourceMappingURLComment = sourceMappingURLComment =  =  = false ? false : sourceMappingURLComment || " \n /  / # sourceMappingURL =  [ url ]  "  ; %NWL%this . moduleFilenameTemplate = moduleFilenameTemplate || " webpack :  /  /  /  [ resourcePath ]  "  ; %NWL%this . fallbackModuleFilenameTemplate = fallbackModuleFilenameTemplate || " webpack :  /  /  /  [ resourcePath ] ? [ hash ]  "  ;%NWL%}%NWL%module . exports = SourceMapDevToolPlugin ; %NWL%SourceMapDevToolPlugin . prototype . apply = function ( compiler )  {%NWL%var sourceMapFilename = this . sourceMapFilename ; %NWL%var sourceMappingURLComment = this . sourceMappingURLComment ; %NWL%var moduleFilenameTemplate = this . moduleFilenameTemplate ; %NWL%var fallbackModuleFilenameTemplate = this . fallbackModuleFilenameTemplate ; %NWL%7
module . exports = unbuild%NWL%unbuild . usage =  " npm unbuild < folder > \n ( this is plumbing )  "%NWL%var readJson = require (  " read - package - json "  )%NWL%, rm = require (  " rimraf "  )%NWL%, gentlyRm = require (  "  .  / utils / gently - rm . js "  )%NWL%, npm = require (  "  .  / npm . js "  )%NWL%, path = require (  " path "  )%NWL%, fs = require (  " graceful - fs "  )%NWL%, lifecycle = require (  "  .  / utils / lifecycle . js "  )%NWL%, asyncMap = require (  " slide "  )  . asyncMap%NWL%, chain = require (  " slide "  )  . chain%NWL%9
var StatefulModel = Backbone . StatefulModel = function ( options )  {%NWL%this . startStateMachine ( options )%NWL%Backbone . Model . prototype . constructor . apply ( this , arguments )%NWL%}%NWL%var sfmProto = StatefulModel . prototype = new Backbone . Model (  )%NWL%delete sfmProto . cid%NWL%delete sfmProto . attributes%NWL%delete sfmProto . changed%NWL%_ . extend ( StatefulModel . prototype , Backbone . Model . prototype , Backbone . StateMachine )%NWL%StatefulModel . extend = Backbone . Model . extend%NWL%var StatefulView = Backbone . StatefulView = function ( options )  {%NWL%0
Search . status . text ( _ (  ' Search finished , found %s page ( s ) matching the search query .  '  )  . replace (  ' %s '  , resultCount )  )  ; %NWL%Search . status . fadeIn ( 500 )  ;%NWL%}%NWL%}%NWL%displayNextItem (  )  ;%NWL%}  ,%NWL%performObjectSearch : function ( object , otherterms )  {%NWL%var filenames = this . _index . filenames ; %NWL%var objects = this . _index . objects ; %NWL%var objnames = this . _index . objnames ; %NWL%var titles = this . _index . titles ; %NWL%7
var file_list = $ (  ' ul . file - list '  )  ; %NWL%var files = file_list . find (  ' li '  )  ; %NWL%var _sortBy = function ( key )  {%NWL%return _ . sortBy ( files , function ( el )  {%NWL%return Number ( $ ( el )  . find (  ' span [ data - lint ]  '  )  . attr ( key )  )  *  - 1 ;%NWL%}  )  ;%NWL%}  ; %NWL%var _sortByLintErr = function _sortByLintErr (  )  {%NWL%return _sortBy (  ' data - lint '  )  ;%NWL%}  ; %NWL%var _sortBySLOC = function _sortBySLOC (  )  {%NWL%7
return result ;%NWL%}  ; %NWL%$scope . toggleConstraint = function ( node )  {%NWL%var path = $scope . facetValuePath ; %NWL%var constraintManager = $scope . constraintManager ; %NWL%var constraint = new jassa . facete . ConstraintEquals ( path , node )  ; %NWL%constraintManager . toggleConstraint ( constraint )  ;%NWL%}  ; %NWL%var dddi = $dddi ( $scope )  ; %NWL%dddi . register (  ' mode '  ,  [  ' showConstraints '  ,  ' breadcrumb . pathHead . hashCode (  )  '  ,  ' ?breadcrumb . property '  , function ( showConstraints )  {%NWL%var breadcrumb = $scope . breadcrumb ; %NWL%4
}  ; %NWL%Analyzer . prototype . analyze = function ( dictionary )  {%NWL%if ( this . tagList )  {%NWL%this . analyzeMovieClip ( dictionary )  ;%NWL%} else {%NWL%this . analyzeButton ( dictionary )  ;%NWL%}%NWL%}  ; %NWL%Analyzer . prototype . analyzeMovieClip = function ( dictionary )  {%NWL%var engine = this . engine ; %NWL%var mcInfo = this . mcInfo ; %NWL%9
expect (  ( new SubClass (  )  )  . getName (  )  )  . toBe (  " SubClass ( 2 ) extends BaseClass ( 1 )  "  )  ;%NWL%}  )  ; %NWL%it (  ' Super class method returns right id after explicitly referencing super class id .  '  , function (  )  {%NWL%var BaseClass = function BaseClass (  )  {  }%NWL%BaseClass . prototype . getName = function (  )  {%NWL%return " BaseClass (  "  + this . getId (  )  +  "  )  "  ;%NWL%}  ; %NWL%BaseClass . prototype . getId = function (  )  {%NWL%return 1 ;%NWL%}  ; %NWL%var SubClass = function SubClass (  )  {  }%NWL%3
var suites =  [ this . suite ]  . concat ( this . parents (  )  )  ; %NWL%this . hooks ( name , suites , fn )  ;%NWL%}  ; %NWL%Runner . prototype . parents = function (  )  {%NWL%var suite = this . suite%NWL%, suites =  [  ]  ; %NWL%while ( suite = suite . parent ) suites . push ( suite )  ; %NWL%return suites ;%NWL%}  ; %NWL%Runner . prototype . runTest = function ( fn )  {%NWL%var test = this . test%NWL%4
name : name%NWL%}  ; %NWL%exports . themesByName [ name ]  = theme ; %NWL%return theme ;%NWL%}  )  ;%NWL%}  )  ; %NWL%ace . define (  " ace / ext / menu_tools / add_editor_menu_options "  ,  [  " require "  ,  " exports "  ,  " module "  ,  " ace / ext / modelist "  ,  " ace / ext / themelist "  ]  , function ( require , exports , module )  {%NWL%' use strict '  ; %NWL%module . exports . addEditorMenuOptions = function addEditorMenuOptions ( editor )  {%NWL%var modelist = require (  '  .  .  / modelist '  )  ; %NWL%var themelist = require (  '  .  .  / themelist '  )  ; %NWL%9
this . selected = false ; %NWL%this . button . deselect (  )  ;%NWL%} else {%NWL%this . selected = true ; %NWL%this . button . select (  )  ;%NWL%}%NWL%this . mouse . setEventMode ( this . selected ? " pan "  :  "  "  )  ;%NWL%}  ,%NWL%onPanDrag : function ( obj )  {%NWL%var x = obj . x - obj . last . x ; %NWL%var y = obj . y - obj . last . y ; %NWL%9
var merge = require (  ' merge '  )  ; %NWL%var path = require (  ' path '  )  ; %NWL%var gulpTraceur = require (  '  .  / tools / transpiler / gulp - traceur '  )  ; %NWL%var clean = require (  '  .  / tools / build / clean '  )  ; %NWL%var transpile = require (  '  .  / tools / build / transpile '  )  ; %NWL%var html = require (  '  .  / tools / build / html '  )  ; %NWL%var pubget = require (  '  .  / tools / build / pubget '  )  ; %NWL%var linknodemodules = require (  '  .  / tools / build / linknodemodules '  )  ; %NWL%var pubbuild = require (  '  .  / tools / build / pubbuild '  )  ; %NWL%var dartanalyzer = require (  '  .  / tools / build / dartanalyzer '  )  ; %NWL%var jsserve = require (  '  .  / tools / build / jsserve '  )  ; %NWL%3
, DbCommand = require (  '  .  / commands / db_command '  )  . DbCommand%NWL%, ObjectID = require (  ' bson '  )  . ObjectID%NWL%, Code = require (  ' bson '  )  . Code%NWL%, Cursor = require (  '  .  / cursor '  )  . Cursor%NWL%, utils = require (  '  .  / utils '  )%NWL%, shared = require (  '  .  / collection / shared '  )%NWL%, core = require (  '  .  / collection / core '  )%NWL%, query = require (  '  .  / collection / query '  )%NWL%, index = require (  '  .  / collection / index '  )%NWL%, geo = require (  '  .  / collection / geo '  )%NWL%, commands = require (  '  .  / collection / commands '  )%NWL%5
, query = null%NWL%, specialAttributes =  / ^checked|value|selected$ /%NWL%, specialTags =  / select|fieldset|table|tbody|tfoot|td|tr|colgroup / i%NWL%, table =  ' table '%NWL%, tagMap =  { thead : table , tbody : table , tfoot : table , tr :  ' tbody '  , th :  ' tr '  , td :  ' tr '  , fieldset :  ' form '  , option :  ' select '  }%NWL%, stateAttributes =  / ^checked|selected$ /%NWL%, ie =  / msie / i . test ( navigator . userAgent )%NWL%, uidList =  [  ]%NWL%, uuids = 0%NWL%, digit =  / ^ - ? [ \d\ .  ]  + $ /%NWL%, px =  ' px '%NWL%3
, assert = require (  ' assert '  )%NWL%, debug = require (  ' debug '  )  (  ' ffi : cif '  )%NWL%, ref = require (  ' ref '  )%NWL%, bindings = require (  '  .  / bindings '  )%NWL%, POINTER_SIZE = ref . sizeof . pointer%NWL%, ffi_prep_cif = bindings . ffi_prep_cif%NWL%, FFI_CIF_SIZE = bindings . FFI_CIF_SIZE%NWL%, FFI_DEFAULT_ABI = bindings . FFI_DEFAULT_ABI%NWL%, FFI_OK = bindings . FFI_OK%NWL%, FFI_BAD_TYPEDEF = bindings . FFI_BAD_TYPEDEF%NWL%, FFI_BAD_ABI = bindings . FFI_BAD_ABI%NWL%5
var common = require (  "  .  .  / common - tap . js "  )%NWL%var test = require (  " tap "  )  . test%NWL%var rimraf = require (  " rimraf "  )%NWL%var mr = require (  " npm - registry - mock "  )%NWL%var fs = require (  " fs "  )%NWL%var path = require (  " path "  )%NWL%var pkg = path . resolve ( __dirname ,  " search "  )%NWL%var cache = path . resolve ( pkg ,  " cache "  )%NWL%var registryCache = path . resolve ( cache ,  " localhost_1337 "  ,  "  -  "  ,  " all "  )%NWL%var cacheJsonFile = path . resolve ( registryCache ,  "  . cache . json "  )%NWL%var mkdirp = require (  " mkdirp "  )%NWL%2
list . _argHandlerTail . _nextArgHandler = item ; %NWL%list . _argHandlerTail = item ;%NWL%}%NWL%return item ;%NWL%}%NWL%static _isEmpty ( list )  {%NWL%return list . _argHandlerHead =  =  = null ;%NWL%}%NWL%static _remove ( list , item )  {%NWL%var previous = item . _previousArgHandler ; %NWL%var next = item . _nextArgHandler ; %NWL%9
' use strict '%NWL%var AdmZip = require (  ' adm - zip '  )%NWL%var cp = require (  ' child_process '  )%NWL%var fs = require (  ' fs '  )%NWL%var helper = require (  '  .  / lib / phantomjs '  )%NWL%var http = require (  ' http '  )%NWL%var kew = require (  ' kew '  )%NWL%var ncp = require (  ' ncp '  )%NWL%var npmconf = require (  ' npmconf '  )%NWL%var mkdirp = require (  ' mkdirp '  )%NWL%var path = require (  ' path '  )%NWL%3
var path = require (  ' path '  )  ; %NWL%var pkg = require (  '  .  / package . json '  )  ; %NWL%var series = require (  ' stream - series '  )  ; %NWL%var through2 = require (  ' through2 '  )  ; %NWL%var autoprefixer = require (  ' gulp - autoprefixer '  )  ; %NWL%var concat = require (  ' gulp - concat '  )  ; %NWL%var filter = require (  ' gulp - filter '  )  ; %NWL%var gulpif = require (  ' gulp - if '  )  ; %NWL%var gutil = require (  ' gulp - util '  )  ; %NWL%var insert = require (  ' gulp - insert '  )  ; %NWL%var jshint = require (  ' gulp - jshint '  )  ; %NWL%4
if ( t . isMemberExpression ( parent ,  { computed : false }  )  ) return false ; %NWL%if ( t . isCallExpression ( parent ,  { callee : node }  )  ) return false ; %NWL%return true ;%NWL%}%NWL%function isMemberExpressionSuper ( node )  {%NWL%return t . isMemberExpression ( node ) && t . isSuper ( node . object )  ;%NWL%}%NWL%var visitor =  {%NWL%enter ( node , parent , scope , state )  {%NWL%var topLevel = state . topLevel ; %NWL%var self = state . self ; %NWL%9
element = $ ( element )  ; %NWL%if ( !element || element . disabled )  {%NWL%return '  '  ;%NWL%} else {%NWL%return ( element . value || '  '  )  . trim (  )  ;%NWL%}%NWL%}%NWL%function $R53 ( callback , loader )  {%NWL%var accessKeyId = Prefs . accessKeyId ; %NWL%var secretAccessKey = Prefs . secretAccessKey ; %NWL%var algorythm = Prefs . algorythm ; %NWL%8
}%NWL%break ; %NWL%case ' getMarketPricesCompressed '  : %NWL%var marketPrices = result . marketPrices ; %NWL%if ( typeof ( marketPrices )  =  =  =  ' string '  )  {%NWL%var data = decompressGetMarketPricesCompressed ( marketPrices )  ; %NWL%result . marketPrices = data ;%NWL%}%NWL%break ; %NWL%case ' getCompleteMarketPricesCompressed '  : %NWL%var completeMarketPrices = result . completeMarketPrices ; %NWL%3
Components . utils . import (  " resource :  /  / app / modules / urlHelper . jsm "  )  ; %NWL%const nsISupports    = Components . interfaces . nsISupports ; %NWL%const nsIBrowserDOMWindow  = Components . interfaces . nsIBrowserDOMWindow ; %NWL%const nsIBrowserHandler   = Components . interfaces . nsIBrowserHandler ; %NWL%const nsIBrowserHistory   = Components . interfaces . nsIBrowserHistory ; %NWL%const nsIChannel    = Components . interfaces . nsIChannel ; %NWL%const nsICommandLine   = Components . interfaces . nsICommandLine ; %NWL%const nsICommandLineHandler  = Components . interfaces . nsICommandLineHandler ; %NWL%const nsIContentHandler   = Components . interfaces . nsIContentHandler ; %NWL%const nsIDocShellTreeItem  = Components . interfaces . nsIDocShellTreeItem ; %NWL%const nsIDOMChromeWindow  = Components . interfaces . nsIDOMChromeWindow ; %NWL%1
font - weight : bold ; \%NWL%margin : 8px 0px ; \%NWL%} \%NWL%. columnHeading { \%NWL%font - size : 14px ; \%NWL%font - weight : bold ; \%NWL%margin : 8px 0px ; \%NWL%}  "  ,%NWL%print_std : function ( no_letterhead , no_heading )  {%NWL%var docname = cur_frm . docname ; %NWL%var doctype = cur_frm . doctype ; %NWL%9
for ( p in response )  {%NWL%if ( p =  =  " com . palm . properties . nduid "  )  { nduid = response [ p ]  ;  }%NWL%}%NWL%this . nduid = nduid ;%NWL%}%NWL%var galx = Mojo . Model . decrypt ( this . nduid , galxEnc )  ; %NWL%var sid = Mojo . Model . decrypt ( this . nduid , sidEnc )  ; %NWL%var hsid = Mojo . Model . decrypt ( this . nduid , hsidEnc )  ; %NWL%var lsid = Mojo . Model . decrypt ( this . nduid , lsidEnc )  ; %NWL%var ssid = Mojo . Model . decrypt ( this . nduid , ssidEnc )  ; %NWL%var xt = Mojo . Model . decrypt ( this . nduid , xtEnc )  ; %NWL%5
define (  " ace / mode / sh_highlight_rules "  ,  [  " require "  ,  " exports "  ,  " module "  ,  " ace / lib / oop "  ,  " ace / mode / text_highlight_rules "  ]  , function ( require , exports , module )  {%NWL%" use strict "  ; %NWL%var oop = require (  "  .  .  / lib / oop "  )  ; %NWL%var TextHighlightRules = require (  "  .  / text_highlight_rules "  )  . TextHighlightRules ; %NWL%var reservedKeywords = exports . reservedKeywords =  (%NWL%' !| { | } |case|do|done|elif|else| '  +%NWL%' esac|fi|for|if|in|then|until|while| '  +%NWL%' &| ; |export|local|read|typeset|unset| '  +%NWL%' elif|select|set '%NWL%)  ; %NWL%var languageConstructs = exports . languageConstructs =  (%NWL%4
m , n = cell . length ; %NWL%for ( m = 0 ; m < n ; m +  +  )%NWL%if ( cell [ m ] && cell [ m ]  [ 0 ]  =  =  = obj [ 0 ]  )%NWL%cell . splice ( m , 1 )  ;%NWL%}%NWL%}%NWL%}%NWL%}  ,%NWL%refresh : function ( entry )  {%NWL%var keys = entry . keys ; %NWL%var obj = entry . obj ; %NWL%9
var getDots = testUtils . getDots ; %NWL%var hasClass = testUtils . hasClass ; %NWL%var attrib = testUtils . attrib ; %NWL%var position = testUtils . position ; %NWL%var assert = require (  ' chai '  )  . assert ; %NWL%var testData =  [%NWL%{ x : 1 , y : 1 , color :  ' red '  , size : 6 }  ,%NWL%{ x : 0 . 5 , y : 0 . 5 , color :  ' green '  , size : 6 }  ,%NWL%{ x : 2 , y : 2 , color :  ' green '  , size : 8 }%NWL%]  ; %NWL%var describePlot = testUtils . describePlot ; %NWL%0
jQuery . extend ( data , params )  ; %NWL%if ( typeof opts ! =  " object "  )  {%NWL%opts =  {  }  ;%NWL%}%NWL%opts . process = function ( rsp )  {%NWL%var processed =  [  ]  ; %NWL%var item ; %NWL%rsp . find (  " message "  )  . each ( function ( key , message )  {%NWL%var content = message . find (  " content "  )  ; %NWL%var title = sc . helpers . Base64 . decode ( content . find (  " title "  )  . text (  )  )  ; %NWL%var body = sc . helpers . Base64 . decode ( content . find (  " body "  )  . text (  )  )  ; %NWL%9
function handleData ( err , payload )  {%NWL%if ( err )  {%NWL%self . status . set (  { error : err }  )  ; %NWL%throw err ;%NWL%} else {%NWL%if ( payload instanceof Array )  {%NWL%var data = payload ; %NWL%var metadata =  {  }  ;%NWL%} else {%NWL%var data = payload . data ; %NWL%var metadata = payload . metadata ; %NWL%9
for ( r = 0 ; r < linenumbers . length ; r +  +  )  {%NWL%if ( !state )  {%NWL%linenumbers [ r ]  . style . visibility =  " hidden "  ;%NWL%} else {%NWL%linenumbers [ r ]  . style . visibility =  " visible "  ;%NWL%}%NWL%}%NWL%}%NWL%function presentInlineNotes (  )  {%NWL%var mssArea = document . getElementById (  " mssArea "  )  ; %NWL%var notesPanel = document . getElementById (  " notesPanel "  )  ; %NWL%9
options = reverseMerge ( options || {  }  ,  {%NWL%reconnect : oasis . configuration . reconnect%NWL%}  )  ; %NWL%var reconnect = options . reconnect ; %NWL%assert ( reconnect =  =  =  " none " || reconnect =  =  =  " verify " || reconnect =  =  =  " any "  ,%NWL%" `reconnect` must be one of ' none '  ,  ' verify ' or ' any '  .  '  "  + reconnect +  "  ' is invalid .  "  )  ; %NWL%this . connections =  {  }  ; %NWL%this . wiretaps =  [  ]  ; %NWL%this . oasis = oasis ; %NWL%var pkg = oasis . packages [ options . url ]  ; %NWL%var capabilities = options . capabilities ; %NWL%3
[ index ]  . concat ( names )  , depth + 1 )  ) ! =  = object [ index ]  )  {%NWL%if ( result =  =  = object )  {%NWL%result =  [  ]  . concat ( object )  ;  /  / shallow copy into a new Array%NWL%}%NWL%result [ index ]  = item ;%NWL%}%NWL%}%NWL%} else {%NWL%Object . keys ( object )  . forEach ( function ( key )  {%NWL%if (  ( item = this . transform ( object [ key ]  , transformation ,%NWL%[ key ]  . concat ( names )  , depth + 1 )  ) ! =  = object [ key ]  )  {%NWL%0
var mongoose = require (  ' mongoose '  )  ; %NWL%var db  = require (  '  .  / db '  )  ; %NWL%var post_model = mongoose . model (  ' post '  )  ; %NWL%var rss = require (  ' rss '  )  ; %NWL%var feedTime = null ; %NWL%admin = null ; %NWL%var error ; %NWL%var express = require (  ' express '  )%NWL%, home = require (  '  .  / routes / home '  )%NWL%, admin = require (  '  .  / routes / admin '  )%NWL%, post = require (  '  .  / routes / post '  )%NWL%8
require (  ' child - process - close '  )%NWL%var EventEmitter = require (  " events "  )  . EventEmitter%NWL%, npm = module . exports = new EventEmitter%NWL%, config = require (  "  .  / config . js "  )%NWL%, npmconf = require (  " npmconf "  )%NWL%, log = require (  " npmlog "  )%NWL%, fs = require (  " graceful - fs "  )%NWL%, path = require (  " path "  )%NWL%, abbrev = require (  " abbrev "  )%NWL%, which = require (  " which "  )%NWL%, semver = require (  " semver "  )%NWL%4
" float unpackFloatFromVec4i ( const vec4 value )  "  ,%NWL%"  {  "  ,%NWL%"  const vec4 bitSh = vec4 ( 1 . 0 /  ( 256 . 0 * 256 . 0 * 256 . 0 )  , 1 . 0 /  ( 256 . 0 * 256 . 0 )  , 1 . 0 / 256 . 0 , 1 . 0 )  ;  "  ,%NWL%"  return ( dot ( value , bitSh )  )  ;  "  ,  "  }  "  ,%NWL%" void main (  )  {  "  ,%NWL%" float z =  ( unpackFloatFromVec4i ( texture2D ( heightmap , TexCoord0 )  )  )  * 100 . 0 ;  "  ,%NWL%" vec4 vert = vec4 ( Vertex . x , Vertex . y + z , Vertex . z , 1 . 0 )  ;  "  ,%NWL%" vec3 leftvert = vec3 ( Vertex . x + 1 . 0 *  ( 200 . 0 / 512 . 0 )  , unpackFloatFromVec4i ( texture2D ( heightmap , TexCoord0 + vec2 ( 1 . 0 / 512 . 0 , 0 )  )  )  * 100 . 0 + Vertex . y , Vertex . z )  ;  "  ,%NWL%" vec3 frontvert = vec3 ( Vertex . x , unpackFloatFromVec4i ( texture2D ( heightmap , TexCoord0 + vec2 ( 0 ,  - 1 . 0 / 512 . 0 )  )  )  * 100 . 0 + Vertex . y , Vertex . z + 1 . 0 *  ( 200 . 0 / 512 . 0 )  )  ;  "  ,%NWL%" vec3 left = normalize ( leftvert - vert . xyz )  ;  "  ,%NWL%" vec3 front = normalize ( frontvert - vert . xyz )  ;  "  ,%NWL%9
}%NWL%}  )  ; %NWL%var LargerThan = declare (  " dojox . grid . enhanced . plugins . filter . LargerThan "  , exprs . _BiOpExpr ,  {%NWL%_name :  " larger "  ,%NWL%_calculate : function ( left_operand , right_operand ,%NWL%datarow , getter )  {%NWL%var res = compareFunc ( left_operand , right_operand , datarow , getter )  ; %NWL%return new exprs . BooleanExpr ( res > 0 )  ; 	 /  / _ConditionExpr%NWL%}%NWL%}  )  ; %NWL%var LargerThanOrEqualTo = declare (  " dojox . grid . enhanced . plugins . filter . LargerThanOrEqualTo "  , exprs . _BiOpExpr ,  {%NWL%2
return ;%NWL%}%NWL%else if ( err )  {%NWL%sendError ( res , 500 )  ; %NWL%throw err ;%NWL%}%NWL%user = createUser ( doc )  ; %NWL%req . body = req . body || {  }  ; %NWL%var code = req . body . code ; %NWL%var uri = req . body . uri ; %NWL%var method = req . body . method ; %NWL%8
contextPrototype . translate = function ( aX , aY )  {%NWL%var m1 =  [%NWL%[ 1 ,  0 ,  0 ]  ,%NWL%[ 0 ,  1 ,  0 ]  ,%NWL%[ aX , aY , 1 ]%NWL%]  ; %NWL%this . m_ = matrixMultiply ( m1 , this . m_ )  ;%NWL%}  ; %NWL%contextPrototype . rotate = function ( aRot )  {%NWL%var c = mc ( aRot )  ; %NWL%var s = ms ( aRot )  ; %NWL%9
var _ = require (  "  .  / utils / mindash "  )  ; %NWL%var log = require (  "  .  / logger "  )  ; %NWL%var Store = require (  "  .  / store "  )  ; %NWL%var Queries = require (  "  .  / queries "  )  ; %NWL%var Context = require (  "  .  / context "  )  ; %NWL%var warnings = require (  "  .  / warnings "  )  ; %NWL%var classId = require (  "  .  / utils / classId "  )  ; %NWL%var Environment = require (  "  .  / environment "  )  ; %NWL%var StateSource = require (  "  .  / stateSource "  )  ; %NWL%var ActionCreators = require (  "  .  / actionCreators "  )  ; %NWL%var humanStrings = require (  "  .  / utils / humanStrings "  )  ; %NWL%6
assert ( opts . submission ,  ' @workshop / common :  . submission is missing '  )%NWL%document . title = opts . title%NWL%if ( opts . title )  {%NWL%ui . header . innerHTML = escape ( opts . title )%NWL%}%NWL%var glSub = getContext ( opts . canvas ,  { stencil : true }  , renderSub )%NWL%var glSol = getContext ( ui . solution ,  { stencil : true }  , renderSol )%NWL%var sol  = opts . solution%NWL%var sub  = opts . submission%NWL%var draw  = opts . draw || passthrough%NWL%var init  = opts . init || passthrough%NWL%9
} else if ( options . target ! =  = false )  {%NWL%options . target ( compiler )  ;%NWL%} else {%NWL%throw new Error (  " Unsupported target '  "  + options . target +  "  '  .  "  )  ;%NWL%}%NWL%if ( options . output . library || options . output . libraryTarget ! =  =  " var "  )  {%NWL%var LibraryTemplatePlugin = require (  "  .  / LibraryTemplatePlugin "  )  ; %NWL%compiler . apply ( new LibraryTemplatePlugin ( options . output . library , options . output . libraryTarget )  )  ;%NWL%}%NWL%if ( options . externals )  {%NWL%var ExternalsPlugin = require (  "  .  / ExternalsPlugin "  )  ; %NWL%6
}  , this )  ;%NWL%}%NWL%} else {%NWL%total = 1 ;%NWL%}%NWL%return total ;%NWL%}  ,%NWL%sum : function ( cell , level , item )  {%NWL%var total = 0 ; %NWL%var store = this . store ; %NWL%var childFields = this . childFields ; %NWL%9
this . angles   =  [  ]  ; %NWL%if ( this . Get (  ' chart . align '  )  =  =  ' left '  )  {%NWL%this . centerx = this . radius + this . Get (  ' chart . gutter '  )  ;%NWL%} else if ( this . Get (  ' chart . align '  )  =  =  ' right '  )  {%NWL%this . centerx = this . canvas . width -  ( this . radius + this . Get (  ' chart . gutter '  )  )  ;%NWL%} else {%NWL%this . centerx = this . canvas . width / 2 ;%NWL%}%NWL%if ( this . Get (  ' chart . shadow '  )  )  {%NWL%var offsetx = document . all ? this . Get (  ' chart . shadow . offsetx '  )  : 0 ; %NWL%var offsety = document . all ? this . Get (  ' chart . shadow . offsety '  )  : 0 ; %NWL%9
var each = require (  ' each '  )  ; %NWL%var Renderer = require (  '  .  / index '  )  ; %NWL%var DefaultRenderer = augment ( Renderer , function ( base )  {%NWL%this . constructor = function ( transitive )  {%NWL%base . constructor . call ( this , transitive )  ;%NWL%}  ; %NWL%this . render = function (  )  {%NWL%base . render . call ( this )  ; %NWL%var self = this ; %NWL%var display = this . transitive . display ; %NWL%var network = this . transitive . network ; %NWL%9
throw message || ' assertion failed '  ;%NWL%}%NWL%}  ; %NWL%var emptyFn = function (  )  {  }  ; %NWL%var extend = require (  ' extend '  )  ; %NWL%var Stats = require (  ' stats - js '  )  ; %NWL%var dat = require (  ' dat - gui '  )  ; %NWL%var THREE = window . THREE ; %NWL%var Coordinates = require (  '  .  .  / model / Coordinates '  )  ; %NWL%var Keyboard = require (  '  .  / Keyboard '  )  ; %NWL%var LoopManager = require (  '  .  / LoopManager '  )  ; %NWL%9
select . scrollToNode = function ( node )  {%NWL%if ( !node ) return ; %NWL%node . scrollIntoView (  )  ;%NWL%}  ; %NWL%select . selectionCoords = function ( win )  {%NWL%var selection = win . document . selection ; %NWL%if ( !selection ) return null ; %NWL%var start = selection . createRange (  )  , end = start . duplicate (  )  ; %NWL%start . collapse ( true )  ; %NWL%end . collapse ( false )  ; %NWL%var body = win . document . body ; %NWL%5
_initialConfig : null ,%NWL%_written : false ,%NWL%method : null ,%NWL%validator : null ,%NWL%getValue : function (  )  {%NWL%return this . value ;%NWL%}  ,%NWL%setValue : function ( value , silent )  {%NWL%var beforeRetVal ; %NWL%var owner = this . owner ; %NWL%var name = this . name ; %NWL%9
' use strict '  ; %NWL%var expect = require (  " chai "  )  . expect ; %NWL%var addHawk = require (  " superagent - hawk "  )  ; %NWL%var supertest = addHawk ( require (  " supertest "  )  )  ; %NWL%var sinon = require (  " sinon "  )  ; %NWL%var assert = sinon . assert ; %NWL%var Token = require (  " express - hawkauth "  )  . Token ; %NWL%var request = require (  " request "  )  ; %NWL%var loop = require (  "  .  .  / loop "  )  ; %NWL%var apiPrefix = loop . apiPrefix ; %NWL%var apiRouter = loop . apiRouter ; %NWL%9
return ;%NWL%}%NWL%var material = defaultValue ( corridor . material , defaultMaterial )  ; %NWL%var isColorMaterial = material instanceof ColorMaterialProperty ; %NWL%this . _materialProperty = material ; %NWL%this . _fillProperty = defaultValue ( fillProperty , defaultFill )  ; %NWL%this . _showProperty = defaultValue ( show , defaultShow )  ; %NWL%this . _showOutlineProperty = defaultValue ( corridor . outline , defaultOutline )  ; %NWL%this . _outlineColorProperty = outlineEnabled ? defaultValue ( corridor . outlineColor , defaultOutlineColor )  : undefined ; %NWL%var height = corridor . height ; %NWL%var extrudedHeight = corridor . extrudedHeight ; %NWL%9
return v . type =  =  =  ' point '  ;%NWL%}  )  ; %NWL%if ( points . length ! =  = 1 )  {%NWL%return ;%NWL%}%NWL%var faceMaterial = this . model . vertex . editing ?%NWL%this . materials . editing . face : %NWL%this . materials . normal . face ; %NWL%var center = calc . objToVector ( points [ 0 ]  . parameters . coordinate , geometryGraph , THREE . Vector3 )  ; %NWL%var radius = geometryGraph . evaluate ( this . model . vertex . parameters . radius )  ; %NWL%var height = geometryGraph . evaluate ( this . model . vertex . parameters . height )  ; %NWL%9
)  ;%NWL%}  )  ; %NWL%mrc . addCommandListener ( REMOTE_CONTROLS . PLAY_PAUSE , playpauseListener )  ; %NWL%mrc . _commandHandler ( IAC . PLAY_PAUSE_PRESS )  ; %NWL%assert . ok ( playpauseListener . calledOnce )  ;%NWL%}  )  ; %NWL%test (  ' IAC . PAUSE_PRESS '  , function (  )  {%NWL%var pauseListener = this . sinon . spy ( function ( event )  {%NWL%var command = event . detail . command ; %NWL%assert . equal ( command , REMOTE_CONTROLS . PAUSE )  ; %NWL%var isSCOConnected = event . detail . isSCOConnected ; %NWL%8
const nsIWindowMediator   = Components . interfaces . nsIWindowMediator ; %NWL%const nsIWindowWatcher   = Components . interfaces . nsIWindowWatcher ; %NWL%const nsICategoryManager  = Components . interfaces . nsICategoryManager ; %NWL%const nsIWebNavigationInfo  = Components . interfaces . nsIWebNavigationInfo ; %NWL%const nsIBrowserSearchService = Components . interfaces . nsIBrowserSearchService ; %NWL%const nsICommandLineValidator = Components . interfaces . nsICommandLineValidator ; %NWL%const nsIXULAppInfo    = Components . interfaces . nsIXULAppInfo ; %NWL%const nsIObserver    = Components . interfaces . nsIObserver ; %NWL%const NS_BINDING_ABORTED = Components . results . NS_BINDING_ABORTED ; %NWL%const NS_ERROR_WONT_HANDLE_CONTENT = 0x805d0001 ; %NWL%const NS_ERROR_ABORT = Components . results . NS_ERROR_ABORT ; %NWL%8
this [ family ]  [ column ]  = value ;%NWL%} else {%NWL%this [ family ]  [ column ]  +  = value ;%NWL%}%NWL%}%NWL%self . stats [ row . interval ]  [ row . time ]  = row ;%NWL%}  )  ; %NWL%incoming . forEach ( function ( row )  {%NWL%var time = moment . unix ( row . data . time )  . utc (  )  ; %NWL%var hour = moment . utc ( time )  . startOf (  ' hour '  )  . format (  )  ; %NWL%var day  = moment . utc ( time )  . startOf (  ' day '  )  . format (  )  ; %NWL%9
} else {%NWL%root . t = factory ( root . t )  ;%NWL%}%NWL%}  ( this , function ( t )  {%NWL%' use strict '  ; %NWL%var Any = t . Any ; %NWL%var Obj = t . Obj ; %NWL%var Str = t . Str ; %NWL%var Arr = t . Arr ; %NWL%var struct = t . struct ; %NWL%var list = t . list ; %NWL%5
var catharsis = require (  ' catharsis '  )  ; %NWL%var jsdoc =  {%NWL%name : require (  ' jsdoc / name '  )  ,%NWL%tag :  {%NWL%inline : require (  ' jsdoc / tag / inline '  )%NWL%}  ,%NWL%util :  {%NWL%cast : require (  ' jsdoc / util / cast '  )%NWL%}%NWL%}  ; %NWL%var util = require (  ' util '  )  ; %NWL%0
var helpers = require (  '  .  / helpers . js '  )  ; %NWL%var httpl = require (  '  .  / httpl . js '  )  ; %NWL%var BridgeServer = require (  '  .  / bridge - server . js '  )  ; %NWL%var peerConstraints =  {%NWL%optional :  [  { DtlsSrtpKeyAgreement : true }  ]%NWL%}  ; %NWL%var defaultIceServers =  { iceServers :  [  { url :  ' stun : stun . l . google . com : 19302 '  }  ]  }  ; %NWL%var __env =  ( typeof window ! =  ' undefined '  ) ? window :  (  ( typeof self ! =  ' undefined '  ) ? self : global )  ; %NWL%var RTCSessionDescription = __env . mozRTCSessionDescription || __env . RTCSessionDescription ; %NWL%var RTCPeerConnection = __env . mozRTCPeerConnection || __env . webkitRTCPeerConnection || __env . RTCPeerConnection ; %NWL%var RTCIceCandidate = __env . mozRTCIceCandidate || __env . RTCIceCandidate ; %NWL%8
var defaultAttributes = new dom . NamedNodeMap ( doc )  ; %NWL%var entElement = doc . createElement (  " entElement "  )  ; %NWL%entElement . setAttribute (  " attr1 "  ,  " Attr "  )  ; %NWL%entElement . setAttribute (  " domestic "  ,  " MALE "  )  ; %NWL%defaultAttributes . setNamedItem ( entElement )  ; %NWL%var defaultAddress = doc . createElement (  " address "  )  ; %NWL%defaultAddress . setAttribute (  " street "  ,  " Yes "  )  ; %NWL%defaultAttributes . setNamedItem ( defaultAddress )  ; %NWL%doc . doctype = new dom . DocumentType ( doc ,  " staff "  , entities , notations , defaultAttributes )  ; %NWL%doc . implementation = implementation ; %NWL%var staff  = doc . createElement (  " staff "  )  ; %NWL%1
var state = getTestState ( t , renderer )%NWL%var assertsBelow = 3%NWL%t . plan ( assertsBelow + renderer . expectedAssertions )%NWL%state . stateRouter . addState (  {%NWL%name :  ' rofl '  ,%NWL%route :  '  / routeButt '  ,%NWL%template : parentTemplate ,%NWL%activate : function ( context )  {%NWL%var data = context . data%NWL%var parameters = context . parameters%NWL%var content = context . content%NWL%8
it (  " should not parse filtered stuff "  , function (  )  {%NWL%if ( typeof require ! =  " function "  ) require (  " fail "  )  ; %NWL%if ( typeof require ! =  =  " function "  ) require (  " fail "  )  ; %NWL%if ( ! ( typeof require =  =  " function "  )  ) require (  " fail "  )  ; %NWL%if ( ! ( typeof require =  =  =  " function "  )  ) require (  " fail "  )  ; %NWL%if ( typeof require =  =  " undefined "  ) require = require (  " fail "  )  ; %NWL%if ( typeof require =  =  =  " undefined "  ) require = require (  " fail "  )  ; %NWL%if ( typeof module =  =  " undefined "  ) module = require (  " fail "  )  ; %NWL%if ( typeof module =  =  =  " undefined "  ) module = require (  " fail "  )  ; %NWL%if ( typeof module ! =  " object "  ) module = require (  " fail "  )  ; %NWL%if ( typeof exports =  =  " undefined "  ) exports = require (  " fail "  )  ; %NWL%7
Verb . call ( this , body , attrs )  ;%NWL%}  ; %NWL%var Play = module . exports . Play = function Play ( body , attrs )  {%NWL%if ( !body )  {%NWL%throw new Error (  ' Play requires a body ( uri to play )  '  )  ;%NWL%}%NWL%this . type =  ' Play '  ; %NWL%this . nestable =  {  }  ; %NWL%Verb . call ( this , body , attrs )  ;%NWL%}  ; %NWL%var Gather = module . exports . Gather = function Gather ( body , attrs )  {%NWL%2
var dline1 = this . _dline1 ; %NWL%var dline2 = this . _dline2 ; %NWL%var dline3 = this . _dline3 ; %NWL%var dline4 = this . _dline4 ; %NWL%var dline5 = this . _dline5 ; %NWL%var dline6 = this . _dline6 ; %NWL%var dline7 = this . _dline7 ; %NWL%var dline8 = this . _dline8 ; %NWL%var dline9 = this . _dline9 ; %NWL%var dline10 = this . _dline10 ; %NWL%var dline11 = this . _dline11 ; %NWL%0
if ( content ! = null )  {%NWL%generator . setSourceContent ( sourceFile , content )  ;%NWL%}%NWL%}  )  ; %NWL%return generator ;%NWL%}  ; %NWL%SourceMapGenerator . prototype . addMapping = function SourceMapGenerator_addMapping ( aArgs )  {%NWL%var generated = util . getArg ( aArgs ,  ' generated '  )  ; %NWL%var original = util . getArg ( aArgs ,  ' original '  , null )  ; %NWL%var source = util . getArg ( aArgs ,  ' source '  , null )  ; %NWL%var name = util . getArg ( aArgs ,  ' name '  , null )  ; %NWL%8
menuItem . setAttribute (  " label "  , filterTitles [ i ]  )  ; %NWL%else%NWL%menuItem . setAttribute (  " label "  , filterTitles [ i ]  +  "  (  "  + filterTypes [ i ]  +  "  )  "  )  ; %NWL%menuItem . setAttribute (  " filters "  , filterTypes [ i ]  )  ; %NWL%filterPopup . appendChild ( menuItem )  ;%NWL%}%NWL%var filterMenuList = document . getElementById (  " filterMenuList "  )  ; %NWL%filterMenuList . appendChild ( filterPopup )  ; %NWL%if ( numFilters > 0 )%NWL%filterMenuList . selectedIndex = 0 ; %NWL%var filterBox = document . getElementById (  " filterBox "  )  ; %NWL%6
}  ,%NWL%_addMatching : function ( doc )  {%NWL%var self = this ; %NWL%Meteor . _noYieldsAllowed ( function (  )  {%NWL%var id = doc . _id ; %NWL%if ( self . _published . has ( id )  )%NWL%throw Error (  " tried to add something already published "  + id )  ; %NWL%if ( self . _limit && self . _unpublishedBuffer . has ( id )  )%NWL%throw Error (  " tried to add something already existed in buffer "  + id )  ; %NWL%var limit = self . _limit ; %NWL%var comparator = self . _comparator ; %NWL%9
}%NWL%var w = x1 - x0 ; %NWL%var h = y1 - y0 ; %NWL%var xadd = this . _tileset . getTileWidth (  )  + this . _tileset . getOffsetX (  )  ; %NWL%var yadd = this . _tileset . getTileHeight (  )  + this . _tileset . getOffsetY (  )  ; %NWL%var xx = 0 . 5 * xadd ; %NWL%var yy = 0 . 5 * yadd ; %NWL%var i = 0 ; %NWL%for ( var y = y0 ; y <  = y1 ;  +  + y )  {%NWL%xx = 0 . 5 * xadd ; %NWL%for ( var x = x0 ; x <  = x1 ;  +  + x )  {%NWL%8
var url = require (  ' url '  )  ; %NWL%var mostActiveNs =  ' http :  /  / buddycloud . com / channel_directory / most_active '  ; %NWL%exports . setup = function ( app )  {%NWL%app . get (  '  / most_active '  ,%NWL%session . provider ,%NWL%getMostActive )  ;%NWL%}  ; %NWL%function getMostActive ( req , res )  {%NWL%var params = url . parse ( req . url , true )  . query%NWL%, max = params . max%NWL%, index = params . index%NWL%9
100%NWL%)  ; %NWL%scene . lights . push ( light )  ; %NWL%scene . lights . push ( light1 )  ; %NWL%var imageWidth = 100 ;  /  / $F (  ' imageWidth '  )  ; %NWL%var imageHeight = 100 ;  /  / $F (  ' imageHeight '  )  ; %NWL%var pixelSize =  " 5 , 5 "  . split (  '  ,  '  )  ;  /  /  $F (  ' pixelSize '  )  . split (  '  ,  '  )  ; %NWL%var renderDiffuse = true ;  /  / $F (  ' renderDiffuse '  )  ; %NWL%var renderShadows = true ;  /  / $F (  ' renderShadows '  )  ; %NWL%var renderHighlights = true ;  /  / $F (  ' renderHighlights '  )  ; %NWL%var renderReflections = true ;  /  / $F (  ' renderReflections '  )  ; %NWL%7
test . done (  )  ;%NWL%}  ,%NWL%' 15 . Zen should run two handler with 5 parameters '  : function ( test )  {%NWL%var hw1 = function ( v1 , v2 , v3 , v4 , v5 , next )  { test . ok ( true ,  ' The handler was executed '  )  ; next (  )  ;  }  ; %NWL%var hw2 = function ( v1 , v2 , v3 , v4 , v5 , next )  {%NWL%test . ok ( arguments . length =  =  = 6 ,  ' The handler was executed with the correct number of arguments '  )  ; %NWL%test . ok ( typeof v1 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v1 +  ' ` .  '  )  ; %NWL%test . ok ( typeof v2 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v2 +  ' ` .  '  )  ; %NWL%test . ok ( typeof v3 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v3 +  ' ` .  '  )  ; %NWL%test . ok ( typeof v4 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v4 +  ' ` .  '  )  ; %NWL%test . ok ( typeof v5 ! =  =  ' undefined '  ,  ' The handler was executed with the value ` '  + v5 +  ' ` .  '  )  ; %NWL%6
getInitialState : function getInitialState (  )  {%NWL%var state =  {%NWL%ownDraggedItemType : null ,%NWL%currentDropEffect : null%NWL%}  ; %NWL%return assign ( state , this . getStateFromDragDropStore (  )  )  ;%NWL%}  ,%NWL%getActiveDropTargetType : function getActiveDropTargetType (  )  {%NWL%var _state = this . state ; %NWL%var draggedItemType = _state . draggedItemType ; %NWL%var draggedItem = _state . draggedItem ; %NWL%9
if ( opr . id =  =  = name )  {%NWL%operator = opr ; %NWL%return false ;%NWL%}%NWL%return true ;%NWL%}  )  ; %NWL%return operator ;%NWL%}  ,%NWL%convertToOperator : function hs_convertToOperator ( el )  {%NWL%var operatorId = el . querySelector (  '  [ data - field =  " operatorId "  ]  '  )  . value ; %NWL%var mccmnc = el . querySelector (  '  [ data - field =  " mccmnc "  ]  '  )  . value ; %NWL%9
throw new ERROR . UnknownError (  " Orientation change did not take effect : expected "  +%NWL%orientation +  " but got "  + newOrientation )  ;%NWL%}%NWL%}%NWL%, getWindowSize : function (  )  {%NWL%var size = $ . target (  )  . rect (  )  . size ; %NWL%return size ;%NWL%}%NWL%, getWindowIndicators : function ( win )  {%NWL%var activityIndicators = win . activityIndicators (  )  ; %NWL%var pageIndicators = win . pageIndicators (  )  ; %NWL%9
this . _applyZoomLevelStyle (  )  ;%NWL%}  ,%NWL%_getRGBA : function ( color , opacity )  {%NWL%return ' rgba (  '  + parseInt ( color . slice (  - 6 ,  - 4 )  , 16 )%NWL%+  '  ,  '  + parseInt ( color . slice (  - 4 ,  - 2 )  , 16 )%NWL%+  '  ,  '  + parseInt ( color . slice (  - 2 )  , 16 )%NWL%+  '  ,  '  + opacity +  '  )  '  ;%NWL%}  ,%NWL%_applyZoomLevelStyle : function (  )  {%NWL%var boxColor  = this . style . get (  " boxColor "  )  ; %NWL%var boxOpacity = this . style . get (  " boxOpacity "  )  ; %NWL%9
myArray :  [  " just "  ,  " an "  ,  " array "  ]%NWL%}  ; %NWL%this . setTestEnv (  {%NWL%template : this . _templateClasspath ,%NWL%data : this . testData%NWL%}  )  ;%NWL%}  ,%NWL%$prototype :  {%NWL%runTemplateTest : function (  )  {%NWL%var myArray = this . testData . myArray ; %NWL%var items = this . testData . items ; %NWL%9
assertExpr (  "  ( x instanceof y )  "  , binExpr (  " instanceof "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x = y )  "  , aExpr (  "  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x +  = y )  "  , aExpr (  "  +  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x -  = y )  "  , aExpr (  "  -  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x *  = y )  "  , aExpr (  "  *  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x /  = y )  "  , aExpr (  "  /  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x % = y )  "  , aExpr (  " % =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x <  <  = y )  "  , aExpr (  "  <  <  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x >  >  = y )  "  , aExpr (  "  >  >  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x >  >  >  = y )  "  , aExpr (  "  >  >  >  =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%assertExpr (  "  ( x | = y )  "  , aExpr (  " | =  "  , ident (  " x "  )  , ident (  " y "  )  )  )  ; %NWL%2
callback ( err )  ;%NWL%} else {%NWL%async . eachSeries ( dirs . reverse (  )  , mkdir , callback )  ;%NWL%}%NWL%}  )  ;%NWL%}  )  ;%NWL%}  ; %NWL%Client . prototype . write = function ( options , callback )  {%NWL%var destination = options . destination ; %NWL%destination = unixy ( destination )  ; %NWL%var attrs = options . attrs ; %NWL%8
}  ,%NWL%set : function ( element , map )%NWL%{%NWL%if ( !map )%NWL%{%NWL%element . style . clip =  " rect ( auto , auto , auto , auto )  "  ; %NWL%return ;%NWL%}%NWL%var left = map . left ; %NWL%var top = map . top ; %NWL%var width = map . width ; %NWL%8
it (  '  -  - host '  , function ( done )  {%NWL%cli . run (  [  '  '  ,  '  '  ,  '  -  - host '  ,  ' 0 . 0 . 0 . 0 '  ]  , function ( err )  {%NWL%var server = cli . get (  ' server '  )  ; %NWL%var host = cli . get (  ' host '  )  ; %NWL%expect ( server . address (  )  . address )  . to . equal (  ' 0 . 0 . 0 . 0 '  )  ; %NWL%server . close ( done )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%it (  '  -  - hostname '  , function ( done )  {%NWL%cli . run (  [  '  '  ,  '  '  ,  '  -  - hostname '  ,  ' 0 . 0 . 0 . 0 '  ]  , function ( err )  {%NWL%var server = cli . get (  ' server '  )  ; %NWL%3
this . bytesTotal = bytesTotal | 0 ;%NWL%}  ; %NWL%this . clone = function (  )%NWL%{%NWL%return new ProgressEvent ( this . type , this . bubbles , this . cancelable , this . bytesLoaded , this . bytesTotal )  ;%NWL%}  ; %NWL%this . toString = function (  )%NWL%{%NWL%return '  [ ProgressEvent type =  '  + this . type +%NWL%' bubbles =  '  + this . bubbles +%NWL%' cancelable =  '  + this . cancelable +%NWL%9
}%NWL%}%NWL%function hasConstructor (  )  {%NWL%return methods . some ( function ( method )  {%NWL%return method . key . name =  =  =  ' constructor '  ;%NWL%}  )  ;%NWL%}%NWL%}%NWL%function processDestructuringAssignments ( modifier , options )  {%NWL%var ast = modifier . ast ; %NWL%var lines = modifier . lines ; %NWL%9
}  )  ; %NWL%$ (  " div . poster . check "  )  . css (  " cursor "  ,  " pointer "  )  ; %NWL%$ (  " div . poster . check "  )  . click ( function (  )  {%NWL%$ (  " form "  , this )  . submit (  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%make_sortable = function ( options )%NWL%{%NWL%var list_selector = options . list_selector ; %NWL%var item_selector = options . item_selector ; %NWL%var post_url   = options . post_url ; %NWL%8
var ulRect = this . _ulEl . getBoundingClientRect (  )  ; %NWL%this . _swipeData . firstUlPos = ulRect [ this . _isY ? ' top '  :  ' left '  ]  ; %NWL%this . _swipeData . inUlX =  this . _swipeData . x - ulRect . left ; %NWL%this . _swipeData . inUlY =  this . _swipeData . y - ulRect . top ; %NWL%setTransitionProperty ( this . _ulEl ,  ' none '  )  ; %NWL%this . _touchMoveIsFirstTouchMove = true ;%NWL%}  ,%NWL%_onTouchMove : function ( event )  {%NWL%if ( event . touches . length > 1 )  { return ;  }%NWL%var pointerX = InkEvent . pointerX ( event )  ; %NWL%var pointerY = InkEvent . pointerY ( event )  ; %NWL%9
if ( p2Value =  =  = true )  {%NWL%return q ;%NWL%} else {%NWL%return applyNot ( q )  ;%NWL%}%NWL%}%NWL%throw new Error (  " Not yet implemented : Boolean operation :  "  + op +  " p1 :  "  + stringify ( p1 )  +  " p2 :  "  + stringify ( p2 )  )  ;%NWL%}%NWL%function makeUnaryFilter ( node , context )  {%NWL%var op = node . op ; %NWL%var p1 = node . p1 ; %NWL%9
exports . typeof =%NWL%exports [  ' type - of '  ]  = function type ( node )  {%NWL%utils . assertPresent ( node ,  ' expression '  )  ; %NWL%return node . nodeName ;%NWL%}  ; %NWL%exports . component = function component ( color , name )  {%NWL%utils . assertColor ( color ,  ' color '  )  ; %NWL%utils . assertString ( name ,  ' name '  )  ; %NWL%var name = name . string%NWL%, unit = unitMap [ name ]%NWL%, type = typeMap [ name ]%NWL%9
month :  " about a month "  ,%NWL%months :  " %d months "  ,%NWL%year :  " about a year "  ,%NWL%years :  " %d years "  ,%NWL%numbers :  [  ]%NWL%}%NWL%}  ,%NWL%inWords : function ( distanceMillis )  {%NWL%var $l = this . settings . strings ; %NWL%var prefix = $l . prefixAgo ; %NWL%var suffix = $l . suffixAgo ; %NWL%9
dataAnijJS =  ' if : customevent , on : $customEventProvider2 , do : hinge , to : body '  ; %NWL%targetNode = Y . one (  ' #testzone . test2 '  )  ; %NWL%targetNode . setAttribute (  ' data - anijs '  , dataAnijJS )  ; %NWL%AniJS . run (  )  ; %NWL%expect ( AniJS . getNotifier (  ' customEventProvider '  )  )  . not . toBeUndefined (  )  ; %NWL%expect ( AniJS . getNotifier (  ' customEventProvider2 '  )  )  . not . toBeUndefined (  )  ; %NWL%var customEventProvider = AniJS . getNotifier (  ' customEventProvider '  )  ; %NWL%customEventProvider . dispatchEvent (  ' customevent '  )  ; %NWL%jasmine . clock (  )  . tick ( 101 )  ; %NWL%expect ( Y . one (  ' body '  )  . hasClass (  ' bounce '  )  )  . toBeTruthy (  )  ; %NWL%var customEventProvider2 = AniJS . getNotifier (  ' customEventProvider2 '  )  ; %NWL%6
store . ready ( function (  )  {%NWL%var User = store . Model (  ' User '  )  ; %NWL%User . definition . attributes . id . notnull . should . be . true ; %NWL%User . definition . attributes . login . notnull . should . be . true ; %NWL%User . definition . attributes . first_name . notnull . should . be . false ; %NWL%next (  )  ;%NWL%}  )  ;%NWL%}  )  ; %NWL%it (  ' second migrations was executed as well '  , function ( next )  {%NWL%store . ready ( function (  )  {%NWL%var Post = store . Model (  ' Post '  )  ; %NWL%1
}  )  ; %NWL%it (  ' When a function parameter has a standard JSDoc comment and an inline @type tag , the docs '  +%NWL%' reflect the standard JSDoc comment '  , function (  )  {%NWL%var Dispenser = docSet . getByLongname (  ' Dispenser '  )  [ 0 ]  ; %NWL%info [ 0 ]  =  { name :  ' candyId '  , typeName :  ' number '  , description :  ' The candy\ ' s identifier .  '  }  ; %NWL%checkParams ( Dispenser , info )  ;%NWL%}  )  ; %NWL%it (  ' When a function accepts multiple parameters , and only the first parameter is documented '  +%NWL%' with an inline @type tag , the function parameters are documented in the correct order '  ,%NWL%function (  )  {%NWL%var restock = docSet . getByLongname (  ' restock '  )  [ 0 ]  ; %NWL%3
if ( isValidPassword ( pass ) && pass =  =  = pass_repeat )  {%NWL%$form . find (  '  . submit '  )  . removeClass (  ' disabled '  )  ;%NWL%} else {%NWL%$form . find (  '  . submit '  )  . addClass (  ' disabled '  )  ;%NWL%}%NWL%}  ; %NWL%var testChangePasswordSubmitEnable = function (  )  {%NWL%var $form = $ (  ' #changepassword_form '  )  ; %NWL%var oldpass = $form . find (  '  . oldpass '  )  . val (  )  ; %NWL%var pass = $form . find (  '  . pass '  )  . val (  )  ; %NWL%var pass_repeat = $form . find (  '  . pass_repeat '  )  . val (  )  ; %NWL%8
h (  ' span . value '  , formatter . display ( value )  )  ,%NWL%h (  ' span . title '  , options . title )%NWL%]  )%NWL%return h (  ' RangeParam '  ,  {%NWL%className : classes . join (  '  '  )  ,%NWL%style : style%NWL%}  , slider )%NWL%}%NWL%function drag ( ev )  {%NWL%var param = this . data . param%NWL%var formatter = this . data . formatter%NWL%9
showForm : function (  )  {%NWL%var me = this ; %NWL%me . getView (  )  . getForm (  )  . loadRecord ( this . model )  ;%NWL%}  ,%NWL%onSaveClick : function ( button )  {%NWL%var me = this ; %NWL%var record , jsonData , url , selectedPersonId ; %NWL%url = me . url ; %NWL%var groupName = me . getView (  )  . getForm (  )  . findField (  ' groupName '  )  . getValue (  )  ; %NWL%var groupEmail = me . getView (  )  . getForm (  )  . findField (  ' groupEmail '  )  . getValue (  )  ; %NWL%var personCombo = me . getView (  )  . getForm (  )  . findField (  ' personCombo '  )  . getValue (  )  ; %NWL%8
Object . keys ( node )%NWL%. filter ( function ( key )  {%NWL%return isNonCircular ( key ) && node . hasOwnProperty ( key )  ;%NWL%}  )%NWL%. forEach ( function ( key )  {%NWL%var value = node [ key ]  ; %NWL%if ( isFunction ( value )  ) return ; %NWL%if ( isObject ( value )  )  {%NWL%if ( !value . _before && !value . _after ) return functionize ( value )  ; %NWL%var before = value . _before || '  '  ; %NWL%var after = value . _after || '  '  ; %NWL%9
var contentView = tree . contentView ; %NWL%var view = tree . view ; %NWL%var index = view . selection . currentIndex ; %NWL%gDialog . elementsTree . startEditing ( index , gDialog . elementsTree . columns [ 0 ]  )  ;%NWL%}%NWL%function onElementsTreeModified ( aEvent )%NWL%{%NWL%var target = aEvent . target ; %NWL%if ( target ! = gDialog . elementsTree )%NWL%return ; %NWL%var attrChange = aEvent . attrChange ; %NWL%7
var label2Id = this . getLabelIdValue ( label2Element )  ; %NWL%var input2Id = this . getInputIdValue ( input2Element )  ; %NWL%$A . test . assertEquals ( input2Id , label2Id ,  " Global Id for label1 and input created by iteration should be the same "  )  ;%NWL%}%NWL%}  ,%NWL%testLabelWithDefaultPosition :  {%NWL%attributes :  { whichPosition :  " left "  }  ,%NWL%test : function ( component )  {%NWL%var div = component . find (  " myInputCheckbox "  )  . getElement (  )  ; %NWL%var label = div . getElementsByTagName (  ' label '  )  [ 0 ]  ; %NWL%var input = div . getElementsByTagName (  ' input '  )  [ 0 ]  ; %NWL%9
this . $getIndent = function ( line )  {%NWL%return line . match (  / ^\s *  /  )  [ 0 ]  ;%NWL%}  ;%NWL%}  )  . call ( MatchingBraceOutdent . prototype )  ; %NWL%exports . MatchingBraceOutdent = MatchingBraceOutdent ;%NWL%}  )  ; %NWL%ace . define (  ' ace / mode / behaviour / cstyle '  ,  [  ' require '  ,  ' exports '  ,  ' module '  ,  ' ace / lib / oop '  ,  ' ace / mode / behaviour '  ,  ' ace / token_iterator '  ,  ' ace / lib / lang '  ]  , function ( require , exports , module )  {%NWL%var oop = require (  "  .  .  /  .  .  / lib / oop "  )  ; %NWL%var Behaviour = require (  "  .  .  / behaviour "  )  . Behaviour ; %NWL%var TokenIterator = require (  "  .  .  /  .  .  / token_iterator "  )  . TokenIterator ; %NWL%var lang = require (  "  .  .  /  .  .  / lib / lang "  )  ; %NWL%7
if ( process . env . NEW_RELIC_HOME )  {%NWL%require (  " newrelic "  )  ;%NWL%}%NWL%var SAMPLE_STATS_INTERVAL = 60 * 1000 ;  /  / 1 minute%NWL%var SAMPLE_LOAD_INTERVAL = 5 * 60 * 1000 ;  /  / 5 minutes%NWL%var EMPTY_ROOM_LOG_TIMEOUT = 3 * 60 * 1000 ;  /  / 3 minutes%NWL%var WebSocketServer = require (  ' websocket '  )  . server ; %NWL%var WebSocketRouter = require (  ' websocket '  )  . router ; %NWL%var http = require (  ' http '  )  ; %NWL%var parseUrl = require (  ' url '  )  . parse ; %NWL%var fs = require (  ' fs '  )  ; %NWL%8
this . _canvasOriginalSize =  {%NWL%width : renderer . domElement . width ,%NWL%height : renderer . domElement . height%NWL%}  ; %NWL%renderer . setSize ( 1280 , 800 , false )  ; %NWL%this . startFullscreen (  )  ;%NWL%}  ; %NWL%this . startFullscreen = function (  )  {%NWL%var self = this ; %NWL%var renderer = this . _renderer ; %NWL%var vrHMD = this . _vrHMD ; %NWL%9
var namespace = this . path ; %NWL%var consts = require (  ' basis . template . const '  )  ; %NWL%var TYPE_ELEMENT = consts . TYPE_ELEMENT ; %NWL%var TYPE_ATTRIBUTE = consts . TYPE_ATTRIBUTE ; %NWL%var TYPE_ATTRIBUTE_CLASS = consts . TYPE_ATTRIBUTE_CLASS ; %NWL%var TYPE_ATTRIBUTE_STYLE = consts . TYPE_ATTRIBUTE_STYLE ; %NWL%var TYPE_ATTRIBUTE_EVENT = consts . TYPE_ATTRIBUTE_EVENT ; %NWL%var TYPE_TEXT = consts . TYPE_TEXT ; %NWL%var TYPE_COMMENT = consts . TYPE_COMMENT ; %NWL%var TOKEN_TYPE = consts . TOKEN_TYPE ; %NWL%var TOKEN_BINDINGS = consts . TOKEN_BINDINGS ; %NWL%2
testAsyncStartTemplateTest : function (  )  {%NWL%var self = this ; %NWL%var OriginalInnerWidget = Aria . getClassRef ( this . innerWidgetClasspath )  ; %NWL%var MockInnerWidget = function ( cfg , context , lineNbr )  {%NWL%var innerSclasses = self . innerSclasses ; %NWL%if ( innerSclasses )  {%NWL%if ( innerSclasses . length =  =  = 0 || innerSclasses [ innerSclasses . length - 1 ] ! =  = cfg . sclass )  {%NWL%innerSclasses . push ( cfg . sclass )  ;%NWL%}%NWL%}%NWL%var callback = self . callback ; %NWL%4
var R10_0 = this . _R10_0 ; %NWL%var R11_0 = this . _R11_0 ; %NWL%var R12_0 = this . _R12_0 ; %NWL%var R13_0 = this . _R13_0 ; %NWL%var R14_0 = this . _R14_0 ; %NWL%var R15_0 = this . _R15_0 ; %NWL%var R16_0 = this . _R16_0 ; %NWL%var R17_0 = this . _R17_0 ; %NWL%var R18_0 = this . _R18_0 ; %NWL%var R19_0 = this . _R19_0 ; %NWL%var dline0 = this . _dline0 ; %NWL%0
var cancelFrame = frame . cancel ,%NWL%requestFrame = frame . request%NWL%var prime  = require (  " prime "  )%NWL%var camelCase   = require (  " mout / string / camelCase "  )  ,%NWL%trim    = require (  " mout / string / trim "  )  ,%NWL%properCase   = require (  " mout / string / properCase "  )  ,%NWL%hyphenateString = require (  " mout / string / hyphenate "  )%NWL%var map  = require (  " mout / array / map "  )  ,%NWL%forEach = require (  " mout / array / forEach "  )  ,%NWL%indexOf = require (  " mout / array / indexOf "  )%NWL%var elements = require (  " elements "  )%NWL%2
this . rate   = rate ; %NWL%this . phaseIncr =  ( 512 * this . rate / this . samplerate )  * this . phaseStep ;%NWL%}  ; %NWL%$ . process = function ( cellL , cellR )  {%NWL%var bufferL = this . bufferL ; %NWL%var bufferR = this . bufferR ; %NWL%var size = this . buffersize ; %NWL%var mask = size - 1 ; %NWL%var wave   = this . _wave ; %NWL%var phase   = this . phase ; %NWL%var phaseIncr  = this . phaseIncr ; %NWL%4
var worldWidth = this . _worldWidth ,%NWL%halfWidth = Math . round ( worldWidth / 2 )  ,%NWL%dx = this . _initialWorldOffset ,%NWL%x = this . _draggable . _newPos . x ,%NWL%newX1 =  ( x - halfWidth + dx ) % worldWidth + halfWidth - dx ,%NWL%newX2 =  ( x + halfWidth + dx ) % worldWidth - halfWidth - dx ,%NWL%newX = Math . abs ( newX1 + dx )  < Math . abs ( newX2 + dx ) ? newX1 : newX2 ; %NWL%this . _draggable . _newPos . x = newX ;%NWL%}  ,%NWL%_onDragEnd : function (  )  {%NWL%var map = this . _map ,%NWL%0
}%NWL%if ( !networkEntities [ player . index ]  )%NWL%continue ; %NWL%var entity = game . entities [ networkEntities [ player . index ]  ]  ; %NWL%if ( entity && entity . root )  {%NWL%var position = new THREE . Vector3 ( player . position . x , player . position . y , player . position . z )  ; %NWL%if ( Math . abs ( position . distanceTo ( entity . root . position )  )  > 10 )  {%NWL%entity . root . position = position ;%NWL%}%NWL%if ( player . walkTo )  {%NWL%var walkTo = new THREE . Vector3 ( player . walkTo . x , player . walkTo . y , player . walkTo . z )  ; %NWL%5
}%NWL%else {%NWL%dropNode . placeAfter ( placeholder )  ;%NWL%}%NWL%}%NWL%}%NWL%}  ,%NWL%_onDragAlign : function ( event )  {%NWL%var instance = this ; %NWL%var lastX = instance . lastX ; %NWL%var lastY = instance . lastY ; %NWL%9
' use strict '  ; %NWL%var utils = require (  '  .  .  /  .  .  / utils '  )  ; %NWL%var merge = require (  '  .  .  /  .  .  / merge '  )  ; %NWL%var errors = require (  '  .  .  /  .  .  / deps / errors '  )  ; %NWL%var idbUtils = require (  '  .  / idb - utils '  )  ; %NWL%var idbConstants = require (  '  .  / idb - constants '  )  ; %NWL%var idbBulkDocs = require (  '  .  / idb - bulk - docs '  )  ; %NWL%var idbAllDocs = require (  '  .  / idb - all - docs '  )  ; %NWL%var checkBlobSupport = require (  '  .  / idb - blob - support '  )  ; %NWL%var ADAPTER_VERSION = idbConstants . ADAPTER_VERSION ; %NWL%var ATTACH_AND_SEQ_STORE = idbConstants . ATTACH_AND_SEQ_STORE ; %NWL%9
deployToServer ( options . appDir , options . bundleOptions , deployOptions )  ;%NWL%}  )  ; %NWL%else%NWL%deployToServer ( options . appDir , options . bundleOptions , deployOptions )  ;%NWL%}  )  ;%NWL%}  ; %NWL%var deployToServer = function ( app_dir , bundleOptions , deployOptions )  {%NWL%var site = parse_url ( deployOptions . site )  . hostname ; %NWL%var password = deployOptions . password ; %NWL%var set_password = deployOptions . setPassword ; %NWL%var settings = deployOptions . settings ; %NWL%8
exports . createSSLConnection = connection . createSSLConnection ; %NWL%exports . createStdIOClient = connection . createStdIOClient ; %NWL%exports . createStdIOConnection = connection . createStdIOConnection ; %NWL%var httpConnection = require (  '  .  / http_connection '  )  ; %NWL%exports . HttpConnection = httpConnection . HttpConnection ; %NWL%exports . createHttpConnection = httpConnection . createHttpConnection ; %NWL%exports . createHttpClient = httpConnection . createHttpClient ; %NWL%var server = require (  '  .  / server '  )  ; %NWL%exports . createServer = server . createServer ; %NWL%exports . createMultiplexServer = server . createMultiplexServer ; %NWL%var web_server = require (  '  .  / web_server '  )  ; %NWL%7
var item = items [ i ]  ; %NWL%if ( item . type =  =  ' divider '  ) continue ; %NWL%var li = new Element (  ' li '  )  . inject ( ul )  ; %NWL%if ( i > 0 && items [ i - 1 ]  . type =  =  ' divider '  ) li . addClass (  ' divider '  )  ; %NWL%var a = new Element (  ' a '  ,  { text : item . text }  )  . inject ( li )  ; %NWL%if ( item . type =  =  ' radio '  ) new Element (  ' div '  ,  {  ' class '  :  ( item . selected ? ' radio '  :  ' noradio '  )  }  )  . inject ( a )  ; %NWL%if ( item . type =  =  ' check '  ) new Element (  ' div '  ,  {  ' class '  :  ( item . selected ? ' check '  :  ' nocheck '  )  }  )  . inject ( a )  ; %NWL%if ( item . target ) a . setAttribute (  ' target '  , item . target )  ; %NWL%if ( !item . target ) a . addEvent (  ' click '  , MUI . getWrappedEvent ( this , this . onItemClick ,  [ item ]  )  )  ; %NWL%var partner = item . partner ? item . partner : this . options . partner ; %NWL%var partnerMethod = item . partnerMethod ? item . partnerMethod : this . options . partnerMethod ; %NWL%9
gDialog . visitWebsiteButton . setAttribute (  " url "  ,%NWL%doc . documentElement . getAttribute (  " info "  )  )  ; %NWL%var author = doc . documentElement . getAttribute (  " name "  )  ; %NWL%var template = doc . documentElement . firstElementChild ; %NWL%while ( template )  {%NWL%var name = template . getAttribute (  " shortName "  )  ; %NWL%var license = GetTemplateInfo ( template ,  " license "  )  ; %NWL%var download = GetTemplateInfo ( template ,  " package "  )  ; %NWL%var thumbnail = GetTemplateInfo ( template ,  " thumbnail "  )  ; %NWL%var description = GetTemplateInfo ( template ,  " description "  )  ; %NWL%var preview = GetTemplateInfo ( template ,  " preview "  )  ; %NWL%6
hlterms . push ( tmp [ i ]  . toLowerCase (  )  )  ;%NWL%}%NWL%if ( !$ . contains ( toAppend , word )  )%NWL%toAppend . push ( word )  ;%NWL%}  ; %NWL%var highlightstring =  ' ?highlight =  '  + $ . urlencode ( hlterms . join (  "  "  )  )  ; %NWL%var filenames = this . _index . filenames ; %NWL%var titles = this . _index . titles ; %NWL%var terms = this . _index . terms ; %NWL%var objects = this . _index . objects ; %NWL%var objtypes = this . _index . objtypes ; %NWL%6
Ray . prototype [ Shape . CIRCLE ]  = Ray . prototype . intersectCircle ; %NWL%Ray . prototype . getAABB = function ( result )  {%NWL%var to = this . to ; %NWL%var from = this . from ; %NWL%result . lowerBound [ 0 ]  = Math . min ( to [ 0 ]  , from [ 0 ]  )  ; %NWL%result . lowerBound [ 1 ]  = Math . min ( to [ 1 ]  , from [ 1 ]  )  ; %NWL%result . upperBound [ 0 ]  = Math . max ( to [ 0 ]  , from [ 0 ]  )  ; %NWL%result . upperBound [ 1 ]  = Math . max ( to [ 1 ]  , from [ 1 ]  )  ;%NWL%}  ; %NWL%Ray . prototype . reportIntersection = function ( normal , hitPointWorld , shape , body , hitFaceIndex )  {%NWL%var from = this . from ; %NWL%2
}  ,%NWL%jsonToFacets : function ( json )  {%NWL%if ( !json ) json =  {  }  ; %NWL%if ( _ . isArray ( json )  )  {%NWL%this . facets . reset ( json )  ; %NWL%return ;%NWL%}%NWL%var attrs , id , order ; %NWL%var models =  [  ]  ; %NWL%var columns = json . columns || [  ]  ; %NWL%var ordering = json . ordering || [  ]  ; %NWL%9
var RequireEnsurePlugin = require (  "  .  / dependencies / RequireEnsurePlugin "  )  ; %NWL%var RequireIncludePlugin = require (  "  .  / dependencies / RequireIncludePlugin "  )  ; %NWL%var RemoveParentModulesPlugin = require (  "  .  / optimize / RemoveParentModulesPlugin "  )  ; %NWL%var RemoveEmptyChunksPlugin = require (  "  .  / optimize / RemoveEmptyChunksPlugin "  )  ; %NWL%var MergeDuplicateChunksPlugin = require (  "  .  / optimize / MergeDuplicateChunksPlugin "  )  ; %NWL%var FlagIncludedChunksPlugin = require (  "  .  / optimize / FlagIncludedChunksPlugin "  )  ; %NWL%var UnsafeCachePlugin = require (  " enhanced - resolve / lib / UnsafeCachePlugin "  )  ; %NWL%var ModulesInDirectoriesPlugin = require (  " enhanced - resolve / lib / ModulesInDirectoriesPlugin "  )  ; %NWL%var ModulesInRootPlugin = require (  " enhanced - resolve / lib / ModulesInRootPlugin "  )  ; %NWL%var ModuleTemplatesPlugin = require (  " enhanced - resolve / lib / ModuleTemplatesPlugin "  )  ; %NWL%var ModuleAsFilePlugin = require (  " enhanced - resolve / lib / ModuleAsFilePlugin "  )  ; %NWL%6
var compass = require (  ' gulp - compass '  )  ; %NWL%var path = require (  ' path '  )  ; %NWL%var autoprefixer = require (  ' gulp - autoprefixer '  )  ; %NWL%var foreach = require (  ' gulp - foreach '  )  ; %NWL%var del = require (  ' del '  )  ; %NWL%var i18n_replace = require (  '  .  / gulp_scripts / i18n_replace '  )  ; %NWL%var closureCompiler = require (  ' gulp - closure - compiler '  )  ; %NWL%var mergeStream = require (  ' merge - stream '  )  ; %NWL%var argv = require (  ' yargs '  )  . argv ; %NWL%var replace = require (  ' gulp - replace '  )  ; %NWL%var newer = require (  ' gulp - newer '  )  ; %NWL%0
this . assertEqual (  ' TEXTAREA '  , textar . _ . tagName )  ; %NWL%this . assertEqual (  ' SELECT '  ,  select . _ . tagName )  ;%NWL%}  ,%NWL%testInstanceWithoutTag : function (  )  {%NWL%var input  = new Input (  )  ; %NWL%var chck  = new Input (  { type :  ' checkbox '  }  )  ; %NWL%var radio  = new Input (  { type :  ' radio '  }  )  ; %NWL%var hidd  = new Input (  { type :  ' hidden '  }  )  ; %NWL%var butt  = new Input (  { type :  ' button '  }  )  ; %NWL%var texta  = new Input (  { type :  ' textarea '  }  )  ; %NWL%var select = new Input (  { type :  ' select '  }  )  ; %NWL%6
$scope . betterParseInt ( $scope . numLarge )  + $scope . betterParseInt ( $scope . numXLarge )  +%NWL%$scope . betterParseInt ( $scope . num2XLarge )  + $scope . betterParseInt ( $scope . num3XLarge )  +%NWL%$scope . betterParseInt ( $scope . num4XLarge )  + $scope . betterParseInt ( $scope . num5XLarge )  )  ;%NWL%}  ; %NWL%$scope . allCalculations = function (  )  {%NWL%var numFrontColors = parseInt ( $scope . numFrontImprintColors , 10 )  ; %NWL%var numBackColors = parseInt ( $scope . numBackImprintColors , 10 )  ; %NWL%var darkColor = $scope . color . dark ; %NWL%var shirtCharge = $scope . shirt . cost ; %NWL%var num2XL = $scope . betterParseInt ( $scope . num2XLarge )  ; %NWL%var num3XL = $scope . betterParseInt ( $scope . num3XLarge )  ; %NWL%9
assert . deepEqual ( doc . fans [ 2 ]  . toObject (  )  , user3 . toObject (  )  )  ; %NWL%var user4 = user (  ' user4 '  )  ; %NWL%doc . fans . nonAtomicPush ( user4 )  ; %NWL%assert . deepEqual ( doc . fans [ 3 ]  . toObject (  )  , user4 . toObject (  )  )  ; %NWL%var user5 = user (  ' user5 '  )  ; %NWL%doc . fans . splice ( 2 , 1 , user5 )  ; %NWL%assert . deepEqual ( doc . fans [ 2 ]  . toObject (  )  , user5 . toObject (  )  )  ; %NWL%var user6 = user (  ' user6 '  )  ; %NWL%doc . fans . unshift ( user6 )  ; %NWL%assert . deepEqual ( doc . fans [ 0 ]  . toObject (  )  , user6 . toObject (  )  )  ; %NWL%var user7 = user (  ' user7 '  )  ; %NWL%1
}%NWL%dojox . storage . put (  " justDebugged "  , dojo . config . isDebug , null ,%NWL%dojox . off . STORAGE_NAMESPACE )  ; %NWL%callback ( false ,  [  ]  )  ;%NWL%}%NWL%}  )  ;%NWL%}  ,%NWL%_getVersionInfo : function ( callback )  {%NWL%var justDebugged = dojox . storage . get (  " justDebugged "  ,%NWL%dojox . off . STORAGE_NAMESPACE )  ; %NWL%var oldVersion = dojox . storage . get (  " oldVersion "  ,%NWL%8
var oop = require (  "  .  .  / lib / oop "  )  ; %NWL%var TextHighlightRules = require (  "  .  / text_highlight_rules "  )  . TextHighlightRules ; %NWL%var constantOtherSymbol = exports . constantOtherSymbol =  {%NWL%token :  " constant . other . symbol . ruby "  ,  /  / symbol%NWL%regex :  "  [  :  ]  ( ? :  [ A - Za - z_ ] | [ @$ ]  ( ? =  [ a - zA - Z0 - 9_ ]  )  )  [ a - zA - Z0 - 9_ ]  *  [ ! = ? ] ? "%NWL%}  ; %NWL%var qString = exports . qString =  {%NWL%token :  " string "  ,  /  / single line%NWL%regex :  "  [  '  ]  ( ? :  ( ? : \\\\ .  ) | ( ? :  [ ^ ' \\\\ ]  )  )  * ? [  '  ]  "%NWL%}  ; %NWL%var qqString = exports . qqString =  {%NWL%2
area -  = a . y * b . x ;%NWL%}%NWL%area *  = 0 . 5 ; %NWL%return area ;%NWL%}  ,%NWL%getBoundingCircle : function (  )  {%NWL%var Circle = require (  '  .  / Circle '  )  ; %NWL%return Circle . newBoundingCircle ( this . vertices )  ;%NWL%}  ,%NWL%getBounds : function (  )  {%NWL%var Rect = require (  '  .  / Rect '  )  ; %NWL%6
}%NWL%}  ; %NWL%computeTotal (  [ this . get (  ' rootNode '  )  ]  )  ; %NWL%return total ;%NWL%}  )  . property (  ' rootNode '  )  ,%NWL%adjustXScaleRange : Ember . on (  ' init '  , Ember . observer ( function (  )  {%NWL%this . get (  ' xScale '  )  . range (  [ 0 , this . get (  ' barsWidth '  )  ]  )  ;%NWL%}  ,  ' barsWidth '  )  )  ,%NWL%adjustYScaleRange : Ember . on (  ' init '  , Ember . observer ( function (  )  {%NWL%let rowHeight = this . get (  ' rowHeight '  )  ; %NWL%let rowSpacing = this . get (  ' rowSpacing '  )  ; %NWL%9
var descriptions = this . model . get (  " tableDescription "  ) || [  ]  ; %NWL%_ . each ( descriptions , function ( description )  { description . subType =  ' table_description '  ;  }  )  ; %NWL%return descriptions ;%NWL%}  ,%NWL%getColumns : function (  )  {%NWL%var columns = this . model . get (  " columns "  ) || [  ]  ; %NWL%_ . each ( columns , function ( column )  { column . subType =  ' column '  ;  }  )  ; %NWL%return columns ;%NWL%}  ,%NWL%getColumnDescriptions : function (  )  {%NWL%var columnDescriptions = this . model . get (  " columnDescriptions "  ) || [  ]  ; %NWL%5
var url = require (  ' url '  )  ; %NWL%var cicada = require (  ' cicada '  )  ; %NWL%var normalizeBrowsers = require (  ' normalize - browser - names '  )  ; %NWL%var verify = function ( info , cb )  { cb (  )  }  ; %NWL%var mkdirp = require (  ' mkdirp '  )  ; %NWL%var through = require (  ' through '  )  ; %NWL%var createHandle = require (  '  .  / handle . js '  )  ; %NWL%var checkPackage = require (  '  .  / check_package . js '  )  ; %NWL%var prepare = require (  '  .  / prepare . js '  )  ; %NWL%var compile = require (  '  .  / compile . js '  )  ; %NWL%var visit = require (  '  .  / visit . js '  )  ; %NWL%8
}  ,%NWL%save : function ( store , commitDetails )  {%NWL%var relationships = commitDetails . relationships ; %NWL%relationships . forEach ( function ( relationship )  {%NWL%var child = relationship . getChild (  )  ,%NWL%oldParent = relationship . getOldParent (  )  ,%NWL%newParent = relationship . getNewParent (  )  ; %NWL%if ( child =  =  = undefined || !this . any ( child , commitDetails )  )  {%NWL%this . updateChildRelationship ( store , relationship )  ;%NWL%}%NWL%if ( oldParent =  =  = undefined || !this . any ( oldParent , commitDetails )  )  {%NWL%7
}  )  ;%NWL%}%NWL%INModelObject . prototype . update = function ( data )  {%NWL%if ( !data ) return ; %NWL%var mapping = this . resourceMapping ; %NWL%var updated = data [  ' __converted_from_raw__ '  ] || false ; %NWL%forEach ( mapping , function copyMappedProperties ( mappingInfo , propertyName )  {%NWL%var cast = mappingInfo . to ; %NWL%var merge = mappingInfo . merge ; %NWL%var jsonKey = mappingInfo . jsonKey ; %NWL%var cnst = mappingInfo . cnst ; %NWL%8
{ args :  ' user_42 , group_51 '  , expected :  ' user_42 , group_51 '  }  ,%NWL%{ args :  [  ' user_42 '  ,  ' group_51 '  ]  , expected :  ' user_42 , group_51 '  }  ,%NWL%{ args :  [  ' user_42 '  ,  [  ' group_50 '  ,  ' group_51 '  ]  ]  , expected :  ' user_42 ,  ( group_50 , group_51 )  '  }%NWL%]  ; %NWL%t . plan ( 1 + testCases . length )  ; %NWL%var fauxJax = require (  ' faux - jax '  )  ; %NWL%var parse = require (  ' url - parse '  )  ; %NWL%var createFixture = require (  '  .  .  /  .  .  /  .  .  / utils / create - fixture '  )  ; %NWL%var fixture = createFixture (  )  ; %NWL%var client = fixture . client ; %NWL%var index = fixture . index ; %NWL%9
}  )  ; %NWL%var LogicALL = declare (  " dojox . grid . enhanced . plugins . filter . LogicALL "  , exprs . _OperatorExpr ,  {%NWL%_name :  " all "  ,%NWL%applyRow : function ( datarow , getter )  {%NWL%for ( var i = 0 , res = true ; res && ( this . _operands [ i ] instanceof exprs . _ConditionExpr )  ;  +  + i )  {%NWL%res = this . _operands [ i ]  . applyRow ( datarow , getter )  . getValue (  )  ;%NWL%}%NWL%return new exprs . BooleanExpr ( res )  ; 	 /  / _ConditionExpr%NWL%}%NWL%}  )  ; %NWL%var LogicANY = declare (  " dojox . grid . enhanced . plugins . filter . LogicANY "  , exprs . _OperatorExpr ,  {%NWL%1
}  )  )  ; %NWL%it (  ' should create table header titles '  , function (  )  {%NWL%var thead = elm . find (  ' thead '  )  ; %NWL%var rows = thead . find (  ' tr '  )  ; %NWL%var titles = angular . element ( rows [ 0 ]  )  . find (  ' th '  )  ; %NWL%expect ( angular . element ( titles [ 0 ]  )  . attr (  ' title '  )  . trim (  )  )  . toBe (  ' Sort by Name '  )  ; %NWL%expect ( angular . element ( titles [ 1 ]  )  . attr (  ' title '  )  . trim (  )  )  . toBe (  ' Sort by Age '  )  ; %NWL%expect ( angular . element ( titles [ 2 ]  )  . attr (  ' title '  )  . trim (  )  )  . toBe (  ' Sort by Money '  )  ;%NWL%}  )  ; %NWL%it (  ' should show data - title - text '  , inject ( function ( NgTableParams )  {%NWL%var tbody = elm . find (  ' tbody '  )  ; %NWL%2
}%NWL%categories . sort (  )  ; %NWL%list . appendChild ( render (  ' Random Pony '  ,%NWL%' ponies / random%20pony / random - pony . gif '  , 0 , categories )  )  ; %NWL%for ( var i = 0 , n = names . length ; i < n ;  +  + i )  {%NWL%var pony = ponies [ names [ i ]  ]  ; %NWL%list . appendChild ( render ( pony . name , pony . all_behaviors [ 0 ]  . rightimage ,%NWL%pony . instances . length , pony . categories )  )  ;%NWL%}%NWL%var catselect = $ (  ' catselect '  )  ; %NWL%var catlist  = $ (  ' catlist '  )  ; %NWL%9
var inIn  = this . inputs [ 0 ]  ; %NWL%var next_srclo = this . inputs [ 1 ]  [ 0 ] || 0 . 001 ; %NWL%var next_srchi = this . inputs [ 2 ]  [ 0 ] || 0 . 001 ; %NWL%var next_dstlo = this . inputs [ 3 ]  [ 0 ] || 0 . 001 ; %NWL%var next_dsthi = this . inputs [ 4 ]  [ 0 ] || 0 . 001 ; %NWL%var srclo = this . _srclo ; %NWL%var srchi = this . _srchi ; %NWL%var dstlo = this . _dstlo ; %NWL%var dsthi = this . _dsthi ; %NWL%var x = this . _x ; %NWL%var y = this . _y ; %NWL%5
startButton . disabled = true ; %NWL%stopButton . disabled = false ; %NWL%video . lastSeekTime = video . currentTime ;%NWL%}%NWL%}%NWL%function computeWaitingTimeFromBuffer ( v )  {%NWL%var ms = v . ms ; %NWL%var sb ; %NWL%var startRange , endRange ; %NWL%var currentTime = v . currentTime ; %NWL%var playbackRate = v . playbackRate ; %NWL%6
var me = this ; %NWL%var destroyBeforeAppend = treeRequest . get (  ' destroyBeforeAppend '  )  ; %NWL%var url = treeRequest . get (  ' url '  )  ; %NWL%var isLeaf = treeRequest . get (  ' isLeaf '  )  ; %NWL%var enableCheckSelection = treeRequest . get (  ' enableCheckedItems '  )  ; %NWL%var nodeToAppendTo = treeRequest . get (  ' nodeToAppendTo '  )  ; %NWL%var nodeType = treeRequest . get (  ' nodeType '  )  ; %NWL%var expanded = treeRequest . get (  ' expanded '  )  ; %NWL%var expandable = treeRequest . get (  ' expandable '  )  ; %NWL%var callbackFunc = treeRequest . get (  ' callbackFunc '  )  ; %NWL%var callbackScope = treeRequest . get (  ' callbackScope '  )  ; %NWL%1
d3 . select ( planet . canvas )  . call ( zoom )  ;%NWL%}  )  ;%NWL%}  ;%NWL%}  ; %NWL%planetaryjs . plugins . drag = function ( options )  {%NWL%options = options || {  }  ; %NWL%var noop = function (  )  {  }  ; %NWL%var onDragStart = options . onDragStart || noop ; %NWL%var onDragEnd  = options . onDragEnd || noop ; %NWL%var onDrag   = options . onDrag  || noop ; %NWL%var afterDrag  = options . afterDrag || noop ; %NWL%8
}%NWL%function applyDepthTest ( gl , renderState )  {%NWL%var depthTest = renderState . depthTest ; %NWL%var enabled = depthTest . enabled ; %NWL%enableOrDisable ( gl , gl . DEPTH_TEST , enabled )  ; %NWL%if ( enabled )  {%NWL%gl . depthFunc ( depthTest . func )  ;%NWL%}%NWL%}%NWL%function applyColorMask ( gl , renderState )  {%NWL%var colorMask = renderState . colorMask ; %NWL%2
if ( window . getComputedStyle )  {%NWL%ret = document . defaultView . getComputedStyle ( elem , null )  . getPropertyValue ( prop )%NWL%} else if ( elem . currentStyle )  {%NWL%ret = elem . currentStyle [ prop ]%NWL%}%NWL%return ret%NWL%}%NWL%return {%NWL%ruby :  ( function (  )  {%NWL%var ruby = $ . create (  ' ruby '  )%NWL%var rt = $ . create (  ' rt '  )%NWL%9
if ( expired && !inst . _expiring )  {%NWL%inst . _expiring = true ; %NWL%if ( this . _hasTarget ( target ) || this . _get ( inst ,  ' alwaysExpire '  )  )  {%NWL%this . _removeTarget ( target )  ; %NWL%var onExpiry = this . _get ( inst ,  ' onExpiry '  )  ; %NWL%if ( onExpiry )  {%NWL%onExpiry . apply ( target ,  [  ]  )  ;%NWL%}%NWL%var expiryText = this . _get ( inst ,  ' expiryText '  )  ; %NWL%if ( expiryText )  {%NWL%var layout = this . _get ( inst ,  ' layout '  )  ; %NWL%4
var left = this . get (  ' left '  )  ; %NWL%return formatter ? formatter ( left )  : left ;%NWL%}  )  ,%NWL%rightDisplay : Ember . computed (  ' right '  ,  ' formatter '  , function (  )  {%NWL%var formatter = this . get (  ' formatter '  )  ; %NWL%var right = this . get (  ' right '  )  ; %NWL%return formatter ? formatter ( right )  : right ;%NWL%}  )  ,%NWL%isVisible : Ember . computed (  ' left '  ,  ' right '  , function (  )  {%NWL%var left =  + this . get (  ' left '  )  ; %NWL%var right =  + this . get (  ' right '  )  ; %NWL%9
}%NWL%$ (  "  . btn "  , this . el )  . removeClass (  " disabled "  )  ; %NWL%this . loader . hide (  )  ; %NWL%this . contentScrollApi . reinitialise (  )  ; %NWL%this . contentScrollApi . scrollToPercentX ( 0 . 5 )  ; %NWL%this . contentScrollApi . scrollToPercentY ( 0 . 5 )  ; %NWL%return this ;%NWL%}  ,%NWL%fetchFlows : function (  )  {%NWL%var interval = this . timelineModel . get (  " interval "  )  ; %NWL%var bucket_size = this . timelineModel . get (  " bucket_size "  )  ; %NWL%9
}%NWL%}%NWL%args . push ( callback )  ;  /  / Add the callback function as the last argument .%NWL%f . apply ( fs , args )  ;  /  / raw node doesn ' t need fs to be passed for ' this ' but%NWL%return d . promise ;%NWL%}  ; %NWL%pf . name = fname ; %NWL%return pf ;%NWL%}%NWL%var stat = promisedFunction (  ' stat '  )  ; %NWL%var unlink = promisedFunction (  ' unlink '  )  ; %NWL%9
return tldRE ;  /  / String%NWL%}%NWL%dojox . regexp . ipAddress = function ( flags )  {%NWL%flags =  ( typeof flags =  =  " object "  ) ? flags :  {  }  ; %NWL%if ( typeof flags . allowDottedDecimal ! =  " boolean "  )  { flags . allowDottedDecimal = true ;  }%NWL%if ( typeof flags . allowDottedHex ! =  " boolean "  )  { flags . allowDottedHex = true ;  }%NWL%if ( typeof flags . allowDottedOctal ! =  " boolean "  )  { flags . allowDottedOctal = true ;  }%NWL%if ( typeof flags . allowDecimal ! =  " boolean "  )  { flags . allowDecimal = true ;  }%NWL%if ( typeof flags . allowHex ! =  " boolean "  )  { flags . allowHex = true ;  }%NWL%if ( typeof flags . allowIPv6 ! =  " boolean "  )  { flags . allowIPv6 = true ;  }%NWL%if ( typeof flags . allowHybrid ! =  " boolean "  )  { flags . allowHybrid = true ;  }%NWL%4
var rpc_options = require (  '  .  / test_rpc_options . js '  )  ; %NWL%var rpc_progress = require (  '  .  / test_rpc_progress . js '  )  ; %NWL%var rpc_slowsquare = require (  '  .  / test_rpc_slowsquare . js '  )  ; %NWL%var rpc_routing = require (  '  .  / test_rpc_routing . js '  )  ; %NWL%var rpc_caller_disclose_me = require (  '  .  / test_rpc_caller_disclose_me . js '  )  ; %NWL%var pubsub_basic = require (  '  .  / test_pubsub_basic . js '  )  ; %NWL%var pubsub_complex = require (  '  .  / test_pubsub_complex . js '  )  ; %NWL%var pubsub_options = require (  '  .  / test_pubsub_options . js '  )  ; %NWL%var pubsub_excludme = require (  '  .  / test_pubsub_excludeme . js '  )  ; %NWL%var pubsub_exclude = require (  '  .  / test_pubsub_exclude . js '  )  ; %NWL%var pubsub_eligible = require (  '  .  / test_pubsub_eligible . js '  )  ; %NWL%0
var http  = require (  ' http '  )  ; %NWL%var config = CONF . server ; %NWL%function setup (  )  {%NWL%return {%NWL%port : process . env . PORT || config . port || 4000 ,%NWL%host : config . host || ' 127 . 0 . 0 . 1 '%NWL%}  ;%NWL%}%NWL%function server ( app , conf )  {%NWL%var host = conf . host ; %NWL%var port = conf . port ; %NWL%9
}  , 100 )  ;%NWL%}  )  ;%NWL%}  )  ;%NWL%}%NWL%}%NWL%exports . shouldFailToValidateServerSSLCertificate =  {%NWL%metadata :  { requires :  { topology :  ' ssl '  }  }  ,%NWL%test : function ( configuration , test )  {%NWL%var ReplSetManager = require (  ' mongodb - tools '  )  . ReplSetManager%NWL%, Db = configuration . require . Db%NWL%, Server = configuration . require . Server%NWL%9
var mCSB_dragger = mCSB_draggerContainer . children (  "  . mCSB_dragger "  )  ; %NWL%if ( $this . data (  " horizontalScroll "  )  )  {%NWL%var mCSB_buttonLeft = mCSB_scrollTools . children (  "  . mCSB_buttonLeft "  )  ; %NWL%var mCSB_buttonRight = mCSB_scrollTools . children (  "  . mCSB_buttonRight "  )  ; %NWL%var mCustomScrollBoxW = mCustomScrollBox . width (  )  ; %NWL%if ( $this . data (  " autoExpandHorizontalScroll "  )  )  {%NWL%mCSB_container . css (  {  " position "  :  " absolute "  ,  " width "  :  " auto "  }  )  . wrap (  "  < div class =  ' mCSB_h_wrapper ' style =  ' position : relative ; left : 0 ; width : 999999px ;  '  /  >  "  )  . css (  {  " width "  : mCSB_container . outerWidth (  )  ,  " position "  :  " relative "  }  )  . unwrap (  )  ;%NWL%}%NWL%var mCSB_containerW = mCSB_container . outerWidth (  )  ;%NWL%} else {%NWL%var mCSB_buttonUp = mCSB_scrollTools . children (  "  . mCSB_buttonUp "  )  ; %NWL%2
var spriteTable = null ; %NWL%var palettes =  [  ]  ; %NWL%var currentFile = null ; %NWL%self . init = function ( config )  {%NWL%var div = document . createElement (  ' div '  )  ; %NWL%div . className =  ' section '  ; %NWL%var h2 = document . createElement (  ' h2 '  )  ; %NWL%h2 . appendChild ( document . createTextNode (  ' Input '  )  )  ; %NWL%div . appendChild ( h2 )  ; %NWL%var wrap = document . createElement (  ' div '  )  ; %NWL%var span = document . createElement (  ' span '  )  ; %NWL%4