tape ( " pow . domain ( ) returns a copy of domain values " , function ( test )  {%NWL%var s = scale . scalePow ( ) , d = s . domain ( ) ;%NWL%test . deepEqual ( d ,  [ 0 , 1 ] ) ;%NWL%d . push ( 3 ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( range ) does not coerce range to numbers " , function ( test )  {%NWL%var s = scale . scalePow ( ) . range ( [ " 0px " ,  " 2px " ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ " 0px " ,  " 2px " ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( s . range ( ) ,  [ " 0px " ,  " 2px " ] ) ;%NWL%test . equal ( s ( 0 . 5 ) ,  " 1px " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( range ) can accept range values as colors " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . range ( [ " red " ,  " blue " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " #f00 " ,  " #00f " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " rgb ( 255 , 0 , 0 ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " rgb ( 100% , 0% , 0% ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( scale . scalePow ( ) . range ( [ " red " ,  " blue " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " #f00 " ,  " #00f " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " rgb ( 255 , 0 , 0 ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " rgb ( 100% , 0% , 0% ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ " hsl ( 0 , 100% , 50% ) " ,  " hsl ( 240 , 100% , 50% ) " ] ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( range ) can accept range values as arrays or objects " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . range ( [ { color: " red " } ,  { color: " blue " } ] ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 0 , 128 ) " } ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( range ) can accept range values as arrays or objects " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . range ( [ { color: " red " } ,  { color: " blue " } ] ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 0 , 128 ) " } ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . range ( [ [ " red " ] ,  [ " blue " ] ] ) ( 0 . 5 ) ,  [ " rgb ( 128 , 0 , 128 ) " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scalePow ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%9
tape ( " pow . range ( range ) can accept range values as arrays or objects " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . range ( [ { color: " red " } ,  { color: " blue " } ] ) ( 0 . 5 ) ,  { color: " rgb ( 128 , 0 , 128 ) " } ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . range ( [ [ " red " ] ,  [ " blue " ] ] ) ( 0 . 5 ) ,  [ " rgb ( 128 , 0 , 128 ) " ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scalePow ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scalePow ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( r ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var s = scale . scalePow ( ) , r = s . range ( ) ;%NWL%3
tape ( " pow . range ( range ) makes a copy of range values " , function ( test )  {%NWL%var r = [ 1 , 2 ] , s = scale . scalePow ( ) . range ( r ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( r ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( ) returns a copy of range values " , function ( test )  {%NWL%var s = scale . scalePow ( ) , r = s . range ( ) ;%NWL%r . push ( 3 ) ;%NWL%3
test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( r ,  [ 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( ) returns a copy of range values " , function ( test )  {%NWL%var s = scale . scalePow ( ) , r = s . range ( ) ;%NWL%test . deepEqual ( r ,  [ 0 , 1 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . range ( ) returns a copy of range values " , function ( test )  {%NWL%var s = scale . scalePow ( ) , r = s . range ( ) ;%NWL%test . deepEqual ( r ,  [ 0 , 1 ] ) ;%NWL%r . push ( 3 ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . rangeRound ( range ) is an alias for pow . range ( range ) . interpolate ( interpolateRound ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " pow . rangeRound ( range ) is an alias for pow . range ( range ) . interpolate ( interpolateRound ) " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . rangeRound ( [ 0 , 10 ] ) ( 0 . 59 ) , 6 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . clamp ( ) is false by default " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . clamp ( ) , false ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) ( 2 ) , 30 ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) ( - 1 ) , 0 ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " pow . clamp ( ) is false by default " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . clamp ( ) , false ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) ( 2 ) , 30 ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) ( - 1 ) , 0 ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 2 ) ;%NWL%test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) . invert ( 0 ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . clamp ( true ) restricts output values to the range " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) ( 2 ) , 20 ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( scale . scalePow ( ) . range ( [ 10 , 20 ] ) . invert ( 0 ) ,  - 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . clamp ( true ) restricts output values to the range " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) ( 2 ) , 20 ) ;%NWL%test . equal ( scale . scalePow ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) ( - 1 ) , 10 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . clamp ( true ) restricts input values to the domain " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " pow . clamp ( true ) restricts input values to the domain " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) . invert ( 30 ) , 1 ) ;%NWL%test . equal ( scale . scalePow ( ) . clamp ( true ) . range ( [ 10 , 20 ] ) . invert ( 0 ) , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . clamp ( clamp ) coerces the specified clamp value to a boolean " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . clamp ( " true " ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scalePow ( ) . clamp ( 1 ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scalePow ( ) . clamp ( " " ) . clamp ( ) , false ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( scale . scalePow ( ) . clamp ( " true " ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scalePow ( ) . clamp ( 1 ) . clamp ( ) , true ) ;%NWL%test . equal ( scale . scalePow ( ) . clamp ( " " ) . clamp ( ) , false ) ;%NWL%test . equal ( scale . scalePow ( ) . clamp ( 0 ) . clamp ( ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . interpolate ( interpolate ) takes a custom interpolator factory " , function ( test )  {%NWL%function interpolate ( a , b )  { return function ( t )  { return [ a , b , t ] ; } ; }%NWL%var s = scale . scalePow ( ) . domain ( [ 10 , 20 ] ) . range ( [ " a " ,  " b " ] ) . interpolate ( interpolate ) ;%NWL%test . equal ( s . interpolate ( ) , interpolate ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " pow . interpolate ( interpolate ) takes a custom interpolator factory " , function ( test )  {%NWL%function interpolate ( a , b )  { return function ( t )  { return [ a , b , t ] ; } ; }%NWL%var s = scale . scalePow ( ) . domain ( [ 10 , 20 ] ) . range ( [ " a " ,  " b " ] ) . interpolate ( interpolate ) ;%NWL%test . equal ( s . interpolate ( ) , interpolate ) ;%NWL%test . deepEqual ( s ( 15 ) ,  [ " a " ,  " b " , 0 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( ) is an alias for pow . nice ( 10 ) " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 , 0 . 96 ] ) . nice ( ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( count ) extends the domain to match the desired ticks " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 , 0 . 96 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 , 96 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 100 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 . 96 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 0 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 96 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ 100 , 0 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 ,  - 0 . 96 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 ,  - 1 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 ,  - 96 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 ,  - 100 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ - 0 . 96 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ - 1 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 ,  - 96 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 ,  - 100 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ - 0 . 96 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ - 1 , 0 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ - 96 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ - 100 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( count ) nices the domain , extending it to round numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 1 . 1 , 10 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 11 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 10 . 9 , 1 . 1 ] ) . nice ( 10 ) . domain ( ) ,  [ 11 , 1 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 . 7 , 11 . 001 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 12 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 123 . 1 , 6 . 7 ] ) . nice ( 10 ) . domain ( ) ,  [ 130 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " pow . nice ( count ) nices the domain , extending it to round numbers " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 1 . 1 , 10 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 11 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 10 . 9 , 1 . 1 ] ) . nice ( 10 ) . domain ( ) ,  [ 11 , 1 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 . 7 , 11 . 001 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 12 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 123 . 1 , 6 . 7 ] ) . nice ( 10 ) . domain ( ) ,  [ 130 , 0 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 , 0 . 49 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( count ) has no effect on degenerate domains " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 , 0 . 49 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( count ) has no effect on degenerate domains " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 , 0 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 , 0 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 0 . 5 , 0 . 5 ] ) . nice ( 10 ) . domain ( ) ,  [ 0 . 5 , 0 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( count ) nicing a polypow domain only affects the extent " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 1 . 1 , 1 , 2 , 3 , 10 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 1 , 2 , 3 , 11 ] ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( count ) nicing a polypow domain only affects the extent " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 1 . 1 , 1 , 2 , 3 , 10 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 1 , 1 , 2 , 3 , 11 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 123 . 1 , 1 , 2 , 3 ,  - 0 . 9 ] ) . nice ( 10 ) . domain ( ) ,  [ 130 , 1 , 2 , 3 ,  - 10 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . nice ( count ) accepts a tick count to control nicing step " , function ( test )  {%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 12 , 87 ] ) . nice ( 5 ) . domain ( ) ,  [ 0 , 100 ] ) ;%NWL%test . deepEqual ( scale . scalePow ( ) . domain ( [ 12 , 87 ] ) . nice ( 10 ) . domain ( ) ,  [ 10 , 90 ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( s . ticks ( 3 ) ,  [ - 100 ,       - 50 ,      0 ,     50 ,     100 ] ) ;%NWL%test . deepEqual ( s . ticks ( 2 ) ,  [ - 100 ,              0 ,           100 ] ) ;%NWL%test . deepEqual ( s . ticks ( 1 ) ,  [                0             ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . ticks ( count ) returns the empty array if count is not a positive integer " , function ( test )  {%NWL%var s = scale . scalePow ( ) ;%NWL%test . deepEqual ( s . ticks ( NaN ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( 0 ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( - 1 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " pow . ticks ( count ) returns the empty array if count is not a positive integer " , function ( test )  {%NWL%var s = scale . scalePow ( ) ;%NWL%test . deepEqual ( s . ticks ( NaN ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( 0 ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( - 1 ) ,  [ ] ) ;%NWL%test . deepEqual ( s . ticks ( Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . ticks ( ) is an alias for pow . ticks ( 10 ) " , function ( test )  {%NWL%var s = scale . scalePow ( ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( s . ticks ( Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . ticks ( ) is an alias for pow . ticks ( 10 ) " , function ( test )  {%NWL%var s = scale . scalePow ( ) ;%NWL%test . deepEqual ( s . ticks ( ) , s . ticks ( 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . tickFormat ( ) is an alias for pow . tickFormat ( 10 ) " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . tickFormat ( ) is an alias for pow . tickFormat ( 10 ) " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 100 , 100 ] ) . tickFormat ( ) ( - 20 ) ,  " - 20 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . tickFormat ( count ) returns a format suitable for the ticks " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( 10 ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( 20 ) ( 0 . 2 ) ,  " 0 . 20 " ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " pow . tickFormat ( count ) returns a format suitable for the ticks " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( 10 ) ( 0 . 2 ) ,  " 0 . 2 " ) ;%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( 20 ) ( 0 . 2 ) ,  " 0 . 20 " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ - 100 , 100 ] ) . tickFormat ( 10 ) ( - 20 ) ,  " - 20 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . tickFormat ( count , specifier ) sets the appropriate fixed precision if not specified " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( 10 ,  " + f " ) ( 0 . 2 ) ,  " + 0 . 2 " ) ;%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( 20 ,  " + f " ) ( 0 . 2 ) ,  " + 0 . 20 " ) ;%NWL%test . equal ( scale . scalePow ( ) . tickFormat ( 10 ,  " + % " ) ( 0 . 2 ) ,  " + 20% " ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( scale . scalePow ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 100 ,  " g " ) ( 2 . 11 ) ,  " 2 . 1 " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 10 ,  " r " ) ( 2 . 10e6 ) ,  " 2000000 " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 100 ,  " r " ) ( 2 . 01e6 ) ,  " 2000000 " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 0 , 9 ] ) . tickFormat ( 100 ,  " r " ) ( 2 . 11e6 ) ,  " 2100000 " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 0 , 0 . 9 ] ) . tickFormat ( 10 ,  " p " ) ( 0 . 210 ) ,  " 20% " ) ;%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 0 . 19 , 0 . 21 ] ) . tickFormat ( 10 ,  " p " ) ( 0 . 201 ) ,  " 20 . 1% " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . tickFormat ( count , specifier ) sets the appropriate prefix precision if not specified " , function ( test )  {%NWL%test . equal ( scale . scalePow ( ) . domain ( [ 0 , 1e6 ] ) . tickFormat ( 10 ,  " $s " ) ( 0 . 51e6 ) ,  " $0 . 5M " ) ;%NWL%test . end ( ) ;%NWL%6
x . domain ( [ 1 , 2 ] ) ;%NWL%test . deepEqual ( y . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%test . equal ( x ( 1 ) , 0 ) ;%NWL%test . equal ( y ( 1 ) , 1 ) ;%NWL%y . domain ( [ 2 , 3 ] ) ;%NWL%test . equal ( x ( 2 ) , 1 ) ;%NWL%test . equal ( y ( 2 ) , 0 ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%test . deepEqual ( y . domain ( ) ,  [ 2 , 3 ] ) ;%NWL%y = x . domain ( [ 1 , 1 . 9 ] ) . copy ( ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ 1 , 2 ] ) ;%NWL%7
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . copy ( ) returns a copy with changes to the interpolator are isolated " , function ( test )  {%NWL%var x = scale . scalePow ( ) . range ( [ " red " ,  " blue " ] ) ,%NWL%y = x . copy ( ) ,%NWL%i0 = x . interpolate ( ) ,%NWL%i1 = function ( a , b )  { return function ( )  { return b; } ; } ;%NWL%x . interpolate ( i1 ) ;%NWL%test . equal ( y . interpolate ( ) , i0 ) ;%NWL%test . equal ( x ( 0 . 5 ) ,  " blue " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( x ( 0 . 5 ) ,  " blue " ) ;%NWL%test . equal ( y ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow . copy ( ) returns a copy with changes to clamping are isolated " , function ( test )  {%NWL%var x = scale . scalePow ( ) . clamp ( true ) , y = x . copy ( ) ;%NWL%x . clamp ( false ) ;%NWL%test . equal ( x ( 2 ) , 2 ) ;%NWL%test . equal ( y ( 2 ) , 1 ) ;%NWL%test . equal ( y . clamp ( ) , true ) ;%NWL%test . equal ( x ( 2 ) , 2 ) ;%NWL%7
test . equal ( y . clamp ( ) , true ) ;%NWL%y . clamp ( false ) ;%NWL%test . equal ( x ( 2 ) , 2 ) ;%NWL%test . equal ( y ( 2 ) , 2 ) ;%NWL%test . equal ( x . clamp ( ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " pow ( ) . clamp ( true ) . invert ( x ) cannot return a value outside the domain " , function ( test )  {%NWL%var x = scale . scalePow ( ) . exponent ( 0 . 5 ) . domain ( [ 1 , 20 ] ) . clamp ( true ) ;%NWL%test . equal ( x . invert ( 0 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " pow ( ) . clamp ( true ) . invert ( x ) cannot return a value outside the domain " , function ( test )  {%NWL%var x = scale . scalePow ( ) . exponent ( 0 . 5 ) . domain ( [ 1 , 20 ] ) . clamp ( true ) ;%NWL%test . equal ( x . invert ( 0 ) , 1 ) ;%NWL%test . equal ( x . invert ( 1 ) , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleSqrt ( ) is an alias for pow ( ) . exponent ( 0 . 5 ) " , function ( test )  {%NWL%var s = scale . scaleSqrt ( ) ;%NWL%test . equal ( s . exponent ( ) , 0 . 5 ) ;%NWL%test . inDelta ( s ( 0 . 5 ) , Math . SQRT1_2 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( s . domain ( ) ,  [ ] ) ;%NWL%test . deepEqual ( s . range ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile ( x ) uses the R - 7 algorithm to compute quantiles " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%6
test . deepEqual ( s . range ( ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile ( x ) uses the R - 7 algorithm to compute quantiles " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%s . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ 1 , 1 ] ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile ( x ) uses the R - 7 algorithm to compute quantiles " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%s . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%6
} ) ;%NWL%tape ( " quantile ( x ) uses the R - 7 algorithm to compute quantiles " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%s . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%6
test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%s . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ 1 , 1 ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile ( x ) returns undefined if the input value is NaN " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile ( x ) returns undefined if the input value is NaN " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . equal ( s ( NaN ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . domain ( ) values are sorted in ascending order " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 6 , 3 , 7 , 8 , 8 , 13 , 20 , 15 , 16 , 10 ] ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( s ( NaN ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . domain ( ) values are sorted in ascending order " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 6 , 3 , 7 , 8 , 8 , 13 , 20 , 15 , 16 , 10 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . domain ( ) values are coerced to numbers " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ " 6 " ,  " 13 " ,  " 20 " ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( s . domain ( ) ,  [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . domain ( ) values are coerced to numbers " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ " 6 " ,  " 13 " ,  " 20 " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 6 , 13 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . domain ( ) values are allowed to be zero " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 1 , 2 , 0 , 0 , null ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( s . domain ( ) ,  [ 6 , 13 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . domain ( ) values are allowed to be zero " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 1 , 2 , 0 , 0 , null ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 0 , 0 , 1 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . domain ( ) non - numeric values are ignored " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 6 , 3 , NaN , undefined , 7 , 8 , 8 , 13 , null , 20 , 15 , 16 , 10 , NaN ] ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " quantile . domain ( ) non - numeric values are ignored " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 6 , 3 , NaN , undefined , 7 , 8 , 8 , 13 , null , 20 , 15 , 16 , 10 , NaN ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . quantiles ( ) returns the inner thresholds " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( s . quantiles ( ) ,  [ 7 . 25 , 9 , 14 . 5 ] ) ;%NWL%s . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( s . quantiles ( ) ,  [ 7 . 25 , 9 , 14 . 5 ] ) ;%NWL%s . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( s . quantiles ( ) ,  [ 7 . 5 , 9 , 14 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . range ( ) cardinality determines the number of quantiles " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) ;%NWL%test . deepEqual ( s . range ( [ 0 , 1 , 2 , 3 ] ) . quantiles ( ) ,  [ 7 . 25 , 9 , 14 . 5 ] ) ;%NWL%test . deepEqual ( s . range ( [ 0 , 1 ] ) . quantiles ( ) ,  [ 9 ] ) ;%NWL%test . deepEqual ( s . range ( [ , , , , , ] ) . quantiles ( ) ,  [ 6 . 8 , 8 , 11 . 2 , 15 . 2 ] ) ;%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . range ( ) values are arbitrary " , function ( test )  {%NWL%var a = { } ,%NWL%b = { } ,%NWL%c = { } ,%NWL%s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ a , b , c , a ] ) ;%NWL%test . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( s ) ,  [ a , a , a , a , a ] ) ;%NWL%test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ b , b ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ c , c , c , c ] ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( [ 8 , 8 . 9 ] . map ( s ) ,  [ b , b ] ) ;%NWL%test . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( s ) ,  [ c , c , c , c ] ) ;%NWL%test . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( s ) ,  [ a , a , a , a , a ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . invertExtent ( ) maps a value in the range to a domain extent " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 0 ) ,  [ 3 , 7 . 25 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 1 ) ,  [ 7 . 25 , 9 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 2 ) ,  [ 9 , 14 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( s . invertExtent ( 1 ) ,  [ 7 . 25 , 9 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 2 ) ,  [ 9 , 14 . 5 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 3 ) ,  [ 14 . 5 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . invertExtent ( ) allows arbitrary range values " , function ( test )  {%NWL%var a = { } ,%NWL%b = { } ,%NWL%s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ a , b ] ) ;%NWL%test . deepEqual ( s . invertExtent ( a ) ,  [ 3 , 9 ] ) ;%NWL%test . end ( ) ;%NWL%3
s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ a , b ] ) ;%NWL%test . deepEqual ( s . invertExtent ( a ) ,  [ 3 , 9 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( b ) ,  [ 9 , 20 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . invertExtent ( ) returns [ NaN , NaN ] when the given value is not in the range " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) ;%NWL%test . ok ( s . invertExtent ( - 1 ) . every ( isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 0 . 5 ) . every ( isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 2 ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%3
test . ok ( s . invertExtent ( - 1 ) . every ( isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 0 . 5 ) . every ( isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 2 ) . every ( isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( ' a ' ) . every ( isNaN ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantile . invertExtent ( ) returns the first match if duplicate values exist in the range " , function ( test )  {%NWL%var s = scale . scaleQuantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 0 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 0 ) ,  [ 3 , 7 . 25 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 1 ) ,  [ 7 . 25 , 9 ] ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( s ( 0 . 75 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize ( value ) maps a number to a discrete value in the range " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) . range ( [ 0 , 1 , 2 ] ) ;%NWL%test . equal ( s ( 0 . 0 ) , 0 ) ;%NWL%test . equal ( s ( 0 . 2 ) , 0 ) ;%NWL%test . equal ( s ( 0 . 4 ) , 1 ) ;%NWL%test . equal ( s ( 0 . 6 ) , 1 ) ;%NWL%test . equal ( s ( 0 . 8 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( s ( 0 . 8 ) , 2 ) ;%NWL%test . equal ( s ( 1 . 0 ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize ( value ) clamps input values to the domain " , function ( test )  {%NWL%var a = { } ,%NWL%b = { } ,%NWL%c = { } ,%NWL%s = scale . scaleQuantize ( ) . range ( [ a , b , c ] ) ;%NWL%test . equal ( s ( - 0 . 5 ) , a ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( s ( - 0 . 5 ) , a ) ;%NWL%test . equal ( s ( + 1 . 5 ) , c ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . domain ( ) coerces domain values to numbers " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) . domain ( [ " - 1 . 20 " ,  " 2 . 40 " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 1 . 2 , 2 . 4 ] ) ;%NWL%test . equal ( s ( - 1 . 2 ) , 0 ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 ) ;%NWL%test . equal ( s ( 0 . 7 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%2
var s = scale . scaleQuantize ( ) . domain ( [ " - 1 . 20 " ,  " 2 . 40 " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 1 . 2 , 2 . 4 ] ) ;%NWL%test . equal ( s ( - 1 . 2 ) , 0 ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 ) ;%NWL%test . equal ( s ( 0 . 7 ) , 1 ) ;%NWL%test . equal ( s ( 2 . 4 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . domain ( ) only considers the first and second element of the domain " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) . domain ( [ - 1 , 100 , 200 ] ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . range ( ) cardinality determines the degree of quantization " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) ;%NWL%test . inDelta ( s . range ( array . range ( 0 , 1 . 001 , 0 . 001 ) ) ( 1 / 3 ) , 0 . 333 , 1e - 6 ) ;%NWL%test . inDelta ( s . range ( array . range ( 0 , 1 . 010 , 0 . 010 ) ) ( 1 / 3 ) , 0 . 330 , 1e - 6 ) ;%NWL%test . inDelta ( s . range ( array . range ( 0 , 1 . 100 , 0 . 100 ) ) ( 1 / 3 ) , 0 . 300 , 1e - 6 ) ;%NWL%test . inDelta ( s . range ( array . range ( 0 , 1 . 200 , 0 . 200 ) ) ( 1 / 3 ) , 0 . 400 , 1e - 6 ) ;%NWL%test . inDelta ( s . range ( array . range ( 0 , 1 . 250 , 0 . 250 ) ) ( 1 / 3 ) , 0 . 250 , 1e - 6 ) ;%NWL%test . inDelta ( s . range ( array . range ( 0 , 1 . 500 , 0 . 500 ) ) ( 1 / 3 ) , 0 . 500 , 1e - 6 ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( s ( 0 . 6 ) , b ) ;%NWL%test . equal ( s ( 0 . 8 ) , c ) ;%NWL%test . equal ( s ( 1 . 0 ) , c ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . invertExtent ( ) maps a value in the range to a domain extent " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 0 ) ,  [ 0 . 00 , 0 . 25 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 1 ) ,  [ 0 . 25 , 0 . 50 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 2 ) ,  [ 0 . 50 , 0 . 75 ] ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( s . invertExtent ( 1 ) ,  [ 0 . 25 , 0 . 50 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 2 ) ,  [ 0 . 50 , 0 . 75 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 3 ) ,  [ 0 . 75 , 1 . 00 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . invertExtent ( ) allows arbitrary range values " , function ( test )  {%NWL%var a = { } ,%NWL%b = { } ,%NWL%s = scale . scaleQuantize ( ) . range ( [ a , b ] ) ;%NWL%test . deepEqual ( s . invertExtent ( a ) ,  [ 0 . 0 , 0 . 5 ] ) ;%NWL%test . end ( ) ;%NWL%3
s = scale . scaleQuantize ( ) . range ( [ a , b ] ) ;%NWL%test . deepEqual ( s . invertExtent ( a ) ,  [ 0 . 0 , 0 . 5 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( b ) ,  [ 0 . 5 , 1 . 0 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . invertExtent ( ) returns [ NaN , NaN ] when the given value is not in the range " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) ;%NWL%test . ok ( s . invertExtent ( - 1 ) . every ( Number . isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 0 . 5 ) . every ( Number . isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 2 ) . every ( Number . isNaN ) ) ;%NWL%test . end ( ) ;%NWL%3
var s = scale . scaleQuantize ( ) ;%NWL%test . ok ( s . invertExtent ( - 1 ) . every ( Number . isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 0 . 5 ) . every ( Number . isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( 2 ) . every ( Number . isNaN ) ) ;%NWL%test . ok ( s . invertExtent ( " a " ) . every ( Number . isNaN ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . invertExtent ( ) returns the first match if duplicate values exist in the range " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) . range ( [ 0 , 1 , 2 , 0 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 0 ) ,  [ 0 . 00 , 0 . 25 ] ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( s . invertExtent ( 0 ) ,  [ 0 . 00 , 0 . 25 ] ) ;%NWL%test . deepEqual ( s . invertExtent ( 1 ) ,  [ 0 . 25 , 0 . 50 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " quantize . invertExtent ( y ) is exactly consistent with quantize ( x ) " , function ( test )  {%NWL%var s = scale . scaleQuantize ( ) . domain ( [ 4 . 2 , 6 . 2 ] ) . range ( array . range ( 10 ) ) ;%NWL%s . range ( ) . forEach ( function ( y )  {%NWL%var e = s . invertExtent ( y ) ;%NWL%test . equal ( s ( e [ 0 ] ) , y ) ;%NWL%test . equal ( s ( e [ 1 ] ) , y < 9 ? y + 1 : y ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( d3 . interpolateRainbow ( 0 . 0 ) ,  " rgb ( 110 , 64 , 170 ) " ) ;%NWL%test . equal ( d3 . interpolateRainbow ( 0 . 5 ) ,  " rgb ( 175 , 240 , 91 ) " ) ;%NWL%test . equal ( d3 . interpolateRainbow ( 1 . 0 ) ,  " rgb ( 110 , 64 , 170 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateRainbow ( t ) cycles t " , function ( test )  {%NWL%for ( var i = - 2; i < 3; + + i )  {%NWL%test . equal ( d3 . interpolateRainbow ( i + 0 . 0 ) ,  " rgb ( 110 , 64 , 170 ) " ) ;%NWL%test . equal ( d3 . interpolateRainbow ( i + 0 . 5 ) ,  " rgb ( 175 , 240 , 91 ) " ) ;%NWL%test . equal ( d3 . interpolateRainbow ( i + 1 . 0 ) ,  " rgb ( 110 , 64 , 170 ) " ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( s ( 1 . 5 ) ,  1 . 5 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " sequential . clamp ( true ) enables clamping " , function ( test )  {%NWL%var s = scale . scaleSequential ( function ( t )  { return t; } ) . clamp ( true ) ;%NWL%test . equal ( s . clamp ( ) , true ) ;%NWL%test . equal ( s ( - 0 . 5 ) , 0 . 0 ) ;%NWL%test . equal ( s ( 0 . 0 ) , 0 . 0 ) ;%NWL%test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . equal ( s ( 1 . 0 ) , 1 . 0 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( s ( 0 . 5 ) , 0 . 5 ) ;%NWL%test . equal ( s ( 1 . 0 ) , 1 . 0 ) ;%NWL%test . equal ( s ( 1 . 5 ) , 1 . 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " sequential . domain ( ) coerces domain values to numbers " , function ( test )  {%NWL%var s = scale . scaleSequential ( function ( t )  { return t; } ) . domain ( [ " - 1 . 20 " ,  " 2 . 40 " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 1 . 2 , 2 . 4 ] ) ;%NWL%test . equal ( s ( - 1 . 2 ) , 0 . 0 ) ;%NWL%test . equal ( s ( 0 . 6 ) , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " sequential . domain ( ) coerces domain values to numbers " , function ( test )  {%NWL%var s = scale . scaleSequential ( function ( t )  { return t; } ) . domain ( [ " - 1 . 20 " ,  " 2 . 40 " ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 1 . 2 , 2 . 4 ] ) ;%NWL%test . equal ( s ( - 1 . 2 ) , 0 . 0 ) ;%NWL%test . equal ( s ( 0 . 6 ) , 0 . 5 ) ;%NWL%test . equal ( s ( 2 . 4 ) , 1 . 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " sequential . domain ( ) only considers the first and second element of the domain " , function ( test )  {%NWL%var s = scale . scaleSequential ( function ( t )  { return t; } ) . domain ( [ - 1 , 100 , 200 ] ) ;%NWL%test . end ( ) ;%NWL%6
tape ( " sequential . domain ( ) only considers the first and second element of the domain " , function ( test )  {%NWL%var s = scale . scaleSequential ( function ( t )  { return t; } ) . domain ( [ - 1 , 100 , 200 ] ) ;%NWL%test . deepEqual ( s . domain ( ) ,  [ - 1 , 100 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " sequential . copy ( ) returns an isolated copy of the scale " , function ( test )  {%NWL%var s1 = scale . scaleSequential ( function ( t )  { return t; } ) . domain ( [ 1 , 3 ] ) . clamp ( true ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ 1 , 3 ] ) ;%NWL%test . equal ( s2 . clamp ( ) , true ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ 1 , 3 ] ) ;%NWL%8
test . deepEqual ( s . domain ( ) ,  [ - 1 , 100 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " sequential . copy ( ) returns an isolated copy of the scale " , function ( test )  {%NWL%var s1 = scale . scaleSequential ( function ( t )  { return t; } ) . domain ( [ 1 , 3 ] ) . clamp ( true ) ,%NWL%s2 = s1 . copy ( ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ 1 , 3 ] ) ;%NWL%test . equal ( s2 . clamp ( ) , true ) ;%NWL%s1 . domain ( [ - 1 , 2 ] ) ;%NWL%test . deepEqual ( s2 . domain ( ) ,  [ 1 , 3 ] ) ;%NWL%test . equal ( s2 . clamp ( ) , true ) ;%NWL%7
date = require ( " . / date " ) ;%NWL%tape ( " time . domain ( [ - 1e50 , 1e50 ] ) is equivalent to time . domain ( [ NaN , NaN ] ) " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ - 1e50 , 1e50 ] ) ;%NWL%test . equal ( isNaN ( x . domain ( ) [ 0 ] ) , true ) ; / / Note: also coerced on retrieval , so insufficient test!%NWL%test . equal ( isNaN ( x . domain ( ) [ 1 ] ) , true ) ;%NWL%test . deepEqual ( x . ticks ( 10 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) is an alias for time . nice ( 10 ) " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 17 ) , date . local ( 2009 , 0 , 1 , 23 , 42 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( x . ticks ( 10 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) is an alias for time . nice ( 10 ) " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 17 ) , date . local ( 2009 , 0 , 1 , 23 , 42 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) can nice sub - second domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 128 ) ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) can nice sub - second domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 128 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 130 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) can nice multi - year domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2001 , 0 , 1 ) , date . local ( 2138 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . local ( 2013 , 0 , 1 , 12 , 0 , 0 , 130 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) can nice multi - year domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2001 , 0 , 1 ) , date . local ( 2138 , 0 , 1 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . local ( 2000 , 0 , 1 ) , date . local ( 2140 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( count ) nices using the specified tick count " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 17 ) , date . local ( 2009 , 0 , 1 , 23 , 42 ) ] ) ;%NWL%test . deepEqual ( x . nice ( 100 ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 , 0 , 15 ) , date . local ( 2009 , 0 , 1 , 23 , 45 ) ] ) ;%NWL%test . end ( ) ;%NWL%0
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 17 ) , date . local ( 2009 , 0 , 1 , 23 , 42 ) ] ) ;%NWL%test . deepEqual ( x . nice ( 100 ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 , 0 , 15 ) , date . local ( 2009 , 0 , 1 , 23 , 45 ) ] ) ;%NWL%test . deepEqual ( x . nice ( 10 ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( interval ) nices using the specified time interval " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeDay ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeWeek ) . domain ( ) ,  [ date . local ( 2008 , 11 , 28 ) , date . local ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeMonth ) . domain ( ) ,  [ date . local ( 2008 , 11 , 1 ) , date . local ( 2009 , 1 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " time . nice ( interval ) nices using the specified time interval " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeDay ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeWeek ) . domain ( ) ,  [ date . local ( 2008 , 11 , 28 ) , date . local ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeMonth ) . domain ( ) ,  [ date . local ( 2008 , 11 , 1 ) , date . local ( 2009 , 1 , 1 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeYear ) . domain ( ) ,  [ date . local ( 2008 , 0 , 1 ) , date . local ( 2010 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( interval ) can nice empty domains " , function ( test )  {%NWL%test . deepEqual ( x . nice ( time . timeDay ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%3
tape ( " time . nice ( interval ) nices using the specified time interval " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeDay ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeWeek ) . domain ( ) ,  [ date . local ( 2008 , 11 , 28 ) , date . local ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeMonth ) . domain ( ) ,  [ date . local ( 2008 , 11 , 1 ) , date . local ( 2009 , 1 , 1 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeYear ) . domain ( ) ,  [ date . local ( 2008 , 0 , 1 ) , date . local ( 2010 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( interval ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( x . nice ( time . timeYear ) . domain ( ) ,  [ date . local ( 2008 , 0 , 1 ) , date . local ( 2010 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( interval ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeDay ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( interval ) can nice a polylinear domain , only affecting its extent " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 23 , 48 ) , date . local ( 2009 , 0 , 2 , 23 , 48 ) ] ) . nice ( time . timeDay ) ;%NWL%test . end ( ) ;%NWL%1
tape ( " time . nice ( interval ) can nice a polylinear domain , only affecting its extent " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 23 , 48 ) , date . local ( 2009 , 0 , 2 , 23 , 48 ) ] ) . nice ( time . timeDay ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 1 , 23 , 48 ) , date . local ( 2009 , 0 , 3 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . nice ( interval , step ) nices using the specified time interval and step " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 , 0 , 12 ) , date . local ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeDay , 3 ) . domain ( ) ,  [ date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeWeek , 2 ) . domain ( ) ,  [ date . local ( 2008 , 11 , 21 ) , date . local ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . timeMonth , 3 ) . domain ( ) ,  [ date . local ( 2008 , 9 , 1 ) , date . local ( 2009 , 3 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( y . range ( ) ,  [ 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . copy ( ) isolates changes to the interpolator " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 ) , date . local ( 2010 , 0 , 1 ) ] ) . range ( [ " red " ,  " blue " ] ) ,%NWL%i = x . interpolate ( ) ,%NWL%y = x . copy ( ) ;%NWL%x . interpolate ( interpolate . interpolateHsl ) ;%NWL%test . equal ( x ( date . local ( 2009 , 6 , 1 ) ) ,  " rgb ( 255 , 0 , 253 ) " ) ;%NWL%test . equal ( y ( date . local ( 2009 , 6 , 1 ) ) ,  " rgb ( 129 , 0 , 126 ) " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( y ( date . local ( 2009 , 6 , 1 ) ) ,  " rgb ( 129 , 0 , 126 ) " ) ;%NWL%test . equal ( y . interpolate ( ) , i ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . copy ( ) isolates changes to clamping " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2009 , 0 , 1 ) , date . local ( 2010 , 0 , 1 ) ] ) . clamp ( true ) , y = x . copy ( ) ;%NWL%x . clamp ( false ) ;%NWL%test . equal ( x ( date . local ( 2011 , 0 , 1 ) ) , 2 ) ;%NWL%test . equal ( y ( date . local ( 2011 , 0 , 1 ) ) , 1 ) ;%NWL%test . equal ( y . clamp ( ) , true ) ;%NWL%test . equal ( x ( date . local ( 2011 , 0 , 1 ) ) , 2 ) ;%NWL%7
test . equal ( x . clamp ( ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . clamp ( true ) . invert ( value ) never returns a value outside the domain " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . clamp ( true ) ;%NWL%test . ok ( x . invert ( 0 ) instanceof Date ) ;%NWL%test . ok ( x . invert ( 0 ) !== x . invert ( 0 ) ) ; / / returns a distinct copy%NWL%test . equal ( + x . invert ( - 1 ) ,  + x . domain ( ) [ 0 ] ) ;%NWL%test . equal ( + x . invert ( 0 ) ,  + x . domain ( ) [ 0 ] ) ;%NWL%test . equal ( + x . invert ( 1 ) ,  + x . domain ( ) [ 1 ] ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( + x . invert ( 2 ) ,  + x . domain ( ) [ 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( interval ) observes the specified tick interval " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . timeMinute ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 4 )%NWL%test . end ( ) ;%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( interval , step ) observes the specified tick interval and step " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 33 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . timeMinute , 10 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 20 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 )%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 3 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 4 )%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 3 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 5 - second ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%0
date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 3 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 5 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 0 , 20 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 5 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 0 , 20 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%0
date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%0
date . local ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%1
date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 1 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 1 , 30 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 1 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 1 , 30 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 27 ) , date . local ( 2011 , 0 , 1 , 12 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 4 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 0 , 27 ) , date . local ( 2011 , 0 , 1 , 12 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 5 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 5 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 3 , 27 ) , date . local ( 2011 , 0 , 1 , 12 , 21 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 20 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 3 , 27 ) , date . local ( 2011 , 0 , 1 , 12 , 21 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 15 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 15 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 8 , 27 ) , date . local ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 15 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 8 , 27 ) , date . local ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 8 , 27 ) , date . local ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 30 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 30 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . local ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 30 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . local ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 14 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . local ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 14 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%date . local ( 2011 , 0 , 1 , 14 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . local ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . local ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 16 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . local ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 16 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 3 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 16 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 3 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 14 , 28 , 27 ) , date . local ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 3 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 14 , 28 , 27 ) , date . local ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 14 , 28 , 27 ) , date . local ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 6 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 6 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 6 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 12 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 12 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 12 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 12 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 12 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%1
date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 5 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 5 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 2 - day ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 5 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 2 - day ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 2 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 2 - day ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 2 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 5 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 7 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 9 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 2 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 5 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 7 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 9 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - week ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - week ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 23 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 9 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 16 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 23 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . local ( 2011 , 0 , 23 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 9 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 16 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 23 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - month ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - month ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 18 ) , date . local ( 2011 , 4 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 4 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2011 , 0 , 18 ) , date . local ( 2011 , 4 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 4 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 3 - month ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
date . local ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 4 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 3 - month ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2010 , 11 , 18 ) , date . local ( 2011 , 10 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 3 - month ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2010 , 11 , 18 ) , date . local ( 2011 , 10 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 9 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleTime ( ) . domain ( [ date . local ( 2010 , 11 , 18 ) , date . local ( 2011 , 10 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 9 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - year ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 9 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - year ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2010 , 11 , 18 ) , date . local ( 2014 , 2 , 2 ) ] ) ;%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate 1 - year ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2010 , 11 , 18 ) , date . local ( 2014 , 2 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2012 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2013 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2014 , 0 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) can generate multi - year ticks " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 0 , 11 , 18 ) , date . local ( 2014 , 2 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 6 ) ,  [%NWL%date . local ( 500 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 1000 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 1500 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2000 , 0 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( x . ticks ( 6 ) ,  [%NWL%date . local ( 500 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 1000 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 1500 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2000 , 0 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) returns no ticks for an empty domain " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2014 , 2 , 2 ) , date . local ( 2014 , 2 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( count ) returns no ticks for an empty domain " , function ( test )  {%NWL%var x = scale . scaleTime ( ) . domain ( [ date . local ( 2014 , 2 , 2 ) , date . local ( 2014 , 2 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 6 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . ticks ( ) returns descending ticks for a descending domain " , function ( test )  {%NWL%var x = scale . scaleTime ( ) ;%NWL%test . deepEqual ( x . domain ( [ date . local ( 2014 , 2 , 2 ) , date . local ( 2010 , 11 , 18 ) ] ) . ticks ( 4 ) ,  [ date . local ( 2014 , 0 , 1 , 0 , 0 ) , date . local ( 2013 , 0 , 1 , 0 , 0 ) , date . local ( 2012 , 0 , 1 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 0 , 0 ) ] ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " time . ticks ( ) returns descending ticks for a descending domain " , function ( test )  {%NWL%var x = scale . scaleTime ( ) ;%NWL%test . deepEqual ( x . domain ( [ date . local ( 2014 , 2 , 2 ) , date . local ( 2010 , 11 , 18 ) ] ) . ticks ( 4 ) ,  [ date . local ( 2014 , 0 , 1 , 0 , 0 ) , date . local ( 2013 , 0 , 1 , 0 , 0 ) , date . local ( 2012 , 0 , 1 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 0 , 0 ) ] ) ;%NWL%test . deepEqual ( x . domain ( [ date . local ( 2011 , 10 , 2 ) , date . local ( 2010 , 11 , 18 ) ] ) . ticks ( 4 ) ,  [ date . local ( 2011 , 9 , 1 , 0 , 0 ) , date . local ( 2011 , 6 , 1 , 0 , 0 ) , date . local ( 2011 , 3 , 1 , 0 , 0 ) , date . local ( 2011 , 0 , 1 , 0 , 0 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) formats year on New Year ' s " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 0 , 1 ) ) ,  " 2011 " ) ;%NWL%test . equal ( f ( date . local ( 2012 , 0 , 1 ) ) ,  " 2012 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 0 , 1 ) ) ,  " 2011 " ) ;%NWL%test . equal ( f ( date . local ( 2012 , 0 , 1 ) ) ,  " 2012 " ) ;%NWL%test . equal ( f ( date . local ( 2013 , 0 , 1 ) ) ,  " 2013 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) formats month on the 1st of each month " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 1 ) ) ,  " February " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 2 , 1 ) ) ,  " March " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 1 ) ) ,  " February " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 2 , 1 ) ) ,  " March " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 3 , 1 ) ) ,  " April " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) formats week on Sunday midnight " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 6 ) ) ,  " Feb 06 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 13 ) ) ,  " Feb 13 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 6 ) ) ,  " Feb 06 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 13 ) ) ,  " Feb 13 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 20 ) ) ,  " Feb 20 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) formats date on midnight " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 ) ) ,  " Wed 02 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 3 ) ) ,  " Thu 03 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 ) ) ,  " Wed 02 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 3 ) ) ,  " Thu 03 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 4 ) ) ,  " Fri 04 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) formats hour on minute zero " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 11 ) ) ,  " 11 AM " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ) ) ,  " 12 PM " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 11 ) ) ,  " 11 AM " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ) ) ,  " 12 PM " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 13 ) ) ,  " 01 PM " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) formats minute on second zero " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 11 , 59 ) ) ,  " 11:59 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  1 ) ) ,  " 12:01 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 11 , 59 ) ) ,  " 11:59 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  1 ) ) ,  " 12:01 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  2 ) ) ,  " 12:02 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) otherwise , formats second " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  1 ,  9 ) ) ,  " :09 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  1 , 10 ) ) ,  " :10 " ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " time . tickFormat ( ) ( date ) otherwise , formats second " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  1 ,  9 ) ) ,  " :09 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  1 , 10 ) ) ,  " :10 " ) ;%NWL%test . equal ( f ( date . local ( 2011 , 1 , 2 , 12 ,  1 , 11 ) ) ,  " :11 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " time . tickFormat ( count , specifier ) returns a time format for the specified specifier " , function ( test )  {%NWL%var f = scale . scaleTime ( ) . tickFormat ( 10 ,  " %c " ) ;%NWL%test . end ( ) ;%NWL%6
, $inc = { 39: [ + i , 0 ]%NWL%, 37: [ - i , 0 ]%NWL%, 40: [ 0 ,  + i ]%NWL%, 38: [ 0 ,  - i ]%NWL%} [ e . keyCode ]%NWL%if ( e . which == 82 ) sn . redo ( )%NWL%if ( e . which == 90 ) sn . undo ( )%NWL%if ( e . keyCode === 8 )%NWL%e . preventDefault ( )  +%NWL%sn . Graph . remove ( { _id: d . _id } )%NWL%e . preventDefault ( )  +%NWL%8
time = require ( " d3 - time " ) ,%NWL%scale = require ( " . . / " ) ,%NWL%date = require ( " . / date " ) ;%NWL%tape ( " scaleUtc . nice ( ) is an alias for scaleUtc . nice ( 10 ) " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 17 ) , date . utc ( 2009 , 0 , 1 , 23 , 42 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( ) can nice sub - second domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 128 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( ) can nice sub - second domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 128 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 130 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( ) can nice multi - year domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2001 , 0 , 1 ) , date . utc ( 2138 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 0 ) , date . utc ( 2013 , 0 , 1 , 12 , 0 , 0 , 130 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( ) can nice multi - year domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2001 , 0 , 1 ) , date . utc ( 2138 , 0 , 1 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . utc ( 2000 , 0 , 1 ) , date . utc ( 2140 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . deepEqual ( x . nice ( ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( count ) nices using the specified tick count " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 17 ) , date . utc ( 2009 , 0 , 1 , 23 , 42 ) ] ) ;%NWL%test . deepEqual ( x . nice ( 100 ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 , 0 , 15 ) , date . utc ( 2009 , 0 , 1 , 23 , 45 ) ] ) ;%NWL%test . end ( ) ;%NWL%0
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 17 ) , date . utc ( 2009 , 0 , 1 , 23 , 42 ) ] ) ;%NWL%test . deepEqual ( x . nice ( 100 ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 , 0 , 15 ) , date . utc ( 2009 , 0 , 1 , 23 , 45 ) ] ) ;%NWL%test . deepEqual ( x . nice ( 10 ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( interval ) nices using the specified time interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcDay ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcWeek ) . domain ( ) ,  [ date . utc ( 2008 , 11 , 28 ) , date . utc ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcMonth ) . domain ( ) ,  [ date . utc ( 2008 , 11 , 1 ) , date . utc ( 2009 , 1 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " scaleUtc . nice ( interval ) nices using the specified time interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcDay ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcWeek ) . domain ( ) ,  [ date . utc ( 2008 , 11 , 28 ) , date . utc ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcMonth ) . domain ( ) ,  [ date . utc ( 2008 , 11 , 1 ) , date . utc ( 2009 , 1 , 1 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcYear ) . domain ( ) ,  [ date . utc ( 2008 , 0 , 1 ) , date . utc ( 2010 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( interval ) can nice empty domains " , function ( test )  {%NWL%test . deepEqual ( x . nice ( time . utcDay ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%3
tape ( " scaleUtc . nice ( interval ) nices using the specified time interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcDay ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcWeek ) . domain ( ) ,  [ date . utc ( 2008 , 11 , 28 ) , date . utc ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcMonth ) . domain ( ) ,  [ date . utc ( 2008 , 11 , 1 ) , date . utc ( 2009 , 1 , 1 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcYear ) . domain ( ) ,  [ date . utc ( 2008 , 0 , 1 ) , date . utc ( 2010 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( interval ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( x . nice ( time . utcYear ) . domain ( ) ,  [ date . utc ( 2008 , 0 , 1 ) , date . utc ( 2010 , 0 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( interval ) can nice empty domains " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 0 , 12 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcDay ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( interval ) can nice a polylinear domain , only affecting its extent " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 23 , 48 ) , date . utc ( 2009 , 0 , 2 , 23 , 48 ) ] ) . nice ( time . utcDay ) ;%NWL%test . end ( ) ;%NWL%1
tape ( " scaleUtc . nice ( interval ) can nice a polylinear domain , only affecting its extent " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 23 , 48 ) , date . utc ( 2009 , 0 , 2 , 23 , 48 ) ] ) . nice ( time . utcDay ) ;%NWL%test . deepEqual ( x . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 1 , 23 , 48 ) , date . utc ( 2009 , 0 , 3 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . nice ( interval , step ) nices using the specified time interval and step " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 , 0 , 12 ) , date . utc ( 2009 , 0 , 1 , 23 , 48 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcDay , 3 ) . domain ( ) ,  [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcWeek , 2 ) . domain ( ) ,  [ date . utc ( 2008 , 11 , 21 ) , date . utc ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . nice ( time . utcMonth , 3 ) . domain ( ) ,  [ date . utc ( 2008 , 9 , 1 ) , date . utc ( 2009 , 3 , 1 ) ] ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( y . range ( ) ,  [ 2 , 3 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . copy ( ) isolates changes to the interpolator " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2010 , 0 , 1 ) ] ) . range ( [ " red " ,  " blue " ] ) ,%NWL%i = x . interpolate ( ) ,%NWL%y = x . copy ( ) ;%NWL%x . interpolate ( interpolate . interpolateHsl ) ;%NWL%test . equal ( x ( date . utc ( 2009 , 6 , 1 ) ) ,  " rgb ( 255 , 0 , 253 ) " ) ;%NWL%test . equal ( y ( date . utc ( 2009 , 6 , 1 ) ) ,  " rgb ( 129 , 0 , 126 ) " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( y ( date . utc ( 2009 , 6 , 1 ) ) ,  " rgb ( 129 , 0 , 126 ) " ) ;%NWL%test . equal ( y . interpolate ( ) , i ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . copy ( ) isolates changes to clamping " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2009 , 0 , 1 ) , date . utc ( 2010 , 0 , 1 ) ] ) . clamp ( true ) , y = x . copy ( ) ;%NWL%x . clamp ( false ) ;%NWL%test . equal ( x ( date . utc ( 2011 , 0 , 1 ) ) , 2 ) ;%NWL%test . equal ( y ( date . utc ( 2011 , 0 , 1 ) ) , 1 ) ;%NWL%test . equal ( y . clamp ( ) , true ) ;%NWL%test . equal ( x ( date . utc ( 2011 , 0 , 1 ) ) , 2 ) ;%NWL%7
test . equal ( x . clamp ( ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval ) observes the specified tick interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval ) observes the specified named tick interval " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%1
test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval ) observes the specified named tick interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%1
date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval ) observes the specified named tick interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%1
date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval ) observes the specified named tick interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%1
date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval ) observes the specified named tick interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval ) observes the specified named tick interval " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . utcMinute ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%test . end ( ) ;%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( interval , step ) observes the specified tick interval and step " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 33 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( time . utcMinute , 10 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 20 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 )%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 4 )%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 5 - second ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%0
date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 5 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 0 , 20 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 5 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 0 , 20 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%0
date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%0
date . utc ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 15 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%1
date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 30 - second ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 , 30 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , date . utc ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 , 30 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 27 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 0 , 27 ) , date . utc ( 2011 , 0 , 1 , 12 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 5 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 5 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 3 , 27 ) , date . utc ( 2011 , 0 , 1 , 12 , 21 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 20 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 3 , 27 ) , date . utc ( 2011 , 0 , 1 , 12 , 21 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 15 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 20 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 15 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 8 , 27 ) , date . utc ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 15 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 8 , 27 ) , date . utc ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 8 , 27 ) , date . utc ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 30 - minute ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 30 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . utc ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 30 - minute ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . utc ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 14 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . utc ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 14 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 14 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . utc ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . utc ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 16 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , date . utc ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 16 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 3 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 16 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 3 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 14 , 28 , 27 ) , date . utc ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 3 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 14 , 28 , 27 ) , date . utc ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 14 , 28 , 27 ) , date . utc ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 6 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 6 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 6 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 12 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 12 - hour ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 12 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 12 - hour ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 12 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%1
date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - day ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 5 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 5 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 2 - day ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 5 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 2 - day ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 2 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 2 - day ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 2 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 5 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 7 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 9 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 2 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 5 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 7 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 9 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - week ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - week ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 23 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 9 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 16 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 23 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , date . utc ( 2011 , 0 , 23 , 21 , 34 , 12 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 9 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 16 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 23 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - month ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - month ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 18 ) , date . utc ( 2011 , 4 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 4 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2011 , 0 , 18 ) , date . utc ( 2011 , 4 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 4 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 3 - month ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
date . utc ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 4 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 3 - month ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2010 , 11 , 18 ) , date . utc ( 2011 , 10 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%2
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 3 - month ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2010 , 11 , 18 ) , date . utc ( 2011 , 10 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 9 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2010 , 11 , 18 ) , date . utc ( 2011 , 10 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 9 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - year ticks " , function ( test )  {%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%1
test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 9 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - year ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2010 , 11 , 18 ) , date . utc ( 2014 , 2 , 2 ) ] ) ;%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate 1 - year ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2010 , 11 , 18 ) , date . utc ( 2014 , 2 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2012 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2013 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2014 , 0 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) can generate multi - year ticks " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 0 , 11 , 18 ) , date . utc ( 2014 , 2 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 6 ) ,  [%NWL%date . utc ( 500 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 1000 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 1500 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2000 , 0 , 1 , 0 , 0 )%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( x . ticks ( 6 ) ,  [%NWL%date . utc ( 500 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 1000 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 1500 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2000 , 0 , 1 , 0 , 0 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) returns no ticks for an empty domain " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2014 , 2 , 2 ) , date . utc ( 2014 , 2 , 2 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( " scaleUtc . ticks ( count ) returns no ticks for an empty domain " , function ( test )  {%NWL%var x = scale . scaleUtc ( ) . domain ( [ date . utc ( 2014 , 2 , 2 ) , date . utc ( 2014 , 2 , 2 ) ] ) ;%NWL%test . deepEqual ( x . ticks ( 6 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) formats year on New Year ' s " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 0 , 1 ) ) ,  " 2011 " ) ;%NWL%test . equal ( f ( date . utc ( 2012 , 0 , 1 ) ) ,  " 2012 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 0 , 1 ) ) ,  " 2011 " ) ;%NWL%test . equal ( f ( date . utc ( 2012 , 0 , 1 ) ) ,  " 2012 " ) ;%NWL%test . equal ( f ( date . utc ( 2013 , 0 , 1 ) ) ,  " 2013 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) formats month on the 1st of each month " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 1 ) ) ,  " February " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 2 , 1 ) ) ,  " March " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 1 ) ) ,  " February " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 2 , 1 ) ) ,  " March " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 3 , 1 ) ) ,  " April " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) formats week on Sunday midnight " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 6 ) ) ,  " Feb 06 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 13 ) ) ,  " Feb 13 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 6 ) ) ,  " Feb 06 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 13 ) ) ,  " Feb 13 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 20 ) ) ,  " Feb 20 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) formats date on midnight " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 ) ) ,  " Wed 02 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 3 ) ) ,  " Thu 03 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 ) ) ,  " Wed 02 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 3 ) ) ,  " Thu 03 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 4 ) ) ,  " Fri 04 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) formats hour on minute zero " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 11 ) ) ,  " 11 AM " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ) ) ,  " 12 PM " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 11 ) ) ,  " 11 AM " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ) ) ,  " 12 PM " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 13 ) ) ,  " 01 PM " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) formats minute on second zero " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 11 , 59 ) ) ,  " 11:59 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  1 ) ) ,  " 12:01 " ) ;%NWL%test . end ( ) ;%NWL%4
var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 11 , 59 ) ) ,  " 11:59 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  1 ) ) ,  " 12:01 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  2 ) ) ,  " 12:02 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) otherwise , formats second " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  1 ,  9 ) ) ,  " :09 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  1 , 10 ) ) ,  " :10 " ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " scaleUtc . tickFormat ( ) ( date ) otherwise , formats second " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  1 ,  9 ) ) ,  " :09 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  1 , 10 ) ) ,  " :10 " ) ;%NWL%test . equal ( f ( date . utc ( 2011 , 1 , 2 , 12 ,  1 , 11 ) ) ,  " :11 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " scaleUtc . tickFormat ( count , specifier ) returns a time format for the specified specifier " , function ( test )  {%NWL%var f = scale . scaleUtc ( ) . tickFormat ( 10 ,  " %c " ) ;%NWL%test . end ( ) ;%NWL%6
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%tape ( " interpolateViridis ( t ) returns the expected values " , function ( test )  {%NWL%test . equal ( d3 . interpolateViridis ( 0 . 0 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 5 ) ,  " #21918c " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 1 . 0 ) ,  " #fde725 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateViridis ( t ) clamps t " , function ( test )  {%NWL%test . equal ( d3 . interpolateViridis ( 0 . 0 ) ,  " #440154 " ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%tape ( " interpolateViridis ( t ) returns the expected values " , function ( test )  {%NWL%test . equal ( d3 . interpolateViridis ( 0 . 0 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 5 ) ,  " #21918c " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 1 . 0 ) ,  " #fde725 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateViridis ( t ) clamps t " , function ( test )  {%NWL%test . equal ( d3 . interpolateViridis ( - 0 . 5 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 5 ) ,  " #21918c " ) ;%NWL%4
d3 = require ( " . . / " ) ;%NWL%tape ( " interpolateViridis ( t ) returns the expected values " , function ( test )  {%NWL%test . equal ( d3 . interpolateViridis ( 0 . 0 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 5 ) ,  " #21918c " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 1 . 0 ) ,  " #fde725 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateViridis ( t ) clamps t " , function ( test )  {%NWL%test . equal ( d3 . interpolateViridis ( - 0 . 5 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 0 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 1 . 0 ) ,  " #fde725 " ) ;%NWL%4
test . equal ( d3 . interpolateViridis ( 0 . 0 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 5 ) ,  " #21918c " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 1 . 0 ) ,  " #fde725 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " interpolateViridis ( t ) clamps t " , function ( test )  {%NWL%test . equal ( d3 . interpolateViridis ( - 0 . 5 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 0 ) ,  " #440154 " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 0 . 5 ) ,  " #21918c " ) ;%NWL%test . equal ( d3 . interpolateViridis ( 1 . 0 ) ,  " #fde725 " ) ;%NWL%test . end ( ) ;%NWL%3
var std = 1 ,%NWL%mean = 0;%NWL%var input_pos_match = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ;%NWL%var input_no_match = [ 0 , 1 , 0 , 1 , 1 , 2 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ;%NWL%tape ( ' rule_7 marks low values ' , function ( test )  {%NWL%var result = rule_7 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_7 does not mark higher values ' , function ( test )  {%NWL%test . notOk ( result ) ;%NWL%6
mean = 0;%NWL%var input_pos_match = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ;%NWL%var input_no_match = [ 0 , 1 , 0 , 1 , 1 , 2 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ] ;%NWL%tape ( ' rule_7 marks low values ' , function ( test )  {%NWL%var result = rule_7 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_7 does not mark higher values ' , function ( test )  {%NWL%var result = rule_7 ( input_no_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%6
, self = d3 . select ( this )%NWL%var a = d3 . select ( ' svg ' ) . selectAll ( ' . arc ' ) . data ( data , pluckWith ( ' i ' ) )%NWL%a . enter ( )%NWL%. append ( ' path ' )%NWL%. attr ( ' class ' ,  ' arc ' )%NWL%. attr ( ' fill ' , node_fill )%NWL%. attr ( ' d ' , arc )%NWL%. on ( ' mouseover ' , function ( d )  {%NWL%self . transition ( ) . attr ( ' fill ' , node_fill ( d ) )%NWL%} )%NWL%self . transition ( ) . attr ( ' fill ' , node_fill ( d ) )%NWL%8
add: function ( name )  {%NWL%var i = this . _names . indexOf ( name ) ;%NWL%if ( i < 0 )  {%NWL%this . _names . push ( name ) ;%NWL%this . _node . setAttribute ( " class " , this . _names . join ( "  " ) ) ;%NWL%}%NWL%} ,%NWL%remove: function ( name )  {%NWL%var i = this . _names . indexOf ( name ) ;%NWL%if ( i >= 0 )  {%NWL%this . _node . setAttribute ( " class " , this . _names . join ( "  " ) ) ;%NWL%4
return output%NWL%}%NWL%} )%NWL%var output = el . append ( ' circle ' )%NWL%. call ( circle , datum )%NWL%. attr ( ' fill ' , function ( d )  { return d . fill = ' url ( #ocean_fill ) ' } )%NWL%. classed ( ' output ' , true )%NWL%. on ( ' signal ' , signal )%NWL%el . append ( ' circle ' )%NWL%. call ( circle , datum )%NWL%el . append ( ' circle ' )%NWL%8
test . deepEqual ( type ( d3 . creator ( " h1 " ) . call ( document . body ) ) ,  { namespace: " http: / / www . w3 . org / 1999 / xhtml " , name: " H1 " } ) ;%NWL%test . deepEqual ( type ( d3 . creator ( " xhtml:h1 " ) . call ( document . body ) ) ,  { namespace: " http: / / www . w3 . org / 1999 / xhtml " , name: " H1 " } ) ;%NWL%test . deepEqual ( type ( d3 . creator ( " svg " ) . call ( document . body ) ) ,  { namespace: " http: / / www . w3 . org / 2000 / svg " , name: " svg " } ) ;%NWL%test . deepEqual ( type ( d3 . creator ( " g " ) . call ( document . body ) ) ,  { namespace: " http: / / www . w3 . org / 1999 / xhtml " , name: " G " } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . creator ( name ) . call ( element ) can inherit the namespace from the given element " , function ( test )  {%NWL%var document = jsdom ( " <body class= ' foo ' ><svg>< / svg> " ) ,%NWL%svg = document . querySelector ( " svg " ) ;%NWL%test . deepEqual ( type ( d3 . creator ( " g " ) . call ( document . body ) ) ,  { namespace: " http: / / www . w3 . org / 1999 / xhtml " , name: " G " } ) ;%NWL%test . end ( ) ;%NWL%4
var tape = require ( " tape " ) ,%NWL%jsdom = require ( " . / jsdom " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%tape ( " d3 . event is set exactly during the callback of an event listener " , function ( test )  {%NWL%var event ,%NWL%document = jsdom ( " <h1 id= ' one ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%selection = d3 . selectAll ( [ one ] ) . on ( " click " , function ( )  { event = d3 . event; } ) ;%NWL%test . equal ( d3 . event , null ) ;%NWL%test . equal ( d3 . event , null ) ;%NWL%8
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . event is restored to its previous value during reentrant events " , function ( test )  {%NWL%var event1 ,%NWL%event2 ,%NWL%event3 ,%NWL%document = jsdom ( " <h1 id= ' one ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%selection = d3 . selectAll ( [ one ] ) . on ( " foo " , function ( )  { event1 = d3 . event; selection . dispatch ( " bar " ) ; event3 = d3 . event; } ) . on ( " bar " , function ( )  { event2 = d3 . event; } ) ;%NWL%test . equal ( d3 . event , null ) ;%NWL%test . equal ( d3 . event , null ) ;%NWL%9
test . equal ( d3 . selector ( " . foo " ) . call ( document . documentElement ) , document . body ) ;%NWL%test . equal ( d3 . selector ( " body . foo " ) . call ( document . documentElement ) , document . body ) ;%NWL%test . equal ( d3 . selector ( " h1 " ) . call ( document . documentElement ) , null ) ;%NWL%test . equal ( d3 . selector ( " body . bar " ) . call ( document . documentElement ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . selector ( null ) . call ( element ) always returns undefined " , function ( test )  {%NWL%var document = jsdom ( " <body class= ' foo ' ><undefined>< / undefined><null>< / null> " ) ;%NWL%test . equal ( d3 . selector ( ) . call ( document . documentElement ) , undefined ) ;%NWL%test . equal ( d3 . selector ( null ) . call ( document . documentElement ) , undefined ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . selectorAll ( " div " ) . call ( document . documentElement ) ,  [ div ] ) ;%NWL%test . deepEqual ( d3 . selectorAll ( " div , body " ) . call ( document . documentElement ) ,  [ body , div ] ) ;%NWL%test . deepEqual ( d3 . selectorAll ( " h1 " ) . call ( document . documentElement ) ,  [ ] ) ;%NWL%test . deepEqual ( d3 . selectorAll ( " body . bar " ) . call ( document . documentElement ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . selectorAll ( null ) . call ( element ) always returns the empty array " , function ( test )  {%NWL%var document = jsdom ( " <body class= ' foo ' ><undefined>< / undefined><null>< / null> " ) ;%NWL%test . deepEqual ( d3 . selectorAll ( ) . call ( document . documentElement ) ,  [ ] ) ;%NWL%test . deepEqual ( d3 . selectorAll ( null ) . call ( document . documentElement ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( d3 . selectorAll ( ) . call ( document . documentElement ) ,  [ ] ) ;%NWL%test . deepEqual ( d3 . selectorAll ( null ) . call ( document . documentElement ) ,  [ ] ) ;%NWL%test . deepEqual ( d3 . selectorAll ( undefined ) . call ( document . documentElement ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . selectorAll ( null ) . call ( element ) returns a new empty array each time " , function ( test )  {%NWL%var one = d3 . selectorAll ( ) ( ) ,%NWL%two = d3 . selectorAll ( ) ( ) ;%NWL%test . equal ( one === two , false ) ;%NWL%one . push ( " one " ) ;%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%jsdom = require ( " . / jsdom " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%tape ( " d3 . window ( node ) returns node . ownerDocument . defaultView " , function ( test )  {%NWL%var document = jsdom ( ) ;%NWL%test . equal ( d3 . window ( document . body ) , document . defaultView ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . window ( document ) returns document . defaultView " , function ( test )  {%NWL%var document = jsdom ( ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( d3 . window ( document . body ) , document . defaultView ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . window ( document ) returns document . defaultView " , function ( test )  {%NWL%var document = jsdom ( ) ;%NWL%test . equal ( d3 . window ( document ) , document . defaultView ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . window ( window ) returns window " , function ( test )  {%NWL%var window = jsdom ( ) . defaultView;%NWL%test . end ( ) ;%NWL%1
jsdom = require ( " . . / jsdom " ) ,%NWL%d3 = require ( " . . / . . / " ) ;%NWL%tape ( " selection . attr ( name ) returns the value of the attribute with the specified name on the first selected element " , function ( test )  {%NWL%var document = jsdom ( " <h1 class= ' c1 c2 ' >hello< / h1><h1 class= ' c3 ' >< / h1> " ) ;%NWL%test . equal ( d3 . select ( document ) . select ( " h1 " ) . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( d3 . selectAll ( [ null , document ] ) . select ( " h1 " ) . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name ) coerces the specified name to a string " , function ( test )  {%NWL%var document = jsdom ( " <h1 class= ' c1 c2 ' >hello< / h1><h1 class= ' c3 ' >< / h1> " ) ;%NWL%test . end ( ) ;%NWL%6
var document = jsdom ( " <h1 class= ' c1 c2 ' >hello< / h1><h1 class= ' c3 ' >< / h1> " ) ;%NWL%test . equal ( d3 . select ( document ) . select ( " h1 " ) . attr ( { toString: function ( )  { return " class " ; } } ) ,  " c1 c2 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name ) observes the namespace prefix , if any " , function ( test )  {%NWL%var selection = d3 . select ( {%NWL%getAttribute: function ( name )  { return name === " foo " ? " bar " : null; } ,%NWL%getAttributeNS: function ( url , name )  { return url === " http: / / www . w3 . org / 2000 / svg " && name === " foo " ? " svg:bar " : null; }%NWL%} ) ;%NWL%test . equal ( selection . attr ( " foo " ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name , value ) observes the namespace prefix , if any " , function ( test )  {%NWL%var result , selection = d3 . select ( {%NWL%setAttribute: function ( name , value )  { result = name === " foo " ? value : null; } ,%NWL%setAttributeNS: function ( url , name , value )  { result = url === " http: / / www . w3 . org / 2000 / svg " && name === " foo " ? value : null; }%NWL%} ) ;%NWL%test . equal ( ( result = undefined , selection . attr ( " foo " ,  " bar " ) , result ) ,  " bar " ) ;%NWL%test . equal ( ( result = undefined , selection . attr ( " svg:foo " ,  " svg:bar " ) , result ) ,  " svg:bar " ) ;%NWL%test . equal ( ( result = undefined , selection . attr ( " foo " , function ( )  { return " bar " ; } ) , result ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name , null ) observes the namespace prefix , if any " , function ( test )  {%NWL%var result , selection = d3 . select ( {%NWL%removeAttribute: function ( name )  { result = name === " foo " ? " foo " : null; } ,%NWL%removeAttributeNS: function ( url , name )  { result = url === " http: / / www . w3 . org / 2000 / svg " && name === " foo " ? " svg:foo " : null; }%NWL%} ) ;%NWL%test . equal ( ( result = undefined , selection . attr ( " foo " , null ) , result ) ,  " foo " ) ;%NWL%test . equal ( ( result = undefined , selection . attr ( " svg:foo " , null ) , result ) ,  " svg:foo " ) ;%NWL%test . equal ( ( result = undefined , selection . attr ( " foo " , function ( )  { return null; } ) , result ) ,  " foo " ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( ( result = undefined , selection . attr ( " svg:foo " , function ( )  { return null; } ) , result ) ,  " svg:foo " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name , value ) sets the value of the attribute with the specified name on the selected elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' class= ' c1 c2 ' >hello< / h1><h1 id= ' two ' class= ' c3 ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . attr ( " foo " ,  " bar " ) , selection ) ;%NWL%test . equal ( one . getAttribute ( " foo " ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( two . getAttribute ( " foo " ) ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name , null ) removes the attribute with the specified name on the selected elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' foo= ' bar ' class= ' c1 c2 ' >hello< / h1><h1 id= ' two ' foo= ' bar ' class= ' c3 ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . attr ( " foo " , null ) , selection ) ;%NWL%test . equal ( one . hasAttribute ( " foo " ) , false ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( selection . attr ( " foo " , null ) , selection ) ;%NWL%test . equal ( one . hasAttribute ( " foo " ) , false ) ;%NWL%test . equal ( two . hasAttribute ( " foo " ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name , function ) sets the value of the attribute with the specified name on the selected elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' class= ' c1 c2 ' >hello< / h1><h1 id= ' two ' class= ' c3 ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( one . hasAttribute ( " foo " ) , false ) ;%NWL%1
test . equal ( two . hasAttribute ( " foo " ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attr ( name , function ) sets the value of the attribute with the specified name on the selected elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' class= ' c1 c2 ' >hello< / h1><h1 id= ' two ' class= ' c3 ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . attr ( " foo " , function ( d , i )  { return i ? " bar - "  + i : null; } ) , selection ) ;%NWL%test . equal ( one . hasAttribute ( " foo " ) , false ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( d3 . select ( document ) . select ( " h1 " ) . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( d3 . select ( document ) . select ( " h1 " ) . classed ( " c2 c1 " ) , true ) ;%NWL%test . equal ( d3 . select ( document ) . select ( " h1 " ) . classed ( " c1 c3 " ) , false ) ;%NWL%test . equal ( d3 . selectAll ( [ null , document ] ) . select ( " h1 " ) . classed ( " c1 " ) , true ) ;%NWL%test . equal ( d3 . selectAll ( [ null , document ] ) . select ( " h1 " ) . classed ( " c2 " ) , true ) ;%NWL%test . equal ( d3 . selectAll ( [ null , document ] ) . select ( " h1 " ) . classed ( " c3 " ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes ) coerces the specified classes to a string " , function ( test )  {%NWL%var document = jsdom ( " <h1 class= ' c1 c2 ' >hello< / h1><h1 class= ' c3 ' >< / h1> " ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes ) gets the class attribute if classList is not supported " , function ( test )  {%NWL%var node = new Node ( " c1 c2 " ) ;%NWL%test . equal ( d3 . select ( node ) . classed ( " " ) , true ) ;%NWL%test . equal ( d3 . select ( node ) . classed ( " c1 " ) , true ) ;%NWL%test . equal ( d3 . select ( node ) . classed ( " c2 " ) , true ) ;%NWL%test . equal ( d3 . select ( node ) . classed ( " c3 " ) , false ) ;%NWL%test . equal ( d3 . select ( node ) . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( d3 . select ( node ) . classed ( " c2 c1 " ) , true ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes , value ) sets whether the selected elements have the specified classes " , function ( test )  {%NWL%var document = jsdom ( " " ) ,%NWL%selection = d3 . select ( document . body ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) , null ) ;%NWL%test . equal ( selection . classed ( " c1 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 " ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%8
test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) , null ) ;%NWL%test . equal ( selection . classed ( " c1 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 " ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%0
test . equal ( selection . attr ( " class " ) , null ) ;%NWL%test . equal ( selection . classed ( " c1 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 " ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " , false ) , selection ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%6
test . equal ( selection . classed ( " c1 c2 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " , false ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%6
test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes , function ) sets whether the selected elements have the specified classes " , function ( test )  {%NWL%var document = jsdom ( " " ) ,%NWL%selection = d3 . select ( document . body ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , function ( )  { return true; } ) , selection ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " " ) ;%NWL%2
test . equal ( selection . classed ( " c2 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes , function ) sets whether the selected elements have the specified classes " , function ( test )  {%NWL%var document = jsdom ( " " ) ,%NWL%selection = d3 . select ( document . body ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , function ( )  { return true; } ) , selection ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , function ( )  { return false; } ) , selection ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes , value ) sets the class attribute if classList is not supported " , function ( test )  {%NWL%var node = new Node ( null ) ,%NWL%selection = d3 . select ( node ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) , null ) ;%NWL%test . equal ( selection . classed ( " c1 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 " ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%8
test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) , null ) ;%NWL%test . equal ( selection . classed ( " c1 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 " ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%0
test . equal ( selection . attr ( " class " ) , null ) ;%NWL%test . equal ( selection . classed ( " c1 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 " ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " , false ) , selection ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%6
test . equal ( selection . classed ( " c1 c2 " , true ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , true ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c1 c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " , false ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , true ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%6
test . equal ( selection . classed ( " c1 c2 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " c2 " ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " , false ) , selection ) ;%NWL%test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes , value ) coerces the specified classes to a string " , function ( test )  {%NWL%var document = jsdom ( " <h1>hello< / h1> " ) ,%NWL%test . equal ( selection . classed ( " c1 c2 " ) , false ) ;%NWL%0
test . equal ( selection . classed ( " c1 " ) , false ) ;%NWL%test . equal ( selection . classed ( " c2 " ) , false ) ;%NWL%test . equal ( selection . attr ( " class " ) ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . classed ( classes , value ) coerces the specified classes to a string " , function ( test )  {%NWL%var document = jsdom ( " <h1>hello< / h1> " ) ,%NWL%selection = d3 . select ( document ) . select ( " h1 " ) ;%NWL%test . equal ( selection . classed ( " c1 c2 " ) , false ) ;%NWL%test . equal ( selection . classed ( { toString: function ( )  { return " c1 c2 " ; } } , true ) , selection ) ;%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%jsdom = require ( " . . / jsdom " ) ,%NWL%d3 = require ( " . . / . . / " ) ;%NWL%var body = jsdom ( " <div id= ' one ' >< / div><div id= ' two ' >< / div><div id= ' three ' >< / div> " ) . body ,%NWL%0
test . equal ( d3 . select ( node ) . datum ( ) ,  " hello " ) ;%NWL%test . equal ( d3 . selectAll ( [ null , node ] ) . datum ( ) ,  " hello " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . datum ( value ) sets datum on the selected elements " , function ( test )  {%NWL%var one = { __data__: " " } ,%NWL%two = { __data__: " " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . datum ( " bar " ) , selection ) ;%NWL%test . equal ( one . __data__ ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( one . __data__ ,  " bar " ) ;%NWL%test . equal ( two . __data__ ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . datum ( null ) clears the datum on the selected elements " , function ( test )  {%NWL%var one = { __data__: " bar " } ,%NWL%two = { __data__: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . datum ( null ) , selection ) ;%NWL%test . equal ( " __data__ " in one , false ) ;%NWL%test . end ( ) ;%NWL%2
selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . datum ( null ) , selection ) ;%NWL%test . equal ( " __data__ " in one , false ) ;%NWL%test . equal ( " __data__ " in two , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . datum ( function ) sets the value of the datum on the selected elements " , function ( test )  {%NWL%var one = { __data__: " bar " } ,%NWL%two = { __data__: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( " __data__ " in one , false ) ;%NWL%2
test . equal ( " __data__ " in one , false ) ;%NWL%test . equal ( " __data__ " in two , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . datum ( function ) sets the value of the datum on the selected elements " , function ( test )  {%NWL%var one = { __data__: " bar " } ,%NWL%two = { __data__: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . datum ( function ( d , i )  { return i ? " baz " : null; } ) , selection ) ;%NWL%test . equal ( " __data__ " in one , false ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( result ,  [ one ,  " node - 0 " , 0 ,  [ one , two ] , two ,  " node - 1 " , 1 ,  [ one , two ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . each ( function ) skips missing elements " , function ( test )  {%NWL%var result = [ ] ,%NWL%document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ , one , , two ] ) . datum ( function ( d , i )  { return " node - "  + i; } ) ;%NWL%test . equal ( selection . each ( function ( d , i , nodes )  { result . push ( this , d , i , nodes ) ; } ) , selection ) ;%NWL%test . end ( ) ;%NWL%1
d3 = require ( " . . / . . / " ) ;%NWL%tape ( " selection . empty ( ) return false if the selection is not empty " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ;%NWL%test . equal ( d3 . select ( document ) . empty ( ) , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . empty ( ) return true if the selection is empty " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ;%NWL%test . equal ( d3 . select ( null ) . empty ( ) , true ) ;%NWL%test . equal ( d3 . selectAll ( [ ] ) . empty ( ) , true ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( d3 . select ( node ) . html ( ) ,  " hello " ) ;%NWL%test . equal ( d3 . selectAll ( [ null , node ] ) . html ( ) ,  " hello " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . html ( value ) sets inner HTML on the selected elements " , function ( test )  {%NWL%var one = { innerHTML: " " } ,%NWL%two = { innerHTML: " " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . html ( " bar " ) , selection ) ;%NWL%test . equal ( one . innerHTML ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( one . innerHTML ,  " bar " ) ;%NWL%test . equal ( two . innerHTML ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . html ( null ) clears the inner HTML on the selected elements " , function ( test )  {%NWL%var one = { innerHTML: " bar " } ,%NWL%two = { innerHTML: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . html ( null ) , selection ) ;%NWL%test . equal ( one . innerHTML ,  " " ) ;%NWL%test . end ( ) ;%NWL%2
selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . html ( null ) , selection ) ;%NWL%test . equal ( one . innerHTML ,  " " ) ;%NWL%test . equal ( two . innerHTML ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . html ( function ) sets the value of the inner HTML on the selected elements " , function ( test )  {%NWL%var one = { innerHTML: " bar " } ,%NWL%two = { innerHTML: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( one . innerHTML ,  " " ) ;%NWL%2
test . equal ( one . innerHTML ,  " " ) ;%NWL%test . equal ( two . innerHTML ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . html ( function ) sets the value of the inner HTML on the selected elements " , function ( test )  {%NWL%var one = { innerHTML: " bar " } ,%NWL%two = { innerHTML: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . html ( function ( d , i )  { return i ? " baz " : null; } ) , selection ) ;%NWL%test . equal ( one . innerHTML ,  " " ) ;%NWL%test . end ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%jsdom = require ( " . . / jsdom " ) ,%NWL%d3 = require ( " . . / . . / " ) ;%NWL%var document = global . document = jsdom ( ) ;%NWL%0
test . equal ( s . checked ( ) , true ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%delete d3 . selection . prototype . checked;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . selection ( ) returns an instanceof d3 . selection " , function ( test )  {%NWL%var document = global . document = jsdom ( ) ;%NWL%try {%NWL%test . ok ( d3 . selection ( ) instanceof d3 . selection ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( selection ,  { _groups: [ [ three , four ] ] , _parents: [ null ] } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . insert ( function , function ) inserts the returned element before the specified child of each selected element " , function ( test )  {%NWL%var document = jsdom ( " <div id= ' one ' ><span class= ' before ' >< / span>< / div><div id= ' two ' ><span class= ' before ' >< / span>< / div> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) . insert ( function ( )  { return document . createElement ( " SPAN " ) ; } , function ( )  { return this . firstChild; } ) ,%NWL%three = one . querySelector ( " span:first - child " ) ,%NWL%four = two . querySelector ( " span:first - child " ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( selection ,  { _groups: [ [ three , four ] ] , _parents: [ null ] } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . insert ( function , function ) inserts the returned element as the last child if the selector function returns null " , function ( test )  {%NWL%var document = jsdom ( " <div id= ' one ' ><span class= ' before ' >< / span>< / div><div id= ' two ' ><span class= ' before ' >< / span>< / div> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) . insert ( function ( )  { return document . createElement ( " SPAN " ) ; } , function ( )  { return; } ) ,%NWL%three = one . querySelector ( " span:last - child " ) ,%NWL%four = two . querySelector ( " span:last - child " ) ;%NWL%test . end ( ) ;%NWL%1
var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . equal ( d3 . selectAll ( [ one , two ] ) . node ( ) , one ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . node ( ) skips missing elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . end ( ) ;%NWL%4
var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . equal ( d3 . selectAll ( [ , one , , two ] ) . node ( ) , one ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . node ( ) skips empty groups " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " selection . node ( ) skips empty groups " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . equal ( d3 . selectAll ( [ one , two ] ) . selectAll ( function ( d , i )  { return i ? [ this ] : [ ] ; } ) . node ( ) , two ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . node ( ) returns null for an empty selection " , function ( test )  {%NWL%test . equal ( d3 . select ( null ) . node ( ) , null ) ;%NWL%test . equal ( d3 . selectAll ( [ ] ) . node ( ) , null ) ;%NWL%test . end ( ) ;%NWL%5
var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . deepEqual ( d3 . selectAll ( [ one , two ] ) . nodes ( ) ,  [ one , two ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . nodes ( ) merges nodes from all groups into a single array " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . end ( ) ;%NWL%4
var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . deepEqual ( d3 . selectAll ( [ one , two ] ) . selectAll ( function ( )  { return [ this ] ; } ) . nodes ( ) ,  [ one , two ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . nodes ( ) skips missing elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . end ( ) ;%NWL%4
d3 = require ( " . . / . . / " ) ;%NWL%tape ( " selection . on ( type , listener ) registers a listeners for the specified event type on each selected element " , function ( test )  {%NWL%var clicks = 0 ,%NWL%document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . on ( " click " , function ( )  {  + + clicks; } ) , selection ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%9
selection = d3 . selectAll ( [ one , two ] ) . on ( " click . foo " , function ( )  {  + + foo; } ) . on ( " click . bar " , function ( )  {  + + bar; } ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . equal ( foo , 2 ) ;%NWL%test . equal ( bar , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( type , listener , capture ) observes the specified capture flag , if any " , function ( test )  {%NWL%var result ,%NWL%selection = d3 . select ( { addEventListener: function ( type , listener , capture )  { result = capture; } } ) ;%NWL%test . equal ( selection . on ( " click . foo " , function ( )  { } , true ) , selection ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( selection . on ( " click . foo " , function ( )  { } , true ) , selection ) ;%NWL%test . deepEqual ( result , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( type ) returns the listener for the specified event type , if any " , function ( test )  {%NWL%var clicked = function ( )  { } ,%NWL%document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) . on ( " click " , clicked ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( selection . on ( " click . bar " ) , barred ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . equal ( foo , 0 ) ;%NWL%test . equal ( bar , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( type , null , capture ) ignores the specified capture flag , if any " , function ( test )  {%NWL%var clicks = 0 ,%NWL%clicked = function ( )  {  + + clicks; } ,%NWL%document = jsdom ( ) ,%NWL%selection . dispatch ( " click " ) ;%NWL%1
test . equal ( bar , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( type , null , capture ) ignores the specified capture flag , if any " , function ( test )  {%NWL%var clicks = 0 ,%NWL%clicked = function ( )  {  + + clicks; } ,%NWL%document = jsdom ( ) ,%NWL%selection = d3 . select ( document ) . on ( " click . foo " , clicked , true ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . equal ( clicks , 1 ) ;%NWL%test . equal ( clicks , 1 ) ;%NWL%9
two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) . on ( " click . foo " , clicked ) . on ( " load . foo " , loaded ) ;%NWL%test . equal ( selection . on ( " click . foo " ) , clicked ) ;%NWL%test . equal ( selection . on ( " load . foo " ) , loaded ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%selection . dispatch ( " load " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%test . equal ( loads , 2 ) ;%NWL%test . equal ( selection . on ( " . foo " , null ) , selection ) ;%NWL%test . equal ( selection . on ( " click . foo " ) , undefined ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%4
selection = d3 . selectAll ( [ one , two ] ) . on ( " click . foo " , clicked ) . on ( " load . foo " , loaded ) ;%NWL%test . equal ( selection . on ( " click . foo " ) , clicked ) ;%NWL%test . equal ( selection . on ( " load . foo " ) , loaded ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%selection . dispatch ( " load " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%test . equal ( loads , 2 ) ;%NWL%test . equal ( selection . on ( " . foo " , null ) , selection ) ;%NWL%test . equal ( selection . on ( " click . foo " ) , undefined ) ;%NWL%test . equal ( selection . on ( " load . foo " ) , undefined ) ;%NWL%selection . dispatch ( " load " ) ;%NWL%4
test . equal ( selection . on ( " click . foo " ) , clicked ) ;%NWL%test . equal ( selection . on ( " load . foo " ) , loaded ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%selection . dispatch ( " load " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%test . equal ( loads , 2 ) ;%NWL%test . equal ( selection . on ( " . foo " , null ) , selection ) ;%NWL%test . equal ( selection . on ( " click . foo " ) , undefined ) ;%NWL%test . equal ( selection . on ( " load . foo " ) , undefined ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%4
test . equal ( selection . on ( " load . foo " ) , loaded ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%selection . dispatch ( " load " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%test . equal ( loads , 2 ) ;%NWL%test . equal ( selection . on ( " . foo " , null ) , selection ) ;%NWL%test . equal ( selection . on ( " click . foo " ) , undefined ) ;%NWL%test . equal ( selection . on ( " load . foo " ) , undefined ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%selection . dispatch ( " load " ) ;%NWL%test . equal ( loads , 2 ) ;%NWL%4
selection . dispatch ( " click " ) ;%NWL%selection . dispatch ( " load " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%test . equal ( loads , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( name , null ) can remove a listener with capture " , function ( test )  {%NWL%var clicks = 0 ,%NWL%clicked = function ( )  {  + + clicks; } ,%NWL%document = jsdom ( ) ,%NWL%selection . dispatch ( " click " ) ;%NWL%0
test . equal ( loads , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( name , null ) can remove a listener with capture " , function ( test )  {%NWL%var clicks = 0 ,%NWL%clicked = function ( )  {  + + clicks; } ,%NWL%document = jsdom ( ) ,%NWL%selection = d3 . select ( document ) . on ( " click . foo " , clicked , true ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . equal ( clicks , 1 ) ;%NWL%test . equal ( clicks , 1 ) ;%NWL%9
selection . dispatch ( " click " ) ;%NWL%test . equal ( clicks , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( type ) skips missing elements " , function ( test )  {%NWL%var clicked = function ( )  { } ,%NWL%document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ one , two ] ) . on ( " click . foo " , clicked ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . on ( type , listener ) skips missing elements " , function ( test )  {%NWL%var clicks = 0 ,%NWL%clicked = function ( )  {  + + clicks; } ,%NWL%document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ , two ] ) . on ( " click . foo " , clicked ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " selection . on ( type , listener ) passes the listener the index as of registration time " , function ( test )  {%NWL%var result ,%NWL%document = jsdom ( " <parent id= ' one ' >< / parent> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%selection = d3 . selectAll ( [ , one ] ) . on ( " click " , function ( d , i )  { result = i; } ) ;%NWL%selection . dispatch ( " click " ) ;%NWL%test . deepEqual ( selection ,  { _groups: [ [ , one ] ] , _parents: [ null ] } ) ;%NWL%test . equal ( result , 1 ) ;%NWL%selection = selection . sort ( ) . dispatch ( " click " ) ;%NWL%test . equal ( result , 1 ) ;%NWL%8
selection = d3 . selectAll ( [ two , one ] ) ;%NWL%test . equal ( selection . order ( ) , selection ) ;%NWL%test . equal ( one . nextSibling , null ) ;%NWL%test . equal ( two . nextSibling , one ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . order ( ) only orders within each group " , function ( test )  {%NWL%var document = jsdom ( " <h1><span id= ' one ' >< / span>< / h1><h1><span id= ' two ' >< / span>< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%test . equal ( selection . order ( ) , selection ) ;%NWL%1
test . equal ( selection . order ( ) , selection ) ;%NWL%test . equal ( one . nextSibling , null ) ;%NWL%test . equal ( two . nextSibling , one ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . order ( ) only orders within each group " , function ( test )  {%NWL%var document = jsdom ( " <h1><span id= ' one ' >< / span>< / h1><h1><span id= ' two ' >< / span>< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . select ( document ) . selectAll ( " h1 " ) . selectAll ( " span " ) ;%NWL%test . equal ( one . nextSibling , null ) ;%NWL%1
test . equal ( two . nextSibling , one ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . order ( ) only orders within each group " , function ( test )  {%NWL%var document = jsdom ( " <h1><span id= ' one ' >< / span>< / h1><h1><span id= ' two ' >< / span>< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . select ( document ) . selectAll ( " h1 " ) . selectAll ( " span " ) ;%NWL%test . equal ( selection . order ( ) , selection ) ;%NWL%test . equal ( one . nextSibling , null ) ;%NWL%test . end ( ) ;%NWL%1
two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . select ( document ) . selectAll ( " h1 " ) . selectAll ( " span " ) ;%NWL%test . equal ( selection . order ( ) , selection ) ;%NWL%test . equal ( one . nextSibling , null ) ;%NWL%test . equal ( two . nextSibling , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . order ( ) does not re - append nodes that are already in order " , function ( test )  {%NWL%var two = { nextSibling: null } ,%NWL%one = { nextSibling: two } ,%NWL%test . equal ( selection . order ( ) , selection ) ;%NWL%2
test . equal ( selection . order ( ) , selection ) ;%NWL%test . equal ( one . nextSibling , null ) ;%NWL%test . equal ( two . nextSibling , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . order ( ) does not re - append nodes that are already in order " , function ( test )  {%NWL%var two = { nextSibling: null } ,%NWL%one = { nextSibling: two } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . order ( ) , selection ) ;%NWL%test . equal ( two . nextSibling , null ) ;%NWL%2
test . equal ( one . nextSibling , null ) ;%NWL%test . equal ( two . nextSibling , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . order ( ) does not re - append nodes that are already in order " , function ( test )  {%NWL%var two = { nextSibling: null } ,%NWL%one = { nextSibling: two } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . order ( ) , selection ) ;%NWL%test . equal ( one . nextSibling , two ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( d3 . select ( node ) . property ( " foo " ) , 42 ) ;%NWL%test . equal ( d3 . selectAll ( [ null , node ] ) . property ( " foo " ) , 42 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . property ( name , value ) sets property with the specified name on the selected elements " , function ( test )  {%NWL%var one = { } ,%NWL%two = { } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . property ( " foo " ,  " bar " ) , selection ) ;%NWL%test . equal ( one . foo ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( one . foo ,  " bar " ) ;%NWL%test . equal ( two . foo ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . property ( name , null ) removes the property with the specified name on the selected elements " , function ( test )  {%NWL%var one = { foo: " bar " } ,%NWL%two = { foo: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . property ( " foo " , null ) , selection ) ;%NWL%test . equal ( " foo " in one , false ) ;%NWL%test . end ( ) ;%NWL%2
selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . property ( " foo " , null ) , selection ) ;%NWL%test . equal ( " foo " in one , false ) ;%NWL%test . equal ( " foo " in two , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . property ( name , function ) sets the value of the property with the specified name on the selected elements " , function ( test )  {%NWL%var one = { foo: " bar " } ,%NWL%two = { foo: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( " foo " in one , false ) ;%NWL%2
test . equal ( " foo " in one , false ) ;%NWL%test . equal ( " foo " in two , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . property ( name , function ) sets the value of the property with the specified name on the selected elements " , function ( test )  {%NWL%var one = { foo: " bar " } ,%NWL%two = { foo: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . property ( " foo " , function ( d , i )  { return i ? " baz " : null; } ) , selection ) ;%NWL%test . equal ( " foo " in one , false ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( selection . remove ( ) , selection ) ;%NWL%test . equal ( one . parentNode , null ) ;%NWL%test . equal ( two . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . remove ( ) skips elements that have already been detached " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ two , one ] ) ;%NWL%test . equal ( selection . remove ( ) , selection ) ;%NWL%0
test . equal ( one . parentNode , null ) ;%NWL%test . equal ( two . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . remove ( ) skips elements that have already been detached " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ two , one ] ) ;%NWL%one . parentNode . removeChild ( one ) ;%NWL%test . equal ( one . parentNode , null ) ;%NWL%0
test . equal ( two . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . remove ( ) skips elements that have already been detached " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ two , one ] ) ;%NWL%one . parentNode . removeChild ( one ) ;%NWL%test . equal ( selection . remove ( ) , selection ) ;%NWL%test . equal ( two . parentNode , null ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . remove ( ) skips elements that have already been detached " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ two , one ] ) ;%NWL%one . parentNode . removeChild ( one ) ;%NWL%test . equal ( selection . remove ( ) , selection ) ;%NWL%test . equal ( one . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%0
one . parentNode . removeChild ( one ) ;%NWL%test . equal ( selection . remove ( ) , selection ) ;%NWL%test . equal ( one . parentNode , null ) ;%NWL%test . equal ( two . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . remove ( ) skips missing elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%test . equal ( selection . remove ( ) , selection ) ;%NWL%1
test . equal ( selection . remove ( ) , selection ) ;%NWL%test . equal ( one . parentNode , null ) ;%NWL%test . equal ( two . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . remove ( ) skips missing elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ , one ] ) ;%NWL%test . equal ( one . parentNode , null ) ;%NWL%1
test . equal ( two . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . remove ( ) skips missing elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%selection = d3 . selectAll ( [ , one ] ) ;%NWL%test . equal ( selection . remove ( ) , selection ) ;%NWL%test . equal ( one . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%1
two = document . querySelector ( " #two " ) ;%NWL%test . deepEqual ( d3 . selectAll ( [ ] ) . size ( ) , 0 ) ;%NWL%test . deepEqual ( d3 . selectAll ( [ one ] ) . size ( ) , 1 ) ;%NWL%test . deepEqual ( d3 . selectAll ( [ one , two ] ) . size ( ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . size ( ) skips missing elements " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ;%NWL%test . end ( ) ;%NWL%4
jsdom = require ( " . . / jsdom " ) ,%NWL%d3 = require ( " . . / . . / " ) ;%NWL%tape ( " d3 . style ( node , name ) returns the inline value of the style property with the specified name on the first selected element , if present " , function ( test )  {%NWL%var node = { style: { getPropertyValue: function ( name )  { return name === " color " ? " red " : " " } } } ;%NWL%test . equal ( d3 . style ( node ,  " color " ) ,  " red " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . style ( node , name ) returns the computed value of the style property with the specified name on the first selected element , if there is no inline style " , function ( test )  {%NWL%var style = { getPropertyValue: function ( name )  { return name === " color " ? " rgb ( 255 , 0 , 0 ) " : " " } } ,%NWL%node = { style: { getPropertyValue: function ( )  { return " " ; } } , ownerDocument: { defaultView: { getComputedStyle: function ( n )  { return n === node ? style : null; } } } } ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " d3 . style ( node , name ) returns the computed value of the style property with the specified name on the first selected element , if there is no inline style " , function ( test )  {%NWL%var style = { getPropertyValue: function ( name )  { return name === " color " ? " rgb ( 255 , 0 , 0 ) " : " " } } ,%NWL%node = { style: { getPropertyValue: function ( )  { return " " ; } } , ownerDocument: { defaultView: { getComputedStyle: function ( n )  { return n === node ? style : null; } } } } ;%NWL%test . equal ( d3 . style ( node ,  " color " ) ,  " rgb ( 255 , 0 , 0 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . style ( name ) returns the inline value of the style property with the specified name on the first selected element , if present " , function ( test )  {%NWL%var node = { style: { getPropertyValue: function ( name )  { return name === " color " ? " red " : " " } } } ;%NWL%test . equal ( d3 . select ( node ) . style ( " color " ) ,  " red " ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " selection . style ( name ) returns the inline value of the style property with the specified name on the first selected element , if present " , function ( test )  {%NWL%var node = { style: { getPropertyValue: function ( name )  { return name === " color " ? " red " : " " } } } ;%NWL%test . equal ( d3 . select ( node ) . style ( " color " ) ,  " red " ) ;%NWL%test . equal ( d3 . selectAll ( [ null , node ] ) . style ( " color " ) ,  " red " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . style ( name ) returns the computed value of the style property with the specified name on the first selected element , if there is no inline style " , function ( test )  {%NWL%var style = { getPropertyValue: function ( name )  { return name === " color " ? " rgb ( 255 , 0 , 0 ) " : " " } } ,%NWL%node = { style: { getPropertyValue: function ( )  { return " " ; } } , ownerDocument: { defaultView: { getComputedStyle: function ( n )  { return n === node ? style : null; } } } } ;%NWL%test . equal ( d3 . select ( node ) . style ( " color " ) ,  " rgb ( 255 , 0 , 0 ) " ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( d3 . select ( node ) . text ( ) ,  " hello " ) ;%NWL%test . equal ( d3 . selectAll ( [ null , node ] ) . text ( ) ,  " hello " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . text ( value ) sets text content on the selected elements " , function ( test )  {%NWL%var one = { textContent: " " } ,%NWL%two = { textContent: " " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . text ( " bar " ) , selection ) ;%NWL%test . equal ( one . textContent ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( one . textContent ,  " bar " ) ;%NWL%test . equal ( two . textContent ,  " bar " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . text ( null ) clears the text content on the selected elements " , function ( test )  {%NWL%var one = { textContent: " bar " } ,%NWL%two = { textContent: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . text ( null ) , selection ) ;%NWL%test . equal ( one . textContent ,  " " ) ;%NWL%test . end ( ) ;%NWL%2
selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . text ( null ) , selection ) ;%NWL%test . equal ( one . textContent ,  " " ) ;%NWL%test . equal ( two . textContent ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . text ( function ) sets the value of the text content on the selected elements " , function ( test )  {%NWL%var one = { textContent: " bar " } ,%NWL%two = { textContent: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( one . textContent ,  " " ) ;%NWL%2
test . equal ( one . textContent ,  " " ) ;%NWL%test . equal ( two . textContent ,  " " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . text ( function ) sets the value of the text content on the selected elements " , function ( test )  {%NWL%var one = { textContent: " bar " } ,%NWL%two = { textContent: " bar " } ,%NWL%selection = d3 . selectAll ( [ one , two ] ) ;%NWL%test . equal ( selection . text ( function ( d , i )  { return i ? " baz " : null; } ) , selection ) ;%NWL%test . equal ( one . textContent ,  " " ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . attrs can take a function that returns an object " , function ( test )  {%NWL%var document = jsdom . jsdom ( " <h1>hello< / h1><h2>world< / h2> " ) ,%NWL%h1 = document . querySelector ( " h1 " ) ,%NWL%h2 = document . querySelector ( " h2 " ) ;%NWL%d3 . selectAll ( [ h1 , h2 ] ) . attrs ( function ( d , i )  { return !i ? { foo: 42 } : { bar: " BAR " } ; } ) ;%NWL%test . equal ( h1 . getAttribute ( " foo " ) ,  " 42 " ) ;%NWL%test . equal ( h1 . hasAttribute ( " bar " ) , false ) ;%NWL%test . equal ( h2 . hasAttribute ( " foo " ) , false ) ;%NWL%test . end ( ) ;%NWL%0
buffer ,%NWL%x0z = new Array ( n ) ,%NWL%y0z = new Array ( n ) ;%NWL%if ( context == null ) output = curve ( buffer = path ( ) ) ;%NWL%for ( i = 0; i <= n; + + i )  {%NWL%if ( ! ( i < n && defined ( d = data [ i ] , i , data ) ) === defined0 )  {%NWL%if ( defined0 = !defined0 )  {%NWL%j = i;%NWL%output . areaStart ( ) ;%NWL%output . lineStart ( ) ;%NWL%output . lineEnd ( ) ;%NWL%8
x0z = new Array ( n ) ,%NWL%y0z = new Array ( n ) ;%NWL%if ( context == null ) output = curve ( buffer = path ( ) ) ;%NWL%for ( i = 0; i <= n; + + i )  {%NWL%if ( ! ( i < n && defined ( d = data [ i ] , i , data ) ) === defined0 )  {%NWL%if ( defined0 = !defined0 )  {%NWL%j = i;%NWL%output . areaStart ( ) ;%NWL%output . lineStart ( ) ;%NWL%} else {%NWL%output . lineStart ( ) ;%NWL%7
if ( ! ( i < n && defined ( d = data [ i ] , i , data ) ) === defined0 )  {%NWL%if ( defined0 = !defined0 )  {%NWL%j = i;%NWL%output . areaStart ( ) ;%NWL%output . lineStart ( ) ;%NWL%} else {%NWL%output . lineEnd ( ) ;%NWL%output . lineStart ( ) ;%NWL%for ( k = i - 1; k >= j; - - k )  {%NWL%output . point ( x0z [ k ] , y0z [ k ] ) ;%NWL%output . lineEnd ( ) ;%NWL%3
if ( defined0 = !defined0 )  {%NWL%j = i;%NWL%output . areaStart ( ) ;%NWL%output . lineStart ( ) ;%NWL%} else {%NWL%output . lineEnd ( ) ;%NWL%output . lineStart ( ) ;%NWL%for ( k = i - 1; k >= j; - - k )  {%NWL%output . point ( x0z [ k ] , y0z [ k ] ) ;%NWL%}%NWL%output . areaEnd ( ) ;%NWL%2
var std = 1 ,%NWL%mean = 0;%NWL%var input_pos_match = [ 2 , 4 , 2 ,  - 4 , 6 ,  - 10 , 7 , 2 ] ;%NWL%var input_no_match = [ 2 , 0 , 2 ,  - 4 , 6 , 0 , 7 , 2 ] ;%NWL%tape ( ' rule_8 marks high values ' , function ( test )  {%NWL%var result = rule_8 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_8 does not mark low values ' , function ( test )  {%NWL%test . notOk ( result ) ;%NWL%6
mean = 0;%NWL%var input_pos_match = [ 2 , 4 , 2 ,  - 4 , 6 ,  - 10 , 7 , 2 ] ;%NWL%var input_no_match = [ 2 , 0 , 2 ,  - 4 , 6 , 0 , 7 , 2 ] ;%NWL%tape ( ' rule_8 marks high values ' , function ( test )  {%NWL%var result = rule_8 ( input_pos_match , mean , std ) ;%NWL%test . ok ( result ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( ' rule_8 does not mark low values ' , function ( test )  {%NWL%var result = rule_8 ( input_no_match , mean , std ) ;%NWL%test . end ( ) ;%NWL%6
sn . worlds . table = table%NWL%table . step = step%NWL%table . msPerBeat = 60000 / table . bpm%NWL%1
sn . worlds . table = table%NWL%table . step = step%NWL%table . bpm = 150%NWL%table . msPerBeat = 60000 / table . bpm%NWL%table . class = ' source '%NWL%var rows = 16%NWL%, size = ~~ ( h / rows )%NWL%, w = Session . get ( ' width ' )  *  . 9%NWL%table . schema = d3 . range ( rows * rows ) . map ( d3 . functor ( false ) )%NWL%1
d3 . select ( canvas ) . on ( ' click ' , function ( )  {%NWL%jules * = - 1%NWL%} )%NWL%return function ( )  {%NWL%done = true%NWL%}%NWL%function fadeCanvas ( alpha )  {%NWL%cx . save ( )%NWL%cx . globalAlpha = alpha%NWL%cx . globalCompositeOperation = " copy "%NWL%cx . restore ( )%NWL%7
var stream = streams [ i ]%NWL%if ( stream [ 2 ] == 0 )  {%NWL%stream [ 0 ] = ~~ ( Math . random ( )  *  ( w + 2 * border ) )  - border%NWL%stream [ 1 ] = ~~ ( Math . random ( )  *  ( h + 2 * border ) )  - border%NWL%stream [ 2 ] = 30%NWL%}%NWL%var v = velocity ( stream [ 0 ] , stream [ 1 ] , t )%NWL%if ( v [ 0 ] <= w && v [ 1 ] <= h )  {%NWL%cx . beginPath ( )%NWL%cx . moveTo ( stream [ 0 ] , stream [ 1 ] )%NWL%cx . stroke ( )%NWL%8
stream [ 2 ] = 30%NWL%}%NWL%var v = velocity ( stream [ 0 ] , stream [ 1 ] , t )%NWL%if ( v [ 0 ] <= w && v [ 1 ] <= h )  {%NWL%cx . beginPath ( )%NWL%cx . moveTo ( stream [ 0 ] , stream [ 1 ] )%NWL%cx . lineTo ( stream [ 0 ]  + = v [ 0 ] , stream [ 1 ]  + = v [ 1 ] )%NWL%cx . stroke ( )%NWL%}%NWL%stream [ 2 ] - -%NWL%cx . restore ( )%NWL%4
} ,%NWL%lineEnd: function ( )  {%NWL%switch ( this . _point )  {%NWL%case 1: {%NWL%this . _context . moveTo ( this . _x2 , this . _y2 ) ;%NWL%this . _context . closePath ( ) ;%NWL%break;%NWL%}%NWL%case 2: {%NWL%this . _context . moveTo ( ( this . _x2 + 2 * this . _x3 )  / 3 ,  ( this . _y2 + 2 * this . _y3 )  / 3 ) ;%NWL%this . _context . closePath ( ) ;%NWL%5
this . _point = 0;%NWL%} ,%NWL%lineEnd: function ( )  {%NWL%switch ( this . _point )  {%NWL%case 1: {%NWL%this . _context . moveTo ( this . _x3 , this . _y3 ) ;%NWL%this . _context . closePath ( ) ;%NWL%break;%NWL%}%NWL%case 2: {%NWL%this . _context . closePath ( ) ;%NWL%6
this . _point = 0;%NWL%} ,%NWL%lineEnd: function ( )  {%NWL%switch ( this . _point )  {%NWL%case 1: {%NWL%this . _context . moveTo ( this . _x3 , this . _y3 ) ;%NWL%this . _context . closePath ( ) ;%NWL%break;%NWL%}%NWL%case 2: {%NWL%this . _context . closePath ( ) ;%NWL%6
} ;%NWL%link . context = function ( _ )  {%NWL%return arguments . length ? ( ( context = _ == null ? null : _ ) , link ) : context;%NWL%} ;%NWL%return link;%NWL%}%NWL%function curveHorizontal ( context , x0 , y0 , x1 , y1 )  {%NWL%context . moveTo ( x0 , y0 ) ;%NWL%context . bezierCurveTo ( x0 = ( x0 + x1 )  / 2 , y0 , x0 , y1 , x1 , y1 ) ;%NWL%}%NWL%context . moveTo ( x0 , y0 ) ;%NWL%7
test . equal ( a . y1 ( ) ( [ 42 , 34 ] ) , 34 ) ;%NWL%test . equal ( a . defined ( ) ( [ 42 , 34 ] ) , true ) ;%NWL%test . equal ( a . curve ( ) , shape . curveLinear ) ;%NWL%test . equal ( a . context ( ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ,  [ 4 , 5 ] ] ) ,  " M0 , 1L2 , 3L4 , 5L4 , 0L2 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " area . x ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x0 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x0 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " area . x0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x0 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x1 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x1 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " area . x1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . x1 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " area . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y0 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y0 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " area . y0 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y0 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y1 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y1 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . defined ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " area . y1 ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . y1 ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . defined ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . area ( ) . defined ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
shape . area ( ) . defined ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x ( x ) ( data ) observes the specified function " , function ( test )  {%NWL%var x = function ( d )  { return d . x; } ,%NWL%a = shape . area ( ) . x ( x ) ;%NWL%test . equal ( a . x ( ) , x ) ;%NWL%test . equal ( a . x0 ( ) , x ) ;%NWL%test . equal ( a . x1 ( ) , null ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( a . x ( ) , x ) ;%NWL%test . equal ( a . x0 ( ) , x ) ;%NWL%test . equal ( a . x1 ( ) , null ) ;%NWL%test . pathEqual ( a ( [ { x: 0 , 1: 1 } ,  { x: 2 , 1: 3 } ,  { x: 4 , 1: 5 } ] ) ,  " M0 , 1L2 , 3L4 , 5L4 , 0L2 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x ( x ) ( data ) observes the specified constant " , function ( test )  {%NWL%var x = 0 ,%NWL%a = shape . area ( ) . x ( x ) ;%NWL%test . equal ( a . x ( ) ( ) , 0 ) ;%NWL%test . equal ( a . x1 ( ) , null ) ;%NWL%2
test . equal ( a . x1 ( ) , null ) ;%NWL%test . pathEqual ( a ( [ { x: 0 , 1: 1 } ,  { x: 2 , 1: 3 } ,  { x: 4 , 1: 5 } ] ) ,  " M0 , 1L2 , 3L4 , 5L4 , 0L2 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . x ( x ) ( data ) observes the specified constant " , function ( test )  {%NWL%var x = 0 ,%NWL%a = shape . area ( ) . x ( x ) ;%NWL%test . equal ( a . x ( ) ( ) , 0 ) ;%NWL%test . equal ( a . x0 ( ) ( ) , 0 ) ;%NWL%test . equal ( a . x1 ( ) , null ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( a . x1 ( ) , null ) ;%NWL%test . pathEqual ( a ( [ { 1: 1 } ,  { 1: 3 } ,  { 1: 5 } ] ) ,  " M0 , 1L0 , 3L0 , 5L0 , 0L0 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y ( y ) ( data ) observes the specified function " , function ( test )  {%NWL%var y = function ( d )  { return d . y; } ,%NWL%a = shape . area ( ) . y ( y ) ;%NWL%test . equal ( a . y ( ) , y ) ;%NWL%test . equal ( a . y0 ( ) , y ) ;%NWL%test . equal ( a . y1 ( ) , null ) ;%NWL%test . end ( ) ;%NWL%2
a = shape . area ( ) . y ( y ) ;%NWL%test . equal ( a . y ( ) , y ) ;%NWL%test . equal ( a . y0 ( ) , y ) ;%NWL%test . equal ( a . y1 ( ) , null ) ;%NWL%test . pathEqual ( a ( [ { 0: 0 , y: 1 } ,  { 0: 2 , y: 3 } ,  { 0: 4 , y: 5 } ] ) ,  " M0 , 1L2 , 3L4 , 5L4 , 5L2 , 3L0 , 1Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y ( y ) ( data ) observes the specified constant " , function ( test )  {%NWL%var a = shape . area ( ) . y ( 0 ) ;%NWL%test . equal ( a . y ( ) ( ) , 0 ) ;%NWL%test . equal ( a . y1 ( ) , null ) ;%NWL%3
test . equal ( a . y0 ( ) , y ) ;%NWL%test . equal ( a . y1 ( ) , null ) ;%NWL%test . pathEqual ( a ( [ { 0: 0 , y: 1 } ,  { 0: 2 , y: 3 } ,  { 0: 4 , y: 5 } ] ) ,  " M0 , 1L2 , 3L4 , 5L4 , 5L2 , 3L0 , 1Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . y ( y ) ( data ) observes the specified constant " , function ( test )  {%NWL%var a = shape . area ( ) . y ( 0 ) ;%NWL%test . equal ( a . y ( ) ( ) , 0 ) ;%NWL%test . equal ( a . y0 ( ) ( ) , 0 ) ;%NWL%test . equal ( a . y1 ( ) , null ) ;%NWL%test . end ( ) ;%NWL%3
tape ( " area . y ( y ) ( data ) observes the specified constant " , function ( test )  {%NWL%var a = shape . area ( ) . y ( 0 ) ;%NWL%test . equal ( a . y ( ) ( ) , 0 ) ;%NWL%test . equal ( a . y0 ( ) ( ) , 0 ) ;%NWL%test . equal ( a . y1 ( ) , null ) ;%NWL%test . pathEqual ( a ( [ { 0: 0 } ,  { 0: 2 } ,  { 0: 4 } ] ) ,  " M0 , 0L2 , 0L4 , 0L4 , 0L2 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curve ) sets the curve method " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal ) ;%NWL%test . end ( ) ;%NWL%6
var a = shape . area ( ) . curve ( shape . curveCardinal ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 333333 , 0 , 2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) sets the cardinal spline tension " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( 0 . 1 ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " area . curve ( curveCardinal . tension ( tension ) ) sets the cardinal spline tension " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( 0 . 1 ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 1 . 700000 , 1 , 2 , 1C2 . 300000 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 300000 , 0 , 2 , 0C1 . 700000 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( 0 . 1 ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 1 . 700000 , 1 , 2 , 1C2 . 300000 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 300000 , 0 , 2 , 0C1 . 700000 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( " 0 . 1 " ) ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%2
test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 1 . 700000 , 1 , 2 , 1C2 . 300000 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 300000 , 0 , 2 , 0C1 . 700000 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( " 0 . 1 " ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%2
test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 1 . 700000 , 1 , 2 , 1C2 . 300000 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 300000 , 0 , 2 , 0C1 . 700000 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( " 0 . 1 " ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%2
test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 1 . 700000 , 1 , 2 , 1C2 . 300000 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 300000 , 0 , 2 , 0C1 . 700000 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( " 0 . 1 " ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 1 . 700000 , 1 , 2 , 1C2 . 300000 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 300000 , 0 , 2 , 0C1 . 700000 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%2
test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 1 . 700000 , 1 , 2 , 1C2 . 300000 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 300000 , 0 , 2 , 0C1 . 700000 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( " 0 . 1 " ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 700000 , 3 , 1 , 3C1 . 300000 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 300000 , 0 , 1 , 0C0 . 700000 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( l . y ( ) ( [ 42 , 34 ] ) , 34 ) ;%NWL%test . equal ( l . defined ( ) ( [ 42 , 34 ] ) , true ) ;%NWL%test . equal ( l . curve ( ) , shape . curveLinear ) ;%NWL%test . equal ( l . context ( ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ,  [ 4 , 5 ] ] ) ,  " M0 , 1L2 , 3L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . x ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . x ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . x ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . x ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " line . x ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . x ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . y ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . y ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . defined ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%5
} ) ;%NWL%tape ( " line . y ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . y ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . defined ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . defined ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . defined ( f ) ( data ) passes d , i and data to the specified function f " , function ( test )  {%NWL%var data = [ " a " ,  " b " ] , actual = [ ] ;%NWL%shape . line ( ) . defined ( function ( )  { actual . push ( [ ] . slice . call ( arguments ) ) ; } ) ( data ) ;%NWL%test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . x ( x ) ( data ) observes the specified function " , function ( test )  {%NWL%var l = shape . line ( ) . x ( function ( d )  { return d . x; } ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( actual ,  [ [ " a " , 0 , data ] ,  [ " b " , 1 , data ] ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . x ( x ) ( data ) observes the specified function " , function ( test )  {%NWL%var l = shape . line ( ) . x ( function ( d )  { return d . x; } ) ;%NWL%test . pathEqual ( l ( [ { x: 0 , 1: 1 } ,  { x: 2 , 1: 3 } ,  { x: 4 , 1: 5 } ] ) ,  " M0 , 1L2 , 3L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . x ( x ) ( data ) observes the specified constant " , function ( test )  {%NWL%var l = shape . line ( ) . x ( 0 ) ;%NWL%test . end ( ) ;%NWL%1
test . pathEqual ( l ( [ { x: 0 , 1: 1 } ,  { x: 2 , 1: 3 } ,  { x: 4 , 1: 5 } ] ) ,  " M0 , 1L2 , 3L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . x ( x ) ( data ) observes the specified constant " , function ( test )  {%NWL%var l = shape . line ( ) . x ( 0 ) ;%NWL%test . pathEqual ( l ( [ { 1: 1 } ,  { 1: 3 } ,  { 1: 5 } ] ) ,  " M0 , 1L0 , 3L0 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . y ( y ) ( data ) observes the specified function " , function ( test )  {%NWL%var l = shape . line ( ) . y ( function ( d )  { return d . y; } ) ;%NWL%test . end ( ) ;%NWL%1
test . pathEqual ( l ( [ { 1: 1 } ,  { 1: 3 } ,  { 1: 5 } ] ) ,  " M0 , 1L0 , 3L0 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . y ( y ) ( data ) observes the specified function " , function ( test )  {%NWL%var l = shape . line ( ) . y ( function ( d )  { return d . y; } ) ;%NWL%test . pathEqual ( l ( [ { 0: 0 , y: 1 } ,  { 0: 2 , y: 3 } ,  { 0: 4 , y: 5 } ] ) ,  " M0 , 1L2 , 3L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . y ( y ) ( data ) observes the specified constant " , function ( test )  {%NWL%var l = shape . line ( ) . y ( 0 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . y ( y ) ( data ) observes the specified constant " , function ( test )  {%NWL%var l = shape . line ( ) . y ( 0 ) ;%NWL%test . pathEqual ( l ( [ { 0: 0 } ,  { 0: 2 } ,  { 0: 4 } ] ) ,  " M0 , 0L2 , 0L4 , 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curve ) sets the curve method " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveLinearClosed ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . end ( ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%shape = require ( " . . / " ) ;%NWL%tape ( " symbols is the array of symbol types " , function ( test )  {%NWL%test . deepEqual ( shape . symbols ,  [%NWL%shape . symbolCircle ,%NWL%shape . symbolDiamond ,%NWL%4
var tape = require ( " tape " ) ,%NWL%shape = require ( " . . / " ) ;%NWL%tape ( " symbols is the array of symbol types " , function ( test )  {%NWL%test . deepEqual ( shape . symbols ,  [%NWL%shape . symbolCircle ,%NWL%shape . symbolCross ,%NWL%shape . symbolSquare ,%NWL%4
var tape = require ( " tape " ) ,%NWL%shape = require ( " . . / " ) ;%NWL%tape ( " symbols is the array of symbol types " , function ( test )  {%NWL%test . deepEqual ( shape . symbols ,  [%NWL%shape . symbolCircle ,%NWL%shape . symbolCross ,%NWL%shape . symbolDiamond ,%NWL%shape . symbolStar ,%NWL%4
var tape = require ( " tape " ) ,%NWL%shape = require ( " . . / " ) ;%NWL%tape ( " symbols is the array of symbol types " , function ( test )  {%NWL%test . deepEqual ( shape . symbols ,  [%NWL%shape . symbolCircle ,%NWL%shape . symbolCross ,%NWL%shape . symbolDiamond ,%NWL%shape . symbolSquare ,%NWL%shape . symbolTriangle ,%NWL%4
test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1L0 . 166667 , 1 . 333333C0 . 333333 , 1 . 666667 , 0 . 666667 , 2 . 333333 , 1 , 2 . 333333C1 . 333333 , 2 . 333333 , 1 . 666667 , 1 . 666667 , 1 . 833333 , 1 . 333333L2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveBasis ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveBasis ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%3
test . pathEqual ( l ( [ [ 0 , 0 ] ,  [ 0 , 10 ] ,  [ 10 , 10 ] ,  [ 10 , 0 ] ,  [ 0 , 0 ] ] ) ,  " M1 . 666667 , 8 . 333333C3 . 333333 , 10 , 6 . 666667 , 10 , 8 . 333333 , 8 . 333333C10 , 6 . 666667 , 10 , 3 . 333333 , 8 . 333333 , 1 . 666667 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveBasisOpen ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveBasisOpen ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 0 ] ,  [ 0 , 10 ] ,  [ 10 , 10 ] ] ) ,  " M1 . 666667 , 8 . 333333L1 . 666667 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 0 ] ,  [ 0 , 10 ] ,  [ 10 , 10 ] ,  [ 10 , 0 ] ] ) ,  " M1 . 666667 , 8 . 333333C3 . 333333 , 10 , 6 . 666667 , 10 , 8 . 333333 , 8 . 333333L8 . 333333 , 0C6 . 666667 , 0 , 3 . 333333 , 0 , 1 . 666667 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%1
var tape = require ( " tape " ) ,%NWL%shape = require ( " . . / . . / " ) ;%NWL%require ( " . . / pathEqual " ) ;%NWL%tape ( " line . curve ( curveBundle ) uses a default beta of 0 . 85 " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveBundle . beta ( 0 . 85 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveBundle ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveBundle . beta ( beta ) ) uses the specified beta " , function ( test )  {%NWL%test . end ( ) ;%NWL%6
var l = shape . line ( ) . curve ( shape . curveBundle . beta ( 0 . 85 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveBundle ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveBundle . beta ( beta ) ) uses the specified beta " , function ( test )  {%NWL%test . equal ( shape . line ( ) . curve ( shape . curveBundle . beta ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1L0 . 16666666666666666 , 1 . 222222222222222C0 . 3333333333333333 , 1 . 4444444444444444 , 0 . 6666666666666666 , 1 . 8888888888888886 , 1 , 1 . 9999999999999998C1 . 3333333333333333 , 2 . 1111111111111107 , 1 . 6666666666666667 , 1 . 8888888888888886 , 2 , 2C2 . 3333333333333335 , 2 . 111111111111111 , 2 . 6666666666666665 , 2 . 5555555555555554 , 2 . 8333333333333335 , 2 . 7777777777777772L3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveBundle . beta ( beta ) ) coerces the specified beta to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveBundle . beta ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinal ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinal ) uses a default tension of zero " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinal . tension ( 0 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinal ) uses a default tension of zero " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinal . tension ( 0 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinal ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinal . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinal . tension ( 0 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinal ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinal . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . pathEqual ( shape . line ( ) . curve ( shape . curveCardinal . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 833333 , 3 , 1 , 3C1 . 166667 , 3 , 1 . 833333 , 1 , 2 , 1C2 . 166667 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinal . tension ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinal . tension ( " 0 . 5 " ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinal . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCardinal ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 333333 , 0 , 2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal ) uses a default tension of zero " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( 0 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 333333 , 0 , 2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal ) uses a default tension of zero " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( 0 ) ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCardinal ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( 0 ) ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCardinal ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . pathEqual ( shape . area ( ) . curve ( shape . curveCardinal . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 833333 , 3 , 1 , 3C1 . 166667 , 3 , 1 . 833333 , 1 , 2 , 1C2 . 166667 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 166667 , 0 , 2 , 0C1 . 833333 , 0 , 1 . 166667 , 0 , 1 , 0C0 . 833333 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinal . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinal . tension ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinalClosed ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalClosed ) uses a default tension of zero " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinalClosed . tension ( 0 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalClosed ) uses a default tension of zero " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinalClosed . tension ( 0 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinalClosed ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalClosed . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinalClosed . tension ( 0 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinalClosed ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalClosed . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . pathEqual ( shape . line ( ) . curve ( shape . curveCardinalClosed . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 166667 , 3 , 1 . 833333 , 1 , 2 , 1C2 . 166667 , 1 , 3 . 166667 , 3 , 3 , 3C2 . 833333 , 3 , 0 . 166667 , 1 , 0 , 1C - 0 . 166667 , 1 , 0 . 833333 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalClosed . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinalClosed . tension ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinalClosed . tension ( " 0 . 5 " ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinalClosed . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalClosed ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalClosed ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1ZM0 , 0Z " ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1ZM0 , 0L1 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3M1 , 0C0 . 666667 , 0 , - 0 . 166667 , 0 , 0 , 0C0 . 166667 , 0 , 1 . 833333 , 0 , 2 , 0C2 . 166667 , 0 , 1 . 333333 , 0 , 1 , 0 " ) ;%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCardinalClosed ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1ZM0 , 0Z " ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1ZM0 , 0L1 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3M1 , 0C0 . 666667 , 0 , - 0 . 166667 , 0 , 0 , 0C0 . 166667 , 0 , 1 . 833333 , 0 , 2 , 0C2 . 166667 , 0 , 1 . 333333 , 0 , 1 , 0 " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3M2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , - 0 . 333333 , 0 , 0 , 0C0 . 333333 , 0 , 2 . 666667 , 0 , 3 , 0C3 . 333333 , 0 , 2 . 333333 , 0 , 2 , 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalClosed ) uses a default tension of zero " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalClosed . tension ( 0 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3M1 , 0C0 . 666667 , 0 , - 0 . 166667 , 0 , 0 , 0C0 . 166667 , 0 , 1 . 833333 , 0 , 2 , 0C2 . 166667 , 0 , 1 . 333333 , 0 , 1 , 0 " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3M2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , - 0 . 333333 , 0 , 0 , 0C0 . 333333 , 0 , 2 . 666667 , 0 , 3 , 0C3 . 333333 , 0 , 2 . 333333 , 0 , 2 , 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalClosed ) uses a default tension of zero " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalClosed . tension ( 0 ) ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCardinalClosed ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalClosed . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCardinalClosed . tension ( 0 ) ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCardinalClosed ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalClosed . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . pathEqual ( shape . area ( ) . curve ( shape . curveCardinalClosed . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 166667 , 3 , 1 . 833333 , 1 , 2 , 1C2 . 166667 , 1 , 3 . 166667 , 3 , 3 , 3C2 . 833333 , 3 , 0 . 166667 , 1 , 0 , 1C - 0 . 166667 , 1 , 0 . 833333 , 3 , 1 , 3M2 , 0C1 . 833333 , 0 , 1 . 166667 , 0 , 1 , 0C0 . 833333 , 0 , - 0 . 166667 , 0 , 0 , 0C0 . 166667 , 0 , 2 . 833333 , 0 , 3 , 0C3 . 166667 , 0 , 2 . 166667 , 0 , 2 , 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalClosed . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalClosed . tension ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinalOpen ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalOpen ) uses a default tension of zero " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinalOpen . tension ( 0 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalOpen ) uses a default tension of zero " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinalOpen . tension ( 0 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinalOpen ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalOpen . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinalOpen . tension ( 0 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinalOpen ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalOpen . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . pathEqual ( shape . line ( ) . curve ( shape . curveCardinalOpen . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 166667 , 3 , 1 . 833333 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCardinalOpen . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCardinalOpen . tension ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCardinalOpen . tension ( " 0 . 5 " ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCardinalOpen . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalOpen ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalOpen ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3L1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCardinalOpen ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3L1 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1L2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalOpen ) uses a default tension of zero " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalOpen . tension ( 0 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3L1 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1L2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalOpen ) uses a default tension of zero " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalOpen . tension ( 0 ) ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCardinalOpen ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalOpen . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCardinalOpen . tension ( 0 ) ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCardinalOpen ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalOpen . tension ( tension ) ) uses the specified tension " , function ( test )  {%NWL%test . pathEqual ( shape . area ( ) . curve ( shape . curveCardinalOpen . tension ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 166667 , 3 , 1 . 833333 , 1 , 2 , 1L2 , 0C1 . 833333 , 0 , 1 . 166667 , 0 , 1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCardinalOpen . tension ( tension ) ) coerces the specified tension to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCardinalOpen . tension ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " line . curve ( curveCatmullRom ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCatmullRom ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 1 ) ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%2
test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 0 . 5 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 0 . 5 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCatmullRom ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( alpha ) ) coerces the specified alpha to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%1
var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( " 0 . 5 " ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRom . alpha ( 0 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRom . alpha ( 0 ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCatmullRom . alpha ( 0 ) ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 2 , 1 , 2 , 1L2 , 0C2 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 333333 , 0 , 2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRom ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRom . alpha ( 0 . 5 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 , 1 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 , 3 , 3 , 3L3 , 0C3 , 0 , 2 . 333333 , 0 , 2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRom ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRom . alpha ( 0 . 5 ) ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCatmullRom ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRom . alpha ( alpha ) ) coerces the specified alpha to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRom . alpha ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%1
tape ( " line . curve ( curveCatmullRomClosed ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 200267 , 1 . 324038 , 2 , 1C1 . 810600 , 0 . 693544 , 0 . 189400 , 0 . 693544 , 0 , 1C - 0 . 200267 , 1 . 324038 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 160469 , 2 . 858341 , 3 , 3C2 . 796233 , 3 . 179882 , 0 . 203767 , 0 . 820118 , 0 , 1C - 0 . 160469 , 1 . 141659 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 0 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 200267 , 1 . 324038 , 2 , 1C1 . 810600 , 0 . 693544 , 0 . 189400 , 0 . 693544 , 0 , 1C - 0 . 200267 , 1 . 324038 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 160469 , 2 . 858341 , 3 , 3C2 . 796233 , 3 . 179882 , 0 . 203767 , 0 . 820118 , 0 , 1C - 0 . 160469 , 1 . 141659 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 0 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 ) ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%2
test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 200267 , 1 . 324038 , 2 , 1C1 . 810600 , 0 . 693544 , 0 . 189400 , 0 . 693544 , 0 , 1C - 0 . 200267 , 1 . 324038 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 160469 , 2 . 858341 , 3 , 3C2 . 796233 , 3 . 179882 , 0 . 203767 , 0 . 820118 , 0 , 1C - 0 . 160469 , 1 . 141659 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 0 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 200267 , 1 . 324038 , 2 , 1C1 . 810600 , 0 . 693544 , 0 . 189400 , 0 . 693544 , 0 , 1C - 0 . 200267 , 1 . 324038 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 160469 , 2 . 858341 , 3 , 3C2 . 796233 , 3 . 179882 , 0 . 203767 , 0 . 820118 , 0 , 1C - 0 . 160469 , 1 . 141659 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 0 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " line . curve ( curveCatmullRomClosed . alpha ( 0 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 1 ) ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%2
test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 166667 , 1 . 333333 , 2 , 1C1 . 833333 , 0 . 666667 , 0 . 166667 , 0 . 666667 , 0 , 1C - 0 . 166667 , 1 . 333333 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 333333 , 3 , 3 , 3C2 . 666667 , 3 , 0 . 333333 , 1 , 0 , 1C - 0 . 333333 , 1 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 236068 , 1 . 314757 , 2 , 1C1 . 788854 , 0 . 718473 , 0 . 211146 , 0 . 718473 , 0 , 1C - 0 . 236068 , 1 . 314757 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M1 , 3L0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 2 . 236068 , 1 . 314757 , 2 , 1C1 . 788854 , 0 . 718473 , 0 . 211146 , 0 . 718473 , 0 , 1C - 0 . 236068 , 1 . 314757 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 031652 , 2 . 746782 , 3 , 3C2 . 948962 , 3 . 408301 , 0 . 051038 , 0 . 591699 , 0 , 1C - 0 . 031652 , 1 . 253218 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 . 5 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 3 . 031652 , 2 . 746782 , 3 , 3C2 . 948962 , 3 . 408301 , 0 . 051038 , 0 . 591699 , 0 , 1C - 0 . 031652 , 1 . 253218 , 0 . 666667 , 3 , 1 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 . 5 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCatmullRomClosed ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( alpha ) ) coerces the specified alpha to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( shape . line ( ) . curve ( shape . curveCatmullRomClosed ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomClosed . alpha ( alpha ) ) coerces the specified alpha to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( " 0 . 5 " ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCatmullRomClosed . alpha ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRomClosed . alpha ( alpha ) ) coerces the specified alpha to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRomClosed . alpha ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%1
tape ( " line . curve ( curveCatmullRomOpen ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%2
test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%2
test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%2
test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen . alpha ( 1 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 1 ) ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 0 . 5 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRomOpen ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRomOpen . alpha ( 0 . 5 ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCatmullRomOpen ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveCatmullRom . alpha ( alpha ) ) coerces the specified alpha to a number " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%1
var l = shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( " 0 . 5 " ) ) ;%NWL%test . equal ( shape . line ( ) . curve ( shape . curveCatmullRom . alpha ( 0 . 5 ) ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRomOpen . alpha ( 0 . 5 ) ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRomOpen , 0 . 5 ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3L1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
var a = shape . area ( ) . curve ( shape . curveCatmullRomOpen , 0 . 5 ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ] ) , null ) ;%NWL%test . equal ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M1 , 3L1 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1L2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRomOpen ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRomOpen , 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%6
test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1L2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRomOpen ) uses a default alpha of 0 . 5 ( centripetal ) " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRomOpen , 0 . 5 ) ;%NWL%test . equal ( shape . area ( ) . curve ( shape . curveCatmullRomOpen ) ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) , a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveCatmullRomOpen . alpha ( alpha ) ) coerces the specified alpha to a number " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveCatmullRomOpen . alpha ( " 0 . 5 " ) ) ;%NWL%test . end ( ) ;%NWL%1
test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L2 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ,  [ 4 , 5 ] ] ) ,  " M0 , 1L2 , 3L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveLinear ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveLinear ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L2 , 3L2 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%3
var l = shape . line ( ) . curve ( shape . curveMonotoneX ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 . 333333 , 2 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 2 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 . 333333 , 2 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 1 , 2 , 1C2 . 333333 , 1 , 2 . 666667 , 2 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneX ) ( data ) preserves monotonicity in y " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneX ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( " line . curve ( curveMonotoneX ) ( data ) preserves monotonicity in y " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneX ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 200 , 100 ] ,  [ 300 , 300 ] ,  [ 400 , 300 ] ] ) ,  " M0 , 200C33 . 333333 , 150 , 66 . 666667 , 100 , 100 , 100C133 . 333333 , 100 , 166 . 666667 , 100 , 200 , 100C233 . 333333 , 100 , 266 . 666667 , 300 , 300 , 300C333 . 333333 , 300 , 366 . 666667 , 300 , 400 , 300 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneX ) ( data ) handles duplicate x - values " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneX ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 0 , 100 ] ,  [ 100 , 100 ] ,  [ 200 , 0 ] ] ) ,  " M0 , 200C0 , 200 , 0 , 100 , 0 , 100C33 . 333333 , 100 , 66 . 666667 , 100 , 100 , 100C133 . 333333 , 100 , 166 . 666667 , 50 , 200 , 0 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 100 , 0 ] ,  [ 200 , 0 ] ] ) ,  " M0 , 200C33 . 333333 , 183 . 333333 , 66 . 666667 , 166 . 666667 , 100 , 100C100 , 100 , 100 , 0 , 100 , 0C133 . 333333 , 0 , 166 . 666667 , 0 , 200 , 0 " ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " line . curve ( curveMonotoneX ) ( data ) handles duplicate x - values " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneX ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 0 , 100 ] ,  [ 100 , 100 ] ,  [ 200 , 0 ] ] ) ,  " M0 , 200C0 , 200 , 0 , 100 , 0 , 100C33 . 333333 , 100 , 66 . 666667 , 100 , 100 , 100C133 . 333333 , 100 , 166 . 666667 , 50 , 200 , 0 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 100 , 0 ] ,  [ 200 , 0 ] ] ) ,  " M0 , 200C33 . 333333 , 183 . 333333 , 66 . 666667 , 166 . 666667 , 100 , 100C100 , 100 , 100 , 0 , 100 , 0C133 . 333333 , 0 , 166 . 666667 , 0 , 200 , 0 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 200 , 100 ] ,  [ 200 , 0 ] ] ) ,  " M0 , 200C33 . 333333 , 150 , 66 . 666667 , 100 , 100 , 100C133 . 333333 , 100 , 166 . 666667 , 100 , 200 , 100C200 , 100 , 200 , 0 , 200 , 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneX ) ( data ) handles segments of infinite slope " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneX ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 150 ] ,  [ 100 , 50 ] ,  [ 200 , 0 ] ] ) ,  " M0 , 200C33 . 333333 , 191 . 666667 , 66 . 666667 , 183 . 333333 , 100 , 150C100 , 150 , 100 , 50 , 100 , 50C133 . 333333 , 16 . 666667 , 166 . 666667 , 8 . 333333 , 200 , 0 " ) ;%NWL%test . end ( ) ;%NWL%5
test . pathEqual ( l ( [ [ 200 , 0 ] ,  [ 100 , 50 ] ,  [ 100 , 150 ] ,  [ 0 , 200 ] ] ) ,  " M200 , 0C166 . 666667 , 8 . 333333 , 133 . 333333 , 16 . 666667 , 100 , 50C100 , 50 , 100 , 150 , 100 , 150C66 . 666667 , 183 . 333333 , 33 . 333333 , 191 . 666667 , 0 , 200 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneX ) ( data ) ignores coincident points " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneX ) ,%NWL%p = l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] ) , p ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ,  [ 200 , 0 ] ] ) , p ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveMonotoneX ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveMonotoneX ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 . 333333 , 2 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 2 , 2 , 1L2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 . 333333 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
var l = shape . line ( ) . curve ( shape . curveMonotoneY ) ;%NWL%test . equal ( l ( [ ] ) , null ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ] . map ( reflect ) ) ,  " M1 , 0Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] . map ( reflect ) ) ,  " M1 , 0L3 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] . map ( reflect ) ) ,  " M1 , 0C2 , 0 . 333333 , 3 , 0 . 666667 , 3 , 1C3 , 1 . 333333 , 2 , 1 . 666667 , 1 , 2 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] . map ( reflect ) ) ,  " M1 , 0C2 , 0 . 333333 , 3 , 0 . 666667 , 3 , 1C3 , 1 . 333333 , 1 , 1 . 666667 , 1 , 2C1 , 2 . 333333 , 2 , 2 . 666667 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneY ) ( data ) preserves monotonicity in y " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneY ) ;%NWL%test . end ( ) ;%NWL%6
} ) ;%NWL%tape ( " line . curve ( curveMonotoneY ) ( data ) preserves monotonicity in y " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneY ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 200 , 100 ] ,  [ 300 , 300 ] ,  [ 400 , 300 ] ] . map ( reflect ) ) ,  " M200 , 0C150 , 33 . 333333 , 100 , 66 . 666667 , 100 , 100C100 , 133 . 333333 , 100 , 166 . 666667 , 100 , 200C100 , 233 . 333333 , 300 , 266 . 666667 , 300 , 300C300 , 333 . 333333 , 300 , 366 . 666667 , 300 , 400 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneY ) ( data ) handles duplicate x - values " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneY ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 0 , 100 ] ,  [ 100 , 100 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) ,  " M200 , 0C200 , 0 , 100 , 0 , 100 , 0C100 , 33 . 333333 , 100 , 66 . 666667 , 100 , 100C100 , 133 . 333333 , 50 , 166 . 666667 , 0 , 200 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 100 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) ,  " M200 , 0C183 . 333333 , 33 . 333333 , 166 . 666667 , 66 . 666667 , 100 , 100C100 , 100 , 0 , 100 , 0 , 100C0 , 133 . 333333 , 0 , 166 . 666667 , 0 , 200 " ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " line . curve ( curveMonotoneY ) ( data ) handles duplicate x - values " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneY ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 0 , 100 ] ,  [ 100 , 100 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) ,  " M200 , 0C200 , 0 , 100 , 0 , 100 , 0C100 , 33 . 333333 , 100 , 66 . 666667 , 100 , 100C100 , 133 . 333333 , 50 , 166 . 666667 , 0 , 200 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 100 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) ,  " M200 , 0C183 . 333333 , 33 . 333333 , 166 . 666667 , 66 . 666667 , 100 , 100C100 , 100 , 0 , 100 , 0 , 100C0 , 133 . 333333 , 0 , 166 . 666667 , 0 , 200 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 100 ] ,  [ 200 , 100 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) ,  " M200 , 0C150 , 33 . 333333 , 100 , 66 . 666667 , 100 , 100C100 , 133 . 333333 , 100 , 166 . 666667 , 100 , 200C100 , 200 , 0 , 200 , 0 , 200 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneY ) ( data ) handles segments of infinite slope " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneY ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 200 ] ,  [ 100 , 150 ] ,  [ 100 , 50 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) ,  " M200 , 0C191 . 666667 , 33 . 333333 , 183 . 333333 , 66 . 666667 , 150 , 100C150 , 100 , 50 , 100 , 50 , 100C16 . 666667 , 133 . 333333 , 8 . 333333 , 166 . 666667 , 0 , 200 " ) ;%NWL%test . end ( ) ;%NWL%5
test . pathEqual ( l ( [ [ 200 , 0 ] ,  [ 100 , 50 ] ,  [ 100 , 150 ] ,  [ 0 , 200 ] ] . map ( reflect ) ) ,  " M0 , 200C8 . 333333 , 166 . 666667 , 16 . 666667 , 133 . 333333 , 50 , 100C50 , 100 , 150 , 100 , 150 , 100C183 . 333333 , 66 . 666667 , 191 . 666667 , 33 . 333333 , 200 , 0 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " line . curve ( curveMonotoneY ) ( data ) ignores coincident points " , function ( test )  {%NWL%var l = shape . line ( ) . curve ( shape . curveMonotoneY ) ,%NWL%p = l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) , p ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) , p ) ;%NWL%test . equal ( l ( [ [ 0 , 200 ] ,  [ 50 , 200 ] ,  [ 100 , 100 ] ,  [ 150 , 0 ] ,  [ 200 , 0 ] ,  [ 200 , 0 ] ] . map ( reflect ) ) , p ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveMonotoneY ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveMonotoneY ) ;%NWL%test . equal ( a ( [ ] . map ( reflect ) ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] . map ( reflect ) ) ,  " M1 , 0L1 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] . map ( reflect ) ) ,  " M1 , 0L3 , 1L3 , 0L1 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] . map ( reflect ) ) ,  " M1 , 0C2 , 0 . 333333 , 3 , 0 . 666667 , 3 , 1C3 , 1 . 333333 , 2 , 1 . 666667 , 1 , 2L1 , 0C1 , 0 , 3 , 0 , 3 , 0C3 , 0 , 1 , 0 , 1 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 . 333333 , 2 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 2 , 2 , 1 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ,  [ 3 , 3 ] ] ) ,  " M0 , 1C0 . 333333 , 2 . 111111 , 0 . 666667 , 3 . 222222 , 1 , 3C1 . 333333 , 2 . 777778 , 1 . 666667 , 1 . 222222 , 2 , 1C2 . 333333 , 0 . 777778 , 2 . 666667 , 1 . 888889 , 3 , 3 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveNatural ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveNatural ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ] ) ,  " M0 , 1L1 , 3L1 , 0L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 1 , 3 ] ,  [ 2 , 1 ] ] ) ,  " M0 , 1C0 . 333333 , 2 , 0 . 666667 , 3 , 1 , 3C1 . 333333 , 3 , 1 . 666667 , 2 , 2 , 1L2 , 0C1 . 666667 , 0 , 1 . 333333 , 0 , 1 , 0C0 . 666667 , 0 , 0 . 333333 , 0 , 0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%2
test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L1 , 1L1 , 3L2 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ,  [ 4 , 5 ] ] ) ,  " M0 , 1L1 , 1L1 , 3L3 , 3L3 , 5L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveStep ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveStep ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L1 , 1L1 , 3L2 , 3L2 , 0L1 , 0L1 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%3
test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L2 , 1L2 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ,  [ 4 , 5 ] ] ) ,  " M0 , 1L2 , 1L2 , 3L4 , 3L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveStepAfter ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveStepAfter ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L2 , 1L2 , 3L2 , 0L2 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%3
test . pathEqual ( l ( [ [ 0 , 1 ] ] ) ,  " M0 , 1Z " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L0 , 3L2 , 3 " ) ;%NWL%test . pathEqual ( l ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ,  [ 4 , 5 ] ] ) ,  " M0 , 1L0 , 3L2 , 3L2 , 5L4 , 5 " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " area . curve ( curveStepBefore ) ( data ) generates the expected path " , function ( test )  {%NWL%var a = shape . area ( ) . curve ( shape . curveStepBefore ) ;%NWL%test . equal ( a ( [ ] ) , null ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ] ) ,  " M0 , 1L0 , 0Z " ) ;%NWL%test . pathEqual ( a ( [ [ 0 , 1 ] ,  [ 2 , 3 ] ] ) ,  " M0 , 1L0 , 3L2 , 3L2 , 0L0 , 0L0 , 0Z " ) ;%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%shape = require ( " . . / . . / " ) ;%NWL%tape ( " stackOrderAscending ( series ) returns an order by sum " , function ( test )  {%NWL%test . deepEqual ( shape . stackOrderAscending ( [%NWL%[ [ 0 , 1 ] ,  [ 0 , 2 ] ,  [ 0 , 3 ] ] ,%NWL%[ [ 0 , 2 ] ,  [ 0 , 3 ] ,  [ 0 , 4 ] ] ,%NWL%[ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , 2 ] ]%NWL%] ) ,  [ 2 , 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%test . deepEqual ( shape . stackOrderAscending ( [%NWL%3
[ [ 0 , 2 ] ,  [ 0 , 3 ] ,  [ 0 , 4 ] ] ,%NWL%[ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , 2 ] ]%NWL%] ) ,  [ 2 , 0 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stackOrderAscending ( series ) treats NaN values as zero " , function ( test )  {%NWL%test . deepEqual ( shape . stackOrderAscending ( [%NWL%[ [ 0 , 1 ] ,  [ 0 , 2 ] ,  [ 0 , NaN ] ,  [ 0 , 3 ] ] ,%NWL%[ [ 0 , 2 ] ,  [ 0 , 3 ] ,  [ 0 , NaN ] ,  [ 0 , 4 ] ] ,%NWL%[ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , NaN ] ,  [ 0 , 2 ] ]%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%shape = require ( " . . / . . / " ) ;%NWL%tape ( " stackOrderDescending ( series ) returns an order by sum " , function ( test )  {%NWL%test . deepEqual ( shape . stackOrderDescending ( [%NWL%[ [ 0 , 1 ] ,  [ 0 , 2 ] ,  [ 0 , 3 ] ] ,%NWL%[ [ 0 , 2 ] ,  [ 0 , 3 ] ,  [ 0 , 4 ] ] ,%NWL%[ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , 2 ] ]%NWL%] ) ,  [ 1 , 0 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%test . deepEqual ( shape . stackOrderDescending ( [%NWL%3
[ [ 0 , 2 ] ,  [ 0 , 3 ] ,  [ 0 , 4 ] ] ,%NWL%[ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , 2 ] ]%NWL%] ) ,  [ 1 , 0 , 2 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " stackOrderDescending ( series ) treats NaN values as zero " , function ( test )  {%NWL%test . deepEqual ( shape . stackOrderDescending ( [%NWL%[ [ 0 , 1 ] ,  [ 0 , 2 ] ,  [ 0 , 3 ] ,  [ 0 , NaN ] ] ,%NWL%[ [ 0 , 2 ] ,  [ 0 , 3 ] ,  [ 0 , 4 ] ,  [ 0 , NaN ] ] ,%NWL%[ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 0 , 2 ] ,  [ 0 , NaN ] ]%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%time = require ( " . . / " ) ,%NWL%date = require ( " . / date " ) ;%NWL%tape ( " timeDays in an alias for timeDay . range " , function ( test )  {%NWL%test . equal ( time . timeDays , time . timeDay . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay is an alias for timeDay . floor " , function ( test )  {%NWL%test . end ( ) ;%NWL%5
test . equal ( time . timeDays , time . timeDay . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay is an alias for timeDay . floor " , function ( test )  {%NWL%test . equal ( time . timeDay , time . timeDay . floor ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . floor ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . floor ( date . local ( 2010 , 11 , 31 , 23 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . local ( 2011 , 00 , 01 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . floor ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . local ( 2011 , 02 , 12 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . floor ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . floor ( date . local ( 0011 , 10 , 06 , 07 ) ) , date . local ( 0011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . round ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . round ( date . local ( 2010 , 11 , 30 , 13 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . round ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 02 , 13 , 20 ) ) , date . local ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 02 , 13 , 20 ) ) , date . local ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2011 , 10 , 06 , 20 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . round ( date ) handles midnight in leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . round ( date ) handles midnight in leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeDay . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . ceil ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . ceil ( date . local ( 2010 , 11 , 30 , 23 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . local ( 2010 , 11 , 31 , 00 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " timeDay . ceil ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . ceil ( date . local ( 2010 , 11 , 30 , 23 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . local ( 2010 , 11 , 31 , 00 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . local ( 2010 , 11 , 31 , 01 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . ceil ( date ) observes start of daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 14 ) ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . local ( 2011 , 02 , 14 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . ceil ( date ) observes end of daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " timeDay . ceil ( date ) observes end of daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . ceil ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 10 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . ceil ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeDay . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date ) is an alias for timeDay . offset ( date , 1 ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeDay . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date ) is an alias for timeDay . offset ( date , 1 ) " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2011 , 00 , 01 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeDay . offset ( date ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeDay . offset ( date ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 11 , 29 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 ) ,  - 1 ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeDay . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 ) ,  - 1 ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2011 , 00 , 01 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 30 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 30 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 30 ) ,  + 1 ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . offset ( date , step ) allows step to be zero " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns days between start ( inclusive ) and stop ( exclusive ) " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 04 ) , date . local ( 2011 , 10 , 10 ) ) ,  [%NWL%date . local ( 2011 , 10 , 04 ) ,%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 06 ) ,%NWL%date . local ( 2011 , 10 , 07 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 09 )%NWL%test . end ( ) ;%NWL%0
date . local ( 2011 , 10 , 04 ) ,%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 06 ) ,%NWL%date . local ( 2011 , 10 , 07 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 09 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns days " , function ( test )  {%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%1
date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 06 ) ,%NWL%date . local ( 2011 , 10 , 07 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 09 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2011 , 10 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 10 , 06 ) ,%NWL%1
date . local ( 2011 , 10 , 06 ) ,%NWL%date . local ( 2011 , 10 , 07 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 09 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2011 , 10 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 07 ) ,%NWL%1
date . local ( 2011 , 10 , 07 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 09 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2011 , 10 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 06 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2011 , 10 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 06 ) ,%NWL%date . local ( 2011 , 10 , 07 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 09 ) ,%NWL%date . local ( 2011 , 10 , 10 )%NWL%test . end ( ) ;%NWL%0
date . local ( 2011 , 10 , 09 ) ,%NWL%date . local ( 2011 , 10 , 10 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( + date . local ( 2011 , 10 , 04 ) ,  + date . local ( 2011 , 10 , 07 ) ) ,  [%NWL%date . local ( 2011 , 10 , 04 ) ,%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 06 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeDay . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( + date . local ( 2011 , 10 , 04 ) ,  + date . local ( 2011 , 10 , 07 ) ) ,  [%NWL%date . local ( 2011 , 10 , 04 ) ,%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 06 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2011 , 10 , 06 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( new Date ( NaN ) , Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 10 ) , date . local ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 10 ) , date . local ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 10 ) , date . local ( 2011 , 10 , 10 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop , step ) returns every step day " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2011 , 10 , 14 , 13 ) , 3 ) ,  [%NWL%date . local ( 2011 , 10 , 05 ) ,%NWL%date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 11 ) ,%NWL%date . local ( 2011 , 10 , 14 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2011 , 10 , 08 ) ,%NWL%date . local ( 2011 , 10 , 11 ) ,%NWL%date . local ( 2011 , 10 , 14 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . range ( start , stop , step ) returns the empty array if step is zero , negative or NaN " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 00 ) , 0 ) ,  [ ] ) ;%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 00 ) ,  - 1 ) ,  [ ] ) ;%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 00 ) , 0 . 5 ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 00 ) ,  - 1 ) ,  [ ] ) ;%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 00 ) , 0 . 5 ) ,  [ ] ) ;%NWL%test . deepEqual ( time . timeDay . range ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 00 ) , NaN ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . count ( start , end ) counts days after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 00 ) ) , 128 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 , 01 ) , date . local ( 2011 , 04 , 09 , 00 ) ) , 128 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2010 , 11 , 31 , 23 ) , date . local ( 2011 , 04 , 09 , 00 ) ) , 129 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 08 , 23 ) ) , 127 ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 08 , 23 ) ) , 127 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 , 00 ) , date . local ( 2011 , 04 , 09 , 01 ) ) , 128 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 71 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 71 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 71 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 309 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 309 ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 71 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 71 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 71 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 309 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 309 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 02 ) ) , 309 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . count ( start , stop ) does not exhibit floating - point rounding error " , function ( test )  {%NWL%var date = new Date ( 2011 , 4 , 9 ) ;%NWL%test . end ( ) ;%NWL%6
test . equal ( time . timeDay . count ( date . local ( 2007 , 00 , 01 ) , date . local ( 2007 , 11 , 31 ) ) , 364 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2008 , 00 , 01 ) , date . local ( 2008 , 11 , 31 ) ) , 365 ) ; / / leap year%NWL%test . equal ( time . timeDay . count ( date . local ( 2009 , 00 , 01 ) , date . local ( 2009 , 11 , 31 ) ) , 364 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2010 , 00 , 01 ) , date . local ( 2010 , 11 , 31 ) ) , 364 ) ;%NWL%test . equal ( time . timeDay . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 11 , 31 ) ) , 364 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeDay . every ( step ) returns every stepth day , starting with the first day of the month " , function ( test )  {%NWL%test . deepEqual ( time . timeDay . every ( 3 ) . range ( date . local ( 2008 , 11 , 30 , 0 , 12 ) , date . local ( 2009 , 0 , 5 , 23 , 48 ) ) ,  [ date . local ( 2008 , 11 , 31 ) , date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( time . timeDay . every ( 5 ) . range ( date . local ( 2008 , 11 , 30 , 0 , 12 ) , date . local ( 2009 , 0 , 6 , 23 , 48 ) ) ,  [ date . local ( 2008 , 11 , 31 ) , date . local ( 2009 , 0 , 1 ) , date . local ( 2009 , 0 , 6 ) ] ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " timeFridays in an alias for timeFriday . range " , function ( test )  {%NWL%test . equal ( time . timeFridays , time . timeFriday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeFriday . floor ( date ) returns Fridays " , function ( test )  {%NWL%test . deepEqual ( time . timeFriday . floor ( date . local ( 2011 , 00 , 05 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeFriday . floor ( date . local ( 2011 , 00 , 06 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeFriday . floor ( date . local ( 2011 , 00 , 06 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeFriday . floor ( date . local ( 2011 , 00 , 06 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . timeFriday . floor ( date . local ( 2011 , 00 , 07 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeFriday . floor ( date . local ( 2011 , 00 , 07 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeFriday . count ( start , end ) counts Fridays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeFriday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 05 ) ) , 0 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 13 ) ) , 2 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2010 , 00 , 01 ) , date . local ( 2010 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2010 , 00 , 01 ) , date . local ( 2010 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . timeFriday . count ( date . local ( 2010 , 00 , 01 ) , date . local ( 2010 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2010 , 00 , 01 ) , date . local ( 2010 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeFriday . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeFriday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . timeFriday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeHour . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . local ( 2011 , 00 , 01 , 00 , 01 ) ) , date . local ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . floor ( date ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 02 , 13 , 08 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 02 , 13 , 09 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 02 , 13 , 09 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 02 , 13 , 09 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 02 , 13 , 10 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . floor ( date ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 07 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 07 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . floor ( date . utc ( 2011 , 10 , 06 , 09 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . ceil ( date ) returns hours " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 ) ) , date . local ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( time . timeHour . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . local ( 2011 , 00 , 01 , 00 , 01 ) ) , date . local ( 2011 , 00 , 01 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . ceil ( date ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 02 , 13 , 08 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 02 , 13 , 09 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 02 , 13 , 09 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 02 , 13 , 09 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 02 , 13 , 10 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 11 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . ceil ( date ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 07 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . timeHour . ceil ( date . utc ( 2011 , 10 , 06 , 09 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeHour . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeHour . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 21 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 12 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 11 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2011 , 00 , 01 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeHour . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 12 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 11 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2011 , 00 , 01 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2011 , 00 , 01 , 00 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 11 ) ,  + 1 ) , date . local ( 2010 , 11 , 31 , 12 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 11 ) ,  + 1 ) , date . local ( 2010 , 11 , 31 , 12 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 , 01 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " timeHour . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeHour . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) returns hours " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2010 , 11 , 31 , 12 , 30 ) , date . local ( 2010 , 11 , 31 , 15 , 30 ) ) ,  [%NWL%date . local ( 2010 , 11 , 31 , 13 ) ,%NWL%date . local ( 2010 , 11 , 31 , 14 ) ,%NWL%date . local ( 2010 , 11 , 31 , 15 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeHour . range ( start , stop ) returns hours " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2010 , 11 , 31 , 12 , 30 ) , date . local ( 2010 , 11 , 31 , 15 , 30 ) ) ,  [%NWL%date . local ( 2010 , 11 , 31 , 13 ) ,%NWL%date . local ( 2010 , 11 , 31 , 14 ) ,%NWL%date . local ( 2010 , 11 , 31 , 15 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2010 , 11 , 31 , 14 ) ,%NWL%date . local ( 2010 , 11 , 31 , 15 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2010 , 11 , 31 , 23 ) , date . local ( 2011 , 0 , 1 , 2 ) ) [ 0 ] , date . local ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " timeHour . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2010 , 11 , 31 , 23 ) , date . local ( 2011 , 0 , 1 , 2 ) ) [ 2 ] , date . local ( 2011 , 0 , 1 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) can skip hours " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2011 , 1 , 1 , 1 ) , date . local ( 2011 , 1 , 1 , 13 ) , 3 ) ,  [%NWL%date . local ( 2011 , 1 , 1 , 1 ) ,%NWL%date . local ( 2011 , 1 , 1 , 4 ) ,%NWL%date . local ( 2011 , 1 , 1 , 7 ) ,%NWL%date . local ( 2011 , 1 , 1 , 10 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2011 , 1 , 1 , 7 ) ,%NWL%date . local ( 2011 , 1 , 1 , 10 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2011 , 2 , 13 , 1 ) , date . local ( 2011 , 2 , 13 , 5 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 13 , 9 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 11 )%NWL%test . end ( ) ;%NWL%3
date . utc ( 2011 , 2 , 13 , 10 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 11 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2011 , 10 , 6 , 0 ) , date . local ( 2011 , 10 , 6 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 7 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 8 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 )%NWL%test . end ( ) ;%NWL%3
tape ( " timeHour . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( date . local ( 2011 , 10 , 6 , 0 ) , date . local ( 2011 , 10 , 6 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 7 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 8 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . every ( step ) returns every stepth hour , starting with the first hour of the day " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . every ( 4 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 47 ) , date . local ( 2008 , 11 , 31 , 13 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 16 ) , date . local ( 2008 , 11 , 30 , 20 ) , date . local ( 2008 , 11 , 31 , 0 ) , date . local ( 2008 , 11 , 31 , 4 ) , date . local ( 2008 , 11 , 31 , 8 ) , date . local ( 2008 , 11 , 31 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . timeHour . every ( 4 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 47 ) , date . local ( 2008 , 11 , 31 , 13 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 16 ) , date . local ( 2008 , 11 , 30 , 20 ) , date . local ( 2008 , 11 , 31 , 0 ) , date . local ( 2008 , 11 , 31 , 4 ) , date . local ( 2008 , 11 , 31 , 8 ) , date . local ( 2008 , 11 , 31 , 12 ) ] ) ;%NWL%test . deepEqual ( time . timeHour . every ( 12 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 47 ) , date . local ( 2008 , 11 , 31 , 13 , 57 ) ) ,  [ date . local ( 2008 , 11 , 31 , 0 ) , date . local ( 2008 , 11 , 31 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeHour . range ( start , stop ) returns every hour crossing the daylight savings boundary " , function ( test )  {%NWL%test . deepEqual ( time . timeHour . range ( new Date ( 1478422800000 - 2 * 36e5 ) , new Date ( 1478422800000 + 2 * 36e5 ) ) ,  [%NWL%new Date ( 1478415600000 ) ,  / / Sun Nov 06 2016 00:00:00 GMT - 0700 ( PDT )%NWL%new Date ( 1478419200000 ) ,  / / Sun Nov 06 2016 01:00:00 GMT - 0700 ( PDT )%NWL%new Date ( 1478422800000 ) ,  / / Sun Nov 06 2016 01:00:00 GMT - 0800 ( PDT )%NWL%new Date ( 1478426400000 )  / / Sun Nov 06 2016 02:00:00 GMT - 0800 ( PDT )%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeMinute . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . deepEqual ( time . timeMinute . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeMinute . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 59 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeMinute . floor ( date . local ( 2011 , 00 , 01 , 00 , 01 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . ceil ( date ) returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeMinute . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeMinute . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 59 ) ) , date . local ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " timeMinute . ceil ( date ) returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeMinute . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeMinute . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 59 ) ) , date . local ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMinute . ceil ( date . local ( 2011 , 00 , 01 , 00 , 01 , 00 ) ) , date . local ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeMinute . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeMinute . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 , 57 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 12 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 23 , 11 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2011 , 00 , 01 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeMinute . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 12 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 23 , 11 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2011 , 00 , 01 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2011 , 00 , 01 , 00 , 00 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 11 ) ,  + 1 ) , date . local ( 2010 , 11 , 31 , 23 , 12 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 11 ) ,  + 1 ) , date . local ( 2010 , 11 , 31 , 23 , 12 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " timeMinute . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeMinute . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . local ( 2010 , 11 , 31 , 23 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 2 ) ) ,  [%NWL%date . local ( 2010 , 11 , 31 , 23 , 59 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . local ( 2010 , 11 , 31 , 23 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 2 ) ) ,  [%NWL%date . local ( 2010 , 11 , 31 , 23 , 59 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . local ( 2010 , 11 , 31 , 23 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 2 ) ) [ 0 ] , date . local ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " timeMinute . range ( start , stop ) , has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . local ( 2010 , 11 , 31 , 23 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 2 ) ) [ 2 ] , date . local ( 2011 , 0 , 1 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , can skip minutes " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . local ( 2011 , 1 , 1 , 12 , 7 ) , date . local ( 2011 , 1 , 1 , 13 , 7 ) , 15 ) ,  [%NWL%date . local ( 2011 , 1 , 1 , 12 , 7 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 22 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 37 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 52 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2011 , 1 , 1 , 12 , 37 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 52 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . utc ( 2011 , 2 , 13 , 9 , 59 ) , date . utc ( 2011 , 2 , 13 , 10 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 13 , 9 , 59 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 1 )%NWL%test . end ( ) ;%NWL%3
date . utc ( 2011 , 2 , 13 , 10 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) , observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 1 )%NWL%test . end ( ) ;%NWL%3
tape ( " timeMinute . range ( start , stop ) , observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . every ( step ) returns every stepth minute , starting with the first minute of the hour " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . every ( 15 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 47 ) , date . local ( 2008 , 11 , 30 , 13 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 13 , 0 ) , date . local ( 2008 , 11 , 30 , 13 , 15 ) , date . local ( 2008 , 11 , 30 , 13 , 30 ) , date . local ( 2008 , 11 , 30 , 13 , 45 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . timeMinute . every ( 15 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 47 ) , date . local ( 2008 , 11 , 30 , 13 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 13 , 0 ) , date . local ( 2008 , 11 , 30 , 13 , 15 ) , date . local ( 2008 , 11 , 30 , 13 , 30 ) , date . local ( 2008 , 11 , 30 , 13 , 45 ) ] ) ;%NWL%test . deepEqual ( time . timeMinute . every ( 30 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 47 ) , date . local ( 2008 , 11 , 30 , 13 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 13 , 0 ) , date . local ( 2008 , 11 , 30 , 13 , 30 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMinute . range ( start , stop ) returns every minute crossing the daylight savings boundary " , function ( test )  {%NWL%test . deepEqual ( time . timeMinute . range ( new Date ( 1478422800000 - 2 * 6e4 ) , new Date ( 1478422800000 + 2 * 6e4 ) ) ,  [%NWL%new Date ( 1478422680000 ) ,  / / Sun Nov 06 2016 01:58:00 GMT - 0700 ( PDT )%NWL%new Date ( 1478422740000 ) ,  / / Sun Nov 06 2016 01:59:00 GMT - 0700 ( PDT )%NWL%new Date ( 1478422800000 ) ,  / / Sun Nov 06 2016 01:00:00 GMT - 0800 ( PDT )%NWL%new Date ( 1478422860000 )  / / Sun Nov 06 2016 01:01:00 GMT - 0800 ( PDT )%NWL%test . end ( ) ;%NWL%2
tape ( " timeMondays in an alias for timeMonday . range " , function ( test )  {%NWL%test . equal ( time . timeMondays , time . timeMonday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonday . floor ( date ) returns Mondays " , function ( test )  {%NWL%test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 02 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 03 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 03 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 02 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 03 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 03 ) ) ;%NWL%test . deepEqual ( time . timeMonday . floor ( date . local ( 2011 , 00 , 03 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 03 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonday . range ( start , stop , step ) returns every step Monday " , function ( test )  {%NWL%test . deepEqual ( time . timeMonday . range ( date . local ( 2011 , 11 , 01 ) , date . local ( 2012 , 00 , 15 ) , 2 ) ,  [%NWL%date . local ( 2011 , 11 , 05 ) ,%NWL%date . local ( 2011 , 11 , 19 ) ,%NWL%date . local ( 2012 , 00 , 02 )%NWL%test . end ( ) ;%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonday . count ( start , end ) counts Mondays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeMonday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 05 ) ) , 0 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 13 ) ) , 2 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2018 , 00 , 01 ) , date . local ( 2018 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2018 , 00 , 01 ) , date . local ( 2018 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . timeMonday . count ( date . local ( 2018 , 00 , 01 ) , date . local ( 2018 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2018 , 00 , 01 ) , date . local ( 2018 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonday . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeMonday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . timeMonday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%time = require ( " . . / " ) ,%NWL%date = require ( " . / date " ) ;%NWL%tape ( " timeMonths in an alias for timeMonth . range " , function ( test )  {%NWL%test . equal ( time . timeMonths , time . timeMonth . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . equal ( time . timeMonths , time . timeMonth . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( time . timeMonth . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeMonth . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 0011 , 10 , 06 , 07 ) ) , date . local ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( time . timeMonth . floor ( date . local ( 0011 , 10 , 06 , 07 ) ) , date . local ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 01 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( time . timeMonth . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 01 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeMonth . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeMonth . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 09 , 31 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2010 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeMonth . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2010 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2011 , 00 , 01 ) ,  - 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 10 , 01 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 10 , 01 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 10 , 01 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 10 , 01 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 01 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 10 , 01 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 01 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonths in an alias for timeMonth . range " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonths in an alias for timeMonth . range " , function ( test )  {%NWL%test . equal ( time . timeMonths , time . timeMonth . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2010 , 11 , 31 , 23 ) ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 2011 , 00 , 01 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . floor ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . floor ( date . local ( 0011 , 10 , 06 , 07 ) ) , date . local ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . round ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . round ( date . local ( 2010 , 11 , 16 , 12 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . round ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 02 , 13 , 20 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 02 , 13 , 20 ) ) , date . local ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2011 , 10 , 06 , 20 ) ) , date . local ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . round ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%6
tape ( " timeMonth . round ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2010 , 10 , 30 , 23 ) ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2010 , 11 , 01 , 01 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 1 , 1 ) ) , date . local ( 2011 , 1 , 1 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . local ( 2011 , 2 , 1 ) ) , date . local ( 2011 , 2 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . local ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . local ( 2011 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . ceil ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) is an alias for timeMonth . offset ( date , 1 ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . local ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date ) is an alias for timeMonth . offset ( date , 1 ) " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeMonth . offset ( date ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeMonth . offset ( date ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 09 , 31 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 ) ,  - 1 ) , date . local ( 2010 , 10 , 31 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 ) ,  - 1 ) , date . local ( 2010 , 10 , 31 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2011 , 00 , 01 ) ,  - 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 ) ,  + 1 ) , date . local ( 2011 , 00 , 31 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 30 ) ,  + 2 ) , date . local ( 2011 , 01 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 ) ,  + 1 ) , date . local ( 2011 , 00 , 31 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 30 ) ,  + 2 ) , date . local ( 2011 , 01 , 30 ) ) ;%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 30 ) ,  + 1 ) , date . local ( 2011 , 00 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . offset ( date , step ) allows step to be zero " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months between start ( inclusive ) and stop ( exclusive ) " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 11 , 01 ) , date . local ( 2012 , 05 , 01 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%test . end ( ) ;%NWL%0
date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%0
date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%0
date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%0
date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%0
date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%0
date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 10 , 04 , 02 ) , date . local ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%test . end ( ) ;%NWL%0
date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%0
date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 ) ,%NWL%date . local ( 2012 , 02 , 01 ) ,%NWL%date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( + date . local ( 2011 , 10 , 04 ) ,  + date . local ( 2012 , 01 , 07 ) ) ,  [%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%0
date . local ( 2012 , 03 , 01 ) ,%NWL%date . local ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( + date . local ( 2011 , 10 , 04 ) ,  + date . local ( 2012 , 01 , 07 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( + date . local ( 2011 , 10 , 04 ) ,  + date . local ( 2012 , 01 , 07 ) ) ,  [%NWL%date . local ( 2011 , 11 , 01 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 01 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2012 , 01 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( new Date ( NaN ) , Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 11 , 10 ) , date . local ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " timeMonth . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 11 , 10 ) , date . local ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 10 , 01 ) , date . local ( 2011 , 10 , 01 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2010 , 10 , 31 ) , date . local ( 2011 , 2 , 1 ) ) ,  [%NWL%date . local ( 2010 , 11 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 ) ,%NWL%date . local ( 2011 , 1 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2010 , 10 , 31 ) , date . local ( 2011 , 2 , 1 ) ) ,  [%NWL%date . local ( 2010 , 11 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 ) ,%NWL%date . local ( 2011 , 1 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2011 , 0 , 1 ) ,%NWL%date . local ( 2011 , 1 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2010 , 10 , 31 ) , date . local ( 2011 , 2 , 1 ) ) [ 0 ] , date . local ( 2010 , 11 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " timeMonth . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2010 , 10 , 31 ) , date . local ( 2011 , 2 , 1 ) ) [ 2 ] , date . local ( 2011 , 1 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) can skip months " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 1 , 1 ) , date . local ( 2012 , 1 , 1 ) , 3 ) ,  [%NWL%date . local ( 2011 , 1 , 1 ) ,%NWL%date . local ( 2011 , 4 , 1 ) ,%NWL%date . local ( 2011 , 7 , 1 ) ,%NWL%date . local ( 2011 , 10 , 1 )%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 1 , 1 ) , date . local ( 2012 , 1 , 1 ) , 3 ) ,  [%NWL%date . local ( 2011 , 1 , 1 ) ,%NWL%date . local ( 2011 , 4 , 1 ) ,%NWL%date . local ( 2011 , 7 , 1 ) ,%NWL%date . local ( 2011 , 10 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 0 , 1 ) , date . local ( 2011 , 4 , 1 ) ) ,  [%NWL%date . local ( 2011 , 1 , 1 ) ,%NWL%1
date . local ( 2011 , 10 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 0 , 1 ) , date . local ( 2011 , 4 , 1 ) ) ,  [%NWL%date . local ( 2011 , 0 , 1 ) ,%NWL%date . local ( 2011 , 1 , 1 ) ,%NWL%date . local ( 2011 , 2 , 1 ) ,%NWL%date . local ( 2011 , 3 , 1 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2011 , 3 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeMonth . range ( date . local ( 2011 , 9 , 1 ) , date . local ( 2012 , 1 , 1 ) ) ,  [%NWL%date . local ( 2011 , 9 , 1 ) ,%NWL%date . local ( 2011 , 10 , 1 ) ,%NWL%date . local ( 2011 , 11 , 1 ) ,%NWL%date . local ( 2012 , 0 , 1 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2012 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . count ( start , end ) counts months after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeMonth . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 04 , 01 ) ) , 4 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 03 , 30 ) ) , 3 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2010 , 11 , 31 ) , date . local ( 2011 , 03 , 30 ) ) , 4 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2010 , 11 , 31 ) , date . local ( 2011 , 04 , 01 ) ) , 5 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2009 , 11 , 31 ) , date . local ( 2012 , 04 , 01 ) ) , 29 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " timeMonth . count ( start , end ) counts months after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeMonth . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 04 , 01 ) ) , 4 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 03 , 30 ) ) , 3 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2010 , 11 , 31 ) , date . local ( 2011 , 03 , 30 ) ) , 4 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2010 , 11 , 31 ) , date . local ( 2011 , 04 , 01 ) ) , 5 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2009 , 11 , 31 ) , date . local ( 2012 , 04 , 01 ) ) , 29 ) ;%NWL%test . equal ( time . timeMonth . count ( date . local ( 2012 , 04 , 01 ) , date . local ( 2009 , 11 , 31 ) ) ,  - 29 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeMonth . every ( step ) returns every stepth month , starting with the first month of the year " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date = require ( " . / date " ) ;%NWL%tape ( " timeYear . every ( n ) . floor ( date ) returns integer multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . every ( 10 ) . floor ( date . local ( 2009 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . every ( 10 ) . floor ( date . local ( 2010 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2010 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . every ( 10 ) . floor ( date . local ( 2010 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2010 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( n ) . ceil ( date ) returns integer multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . every ( 100 ) . ceil ( date . local ( 1999 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . every ( 100 ) . ceil ( date . local ( 2000 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2000 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " timeYear . every ( n ) . ceil ( date ) returns integer multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . every ( 100 ) . ceil ( date . local ( 1999 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . every ( 100 ) . ceil ( date . local ( 2000 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . every ( 100 ) . ceil ( date . local ( 2000 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2100 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( n ) . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeYear . every ( 5 ) . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( n ) . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeYear . every ( 5 ) . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( n ) . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . every ( 5 ) . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2015 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( n ) . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . every ( 5 ) . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2015 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeYear . every ( 5 ) . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2000 , 11 , 31 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( n ) does not define interval . count or interval . every " , function ( test )  {%NWL%var decade = time . timeYear . every ( 10 ) ;%NWL%test . equal ( decade . count , undefined ) ;%NWL%test . end ( ) ;%NWL%0
var decade = time . timeYear . every ( 10 ) ;%NWL%test . equal ( decade . count , undefined ) ;%NWL%test . equal ( decade . every , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( n ) . range ( start , stop ) returns multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . every ( 10 ) . range ( date . local ( 2010 , 0 , 1 ) , date . local ( 2031 , 0 , 1 ) ) ,  [%NWL%date . local ( 2010 , 0 , 1 ) ,%NWL%date . local ( 2020 , 0 , 1 ) ,%NWL%date . local ( 2030 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
tape ( " timeSaturdays in an alias for timeSaturday . range " , function ( test )  {%NWL%test . equal ( time . timeSaturdays , time . timeSaturday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSaturday . floor ( date ) returns Saturdays " , function ( test )  {%NWL%test . deepEqual ( time . timeSaturday . floor ( date . local ( 2011 , 00 , 06 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeSaturday . floor ( date . local ( 2011 , 00 , 07 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeSaturday . floor ( date . local ( 2011 , 00 , 07 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeSaturday . floor ( date . local ( 2011 , 00 , 07 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeSaturday . floor ( date . local ( 2011 , 00 , 08 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 08 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeSaturday . floor ( date . local ( 2011 , 00 , 08 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 08 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSaturday . count ( start , end ) counts Saturdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 06 ) ) , 0 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 14 ) ) , 2 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSaturday . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . timeSaturday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
date = require ( " . / date " ) ;%NWL%tape ( " timeSecond . floor ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . deepEqual ( time . timeSecond . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 000 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 001 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . round ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . round ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . round ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 499 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " timeSecond . round ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . round ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . round ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 499 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . round ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 500 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . ceil ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 000 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " timeSecond . ceil ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 000 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 001 ) ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeSecond . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeSecond . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 , 999 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 57 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ,  - 2 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ,  - 1 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 1 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 1 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " timeSecond . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeSecond . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) ,  [%NWL%date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) ,  [%NWL%date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2011 , 0 , 1 , 0 , 0 , 0 ) ,%NWL%date . local ( 2011 , 0 , 1 , 0 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) [ 0 ] , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " timeSecond . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . local ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) [ 2 ] , date . local ( 2011 , 0 , 1 , 0 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop , step ) can skip seconds " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . local ( 2011 , 1 , 1 , 12 , 0 , 7 ) , date . local ( 2011 , 1 , 1 , 12 , 1 , 7 ) , 15 ) ,  [%NWL%date . local ( 2011 , 1 , 1 , 12 , 0 , 7 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 0 , 22 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 0 , 37 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 0 , 52 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2011 , 1 , 1 , 12 , 0 , 37 ) ,%NWL%date . local ( 2011 , 1 , 1 , 12 , 0 , 52 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . utc ( 2011 , 2 , 13 , 9 , 59 , 59 ) , date . utc ( 2011 , 2 , 13 , 10 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 13 , 9 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
date . utc ( 2011 , 2 , 13 , 10 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
tape ( " timeSecond . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . every ( step ) returns every stepth second , starting with the first second of the minute " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . every ( 15 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 36 , 47 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 12 , 37 , 0 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 15 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 30 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 45 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . timeSecond . every ( 15 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 36 , 47 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 12 , 37 , 0 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 15 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 30 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 45 ) ] ) ;%NWL%test . deepEqual ( time . timeSecond . every ( 30 ) . range ( date . local ( 2008 , 11 , 30 , 12 , 36 , 47 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 57 ) ) ,  [ date . local ( 2008 , 11 , 30 , 12 , 37 , 0 ) , date . local ( 2008 , 11 , 30 , 12 , 37 , 30 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSecond . range ( start , stop ) returns every second crossing the daylight savings boundary " , function ( test )  {%NWL%test . deepEqual ( time . timeSecond . range ( new Date ( 1478422800000 - 2 * 1e3 ) , new Date ( 1478422800000 + 2 * 1e3 ) ) ,  [%NWL%new Date ( 1478422798000 ) ,  / / Sun Nov 06 2016 01:59:58 GMT - 0700 ( PDT )%NWL%new Date ( 1478422799000 ) ,  / / Sun Nov 06 2016 01:59:59 GMT - 0700 ( PDT )%NWL%new Date ( 1478422800000 ) ,  / / Sun Nov 06 2016 01:00:00 GMT - 0800 ( PDT )%NWL%new Date ( 1478422801000 )  / / Sun Nov 06 2016 01:00:01 GMT - 0800 ( PDT )%NWL%test . end ( ) ;%NWL%2
tape ( " timeSundays in an alias for timeSunday . range " , function ( test )  {%NWL%test . equal ( time . timeSundays , time . timeSunday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . floor ( date ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeSunday . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . floor ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . floor ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " timeSunday . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . floor ( date . local ( 0011 , 10 , 06 , 07 ) ) , date . local ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . ceil ( date ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeSunday . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . ceil ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 20 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . ceil ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 20 ) ) ;%NWL%test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 10 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date ) is an alias for timeSunday . offset ( date , 1 ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeSunday . ceil ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 10 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date ) is an alias for timeSunday . offset ( date , 1 ) " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . local ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeSunday . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeSunday . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 11 , 17 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 18 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 18 ) ) ;%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2011 , 00 , 01 ) ,  - 1 ) , date . local ( 2010 , 11 , 25 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 10 , 24 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 18 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 10 , 24 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 18 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 25 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . offset ( date , step ) allows step to be zero " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays between start ( inclusive ) and stop ( exclusive ) " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 ) , date . local ( 2012 , 00 , 15 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%test . end ( ) ;%NWL%0
date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%0
date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 , 12 , 23 ) , date . local ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%0
date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 , 12 , 23 ) , date . local ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%0
date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 , 12 , 23 ) , date . local ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%0
date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 , 12 , 23 ) , date . local ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%0
date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 , 12 , 23 ) , date . local ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 , 12 , 23 ) , date . local ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%test . end ( ) ;%NWL%0
date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%0
date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( + date . local ( 2011 , 11 , 01 ) ,  + date . local ( 2012 , 00 , 15 ) ) ,  [%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%0
date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( + date . local ( 2011 , 11 , 01 ) ,  + date . local ( 2012 , 00 , 15 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%0
date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( + date . local ( 2011 , 11 , 01 ) ,  + date . local ( 2012 , 00 , 15 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%0
date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( + date . local ( 2011 , 11 , 01 ) ,  + date . local ( 2012 , 00 , 15 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%0
date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( + date . local ( 2011 , 11 , 01 ) ,  + date . local ( 2012 , 00 , 15 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( + date . local ( 2011 , 11 , 01 ) ,  + date . local ( 2012 , 00 , 15 ) ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%test . end ( ) ;%NWL%0
date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 11 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2011 , 11 , 25 ) ,%NWL%date . local ( 2012 , 00 , 01 ) ,%NWL%date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( new Date ( NaN ) , Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 10 ) , date . local ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " timeSunday . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 10 ) , date . local ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 10 , 01 ) , date . local ( 2011 , 10 , 01 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . range ( start , stop , step ) returns every step Sunday " , function ( test )  {%NWL%test . deepEqual ( time . timeSunday . range ( date . local ( 2011 , 11 , 01 ) , date . local ( 2012 , 00 , 15 ) , 2 ) ,  [%NWL%date . local ( 2011 , 11 , 04 ) ,%NWL%date . local ( 2011 , 11 , 18 ) ,%NWL%date . local ( 2012 , 00 , 01 )%NWL%test . end ( ) ;%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . count ( start , end ) counts Sundays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeSunday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 04 ) ) , 0 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 05 ) ) , 1 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 12 ) ) , 2 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . timeSunday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeSunday . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeSunday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 11 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 11 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 11 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 45 ) ;%NWL%test . equal ( time . timeSunday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 45 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " timeThursdays in an alias for timeThursday . range " , function ( test )  {%NWL%test . equal ( time . timeThursdays , time . timeThursday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeThursday . floor ( date ) returns Thursdays " , function ( test )  {%NWL%test . deepEqual ( time . timeThursday . floor ( date . local ( 2011 , 00 , 04 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . timeThursday . floor ( date . local ( 2011 , 00 , 05 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . timeThursday . floor ( date . local ( 2011 , 00 , 05 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . timeThursday . floor ( date . local ( 2011 , 00 , 05 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . timeThursday . floor ( date . local ( 2011 , 00 , 06 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeThursday . floor ( date . local ( 2011 , 00 , 06 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeThursday . count ( start , end ) counts Thursdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeThursday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 04 ) ) , 0 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 05 ) ) , 1 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 12 ) ) , 2 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2015 , 00 , 01 ) , date . local ( 2015 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2015 , 00 , 01 ) , date . local ( 2015 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . timeThursday . count ( date . local ( 2015 , 00 , 01 ) , date . local ( 2015 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2015 , 00 , 01 ) , date . local ( 2015 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeThursday . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeThursday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . timeThursday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " timeTuesdays in an alias for timeTuesday . range " , function ( test )  {%NWL%test . equal ( time . timeTuesdays , time . timeTuesday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeTuesday . floor ( date ) returns Tuesdays " , function ( test )  {%NWL%test . deepEqual ( time . timeTuesday . floor ( date . local ( 2011 , 00 , 02 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . timeTuesday . floor ( date . local ( 2011 , 00 , 03 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . timeTuesday . floor ( date . local ( 2011 , 00 , 03 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . timeTuesday . floor ( date . local ( 2011 , 00 , 03 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . timeTuesday . floor ( date . local ( 2011 , 00 , 04 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 04 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeTuesday . floor ( date . local ( 2011 , 00 , 04 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 04 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeTuesday . count ( start , end ) counts Tuesdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 06 ) ) , 0 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 14 ) ) , 2 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2013 , 00 , 01 ) , date . local ( 2013 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2013 , 00 , 01 ) , date . local ( 2013 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . timeTuesday . count ( date . local ( 2013 , 00 , 01 ) , date . local ( 2013 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2013 , 00 , 01 ) , date . local ( 2013 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeTuesday . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . timeTuesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%time = require ( " . . / " ) ,%NWL%date = require ( " . / date " ) ;%NWL%tape ( " utcDays in an alias for utcDay . range " , function ( test )  {%NWL%test . equal ( time . utcDays , time . utcDay . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . floor ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2010 , 11 , 31 , 23 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 00 , 01 , 00 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . floor ( date ) does not observe daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 10 , 06 , 05 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 10 , 06 , 06 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 10 , 06 , 05 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 10 , 06 , 06 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . deepEqual ( time . utcDay . floor ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . round ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . round ( date . utc ( 2010 , 11 , 30 , 13 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . round ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . round ( date . utc ( 2010 , 11 , 30 , 13 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . utcDay . round ( date . utc ( 2010 , 11 , 30 , 11 ) ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . ceil ( date ) returns days " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2010 , 11 , 30 , 23 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2010 , 11 , 31 , 00 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . ceil ( date ) does not observe daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . utc ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . utc ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 05 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 06 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . utc ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 02 , 14 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 05 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 06 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date ) is an alias for utcDay . offset ( date , 1 ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . utcDay . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 10 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date ) is an alias for utcDay . offset ( date , 1 ) " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcDay . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcDay . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2010 , 11 , 29 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 ) ,  - 1 ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcDay . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 ) ,  - 1 ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 30 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 30 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 30 ) ,  + 1 ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . offset ( date , step ) allows step to be zero " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " utcDay . offset ( date , step ) allows step to be zero " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcDay . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . count ( start , end ) counts days after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 , 00 ) , date . utc ( 2011 , 04 , 09 , 00 ) ) , 128 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 , 01 ) , date . utc ( 2011 , 04 , 09 , 00 ) ) , 128 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2010 , 11 , 31 , 23 ) , date . utc ( 2011 , 04 , 09 , 00 ) ) , 129 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 , 00 ) , date . utc ( 2011 , 04 , 08 , 23 ) ) , 127 ) ;%NWL%test . end ( ) ;%NWL%3
test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 , 00 ) , date . utc ( 2011 , 04 , 08 , 23 ) ) , 127 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 , 00 ) , date . utc ( 2011 , 04 , 09 , 01 ) ) , 128 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 71 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 71 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 71 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 309 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 309 ) ;%NWL%test . end ( ) ;%NWL%2
test . equal ( time . utcDay . count ( date . utc ( 2007 , 00 , 01 ) , date . utc ( 2007 , 11 , 31 ) ) , 364 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2008 , 00 , 01 ) , date . utc ( 2008 , 11 , 31 ) ) , 365 ) ; / / leap year%NWL%test . equal ( time . utcDay . count ( date . utc ( 2009 , 00 , 01 ) , date . utc ( 2009 , 11 , 31 ) ) , 364 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2010 , 00 , 01 ) , date . utc ( 2010 , 11 , 31 ) ) , 364 ) ;%NWL%test . equal ( time . utcDay . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 11 , 31 ) ) , 364 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcDay . every ( step ) returns every stepth day , starting with the first day of the month " , function ( test )  {%NWL%test . deepEqual ( time . utcDay . every ( 3 ) . range ( date . utc ( 2008 , 11 , 30 , 0 , 12 ) , date . utc ( 2009 , 0 , 5 , 23 , 48 ) ) ,  [ date . utc ( 2008 , 11 , 31 ) , date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 4 ) ] ) ;%NWL%test . deepEqual ( time . utcDay . every ( 5 ) . range ( date . utc ( 2008 , 11 , 30 , 0 , 12 ) , date . utc ( 2009 , 0 , 6 , 23 , 48 ) ) ,  [ date . utc ( 2008 , 11 , 31 ) , date . utc ( 2009 , 0 , 1 ) , date . utc ( 2009 , 0 , 6 ) ] ) ;%NWL%test . end ( ) ;%NWL%5
tape ( " utcFridays in an alias for utcFriday . range " , function ( test )  {%NWL%test . equal ( time . utcFridays , time . utcFriday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcFriday . floor ( date ) returns Fridays " , function ( test )  {%NWL%test . deepEqual ( time . utcFriday . floor ( date . utc ( 2011 , 00 , 05 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . utcFriday . floor ( date . utc ( 2011 , 00 , 06 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . utcFriday . floor ( date . utc ( 2011 , 00 , 06 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . utcFriday . floor ( date . utc ( 2011 , 00 , 06 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 31 ) ) ;%NWL%test . deepEqual ( time . utcFriday . floor ( date . utc ( 2011 , 00 , 07 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcFriday . floor ( date . utc ( 2011 , 00 , 07 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 07 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcFriday . count ( start , end ) counts Fridays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 05 ) ) , 0 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 13 ) ) , 2 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2010 , 00 , 01 ) , date . utc ( 2010 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2010 , 00 , 01 ) , date . utc ( 2010 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . utcFriday . count ( date . utc ( 2010 , 00 , 01 ) , date . utc ( 2010 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2010 , 00 , 01 ) , date . utc ( 2010 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcFriday . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . utcFriday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . floor ( date ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 02 , 13 , 08 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 02 , 13 , 09 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 02 , 13 , 09 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 02 , 13 , 09 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 02 , 13 , 10 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . floor ( date ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 07 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 07 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . floor ( date . utc ( 2011 , 10 , 06 , 09 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . ceil ( date ) returns hours " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) ) , date . utc ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 01 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . ceil ( date ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 02 , 13 , 08 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 02 , 13 , 09 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 02 , 13 , 09 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 02 , 13 , 09 , 59 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 02 , 13 , 10 , 00 ) ) , date . utc ( 2011 , 02 , 13 , 10 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 02 , 13 , 10 , 01 ) ) , date . utc ( 2011 , 02 , 13 , 11 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . ceil ( date ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 07 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 08 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 08 , 59 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 09 , 00 ) ) , date . utc ( 2011 , 10 , 06 , 09 ) ) ;%NWL%test . deepEqual ( time . utcHour . ceil ( date . utc ( 2011 , 10 , 06 , 09 , 01 ) ) , date . utc ( 2011 , 10 , 06 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcHour . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcHour . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 21 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 12 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 11 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2011 , 00 , 01 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcHour . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 12 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 11 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2011 , 00 , 01 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2011 , 00 , 01 , 00 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 11 ) ,  + 1 ) , date . utc ( 2010 , 11 , 31 , 12 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 11 ) ,  + 1 ) , date . utc ( 2010 , 11 , 31 , 12 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 , 01 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " utcHour . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcHour . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . range ( start , stop ) returns hours " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2010 , 11 , 31 , 12 , 30 ) , date . utc ( 2010 , 11 , 31 , 15 , 30 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 31 , 13 ) ,%NWL%date . utc ( 2010 , 11 , 31 , 14 ) ,%NWL%date . utc ( 2010 , 11 , 31 , 15 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcHour . range ( start , stop ) returns hours " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2010 , 11 , 31 , 12 , 30 ) , date . utc ( 2010 , 11 , 31 , 15 , 30 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 31 , 13 ) ,%NWL%date . utc ( 2010 , 11 , 31 , 14 ) ,%NWL%date . utc ( 2010 , 11 , 31 , 15 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2010 , 11 , 31 , 14 ) ,%NWL%date . utc ( 2010 , 11 , 31 , 15 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2010 , 11 , 31 , 23 ) , date . utc ( 2011 , 0 , 1 , 2 ) ) [ 0 ] , date . utc ( 2010 , 11 , 31 , 23 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " utcHour . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2010 , 11 , 31 , 23 ) , date . utc ( 2011 , 0 , 1 , 2 ) ) [ 2 ] , date . utc ( 2011 , 0 , 1 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . range ( start , stop ) can skip hours " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2011 , 1 , 1 , 1 ) , date . utc ( 2011 , 1 , 1 , 13 ) , 3 ) ,  [%NWL%date . utc ( 2011 , 1 , 1 , 1 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 4 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 7 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 10 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2011 , 1 , 1 , 10 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . range ( start , stop ) does not observe the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2011 , 2 , 13 , 1 ) , date . utc ( 2011 , 2 , 13 , 5 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 13 , 1 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 2 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 3 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 4 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2011 , 2 , 13 , 2 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 3 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 4 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . range ( start , stop ) does not observe the end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2011 , 10 , 6 , 0 ) , date . utc ( 2011 , 10 , 6 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 1 )%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " utcHour . range ( start , stop ) does not observe the end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . range ( date . utc ( 2011 , 10 , 6 , 0 ) , date . utc ( 2011 , 10 , 6 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcHour . every ( step ) returns every stepth hour , starting with the first hour of the day " , function ( test )  {%NWL%test . deepEqual ( time . utcHour . every ( 4 ) . range ( date . utc ( 2008 , 11 , 30 , 12 , 47 ) , date . utc ( 2008 , 11 , 31 , 13 , 57 ) ) ,  [ date . utc ( 2008 , 11 , 30 , 16 ) , date . utc ( 2008 , 11 , 30 , 20 ) , date . utc ( 2008 , 11 , 31 , 0 ) , date . utc ( 2008 , 11 , 31 , 4 ) , date . utc ( 2008 , 11 , 31 , 8 ) , date . utc ( 2008 , 11 , 31 , 12 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . utcMinute . floor ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . deepEqual ( time . utcMinute . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcMinute . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 59 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcMinute . floor ( date . utc ( 2011 , 00 , 01 , 00 , 01 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . ceil ( date ) returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcMinute . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcMinute . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 59 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " utcMinute . ceil ( date ) returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcMinute . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcMinute . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 59 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMinute . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 01 , 00 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcMinute . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcMinute . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 , 57 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 12 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 11 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2011 , 00 , 01 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcMinute . offset ( date ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 12 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 11 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2011 , 00 , 01 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2011 , 00 , 01 , 00 , 00 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 11 ) ,  + 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 12 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 11 ) ,  + 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 12 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " utcMinute . offset ( date ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcMinute . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 31 , 23 , 59 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , returns minutes " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 31 , 23 , 59 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 2 ) ) [ 0 ] , date . utc ( 2010 , 11 , 31 , 23 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " utcMinute . range ( start , stop ) , has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 2 ) ) [ 2 ] , date . utc ( 2011 , 0 , 1 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , can skip minutes " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2011 , 1 , 1 , 12 , 7 ) , date . utc ( 2011 , 1 , 1 , 13 , 7 ) , 15 ) ,  [%NWL%date . utc ( 2011 , 1 , 1 , 12 , 7 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 22 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 37 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 52 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2011 , 1 , 1 , 12 , 37 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 52 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2011 , 2 , 13 , 9 , 59 ) , date . utc ( 2011 , 2 , 13 , 10 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 13 , 9 , 59 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 1 )%NWL%test . end ( ) ;%NWL%3
date . utc ( 2011 , 2 , 13 , 10 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . range ( start , stop ) , observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 1 )%NWL%test . end ( ) ;%NWL%3
tape ( " utcMinute . range ( start , stop ) , observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMinute . every ( step ) returns every stepth minute , starting with the first minute of the hour " , function ( test )  {%NWL%test . deepEqual ( time . utcMinute . every ( 15 ) . range ( date . utc ( 2008 , 11 , 30 , 12 , 47 ) , date . utc ( 2008 , 11 , 30 , 13 , 57 ) ) ,  [ date . utc ( 2008 , 11 , 30 , 13 , 0 ) , date . utc ( 2008 , 11 , 30 , 13 , 15 ) , date . utc ( 2008 , 11 , 30 , 13 , 30 ) , date . utc ( 2008 , 11 , 30 , 13 , 45 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
tape ( " utcMondays in an alias for utcMonday . range " , function ( test )  {%NWL%test . equal ( time . utcMondays , time . utcMonday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonday . floor ( date ) returns Mondays " , function ( test )  {%NWL%test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 02 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 03 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 03 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 02 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 27 ) ) ;%NWL%test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 03 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 03 ) ) ;%NWL%test . deepEqual ( time . utcMonday . floor ( date . utc ( 2011 , 00 , 03 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 03 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonday . range ( start , stop , step ) returns every step Monday " , function ( test )  {%NWL%test . deepEqual ( time . utcMonday . range ( date . utc ( 2011 , 11 , 01 ) , date . utc ( 2012 , 00 , 15 ) , 2 ) ,  [%NWL%date . utc ( 2011 , 11 , 05 ) ,%NWL%date . utc ( 2011 , 11 , 19 ) ,%NWL%date . utc ( 2012 , 00 , 02 )%NWL%test . end ( ) ;%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonday . count ( start , end ) counts Mondays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 05 ) ) , 0 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 13 ) ) , 2 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2018 , 00 , 01 ) , date . utc ( 2018 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2018 , 00 , 01 ) , date . utc ( 2018 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . utcMonday . count ( date . utc ( 2018 , 00 , 01 ) , date . utc ( 2018 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2018 , 00 , 01 ) , date . utc ( 2018 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonday . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . utcMonday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%time = require ( " . . / " ) ,%NWL%date = require ( " . / date " ) ;%NWL%tape ( " utcMonths in an alias for utcMonth . range " , function ( test )  {%NWL%test . equal ( time . utcMonths , time . utcMonth . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . floor ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2010 , 11 , 31 , 23 ) ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 00 , 01 , 00 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . floor ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . floor ( date . utc ( 0011 , 10 , 06 , 07 ) ) , date . utc ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . round ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2010 , 11 , 16 , 12 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . round ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 02 , 13 , 20 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 02 , 13 , 20 ) ) , date . utc ( 2011 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 20 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . round ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . utc ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . utcMonth . round ( date . utc ( 2011 , 10 , 06 , 20 ) ) , date . utc ( 2011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . round ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . utc ( 2012 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . round ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . utc ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . ceil ( date ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2010 , 10 , 30 , 23 ) ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . ceil ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 02 , 13 , 07 ) ) , date . utc ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 02 , 13 , 08 ) ) , date . utc ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 02 , 13 , 09 ) ) , date . utc ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 02 , 13 , 10 ) ) , date . utc ( 2011 , 03 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 07 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 08 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . ceil ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . utc ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 09 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2011 , 10 , 06 , 10 ) ) , date . utc ( 2011 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . ceil ( date ) handles midnight for leap years " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . utc ( 2012 , 02 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . utc ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date ) is an alias for utcMonth . offset ( date , 1 ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcMonth . ceil ( date . utc ( 2012 , 02 , 01 , 00 ) ) , date . utc ( 2012 , 02 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date ) is an alias for utcMonth . offset ( date , 1 ) " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcMonth . offset ( date ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcMonth . offset ( date ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2010 , 09 , 31 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 ) ,  - 1 ) , date . utc ( 2010 , 10 , 31 ) ) ;%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 ) ,  - 1 ) , date . utc ( 2010 , 10 , 31 ) ) ;%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 10 , 01 ) ) ;%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 1 ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 ) ,  + 1 ) , date . utc ( 2011 , 00 , 31 ) ) ;%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 30 ) ,  + 2 ) , date . utc ( 2011 , 01 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 ) ,  + 1 ) , date . utc ( 2011 , 00 , 31 ) ) ;%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 30 ) ,  + 2 ) , date . utc ( 2011 , 01 , 30 ) ) ;%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 30 ) ,  + 1 ) , date . utc ( 2011 , 00 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . offset ( date , step ) allows step to be zero " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months between start ( inclusive ) and stop ( exclusive ) " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 11 , 01 ) , date . utc ( 2012 , 05 , 01 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%test . end ( ) ;%NWL%0
date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%0
date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 10 , 04 , 02 ) , date . utc ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%0
date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 10 , 04 , 02 ) , date . utc ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%0
date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 10 , 04 , 02 ) , date . utc ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%0
date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 10 , 04 , 02 ) , date . utc ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%0
date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 10 , 04 , 02 ) , date . utc ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 10 , 04 , 02 ) , date . utc ( 2012 , 04 , 10 , 13 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%test . end ( ) ;%NWL%0
date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%0
date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 ) ,%NWL%date . utc ( 2012 , 02 , 01 ) ,%NWL%date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( + date . utc ( 2011 , 10 , 04 ) ,  + date . utc ( 2012 , 01 , 07 ) ) ,  [%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%0
date . utc ( 2012 , 03 , 01 ) ,%NWL%date . utc ( 2012 , 04 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( + date . utc ( 2011 , 10 , 04 ) ,  + date . utc ( 2012 , 01 , 07 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( + date . utc ( 2011 , 10 , 04 ) ,  + date . utc ( 2012 , 01 , 07 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 01 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2012 , 01 , 01 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( new Date ( NaN ) , Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 11 , 10 ) , date . utc ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcMonth . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 11 , 10 ) , date . utc ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 10 , 01 ) , date . utc ( 2011 , 10 , 01 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2010 , 10 , 31 ) , date . utc ( 2011 , 2 , 1 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 1 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) returns months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2010 , 10 , 31 ) , date . utc ( 2011 , 2 , 1 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 1 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2011 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 1 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2010 , 10 , 31 ) , date . utc ( 2011 , 2 , 1 ) ) [ 0 ] , date . utc ( 2010 , 11 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " utcMonth . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2010 , 10 , 31 ) , date . utc ( 2011 , 2 , 1 ) ) [ 2 ] , date . utc ( 2011 , 1 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) can skip months " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 1 , 1 ) , date . utc ( 2012 , 1 , 1 ) , 3 ) ,  [%NWL%date . utc ( 2011 , 1 , 1 ) ,%NWL%date . utc ( 2011 , 4 , 1 ) ,%NWL%date . utc ( 2011 , 7 , 1 ) ,%NWL%date . utc ( 2011 , 10 , 1 )%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 1 , 1 ) , date . utc ( 2012 , 1 , 1 ) , 3 ) ,  [%NWL%date . utc ( 2011 , 1 , 1 ) ,%NWL%date . utc ( 2011 , 4 , 1 ) ,%NWL%date . utc ( 2011 , 7 , 1 ) ,%NWL%date . utc ( 2011 , 10 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 0 , 1 ) , date . utc ( 2011 , 4 , 1 ) ) ,  [%NWL%date . utc ( 2011 , 1 , 1 ) ,%NWL%1
date . utc ( 2011 , 10 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 0 , 1 ) , date . utc ( 2011 , 4 , 1 ) ) ,  [%NWL%date . utc ( 2011 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 1 , 1 ) ,%NWL%date . utc ( 2011 , 2 , 1 ) ,%NWL%date . utc ( 2011 , 3 , 1 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2011 , 3 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcMonth . range ( date . utc ( 2011 , 9 , 1 ) , date . utc ( 2012 , 1 , 1 ) ) ,  [%NWL%date . utc ( 2011 , 9 , 1 ) ,%NWL%date . utc ( 2011 , 10 , 1 ) ,%NWL%date . utc ( 2011 , 11 , 1 ) ,%NWL%date . utc ( 2012 , 0 , 1 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2012 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . count ( start , end ) counts months after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 04 , 01 ) ) , 4 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 03 , 30 ) ) , 3 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2010 , 11 , 31 ) , date . utc ( 2011 , 03 , 30 ) ) , 4 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2010 , 11 , 31 ) , date . utc ( 2011 , 04 , 01 ) ) , 5 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2009 , 11 , 31 ) , date . utc ( 2012 , 04 , 01 ) ) , 29 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcMonth . count ( start , end ) counts months after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 04 , 01 ) ) , 4 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 03 , 30 ) ) , 3 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2010 , 11 , 31 ) , date . utc ( 2011 , 03 , 30 ) ) , 4 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2010 , 11 , 31 ) , date . utc ( 2011 , 04 , 01 ) ) , 5 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2009 , 11 , 31 ) , date . utc ( 2012 , 04 , 01 ) ) , 29 ) ;%NWL%test . equal ( time . utcMonth . count ( date . utc ( 2012 , 04 , 01 ) , date . utc ( 2009 , 11 , 31 ) ) ,  - 29 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcMonth . every ( step ) returns every stepth month , starting with the first month of the year " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date = require ( " . / date " ) ;%NWL%tape ( " utcYear . every ( n ) . floor ( date ) returns integer multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . every ( 10 ) . floor ( date . utc ( 2009 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . every ( 10 ) . floor ( date . utc ( 2010 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . every ( 10 ) . floor ( date . utc ( 2010 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( n ) . ceil ( date ) returns integer multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . every ( 100 ) . ceil ( date . utc ( 1999 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . every ( 100 ) . ceil ( date . utc ( 2000 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2000 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " utcYear . every ( n ) . ceil ( date ) returns integer multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . every ( 100 ) . ceil ( date . utc ( 1999 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . every ( 100 ) . ceil ( date . utc ( 2000 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2000 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . every ( 100 ) . ceil ( date . utc ( 2000 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2100 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( n ) . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcYear . every ( 5 ) . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( n ) . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcYear . every ( 5 ) . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( n ) . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . every ( 5 ) . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2015 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( n ) . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . every ( 5 ) . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2015 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcYear . every ( 5 ) . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2000 , 11 , 31 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( n ) does not define interval . count or interval . every " , function ( test )  {%NWL%var decade = time . utcYear . every ( 10 ) ;%NWL%test . equal ( decade . count , undefined ) ;%NWL%test . end ( ) ;%NWL%0
var decade = time . utcYear . every ( 10 ) ;%NWL%test . equal ( decade . count , undefined ) ;%NWL%test . equal ( decade . every , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( n ) . range ( start , stop ) returns multiples of n years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . every ( 10 ) . range ( date . utc ( 2010 , 0 , 1 ) , date . utc ( 2031 , 0 , 1 ) ) ,  [%NWL%date . utc ( 2010 , 0 , 1 ) ,%NWL%date . utc ( 2020 , 0 , 1 ) ,%NWL%date . utc ( 2030 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
tape ( " utcSaturdays in an alias for utcSaturday . range " , function ( test )  {%NWL%test . equal ( time . utcSaturdays , time . utcSaturday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSaturday . floor ( date ) returns Saturdays " , function ( test )  {%NWL%test . deepEqual ( time . utcSaturday . floor ( date . utc ( 2011 , 00 , 06 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcSaturday . floor ( date . utc ( 2011 , 00 , 07 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcSaturday . floor ( date . utc ( 2011 , 00 , 07 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcSaturday . floor ( date . utc ( 2011 , 00 , 07 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcSaturday . floor ( date . utc ( 2011 , 00 , 08 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 08 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcSaturday . floor ( date . utc ( 2011 , 00 , 08 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 08 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSaturday . count ( start , end ) counts Saturdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 06 ) ) , 0 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 14 ) ) , 2 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSaturday . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . utcSaturday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
date = require ( " . / date " ) ;%NWL%tape ( " utcSecond . floor ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . floor ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . deepEqual ( time . utcSecond . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 000 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 001 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . round ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . round ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . round ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 499 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " utcSecond . round ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . round ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . round ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 499 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . round ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 500 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . ceil ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 000 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " utcSecond . ceil ( date ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 000 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 001 ) ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcSecond . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcSecond . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 , 999 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 57 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ,  - 2 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ,  - 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 1 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " utcSecond . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcSecond . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . range ( start , stop ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcSecond . range ( start , stop ) returns seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2011 , 0 , 1 , 0 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 0 , 1 , 0 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) [ 0 ] , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " utcSecond . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) , date . utc ( 2011 , 0 , 1 , 0 , 0 , 2 ) ) [ 2 ] , date . utc ( 2011 , 0 , 1 , 0 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . range ( start , stop , step ) can skip seconds " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2011 , 1 , 1 , 12 , 0 , 7 ) , date . utc ( 2011 , 1 , 1 , 12 , 1 , 7 ) , 15 ) ,  [%NWL%date . utc ( 2011 , 1 , 1 , 12 , 0 , 7 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 0 , 22 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 0 , 37 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 0 , 52 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2011 , 1 , 1 , 12 , 0 , 37 ) ,%NWL%date . utc ( 2011 , 1 , 1 , 12 , 0 , 52 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2011 , 2 , 13 , 9 , 59 , 59 ) , date . utc ( 2011 , 2 , 13 , 10 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 13 , 9 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
date . utc ( 2011 , 2 , 13 , 10 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 2 , 13 , 10 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
tape ( " utcSecond . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . range ( date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) , date . utc ( 2011 , 10 , 6 , 9 , 0 , 2 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 , 8 , 59 , 59 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 0 ) ,%NWL%date . utc ( 2011 , 10 , 6 , 9 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSecond . every ( step ) returns every stepth second , starting with the first second of the minute " , function ( test )  {%NWL%test . deepEqual ( time . utcSecond . every ( 15 ) . range ( date . utc ( 2008 , 11 , 30 , 12 , 36 , 47 ) , date . utc ( 2008 , 11 , 30 , 12 , 37 , 57 ) ) ,  [ date . utc ( 2008 , 11 , 30 , 12 , 37 , 0 ) , date . utc ( 2008 , 11 , 30 , 12 , 37 , 15 ) , date . utc ( 2008 , 11 , 30 , 12 , 37 , 30 ) , date . utc ( 2008 , 11 , 30 , 12 , 37 , 45 ) ] ) ;%NWL%test . end ( ) ;%NWL%6
tape ( " utcSundays in an alias for utcSunday . range " , function ( test )  {%NWL%test . equal ( time . utcSundays , time . utcSunday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . floor ( date ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcSunday . floor ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . floor ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . floor ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 2011 , 10 , 06 , 01 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
tape ( " utcSunday . floor ( date ) handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . floor ( date . utc ( 0011 , 10 , 06 , 07 ) ) , date . utc ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . ceil ( date ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . ceil ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 20 ) ) ;%NWL%test . end ( ) ;%NWL%6
test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . ceil ( date ) observes daylight saving " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 20 ) ) ;%NWL%test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 10 , 06 , 01 ) ) , date . utc ( 2011 , 10 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date ) is an alias for utcSunday . offset ( date , 1 ) " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcSunday . ceil ( date . utc ( 2011 , 10 , 06 , 01 ) ) , date . utc ( 2011 , 10 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date ) is an alias for utcSunday . offset ( date , 1 ) " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) , date . utc ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcSunday . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcSunday . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) does not round the passed - in date " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2010 , 11 , 17 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 01 ) ,  - 1 ) , date . utc ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 18 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) allows step to be negative " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 01 ) ,  - 1 ) , date . utc ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 18 ) ) ;%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 1 ) , date . utc ( 2010 , 11 , 25 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 10 , 24 ) ,  + 1 ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 18 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) allows step to be positive " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 10 , 24 ) ,  + 1 ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 18 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 25 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . offset ( date , step ) allows step to be zero " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays between start ( inclusive ) and stop ( exclusive ) " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 ) , date . utc ( 2012 , 00 , 15 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%test . end ( ) ;%NWL%0
date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%0
date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 , 12 , 23 ) , date . utc ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%0
date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 , 12 , 23 ) , date . utc ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%0
date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 , 12 , 23 ) , date . utc ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%0
date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 , 12 , 23 ) , date . utc ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%0
date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 , 12 , 23 ) , date . utc ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns Sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 , 12 , 23 ) , date . utc ( 2012 , 00 , 14 , 12 , 23 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%test . end ( ) ;%NWL%0
date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%0
date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( + date . utc ( 2011 , 11 , 01 ) ,  + date . utc ( 2012 , 00 , 15 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%0
date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( + date . utc ( 2011 , 11 , 01 ) ,  + date . utc ( 2012 , 00 , 15 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%0
date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( + date . utc ( 2011 , 11 , 01 ) ,  + date . utc ( 2012 , 00 , 15 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%0
date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( + date . utc ( 2011 , 11 , 01 ) ,  + date . utc ( 2012 , 00 , 15 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%0
date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( + date . utc ( 2011 , 11 , 01 ) ,  + date . utc ( 2012 , 00 , 15 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) coerces start and stop to dates " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( + date . utc ( 2011 , 11 , 01 ) ,  + date . utc ( 2012 , 00 , 15 ) ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%test . end ( ) ;%NWL%0
date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 11 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2011 , 11 , 25 ) ,%NWL%date . utc ( 2012 , 00 , 01 ) ,%NWL%date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2012 , 00 , 08 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns the empty array for invalid dates " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( new Date ( NaN ) , Infinity ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 10 ) , date . utc ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcSunday . range ( start , stop ) returns the empty array if start >= stop " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 10 ) , date . utc ( 2011 , 10 , 04 ) ) ,  [ ] ) ;%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 10 , 01 ) , date . utc ( 2011 , 10 , 01 ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . range ( start , stop , step ) returns every step Sunday " , function ( test )  {%NWL%test . deepEqual ( time . utcSunday . range ( date . utc ( 2011 , 11 , 01 ) , date . utc ( 2012 , 00 , 15 ) , 2 ) ,  [%NWL%date . utc ( 2011 , 11 , 04 ) ,%NWL%date . utc ( 2011 , 11 , 18 ) ,%NWL%date . utc ( 2012 , 00 , 01 )%NWL%test . end ( ) ;%NWL%3
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . count ( start , end ) counts Sundays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 04 ) ) , 0 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 05 ) ) , 1 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 12 ) ) , 2 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . utcSunday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcSunday . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 11 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 11 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 11 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 45 ) ;%NWL%test . equal ( time . utcSunday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 45 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcThursdays in an alias for utcThursday . range " , function ( test )  {%NWL%test . equal ( time . utcThursdays , time . utcThursday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcThursday . floor ( date ) returns Thursdays " , function ( test )  {%NWL%test . deepEqual ( time . utcThursday . floor ( date . utc ( 2011 , 00 , 04 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . utcThursday . floor ( date . utc ( 2011 , 00 , 05 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . utcThursday . floor ( date . utc ( 2011 , 00 , 05 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . utcThursday . floor ( date . utc ( 2011 , 00 , 05 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 30 ) ) ;%NWL%test . deepEqual ( time . utcThursday . floor ( date . utc ( 2011 , 00 , 06 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcThursday . floor ( date . utc ( 2011 , 00 , 06 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcThursday . count ( start , end ) counts Thursdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 04 ) ) , 0 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 05 ) ) , 1 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 06 ) ) , 1 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 12 ) ) , 2 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2015 , 00 , 01 ) , date . utc ( 2015 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2015 , 00 , 01 ) , date . utc ( 2015 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . utcThursday . count ( date . utc ( 2015 , 00 , 01 ) , date . utc ( 2015 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2015 , 00 , 01 ) , date . utc ( 2015 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcThursday . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . utcThursday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcTuesdays in an alias for utcTuesday . range " , function ( test )  {%NWL%test . equal ( time . utcTuesdays , time . utcTuesday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcTuesday . floor ( date ) returns Tuesdays " , function ( test )  {%NWL%test . deepEqual ( time . utcTuesday . floor ( date . utc ( 2011 , 00 , 02 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . utcTuesday . floor ( date . utc ( 2011 , 00 , 03 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . utcTuesday . floor ( date . utc ( 2011 , 00 , 03 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . utcTuesday . floor ( date . utc ( 2011 , 00 , 03 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 28 ) ) ;%NWL%test . deepEqual ( time . utcTuesday . floor ( date . utc ( 2011 , 00 , 04 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 04 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcTuesday . floor ( date . utc ( 2011 , 00 , 04 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 04 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcTuesday . count ( start , end ) counts Tuesdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 06 ) ) , 0 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 07 ) ) , 1 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 14 ) ) , 2 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2013 , 00 , 01 ) , date . utc ( 2013 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2013 , 00 , 01 ) , date . utc ( 2013 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . utcTuesday . count ( date . utc ( 2013 , 00 , 01 ) , date . utc ( 2013 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2013 , 00 , 01 ) , date . utc ( 2013 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcTuesday . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . utcTuesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcWednesdays in an alias for utcWednesday . range " , function ( test )  {%NWL%test . equal ( time . utcWednesdays , time . utcWednesday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWednesday . floor ( date ) returns Wednesdays " , function ( test )  {%NWL%test . deepEqual ( time . utcWednesday . floor ( date . utc ( 2011 , 00 , 03 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . utcWednesday . floor ( date . utc ( 2011 , 00 , 04 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . utcWednesday . floor ( date . utc ( 2011 , 00 , 04 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . utcWednesday . floor ( date . utc ( 2011 , 00 , 04 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . utcWednesday . floor ( date . utc ( 2011 , 00 , 05 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 05 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . utcWednesday . floor ( date . utc ( 2011 , 00 , 05 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 05 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWednesday . count ( start , end ) counts Wednesdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 03 ) ) , 0 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 04 ) ) , 1 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 05 ) ) , 1 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2012 , 00 , 01 ) , date . utc ( 2012 , 00 , 11 ) ) , 2 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . utcWednesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2014 , 00 , 01 ) , date . utc ( 2014 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWednesday . count ( start , end ) does not observe daylight saving " , function ( test )  {%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . utcWednesday . count ( date . utc ( 2011 , 00 , 01 ) , date . utc ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcWeek . floor ( date ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . floor ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcWeek . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . floor ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 2011 , 10 , 06 , 01 ) ) , date . utc ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " utcWeek . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . floor ( date . utc ( 0011 , 10 , 06 , 07 ) ) , date . utc ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . ceil ( date ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " utcWeek . ceil ( date ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . ceil ( date ) does not observe the start of daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . ceil ( date ) does not observe the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 20 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . ceil ( date ) does not observe the end of the daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 02 , 13 , 01 ) ) , date . utc ( 2011 , 02 , 20 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . ceil ( date ) does not observe the end of the daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . ceil ( date . utc ( 2011 , 10 , 06 , 01 ) ) , date . utc ( 2011 , 10 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcWeek . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcWeek . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2010 , 11 , 17 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 01 ) ,  - 1 ) , date . utc ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 18 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 01 ) ,  - 1 ) , date . utc ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2010 , 11 , 18 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 1 ) , date . utc ( 2010 , 11 , 25 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 10 , 24 ) ,  + 1 ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 18 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 10 , 24 ) ,  + 1 ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 18 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 25 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " utcWeek . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcWeek . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2010 , 11 , 21 ) , date . utc ( 2011 , 0 , 12 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 26 ) ,%NWL%date . utc ( 2011 , 0 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 9 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2010 , 11 , 21 ) , date . utc ( 2011 , 0 , 12 ) ) ,  [%NWL%date . utc ( 2010 , 11 , 26 ) ,%NWL%date . utc ( 2011 , 0 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 9 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2011 , 0 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 9 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2010 , 11 , 21 ) , date . utc ( 2011 , 0 , 12 ) ) [ 0 ] , date . utc ( 2010 , 11 , 26 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " utcWeek . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2010 , 11 , 21 ) , date . utc ( 2011 , 0 , 12 ) ) [ 2 ] , date . utc ( 2011 , 0 , 9 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) can skip weeks " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2011 , 0 , 1 ) , date . utc ( 2011 , 3 , 1 ) , 4 ) ,  [%NWL%date . utc ( 2011 , 0 , 2 ) ,%NWL%date . utc ( 2011 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 1 , 27 ) ,%NWL%date . utc ( 2011 , 2 , 27 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2011 , 0 , 30 ) ,%NWL%date . utc ( 2011 , 1 , 27 ) ,%NWL%date . utc ( 2011 , 2 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) does not observe start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2011 , 2 , 1 ) , date . utc ( 2011 , 2 , 28 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 6 ) ,%NWL%date . utc ( 2011 , 2 , 13 ) ,%NWL%date . utc ( 2011 , 2 , 27 )%NWL%2
date . utc ( 2011 , 2 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) does not observe start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2011 , 2 , 1 ) , date . utc ( 2011 , 2 , 28 ) ) ,  [%NWL%date . utc ( 2011 , 2 , 6 ) ,%NWL%date . utc ( 2011 , 2 , 13 ) ,%NWL%date . utc ( 2011 , 2 , 20 ) ,%NWL%date . utc ( 2011 , 2 , 27 )%NWL%test . end ( ) ;%NWL%2
date . utc ( 2011 , 2 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . range ( start , stop ) does not observe end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2011 , 10 , 1 ) , date . utc ( 2011 , 10 , 30 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 ) ,%NWL%date . utc ( 2011 , 10 , 13 ) ,%NWL%date . utc ( 2011 , 10 , 20 ) ,%NWL%date . utc ( 2011 , 10 , 27 )%NWL%test . end ( ) ;%NWL%2
tape ( " utcWeek . range ( start , stop ) does not observe end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . utcWeek . range ( date . utc ( 2011 , 10 , 1 ) , date . utc ( 2011 , 10 , 30 ) ) ,  [%NWL%date . utc ( 2011 , 10 , 6 ) ,%NWL%date . utc ( 2011 , 10 , 13 ) ,%NWL%date . utc ( 2011 , 10 , 20 ) ,%NWL%date . utc ( 2011 , 10 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek is an alias for utcSunday " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2011 , 10 , 20 ) ,%NWL%date . utc ( 2011 , 10 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek is an alias for utcSunday " , function ( test )  {%NWL%test . equal ( time . utcWeek , time . utcSunday ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcWeek . every ( step ) returns every stepth Sunday , starting with the first Sunday of the month " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
date = require ( " . / date " ) ;%NWL%tape ( " utcYear . floor ( date ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . floor ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2010 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . floor ( date ) does not modify the specified date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ;%NWL%test . deepEqual ( time . utcYear . floor ( d ) , date . utc ( 2010 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( time . utcYear . floor ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . floor ( date ) does not modify the specified date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ;%NWL%test . deepEqual ( time . utcYear . floor ( d ) , date . utc ( 2010 , 00 , 01 ) ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . floor ( date . utc ( 0011 , 10 , 06 , 07 ) ) , date . utc ( 0011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . ceil ( date ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " utcYear . ceil ( date ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . ceil ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . ceil ( date . utc ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . utc ( 2012 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcYear . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . utcYear . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . utc ( 2011 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . utc ( 2008 , 11 , 31 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 01 ) ,  - 1 ) , date . utc ( 2009 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2009 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " utcYear . offset ( date , count ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 01 ) ,  - 1 ) , date . utc ( 2009 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 2 ) , date . utc ( 2009 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2011 , 00 , 01 ) ,  - 1 ) , date . utc ( 2010 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2009 , 11 , 01 ) ,  + 1 ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2009 , 00 , 01 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2009 , 11 , 01 ) ,  + 1 ) , date . utc ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2009 , 00 , 01 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 00 , 01 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . utcYear . offset ( date . utc ( 2009 , 00 , 01 ) ,  + 2 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 00 , 01 ) ,  + 1 ) , date . utc ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . offset ( date , count ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . utcYear . offset ( date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . utc ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . every ( step ) returns every stepth year , starting with year zero " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
} ) ;%NWL%tape ( " utcYear . every ( step ) returns every stepth year , starting with year zero " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . every ( 5 ) . range ( date . utc ( 2008 ) , date . utc ( 2023 ) ) ,  [ date . utc ( 2010 ) , date . utc ( 2015 ) , date . utc ( 2020 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . range ( start , stop ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . range ( date . utc ( 2010 , 0 , 1 ) , date . utc ( 2013 , 0 , 1 ) ) ,  [%NWL%date . utc ( 2010 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 ) ,%NWL%date . utc ( 2012 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " utcYear . range ( start , stop ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . range ( date . utc ( 2010 , 0 , 1 ) , date . utc ( 2013 , 0 , 1 ) ) ,  [%NWL%date . utc ( 2010 , 0 , 1 ) ,%NWL%date . utc ( 2011 , 0 , 1 ) ,%NWL%date . utc ( 2012 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . utc ( 2011 , 0 , 1 ) ,%NWL%date . utc ( 2012 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . range ( date . utc ( 2010 , 0 , 1 ) , date . utc ( 2013 , 0 , 1 ) ) [ 0 ] , date . utc ( 2010 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " utcYear . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . range ( date . utc ( 2010 , 0 , 1 ) , date . utc ( 2013 , 0 , 1 ) ) [ 2 ] , date . utc ( 2012 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcYear . range ( start , stop , step ) can skip years " , function ( test )  {%NWL%test . deepEqual ( time . utcYear . range ( date . utc ( 2009 , 0 , 1 ) , date . utc ( 2029 , 0 , 1 ) , 5 ) ,  [%NWL%date . utc ( 2009 , 0 , 1 ) ,%NWL%date . utc ( 2014 , 0 , 1 ) ,%NWL%date . utc ( 2019 , 0 , 1 ) ,%NWL%date . utc ( 2024 , 0 , 1 )%NWL%test . end ( ) ;%NWL%2
tape ( " timeWednesdays in an alias for timeWednesday . range " , function ( test )  {%NWL%test . equal ( time . timeWednesdays , time . timeWednesday . range ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWednesday . floor ( date ) returns Wednesdays " , function ( test )  {%NWL%test . deepEqual ( time . timeWednesday . floor ( date . local ( 2011 , 00 , 03 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . timeWednesday . floor ( date . local ( 2011 , 00 , 04 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . timeWednesday . floor ( date . local ( 2011 , 00 , 04 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . timeWednesday . floor ( date . local ( 2011 , 00 , 04 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 29 ) ) ;%NWL%test . deepEqual ( time . timeWednesday . floor ( date . local ( 2011 , 00 , 05 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 05 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( time . timeWednesday . floor ( date . local ( 2011 , 00 , 05 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 05 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWednesday . count ( start , end ) counts Wednesdays after start ( exclusive ) and before end ( inclusive ) " , function ( test )  {%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 03 ) ) , 0 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 04 ) ) , 1 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 05 ) ) , 1 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2012 , 00 , 01 ) , date . local ( 2012 , 00 , 11 ) ) , 2 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 07 ) ) , 0 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 08 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . equal ( time . timeWednesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 08 ) ) , 1 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2014 , 00 , 01 ) , date . local ( 2014 , 00 , 09 ) ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWednesday . count ( start , end ) observes daylight saving " , function ( test )  {%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 01 ) ) , 10 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 03 ) ) , 10 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 02 , 13 , 04 ) ) , 10 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 00 ) ) , 44 ) ;%NWL%test . equal ( time . timeWednesday . count ( date . local ( 2011 , 00 , 01 ) , date . local ( 2011 , 10 , 06 , 01 ) ) , 44 ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " timeWeek . floor ( date ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . floor ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeWeek . floor ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . floor ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 10 , 06 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " timeWeek . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . floor ( date . local ( 0011 , 10 , 06 , 07 ) ) , date . local ( 0011 , 10 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . ceil ( date ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . end ( ) ;%NWL%2
tape ( " timeWeek . ceil ( date ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . ceil ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 01 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 02 ) ) ;%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 00 , 02 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 09 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . ceil ( date ) observes the start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 20 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . ceil ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 02 , 13 , 01 ) ) , date . local ( 2011 , 02 , 20 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . ceil ( date ) observes the end of the daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . ceil ( date . local ( 2011 , 10 , 06 , 01 ) ) , date . local ( 2011 , 10 , 13 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeWeek . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeWeek . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 00 , 07 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2010 , 11 , 17 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 18 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2010 , 10 , 24 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2010 , 11 , 18 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2011 , 00 , 01 ) ,  - 1 ) , date . local ( 2010 , 11 , 25 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 10 , 24 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 18 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 10 , 24 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 18 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 25 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
tape ( " timeWeek . offset ( date , step ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeWeek . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2010 , 11 , 21 ) , date . local ( 2011 , 0 , 12 ) ) ,  [%NWL%date . local ( 2010 , 11 , 26 ) ,%NWL%date . local ( 2011 , 0 , 2 ) ,%NWL%date . local ( 2011 , 0 , 9 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) returns sundays " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2010 , 11 , 21 ) , date . local ( 2011 , 0 , 12 ) ) ,  [%NWL%date . local ( 2010 , 11 , 26 ) ,%NWL%date . local ( 2011 , 0 , 2 ) ,%NWL%date . local ( 2011 , 0 , 9 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2011 , 0 , 2 ) ,%NWL%date . local ( 2011 , 0 , 9 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2010 , 11 , 21 ) , date . local ( 2011 , 0 , 12 ) ) [ 0 ] , date . local ( 2010 , 11 , 26 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " timeWeek . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2010 , 11 , 21 ) , date . local ( 2011 , 0 , 12 ) ) [ 2 ] , date . local ( 2011 , 0 , 9 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) can skip weeks " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2011 , 0 , 1 ) , date . local ( 2011 , 3 , 1 ) , 4 ) ,  [%NWL%date . local ( 2011 , 0 , 2 ) ,%NWL%date . local ( 2011 , 0 , 30 ) ,%NWL%date . local ( 2011 , 1 , 27 ) ,%NWL%date . local ( 2011 , 2 , 27 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2011 , 0 , 30 ) ,%NWL%date . local ( 2011 , 1 , 27 ) ,%NWL%date . local ( 2011 , 2 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2011 , 2 , 1 ) , date . local ( 2011 , 2 , 28 ) ) ,  [%NWL%date . local ( 2011 , 2 , 6 ) ,%NWL%date . local ( 2011 , 2 , 13 ) ,%NWL%date . local ( 2011 , 2 , 27 )%NWL%2
date . local ( 2011 , 2 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) observes start of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2011 , 2 , 1 ) , date . local ( 2011 , 2 , 28 ) ) ,  [%NWL%date . local ( 2011 , 2 , 6 ) ,%NWL%date . local ( 2011 , 2 , 13 ) ,%NWL%date . local ( 2011 , 2 , 20 ) ,%NWL%date . local ( 2011 , 2 , 27 )%NWL%test . end ( ) ;%NWL%2
date . local ( 2011 , 2 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2011 , 10 , 1 ) , date . local ( 2011 , 10 , 30 ) ) ,  [%NWL%date . local ( 2011 , 10 , 6 ) ,%NWL%date . local ( 2011 , 10 , 13 ) ,%NWL%date . local ( 2011 , 10 , 20 ) ,%NWL%date . local ( 2011 , 10 , 27 )%NWL%test . end ( ) ;%NWL%2
tape ( " timeWeek . range ( start , stop ) observes end of daylight savings time " , function ( test )  {%NWL%test . deepEqual ( time . timeWeek . range ( date . local ( 2011 , 10 , 1 ) , date . local ( 2011 , 10 , 30 ) ) ,  [%NWL%date . local ( 2011 , 10 , 6 ) ,%NWL%date . local ( 2011 , 10 , 13 ) ,%NWL%date . local ( 2011 , 10 , 20 ) ,%NWL%date . local ( 2011 , 10 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek is an alias for timeSunday " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2011 , 10 , 20 ) ,%NWL%date . local ( 2011 , 10 , 27 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek is an alias for timeSunday " , function ( test )  {%NWL%test . equal ( time . timeWeek , time . timeSunday ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeWeek . every ( step ) returns every stepth Sunday , starting with the first Sunday of the month " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
this . svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' x axis ' )%NWL%. attr ( ' transform ' ,  ' translate ( 0 , '  + this . height +  ' ) ' )%NWL%. call ( xAxis ) ;%NWL%var yAxis = d3 . svg . axis ( )%NWL%. scale ( this . scales . y )%NWL%. orient ( ' left ' )%NWL%. ticks ( Math . ceil ( this . height / 40 ) )%NWL%. tickSize ( - this . width )%NWL%. tickFormat ( this . options . yFormat )%NWL%this . svg . append ( ' g ' )%NWL%0
date = require ( " . / date " ) ;%NWL%tape ( " timeYear . floor ( date ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . floor ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2010 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . floor ( date ) does not modify the specified date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ;%NWL%test . deepEqual ( time . timeYear . floor ( d ) , date . local ( 2010 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . deepEqual ( time . timeYear . floor ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . floor ( date ) does not modify the specified date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ;%NWL%test . deepEqual ( time . timeYear . floor ( d ) , date . local ( 2010 , 00 , 01 ) ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . floor ( date ) correctly handles years in the first century " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . floor ( date . local ( 0011 , 10 , 06 , 07 ) ) , date . local ( 0011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . ceil ( date ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%1
} ) ;%NWL%tape ( " timeYear . ceil ( date ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . ceil ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 00 ) ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . ceil ( date . local ( 2011 , 00 , 01 , 00 , 00 , 01 ) ) , date . local ( 2012 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeYear . offset ( d ,  + 1 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) does not modify the passed - in date " , function ( test )  {%NWL%var d = date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ;%NWL%time . timeYear . offset ( d ,  + 1 ) ;%NWL%test . deepEqual ( d , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) does not round the passed - in - date " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ,  + 1 ) , date . local ( 2011 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 456 ) ,  - 2 ) , date . local ( 2008 , 11 , 31 , 23 , 59 , 59 , 456 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2009 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2009 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeYear . offset ( date , count ) allows negative offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 01 ) ,  - 1 ) , date . local ( 2009 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2011 , 00 , 01 ) ,  - 2 ) , date . local ( 2009 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2011 , 00 , 01 ) ,  - 1 ) , date . local ( 2010 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2009 , 11 , 01 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2009 , 00 , 01 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) allows positive offsets " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2009 , 11 , 01 ) ,  + 1 ) , date . local ( 2010 , 11 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2009 , 00 , 01 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 00 , 01 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( time . timeYear . offset ( date . local ( 2009 , 00 , 01 ) ,  + 2 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 00 , 01 ) ,  + 1 ) , date . local ( 2011 , 00 , 01 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . offset ( date , count ) allows zero offset " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 59 , 999 ) ) ;%NWL%test . deepEqual ( time . timeYear . offset ( date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) , 0 ) , date . local ( 2010 , 11 , 31 , 23 , 59 , 58 , 000 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . every ( step ) returns every stepth year , starting with year zero " , function ( test )  {%NWL%test . end ( ) ;%NWL%2
} ) ;%NWL%tape ( " timeYear . every ( step ) returns every stepth year , starting with year zero " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . every ( 5 ) . range ( date . local ( 2008 ) , date . local ( 2023 ) ) ,  [ date . local ( 2010 ) , date . local ( 2015 ) , date . local ( 2020 ) ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . range ( start , stop ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . range ( date . local ( 2010 , 0 , 1 ) , date . local ( 2013 , 0 , 1 ) ) ,  [%NWL%date . local ( 2010 , 0 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 ) ,%NWL%date . local ( 2012 , 0 , 1 )%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " timeYear . range ( start , stop ) returns years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . range ( date . local ( 2010 , 0 , 1 ) , date . local ( 2013 , 0 , 1 ) ) ,  [%NWL%date . local ( 2010 , 0 , 1 ) ,%NWL%date . local ( 2011 , 0 , 1 ) ,%NWL%date . local ( 2012 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%7
date . local ( 2011 , 0 , 1 ) ,%NWL%date . local ( 2012 , 0 , 1 )%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . range ( start , stop ) has an inclusive lower bound " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . range ( date . local ( 2010 , 0 , 1 ) , date . local ( 2013 , 0 , 1 ) ) [ 0 ] , date . local ( 2010 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
tape ( " timeYear . range ( start , stop ) has an exclusive upper bound " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . range ( date . local ( 2010 , 0 , 1 ) , date . local ( 2013 , 0 , 1 ) ) [ 2 ] , date . local ( 2012 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeYear . range ( start , stop , step ) can skip years " , function ( test )  {%NWL%test . deepEqual ( time . timeYear . range ( date . local ( 2009 , 0 , 1 ) , date . local ( 2029 , 0 , 1 ) , 5 ) ,  [%NWL%date . local ( 2009 , 0 , 1 ) ,%NWL%date . local ( 2014 , 0 , 1 ) ,%NWL%date . local ( 2019 , 0 , 1 ) ,%NWL%date . local ( 2024 , 0 , 1 )%NWL%test . end ( ) ;%NWL%2
function localDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%var date = new Date ( - 1 , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%date . setFullYear ( d . y ) ;%NWL%return date;%NWL%}%NWL%return new Date ( d . y , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%}%NWL%function utcDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%date . setUTCFullYear ( d . y ) ;%NWL%3
if ( ! ( date instanceof Date ) ) date = new Date ( + date ) ;%NWL%while ( + + i < n )  {%NWL%if ( specifier . charCodeAt ( i ) === 37 )  {%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%if ( ( pad = pads [ c = specifier . charAt ( + + i ) ] ) != null ) c = specifier . charAt ( + + i ) ;%NWL%else pad = c === " e " ? "  " : " 0 " ;%NWL%if ( format = formats [ c ] ) c = format ( date , pad ) ;%NWL%string . push ( c ) ;%NWL%j = i + 1;%NWL%}%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%3
var d = newYear ( 1900 ) ,%NWL%i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%d . H + = d . Z / 100 | 0;%NWL%8
i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%if ( " Z " in d )  {%NWL%d . M + = d . Z % 100;%NWL%7
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ,%NWL%enUs = require ( " . . / locale / en - US " ) ,%NWL%frFr = require ( " . . / locale / fr - FR " ) ;%NWL%tape ( " d3 . timeFormat ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . equal ( d3 . timeFormat ( " %c " ) ( new Date ( 2000 , 0 , 1 ) ) ,  " 1 / 1 / 2000 , 12:00:00 AM " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . timeParse ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . end ( ) ;%NWL%6
frFr = require ( " . . / locale / fr - FR " ) ;%NWL%tape ( " d3 . timeFormat ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . equal ( d3 . timeFormat ( " %c " ) ( new Date ( 2000 , 0 , 1 ) ) ,  " 1 / 1 / 2000 , 12:00:00 AM " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . timeParse ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . equal ( + d3 . timeParse ( " %c " ) ( " 1 / 1 / 2000 , 12:00:00 AM " ) ,  + new Date ( 2000 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . utcFormat ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " d3 . timeParse ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . equal ( + d3 . timeParse ( " %c " ) ( " 1 / 1 / 2000 , 12:00:00 AM " ) ,  + new Date ( 2000 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . utcFormat ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . equal ( d3 . utcFormat ( " %c " ) ( new Date ( Date . UTC ( 2000 , 0 , 1 ) ) ) ,  " 1 / 1 / 2000 , 12:00:00 AM " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . utcParse ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
test . equal ( d3 . utcFormat ( " %c " ) ( new Date ( Date . UTC ( 2000 , 0 , 1 ) ) ) ,  " 1 / 1 / 2000 , 12:00:00 AM " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . utcParse ( specifier ) defaults to en - US " , function ( test )  {%NWL%test . equal ( + d3 . utcParse ( " %c " ) ( " 1 / 1 / 2000 , 12:00:00 AM " ) ,  + new Date ( Date . UTC ( 2000 , 0 , 1 ) ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) returns the new default locale " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . end ( ) ;%NWL%1
test . equal ( locale . format ( " %c " ) ( new Date ( 2000 , 0 , 1 ) ) ,  " samedi , le 1 janvier 2000 , 00:00:00 " ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . timeFormat " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . timeFormat , locale . format ) ;%NWL%test . end ( ) ;%NWL%1
} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . timeFormat " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . timeFormat , locale . format ) ;%NWL%test . equal ( d3 . timeFormat ( " %c " ) ( new Date ( 2000 , 0 , 1 ) ) ,  " samedi , le 1 janvier 2000 , 00:00:00 " ) ;%NWL%test . end ( ) ;%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%1
test . equal ( d3 . timeFormat ( " %c " ) ( new Date ( 2000 , 0 , 1 ) ) ,  " samedi , le 1 janvier 2000 , 00:00:00 " ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . timeParse " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . timeParse , locale . parse ) ;%NWL%test . end ( ) ;%NWL%1
} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . timeParse " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . timeParse , locale . parse ) ;%NWL%test . equal ( + d3 . timeParse ( " %c " ) ( " samedi , le 1 janvier 2000 , 00:00:00 " ) ,  + new Date ( 2000 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%1
test . equal ( + d3 . timeParse ( " %c " ) ( " samedi , le 1 janvier 2000 , 00:00:00 " ) ,  + new Date ( 2000 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . utcFormat " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . utcFormat , locale . utcFormat ) ;%NWL%test . end ( ) ;%NWL%1
} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . utcFormat " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . utcFormat , locale . utcFormat ) ;%NWL%test . equal ( d3 . utcFormat ( " %c " ) ( new Date ( Date . UTC ( 2000 , 0 , 1 ) ) ) ,  " samedi , le 1 janvier 2000 , 00:00:00 " ) ;%NWL%test . end ( ) ;%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%1
test . equal ( d3 . utcFormat ( " %c " ) ( new Date ( Date . UTC ( 2000 , 0 , 1 ) ) ) ,  " samedi , le 1 janvier 2000 , 00:00:00 " ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . utcParse " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . utcParse , locale . utcParse ) ;%NWL%test . end ( ) ;%NWL%1
} finally {%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . timeFormatDefaultLocale ( definition ) affects d3 . utcParse " , function ( test )  {%NWL%var locale = d3 . timeFormatDefaultLocale ( frFr ) ;%NWL%try {%NWL%test . equal ( d3 . utcParse , locale . utcParse ) ;%NWL%test . equal ( + d3 . utcParse ( " %c " ) ( " samedi , le 1 janvier 2000 , 00:00:00 " ) ,  + new Date ( Date . UTC ( 2000 , 0 , 1 ) ) ) ;%NWL%test . end ( ) ;%NWL%d3 . timeFormatDefaultLocale ( enUs ) ;%NWL%1
D3 . chartDefaults       / / Library level defaults%NWL%) ;%NWL%Backbone . View . prototype . initialize . apply ( this , arguments ) ;%NWL%} ,%NWL%render: function ( )  {%NWL%this . $el . empty ( ) ;%NWL%var margin = this . options . margin ,%NWL%width = this . options . width || this . $el . width ( ) ,%NWL%height = this . options . height || this . $el . height ( ) ;%NWL%this . width = width - margin . left - margin . right;%NWL%this . svg = d3 . select ( this . el ) . append ( ' svg ' )%NWL%9
test . deepEqual ( p ( { toString: function ( )  { return " 1 / 4 / 1990 , 12:00:00 AM " ; } } ) , date . local ( 1990 , 0 , 4 ) ) ;%NWL%test . deepEqual ( p ( { toString: function ( )  { return " 1 / 5 / 1990 , 12:00:00 AM " ; } } ) , date . local ( 1990 , 0 , 5 ) ) ;%NWL%test . deepEqual ( p ( { toString: function ( )  { return " 1 / 6 / 1990 , 12:00:00 AM " ; } } ) , date . local ( 1990 , 0 , 6 ) ) ;%NWL%test . deepEqual ( p ( { toString: function ( )  { return " 1 / 7 / 1990 , 12:00:00 AM " ; } } ) , date . local ( 1990 , 0 , 7 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %a %m / %d / %Y\ " ) ( date ) parses abbreviated weekday and date " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %a %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " Sun 01 / 01 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Wed 02 / 03 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . timeParse ( " %a %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " Sun 01 / 01 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Wed 02 / 03 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . equal ( p ( " XXX 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %A %m / %d / %Y\ " ) ( date ) parses weekday and date " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %A %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " Sunday 01 / 01 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Wednesday 02 / 03 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . timeParse ( " %A %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " Sunday 01 / 01 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Wednesday 02 / 03 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . equal ( p ( " Caturday 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %U %Y\ " ) ( date ) parses week number ( Sunday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %U %Y " ) ;%NWL%test . deepEqual ( p ( " 00 1990 " ) , date . local ( 1989 , 11 , 31 ) ) ;%NWL%test . deepEqual ( p ( " 05 1991 " ) , date . local ( 1991 ,  1 ,  3 ) ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( p ( " 00 1990 " ) , date . local ( 1989 , 11 , 31 ) ) ;%NWL%test . deepEqual ( p ( " 05 1991 " ) , date . local ( 1991 ,  1 ,  3 ) ) ;%NWL%test . deepEqual ( p ( " 01 1995 " ) , date . local ( 1995 ,  0 ,  1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %a %U %Y\ " ) ( date ) parses abbreviated weekday , week number ( Sunday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %a %U %Y " ) ;%NWL%test . deepEqual ( p ( " Mon 00 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Sun 05 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sun 01 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( p ( " Sun 05 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sun 01 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . equal ( p ( " XXX 03 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %A %U %Y\ " ) ( date ) parses weekday , week number ( Sunday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %A %U %Y " ) ;%NWL%test . deepEqual ( p ( " Monday 00 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Sunday 05 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sunday 01 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( p ( " Sunday 05 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sunday 01 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . equal ( p ( " Caturday 03 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %w %U %Y\ " ) ( date ) parses numeric weekday , week number ( Sunday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %w %U %Y " ) ;%NWL%test . deepEqual ( p ( " 1 00 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 0 05 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 0 01 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( p ( " 1 00 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 0 05 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 0 01 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . equal ( p ( " X 03 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %W %Y\ " ) ( date ) parses week number ( Monday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %W %Y " ) ;%NWL%test . deepEqual ( p ( " 01 1990 " ) , date . local ( 1990 ,  0 ,  1 ) ) ;%NWL%test . deepEqual ( p ( " 04 1991 " ) , date . local ( 1991 ,  0 , 28 ) ) ;%NWL%test . end ( ) ;%NWL%4
test . deepEqual ( p ( " 01 1990 " ) , date . local ( 1990 ,  0 ,  1 ) ) ;%NWL%test . deepEqual ( p ( " 04 1991 " ) , date . local ( 1991 ,  0 , 28 ) ) ;%NWL%test . deepEqual ( p ( " 00 1995 " ) , date . local ( 1994 , 11 , 26 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %a %W %Y\ " ) ( date ) parses abbreviated weekday , week number ( Monday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %a %W %Y " ) ;%NWL%test . deepEqual ( p ( " Mon 01 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Sun 04 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sun 00 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( p ( " Sun 04 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sun 00 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . equal ( p ( " XXX 03 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %A %W %Y\ " ) ( date ) parses weekday , week number ( Monday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %A %W %Y " ) ;%NWL%test . deepEqual ( p ( " Monday 01 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Sunday 04 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sunday 00 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( p ( " Sunday 04 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " Sunday 00 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . equal ( p ( " Caturday 03 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %w %W %Y\ " ) ( date ) parses numeric weekday , week number ( Monday ) and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %w %W %Y " ) ;%NWL%test . deepEqual ( p ( " 1 01 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 0 04 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 0 00 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( p ( " 0 00 1995 " ) , date . local ( 1995 , 0 , 1 ) ) ;%NWL%test . equal ( p ( " X 03 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %y\ " ) ( date ) parses month , date and two - digit year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %y " ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 69 " ) , date . local ( 1969 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 01 / 90 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 91 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 68 " ) , date . local ( 2068 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( p ( " 01 / 01 / 90 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 91 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 68 " ) , date . local ( 2068 , 1 , 3 ) ) ;%NWL%test . equal ( p ( " 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %x\ " ) ( date ) parses locale date " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %x " ) ;%NWL%test . deepEqual ( p ( " 1 / 1 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 2 / 3 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . timeParse ( " %x " ) ;%NWL%test . deepEqual ( p ( " 1 / 1 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 2 / 3 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 3 / 10 / 2010 " ) , date . local ( 2010 , 2 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %b %d , %Y\ " ) ( date ) parses abbreviated month , date and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %b %d , %Y " ) ;%NWL%test . deepEqual ( p ( " jan 01 , 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " feb 2 , 2010 " ) , date . local ( 2010 , 1 , 2 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . timeParse ( " %b %d , %Y " ) ;%NWL%test . deepEqual ( p ( " jan 01 , 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " feb 2 , 2010 " ) , date . local ( 2010 , 1 , 2 ) ) ;%NWL%test . equal ( p ( " jan . 1 , 1990 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %B %d , %Y\ " ) ( date ) parses month , date and year " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %B %d , %Y " ) ;%NWL%test . deepEqual ( p ( " january 01 , 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " February 2 , 2010 " ) , date . local ( 2010 , 1 , 2 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . timeParse ( " %B %d , %Y " ) ;%NWL%test . deepEqual ( p ( " january 01 , 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " February 2 , 2010 " ) , date . local ( 2010 , 1 , 2 ) ) ;%NWL%test . equal ( p ( " jan 1 , 1990 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %j %m / %d / %Y\ " ) ( date ) parses day of year and date " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %j %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " 001 01 / 01 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 034 02 / 03 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " timeParse ( \ " %j %m / %d / %Y\ " ) ( date ) parses day of year and date " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %j %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " 001 01 / 01 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 034 02 / 03 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . equal ( p ( " 2012 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %c\ " ) ( date ) parses locale date and time " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %c " ) ;%NWL%test . end ( ) ;%NWL%6
var p = timeFormat . timeParse ( " %c " ) ;%NWL%test . deepEqual ( p ( " 1 / 1 / 1990 , 12:00:00 AM " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %H:%M:%S\ " ) ( date ) parses twenty - four hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %H:%M:%S " ) ;%NWL%test . deepEqual ( p ( " 00:00:00 " ) , date . local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( p ( " 12:00:01 " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 23:59:59 " ) , date . local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %X\ " ) ( date ) parses locale time " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %X " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 AM " ) , date . local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 PM " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 PM " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%2
var p = timeFormat . timeParse ( " %X " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 AM " ) , date . local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 PM " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 PM " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %I:%M:%S %p\ " ) ( date ) parses twelve hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %I:%M:%S %p " ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%2
test . deepEqual ( p ( " 12:00:00 PM " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 PM " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %I:%M:%S %p\ " ) ( date ) parses twelve hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %I:%M:%S %p " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 am " ) , date . local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 pm " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%2
test . deepEqual ( p ( " 12:00:01 PM " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %I:%M:%S %p\ " ) ( date ) parses twelve hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %I:%M:%S %p " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 am " ) , date . local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 pm " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 pm " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( p ( " 12:00:01 pm " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %I %p\ " ) ( date ) parses period in non - English locales " , function ( test )  {%NWL%var p = timeFormat . timeFormatLocale ( FiFi ) . parse ( " %I:%M:%S %p " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 a . m . " ) , date . local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 A . M . " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 p . m . " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 p . m . " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( p ( " 11:59:59 A . M . " ) , date . local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 p . m . " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 p . m . " ) , date . local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 P . M . " ) , date . local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %% %m / %d / %Y\ " ) ( date ) parses literal % " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %% %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " % 01 / 01 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " % 02 / 03 / 1991 " ) , date . local ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
test . equal ( p ( " %% 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %Y %Z\ " ) ( date ) parses timezone offset " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0000 " ) , date . local ( 1990 , 0 , 1 , 16 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0100 " ) , date . local ( 1990 , 0 , 1 , 15 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0130 " ) , date . local ( 1990 , 0 , 1 , 14 , 30 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0100 " ) , date . local ( 1990 , 0 , 1 , 17 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0130 " ) , date . local ( 1990 , 0 , 1 , 17 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( p ( " 01 / 02 / 1990 + 0100 " ) , date . local ( 1990 , 0 , 1 , 15 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0130 " ) , date . local ( 1990 , 0 , 1 , 14 , 30 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0100 " ) , date . local ( 1990 , 0 , 1 , 17 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0130 " ) , date . local ( 1990 , 0 , 1 , 17 , 30 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0800 " ) , date . local ( 1990 , 0 , 2 , 0 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %Y %Z\ " ) ( date ) parses timezone offset in the form ' + - hh:mm ' " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01:30 " ) , date . local ( 1990 , 0 , 1 , 14 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %Y %Z\ " ) ( date ) parses timezone offset in the form ' + - hh:mm ' " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01:30 " ) , date . local ( 1990 , 0 , 1 , 14 , 30 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 01:30 " ) , date . local ( 1990 , 0 , 1 , 17 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %Y %Z\ " ) ( date ) parses timezone offset in the form ' + - hh ' " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01 " ) , date . local ( 1990 , 0 , 1 , 15 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %Y %Z\ " ) ( date ) parses timezone offset in the form ' + - hh ' " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01 " ) , date . local ( 1990 , 0 , 1 , 15 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 01 " ) , date . local ( 1990 , 0 , 1 , 17 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %Y %Z\ " ) ( date ) parses timezone offset in the form ' Z ' " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %Y %Z " ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( p ( " 01 / 02 / 1990 - 01 " ) , date . local ( 1990 , 0 , 1 , 17 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %m / %d / %Y %Z\ " ) ( date ) parses timezone offset in the form ' Z ' " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 Z " ) , date . local ( 1990 , 0 , 1 , 16 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " % - m / %0d / %_Y\ " ) ( date ) ignores optional padding modifier , skipping zeroes and spaces " , function ( test )  {%NWL%var p = timeFormat . timeParse ( " % - m / %0d / %_Y " ) ;%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( p ( " 01 / 1 / 1990 " ) , date . local ( 1990 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " timeParse ( \ " %b %d , %Y\ " ) ( date ) doesn ' t crash when given weird strings " , function ( test )  {%NWL%try {%NWL%Object . prototype . foo = 10;%NWL%var p = timeFormat . timeParse ( " %b %d , %Y " ) ;%NWL%test . equal ( p ( " foo 1 , 1990 " ) , null ) ;%NWL%} finally {%NWL%delete Object . prototype . foo;%NWL%test . end ( ) ;%NWL%1
var p = timeFormat . utcParse ( " %a %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " Sun 01 / 01 / 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Wed 02 / 03 / 1991 " ) , date . utc ( 1991 , 1 , 3 ) ) ;%NWL%test . equal ( p ( " XXX 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses weekday and numeric date " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %A %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " Sunday 01 / 01 / 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Wednesday 02 / 03 / 1991 " ) , date . utc ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . utcParse ( " %A %m / %d / %Y " ) ;%NWL%test . deepEqual ( p ( " Sunday 01 / 01 / 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " Wednesday 02 / 03 / 1991 " ) , date . utc ( 1991 , 1 , 3 ) ) ;%NWL%test . equal ( p ( " Caturday 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses numeric date " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %m / %d / %y " ) ;%NWL%test . deepEqual ( p ( " 01 / 01 / 90 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 91 " ) , date . utc ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . utcParse ( " %m / %d / %y " ) ;%NWL%test . deepEqual ( p ( " 01 / 01 / 90 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 91 " ) , date . utc ( 1991 , 1 , 3 ) ) ;%NWL%test . equal ( p ( " 03 / 10 / 2010 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses locale date " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %x " ) ;%NWL%test . deepEqual ( p ( " 01 / 01 / 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 1991 " ) , date . utc ( 1991 , 1 , 3 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . utcParse ( " %x " ) ;%NWL%test . deepEqual ( p ( " 01 / 01 / 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 02 / 03 / 1991 " ) , date . utc ( 1991 , 1 , 3 ) ) ;%NWL%test . deepEqual ( p ( " 03 / 10 / 2010 " ) , date . utc ( 2010 , 2 , 10 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses abbreviated month , date and year " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %b %d , %Y " ) ;%NWL%test . deepEqual ( p ( " jan 01 , 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " feb 2 , 2010 " ) , date . utc ( 2010 , 1 , 2 ) ) ;%NWL%test . end ( ) ;%NWL%4
var p = timeFormat . utcParse ( " %b %d , %Y " ) ;%NWL%test . deepEqual ( p ( " jan 01 , 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " feb 2 , 2010 " ) , date . utc ( 2010 , 1 , 2 ) ) ;%NWL%test . equal ( p ( " jan . 1 , 1990 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses month , date and year " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %B %d , %Y " ) ;%NWL%test . deepEqual ( p ( " january 01 , 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " February 2 , 2010 " ) , date . utc ( 2010 , 1 , 2 ) ) ;%NWL%test . end ( ) ;%NWL%4
} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses month , date and year " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %B %d , %Y " ) ;%NWL%test . deepEqual ( p ( " january 01 , 1990 " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " February 2 , 2010 " ) , date . utc ( 2010 , 1 , 2 ) ) ;%NWL%test . equal ( p ( " jan 1 , 1990 " ) , null ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses locale date and time " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %c " ) ;%NWL%test . end ( ) ;%NWL%6
var p = timeFormat . utcParse ( " %c " ) ;%NWL%test . deepEqual ( p ( " 1 / 1 / 1990 , 12:00:00 AM " ) , date . utc ( 1990 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses twenty - four hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %H:%M:%S " ) ;%NWL%test . deepEqual ( p ( " 00:00:00 " ) , date . utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 " ) , date . utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( p ( " 12:00:01 " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 23:59:59 " ) , date . utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses locale time " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %X " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 AM " ) , date . utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 PM " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 PM " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%2
var p = timeFormat . utcParse ( " %X " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 AM " ) , date . utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 PM " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 PM " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses twelve hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %I:%M:%S %p " ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%2
test . deepEqual ( p ( " 12:00:00 PM " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 PM " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses twelve hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %I:%M:%S %p " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 am " ) , date . utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 pm " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%2
test . deepEqual ( p ( " 12:00:01 PM " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses twelve hour , minute and second " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %I:%M:%S %p " ) ;%NWL%test . deepEqual ( p ( " 12:00:00 am " ) , date . utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 AM " ) , date . utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:00 pm " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 pm " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%2
test . deepEqual ( p ( " 12:00:00 pm " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%test . deepEqual ( p ( " 12:00:01 pm " ) , date . utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 11:59:59 PM " ) , date . utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses timezone offset " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0000 " ) , date . utc ( 1990 , 0 , 2 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0100 " ) , date . utc ( 1990 , 0 , 1 , 23 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0100 " ) , date . utc ( 1990 , 0 , 2 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%3
var p = timeFormat . utcParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0000 " ) , date . utc ( 1990 , 0 , 2 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 0100 " ) , date . utc ( 1990 , 0 , 1 , 23 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0100 " ) , date . utc ( 1990 , 0 , 2 , 1 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 0800 " ) , date . local ( 1990 , 0 , 2 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses timezone offset ( in the form ' + - hh:mm ' ) " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01:30 " ) , date . utc ( 1990 , 0 , 1 , 22 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses timezone offset ( in the form ' + - hh:mm ' ) " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01:30 " ) , date . utc ( 1990 , 0 , 1 , 22 , 30 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 01:30 " ) , date . utc ( 1990 , 0 , 2 , 1 , 30 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses timezone offset ( in the form ' + - hh ' ) " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01 " ) , date . utc ( 1990 , 0 , 1 , 23 ) ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses timezone offset ( in the form ' + - hh ' ) " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %m / %d / %Y %Z " ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 + 01 " ) , date . utc ( 1990 , 0 , 1 , 23 ) ) ;%NWL%test . deepEqual ( p ( " 01 / 02 / 1990 - 01 " ) , date . utc ( 1990 , 0 , 2 , 1 ) ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " utcParse ( \ " \ " ) ( date ) parses timezone offset ( in the form ' Z ' ) " , function ( test )  {%NWL%var p = timeFormat . utcParse ( " %m / %d / %Y %Z " ) ;%NWL%test . end ( ) ;%NWL%0
var tape = require ( " tape " ) ,%NWL%timer = require ( " . . / " ) ,%NWL%end = require ( " . / end " ) ;%NWL%require ( " . / inRange " ) ;%NWL%var now = timer . now ( ) ;%NWL%0
} ) ;%NWL%tape ( " timeout ( callback , delay ) invokes the callback once after the specified delay " , function ( test )  {%NWL%var then = timer . now ( ) , delay = 50;%NWL%timer . timeout ( function ( elapsed )  {%NWL%test . inRange ( timer . now ( )  - then , delay - 10 , delay + 10 ) ;%NWL%end ( test ) ;%NWL%} , delay ) ;%NWL%} ) ;%NWL%tape ( " timeout ( callback , delay , time ) invokes the callback once after the specified delay relative to the given time " , function ( test )  {%NWL%var then = timer . now ( )  + 50 , delay = 50;%NWL%test . inRange ( timer . now ( )  - then , delay - 10 , delay + 10 ) ;%NWL%4
tape ( " timerFlush ( ) immediately invokes any eligible timers " , function ( test )  {%NWL%var count = 0;%NWL%var t = timer . timer ( function ( )  {  + + count; t . stop ( ) ; } ) ;%NWL%timer . timerFlush ( ) ;%NWL%timer . timerFlush ( ) ;%NWL%test . equal ( count , 1 ) ;%NWL%end ( test ) ;%NWL%} ) ;%NWL%tape ( " timerFlush ( ) within timerFlush ( ) still executes all eligible timers " , function ( test )  {%NWL%var count = 0;%NWL%timer . timerFlush ( ) ;%NWL%3
var count = 0;%NWL%var t = timer . timer ( function ( )  { if ( + + count >= 3 ) t . stop ( ) ; timer . timerFlush ( ) ; } ) ;%NWL%timer . timerFlush ( ) ;%NWL%test . equal ( count , 3 ) ;%NWL%end ( test ) ;%NWL%} ) ;%NWL%tape ( " timerFlush ( ) observes the current time " , function ( test )  {%NWL%var start = timer . now ( ) , foos = 0 , bars = 0 , bazs = 0;%NWL%var foo = timer . timer ( function ( )  {  + + foos; foo . stop ( ) ; } , 0 , start + 1 ) ;%NWL%var bar = timer . timer ( function ( )  {  + + bars; bar . stop ( ) ; } , 0 , start ) ;%NWL%timer . timerFlush ( ) ;%NWL%2
this . svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' x axis ' )%NWL%. attr ( ' transform ' ,  ' translate ( 0 , '  + this . height +  ' ) ' )%NWL%. call ( xAxis ) ;%NWL%var yAxis = d3 . svg . axis ( )%NWL%. scale ( this . scales . y )%NWL%. orient ( ' left ' )%NWL%. ticks ( Math . ceil ( this . height / 40 ) )%NWL%. tickFormat ( this . options . yFormat )%NWL%. tickSize ( - this . width )%NWL%this . svg . append ( ' g ' )%NWL%0
. tickFormat ( this . options . yFormat )%NWL%. tickSize ( - this . width )%NWL%. tickPadding ( 10 ) ;%NWL%this . svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' y axis ' )%NWL%. call ( yAxis ) ;%NWL%} ,%NWL%renderData: function ( )  {%NWL%var x = this . scales . x ,%NWL%y = this . scales . y ,%NWL%var line = d3 . svg . line ( )%NWL%8
. call ( yAxis ) ;%NWL%} ,%NWL%renderData: function ( )  {%NWL%var x = this . scales . x ,%NWL%y = this . scales . y ,%NWL%opts = this . options;%NWL%var line = d3 . svg . line ( )%NWL%. interpolate ( opts . interpolate )%NWL%. defined ( function ( d )  { return d && opts . yValid ( d [ opts . yAttr ] ) ; } )%NWL%. x ( function ( d )  { return x ( d [ opts . xAttr ] ) ; } )%NWL%var series = this . svg . selectAll ( ' . series ' )%NWL%3
function tween ( )  {%NWL%var node = this , i = value . apply ( node , arguments ) ;%NWL%return i && function ( t )  {%NWL%node . setAttributeNS ( fullname . space , fullname . local , i ( t ) ) ;%NWL%} ;%NWL%}%NWL%tween . _value = value;%NWL%return tween;%NWL%}%NWL%function attrTween ( name , value )  {%NWL%var node = this , i = value . apply ( node , arguments ) ;%NWL%1
o = schedules [ i ] ;%NWL%if ( o . name !== self . name ) continue;%NWL%if ( o . state === STARTED ) return timeout ( start ) ;%NWL%if ( o . state === RUNNING )  {%NWL%o . state = ENDED;%NWL%o . timer . stop ( ) ;%NWL%o . on . call ( " interrupt " , node , node . __data__ , o . index , o . group ) ;%NWL%delete schedules [ i ] ;%NWL%}%NWL%else if ( + i < id )  {%NWL%o . timer . stop ( ) ;%NWL%5
var tape = require ( " tape " ) ,%NWL%jsdom = require ( " . / jsdom " ) ,%NWL%d3_timer = require ( " d3 - timer " ) ,%NWL%d3_selection = require ( " d3 - selection " ) ,%NWL%d3_transition = require ( " . . / " ) ;%NWL%tape ( " d3 . active ( node ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%8
d3_timer = require ( " d3 - timer " ) ,%NWL%d3_selection = require ( " d3 - selection " ) ,%NWL%d3_transition = require ( " . . / " ) ;%NWL%tape ( " d3 . active ( node ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( " foo " ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%6
tape ( " d3 . active ( node ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( " foo " ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%} ) ;%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%3
d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( d3_transition . active ( root ) , null ) ;%NWL%test . end ( ) ;%NWL%} , 100 ) ;%NWL%} ) ;%NWL%tape ( " d3 . active ( node , null ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%8
test . end ( ) ;%NWL%} , 100 ) ;%NWL%} ) ;%NWL%tape ( " d3 . active ( node , null ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( " foo " ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%6
tape ( " d3 . active ( node , null ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( " foo " ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%} ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%3
d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%test . end ( ) ;%NWL%} , 100 ) ;%NWL%} ) ;%NWL%tape ( " d3 . active ( node , undefined ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%8
test . end ( ) ;%NWL%} , 100 ) ;%NWL%} ) ;%NWL%tape ( " d3 . active ( node , undefined ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( " foo " ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%6
tape ( " d3 . active ( node , undefined ) returns null if the specified node has no active transition with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%selection . transition ( ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( " foo " ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%} ) ;%NWL%test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%3
test . strictEqual ( d3_transition . active ( root , undefined ) , null ) ;%NWL%test . end ( ) ;%NWL%} , 100 ) ;%NWL%} ) ;%NWL%tape ( " d3 . active ( node , name ) returns null if the specified node has no active transition with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%selection . transition ( " foo " ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%7
} , 100 ) ;%NWL%} ) ;%NWL%tape ( " d3 . active ( node , name ) returns null if the specified node has no active transition with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%selection . transition ( " foo " ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%5
var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%selection . transition ( " foo " ) . delay ( 50 ) . duration ( 50 ) ;%NWL%selection . transition ( ) . duration ( 50 ) ;%NWL%test . strictEqual ( d3_transition . active ( root , null ) , null ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%} ) ;%NWL%test . strictEqual ( d3_transition . active ( root ,  " foo " ) , null ) ;%NWL%2
d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( \ " start\ " , error ) with delay terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . delay ( 50 ) . on ( " start " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%1
test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( \ " start\ " , error ) with delay terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . delay ( 50 ) . on ( " start " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . end ( ) ;%NWL%1
d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} , 50 ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( \ " foo\ " , error ) terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . tween ( " foo " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%1
test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} , 50 ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( \ " foo\ " , error ) terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . tween ( " foo " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . end ( ) ;%NWL%1
d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( \ " foo\ " , error ) with delay terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . delay ( 50 ) . tween ( " foo " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%1
test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( \ " foo\ " , error ) with delay terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . delay ( 50 ) . tween ( " foo " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . end ( ) ;%NWL%1
d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} , 50 ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( \ " foo\ " , deferredError ) terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . duration ( 50 ) . tween ( " foo " , function ( )  { return function ( t )  { if ( t === 1 ) throw new Error; } ; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%1
test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} , 50 ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( \ " foo\ " , deferredError ) terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . duration ( 50 ) . tween ( " foo " , function ( )  { return function ( t )  { if ( t === 1 ) throw new Error; } ; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . end ( ) ;%NWL%1
d3_timer . timeout ( function ( )  {%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} , 50 ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( \ " end\ " , error ) terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . delay ( 50 ) . duration ( 50 ) . on ( " end " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%test . strictEqual ( root . __transition , undefined ) ;%NWL%1
test . strictEqual ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} , 50 ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( \ " end\ " , error ) terminates the transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . delay ( 50 ) . duration ( 50 ) . on ( " end " , function ( )  { throw new Error; } ) ;%NWL%process . once ( " uncaughtException " , function ( )  { } ) ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . end ( ) ;%NWL%1
test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%d3_transition . interrupt ( root ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( name ) only cancels pending transitions with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%0
test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%d3_transition . interrupt ( root ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( name ) only cancels pending transitions with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( name ) only cancels pending transitions with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%d3_transition . interrupt ( root ,  " foo " ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%8
selection = d3_selection . select ( document ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) cancels any pending transitions on the selected elements " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( ) ,%NWL%transition2 = transition1 . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%1
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) cancels any pending transitions on the selected elements " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( ) ,%NWL%transition2 = transition1 . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%0
test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%0
test . equal ( selection . interrupt ( ) , selection ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%0
test . equal ( root . __transition , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%8
test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( null ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%2
test . equal ( transition2 . _id in root . __transition , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( null ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%8
test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( null ) , selection ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( undefined ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%2
test . equal ( transition2 . _id in root . __transition , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( undefined ) only cancels pending transitions with the null name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%8
test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( undefined ) , selection ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , false ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( name ) only cancels pending transitions with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( name ) only cancels pending transitions with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( " foo " ) , selection ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%8
test . equal ( selection . interrupt ( " foo " ) , selection ) ;%NWL%test . equal ( transition1 . _id in root . __transition , false ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( name ) coerces the name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( name ) coerces the name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition1 = selection . transition ( " foo " ) ,%NWL%transition2 = selection . transition ( ) ;%NWL%test . equal ( transition1 . _id in root . __transition , true ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( { toString: function ( )  { return " foo " ; } } ) , selection ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%8
test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . equal ( selection . interrupt ( { toString: function ( )  { return " foo " ; } } ) , selection ) ;%NWL%test . equal ( transition1 . _id in root . __transition , false ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) does nothing if there is no transition on the selected elements " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%9
test . equal ( selection . interrupt ( { toString: function ( )  { return " foo " ; } } ) , selection ) ;%NWL%test . equal ( transition1 . _id in root . __transition , false ) ;%NWL%test . equal ( transition2 . _id in root . __transition , true ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " selection . interrupt ( ) does nothing if there is no transition on the selected elements " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ;%NWL%test . equal ( root . __transition , undefined ) ;%NWL%test . equal ( selection . interrupt ( ) , selection ) ;%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " selection . interrupt ( ) has no effect on an ended transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . duration ( 50 ) . on ( " end " , ended ) ,%NWL%schedule = root . __transition [ transition . _id ] ;%NWL%function ended ( )  {%NWL%d3_timer . timeout ( function ( )  {%NWL%test . equal ( schedule . state , state . ENDED ) ;%NWL%test . equal ( schedule . timer . _call , null ) ;%NWL%test . equal ( schedule . state , state . ENDED ) ;%NWL%8
tape ( " selection . interrupt ( ) has no effect on an ended transition " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . duration ( 50 ) . on ( " end " , ended ) ,%NWL%schedule = root . __transition [ transition . _id ] ;%NWL%function ended ( )  {%NWL%d3_timer . timeout ( function ( )  {%NWL%test . equal ( schedule . state , state . ENDED ) ;%NWL%test . equal ( schedule . timer . _call , null ) ;%NWL%selection . interrupt ( ) ;%NWL%test . equal ( schedule . timer . _call , null ) ;%NWL%8
schedule = root . __transition [ transition . _id ] ;%NWL%d3_timer . timeout ( function ( )  {%NWL%test . equal ( schedule . state , state . STARTED ) ;%NWL%selection . interrupt ( ) ;%NWL%test . equal ( schedule . state , state . ENDED ) ;%NWL%test . equal ( schedule . timer . _call , null ) ;%NWL%test . equal ( interrupts , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%function interrupted ( )  {%NWL%selection . interrupt ( ) ;%NWL%3
transition = selection . transition ( ) . attr ( " foo " ,  " #00f " ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . strictEqual ( root . getAttribute ( " foo " ) , interpolate ( ease ( elapsed / duration ) ) ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . attr ( name , value ) creates an attrTween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) . attr ( " fill " ,  " red " ) ,%NWL%transition = selection . transition ( ) . attr ( " fill " ,  " blue " ) ;%NWL%test . end ( ) ;%NWL%3
selection = d3_selection . select ( root ) . attr ( " fill " ,  " red " ) ,%NWL%transition = selection . transition ( ) . attr ( " fill " ,  " blue " ) ;%NWL%test . equal ( transition . attrTween ( " fill " ) . call ( root ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . attr ( name , value ) creates a tween with the name \ " attr . name\ " " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) . attr ( " fill " ,  " red " ) ,%NWL%transition = selection . transition ( ) . attr ( " fill " ,  " blue " ) ;%NWL%transition . tween ( " attr . fill " ) . call ( root ) ( 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%3
test . strictEqual ( root . getAttribute ( " foo " ) ,  " 42 " ) ;%NWL%test . strictEqual ( root . getAttributeNS ( " http: / / www . w3 . org / 2000 / svg " ,  " bar " ) ,  " 43 " ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . attrTween ( name , value ) defines a namespaced attribute tween using the interpolator returned by the specified function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . attrTween ( " svg:foo " , function ( )  { return interpolate; } ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . end ( ) ;%NWL%2
d3_timer . timeout ( function ( elapsed )  {%NWL%test . strictEqual ( root . getAttributeNS ( " http: / / www . w3 . org / 2000 / svg " ,  " foo " ) , interpolate ( d3_ease . easeCubic ( elapsed / 250 ) ) ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . attrTween ( name , value ) coerces the specified name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . attrTween ( { toString: function ( )  { return " foo " ; } } , function ( )  { return interpolate; } ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . end ( ) ;%NWL%2
interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . attrTween ( { toString: function ( )  { return " foo " ; } } , function ( )  { return interpolate; } ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . strictEqual ( root . getAttribute ( " foo " ) , interpolate ( d3_ease . easeCubic ( elapsed / 250 ) ) ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . attrTween ( name , value ) throws an error if value is not null and not a function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . end ( ) ;%NWL%4
test . throws ( function ( )  { transition . attrTween ( " foo " , 42 ) ; } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . attrTween ( name , null ) removes the specified attribute tween " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . attrTween ( " foo " , function ( )  { return interpolate; } ) . attrTween ( " foo " , null ) ;%NWL%test . equal ( transition . attrTween ( " foo " ) , null ) ;%NWL%test . equal ( transition . tween ( " attr . foo " ) , null ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . attrTween ( name ) returns the attribute tween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%tween = function ( )  { return interpolate; } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . attrTween ( " foo " , tween ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%test . equal ( transition . attrTween ( " foo " ) , tween ) ;%NWL%test . equal ( transition . attrTween ( " bar " ) , null ) ;%NWL%test . equal ( transition . attrTween ( " foo " ) , tween ) ;%NWL%8
tape ( " transition . attrTween ( name ) returns the attribute tween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%tween = function ( )  { return interpolate; } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . attrTween ( " foo " , tween ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%test . equal ( transition . attrTween ( " foo " ) , tween ) ;%NWL%test . equal ( transition . attrTween ( " bar " ) , null ) ;%NWL%function started ( )  {%NWL%test . equal ( transition . attrTween ( " foo " ) , tween ) ;%NWL%}%NWL%test . equal ( transition . attrTween ( " foo " ) , tween ) ;%NWL%5
}%NWL%function ended ( )  {%NWL%test . equal ( transition . attrTween ( " foo " ) , tween ) ;%NWL%test . end ( ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " transition . attrTween ( name ) coerces the specified name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . attrTween ( " color " , tween ) ;%NWL%test . end ( ) ;%NWL%3
mat [ edge . source ] = mat [ edge . source ] || { } ;%NWL%mat [ edge . source ] [ edge . target ] = edge . weight;%NWL%mat [ edge . target ] = mat [ edge . target ] || { } ;%NWL%mat [ edge . target ] [ edge . source ] = edge . weight;%NWL%} ) ;%NWL%return mat;%NWL%}%NWL%function update_assoc_mat ( graph , edge ) {%NWL%graph . _assoc_mat [ edge . source ] = graph . _assoc_mat [ edge . source ] || { } ;%NWL%graph . _assoc_mat [ edge . source ] [ edge . target ] = edge . weight;%NWL%graph . _assoc_mat [ edge . target ] [ edge . source ] = edge . weight;%NWL%8
status [ ' total_weight ' ] = get_graph_size ( graph ) ;%NWL%if ( typeof part === ' undefined ' ) {%NWL%graph . nodes . forEach ( function ( node , i ) {%NWL%status . nodes_to_com [ node ] = i;%NWL%var deg = get_degree_for_node ( graph , node ) ;%NWL%if ( deg < 0 )  {%NWL%throw ' Bad graph type , use positive weights! ' ;%NWL%}%NWL%status . degrees [ i ] = deg;%NWL%status . gdegrees [ node ] = deg;%NWL%status . internals [ i ] = status . loops [ node ] ;%NWL%0
weights [ neighbourcom ] = ( weights [ neighbourcom ] || 0 )  + weight;%NWL%}%NWL%} ) ;%NWL%return weights;%NWL%}%NWL%function __insert ( node , com , weight , status ) {%NWL%status . nodes_to_com [ node ] = + com;%NWL%status . degrees [ com ] = ( status . degrees [ com ] || 0 )  +  ( status . gdegrees [ node ] ||0 ) ;%NWL%status . internals [ com ] = ( status . internals [ com ] || 0 )  + weight +  ( status . loops [ node ] ||0 ) ;%NWL%}%NWL%status . degrees [ com ] = ( ( status . degrees [ com ] || 0 )  -  ( status . gdegrees [ node ] || 0 ) ) ;%NWL%7
}%NWL%} ) ;%NWL%return weights;%NWL%}%NWL%function __insert ( node , com , weight , status ) {%NWL%status . nodes_to_com [ node ] = + com;%NWL%status . degrees [ com ] = ( status . degrees [ com ] || 0 )  +  ( status . gdegrees [ node ] ||0 ) ;%NWL%status . internals [ com ] = ( status . internals [ com ] || 0 )  + weight +  ( status . loops [ node ] ||0 ) ;%NWL%}%NWL%function __remove ( node , com , weight , status ) {%NWL%status . internals [ com ] = ( ( status . internals [ com ] || 0 )  - weight - ( status . loops [ node ] ||0 ) ) ;%NWL%6
status_list . push ( partition ) ;%NWL%mod = new_mod;%NWL%var current_graph = induced_graph ( partition , original_graph ) ;%NWL%init_status ( current_graph , status ) ;%NWL%while ( true ) {%NWL%__one_level ( current_graph , status ) ;%NWL%new_mod = __modularity ( status ) ;%NWL%if ( new_mod - mod < __MIN )  {%NWL%break;%NWL%}%NWL%status_list . push ( partition ) ;%NWL%0
} else {%NWL%x = appearance . scene . x - 0 . 5 * scale;%NWL%y = appearance . scene . y + appearance . y;%NWL%if ( x - labelSize [ 0 ] < labelSize [ 0 ] )  {%NWL%x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%introduction . x = appearance . character . _x || Math . max ( 0 , Math . min ( size [ 0 ] - labelSize [ 0 ] , x ) ) ;%NWL%8
x = appearance . scene . x - 0 . 5 * scale;%NWL%y = appearance . scene . y + appearance . y;%NWL%if ( x - labelSize [ 0 ] < labelSize [ 0 ] )  {%NWL%x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%} else {%NWL%introduction . y = appearance . character . _y || Math . max ( 0 + labelSize [ 1 ] / 2 , Math . min ( size [ 1 ] - labelSize [ 1 ] / 2 , y ) ) ;%NWL%7
if ( x - labelSize [ 0 ] < labelSize [ 0 ] )  {%NWL%x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%} else {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 , Math . min ( size [ 0 ] - labelSize [ 0 ] , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 + labelSize [ 1 ] / 2 , Math . min ( size [ 1 ] - labelSize [ 1 ] / 2 , y ) ) ;%NWL%introduction . width = appearance . character . _width || labelSize [ 0 ] ;%NWL%5
x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%} else {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 , Math . min ( size [ 0 ] - labelSize [ 0 ] , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 + labelSize [ 1 ] / 2 , Math . min ( size [ 1 ] - labelSize [ 1 ] / 2 , y ) ) ;%NWL%}%NWL%introduction . height = appearance . character . _height || labelSize [ 1 ] ;%NWL%4
} ,%NWL%pop: function ( options )  {%NWL%var model = this . at ( this . length - 1 ) ;%NWL%this . remove ( model , options ) ;%NWL%return model;%NWL%} ,%NWL%unshift: function ( model , options )  {%NWL%return this . add ( model , _ . extend ( { at: 0 } , options ) ) ;%NWL%} ,%NWL%shift: function ( options )  {%NWL%this . remove ( model , options ) ;%NWL%3
return model . get ( value ) ;%NWL%} ;%NWL%return _ [ method ] ( this . models , iterator , context ) ;%NWL%} ;%NWL%} ) ;%NWL%var View = Backbone . View = function ( options )  {%NWL%this . cid = _ . uniqueId ( ' view ' ) ;%NWL%options || ( options = { } ) ;%NWL%_ . extend ( this , _ . pick ( options , viewOptions ) ) ;%NWL%this . _ensureElement ( ) ;%NWL%this . delegateEvents ( ) ;%NWL%9
var type = methodMap [ method ] ;%NWL%_ . defaults ( options || ( options = { } ) ,  {%NWL%emulateHTTP: Backbone . emulateHTTP ,%NWL%emulateJSON: Backbone . emulateJSON%NWL%} ) ;%NWL%var params = { type: type , dataType: ' json ' } ;%NWL%if ( !options . url )  {%NWL%params . url = _ . result ( model ,  ' url ' ) || urlError ( ) ;%NWL%}%NWL%if ( options . data == null && model && ( method === ' create ' || method === ' update ' || method === ' patch ' ) )  {%NWL%params . data = JSON . stringify ( options . attrs || model . toJSON ( options ) ) ;%NWL%7
History . started = false;%NWL%_ . extend ( History . prototype , Events ,  {%NWL%interval: 50 ,%NWL%getHash: function ( window )  {%NWL%var match = ( window || this ) . location . href . match ( / # ( . * ) $ / ) ;%NWL%return match ? match [ 1 ] : ' ' ;%NWL%} ,%NWL%getFragment: function ( fragment , forcePushState )  {%NWL%if ( fragment == null )  {%NWL%if ( this . _hasPushState || !this . _wantsHashChange || forcePushState )  {%NWL%var root = this . root . replace ( trailingSlash ,  ' ' ) ;%NWL%4
} else {%NWL%fragment = this . getHash ( ) ;%NWL%}%NWL%}%NWL%return fragment . replace ( routeStripper ,  ' ' ) ;%NWL%} ,%NWL%start: function ( options )  {%NWL%if ( History . started ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%History . started = true;%NWL%this . options     = _ . extend ( { root: ' / ' } , this . options , options ) ;%NWL%this . _wantsHashChange = this . options . hashChange !== false;%NWL%9
fragment = this . getHash ( ) ;%NWL%}%NWL%}%NWL%return fragment . replace ( routeStripper ,  ' ' ) ;%NWL%} ,%NWL%start: function ( options )  {%NWL%if ( History . started ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%History . started = true;%NWL%this . options     = _ . extend ( { root: ' / ' } , this . options , options ) ;%NWL%this . root       = this . options . root;%NWL%this . _wantsPushState = !!this . options . pushState;%NWL%8
}%NWL%}%NWL%return fragment . replace ( routeStripper ,  ' ' ) ;%NWL%} ,%NWL%start: function ( options )  {%NWL%if ( History . started ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%History . started = true;%NWL%this . options     = _ . extend ( { root: ' / ' } , this . options , options ) ;%NWL%this . root       = this . options . root;%NWL%this . _wantsHashChange = this . options . hashChange !== false;%NWL%this . _hasPushState  = !! ( this . options . pushState && this . history && this . history . pushState ) ;%NWL%7
start: function ( options )  {%NWL%if ( History . started ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%History . started = true;%NWL%this . options     = _ . extend ( { root: ' / ' } , this . options , options ) ;%NWL%this . root       = this . options . root;%NWL%this . _wantsHashChange = this . options . hashChange !== false;%NWL%this . _wantsPushState = !!this . options . pushState;%NWL%this . _hasPushState  = !! ( this . options . pushState && this . history && this . history . pushState ) ;%NWL%var fragment     = this . getFragment ( ) ;%NWL%var docMode      = document . documentMode;%NWL%this . root = ( ' / '  + this . root +  ' / ' ) . replace ( rootStripper ,  ' / ' ) ;%NWL%3
History . started = true;%NWL%this . options     = _ . extend ( { root: ' / ' } , this . options , options ) ;%NWL%this . root       = this . options . root;%NWL%this . _wantsHashChange = this . options . hashChange !== false;%NWL%this . _wantsPushState = !!this . options . pushState;%NWL%this . _hasPushState  = !! ( this . options . pushState && this . history && this . history . pushState ) ;%NWL%var fragment     = this . getFragment ( ) ;%NWL%var docMode      = document . documentMode;%NWL%var oldIE       = ( isExplorer . exec ( navigator . userAgent . toLowerCase ( ) ) && ( !docMode || docMode <= 7 ) ) ;%NWL%this . root = ( ' / '  + this . root +  ' / ' ) . replace ( rootStripper ,  ' / ' ) ;%NWL%this . iframe = Backbone . $ ( ' <iframe src= " javascript:0 " tabindex= " - 1 "  / > ' ) . hide ( ) . appendTo ( ' body ' ) [ 0 ] . contentWindow;%NWL%1
var oldIE       = ( isExplorer . exec ( navigator . userAgent . toLowerCase ( ) ) && ( !docMode || docMode <= 7 ) ) ;%NWL%this . root = ( ' / '  + this . root +  ' / ' ) . replace ( rootStripper ,  ' / ' ) ;%NWL%if ( oldIE && this . _wantsHashChange )  {%NWL%this . iframe = Backbone . $ ( ' <iframe src= " javascript:0 " tabindex= " - 1 "  / > ' ) . hide ( ) . appendTo ( ' body ' ) [ 0 ] . contentWindow;%NWL%this . navigate ( fragment ) ;%NWL%}%NWL%if ( this . _hasPushState )  {%NWL%Backbone . $ ( window ) . on ( ' popstate ' , this . checkUrl ) ;%NWL%} else if ( this . _wantsHashChange && ( ' onhashchange ' in window ) && !oldIE )  {%NWL%Backbone . $ ( window ) . on ( ' hashchange ' , this . checkUrl ) ;%NWL%this . _checkUrlInterval = setInterval ( this . checkUrl , this . interval ) ;%NWL%1
test . strictEqual ( d3_selection . selectAll ( [ one , two ] ) . transition ( transition1 ) . delay ( ) , 0 ) ;%NWL%test . strictEqual ( d3_selection . selectAll ( [ two , one ] ) . transition ( transition2 ) . delay ( ) , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( number ) sets the delay for each selected element to the specified number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( 50 ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . end ( ) ;%NWL%2
two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( 50 ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( value ) coerces the specified value to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 50 ) ;%NWL%2
transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( 50 ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( value ) coerces the specified value to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( " 50 " ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 50 ) ;%NWL%2
test . strictEqual ( one . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( value ) coerces the specified value to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( " 50 " ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 50 ) ;%NWL%test . end ( ) ;%NWL%2
[ " two " , 1 , transition . _groups [ 0 ] , two ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( function ) sets the delay for each selected element to the number returned by the specified function " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( function ( d , i )  { return i * 20; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 0 ) ;%NWL%test . end ( ) ;%NWL%2
two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( function ( d , i )  { return i * 20; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 0 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( function ) coerces the value returned by the specified function to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 0 ) ;%NWL%2
transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( function ( d , i )  { return i * 20; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 0 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( function ) coerces the value returned by the specified function to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( function ( d , i )  { return i * 20 +  " " ; } ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 20 ) ;%NWL%2
test . strictEqual ( one . __transition [ transition . _id ] . delay , 0 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . delay , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . delay ( function ) coerces the value returned by the specified function to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . delay ( function ( d , i )  { return i * 20 +  " " ; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . delay , 0 ) ;%NWL%test . end ( ) ;%NWL%2
test . strictEqual ( d3_selection . selectAll ( [ one , two ] ) . transition ( transition1 ) . duration ( ) , 250 ) ;%NWL%test . strictEqual ( d3_selection . selectAll ( [ two , one ] ) . transition ( transition2 ) . duration ( ) , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( number ) sets the duration for each selected element to the specified number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( 50 ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . end ( ) ;%NWL%2
two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( 50 ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( value ) coerces the specified value to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 50 ) ;%NWL%2
transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( 50 ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( value ) coerces the specified value to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( " 50 " ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 50 ) ;%NWL%2
test . strictEqual ( one . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( value ) coerces the specified value to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( " 50 " ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 50 ) ;%NWL%test . end ( ) ;%NWL%2
[ " two " , 1 , transition . _groups [ 0 ] , two ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( function ) sets the duration for each selected element to the number returned by the specified function " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( function ( d , i )  { return i * 20; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 0 ) ;%NWL%test . end ( ) ;%NWL%2
two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( function ( d , i )  { return i * 20; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 0 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( function ) coerces the value returned by the specified function to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 0 ) ;%NWL%2
transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( function ( d , i )  { return i * 20; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 0 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( function ) coerces the value returned by the specified function to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( function ( d , i )  { return i * 20 +  " " ; } ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 20 ) ;%NWL%2
test . strictEqual ( one . __transition [ transition . _id ] . duration , 0 ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . duration , 20 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . duration ( function ) coerces the value returned by the specified function to a number " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . duration ( function ( d , i )  { return i * 20 +  " " ; } ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . duration , 0 ) ;%NWL%test . end ( ) ;%NWL%2
test . strictEqual ( d3_selection . selectAll ( [ null , one ] ) . transition ( transition1 ) . ease ( ) , d3_ease . easeCubic ) ;%NWL%test . strictEqual ( d3_selection . selectAll ( [ null , two ] ) . transition ( transition2 ) . ease ( ) , d3_ease . easeBounce ) ;%NWL%test . strictEqual ( d3_selection . selectAll ( [ one , two ] ) . transition ( transition1 ) . ease ( ) , d3_ease . easeCubic ) ;%NWL%test . strictEqual ( d3_selection . selectAll ( [ two , one ] ) . transition ( transition2 ) . ease ( ) , d3_ease . easeBounce ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . ease ( ease ) throws an error if ease is not a function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . throws ( function ( )  { transition . ease ( 42 ) ; } ) ;%NWL%test . end ( ) ;%NWL%4
test . throws ( function ( )  { transition . ease ( 42 ) ; } ) ;%NWL%test . throws ( function ( )  { transition . ease ( null ) ; } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . ease ( ease ) sets the easing function for each selected element to the specified function " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) . ease ( d3_ease . easeBounce ) ;%NWL%test . strictEqual ( one . __transition [ transition . _id ] . ease , d3_ease . easeBounce ) ;%NWL%test . end ( ) ;%NWL%2
test . strictEqual ( one . __transition [ transition . _id ] . ease , d3_ease . easeBounce ) ;%NWL%test . strictEqual ( two . __transition [ transition . _id ] . ease , d3_ease . easeBounce ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . ease ( ease ) passes the easing function the normalized time in [ 0 , 1 ] " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%actual ,%NWL%ease = function ( t )  { actual = t; return t; } ;%NWL%d3_selection . select ( root ) . transition ( ) . ease ( ease ) ;%NWL%d3_timer . timeout ( function ( now )  {%NWL%test . end ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%jsdom = require ( " . . / jsdom " ) ,%NWL%d3_transition = require ( " . . / . . / " ) ;%NWL%var document = global . document = jsdom ( ) ,%NWL%0
var tape = require ( " tape " ) ,%NWL%jsdom = require ( " . . / jsdom " ) ,%NWL%d3_transition = require ( " . . / . . / " ) ;%NWL%tape ( " d3 . transition ( ) returns a transition on the document element with the null name " , function ( test )  {%NWL%var document = global . document = jsdom ( ) ,%NWL%root = document . documentElement;%NWL%var transition = d3_transition . transition ( ) ,%NWL%0
try {%NWL%var transition = d3_transition . transition ( ) ,%NWL%schedule = root . __transition [ transition . _id ] ;%NWL%test . equal ( transition . node ( ) , root ) ;%NWL%test . strictEqual ( schedule . name , null ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%delete global . document;%NWL%}%NWL%} ) ;%NWL%var document = global . document = jsdom ( ) ,%NWL%1
test . equal ( transition . node ( ) , root ) ;%NWL%test . strictEqual ( schedule . name , null ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%delete global . document;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . transition ( null ) returns a transition on the document element with the null name " , function ( test )  {%NWL%var document = global . document = jsdom ( ) ,%NWL%root = document . documentElement;%NWL%var transition = d3_transition . transition ( null ) ,%NWL%8
try {%NWL%var transition = d3_transition . transition ( null ) ,%NWL%schedule = root . __transition [ transition . _id ] ;%NWL%test . equal ( transition . node ( ) , root ) ;%NWL%test . strictEqual ( schedule . name , null ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%delete global . document;%NWL%}%NWL%} ) ;%NWL%var document = global . document = jsdom ( ) ,%NWL%1
test . equal ( transition . node ( ) , root ) ;%NWL%test . strictEqual ( schedule . name , null ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%delete global . document;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . transition ( undefined ) returns a transition on the document element with the null name " , function ( test )  {%NWL%var document = global . document = jsdom ( ) ,%NWL%root = document . documentElement;%NWL%var transition = d3_transition . transition ( undefined ) ,%NWL%8
try {%NWL%var transition = d3_transition . transition ( undefined ) ,%NWL%schedule = root . __transition [ transition . _id ] ;%NWL%test . equal ( transition . node ( ) , root ) ;%NWL%test . strictEqual ( schedule . name , null ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%delete global . document;%NWL%}%NWL%} ) ;%NWL%var document = global . document = jsdom ( ) ,%NWL%1
test . equal ( transition . node ( ) , root ) ;%NWL%test . strictEqual ( schedule . name , null ) ;%NWL%test . end ( ) ;%NWL%} finally {%NWL%delete global . document;%NWL%}%NWL%} ) ;%NWL%tape ( " d3 . transition ( name ) returns a transition on the document element with the specified name " , function ( test )  {%NWL%var document = global . document = jsdom ( ) ,%NWL%root = document . documentElement;%NWL%var transition = d3_transition . transition ( " foo " ) ,%NWL%8
test . end ( ) ;%NWL%} finally {%NWL%delete d3_transition . transition . prototype . test;%NWL%delete global . document;%NWL%}%NWL%} ) ;%NWL%tape ( " transitions are instanceof d3 . transition " , function ( test )  {%NWL%global . document = jsdom ( ) ;%NWL%try {%NWL%test . equal ( d3_transition . transition ( ) instanceof d3_transition . transition , true ) ;%NWL%test . end ( ) ;%NWL%0
test . equal ( transition3 . _name , transition1 . _name ) ;%NWL%test . equal ( transition3 . _id , transition1 . _id ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . merge ( other ) throws an error if the other transition has a different id " , function ( test )  {%NWL%var document = jsdom ( " <h1 id= ' one ' >< / h1><h1 id= ' two ' >< / h1> " ) ,%NWL%one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%transition1 = d3_selection . selectAll ( [ null , two ] ) . transition ( ) ,%NWL%transition2 = d3_selection . selectAll ( [ one , null ] ) . transition ( ) ;%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( typename ) returns the listener with the specified typename , if any " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%foo = function ( )  { } ,%NWL%bar = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . on ( " start " , foo ) . on ( " start . bar " , bar ) ;%NWL%test . equal ( transition . on ( " start " ) , foo ) ;%NWL%test . equal ( transition . on ( " start . foo " ) , undefined ) ;%NWL%test . equal ( transition . on ( " start . bar " ) , bar ) ;%NWL%test . end ( ) ;%NWL%0
transition = d3_selection . select ( root ) . transition ( ) . on ( " start " , foo ) . on ( " start . bar " , bar ) ;%NWL%test . equal ( transition . on ( " start " ) , foo ) ;%NWL%test . equal ( transition . on ( " start . foo " ) , undefined ) ;%NWL%test . equal ( transition . on ( " start . bar " ) , bar ) ;%NWL%test . equal ( transition . on ( " end " ) , undefined ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( typename ) throws an error if the specified type is not supported " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " transition . on ( typename ) throws an error if the specified type is not supported " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . throws ( function ( )  { transition . on ( " foo " ) ; } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( typename , listener ) throws an error if the specified type is not supported " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . end ( ) ;%NWL%5
} ) ;%NWL%tape ( " transition . on ( typename , listener ) throws an error if the specified type is not supported " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . throws ( function ( )  { transition . on ( " foo " , function ( )  { } ) ; } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( typename , listener ) throws an error if the specified listener is not a function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . end ( ) ;%NWL%5
d3_timer . timeout ( function ( )  {%NWL%test . equal ( starts , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " transition . on ( \ " start\ " , listener ) registers a listener for the start event " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . on ( " start " , started ) ,%NWL%schedule = root . __transition [ transition . _id ] ;%NWL%function started ( )  {%NWL%test . end ( ) ;%NWL%2
test . equal ( schedule . state , state . STARTING ) ;%NWL%test . end ( ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " transition . on ( \ " interrupt\ " , listener ) registers a listener for the interrupt event ( during start ) " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . on ( " interrupt " , interrupted ) ,%NWL%schedule = root . __transition [ transition . _id ] ;%NWL%function interrupted ( )  {%NWL%test . end ( ) ;%NWL%1
two = document . querySelector ( " #two " ) ,%NWL%foo = function ( )  { } ,%NWL%bar = function ( )  { } ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) ,%NWL%schedule1 = one . __transition [ transition . _id ] ,%NWL%schedule2 = two . __transition [ transition . _id ] ;%NWL%transition . on ( " start " , foo ) ;%NWL%test . equal ( schedule1 . on . on ( " start " ) , foo ) ;%NWL%test . equal ( schedule2 . on , schedule1 . on ) ;%NWL%transition . on ( " start " , bar ) ;%NWL%test . equal ( schedule2 . on , schedule1 . on ) ;%NWL%8
bar = function ( )  { } ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) ,%NWL%schedule1 = one . __transition [ transition . _id ] ,%NWL%schedule2 = two . __transition [ transition . _id ] ;%NWL%transition . on ( " start " , foo ) ;%NWL%test . equal ( schedule1 . on . on ( " start " ) , foo ) ;%NWL%test . equal ( schedule2 . on , schedule1 . on ) ;%NWL%transition . on ( " start " , bar ) ;%NWL%test . equal ( schedule1 . on . on ( " start " ) , bar ) ;%NWL%test . equal ( schedule2 . on , schedule1 . on ) ;%NWL%test . equal ( schedule1 . on . on ( " start " ) , bar ) ;%NWL%8
body = document . body ,%NWL%selection = d3_selection . select ( body ) ,%NWL%transition = selection . transition ( ) . remove ( ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%function started ( )  {%NWL%test . equal ( body . parentNode , root ) ;%NWL%}%NWL%function ended ( )  {%NWL%test . equal ( body . parentNode , null ) ;%NWL%test . end ( ) ;%NWL%}%NWL%test . equal ( body . parentNode , root ) ;%NWL%4
body = document . body ,%NWL%selection = d3_selection . select ( body ) ,%NWL%transition = selection . transition ( ) . remove ( ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%transition . on ( " end . remove " ) . call ( body ) ;%NWL%test . equal ( body . parentNode , null ) ;%NWL%transition . on ( " end . remove " , null ) ;%NWL%root . appendChild ( body ) ;%NWL%function started ( )  {%NWL%test . equal ( body . parentNode , root ) ;%NWL%}%NWL%test . equal ( body . parentNode , root ) ;%NWL%8
transition = selection . transition ( ) . style ( " color " ,  " #00f " ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . strictEqual ( root . style . getPropertyValue ( " color " ) , interpolate ( ease ( elapsed / duration ) ) ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . style ( name , value ) creates an styleTween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) . style ( " color " ,  " red " ) ,%NWL%transition = selection . transition ( ) . style ( " color " ,  " blue " ) ;%NWL%test . end ( ) ;%NWL%3
selection = d3_selection . select ( root ) . style ( " color " ,  " red " ) ,%NWL%transition = selection . transition ( ) . style ( " color " ,  " blue " ) ;%NWL%test . equal ( transition . styleTween ( " color " ) . call ( root ) ( 0 . 5 ) ,  " rgb ( 128 , 0 , 128 ) " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . style ( name , value ) creates a tween with the name \ " style . name\ " " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) . style ( " color " ,  " red " ) ,%NWL%transition = selection . transition ( ) . style ( " color " ,  " blue " ) ;%NWL%transition . tween ( " style . color " ) . call ( root ) ( 0 . 5 ) ;%NWL%test . end ( ) ;%NWL%3
test . deepEqual ( root . style . getPropertyValue ( " color " ) , interpolate ( ease ( elapsed / 250 ) ) ) ;%NWL%test . deepEqual ( root . style . getPropertyPriority ( " color " ) ,  " " ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . styleTween ( name , value , priority ) defines a style tween using the interpolator returned by the specified function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%ease = d3_ease . easeCubic ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( " color " , function ( )  { return interpolate; } ,  " important " ) ;%NWL%test . deepEqual ( root . style . getPropertyValue ( " color " ) , interpolate ( ease ( elapsed / 250 ) ) ) ;%NWL%0
test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . styleTween ( name , value , priority ) defines a style tween using the interpolator returned by the specified function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%ease = d3_ease . easeCubic ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( " color " , function ( )  { return interpolate; } ,  " important " ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . deepEqual ( root . style . getPropertyValue ( " color " ) , interpolate ( ease ( elapsed / 250 ) ) ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( root . style . getPropertyValue ( " color " ) ,  " red " ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . styleTween ( name , value ) coerces the specified name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%ease = d3_ease . easeCubic ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( { toString: function ( )  { return " color " ; } } , function ( )  { return interpolate; } ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . end ( ) ;%NWL%1
ease = d3_ease . easeCubic ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( { toString: function ( )  { return " color " ; } } , function ( )  { return interpolate; } ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . deepEqual ( root . style . getPropertyValue ( " color " ) , interpolate ( ease ( elapsed / 250 ) ) ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . styleTween ( name , value ) throws an error if value is not null and not a function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . end ( ) ;%NWL%4
test . throws ( function ( )  { transition . styleTween ( " color " , 42 ) ; } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . styleTween ( name , null ) removes the specified style tween " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( " color " , function ( )  { return interpolate; } ) . styleTween ( " color " , null ) ;%NWL%test . equal ( transition . styleTween ( " color " ) , null ) ;%NWL%test . equal ( transition . tween ( " style . color " ) , null ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . end ( ) ;%NWL%1
test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . styleTween ( name ) returns the style tween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%tween = function ( )  { return interpolate; } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( " color " , tween ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%test . equal ( transition . styleTween ( " color " ) , tween ) ;%NWL%test . equal ( transition . styleTween ( " bar " ) , null ) ;%NWL%test . equal ( transition . styleTween ( " color " ) , tween ) ;%NWL%8
tape ( " transition . styleTween ( name ) returns the style tween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%interpolate = d3_interpolate . interpolateHcl ( " red " ,  " blue " ) ,%NWL%tween = function ( )  { return interpolate; } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( " color " , tween ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%test . equal ( transition . styleTween ( " color " ) , tween ) ;%NWL%test . equal ( transition . styleTween ( " bar " ) , null ) ;%NWL%function started ( )  {%NWL%test . equal ( transition . styleTween ( " color " ) , tween ) ;%NWL%}%NWL%test . equal ( transition . styleTween ( " color " ) , tween ) ;%NWL%5
}%NWL%function ended ( )  {%NWL%test . equal ( transition . styleTween ( " color " ) , tween ) ;%NWL%test . end ( ) ;%NWL%}%NWL%} ) ;%NWL%tape ( " transition . styleTween ( name ) coerces the specified name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . styleTween ( " color " , tween ) ;%NWL%test . end ( ) ;%NWL%3
test . strictEqual ( one . textContent ,  " red " ) ;%NWL%test . strictEqual ( two . textContent ,  " green " ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%tape ( " transition . text ( value ) creates a tween with the name \ " text\ " " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%selection = d3_selection . select ( root ) ,%NWL%transition = selection . transition ( ) . text ( " hello " ) ;%NWL%test . equal ( transition . tween ( " text " ) . call ( root ) , undefined ) ;%NWL%test . end ( ) ;%NWL%2
two = document . querySelector ( " #two " ) ,%NWL%foo = function ( )  { } ,%NWL%bar = function ( )  { } ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) ,%NWL%schedule1 = one . __transition [ transition . _id ] ,%NWL%schedule2 = two . __transition [ transition . _id ] ;%NWL%transition . tween ( " foo " , foo ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ { name: " foo " , value: foo } ] ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%transition . tween ( " foo " , bar ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%8
one = document . querySelector ( " #one " ) ,%NWL%two = document . querySelector ( " #two " ) ,%NWL%foo = function ( )  { } ,%NWL%transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) ,%NWL%schedule1 = one . __transition [ transition . _id ] ,%NWL%schedule2 = two . __transition [ transition . _id ] ;%NWL%transition . tween ( " foo " , foo ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ { name: " foo " , value: foo } ] ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%transition . tween ( " bar " , null ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%8
transition = d3_selection . selectAll ( [ one , two ] ) . transition ( ) ,%NWL%schedule1 = one . __transition [ transition . _id ] ,%NWL%schedule2 = two . __transition [ transition . _id ] ;%NWL%transition . tween ( " foo " , foo ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ { name: " foo " , value: foo } ] ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%transition . tween ( " bar " , null ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ { name: " foo " , value: foo } ] ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%transition . tween ( " foo " , null ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%5
schedule2 = two . __transition [ transition . _id ] ;%NWL%transition . tween ( " foo " , foo ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ { name: " foo " , value: foo } ] ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%transition . tween ( " bar " , null ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ { name: " foo " , value: foo } ] ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%transition . tween ( " foo " , null ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ ] ) ;%NWL%test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ ] ) ;%NWL%8
test . equal ( schedule2 . tween , schedule1 . tween ) ;%NWL%d3_selection . select ( two ) . transition ( transition ) . tween ( " foo " , foo ) ;%NWL%test . deepEqual ( schedule1 . tween ,  [ ] ) ;%NWL%test . deepEqual ( schedule2 . tween ,  [ { name: " foo " , value: foo } ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( name , value ) coerces the specified name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . tween ( { toString: function ( )  { return " foo " ; } } , tween ) ;%NWL%test . end ( ) ;%NWL%4
var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . tween ( { toString: function ( )  { return " foo " ; } } , tween ) ;%NWL%test . equal ( transition . tween ( " foo " ) , tween ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( name ) coerces the specified name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . tween ( " foo " , tween ) ;%NWL%test . end ( ) ;%NWL%4
tape ( " transition . tween ( name ) coerces the specified name to a string " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . tween ( " foo " , tween ) ;%NWL%test . equal ( transition . tween ( { toString: function ( )  { return " foo " ; } } ) , tween ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( name , value ) throws an error if value is not null and not a function " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%transition = d3_selection . select ( root ) . transition ( ) ;%NWL%test . end ( ) ;%NWL%5
test . throws ( function ( )  { transition . tween ( " foo " , 42 ) ; } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( name , null ) removes the specified tween " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%frames = 0 ,%NWL%interpolate = function ( )  {  + + frames; } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . tween ( " foo " , function ( )  { return interpolate; } ) . tween ( " foo " , null ) ;%NWL%test . equal ( transition . tween ( " foo " ) , null ) ;%NWL%d3_timer . timeout ( function ( elapsed )  {%NWL%test . end ( ) ;%NWL%1
test . strictEqual ( frames , 0 ) ;%NWL%test . end ( ) ;%NWL%} , 125 ) ;%NWL%} ) ;%NWL%tape ( " transition . tween ( name ) returns the tween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . tween ( " foo " , tween ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%test . equal ( transition . tween ( " foo " ) , tween ) ;%NWL%test . equal ( transition . tween ( " bar " ) , null ) ;%NWL%test . equal ( transition . tween ( " foo " ) , tween ) ;%NWL%8
} ) ;%NWL%tape ( " transition . tween ( name ) returns the tween with the specified name " , function ( test )  {%NWL%var root = jsdom ( ) . documentElement ,%NWL%tween = function ( )  { } ,%NWL%transition = d3_selection . select ( root ) . transition ( ) . tween ( " foo " , tween ) . on ( " start " , started ) . on ( " end " , ended ) ;%NWL%test . equal ( transition . tween ( " foo " ) , tween ) ;%NWL%test . equal ( transition . tween ( " bar " ) , null ) ;%NWL%function started ( )  {%NWL%test . equal ( transition . tween ( " foo " ) , tween ) ;%NWL%}%NWL%test . equal ( transition . tween ( " foo " ) , tween ) ;%NWL%5
disappearing = [ beach ] ;%NWL%detachBeach ( beach ) ;%NWL%var lArc = previous;%NWL%while ( lArc . circle%NWL%&& Math . abs ( x - lArc . circle . x ) < epsilon%NWL%&& Math . abs ( y - lArc . circle . cy ) < epsilon )  {%NWL%previous = lArc . P;%NWL%disappearing . unshift ( lArc ) ;%NWL%detachBeach ( lArc ) ;%NWL%lArc = previous;%NWL%disappearing . unshift ( lArc ) ;%NWL%7
disappearing . unshift ( lArc ) ;%NWL%detachCircle ( lArc ) ;%NWL%var rArc = next;%NWL%while ( rArc . circle%NWL%&& Math . abs ( x - rArc . circle . x ) < epsilon%NWL%&& Math . abs ( y - rArc . circle . cy ) < epsilon )  {%NWL%next = rArc . N;%NWL%disappearing . push ( rArc ) ;%NWL%detachBeach ( rArc ) ;%NWL%rArc = next;%NWL%disappearing . push ( rArc ) ;%NWL%7
if ( !lArc && !rArc ) return;%NWL%if ( lArc === rArc )  {%NWL%detachCircle ( lArc ) ;%NWL%rArc = createBeach ( lArc . site ) ;%NWL%beaches . insert ( newArc , rArc ) ;%NWL%newArc . edge = rArc . edge = createEdge ( lArc . site , newArc . site ) ;%NWL%attachCircle ( lArc ) ;%NWL%attachCircle ( rArc ) ;%NWL%return;%NWL%}%NWL%newArc . edge = createEdge ( lArc . site , newArc . site ) ;%NWL%5
return edge . right;%NWL%} ) . map ( function ( edge )  {%NWL%return {%NWL%source: edge . left . data ,%NWL%target: edge . right . data%NWL%} ;%NWL%} ) ;%NWL%} ,%NWL%find: function ( x , y , radius )  {%NWL%var that = this , i0 , i1 = that . _found || 0 , n = that . cells . length , cell;%NWL%var dx = x - cell . site [ 0 ] , dy = y - cell . site [ 1 ] , d2 = dx * dx + dy * dy;%NWL%9
target: edge . right . data%NWL%} ;%NWL%} ) ;%NWL%} ,%NWL%find: function ( x , y , radius )  {%NWL%var that = this , i0 , i1 = that . _found || 0 , n = that . cells . length , cell;%NWL%while ( ! ( cell = that . cells [ i1 ] ) ) if ( + + i1 >= n ) return null;%NWL%var dx = x - cell . site [ 0 ] , dy = y - cell . site [ 1 ] , d2 = dx * dx + dy * dy;%NWL%do {%NWL%cell = that . cells [ i0 = i1 ] , i1 = null;%NWL%var edge = that . edges [ e ] , v = edge . left;%NWL%5
} ) ;%NWL%} ,%NWL%find: function ( x , y , radius )  {%NWL%var that = this , i0 , i1 = that . _found || 0 , n = that . cells . length , cell;%NWL%while ( ! ( cell = that . cells [ i1 ] ) ) if ( + + i1 >= n ) return null;%NWL%var dx = x - cell . site [ 0 ] , dy = y - cell . site [ 1 ] , d2 = dx * dx + dy * dy;%NWL%do {%NWL%cell = that . cells [ i0 = i1 ] , i1 = null;%NWL%cell . halfedges . forEach ( function ( e )  {%NWL%var edge = that . edges [ e ] , v = edge . left;%NWL%var vx = x - v [ 0 ] , vy = y - v [ 1 ] , v2 = vx * vx + vy * vy;%NWL%3
voronoi = require ( " . . / " ) ;%NWL%tape ( " voronoi ( points ) . find ( x , y ) returns the closest site " , function ( test )  {%NWL%var v = voronoi . voronoi ( ) ;%NWL%test . deepEqual ( asArray ( v ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) . find ( 0 , 0 ) ) ,  [ 200 , 200 ] ) ;%NWL%test . deepEqual ( asArray ( v ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) . find ( 600 , 0 ) ) ,  [ 500 , 250 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi ( points ) . find ( x , y , radius ) returns the closest site within radius " , function ( test )  {%NWL%var v = voronoi . voronoi ( ) ;%NWL%test . strictEqual ( v ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) . find ( 0 , 0 , 10 ) , null ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi ( points ) . find ( x , y , radius ) returns the closest site within radius " , function ( test )  {%NWL%var v = voronoi . voronoi ( ) ;%NWL%test . strictEqual ( v ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) . find ( 0 , 0 , 10 ) , null ) ;%NWL%test . deepEqual ( asArray ( v ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) . find ( 0 , 0 , 300 ) ) ,  [ 200 , 200 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi ( points ) . find ( x , y , 0 ) returns the site at the position [ x , y ] " , function ( test )  {%NWL%var v = voronoi . voronoi ( ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( asArray ( v ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) . find ( 0 , 0 , 300 ) ) ,  [ 200 , 200 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi ( points ) . find ( x , y , 0 ) returns the site at the position [ x , y ] " , function ( test )  {%NWL%var v = voronoi . voronoi ( ) ;%NWL%test . deepEqual ( asArray ( v ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) . find ( 200 , 200 , 0 ) ) ,  [ 200 , 200 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi ( points ) . find ( x , y ) handles coincident points " , function ( test )  {%NWL%var v = voronoi . voronoi ( ) ;%NWL%test . end ( ) ;%NWL%1
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ,%NWL%asArray = require ( " . / asArray " ) ,%NWL%polygonArea = require ( " . / polygonArea " ) ;%NWL%var infinity = 1e6 ,  / / For sufficiently small values of Infinity .%NWL%infinite = [ [ - infinity ,  - infinity ] ,  [ infinity , infinity ] ] ;%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%0
var infinity = 1e6 ,  / / For sufficiently small values of Infinity .%NWL%infinite = [ [ - infinity ,  - infinity ] ,  [ infinity , infinity ] ] ;%NWL%tape ( " voronoi ( ) has the expected defaults " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%test . equal ( voronoi . extent ( ) , null ) ;%NWL%test . equal ( voronoi . size ( ) , null ) ;%NWL%test . equal ( voronoi . x ( ) ( [ 1 , 2 ] ) , 1 ) ;%NWL%test . equal ( voronoi . y ( ) ( [ 1 , 2 ] ) , 2 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%3
[ [ 0 , 0 ] ,  [ 0 , 500 ] ,  [ 960 , 500 ] ,  [ 960 , 0 ] ]%NWL%] ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ] ) ) ,  [%NWL%[ [ 435 . 3571428571429 , 500 ] ,  [ 524 . 6428571428572 , 0 ] ,  [ 0 , 0 ] ,  [ 0 , 500 ] ] ,%NWL%[ [ 524 . 6428571428572 , 0 ] ,  [ 435 . 3571428571429 , 500 ] ,  [ 960 , 500 ] ,  [ 960 , 0 ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . size ( ) returns the width and height of the extent " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( [ [ 1 , 2 ] ,  [ 34 , 56 ] ] ) ;%NWL%test . end ( ) ;%NWL%6
[ [ 435 . 3571428571429 , 500 ] ,  [ 524 . 6428571428572 , 0 ] ,  [ 0 , 0 ] ,  [ 0 , 500 ] ] ,%NWL%[ [ 524 . 6428571428572 , 0 ] ,  [ 435 . 3571428571429 , 500 ] ,  [ 960 , 500 ] ,  [ 960 , 0 ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . size ( ) returns the width and height of the extent " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( [ [ 1 , 2 ] ,  [ 34 , 56 ] ] ) ;%NWL%test . deepEqual ( voronoi . size ( ) ,  [ 33 , 54 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%6
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . x ( x ) sets the specified x - accessor " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( infinite ) ;%NWL%test . equal ( voronoi . x ( function ( d )  { return d . x; } ) , voronoi ) ;%NWL%test . equal ( voronoi . x ( ) ( { x: 1 } ) , 1 ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ { x: 200 , 1: 200 } ,  { x: 760 , 1: 300 } ] ) ) ,  [%NWL%[ [ - 178046 . 78571428574 , infinity ] ,  [ 179096 . 07142857145 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 179096 . 07142857145 ,  - infinity ] ,  [ - 178046 . 78571428574 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%1
tape ( " voronoi . x ( x ) sets the specified x - accessor " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( infinite ) ;%NWL%test . equal ( voronoi . x ( function ( d )  { return d . x; } ) , voronoi ) ;%NWL%test . equal ( voronoi . x ( ) ( { x: 1 } ) , 1 ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ { x: 200 , 1: 200 } ,  { x: 760 , 1: 300 } ] ) ) ,  [%NWL%[ [ - 178046 . 78571428574 , infinity ] ,  [ 179096 . 07142857145 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 179096 . 07142857145 ,  - infinity ] ,  [ - 178046 . 78571428574 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var voronoi = d3 . voronoi ( ) . extent ( infinite ) ;%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . y ( y ) sets the specified y - accessor " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( infinite ) ;%NWL%test . equal ( voronoi . y ( function ( d )  { return d . y; } ) , voronoi ) ;%NWL%test . equal ( voronoi . y ( ) ( { y: 1 } ) , 1 ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ { 0: 200 , y: 200 } ,  { 0: 760 , y: 300 } ] ) ) ,  [%NWL%[ [ - 178046 . 78571428574 , infinity ] ,  [ 179096 . 07142857145 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 179096 . 07142857145 ,  - infinity ] ,  [ - 178046 . 78571428574 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . x ( x ) allows the specified x - accessor to be a constant " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( infinite ) . y ( function ( d )  { return d; } ) ;%NWL%test . equal ( voronoi . x ( 42 ) , voronoi ) ;%NWL%test . equal ( voronoi . x ( ) ( ) , 42 ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ 200 , 760 ] ) ) ,  [%NWL%[ [ - infinity , 480 ] ,  [ infinity , 480 ] ,  [ infinity ,  - infinity ] ,  [ - infinity ,  - infinity ] ] ,%NWL%[ [ infinity , 480 ] ,  [ - infinity , 480 ] ,  [ - infinity , infinity ] ,  [ infinity , infinity ] ]%NWL%test . end ( ) ;%NWL%1
test . equal ( voronoi . x ( ) ( ) , 42 ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ 200 , 760 ] ) ) ,  [%NWL%[ [ - infinity , 480 ] ,  [ infinity , 480 ] ,  [ infinity ,  - infinity ] ,  [ - infinity ,  - infinity ] ] ,%NWL%[ [ infinity , 480 ] ,  [ - infinity , 480 ] ,  [ - infinity , infinity ] ,  [ infinity , infinity ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . y ( y ) allows the specified y - accessor to be a constant " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( infinite ) . x ( function ( d )  { return d; } ) ;%NWL%test . equal ( voronoi . y ( 43 ) , voronoi ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ 200 , 760 ] ) ) ,  [%NWL%1
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . y ( y ) allows the specified y - accessor to be a constant " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( infinite ) . x ( function ( d )  { return d; } ) ;%NWL%test . equal ( voronoi . y ( 43 ) , voronoi ) ;%NWL%test . equal ( voronoi . y ( ) ( ) , 43 ) ;%NWL%test . deepEqual ( asArray ( voronoi . polygons ( [ 200 , 760 ] ) ) ,  [%NWL%[ [ 480 , infinity ] ,  [ 480 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 480 ,  - infinity ] ,  [ 480 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%1
test . deepEqual ( asArray ( voronoi . polygons ( [ 200 , 760 ] ) ) ,  [%NWL%[ [ 480 , infinity ] ,  [ 480 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 480 ,  - infinity ] ,  [ 480 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) returns an array of polygons for the specified points " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ] ) ) ,  [%NWL%[ [ - 178046 . 78571428574 , infinity ] ,  [ 179096 . 07142857145 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 179096 . 07142857145 ,  - infinity ] ,  [ - 178046 . 78571428574 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%4
[ [ - 178046 . 78571428574 , infinity ] ,  [ 179096 . 07142857145 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 179096 . 07142857145 ,  - infinity ] ,  [ - 178046 . 78571428574 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) returns open , counterclockwise polygons " , function ( test )  {%NWL%d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ 200 , 200 ] ,  [ 760 , 300 ] ] ) . forEach ( function ( cell )  {%NWL%test . ok ( cell . length > 2 ) ;%NWL%test . ok ( cell [ 0 ] [ 0 ] !== cell [ cell . length - 1 ] [ 0 ] || cell [ 0 ] [ 1 ] !== cell [ cell . length - 1 ] [ 1 ] ) ;%NWL%test . ok ( polygonArea ( cell ) > 0 ) ;%NWL%test . end ( ) ;%NWL%3
test . ok ( cell . length > 2 ) ;%NWL%test . ok ( cell [ 0 ] [ 0 ] !== cell [ cell . length - 1 ] [ 0 ] || cell [ 0 ] [ 1 ] !== cell [ cell . length - 1 ] [ 1 ] ) ;%NWL%test . ok ( polygonArea ( cell ) > 0 ) ;%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) returns polygons where polygons [ i ] . data is equal to points [ i ] " , function ( test )  {%NWL%var points = [ [ 200 , 200 ] ,  [ 760 , 300 ] ] ;%NWL%d3 . voronoi ( ) . extent ( infinite ) . polygons ( points ) . forEach ( function ( cell , i )  {%NWL%test . equal ( cell . data , points [ i ] ) ;%NWL%test . end ( ) ;%NWL%4
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) returns polygons where polygons [ i ] . data is equal to points [ i ] " , function ( test )  {%NWL%var points = [ [ 200 , 200 ] ,  [ 760 , 300 ] ] ;%NWL%d3 . voronoi ( ) . extent ( infinite ) . polygons ( points ) . forEach ( function ( cell , i )  {%NWL%test . equal ( cell . data , points [ i ] ) ;%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can handle no points " , function ( test )  {%NWL%test . end ( ) ;%NWL%0
test . equal ( cell . data , points [ i ] ) ;%NWL%} ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can handle no points " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . size ( [ 960 , 500 ] ) . polygons ( [ ] ) ) ,  [ ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) handles coincident points " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%test . end ( ) ;%NWL%2
var voronoi = d3 . voronoi ( ) ;%NWL%test . equal ( voronoi . polygons ( [ [ 0 , 0 ] ,  [ 0 , 0 ] ] ) [ 1 ] . length , 0 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can handle a single point " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . size ( [ 960 , 500 ] ) . polygons ( [ [ 100 , 100 ] ] ) ) ,  [%NWL%[ [ 0 , 0 ] ,  [ 0 , 500 ] ,  [ 960 , 500 ] ,  [ 960 , 0 ] ]%NWL%] ) ;%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . size ( [ 960 , 500 ] ) . polygons ( [ [ - 100 ,  - 100 ] ] ) ) ,  [%NWL%[ [ 0 , 0 ] ,  [ 0 , 500 ] ,  [ 960 , 500 ] ,  [ 960 , 0 ] ]%NWL%test . end ( ) ;%NWL%2
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can separate two points with a horizontal line " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ 0 ,  - 100 ] ,  [ 0 , 100 ] ] ) ) ,  [%NWL%[ [ - infinity , 0 ] ,  [ infinity , 0 ] ,  [ infinity ,  - infinity ] ,  [ - infinity ,  - infinity ] ] ,%NWL%[ [ infinity , 0 ] ,  [ - infinity , 0 ] ,  [ - infinity , infinity ] ,  [ infinity , infinity ] ]%NWL%] ) ;%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ 0 , 100 ] ,  [ 0 ,  - 100 ] ] ) ) ,  [%NWL%[ [ infinity , 0 ] ,  [ - infinity , 0 ] ,  [ - infinity , infinity ] ,  [ infinity , infinity ] ] ,%NWL%[ [ - infinity , 0 ] ,  [ infinity , 0 ] ,  [ infinity ,  - infinity ] ,  [ - infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can separate two points with a vertical line " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ 100 , 0 ] ,  [ - 100 , 0 ] ] ) ) ,  [%NWL%[ [ 0 ,  - infinity ] ,  [ 0 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ] ,%NWL%[ [ 0 , infinity ] ,  [ 0 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ]%NWL%] ) ;%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ - 100 , 0 ] ,  [ 100 , 0 ] ] ) ) ,  [%NWL%[ [ 0 , infinity ] ,  [ 0 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ 0 ,  - infinity ] ,  [ 0 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%0
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can separate two points with a diagonal line " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ - 100 ,  - 100 ] ,  [ 100 , 100 ] ] ) ) ,  [%NWL%[ [ - infinity , infinity ] ,  [ infinity ,  - infinity ] ,  [ - infinity ,  - infinity ] ] ,%NWL%[ [ infinity ,  - infinity ] ,  [ - infinity , infinity ] ,  [ infinity , infinity ] ]%NWL%] ) ;%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ 100 , 100 ] ,  [ - 100 ,  - 100 ] ] ) ) ,  [%NWL%[ [ infinity ,  - infinity ] ,  [ - infinity , infinity ] ,  [ infinity , infinity ] ] ,%NWL%[ [ - infinity , infinity ] ,  [ infinity ,  - infinity ] ,  [ - infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ 100 , 100 ] ,  [ - 100 ,  - 100 ] ] ) ) ,  [%NWL%[ [ infinity ,  - infinity ] ,  [ - infinity , infinity ] ,  [ infinity , infinity ] ] ,%NWL%[ [ - infinity , infinity ] ,  [ infinity ,  - infinity ] ,  [ - infinity ,  - infinity ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can separate two points with an arbitrary diagonal " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ - 100 ,  - 100 ] ,  [ 100 , 0 ] ] ) ) ,  [%NWL%[ [ - 500025 , infinity ] ,  [ 499975 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[  [ 499975 ,  - infinity ] ,  [ - 500025 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%test . end ( ) ;%NWL%4
[ [ - 500025 , infinity ] ,  [ 499975 ,  - infinity ] ,  [ - infinity ,  - infinity ] ,  [ - infinity , infinity ] ] ,%NWL%[  [ 499975 ,  - infinity ] ,  [ - 500025 , infinity ] ,  [ infinity , infinity ] ,  [ infinity ,  - infinity ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . polygons ( points ) can handle three collinear points " , function ( test )  {%NWL%test . deepEqual ( asArray ( d3 . voronoi ( ) . extent ( infinite ) . polygons ( [ [ - 100 ,  - 100 ] ,  [ 0 , 0 ] ,  [ 100 , 100 ] ] ) ) ,  [%NWL%[ [ - infinity , 999900 ] ,  [ 999900 ,  - infinity ] ,  [ - infinity ,  - infinity ] ] ,%NWL%[ [ - 999900 , infinity ] ,  [ infinity ,  - 999900 ] ,  [ infinity ,  - infinity ] ,  [ 999900 ,  - infinity ] ,  [ - infinity , 999900 ] ,  [ - infinity , infinity ] ] ,%NWL%[ [ infinity ,  - 999900 ] ,  [ - 999900 , infinity ] ,  [ infinity , infinity ] ]%NWL%test . end ( ) ;%NWL%3
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ;%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%0
var voronoi = d3 . voronoi ( ) ;%NWL%test . deepEqual ( voronoi . triangles ( [ [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) ,  [%NWL%[ [ 200 , 200 ] ,  [ 760 , 300 ] ,  [ 500 , 250 ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . triangles ( points ) observes the specified x - and y - accessors " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . x ( function ( d )  { return d . x; } ) . y ( function ( d )  { return d . y; } ) ;%NWL%test . deepEqual ( voronoi . triangles ( [ { x: 200 , y: 200 } ,  { x: 500 , y: 250 } ,  { x: 760 , y: 300 } ] ) ,  [%NWL%[ { x: 200 , y: 200 } ,  { x: 760 , y: 300 } ,  { x: 500 , y: 250 } ]%NWL%test . end ( ) ;%NWL%4
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . triangles ( points ) observes the specified x - and y - accessors " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . x ( function ( d )  { return d . x; } ) . y ( function ( d )  { return d . y; } ) ;%NWL%test . deepEqual ( voronoi . triangles ( [ { x: 200 , y: 200 } ,  { x: 500 , y: 250 } ,  { x: 760 , y: 300 } ] ) ,  [%NWL%[ { x: 200 , y: 200 } ,  { x: 760 , y: 300 } ,  { x: 500 , y: 250 } ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var voronoi = d3 . voronoi ( ) . extent ( [ [ 0 , 0 ] ,  [ 800 , 600 ] ] ) ;%NWL%4
var voronoi = d3 . voronoi ( ) . x ( function ( d )  { return d . x; } ) . y ( function ( d )  { return d . y; } ) ;%NWL%test . deepEqual ( voronoi . triangles ( [ { x: 200 , y: 200 } ,  { x: 500 , y: 250 } ,  { x: 760 , y: 300 } ] ) ,  [%NWL%[ { x: 200 , y: 200 } ,  { x: 760 , y: 300 } ,  { x: 500 , y: 250 } ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . extent ( extent ) . triangles ( points ) returns a limited triangulation " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( [ [ 0 , 0 ] ,  [ 800 , 600 ] ] ) ;%NWL%test . deepEqual ( voronoi . triangles ( [ [ 100 , 100 ] ,  [ 100 , 200 ] ,  [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) ,  [%NWL%[ [ 100 , 100 ] ,  [ 100 , 200 ] ,  [ 200 , 200 ] ]%NWL%test . end ( ) ;%NWL%4
] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . extent ( extent ) . triangles ( points ) returns a limited triangulation " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( [ [ 0 , 0 ] ,  [ 800 , 600 ] ] ) ;%NWL%test . deepEqual ( voronoi . triangles ( [ [ 100 , 100 ] ,  [ 100 , 200 ] ,  [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) ,  [%NWL%[ [ 100 , 100 ] ,  [ 100 , 200 ] ,  [ 200 , 200 ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%4
} ) ;%NWL%tape ( " voronoi . extent ( extent ) . triangles ( points ) returns a limited triangulation " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) . extent ( [ [ 0 , 0 ] ,  [ 800 , 600 ] ] ) ;%NWL%test . deepEqual ( voronoi . triangles ( [ [ 100 , 100 ] ,  [ 100 , 200 ] ,  [ 200 , 200 ] ,  [ 500 , 250 ] ,  [ 760 , 300 ] ] ) ,  [%NWL%[ [ 100 , 100 ] ,  [ 100 , 200 ] ,  [ 200 , 200 ] ]%NWL%] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " voronoi . triangles ( points ) handles coincident points " , function ( test )  {%NWL%var voronoi = d3 . voronoi ( ) ;%NWL%test . end ( ) ;%NWL%6
import { event } from " d3 - selection " ;%NWL%export function nopropagation ( )  {%NWL%event . stopImmediatePropagation ( ) ;%NWL%}%NWL%event . preventDefault ( ) ;%NWL%2
import { event } from " d3 - selection " ;%NWL%export function nopropagation ( )  {%NWL%event . stopImmediatePropagation ( ) ;%NWL%}%NWL%export default function ( )  {%NWL%event . stopImmediatePropagation ( ) ;%NWL%2
var tape = require ( " tape " ) ,%NWL%d3 = require ( " . . / " ) ,%NWL%identity = d3 . zoomIdentity;%NWL%tape ( " d3 . zoomIdentity transform contains k = 1 , x = y = 0 " , function ( test )  {%NWL%test . deepEqual ( toObject ( identity ) ,  { k: 1 , x: 0 , y: 0 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . scale ( k ) returns a new transform scaled with k " , function ( test )  {%NWL%var transform = identity . scale ( 2 . 5 ) ;%NWL%test . end ( ) ;%NWL%5
test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . scale ( k ) returns a new transform scaled with k " , function ( test )  {%NWL%var transform = identity . scale ( 2 . 5 ) ;%NWL%test . deepEqual ( toObject ( transform . scale ( 2 ) ) ,  { k: 5 , x: 0 , y: 0 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . translate ( x , y ) returns a new transform translated with x and y " , function ( test )  {%NWL%var transform = identity . translate ( 2 , 3 ) ;%NWL%test . deepEqual ( toObject ( transform . translate ( - 4 , 4 ) ) ,  { k: 1 , x: - 2 , y: 7 } ) ;%NWL%test . end ( ) ;%NWL%0
test . deepEqual ( toObject ( transform . scale ( 2 ) ) ,  { k: 5 , x: 0 , y: 0 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . translate ( x , y ) returns a new transform translated with x and y " , function ( test )  {%NWL%var transform = identity . translate ( 2 , 3 ) ;%NWL%test . deepEqual ( toObject ( transform . translate ( - 4 , 4 ) ) ,  { k: 1 , x: - 2 , y: 7 } ) ;%NWL%test . deepEqual ( toObject ( transform . scale ( 2 ) . translate ( - 4 , 4 ) ) ,  { k: 2 , x: - 6 , y: 11 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . apply ( [ x , y ] ) returns the transformation of the specified point " , function ( test )  {%NWL%test . end ( ) ;%NWL%1
var transform = identity . translate ( 2 , 3 ) ;%NWL%test . deepEqual ( toObject ( transform . translate ( - 4 , 4 ) ) ,  { k: 1 , x: - 2 , y: 7 } ) ;%NWL%test . deepEqual ( toObject ( transform . scale ( 2 ) . translate ( - 4 , 4 ) ) ,  { k: 2 , x: - 6 , y: 11 } ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . apply ( [ x , y ] ) returns the transformation of the specified point " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 3 ) . scale ( 2 ) . apply ( [ 4 , 5 ] ) ,  [ 10 , 13 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . applyX ( x ) returns the transformation of the specified x - coordinate " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " transform . apply ( [ x , y ] ) returns the transformation of the specified point " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 3 ) . scale ( 2 ) . apply ( [ 4 , 5 ] ) ,  [ 10 , 13 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . applyX ( x ) returns the transformation of the specified x - coordinate " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 0 ) . scale ( 2 ) . applyX ( 4 ) , 10 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . applyY ( y ) returns the transformation of the specified y - coordinate " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " transform . applyX ( x ) returns the transformation of the specified x - coordinate " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 0 ) . scale ( 2 ) . applyX ( 4 ) , 10 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . applyY ( y ) returns the transformation of the specified y - coordinate " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 0 , 3 ) . scale ( 2 ) . applyY ( 5 ) , 13 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . invert ( [ x , y ] ) returns the inverse transformation of the specified point " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " transform . applyY ( y ) returns the transformation of the specified y - coordinate " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 0 , 3 ) . scale ( 2 ) . applyY ( 5 ) , 13 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . invert ( [ x , y ] ) returns the inverse transformation of the specified point " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 3 ) . scale ( 2 ) . invert ( [ 4 , 5 ] ) ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . invertX ( x ) returns the inverse transformation of the specified x - coordinate " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " transform . invert ( [ x , y ] ) returns the inverse transformation of the specified point " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 3 ) . scale ( 2 ) . invert ( [ 4 , 5 ] ) ,  [ 1 , 1 ] ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . invertX ( x ) returns the inverse transformation of the specified x - coordinate " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 0 ) . scale ( 2 ) . invertX ( 4 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . invertY ( y ) returns the inverse transformation of the specified y - coordinate " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
} ) ;%NWL%tape ( " transform . invertX ( x ) returns the inverse transformation of the specified x - coordinate " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 2 , 0 ) . scale ( 2 ) . invertX ( 4 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . invertY ( y ) returns the inverse transformation of the specified y - coordinate " , function ( test )  {%NWL%test . deepEqual ( identity . translate ( 0 , 3 ) . scale ( 2 ) . invertY ( 5 ) , 1 ) ;%NWL%test . end ( ) ;%NWL%} ) ;%NWL%tape ( " transform . toString ( ) returns a string representing the SVG transform " , function ( test )  {%NWL%test . end ( ) ;%NWL%3
numbers = [ ] ;%NWL%if ( valueof == null )  {%NWL%while ( + + i < n )  {%NWL%if ( !isNaN ( value = number ( values [ i ] ) ) )  {%NWL%numbers . push ( value ) ;%NWL%}%NWL%}%NWL%}%NWL%else {%NWL%while ( + + i < n )  {%NWL%numbers . push ( value ) ;%NWL%4
var g = d3Selection . select ( this ) ;%NWL%var scale0 = this . __axis__ || scale ,%NWL%scale1 = this . __axis__ = scale . copy ( ) ;%NWL%var ticks = tickValues == null ? ( scale1 . ticks ? scale1 . ticks . apply ( scale1 , tickArguments ) : scale1 . domain ( ) ) : tickValues ,%NWL%format = tickFormat == null ? ( scale1 . tickFormat ? scale1 . tickFormat . apply ( scale1 , tickArguments ) : identity ) : tickFormat ,%NWL%tick = g . selectAll ( " . tick " ) . data ( ticks , scale1 ) ,%NWL%tickEnter = tick . enter ( ) . append ( " g " ,  " . domain " ) . attr ( " class " ,  " tick " ) . style ( " opacity " , epsilon ) ,%NWL%tickExit = tick . exit ( ) . style ( " opacity " , epsilon ) . remove ( ) ,  / / TODO transition%NWL%tickUpdate = tick . order ( ) . style ( " opacity " , 1 ) ,  / / TODO transition%NWL%tickSpacing = Math . max ( tickSizeInner , 0 )  + tickPadding ,%NWL%var range = scale1 . range ( ) ,%NWL%3
var BC_DA = B * C - D * A;%NWL%function cubehelix ( h , s , l )  {%NWL%if ( arguments . length === 1 )  {%NWL%if ( h instanceof Cubehelix )  {%NWL%l = h . l;%NWL%s = h . s;%NWL%h = h . h;%NWL%} else {%NWL%if ( ! ( h instanceof Rgb ) ) h = rgb ( h ) ;%NWL%var r = h . r / 255 , g = h . g / 255 , b = h . b / 255;%NWL%var bl = b - l , k = ( E *  ( g - l )  - C * bl )  / D;%NWL%9
if ( g = fragmentByStart [ endIndex ] )  {%NWL%delete fragmentByEnd [ f . end ] ;%NWL%delete fragmentByStart [ g . start ] ;%NWL%if ( f === g )  {%NWL%f . ring . push ( end ) ;%NWL%callback ( f . ring ) ;%NWL%} else {%NWL%fragmentByStart [ f . start ] = fragmentByEnd [ g . end ] = { start: f . start , end: g . end , ring: f . ring . concat ( g . ring ) } ;%NWL%}%NWL%} else {%NWL%f . ring . push ( end ) ;%NWL%4
}%NWL%} else {%NWL%delete fragmentByEnd [ f . end ] ;%NWL%f . ring . push ( end ) ;%NWL%fragmentByEnd [ f . end = endIndex ] = f;%NWL%}%NWL%} else if ( f = fragmentByStart [ endIndex ] )  {%NWL%if ( g = fragmentByEnd [ startIndex ] )  {%NWL%delete fragmentByStart [ f . start ] ;%NWL%delete fragmentByEnd [ g . end ] ;%NWL%f . ring . push ( end ) ;%NWL%3
( function ( global , factory )  {%NWL%typeof exports === ' object ' && typeof module !== ' undefined ' ? factory ( exports , require ( ' d3 - dispatch ' ) , require ( ' d3 - selection ' ) ) :%NWL%typeof define === ' function ' && define . amd ? define ( [ ' exports ' ,  ' d3 - dispatch ' ,  ' d3 - selection ' ] , factory ) :%NWL%( factory ( ( global . d3_drag = global . d3_drag || { } ) , global . d3_dispatch , global . d3_selection ) ) ;%NWL%} ( this , function ( exports , d3Dispatch , d3Selection )  {  ' use strict ' ;%NWL%var version = " 0 . 1 . 5 " ;%NWL%function nopropagation ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%}%NWL%function noevent ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%7
( function ( global , factory )  {%NWL%typeof exports === ' object ' && typeof module !== ' undefined ' ? factory ( exports , require ( ' d3 - dispatch ' ) , require ( ' d3 - selection ' ) ) :%NWL%typeof define === ' function ' && define . amd ? define ( [ ' exports ' ,  ' d3 - dispatch ' ,  ' d3 - selection ' ] , factory ) :%NWL%( factory ( ( global . d3_drag = global . d3_drag || { } ) , global . d3_dispatch , global . d3_selection ) ) ;%NWL%} ( this , function ( exports , d3Dispatch , d3Selection )  {  ' use strict ' ;%NWL%var version = " 0 . 2 . 2 " ;%NWL%function nopropagation ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%}%NWL%function noevent ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%7
( function ( global , factory )  {%NWL%typeof exports === ' object ' && typeof module !== ' undefined ' ? factory ( exports , require ( ' d3 - dispatch ' ) , require ( ' d3 - selection ' ) ) :%NWL%typeof define === ' function ' && define . amd ? define ( [ ' exports ' ,  ' d3 - dispatch ' ,  ' d3 - selection ' ] , factory ) :%NWL%( factory ( ( global . d3 = global . d3 || { } ) , global . d3 , global . d3 ) ) ;%NWL%} ( this , function ( exports , d3Dispatch , d3Selection )  {  ' use strict ' ;%NWL%function nopropagation ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%}%NWL%function noevent ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%6
( function ( global , factory )  {%NWL%typeof exports === ' object ' && typeof module !== ' undefined ' ? factory ( exports , require ( ' d3 - dispatch ' ) , require ( ' d3 - selection ' ) ) :%NWL%typeof define === ' function ' && define . amd ? define ( [ ' exports ' ,  ' d3 - dispatch ' ,  ' d3 - selection ' ] , factory ) :%NWL%( factory ( ( global . d3 = global . d3 || { } ) , global . d3 , global . d3 ) ) ;%NWL%} ( this ,  ( function ( exports , d3Dispatch , d3Selection )  {  ' use strict ' ;%NWL%function nopropagation ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%}%NWL%var noevent = function ( )  {%NWL%d3Selection . event . stopImmediatePropagation ( ) ;%NWL%6
stepper . restart ( step ) ;%NWL%return simulation;%NWL%}%NWL%function stop ( )  {%NWL%stepper . stop ( ) ;%NWL%return simulation;%NWL%}%NWL%function step ( )  {%NWL%var stop = tick ( ) ;%NWL%event . call ( " tick " , simulation ) ;%NWL%stepper . stop ( ) ;%NWL%4
stepper . restart ( step ) ;%NWL%return simulation;%NWL%}%NWL%function stop ( )  {%NWL%stepper . stop ( ) ;%NWL%return simulation;%NWL%}%NWL%function step ( )  {%NWL%var stop = tick ( ) ;%NWL%event . call ( " tick " , simulation ) ;%NWL%stepper . stop ( ) ;%NWL%4
if ( e . target . value== ' * ' )  {%NWL%charts . forEach ( function ( c ) {%NWL%chartFactory . charts [ c ] . data = chartFactory . data;%NWL%chartFactory . charts [ c ] . draw ( 500 ) ;%NWL%chartFactory . resetUIFilters ( ) ;%NWL%} ) ;%NWL%} else {%NWL%charts . forEach ( function ( c ) {%NWL%console . log ( c )%NWL%chartFactory . charts [ c ] . data =%NWL%chartFactory . charts [ c ] . draw ( 500 ) ;%NWL%3
stepper . restart ( step ) ;%NWL%return simulation;%NWL%}%NWL%function stop ( )  {%NWL%stepper . stop ( ) ;%NWL%return simulation;%NWL%}%NWL%function step ( )  {%NWL%var stop = tick ( ) ;%NWL%event . call ( " tick " , simulation ) ;%NWL%stepper . stop ( ) ;%NWL%4
stepper . restart ( step ) ;%NWL%return simulation;%NWL%}%NWL%function stop ( )  {%NWL%stepper . stop ( ) ;%NWL%return simulation;%NWL%}%NWL%function step ( )  {%NWL%var stop = tick ( ) ;%NWL%event . call ( " tick " , simulation ) ;%NWL%stepper . stop ( ) ;%NWL%4
node = nodes [ i ] ;%NWL%ri = radii [ i ] , ri2 = ri * ri;%NWL%xi = node . x + node . vx;%NWL%yi = node . y + node . vy;%NWL%tree . visit ( apply ) ;%NWL%}%NWL%}%NWL%function apply ( quad , x0 , y0 , x1 , y1 )  {%NWL%var data = quad . data , rj = quad . r , r = ri + rj;%NWL%if ( data )  {%NWL%var x = xi - data . x - data . vx ,%NWL%8
node = nodes [ i ] ;%NWL%ri = radii [ i ] , ri2 = ri * ri;%NWL%xi = node . x + node . vx;%NWL%yi = node . y + node . vy;%NWL%tree . visit ( apply ) ;%NWL%}%NWL%}%NWL%function apply ( quad , x0 , y0 , x1 , y1 )  {%NWL%var data = quad . data , rj = quad . r , r = ri + rj;%NWL%if ( data )  {%NWL%var x = xi - data . x - data . vx ,%NWL%8
node = nodes [ i ] ;%NWL%ri = radii [ node . index ] , ri2 = ri * ri;%NWL%xi = node . x + node . vx;%NWL%yi = node . y + node . vy;%NWL%tree . visit ( apply ) ;%NWL%}%NWL%}%NWL%function apply ( quad , x0 , y0 , x1 , y1 )  {%NWL%var data = quad . data , rj = quad . r , r = ri + rj;%NWL%if ( data )  {%NWL%var x = xi - data . x - data . vx ,%NWL%8
var options = L . setOptions ( this , options ) ;%NWL%this . _layout = d3 . hexbin ( ) . radius ( this . options . radius ) ;%NWL%this . _data = data;%NWL%this . _levels = { } ;%NWL%} ,%NWL%onAdd: function ( map )  {%NWL%this . _map = map;%NWL%this . _initContainer ( ) ;%NWL%map . on ( {%NWL%' moveend ' : this . _update%NWL%this . _update ( ) ;%NWL%7
attribution: ' <a href= " http: / / content . stamen . com / dotspotting_toner_cartography_available_for_download " >Stamen Toner< / a> , <a href= " http: / / www . openstreetmap . org / " >OpenStreetMap< / a> , <a href= " http: / / creativecommons . org / licenses / by - sa / 2 . 0 / " >CC - BY - SA< / a> ' ,%NWL%maxZoom: 17%NWL%} ) . addTo ( map ) ;%NWL%var svg = d3 . select ( map . getPanes ( ) . overlayPane ) . append ( " svg " ) ,%NWL%g = svg . append ( " g " ) . attr ( " class " ,  " leaflet - zoom - hide " ) ,%NWL%padding = 100 ,%NWL%color = d3 . scale . log ( )%NWL%. domain ( [ 5 , 7 , 15 , 30 ] )%NWL%. range ( [ " #d7191c " ,  " #ffffbf " ,  " #2c7bb6 " ] )%NWL%. interpolate ( d3 . interpolateHcl ) ;%NWL%var path = d3 . geo . path ( ) . projection ( project ) ,%NWL%3
" 9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2 "%NWL%) . map ( colors ) ;%NWL%var Spectral = ramp ( scheme$8 ) ;%NWL%var scheme$9 = new Array ( 3 ) . concat (%NWL%" e5f5f999d8c92ca25f " ,%NWL%" edf8fbb2e2e266c2a4238b45 " ,%NWL%" edf8fbb2e2e266c2a42ca25f006d2c " ,%NWL%" edf8fbccece699d8c966c2a42ca25f006d2c " ,%NWL%" edf8fbccece699d8c966c2a441ae76238b45005824 " ,%NWL%" f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824 " ,%NWL%) . map ( colors ) ;%NWL%1
" f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b "%NWL%) . map ( colors ) ;%NWL%var BuGn = ramp ( scheme$9 ) ;%NWL%var scheme$10 = new Array ( 3 ) . concat (%NWL%" e0ecf49ebcda8856a7 " ,%NWL%" edf8fbb3cde38c96c688419d " ,%NWL%" edf8fbb3cde38c96c68856a7810f7c " ,%NWL%" edf8fbbfd3e69ebcda8c96c68856a7810f7c " ,%NWL%" edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b " ,%NWL%" f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b " ,%NWL%) . map ( colors ) ;%NWL%1
" f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b "%NWL%) . map ( colors ) ;%NWL%var BuPu = ramp ( scheme$10 ) ;%NWL%var scheme$11 = new Array ( 3 ) . concat (%NWL%" e0f3dba8ddb543a2ca " ,%NWL%" f0f9e8bae4bc7bccc42b8cbe " ,%NWL%" f0f9e8bae4bc7bccc443a2ca0868ac " ,%NWL%" f0f9e8ccebc5a8ddb57bccc443a2ca0868ac " ,%NWL%" f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e " ,%NWL%" f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e " ,%NWL%) . map ( colors ) ;%NWL%1
" f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081 "%NWL%) . map ( colors ) ;%NWL%var GnBu = ramp ( scheme$11 ) ;%NWL%var scheme$12 = new Array ( 3 ) . concat (%NWL%" fee8c8fdbb84e34a33 " ,%NWL%" fef0d9fdcc8afc8d59d7301f " ,%NWL%" fef0d9fdcc8afc8d59e34a33b30000 " ,%NWL%" fef0d9fdd49efdbb84fc8d59e34a33b30000 " ,%NWL%" fef0d9fdd49efdbb84fc8d59ef6548d7301f990000 " ,%NWL%" fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000 " ,%NWL%) . map ( colors ) ;%NWL%1
" fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000 "%NWL%) . map ( colors ) ;%NWL%var OrRd = ramp ( scheme$12 ) ;%NWL%var scheme$13 = new Array ( 3 ) . concat (%NWL%" ece2f0a6bddb1c9099 " ,%NWL%" f6eff7bdc9e167a9cf02818a " ,%NWL%" f6eff7bdc9e167a9cf1c9099016c59 " ,%NWL%" f6eff7d0d1e6a6bddb67a9cf1c9099016c59 " ,%NWL%" f6eff7d0d1e6a6bddb67a9cf3690c002818a016450 " ,%NWL%" fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450 " ,%NWL%) . map ( colors ) ;%NWL%1
" fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636 "%NWL%) . map ( colors ) ;%NWL%var PuBuGn = ramp ( scheme$13 ) ;%NWL%var scheme$14 = new Array ( 3 ) . concat (%NWL%" ece7f2a6bddb2b8cbe " ,%NWL%" f1eef6bdc9e174a9cf0570b0 " ,%NWL%" f1eef6bdc9e174a9cf2b8cbe045a8d " ,%NWL%" f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d " ,%NWL%" f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b " ,%NWL%" fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b " ,%NWL%) . map ( colors ) ;%NWL%1
" fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858 "%NWL%) . map ( colors ) ;%NWL%var PuBu = ramp ( scheme$14 ) ;%NWL%var scheme$15 = new Array ( 3 ) . concat (%NWL%" e7e1efc994c7dd1c77 " ,%NWL%" f1eef6d7b5d8df65b0ce1256 " ,%NWL%" f1eef6d7b5d8df65b0dd1c77980043 " ,%NWL%" f1eef6d4b9dac994c7df65b0dd1c77980043 " ,%NWL%" f1eef6d4b9dac994c7df65b0e7298ace125691003f " ,%NWL%" f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f " ,%NWL%) . map ( colors ) ;%NWL%1
" f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f "%NWL%) . map ( colors ) ;%NWL%var PuRd = ramp ( scheme$15 ) ;%NWL%var scheme$16 = new Array ( 3 ) . concat (%NWL%" fde0ddfa9fb5c51b8a " ,%NWL%" feebe2fbb4b9f768a1ae017e " ,%NWL%" feebe2fbb4b9f768a1c51b8a7a0177 " ,%NWL%" feebe2fcc5c0fa9fb5f768a1c51b8a7a0177 " ,%NWL%" feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177 " ,%NWL%" fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177 " ,%NWL%) . map ( colors ) ;%NWL%1
" fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a "%NWL%) . map ( colors ) ;%NWL%var RdPu = ramp ( scheme$16 ) ;%NWL%var scheme$17 = new Array ( 3 ) . concat (%NWL%" edf8b17fcdbb2c7fb8 " ,%NWL%" ffffcca1dab441b6c4225ea8 " ,%NWL%" ffffcca1dab441b6c42c7fb8253494 " ,%NWL%" ffffccc7e9b47fcdbb41b6c42c7fb8253494 " ,%NWL%" ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84 " ,%NWL%" ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84 " ,%NWL%) . map ( colors ) ;%NWL%1
" ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58 "%NWL%) . map ( colors ) ;%NWL%var YlGnBu = ramp ( scheme$17 ) ;%NWL%var scheme$18 = new Array ( 3 ) . concat (%NWL%" f7fcb9addd8e31a354 " ,%NWL%" ffffccc2e69978c679238443 " ,%NWL%" ffffccc2e69978c67931a354006837 " ,%NWL%" ffffccd9f0a3addd8e78c67931a354006837 " ,%NWL%" ffffccd9f0a3addd8e78c67941ab5d238443005a32 " ,%NWL%" ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32 " ,%NWL%) . map ( colors ) ;%NWL%1
" ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529 "%NWL%) . map ( colors ) ;%NWL%var YlGn = ramp ( scheme$18 ) ;%NWL%var scheme$19 = new Array ( 3 ) . concat (%NWL%" fff7bcfec44fd95f0e " ,%NWL%" ffffd4fed98efe9929cc4c02 " ,%NWL%" ffffd4fed98efe9929d95f0e993404 " ,%NWL%" ffffd4fee391fec44ffe9929d95f0e993404 " ,%NWL%" ffffd4fee391fec44ffe9929ec7014cc4c028c2d04 " ,%NWL%" ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04 " ,%NWL%) . map ( colors ) ;%NWL%1
" ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506 "%NWL%) . map ( colors ) ;%NWL%var YlOrBr = ramp ( scheme$19 ) ;%NWL%var scheme$20 = new Array ( 3 ) . concat (%NWL%" ffeda0feb24cf03b20 " ,%NWL%" ffffb2fecc5cfd8d3ce31a1c " ,%NWL%" ffffb2fecc5cfd8d3cf03b20bd0026 " ,%NWL%" ffffb2fed976feb24cfd8d3cf03b20bd0026 " ,%NWL%" ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026 " ,%NWL%" ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026 " ,%NWL%) . map ( colors ) ;%NWL%1
" ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026 "%NWL%) . map ( colors ) ;%NWL%var YlOrRd = ramp ( scheme$20 ) ;%NWL%var scheme$21 = new Array ( 3 ) . concat (%NWL%" deebf79ecae13182bd " ,%NWL%" eff3ffbdd7e76baed62171b5 " ,%NWL%" eff3ffbdd7e76baed63182bd08519c " ,%NWL%" eff3ffc6dbef9ecae16baed63182bd08519c " ,%NWL%" eff3ffc6dbef9ecae16baed64292c62171b5084594 " ,%NWL%" f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594 " ,%NWL%) . map ( colors ) ;%NWL%1
" f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b "%NWL%) . map ( colors ) ;%NWL%var Blues = ramp ( scheme$21 ) ;%NWL%var scheme$22 = new Array ( 3 ) . concat (%NWL%" e5f5e0a1d99b31a354 " ,%NWL%" edf8e9bae4b374c476238b45 " ,%NWL%" edf8e9bae4b374c47631a354006d2c " ,%NWL%" edf8e9c7e9c0a1d99b74c47631a354006d2c " ,%NWL%" edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32 " ,%NWL%" f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32 " ,%NWL%) . map ( colors ) ;%NWL%1
" f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b "%NWL%) . map ( colors ) ;%NWL%var Greens = ramp ( scheme$22 ) ;%NWL%var scheme$23 = new Array ( 3 ) . concat (%NWL%" f0f0f0bdbdbd636363 " ,%NWL%" f7f7f7cccccc969696525252 " ,%NWL%" f7f7f7cccccc969696636363252525 " ,%NWL%" f7f7f7d9d9d9bdbdbd969696636363252525 " ,%NWL%" f7f7f7d9d9d9bdbdbd969696737373525252252525 " ,%NWL%" fffffff0f0f0d9d9d9bdbdbd969696737373525252252525 " ,%NWL%) . map ( colors ) ;%NWL%1
" fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000 "%NWL%) . map ( colors ) ;%NWL%var Greys = ramp ( scheme$23 ) ;%NWL%var scheme$24 = new Array ( 3 ) . concat (%NWL%" efedf5bcbddc756bb1 " ,%NWL%" f2f0f7cbc9e29e9ac86a51a3 " ,%NWL%" f2f0f7cbc9e29e9ac8756bb154278f " ,%NWL%" f2f0f7dadaebbcbddc9e9ac8756bb154278f " ,%NWL%" f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486 " ,%NWL%" fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486 " ,%NWL%) . map ( colors ) ;%NWL%1
" fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d "%NWL%) . map ( colors ) ;%NWL%var Purples = ramp ( scheme$24 ) ;%NWL%var scheme$25 = new Array ( 3 ) . concat (%NWL%" fee0d2fc9272de2d26 " ,%NWL%" fee5d9fcae91fb6a4acb181d " ,%NWL%" fee5d9fcae91fb6a4ade2d26a50f15 " ,%NWL%" fee5d9fcbba1fc9272fb6a4ade2d26a50f15 " ,%NWL%" fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d " ,%NWL%" fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d " ,%NWL%) . map ( colors ) ;%NWL%1
" fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d "%NWL%) . map ( colors ) ;%NWL%var Reds = ramp ( scheme$25 ) ;%NWL%var scheme$26 = new Array ( 3 ) . concat (%NWL%" fee6cefdae6be6550d " ,%NWL%" feeddefdbe85fd8d3cd94701 " ,%NWL%" feeddefdbe85fd8d3ce6550da63603 " ,%NWL%" feeddefdd0a2fdae6bfd8d3ce6550da63603 " ,%NWL%" feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04 " ,%NWL%" fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04 " ,%NWL%) . map ( colors ) ;%NWL%1
g3 . canvas = function ( plot , data ) {%NWL%return new canvas ( plot , data ) ;%NWL%}%NWL%var canvas = function canvas ( plot , data ) {%NWL%if ( !data || !$ . isArray ( data ) ) { return ' Param: data is missing , An array required ' ; }%NWL%if ( !plot ) { return ' Param: plot is missing , a div to attach the svg is required ' ; }%NWL%this . _data = data;%NWL%var padding = $ ( this . _plot . _elem ) . css ( ' padding - left ' ) ;%NWL%3
canvas . prototype . draw = function ( ) {%NWL%this . _context = this . _canvas . node ( ) . getContext ( ' 2d ' ) ;%NWL%this . drawImage ( ) ;%NWL%return this;%NWL%} ;%NWL%canvas . prototype . reDraw = function ( data ) {%NWL%this . _context . clearRect ( 0 , 0 , this . _data [ 0 ] . length , this . _data [ 0 ] [ 0 ] . length ) ;%NWL%this . _canvas%NWL%. attr ( ' width ' , data [ 0 ] . length )%NWL%. attr ( ' height ' , data [ 0 ] [ 0 ] . length ) ;%NWL%this . drawImage ( ) ;%NWL%2
function localDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%var date = new Date ( - 1 , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%date . setFullYear ( d . y ) ;%NWL%return date;%NWL%}%NWL%return new Date ( d . y , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%}%NWL%function utcDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%date . setUTCFullYear ( d . y ) ;%NWL%3
if ( ! ( date instanceof Date ) ) date = new Date ( + date ) ;%NWL%while ( + + i < n )  {%NWL%if ( specifier . charCodeAt ( i ) === 37 )  {%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%if ( ( pad = pads [ c = specifier . charAt ( + + i ) ] ) != null ) c = specifier . charAt ( + + i ) ;%NWL%else pad = c === " e " ? "  " : " 0 " ;%NWL%if ( format = formats [ c ] ) c = format ( date , pad ) ;%NWL%string . push ( c ) ;%NWL%j = i + 1;%NWL%}%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%3
var d = newYear ( 1900 ) ,%NWL%i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%d . H + = d . Z / 100 | 0;%NWL%8
i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%if ( " Z " in d )  {%NWL%d . M + = d . Z % 100;%NWL%7
function localDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%var date = new Date ( - 1 , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%date . setFullYear ( d . y ) ;%NWL%return date;%NWL%}%NWL%return new Date ( d . y , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%}%NWL%function utcDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%date . setUTCFullYear ( d . y ) ;%NWL%3
if ( ! ( date instanceof Date ) ) date = new Date ( + date ) ;%NWL%while ( + + i < n )  {%NWL%if ( specifier . charCodeAt ( i ) === 37 )  {%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%if ( ( pad = pads [ c = specifier . charAt ( + + i ) ] ) != null ) c = specifier . charAt ( + + i ) ;%NWL%else pad = c === " e " ? "  " : " 0 " ;%NWL%if ( format = formats [ c ] ) c = format ( date , pad ) ;%NWL%string . push ( c ) ;%NWL%j = i + 1;%NWL%}%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%3
var d = newYear ( 1900 ) ,%NWL%i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%d . H + = d . Z / 100 | 0;%NWL%8
i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%if ( " Z " in d )  {%NWL%d . M + = d . Z % 100;%NWL%7
return pad ( d . getUTCFullYear ( ) % 10000 , p , 4 ) ;%NWL%}%NWL%function formatUTCZone ( )  {%NWL%return " + 0000 " ;%NWL%}%NWL%function formatLiteralPercent ( )  {%NWL%return " % " ;%NWL%}%NWL%var locale;%NWL%exports . timeFormat;%NWL%exports . utcFormat;%NWL%9
}%NWL%function formatUTCZone ( )  {%NWL%return " + 0000 " ;%NWL%}%NWL%function formatLiteralPercent ( )  {%NWL%return " % " ;%NWL%}%NWL%var locale;%NWL%exports . timeFormat;%NWL%exports . timeParse;%NWL%exports . utcParse;%NWL%8
function localDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%var date = new Date ( - 1 , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%date . setFullYear ( d . y ) ;%NWL%return date;%NWL%}%NWL%return new Date ( d . y , d . m , d . d , d . H , d . M , d . S , d . L ) ;%NWL%}%NWL%function utcDate ( d )  {%NWL%if ( 0 <= d . y && d . y < 100 )  {%NWL%date . setUTCFullYear ( d . y ) ;%NWL%3
if ( ! ( date instanceof Date ) ) date = new Date ( + date ) ;%NWL%while ( + + i < n )  {%NWL%if ( specifier . charCodeAt ( i ) === 37 )  {%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%if ( ( pad = pads [ c = specifier . charAt ( + + i ) ] ) != null ) c = specifier . charAt ( + + i ) ;%NWL%else pad = c === " e " ? "  " : " 0 " ;%NWL%if ( format = formats [ c ] ) c = format ( date , pad ) ;%NWL%string . push ( c ) ;%NWL%j = i + 1;%NWL%}%NWL%string . push ( specifier . slice ( j , i ) ) ;%NWL%3
var d = newYear ( 1900 ) ,%NWL%i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%d . H + = d . Z / 100 | 0;%NWL%8
i = parseSpecifier ( d , specifier , string + = " " , 0 ) ;%NWL%if ( i != string . length ) return null;%NWL%if ( " p " in d ) d . H = d . H % 12 + d . p * 12;%NWL%if ( " W " in d || " U " in d )  {%NWL%if ( ! ( " w " in d ) ) d . w = " W " in d ? 1 : 0;%NWL%var day = " Z " in d ? utcDate ( newYear ( d . y ) ) . getUTCDay ( ) : newDate ( newYear ( d . y ) ) . getDay ( ) ;%NWL%d . m = 0;%NWL%d . d = " W " in d ? ( d . w + 6 ) % 7 + d . W * 7 -  ( day + 5 ) % 7 : d . w + d . U * 7 -  ( day + 6 ) % 7;%NWL%}%NWL%if ( " Z " in d )  {%NWL%d . M + = d . Z % 100;%NWL%7
log . prototype . draw = function ( ) {%NWL%var lineFunc = this . lineFunc ( ) ;%NWL%this . _svg = this . _plot . _svg . append ( ' path ' )%NWL%. datum ( this . _data )%NWL%. attr ( ' d ' , lineFunc )%NWL%. attr ( ' stroke ' , this . _color )%NWL%. attr ( ' stroke - width ' , this . _strokeWidth )%NWL%. attr ( ' fill ' ,  ' none ' ) ;%NWL%return this;%NWL%} ;%NWL%var lineFunc = this . lineFunc ( ) ;%NWL%1
var day = newInterval ( function ( date )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setDate ( date . getDate ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return ( end - start -  ( end . getTimezoneOffset ( )  - start . getTimezoneOffset ( ) )  * 6e4 )  / 864e5;%NWL%} , function ( date )  {%NWL%return date . getDate ( )  - 1;%NWL%} ) ;%NWL%function weekday ( i )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
var month = newInterval ( function ( date )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%date . setDate ( 1 ) ;%NWL%} , function ( date , step )  {%NWL%date . setMonth ( date . getMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getMonth ( )  - start . getMonth ( )  +  ( end . getFullYear ( )  - start . getFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getMonth ( ) ;%NWL%} ) ;%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
var utcDay = newInterval ( function ( date )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setUTCDate ( date . getUTCDate ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return ( end - start )  / 864e5;%NWL%} , function ( date )  {%NWL%return date . getUTCDate ( )  - 1;%NWL%} ) ;%NWL%function utcWeekday ( i )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
var utcMonth = newInterval ( function ( date )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%date . setUTCDate ( 1 ) ;%NWL%} , function ( date , step )  {%NWL%date . setUTCMonth ( date . getUTCMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getUTCMonth ( )  - start . getUTCMonth ( )  +  ( end . getUTCFullYear ( )  - start . getUTCFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getUTCMonth ( ) ;%NWL%} ) ;%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
var day$1 = newInterval ( function ( date )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setDate ( date . getDate ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return ( end - start -  ( end . getTimezoneOffset ( )  - start . getTimezoneOffset ( ) )  * minute )  / day;%NWL%} , function ( date )  {%NWL%return date . getDate ( )  - 1;%NWL%} ) ;%NWL%function weekday ( i )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
var month = newInterval ( function ( date )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%date . setDate ( 1 ) ;%NWL%} , function ( date , step )  {%NWL%date . setMonth ( date . getMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getMonth ( )  - start . getMonth ( )  +  ( end . getFullYear ( )  - start . getFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getMonth ( ) ;%NWL%} ) ;%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
var utcDay = newInterval ( function ( date )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setUTCDate ( date . getUTCDate ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return ( end - start )  / day;%NWL%} , function ( date )  {%NWL%return date . getUTCDate ( )  - 1;%NWL%} ) ;%NWL%function utcWeekday ( i )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
var utcMonth = newInterval ( function ( date )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%date . setUTCDate ( 1 ) ;%NWL%} , function ( date , step )  {%NWL%date . setUTCMonth ( date . getUTCMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getUTCMonth ( )  - start . getUTCMonth ( )  +  ( end . getUTCFullYear ( )  - start . getUTCFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getUTCMonth ( ) ;%NWL%} ) ;%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%1
date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setMonth ( date . getMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getMonth ( )  - start . getMonth ( )  +  ( end . getFullYear ( )  - start . getFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getMonth ( ) ;%NWL%} ) ;%NWL%var months = month . range;%NWL%var year = newInterval ( function ( date )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%0
date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setUTCMonth ( date . getUTCMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getUTCMonth ( )  - start . getUTCMonth ( )  +  ( end . getUTCFullYear ( )  - start . getUTCFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getUTCMonth ( ) ;%NWL%} ) ;%NWL%var utcMonths = utcMonth . range;%NWL%var utcYear = newInterval ( function ( date )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%0
date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setMonth ( date . getMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getMonth ( )  - start . getMonth ( )  +  ( end . getFullYear ( )  - start . getFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getMonth ( ) ;%NWL%} ) ;%NWL%var months = month . range;%NWL%var year = newInterval ( function ( date )  {%NWL%date . setHours ( 0 , 0 , 0 , 0 ) ;%NWL%0
date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%} , function ( date , step )  {%NWL%date . setUTCMonth ( date . getUTCMonth ( )  + step ) ;%NWL%} , function ( start , end )  {%NWL%return end . getUTCMonth ( )  - start . getUTCMonth ( )  +  ( end . getUTCFullYear ( )  - start . getUTCFullYear ( ) )  * 12;%NWL%} , function ( date )  {%NWL%return date . getUTCMonth ( ) ;%NWL%} ) ;%NWL%var utcMonths = utcMonth . range;%NWL%var utcYear = newInterval ( function ( date )  {%NWL%date . setUTCHours ( 0 , 0 , 0 , 0 ) ;%NWL%0
plot . prototype . setAxis = function ( ) {%NWL%if ( this . _xAxisVisible ) {%NWL%this . _xAxis = this . createAxis ( this . _xScale ,  - this . _height , this . _xOrient , this . _xTicks ) ;%NWL%this . _xAxis . tickFormat ( this . _xTickFormat ) ;%NWL%this . _svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' x axis ' )%NWL%. call ( this . _xAxis ) ;%NWL%}%NWL%if ( this . _yAxisVisible ) {%NWL%this . _yAxis = this . createAxis ( this . _yScale ,  - this . _width , this . _yOrient , this . _yTicks ) ;%NWL%this . _svg . append ( ' g ' )%NWL%4
}%NWL%if ( this . _yAxisVisible ) {%NWL%this . _yAxis = this . createAxis ( this . _yScale ,  - this . _width , this . _yOrient , this . _yTicks ) ;%NWL%this . _yAxis . tickFormat ( this . _yTickFormat ) ;%NWL%this . _svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' y axis ' )%NWL%. call ( this . _yAxis ) ;%NWL%}%NWL%if ( this . _x2AxisVisible ) {%NWL%this . _x2Axis = this . createAxis ( this . _x2Scale ,  - this . _height , this . _x2Orient , this . _x2Ticks ) ;%NWL%this . _svg . append ( ' g ' )%NWL%4
if ( this . _x2AxisVisible ) {%NWL%this . _x2Axis = this . createAxis ( this . _x2Scale ,  - this . _height , this . _x2Orient , this . _x2Ticks ) ;%NWL%this . _x2Axis . tickFormat ( this . _x2TickFormat ) ;%NWL%this . _svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' x2 axis ' )%NWL%. attr ( " transform " ,  " translate ( "  +  " 0 , "  + this . _height +  " ) " )%NWL%. call ( this . _x2Axis ) ;%NWL%}%NWL%if ( this . _y2AxisVisible ) {%NWL%this . _y2Axis = this . createAxis ( this . _y2Scale ,  - this . _width , this . _y2Orient , this . _y2Ticks ) ;%NWL%this . _svg . append ( ' g ' )%NWL%3
. attr ( " transform " ,  " translate ( "  +  " 0 , "  + this . _height +  " ) " )%NWL%. attr ( " y " , yMargin )%NWL%. attr ( " dy " ,  " 1em " )%NWL%. style ( " text - anchor " ,  " end " )%NWL%. style ( " font - size " , 12 )%NWL%. text ( this . _y2Title ) ;%NWL%}%NWL%} ;%NWL%plot . prototype . draw = function ( )  {%NWL%this . setScales ( ) ;%NWL%this . setAxis ( ) ;%NWL%9
. attr ( " y " , yMargin )%NWL%. attr ( " dy " ,  " 1em " )%NWL%. style ( " text - anchor " ,  " end " )%NWL%. style ( " font - size " , 12 )%NWL%. text ( this . _y2Title ) ;%NWL%}%NWL%} ;%NWL%plot . prototype . draw = function ( )  {%NWL%this . setScales ( ) ;%NWL%this . _svg = this . createSVG ( ) ;%NWL%this . setTitles ( ) ;%NWL%8
xTrans = this . _xTrans ,%NWL%sampleRate = this . _sampleRate;%NWL%var offset = this . _offsets === undefined ? xTrans * k : this . _offsets [ k ] ;%NWL%this . _plot . _svg . append ( ' path ' )%NWL%. attr ( ' id ' ,  ' area - below '  + k )%NWL%. attr ( ' clip - path ' ,  ' url ( #clip - below '  + this . _rand + k )%NWL%. attr ( ' fill ' , this . _fillColor )%NWL%. style ( ' opacity ' , this . _opacity )%NWL%. attr ( ' d ' , area . x0 ( function ( d , i ) {%NWL%return plot . _xScale ( d * xMult + offset ) ; / /  * sampleRate ) ;%NWL%this . _plot . _svg . append ( ' path ' )%NWL%3
var py = y . call ( hexbin , point , i )  / dy , pj = Math . round ( py ) ,%NWL%px = x . call ( hexbin , point , i )  / dx -  ( pj & 1 ? . 5 : 0 ) , pi = Math . round ( px ) ,%NWL%py1 = py - pj;%NWL%if ( Math . abs ( py1 )  * 3 > 1 )  {%NWL%var px1 = px - pi ,%NWL%pi2 = pi +  ( px < pi ? - 1 : 1 )  / 2 ,%NWL%pj2 = pj +  ( py < pj ? - 1 : 1 ) ,%NWL%px2 = px - pi2 ,%NWL%py2 = py - pj2;%NWL%if ( px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2 ) pi = pi2 +  ( pj & 1 ? 1 : - 1 )  / 2 , pj = pj2;%NWL%var id = pi +  " - "  + pj , bin = binsById [ id ] ;%NWL%0
( function ( factory )  {%NWL%if ( typeof define === ' function ' && define . amd )  { define ( [ ' backbone ' ,  ' d3 ' ] , factory ) ;%NWL%} else if ( typeof exports === ' object ' )  { module . exports = factory ( require ( ' backbone ' ) , require ( ' d3 ' ) ) ;%NWL%} else { factory ( Backbone , d3 ) ; }%NWL%} ( function ( Backbone , d3 )  {%NWL%var paddedLt = / ^\s * < / ;%NWL%var ElementProto = ( typeof Element !== ' undefined ' && Element . prototype ) || { } ;%NWL%var matchesSelector = ElementProto . matches ||%NWL%ElementProto . webkitMatchesSelector ||%NWL%ElementProto . msMatchesSelector ||%NWL%8
return ns ?%NWL%document . createElementNS ( ns , tagName ) :%NWL%document . createElement ( tagName ) ;%NWL%} ,%NWL%_setElement: function ( element )  {%NWL%if ( typeof element == ' string ' )  {%NWL%if ( paddedLt . test ( element ) )  {%NWL%var el = document . createElement ( ' div ' ) ;%NWL%el . innerHTML = element;%NWL%this . el = el . firstChild;%NWL%this . el = document . querySelector ( element ) ;%NWL%9
if ( typeof element == ' string ' )  {%NWL%if ( paddedLt . test ( element ) )  {%NWL%var el = document . createElement ( ' div ' ) ;%NWL%el . innerHTML = element;%NWL%this . el = el . firstChild;%NWL%} else {%NWL%this . el = document . querySelector ( element ) ;%NWL%}%NWL%} else {%NWL%this . el = element;%NWL%this . d3el = d3 . select ( this . el ) ;%NWL%4
var node = event . target ,%NWL%idx = 0 ,%NWL%o = d3 . event;%NWL%d3 . event = event;%NWL%if ( !selector )  {%NWL%listener . call ( view , d3 . event , node . __data__ , idx + + ) ;%NWL%d3 . event = o;%NWL%return;%NWL%}%NWL%while ( node && node !== view . el )  {%NWL%listener . call ( view , d3 . event , node . __data__ , idx + + ) ;%NWL%5
var expect = require ( " chai " ) . expect ,%NWL%_ = require ( ' underscore ' ) ,%NWL%Backbone = require ( ' backbone ' ) ,%NWL%D3View = require ( ' . . / backbone . d3view ' ) ;%NWL%describe ( ' Backbone . D3View ' , function ( )  {%NWL%it ( ' exports as Backbone . D3View ' , function ( )  {%NWL%expect ( D3View ) . to . equal ( Backbone . D3View ) ;%NWL%} ) ;%NWL%var View = Backbone . View . extend ( Backbone . D3ViewMixin ) ;%NWL%0
equal ( view . el . other , void 0 ) ;%NWL%} ) ;%NWL%test ( " $ " , 2 , function ( )  {%NWL%var view = new Backbone . View;%NWL%view . setElement ( ' <p><a><b>test< / b>< / a>< / p> ' ) ;%NWL%var result = view . $ ( ' a b ' ) ;%NWL%strictEqual ( result [ 0 ] . innerHTML ,  ' test ' ) ;%NWL%ok ( result . length === + result . length ) ;%NWL%} ) ;%NWL%test ( " $el " , function ( )  {%NWL%view . setElement ( ' <p><a><b>test< / b>< / a>< / p> ' ) ;%NWL%4
var view = new Backbone . View ( { el: ' #testElement ' } ) ;%NWL%view . increment = function ( ) { counter1 + + ; } ;%NWL%addEventListener . call ( view . el ,  ' click ' , function ( ) { counter2 + + ; } ) ;%NWL%var events = { ' click h1 ' : ' increment ' } ;%NWL%view . delegateEvents ( events ) ;%NWL%click ( view . $ ( ' h1 ' ) [ 0 ] ) ;%NWL%equal ( counter1 , 1 ) ;%NWL%equal ( counter2 , 1 ) ;%NWL%click ( view . $ ( ' h1 ' ) [ 0 ] ) ;%NWL%equal ( counter1 , 2 ) ;%NWL%view . delegateEvents ( events ) ;%NWL%4
var events = {%NWL%click: function ( )  {%NWL%this . counter + + ;%NWL%}%NWL%} ;%NWL%document . body . appendChild ( view . el ) ;%NWL%view . delegateEvents ( events ) ;%NWL%click ( view . el ) ;%NWL%equal ( view . counter , 1 ) ;%NWL%click ( view . el ) ;%NWL%view . delegateEvents ( events ) ;%NWL%6
equal ( view . counter , 2 ) ;%NWL%view . delegateEvents ( events ) ;%NWL%click ( view . el ) ;%NWL%equal ( view . counter , 3 ) ;%NWL%document . body . removeChild ( view . el ) ;%NWL%} ) ;%NWL%test ( " delegateEvents ignore undefined methods " , 0 , function ( )  {%NWL%var view = new Backbone . View ( { el: ' <p>< / p> ' } ) ;%NWL%document . body . appendChild ( view . el ) ;%NWL%view . delegateEvents ( { ' click ' : ' undefinedMethod ' } ) ;%NWL%document . body . removeChild ( view . el ) ;%NWL%4
view . increment = function ( ) { counter1 + + ; } ;%NWL%addEventListener . call ( view . el ,  ' click ' , function ( ) { counter2 + + ; } ) ;%NWL%var events = { ' click h1 ' : ' increment ' } ;%NWL%view . delegateEvents ( events ) ;%NWL%click ( view . $ ( ' h1 ' ) [ 0 ] ) ;%NWL%equal ( counter1 , 1 ) ;%NWL%equal ( counter2 , 1 ) ;%NWL%view . undelegateEvents ( ) ;%NWL%click ( view . $ ( ' h1 ' ) [ 0 ] ) ;%NWL%equal ( counter1 , 1 ) ;%NWL%view . delegateEvents ( events ) ;%NWL%3
view . delegate ( ' click ' , function ( )  { ok ( false ) ; } ) ;%NWL%view . delegate ( ' click ' ,  ' h1 ' , function ( )  { ok ( false ) ; } ) ;%NWL%view . undelegate ( ' click ' ) ;%NWL%click ( view . $ ( ' h1 ' ) [ 0 ] ) ;%NWL%click ( view . el ) ;%NWL%} ) ;%NWL%test ( " undelegate with passed handler " , 1 , function ( )  {%NWL%var view = new Backbone . View ( { el: ' #testElement ' } ) ;%NWL%var listener = function ( )  { ok ( false ) ; } ;%NWL%view . delegate ( ' click ' , listener ) ;%NWL%view . undelegate ( ' click ' , listener ) ;%NWL%9
}%NWL%}%NWL%} ;%NWL%page . open ( url , function ( status )  {%NWL%if ( status !== ' success ' )  {%NWL%console . error ( ' Unable to access network: '  + status ) ;%NWL%phantom . exit ( 1 ) ;%NWL%} else {%NWL%var qunitMissing = page . evaluate ( function ( )  { return ( typeof QUnit === ' undefined ' || !QUnit ) ; } ) ;%NWL%if ( qunitMissing )  {%NWL%phantom . exit ( 1 ) ;%NWL%6
polygonType = ' polyline ' ;%NWL%}%NWL%polygon . enter ( ) . append ( polygonType )%NWL%. classed ( { area: 1 ,  ' d3 - enter ' : 1 } )%NWL%. on ( ' mouseover ' , function ( dd ) {%NWL%d3 . event . stopPropagation ( ) ;%NWL%container . classed ( ' focus ' , 1 ) ;%NWL%d3 . select ( this ) . classed ( ' focused ' , 1 ) ;%NWL%setTooltip ( tooltip , cfg . tooltipFormatClass ( dd . className ) ) ;%NWL%} )%NWL%d3 . event . stopPropagation ( ) ;%NWL%5
} ) ;%NWL%var circle = circleGroups . selectAll ( ' . circle ' ) . data ( function ( datum , i )  {%NWL%return datum . axes . map ( function ( d )  { return [ d , i ] ; } ) ;%NWL%} ) ;%NWL%circle . enter ( ) . append ( ' circle ' )%NWL%. classed ( { circle: 1 ,  ' d3 - enter ' : 1 } )%NWL%. on ( ' mouseover ' , function ( dd ) {%NWL%d3 . event . stopPropagation ( ) ;%NWL%setTooltip ( tooltip , cfg . tooltipFormatValue ( dd [ 0 ] . value ) ) ;%NWL%} )%NWL%d3 . event . stopPropagation ( ) ;%NWL%7
}%NWL%let document = jsDom . jsdom ( )%NWL%if ( options . container )  {%NWL%document = jsDom . jsdom ( options . container )%NWL%}%NWL%let d3Element = options . d3Module . select ( document . body )%NWL%if ( options . selector )  {%NWL%d3Element = d3Element . select ( options . selector )%NWL%}%NWL%this . options = options%NWL%this . window = document . defaultView%NWL%9
if ( options . container )  {%NWL%document = jsDom . jsdom ( options . container )%NWL%}%NWL%let d3Element = options . d3Module . select ( document . body )%NWL%if ( options . selector )  {%NWL%d3Element = d3Element . select ( options . selector )%NWL%}%NWL%this . options = options%NWL%this . document = document%NWL%this . window = document . defaultView%NWL%this . d3 = options . d3Module%NWL%7
const topojson = require ( ' topojson ' ) ;%NWL%const topo = require ( ' . / data / congress . json ' ) ; / / source: https: / / github . com / bradoyler / atlas - make / tree / master / us - states%NWL%const d3 = require ( ' d3 ' ) ;%NWL%0
const topojson = require ( ' topojson ' ) ;%NWL%const topo = require ( ' . / data / va - counties . json ' ) ;%NWL%const d3 = require ( ' d3 - legacy ' ) ;%NWL%0
. projection ( projection ) ;%NWL%var svg = d3n . createSVG ( width , height ) ;%NWL%var state = topojson . feature ( topo , topo . objects . states ) ,%NWL%bounds = path . bounds ( state ) ;%NWL%projection%NWL%. translate ( [ width / 2 -  ( bounds [ 0 ] [ 0 ]  + bounds [ 1 ] [ 0 ] )  / 2 , height / 2 -  ( bounds [ 0 ] [ 1 ]  + bounds [ 1 ] [ 1 ] )  / 2 ] ) ;%NWL%svg . append ( " path " )%NWL%. datum ( state )%NWL%. attr ( " class " ,  " state " )%NWL%. attr ( " d " , path )%NWL%svg . append ( " path " )%NWL%6
const topojson = require ( ' topojson ' ) ;%NWL%const us = require ( ' . / data / us - states . json ' ) ;%NWL%const d3 = require ( ' d3 ' ) ;%NWL%0
const topojson = require ( ' topojson ' ) ;%NWL%const us = require ( ' . / data / us - states . json ' ) ; / / source: https: / / github . com / bradoyler / atlas - make / tree / master / us - states%NWL%const d3 = require ( ' d3 - legacy ' ) ;%NWL%0
const fs = require ( ' fs ' ) ;%NWL%const csvString = fs . readFileSync ( ' examples / data / piechart . csv ' ,  ' UTF - 8 ' ) . toString ( ) ;%NWL%const d3 = require ( ' d3 ' ) ;%NWL%0
const D3Node = require ( ' . / . . / index ' ) ;%NWL%const d3 = require ( ' d3 ' ) ;%NWL%const canvasModule = require ( ' canvas ' ) ;%NWL%var options = { canvasModule } ;%NWL%var d3n = new D3Node ( options ) ;%NWL%var canvas = d3n . createCanvas ( 960 , 500 ) ;%NWL%var context = canvas . getContext ( ' 2d ' ) ;%NWL%var width = canvas . width ,%NWL%height = canvas . height ,%NWL%radius = Math . min ( width , height )  / 2;%NWL%var arc = d3 . arc ( )%NWL%7
height = canvas . height ,%NWL%radius = Math . min ( width , height )  / 2;%NWL%var colors = [ " #98abc5 " ,  " #8a89a6 " ,  " #7b6888 " ,  " #6b486b " ,  " #a05d56 " ,  " #d0743c " ,  " #ff8c00 " ] ;%NWL%var arc = d3 . arc ( )%NWL%. outerRadius ( radius - 10 )%NWL%. innerRadius ( 0 )%NWL%. context ( context ) ;%NWL%var labelArc = d3 . arc ( )%NWL%. outerRadius ( radius - 40 )%NWL%. innerRadius ( radius - 40 )%NWL%var pie = d3 . pie ( )%NWL%3
. context ( context ) ;%NWL%var pie = d3 . pie ( )%NWL%. sort ( null )%NWL%. value ( function ( d )  { return d . population; } ) ;%NWL%context . translate ( width / 2 , height / 2 ) ;%NWL%var data = d3 . csvParse ( csvString ) ;%NWL%var arcs = pie ( data ) ;%NWL%arcs . forEach ( function ( d , i )  {%NWL%context . beginPath ( ) ;%NWL%arc ( d ) ;%NWL%context . fill ( ) ;%NWL%8
. sort ( null )%NWL%. value ( function ( d )  { return d . population; } ) ;%NWL%context . translate ( width / 2 , height / 2 ) ;%NWL%var data = d3 . csvParse ( csvString ) ;%NWL%var arcs = pie ( data ) ;%NWL%arcs . forEach ( function ( d , i )  {%NWL%context . beginPath ( ) ;%NWL%arc ( d ) ;%NWL%context . fillStyle = colors [ i ] ;%NWL%context . fill ( ) ;%NWL%context . beginPath ( ) ;%NWL%6
var data = d3 . csvParse ( csvString ) ;%NWL%var arcs = pie ( data ) ;%NWL%arcs . forEach ( function ( d , i )  {%NWL%context . beginPath ( ) ;%NWL%arc ( d ) ;%NWL%context . fillStyle = colors [ i ] ;%NWL%context . fill ( ) ;%NWL%} ) ;%NWL%context . beginPath ( ) ;%NWL%arcs . forEach ( arc ) ;%NWL%context . stroke ( ) ;%NWL%3
const assert = require ( ' assert ' )%NWL%const d3 = require ( ' d3 ' )%NWL%0
const assert = require ( ' assert ' )%NWL%const d3 = require ( ' d3 ' )%NWL%0
var expected = ' <svg xmlns= " http: / / www . w3 . org / 2000 / svg " ><defs><style type= " text / css " ><! [ CDATA [  . test2 { }  ] ] >< / style>< / defs><g>< / g>< / svg> '%NWL%var actual = d3n . svgString ( )%NWL%assert . equal ( actual , expected )%NWL%} )%NWL%} )%NWL%describe ( ' createSVG ( w / width & height ) ' , function ( )  {%NWL%it ( ' should return svg ' , function ( )  {%NWL%var d3n = new D3Node ( )%NWL%d3n . createSVG ( 100 , 100 ) . append ( ' g ' )%NWL%var expected = ' <svg xmlns= " http: / / www . w3 . org / 2000 / svg " width= " 100 " height= " 100 " ><g>< / g>< / svg> '%NWL%assert . equal ( actual , expected )%NWL%2
}%NWL%} else {%NWL%if ( msg . item && msg . item . channel )  {%NWL%msg . channel = msg . item . channel;%NWL%}%NWL%if ( !msg . channel )  {%NWL%return;%NWL%}%NWL%if ( msg . channel . indexOf ( ' D ' ) === 0 )  {%NWL%this . processDirectMessage ( msg ) ;%NWL%this . processChannelOrGroupMessage ( msg ) ;%NWL%9
this . loop ( ) ;%NWL%}%NWL%%NWL%loop ( )  {%NWL%this . redis . blpop ( settings . prefetchQueueName , 0 )%NWL%. then ( ( data ) => {%NWL%logger . verbose ( ' loop ' ,  ' dequeued: ' , data [ 1 ] ) ;%NWL%try {%NWL%data = JSON . parse ( data [ 1 ] ) ;%NWL%} catch ( ex )  {%NWL%this . loop ( ) ;%NWL%0
. then ( ( ) => logger . verbose ( ' loop ' , `CacheManager rebuilt document $ { data . ts } ` ) )%NWL%. catch ( ( ex ) => logger . error ( ' loop ' , `CacheManager rejected purge promise of $ { data . ts } ` , ex ) ) ;%NWL%break;%NWL%default:%NWL%logger . warn ( ' loop ' , `Received invalid request type " $ { data . type } " ` ) ;%NWL%break;%NWL%}%NWL%this . loop ( ) ;%NWL%} )%NWL%. catch ( ( ex ) => {%NWL%this . loop ( ) ;%NWL%7
this . processors [ k ] . forEach ( p => {%NWL%if ( ( r = p ( $ ) ) )  {%NWL%result [ k ] = result [ k ] || r;%NWL%}%NWL%} ) ;%NWL%} ) ;%NWL%return result;%NWL%} )%NWL%. then ( result => {%NWL%if ( result && result . title && result . image && result . summary )  {%NWL%result . image = URL . resolve ( url , result . image ) ;%NWL%2
logger . error ( ' Proc ' , ex ) ;%NWL%try {%NWL%this . redis . rpush ( settings . errorQueueName , data ) ;%NWL%logger . info ( ' Proc ' , `Old received data has been pushed back to $ { settings . errorQueueName } ` ) ;%NWL%} catch ( ex )  {%NWL%logger . error ( ' Proc ' ,  ' Error pushing data to error queue . Data was lost . ' ) ;%NWL%}%NWL%}%NWL%} )%NWL%. catch ( ( ex ) => {%NWL%logger . error ( ' Proc ' , ex ) ;%NWL%0
rl . setPrompt ( ' Do you really want to continue? ( y / N )  ' ) ;%NWL%rl . prompt ( ) ;%NWL%rl . on ( ' line ' ,  ( answer ) => {%NWL%if ( answer . toString ( ) . toLowerCase ( ) === ' y ' )  {%NWL%logger . info ( ' Flush ' ,  ' Performing . . . ' ) ;%NWL%perform ( ) ;%NWL%} else {%NWL%logger . info ( ' Flush ' ,  ' Aborted . ' ) ;%NWL%process . exit ( 0 ) ;%NWL%}%NWL%logger . info ( ' Flush ' ,  ' Aborted . ' ) ;%NWL%7
rl . prompt ( ) ;%NWL%rl . on ( ' line ' ,  ( answer ) => {%NWL%if ( answer . toString ( ) . toLowerCase ( ) === ' y ' )  {%NWL%logger . info ( ' Flush ' ,  ' Performing . . . ' ) ;%NWL%perform ( ) ;%NWL%} else {%NWL%logger . info ( ' Flush ' ,  ' Aborted . ' ) ;%NWL%process . exit ( 0 ) ;%NWL%}%NWL%} ) . on ( ' close ' ,  ( ) => {%NWL%process . exit ( 0 ) ;%NWL%7
. catch ( ( ex ) => {%NWL%logger . error ( ' Flush ' ,  ' Error: ' ) ;%NWL%logger . error ( ' Flush ' , ex ) ;%NWL%logger . warn ( ' Flush ' ,  ' System may be in an inconsistent state . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%} ) ;%NWL%} ;%NWL%Mongo . prepare ( )%NWL%. then ( run )%NWL%. catch ( ( ex ) => {%NWL%process . exit ( 1 ) ;%NWL%4
. catch ( ( ex ) => {%NWL%logger . error ( ' LostAndFound ' ,  ' Error: ' ) ;%NWL%logger . error ( ' LostAndFound ' , ex ) ;%NWL%logger . warn ( ' LostAndFound ' ,  ' System may be in an inconsistent state . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%} ) ;%NWL%} ;%NWL%Mongo . prepare ( )%NWL%. then ( run )%NWL%. catch ( ( ex ) => {%NWL%process . exit ( 1 ) ;%NWL%4
tip . append ( " img " ) . style ( " float " ,  " left " ) . style ( " margin - right " ,  " 4px " ) . attr ( " src " , d . img ) . attr ( " width " ,  " 64px " ) ;%NWL%}%NWL%tip . append ( " div " ) . style ( " float " ,  " left " ) . html ( dateValue ) ;%NWL%tip . transition ( )%NWL%. duration ( 100 )%NWL%. style ( " opacity " ,  . 9 ) ;%NWL%} )%NWL%. on ( " mouseout " , function ( ) {%NWL%d3 . select ( this )%NWL%. style ( " fill " , function ( d ) { if ( d . background != undefined ) { return d . background } return cfg . background } ) . transition ( )%NWL%tip . transition ( )%NWL%3
var startString = format ( new Date ( minValue ) ) ;%NWL%var endString = format ( new Date ( maxValue ) ) ;%NWL%} else {%NWL%var format = function ( d ) { return d } ; / / Should I do something else?%NWL%var startString = minValue;%NWL%var endString = maxValue;%NWL%}%NWL%svg . append ( " text " )%NWL%. text ( startString ) . style ( " font - size " ,  " 70% " )%NWL%. attr ( " x " , function ( d ) { if ( cfg . horizontalLayout ) { return d3 . max ( [ 0 ,  ( margin - this . getBBox ( ) . width / 2 ) ] ) } return Math . floor ( this . getBBox ( ) . width / 2 ) } )%NWL%svg . append ( " text " )%NWL%7
}%NWL%this . fixEmbeds ( result ) ;%NWL%this . fixEmojis ( ) ;%NWL%} . bind ( this ) )%NWL%. fail ( function ( )  {%NWL%this . waiting = false;%NWL%this . $ . trigger ( ' failed ' ) ;%NWL%} . bind ( this ) ) ;%NWL%} ;%NWL%Controller . prototype . handleScroll = function ( )  {%NWL%this . load ( ) ;%NWL%2
var tinySSG = require ( ' tiny - ssg ' ) ;%NWL%var handlebars = require ( ' handlebars ' ) ;%NWL%var matter = require ( ' gray - matter ' ) ;%NWL%1
var tinySSG = require ( ' tiny - ssg ' ) ;%NWL%var handlebars = require ( ' handlebars ' ) ;%NWL%var marked = require ( ' marked ' ) ;%NWL%var process = require ( ' process ' ) ;%NWL%1
var tinySSG = require ( ' tiny - ssg ' ) ;%NWL%var handlebars = require ( ' handlebars ' ) ;%NWL%var marked = require ( ' marked ' ) ;%NWL%var matter = require ( ' gray - matter ' ) ;%NWL%var highlight = require ( ' highlight . js ' ) ;%NWL%1
var tinySSG = require ( ' tiny - ssg ' ) ;%NWL%var handlebars = require ( ' handlebars ' ) ;%NWL%var marked = require ( ' marked ' ) ;%NWL%var matter = require ( ' gray - matter ' ) ;%NWL%var process = require ( ' process ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
var handlebars = require ( ' handlebars ' ) ;%NWL%var marked = require ( ' marked ' ) ;%NWL%var matter = require ( ' gray - matter ' ) ;%NWL%var process = require ( ' process ' ) ;%NWL%var highlight = require ( ' highlight . js ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%import fetchReadmes from ' . / fetchReadmes ' ;%NWL%import parseReadmes from ' . / parseReadmes ' ;%NWL%import filterReadmes from ' . / filterReadmes ' ;%NWL%import markdownSerialize from ' . / markdownSerialize ' ;%NWL%var resolveExternals = require ( ' . / resolveExternals ' ) ;%NWL%0
var marked = require ( ' marked ' ) ;%NWL%var matter = require ( ' gray - matter ' ) ;%NWL%var process = require ( ' process ' ) ;%NWL%var highlight = require ( ' highlight . js ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%import fetchReadmes from ' . / fetchReadmes ' ;%NWL%import parseReadmes from ' . / parseReadmes ' ;%NWL%import filterReadmes from ' . / filterReadmes ' ;%NWL%import markdownSerialize from ' . / markdownSerialize ' ;%NWL%import copyReadmeAssets from ' . / copyReadmeAssets ' ;%NWL%var createComponentNavigation = require ( ' . / createComponentNavigation ' ) ;%NWL%0
renderMarkdown ,%NWL%renderLayout ,%NWL%writePost ( config . destinationFolder ) ,%NWL%copyReadmeAssets%NWL%] ) ;%NWL%} ) ;%NWL%} )%NWL%. then ( function ( )  {%NWL%process . chdir ( workingDirectory ) ;%NWL%} )%NWL%process . chdir ( workingDirectory ) ;%NWL%8
var Q = require ( ' q ' ) ;%NWL%var util = require ( ' tiny - ssg / es5 / util ' ) ;%NWL%var externals = postMatter . data . externals || [ ] ;%NWL%1
%NWL%booth . hide ( ) ;%NWL%%NWL%try {%NWL%%NWL%navigator . getUserMedia = navigator . getUserMedia || navigator . mozGetUserMedia || navigator . webkitGetUserMedia;%NWL%window . URL = window . URL || window . mozURL || window . webkitURL;%NWL%%NWL%navigator . getUserMedia ( { ' video ' : true } , function ( stream )  {%NWL%video . src = window . opera ? stream : window . URL . createObjectURL ( stream ) ;%NWL%booth . show ( ) ;%NWL%1
var photos = Photos . find ( ) . fetch ( ) ;%NWL%%NWL%if ( !photos . length ) return;%NWL%%NWL%var width = document . documentElement . clientWidth;%NWL%var height = document . documentElement . clientHeight;%NWL%%NWL%var svg = d3 . select ( ' #photos svg ' )%NWL%. attr ( ' width ' , width )%NWL%. attr ( ' height ' , height ) ;%NWL%var layout = d3 . layout . pack ( ) . sort ( d3 . descending ) . size ( [ width , height ] ) ;%NWL%7
d3 . json ( ' https: / / d3fc . io / examples / bubble / data . json ' , function ( _ , data )  {%NWL%data . forEach ( function ( d )  {%NWL%d . income = Number ( d . income ) ;%NWL%d . lifeExpectancy = Number ( d . lifeExpectancy ) ;%NWL%2
var sinLine = fc . seriesSvgLine ( )%NWL%. crossValue ( function ( d )  { return d . x; } )%NWL%. mainValue ( function ( d )  { return d . y; } )%NWL%. decorate ( function ( selection )  {%NWL%selection . enter ( )%NWL%. style ( ' stroke ' ,  ' purple ' ) ;%NWL%} ) ;%NWL%var cosLine = fc . seriesSvgArea ( )%NWL%. crossValue ( function ( d )  { return d . x; } )%NWL%. mainValue ( function ( d )  { return d . z; } )%NWL%selection . enter ( )%NWL%4
if ( !supported )  {%NWL%return this;%NWL%}%NWL%this . sound . play ( ) ;%NWL%return this;%NWL%} ;%NWL%this . togglePlay = function ( )  {%NWL%if ( !supported )  {%NWL%return this;%NWL%}%NWL%this . sound . play ( ) ;%NWL%3
if ( this . sound . paused )  {%NWL%this . sound . play ( ) ;%NWL%} else {%NWL%this . sound . pause ( ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%this . pause = function ( )  {%NWL%if ( !supported )  {%NWL%return this;%NWL%this . sound . pause ( ) ;%NWL%3
} ;%NWL%this . whenReady = function ( func )  {%NWL%if ( !supported )  {%NWL%return null;%NWL%}%NWL%var that = this;%NWL%if ( this . sound . readyState === 0 )  {%NWL%this . bind (  ' canplay . buzzwhenready ' , function ( )  {%NWL%func . call ( that ) ;%NWL%} ) ;%NWL%func . call ( that ) ;%NWL%8
var d3 = require ( ' d3 ' ) ;%NWL%var sample = require ( ' . . / build / d3fc - sample ' ) ;%NWL%0
var d3 = require ( ' d3 ' ) ;%NWL%var topojson = require ( ' topojson ' ) ;%NWL%var sample = require ( ' . . / build / d3fc - sample ' ) ;%NWL%var width = 700;%NWL%var height = 350;%NWL%var strategy = strategyInterceptor ( sample . modeMedian ( ) . value ( function ( d )  { return d . y; } ) ) ;%NWL%var data = [ ] ;%NWL%var ukData = [ ] ;%NWL%d3 . json ( ' uk . json ' , function ( error , uk )  {%NWL%var mesh = topojson . mesh ( uk ) ;%NWL%0
var artboardBounds = jQuery ( ' . artboard ' ) [ 0 ] . getBoundingClientRect ( ) ;%NWL%var margin = { top: 40 , right: 40 , bottom: 40 , left: 40 } ,%NWL%width = artboardBounds . width - margin . left - margin . right ,%NWL%height = artboardBounds . height - margin . top - margin . bottom;%NWL%var tree = d3 . layout . tree ( )%NWL%var diagonal = d3 . svg . diagonal ( )%NWL%4
const dataGenerator = fc . randomFinancial ( )%NWL%. startDate ( new Date ( 2014 , 1 , 1 ) ) ;%NWL%const data = dataGenerator ( 50 ) ;%NWL%const xScale = d3 . scaleTime ( )%NWL%. domain (%NWL%fc . extentDate ( )%NWL%. accessors ( [ d => d . date ] ) ( data )%NWL%)%NWL%. range ( [ 0 , width ] ) ;%NWL%const yScale = d3 . scaleLinear ( )%NWL%fc . extentLinear ( )%NWL%5
return result;%NWL%}%NWL%function drawTriangle ( g )  {%NWL%g . append ( ' path ' )%NWL%. attr ( ' class ' ,  ' glyph ' )%NWL%. attr ( ' d ' ,  ' M0 , - '  + GLYPH_RADIUS +%NWL%' L '  + GLYPH_RADIUS +  ' , '  + GLYPH_RADIUS +%NWL%' L - '  + GLYPH_RADIUS +  ' , '  + GLYPH_RADIUS +%NWL%' L0 , - '  + GLYPH_RADIUS ) ;%NWL%}%NWL%g . append ( ' path ' )%NWL%3
g . append ( ' path ' )%NWL%. attr ( ' class ' ,  ' glyph ' )%NWL%. attr ( ' d ' ,  ' M0 , - '  + GLYPH_RADIUS +%NWL%' L '  + GLYPH_RADIUS +  ' , '  + GLYPH_RADIUS +%NWL%' L - '  + GLYPH_RADIUS +  ' , '  + GLYPH_RADIUS +%NWL%' L0 , - '  + GLYPH_RADIUS ) ;%NWL%}%NWL%function drawX ( g )  {%NWL%g . append ( ' path ' )%NWL%. attr ( ' class ' ,  ' glyph ' )%NWL%g . append ( ' path ' )%NWL%0
if ( !widestDomain )  {%NWL%widestDomain = temp . verticalScale . domain ( ) ;%NWL%} else {%NWL%widestDomain = [%NWL%Math . min ( temp . verticalScale . domain ( ) [ 0 ] , widestDomain [ 0 ] ) ,%NWL%Math . max ( temp . verticalScale . domain ( ) [ 1 ] , widestDomain [ 1 ] )%NWL%] ;%NWL%}%NWL%temp = new MinusLog10Plot ( g +  ' tumor ' , fig2data , drawTriangle ) ;%NWL%temp . render ( domains , ranges , bounds , 5 , false ) ;%NWL%Math . min ( temp . verticalScale . domain ( ) [ 0 ] , widestDomain [ 0 ] ) ,%NWL%4
widestDomain = temp . verticalScale . domain ( ) ;%NWL%} else {%NWL%widestDomain = [%NWL%Math . min ( temp . verticalScale . domain ( ) [ 0 ] , widestDomain [ 0 ] ) ,%NWL%Math . max ( temp . verticalScale . domain ( ) [ 1 ] , widestDomain [ 1 ] )%NWL%] ;%NWL%}%NWL%temp = new MinusLog10Plot ( g +  ' tumor ' , fig2data , drawTriangle ) ;%NWL%temp . render ( domains , ranges , bounds , 5 , false ) ;%NWL%widestDomain = [%NWL%Math . max ( temp . verticalScale . domain ( ) [ 1 ] , widestDomain [ 1 ] )%NWL%4
} ) ;%NWL%verticalScale = temp . verticalScale;%NWL%temp = new Yaxis ( ' yAxis2 ' ) ;%NWL%temp . render ( [ widestDomain ] ,  [ [ bounds . height , 0 ] ] , bounds ) ;%NWL%bounds . y + = bounds . height;%NWL%bounds . height = 20;%NWL%temp = new Xaxis ( ' xAxis2 ' ) ;%NWL%temp . render ( domains , ranges , bounds ) ;%NWL%bounds . y + = bounds . height + 10;%NWL%bounds . height = 80;%NWL%temp . render ( domains , ranges , bounds ) ;%NWL%7
const dataGenerator = fc . randomFinancial ( )%NWL%. startDate ( new Date ( 2014 , 1 , 1 ) ) ;%NWL%const data = dataGenerator ( 50 ) ;%NWL%const xScale = d3 . scaleTime ( )%NWL%. domain (%NWL%fc . extentDate ( )%NWL%. accessors ( [ d => d . date ] ) ( data )%NWL%)%NWL%. range ( [ 0 , width ] ) ;%NWL%const yScale = d3 . scaleLinear ( )%NWL%fc . extentLinear ( )%NWL%5
return xScale;%NWL%}%NWL%xScale = args [ 0 ] ;%NWL%annotations . xScale ( args [ 0 ] ) ;%NWL%return force;%NWL%} ;%NWL%force . yScale = ( . . . args ) => {%NWL%if ( !args . length )  {%NWL%return yScale;%NWL%}%NWL%annotations . yScale ( args [ 0 ] ) ;%NWL%3
return xScale;%NWL%}%NWL%xScale = arguments . length <= 0 ? undefined : arguments [ 0 ] ;%NWL%annotations . xScale ( arguments . length <= 0 ? undefined : arguments [ 0 ] ) ;%NWL%return force;%NWL%} ;%NWL%force . yScale = function ( )  {%NWL%if ( !arguments . length )  {%NWL%return yScale;%NWL%}%NWL%annotations . yScale ( arguments . length <= 0 ? undefined : arguments [ 0 ] ) ;%NWL%3
var artboardBounds = jQuery ( ' . artboard ' ) [ 0 ] . getBoundingClientRect ( ) ;%NWL%var width = artboardBounds . width ,%NWL%height = artboardBounds . height;%NWL%var force = d3 . layout . force ( )%NWL%1
var width = artboardBounds . width ,%NWL%height = artboardBounds . height;%NWL%var color = d3 . scale . category20 ( ) ;%NWL%var force = d3 . layout . force ( )%NWL%. charge ( - 120 )%NWL%. linkDistance ( 30 )%NWL%. size ( [ width , height ] ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . force ' ) . data ( [ 0 ] ) ;%NWL%var svgEnter = svg . enter ( ) ;%NWL%svgEnter . append ( ' g ' )%NWL%svgEnter . append ( ' g ' )%NWL%9
var color = d3 . scale . category20 ( ) ;%NWL%var force = d3 . layout . force ( )%NWL%. charge ( - 120 )%NWL%. linkDistance ( 30 )%NWL%. size ( [ width , height ] ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . force ' ) . data ( [ 0 ] ) ;%NWL%var svgEnter = svg . enter ( ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' linkLayer ' ) ;%NWL%svgEnter . append ( ' g ' )%NWL%var linkLayer = d3 . select ( ' g . linkLayer ' ) ;%NWL%1
var force = d3 . layout . force ( )%NWL%. charge ( - 120 )%NWL%. linkDistance ( 30 )%NWL%. size ( [ width , height ] ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . force ' ) . data ( [ 0 ] ) ;%NWL%var svgEnter = svg . enter ( ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' linkLayer ' ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' nodeLayer ' ) ;%NWL%var nodeLayer = d3 . select ( ' g . nodeLayer ' ) ;%NWL%0
svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' linkLayer ' ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' nodeLayer ' ) ;%NWL%var linkLayer = d3 . select ( ' g . linkLayer ' ) ;%NWL%var nodeLayer = d3 . select ( ' g . nodeLayer ' ) ;%NWL%d3 . json ( " miserables . json " , function ( error , graph )  {%NWL%force%NWL%. nodes ( graph . nodes )%NWL%. links ( graph . links )%NWL%var link = linkLayer . selectAll ( " . link " )%NWL%4
var nodeLayer = d3 . select ( ' g . nodeLayer ' ) ;%NWL%d3 . json ( " miserables . json " , function ( error , graph )  {%NWL%force%NWL%. nodes ( graph . nodes )%NWL%. links ( graph . links )%NWL%. start ( ) ;%NWL%var link = linkLayer . selectAll ( " . link " )%NWL%. data ( graph . links ) ;%NWL%link . enter ( ) . append ( " path " )%NWL%. attr ( " class " ,  " link " )%NWL%var node = nodeLayer . selectAll ( " . node " )%NWL%0
var artboardBounds = jQuery ( ' . artboard ' ) [ 0 ] . getBoundingClientRect ( ) ;%NWL%var width = artboardBounds . width ,%NWL%height = artboardBounds . height;%NWL%var force = d3 . layout . force ( )%NWL%1
var width = artboardBounds . width ,%NWL%height = artboardBounds . height;%NWL%var color = d3 . scale . category20 ( ) ;%NWL%var force = d3 . layout . force ( )%NWL%. charge ( - 120 )%NWL%. linkDistance ( 30 )%NWL%. size ( [ width , height ] ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . force ' ) . data ( [ 0 ] ) ;%NWL%var svgEnter = svg . enter ( ) ;%NWL%svgEnter . append ( ' g ' )%NWL%svgEnter . append ( ' g ' )%NWL%9
var color = d3 . scale . category20 ( ) ;%NWL%var force = d3 . layout . force ( )%NWL%. charge ( - 120 )%NWL%. linkDistance ( 30 )%NWL%. size ( [ width , height ] ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . force ' ) . data ( [ 0 ] ) ;%NWL%var svgEnter = svg . enter ( ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' linkLayer ' ) ;%NWL%svgEnter . append ( ' g ' )%NWL%var linkLayer = d3 . select ( ' g . linkLayer ' ) ;%NWL%1
var force = d3 . layout . force ( )%NWL%. charge ( - 120 )%NWL%. linkDistance ( 30 )%NWL%. size ( [ width , height ] ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . force ' ) . data ( [ 0 ] ) ;%NWL%var svgEnter = svg . enter ( ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' linkLayer ' ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' nodeLayer ' ) ;%NWL%var nodeLayer = d3 . select ( ' g . nodeLayer ' ) ;%NWL%0
svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' linkLayer ' ) ;%NWL%svgEnter . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' nodeLayer ' ) ;%NWL%var linkLayer = d3 . select ( ' g . linkLayer ' ) ;%NWL%var nodeLayer = d3 . select ( ' g . nodeLayer ' ) ;%NWL%d3 . json ( " miserables . json " , function ( error , graph )  {%NWL%force%NWL%. nodes ( graph . nodes )%NWL%. links ( graph . links )%NWL%var link = linkLayer . selectAll ( " . link " )%NWL%4
var nodeLayer = d3 . select ( ' g . nodeLayer ' ) ;%NWL%d3 . json ( " miserables . json " , function ( error , graph )  {%NWL%force%NWL%. nodes ( graph . nodes )%NWL%. links ( graph . links )%NWL%. start ( ) ;%NWL%var link = linkLayer . selectAll ( " . link " )%NWL%. data ( graph . links ) ;%NWL%link . enter ( ) . append ( " path " )%NWL%. attr ( " class " ,  " link " )%NWL%var node = nodeLayer . selectAll ( " . node " )%NWL%0
response . write ( " 404 Not Found\n " ) ;%NWL%response . end ( ) ;%NWL%return;%NWL%}%NWL%%NWL%if ( fs . statSync ( filename ) . isDirectory ( ) ) filename + = ' / index . html ' ;%NWL%%NWL%fs . readFile ( filename ,  " binary " , function ( err , file )  {%NWL%if ( err )  {%NWL%response . writeHead ( 500 ,  { " Content - Type " : " text / plain " } ) ;%NWL%response . end ( ) ;%NWL%1
%NWL%fs . readFile ( filename ,  " binary " , function ( err , file )  {%NWL%if ( err )  {%NWL%response . writeHead ( 500 ,  { " Content - Type " : " text / plain " } ) ;%NWL%response . write ( err +  " \n " ) ;%NWL%response . end ( ) ;%NWL%return;%NWL%}%NWL%%NWL%response . writeHead ( 200 ) ;%NWL%response . end ( ) ;%NWL%5
' use strict ' ;%NWL%var fs = require ( ' fs ' ) ;%NWL%module . exports = function generateGlyphiconsData ( grunt )  {%NWL%var glyphiconsFile = fs . readFileSync ( ' less / glyphicons . less ' ,  ' utf8 ' ) ;%NWL%var glyphiconsLines = glyphiconsFile . split ( ' \n ' ) ;%NWL%var iconClassName = / ^\ . ( glyphicon - [ ^\s ] + ) / ;%NWL%var glyphiconsData = ' # This file is generated via Grunt task .  * * Do not edit directly . * * \n '  +%NWL%' # See the \ ' build - glyphicons - data\ ' task in Gruntfile . js . \n\n ' ;%NWL%var glyphiconsYml = ' docs / _data / glyphicons . yml ' ;%NWL%var match = glyphiconsLines [ i ] . match ( iconClassName ) ;%NWL%1
function Section ( heading , customizable )  {%NWL%this . heading = heading . trim ( ) ;%NWL%this . id = this . heading . replace ( / \s + / g ,  ' - ' ) . toLowerCase ( ) ;%NWL%this . customizable = customizable;%NWL%this . docstring = null;%NWL%this . subsections = [ ] ;%NWL%}%NWL%Section . prototype . addSubSection = function ( subsection )  {%NWL%this . subsections . push ( subsection ) ;%NWL%} ;%NWL%this . heading = heading . trim ( ) ;%NWL%1
this . heading = heading . trim ( ) ;%NWL%this . id = this . heading . replace ( / \s + / g ,  ' - ' ) . toLowerCase ( ) ;%NWL%this . customizable = customizable;%NWL%this . docstring = null;%NWL%this . subsections = [ ] ;%NWL%}%NWL%Section . prototype . addSubSection = function ( subsection )  {%NWL%this . subsections . push ( subsection ) ;%NWL%} ;%NWL%function SubSection ( heading )  {%NWL%this . id = this . heading . replace ( / \s + / g ,  ' - ' ) . toLowerCase ( ) ;%NWL%0
' use strict ' ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var glob = require ( ' glob ' ) ;%NWL%1
this . $element . removeClass ( Affix . RESET ) . addClass ( ' affix ' )%NWL%var scrollTop = this . $target . scrollTop ( )%NWL%var position = this . $element . offset ( )%NWL%return ( this . pinnedOffset = position . top - scrollTop )%NWL%}%NWL%Affix . prototype . checkPositionWithEventLoop = function ( )  {%NWL%setTimeout ( $ . proxy ( this . checkPosition , this ) , 1 )%NWL%}%NWL%Affix . prototype . checkPosition = function ( )  {%NWL%if ( !this . $element . is ( ' :visible ' ) ) return%NWL%var scrollTop  = this . $target . scrollTop ( )%NWL%1
var position = this . $element . offset ( )%NWL%return ( this . pinnedOffset = position . top - scrollTop )%NWL%}%NWL%Affix . prototype . checkPositionWithEventLoop = function ( )  {%NWL%setTimeout ( $ . proxy ( this . checkPosition , this ) , 1 )%NWL%}%NWL%Affix . prototype . checkPosition = function ( )  {%NWL%if ( !this . $element . is ( ' :visible ' ) ) return%NWL%var scrollHeight = $ ( document ) . height ( )%NWL%var scrollTop  = this . $target . scrollTop ( )%NWL%var offset    = this . options . offset%NWL%9
var $this  = $ ( this )%NWL%var selector = $this . attr ( ' data - target ' )%NWL%if ( !selector )  {%NWL%selector = $this . attr ( ' href ' )%NWL%selector = selector && selector . replace ( / . * ( ?=# [ ^\s ] * $ ) / ,  ' ' )  / / strip for ie7%NWL%}%NWL%var $parent = $ ( selector )%NWL%if ( e ) e . preventDefault ( )%NWL%if ( !$parent . length )  {%NWL%$parent = $this . hasClass ( ' alert ' ) ? $this : $this . parent ( )%NWL%$parent . trigger ( e = $ . Event ( ' close . bs . alert ' ) )%NWL%9
var hasData = actives . data ( ' bs . collapse ' )%NWL%if ( hasData && hasData . transitioning ) return%NWL%Plugin . call ( actives ,  ' hide ' )%NWL%hasData || actives . data ( ' bs . collapse ' , null )%NWL%}%NWL%var dimension = this . dimension ( )%NWL%this . $element%NWL%. removeClass ( ' collapse ' )%NWL%. addClass ( ' collapsing ' ) [ dimension ] ( 0 )%NWL%this . transitioning = 1%NWL%this . $element%NWL%6
}%NWL%var dimension = this . dimension ( )%NWL%this . $element%NWL%. removeClass ( ' collapse ' )%NWL%. addClass ( ' collapsing ' ) [ dimension ] ( 0 )%NWL%this . transitioning = 1%NWL%var complete = function ( )  {%NWL%this . $element%NWL%. removeClass ( ' collapsing ' )%NWL%. addClass ( ' collapse in ' ) [ dimension ] ( ' ' )%NWL%this . $element%NWL%2
this . transitioning = 1%NWL%var complete = function ( )  {%NWL%this . $element%NWL%. removeClass ( ' collapsing ' )%NWL%. addClass ( ' collapse in ' ) [ dimension ] ( ' ' )%NWL%this . transitioning = 0%NWL%this . $element%NWL%. trigger ( ' shown . bs . collapse ' )%NWL%}%NWL%if ( !$ . support . transition ) return complete . call ( this )%NWL%this . $element%NWL%2
this . $element%NWL%. one ( ' bsTransitionEnd ' , $ . proxy ( complete , this ) )%NWL%. emulateTransitionEnd ( 350 ) [ dimension ] ( this . $element [ 0 ] [ scrollSize ] )%NWL%}%NWL%Collapse . prototype . hide = function ( )  {%NWL%if ( this . transitioning || !this . $element . hasClass ( ' in ' ) ) return%NWL%var startEvent = $ . Event ( ' hide . bs . collapse ' )%NWL%this . $element . trigger ( startEvent )%NWL%if ( startEvent . isDefaultPrevented ( ) ) return%NWL%var dimension = this . dimension ( )%NWL%this . $element%NWL%0
this . $element . trigger ( startEvent )%NWL%if ( startEvent . isDefaultPrevented ( ) ) return%NWL%var dimension = this . dimension ( )%NWL%this . $element [ dimension ] ( this . $element [ dimension ] ( ) ) [ 0 ] . offsetHeight%NWL%this . $element%NWL%. addClass ( ' collapsing ' )%NWL%. removeClass ( ' collapse ' )%NWL%. removeClass ( ' in ' )%NWL%this . transitioning = 1%NWL%var complete = function ( )  {%NWL%this . $element%NWL%4
. removeClass ( ' collapse ' )%NWL%. removeClass ( ' in ' )%NWL%this . transitioning = 1%NWL%var complete = function ( )  {%NWL%this . transitioning = 0%NWL%this . $element%NWL%. trigger ( ' hidden . bs . collapse ' )%NWL%. removeClass ( ' collapsing ' )%NWL%. addClass ( ' collapse ' )%NWL%}%NWL%this . $element%NWL%5
$ . fn . collapse . noConflict = function ( )  {%NWL%$ . fn . collapse = old%NWL%return this%NWL%}%NWL%$ ( document ) . on ( ' click . bs . collapse . data - api ' ,  ' [ data - toggle= " collapse " ] ' , function ( e )  {%NWL%var href%NWL%var $this  = $ ( this )%NWL%var target = $this . attr ( ' data - target ' )%NWL%|| e . preventDefault ( )%NWL%|| ( href = $this . attr ( ' href ' ) ) && href . replace ( / . * ( ?=# [ ^\s ] + $ ) / ,  ' ' )  / / strip for ie7%NWL%var data  = $target . data ( ' bs . collapse ' )%NWL%7
return this%NWL%}%NWL%$ ( document ) . on ( ' click . bs . collapse . data - api ' ,  ' [ data - toggle= " collapse " ] ' , function ( e )  {%NWL%var href%NWL%var $this  = $ ( this )%NWL%var target = $this . attr ( ' data - target ' )%NWL%|| e . preventDefault ( )%NWL%|| ( href = $this . attr ( ' href ' ) ) && href . replace ( / . * ( ?=# [ ^\s ] + $ ) / ,  ' ' )  / / strip for ie7%NWL%var $target = $ ( target )%NWL%var data  = $target . data ( ' bs . collapse ' )%NWL%var parent = $this . attr ( ' data - parent ' )%NWL%5
x0 . domain ( data . map ( function ( d )  { return d . State; } ) ) ;%NWL%x1 . domain ( ageNames ) . rangeRoundBands ( [ 0 , x0 . rangeBand ( ) ] ) ;%NWL%y . domain ( [ 0 , d3 . max ( data , function ( d )  { return d3 . max ( d . ages , function ( d )  { return d . value; } ) ; } ) ] ) ;%NWL%svg . select ( ' #x_axis ' ) . remove ( ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " id " ,  " x_axis " )%NWL%. attr ( " class " ,  " x axis " )%NWL%. attr ( " transform " ,  " translate ( 0 , "  + height +  " ) " )%NWL%. call ( xAxis ) ;%NWL%%NWL%svg . append ( " g " )%NWL%4
Modal . prototype . toggle = function ( _relatedTarget )  {%NWL%return this . isShown ? this . hide ( ) : this . show ( _relatedTarget )%NWL%}%NWL%Modal . prototype . show = function ( _relatedTarget )  {%NWL%var that = this%NWL%var e  = $ . Event ( ' show . bs . modal ' ,  { relatedTarget: _relatedTarget } )%NWL%this . $element . trigger ( e )%NWL%if ( this . isShown || e . isDefaultPrevented ( ) ) return%NWL%this . isShown = true%NWL%this . checkScrollbar ( )%NWL%this . setScrollbar ( )%NWL%9
return this . isShown ? this . hide ( ) : this . show ( _relatedTarget )%NWL%}%NWL%Modal . prototype . show = function ( _relatedTarget )  {%NWL%var that = this%NWL%var e  = $ . Event ( ' show . bs . modal ' ,  { relatedTarget: _relatedTarget } )%NWL%this . $element . trigger ( e )%NWL%if ( this . isShown || e . isDefaultPrevented ( ) ) return%NWL%this . isShown = true%NWL%this . checkScrollbar ( )%NWL%this . $body . addClass ( ' modal - open ' )%NWL%this . escape ( )%NWL%8
this . backdrop ( function ( )  {%NWL%var transition = $ . support . transition && that . $element . hasClass ( ' fade ' )%NWL%if ( !that . $element . parent ( ) . length )  {%NWL%that . $element . appendTo ( that . $body )  / / don ' t move modals dom position%NWL%}%NWL%that . $element%NWL%. show ( )%NWL%. scrollTop ( 0 )%NWL%if ( transition )  {%NWL%that . $element [ 0 ] . offsetWidth / / force reflow%NWL%that . $element%NWL%5
that . $element%NWL%. addClass ( ' in ' )%NWL%. attr ( ' aria - hidden ' , false )%NWL%that . enforceFocus ( )%NWL%var e = $ . Event ( ' shown . bs . modal ' ,  { relatedTarget: _relatedTarget } )%NWL%transition ?%NWL%that . $element . find ( ' . modal - dialog ' )  / / wait for modal to slide in%NWL%. one ( ' bsTransitionEnd ' , function ( )  {%NWL%that . $element . trigger ( ' focus ' ) . trigger ( e )%NWL%} )%NWL%that . $element . trigger ( ' focus ' ) . trigger ( e )%NWL%8
if ( !this . isShown || e . isDefaultPrevented ( ) ) return%NWL%this . isShown = false%NWL%this . $body . removeClass ( ' modal - open ' )%NWL%this . resetScrollbar ( )%NWL%this . escape ( )%NWL%$ ( document ) . off ( ' focusin . bs . modal ' )%NWL%this . $element%NWL%. removeClass ( ' in ' )%NWL%. attr ( ' aria - hidden ' , true )%NWL%. off ( ' click . dismiss . bs . modal ' )%NWL%this . $element%NWL%6
this . resetScrollbar ( )%NWL%this . escape ( )%NWL%$ ( document ) . off ( ' focusin . bs . modal ' )%NWL%this . $element%NWL%. removeClass ( ' in ' )%NWL%. attr ( ' aria - hidden ' , true )%NWL%. off ( ' click . dismiss . bs . modal ' )%NWL%$ . support . transition && this . $element . hasClass ( ' fade ' ) ?%NWL%this . $element%NWL%. one ( ' bsTransitionEnd ' , $ . proxy ( this . hideModal , this ) )%NWL%this . hideModal ( )%NWL%0
this . $backdrop%NWL%. one ( ' bsTransitionEnd ' , callback )%NWL%. emulateTransitionEnd ( 150 ) :%NWL%callback ( )%NWL%} else if ( !this . isShown && this . $backdrop )  {%NWL%this . $backdrop . removeClass ( ' in ' )%NWL%var callbackRemove = function ( )  {%NWL%that . removeBackdrop ( )%NWL%callback && callback ( )%NWL%}%NWL%this . $backdrop%NWL%0
this . init ( ' popover ' , element , options )%NWL%}%NWL%if ( !$ . fn . tooltip ) throw new Error ( ' Popover requires tooltip . js ' )%NWL%Popover . VERSION = ' 3 . 2 . 0 '%NWL%Popover . DEFAULTS = $ . extend ( { } , $ . fn . tooltip . Constructor . DEFAULTS ,  {%NWL%placement: ' right ' ,%NWL%trigger: ' click ' ,%NWL%content: ' ' ,%NWL%template: ' <div class= " popover " role= " tooltip " ><div class= " arrow " >< / div><h3 class= " popover - title " >< / h3><div class= " popover - content " >< / div>< / div> '%NWL%} )%NWL%Popover . prototype . constructor = Popover%NWL%4
} )%NWL%. sort ( function ( a , b )  { return a [ 0 ]  - b [ 0 ]  } )%NWL%. each ( function ( )  {%NWL%self . offsets . push ( this [ 0 ] )%NWL%self . targets . push ( this [ 1 ] )%NWL%} )%NWL%}%NWL%ScrollSpy . prototype . process = function ( )  {%NWL%var scrollTop  = this . $scrollElement . scrollTop ( )  + this . options . offset%NWL%var scrollHeight = this . getScrollHeight ( )%NWL%var offsets   = this . offsets%NWL%8
. sort ( function ( a , b )  { return a [ 0 ]  - b [ 0 ]  } )%NWL%. each ( function ( )  {%NWL%self . offsets . push ( this [ 0 ] )%NWL%self . targets . push ( this [ 1 ] )%NWL%} )%NWL%}%NWL%ScrollSpy . prototype . process = function ( )  {%NWL%var scrollTop  = this . $scrollElement . scrollTop ( )  + this . options . offset%NWL%var scrollHeight = this . getScrollHeight ( )%NWL%var maxScroll  = this . options . offset + scrollHeight - this . $scrollElement . height ( )%NWL%var targets   = this . targets%NWL%7
. each ( function ( )  {%NWL%self . offsets . push ( this [ 0 ] )%NWL%self . targets . push ( this [ 1 ] )%NWL%} )%NWL%}%NWL%ScrollSpy . prototype . process = function ( )  {%NWL%var scrollTop  = this . $scrollElement . scrollTop ( )  + this . options . offset%NWL%var scrollHeight = this . getScrollHeight ( )%NWL%var maxScroll  = this . options . offset + scrollHeight - this . $scrollElement . height ( )%NWL%var offsets   = this . offsets%NWL%var activeTarget = this . activeTarget%NWL%6
html: false ,%NWL%container: false ,%NWL%viewport: {%NWL%selector: ' body ' ,%NWL%padding: 0%NWL%}%NWL%}%NWL%Tooltip . prototype . init = function ( type , element , options )  {%NWL%this . enabled  = true%NWL%this . type   = type%NWL%this . options  = this . getOptions ( options )%NWL%9
container: false ,%NWL%viewport: {%NWL%selector: ' body ' ,%NWL%padding: 0%NWL%}%NWL%}%NWL%Tooltip . prototype . init = function ( type , element , options )  {%NWL%this . enabled  = true%NWL%this . type   = type%NWL%this . $element = $ ( element )%NWL%this . $viewport = this . options . viewport && $ ( this . options . viewport . selector || this . options . viewport )%NWL%8
Tooltip . prototype . getViewportAdjustedDelta = function ( placement , pos , actualWidth , actualHeight )  {%NWL%var delta = { top: 0 , left: 0 }%NWL%if ( !this . $viewport ) return delta%NWL%var viewportPadding = this . options . viewport && this . options . viewport . padding || 0%NWL%var viewportDimensions = this . getPosition ( this . $viewport )%NWL%if ( / right|left / . test ( placement ) )  {%NWL%var topEdgeOffset  = pos . top - viewportPadding - viewportDimensions . scroll%NWL%var bottomEdgeOffset = pos . top + viewportPadding - viewportDimensions . scroll + actualHeight%NWL%if ( topEdgeOffset < viewportDimensions . top )  {  / / top overflow%NWL%delta . top = viewportDimensions . top - topEdgeOffset%NWL%delta . top = viewportDimensions . top + viewportDimensions . height - bottomEdgeOffset%NWL%9
var topEdgeOffset  = pos . top - viewportPadding - viewportDimensions . scroll%NWL%var bottomEdgeOffset = pos . top + viewportPadding - viewportDimensions . scroll + actualHeight%NWL%if ( topEdgeOffset < viewportDimensions . top )  {  / / top overflow%NWL%delta . top = viewportDimensions . top - topEdgeOffset%NWL%} else if ( bottomEdgeOffset > viewportDimensions . top + viewportDimensions . height )  {  / / bottom overflow%NWL%delta . top = viewportDimensions . top + viewportDimensions . height - bottomEdgeOffset%NWL%}%NWL%} else {%NWL%var leftEdgeOffset = pos . left - viewportPadding%NWL%var rightEdgeOffset = pos . left + viewportPadding + actualWidth%NWL%delta . left = viewportDimensions . left - leftEdgeOffset%NWL%3
if ( topEdgeOffset < viewportDimensions . top )  {  / / top overflow%NWL%delta . top = viewportDimensions . top - topEdgeOffset%NWL%} else if ( bottomEdgeOffset > viewportDimensions . top + viewportDimensions . height )  {  / / bottom overflow%NWL%delta . top = viewportDimensions . top + viewportDimensions . height - bottomEdgeOffset%NWL%}%NWL%} else {%NWL%var leftEdgeOffset = pos . left - viewportPadding%NWL%var rightEdgeOffset = pos . left + viewportPadding + actualWidth%NWL%if ( leftEdgeOffset < viewportDimensions . left )  {  / / left overflow%NWL%delta . left = viewportDimensions . left - leftEdgeOffset%NWL%delta . left = viewportDimensions . left + viewportDimensions . width - rightEdgeOffset%NWL%1
jQuery . merge ( ret , jQuery . buildFragment ( elems , context ) . childNodes ) ;%NWL%if ( fragment )  {%NWL%handleScript = function ( elem )  {%NWL%if ( !elem . type || rscriptType . test ( elem . type )  )  {%NWL%return scripts ?%NWL%scripts . push ( elem . parentNode ? elem . parentNode . removeChild ( elem ) : elem ) :%NWL%fragment . appendChild ( elem ) ;%NWL%}%NWL%} ;%NWL%for ( i = 0; ( elem = ret [ i ] ) != null; i + +  )  {%NWL%fragment . appendChild ( elem ) ;%NWL%6
transport . abort ( finalText ) ;%NWL%}%NWL%done ( 0 , finalText ) ;%NWL%return this;%NWL%}%NWL%} ;%NWL%deferred . promise ( jqXHR ) . complete = completeDeferred . add;%NWL%jqXHR . success = jqXHR . done;%NWL%jqXHR . error = jqXHR . fail;%NWL%s . url = (  ( url || s . url || ajaxLocation )  +  " "  ) . replace ( rhash ,  " "  ) . replace ( rprotocol , ajaxLocParts [ 1 ]  +  " / / "  ) ;%NWL%s . dataTypes = jQuery . trim ( s . dataType || " * "  ) . toLowerCase ( ) . match ( core_rnotwhite ) || [ " " ] ;%NWL%9
s . type = options . method || options . type || s . method || s . type;%NWL%s . dataTypes = jQuery . trim ( s . dataType || " * "  ) . toLowerCase ( ) . match ( core_rnotwhite ) || [ " " ] ;%NWL%if ( s . crossDomain == null )  {%NWL%parts = rurl . exec ( s . url . toLowerCase ( )  ) ;%NWL%s . crossDomain = !! ( parts &&%NWL%( parts [ 1 ] !== ajaxLocParts [ 1 ] || parts [ 2 ] !== ajaxLocParts [ 2 ] ||%NWL%( parts [ 3 ] || ( parts [ 1 ] === " http: " ? 80 : 443 )  ) !=%NWL%( ajaxLocParts [ 3 ] || ( ajaxLocParts [ 1 ] === " http: " ? 80 : 443 )  )  )%NWL%) ;%NWL%}%NWL%s . data = jQuery . param ( s . data , s . traditional ) ;%NWL%0
if ( s . data && s . processData && typeof s . data !== " string "  )  {%NWL%s . data = jQuery . param ( s . data , s . traditional ) ;%NWL%}%NWL%inspectPrefiltersOrTransports ( prefilters , s , options , jqXHR ) ;%NWL%if ( state === 2 )  {%NWL%return jqXHR;%NWL%}%NWL%fireGlobals = s . global;%NWL%if ( fireGlobals && jQuery . active + + === 0 )  {%NWL%jQuery . event . trigger ( " ajaxStart " ) ;%NWL%s . type = s . type . toUpperCase ( ) ;%NWL%1
s . data = jQuery . param ( s . data , s . traditional ) ;%NWL%}%NWL%inspectPrefiltersOrTransports ( prefilters , s , options , jqXHR ) ;%NWL%if ( state === 2 )  {%NWL%return jqXHR;%NWL%}%NWL%fireGlobals = s . global;%NWL%if ( fireGlobals && jQuery . active + + === 0 )  {%NWL%jQuery . event . trigger ( " ajaxStart " ) ;%NWL%}%NWL%s . hasContent = !rnoContent . test ( s . type ) ;%NWL%0
jQuery . event . trigger ( " ajaxStart " ) ;%NWL%}%NWL%s . type = s . type . toUpperCase ( ) ;%NWL%s . hasContent = !rnoContent . test ( s . type ) ;%NWL%cacheURL = s . url;%NWL%if ( !s . hasContent )  {%NWL%if ( s . data )  {%NWL%cacheURL = ( s . url + = ( ajax_rquery . test ( cacheURL ) ? " & " : " ? "  )  + s . data ) ;%NWL%delete s . data;%NWL%}%NWL%s . url = rts . test ( cacheURL ) ?%NWL%2
var artboardBounds = jQuery ( ' . artboard ' ) [ 0 ] . getBoundingClientRect ( ) ;%NWL%var diameter = Math . min ( artboardBounds . width , artboardBounds . height ) ,%NWL%radius = diameter / 2 ,%NWL%innerRadius = radius - 120;%NWL%var cluster = d3 . layout . cluster ( )%NWL%. size ( [ 360 , innerRadius ] )%NWL%. sort ( null )%NWL%var bundle = d3 . layout . bundle ( ) ;%NWL%4
var artboardBounds = jQuery ( ' . artboard ' ) [ 0 ] . getBoundingClientRect ( ) ;%NWL%var diameter = Math . min ( artboardBounds . width , artboardBounds . height ) ,%NWL%radius = diameter / 2 ,%NWL%innerRadius = radius - 120;%NWL%var cluster = d3 . layout . cluster ( )%NWL%. size ( [ 360 , innerRadius ] )%NWL%. sort ( null )%NWL%. value ( function ( d )  { return d . size; } ) ;%NWL%var line = d3 . svg . line . radial ( )%NWL%4
. value ( function ( d )  { return d . size; } ) ;%NWL%var bundle = d3 . layout . bundle ( ) ;%NWL%var line = d3 . svg . line . radial ( )%NWL%. interpolate ( " bundle " )%NWL%. tension ( . 85 )%NWL%. radius ( function ( d )  { return d . y; } )%NWL%. angle ( function ( d )  { return d . x / 180 * Math . PI; } ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . hierarchicalEdgeBundling ' ) . data ( [ 0 ] ) ;%NWL%svg . enter ( ) . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' hierarchicalEdgeBundling ' )%NWL%var linkLayer = svg . selectAll ( ' . linkLayer ' ) . data ( [ 0 ] ) ,%NWL%1
. tension ( . 85 )%NWL%. radius ( function ( d )  { return d . y; } )%NWL%. angle ( function ( d )  { return d . x / 180 * Math . PI; } ) ;%NWL%var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . hierarchicalEdgeBundling ' ) . data ( [ 0 ] ) ;%NWL%svg . enter ( ) . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' hierarchicalEdgeBundling ' )%NWL%. attr ( " transform " ,  " translate ( "  + radius +  " , "  + radius +  " ) " ) ;%NWL%var linkLayer = svg . selectAll ( ' . linkLayer ' ) . data ( [ 0 ] ) ,%NWL%nodeLayer = svg . selectAll ( ' . nodeLayer ' ) . data ( [ 0 ] ) ;%NWL%linkLayer . enter ( ) . append ( " g " ) ;%NWL%var link = linkLayer . selectAll ( " . link " ) ,%NWL%7
var svg = d3 . select ( ' #Layer_1 ' ) . selectAll ( ' . hierarchicalEdgeBundling ' ) . data ( [ 0 ] ) ;%NWL%svg . enter ( ) . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' hierarchicalEdgeBundling ' )%NWL%. attr ( " transform " ,  " translate ( "  + radius +  " , "  + radius +  " ) " ) ;%NWL%var linkLayer = svg . selectAll ( ' . linkLayer ' ) . data ( [ 0 ] ) ,%NWL%nodeLayer = svg . selectAll ( ' . nodeLayer ' ) . data ( [ 0 ] ) ;%NWL%linkLayer . enter ( ) . append ( " g " ) ;%NWL%nodeLayer . enter ( ) . append ( " g " ) ;%NWL%var link = linkLayer . selectAll ( " . link " ) ,%NWL%node = nodeLayer . selectAll ( " . node " ) ;%NWL%var nodes = cluster . nodes ( packageHierarchy ( classes ) ) ,%NWL%4
resolveValues = core_slice . call ( arguments ) ,%NWL%length = resolveValues . length ,%NWL%remaining = length !== 1 || ( subordinate && jQuery . isFunction ( subordinate . promise )  ) ? length : 0 ,%NWL%deferred = remaining === 1 ? subordinate : jQuery . Deferred ( ) ,%NWL%updateFunc = function ( i , contexts , values )  {%NWL%return function ( value )  {%NWL%contexts [ i ] = this;%NWL%values [ i ] = arguments . length > 1 ? core_slice . call ( arguments ) : value;%NWL%if ( values === progressValues )  {%NWL%deferred . notifyWith ( contexts , values ) ;%NWL%deferred . resolveWith ( contexts , values ) ;%NWL%9
length = gotoEnd ? animation . tweens . length : 0;%NWL%if ( stopped )  {%NWL%return this;%NWL%}%NWL%stopped = true;%NWL%for ( ; index < length ; index + +  )  {%NWL%animation . tweens [ index ] . run ( 1 ) ;%NWL%}%NWL%if ( gotoEnd )  {%NWL%deferred . resolveWith ( elem ,  [ animation , gotoEnd ]  ) ;%NWL%deferred . rejectWith ( elem ,  [ animation , gotoEnd ]  ) ;%NWL%9
length = props . length;%NWL%for ( ; index < length ; index + +  )  {%NWL%prop = props [ index ] ;%NWL%tweeners [ prop ] = tweeners [ prop ] || [ ] ;%NWL%tweeners [ prop ] . unshift ( callback ) ;%NWL%}%NWL%} ,%NWL%prefilter: function ( callback , prepend )  {%NWL%if ( prepend )  {%NWL%animationPrefilters . unshift ( callback ) ;%NWL%animationPrefilters . push ( callback ) ;%NWL%9
} else {%NWL%style . zoom = 1;%NWL%}%NWL%}%NWL%}%NWL%if ( opts . overflow )  {%NWL%style . overflow = " hidden " ;%NWL%if ( !jQuery . support . shrinkWrapBlocks )  {%NWL%anim . always ( function ( )  {%NWL%style . overflow = opts . overflow [ 0 ] ;%NWL%style . overflowY = opts . overflow [ 2 ] ;%NWL%9
function Tween ( elem , options , prop , end , easing )  {%NWL%return new Tween . prototype . init ( elem , options , prop , end , easing ) ;%NWL%}%NWL%jQuery . Tween = Tween;%NWL%Tween . prototype = {%NWL%constructor: Tween ,%NWL%init: function ( elem , options , prop , end , easing , unit )  {%NWL%this . elem = elem;%NWL%this . prop = prop;%NWL%this . easing = easing || " swing " ;%NWL%this . start = this . now = this . cur ( ) ;%NWL%9
}%NWL%jQuery . Tween = Tween;%NWL%Tween . prototype = {%NWL%constructor: Tween ,%NWL%init: function ( elem , options , prop , end , easing , unit )  {%NWL%this . elem = elem;%NWL%this . prop = prop;%NWL%this . easing = easing || " swing " ;%NWL%this . options = options;%NWL%this . start = this . now = this . cur ( ) ;%NWL%this . unit = unit || ( jQuery . cssNumber [ prop ] ? " " : " px "  ) ;%NWL%7
. end ( ) . animate ( { opacity: to } , speed , easing , callback ) ;%NWL%} ,%NWL%animate: function ( prop , speed , easing , callback )  {%NWL%var empty = jQuery . isEmptyObject ( prop ) ,%NWL%optall = jQuery . speed ( speed , easing , callback ) ,%NWL%doAnimation = function ( )  {%NWL%var anim = Animation ( this , jQuery . extend (  { } , prop ) , optall ) ;%NWL%doAnimation . finish = function ( )  {%NWL%anim . stop ( true ) ;%NWL%} ;%NWL%anim . stop ( true ) ;%NWL%8
} ) ;%NWL%function genFx ( type , includeWidth )  {%NWL%var which ,%NWL%attrs = { height: type } ,%NWL%i = 0;%NWL%includeWidth = includeWidth? 1 : 0;%NWL%for ( ; i < 4 ; i + = 2 - includeWidth )  {%NWL%which = cssExpand [ i ] ;%NWL%attrs [  " margin "  + which ] = attrs [  " padding "  + which ] = type;%NWL%}%NWL%attrs . opacity = attrs . width = type;%NWL%8
var opt = speed && typeof speed === " object " ? jQuery . extend (  { } , speed ) : {%NWL%complete: fn || !fn && easing ||%NWL%jQuery . isFunction ( speed ) && speed ,%NWL%duration: speed ,%NWL%easing: fn && easing || easing && !jQuery . isFunction ( easing ) && easing%NWL%} ;%NWL%opt . duration = jQuery . fx . off ? 0 : typeof opt . duration === " number " ? opt . duration :%NWL%opt . duration in jQuery . fx . speeds ? jQuery . fx . speeds [ opt . duration ] : jQuery . fx . speeds . _default;%NWL%if ( opt . queue == null || opt . queue === true )  {%NWL%opt . queue = " fx " ;%NWL%opt . old = opt . complete;%NWL%6
x . domain ( d3 . extent ( data , function ( d )  { return d . date; } ) ) ;%NWL%y . domain ( d3 . extent ( data , function ( d )  { return d . close; } ) ) ;%NWL%%NWL%svg . select ( ' #x_axis ' ) . remove ( ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " id " ,  " x_axis " )%NWL%. attr ( " class " ,  " x axis " )%NWL%. attr ( " transform " ,  " translate ( 0 , "  + height +  " ) " )%NWL%. call ( xAxis ) ;%NWL%%NWL%svg . append ( " g " )%NWL%4
rkeyEvent . test ( type ) ? this . keyHooks :%NWL%{ } ;%NWL%}%NWL%copy = fixHook . props ? this . props . concat ( fixHook . props ) : this . props;%NWL%event = new jQuery . Event ( originalEvent ) ;%NWL%i = copy . length;%NWL%while ( i - -  )  {%NWL%prop = copy [ i ] ;%NWL%event [ prop ] = originalEvent [ prop ] ;%NWL%}%NWL%event . target = originalEvent . srcElement || document;%NWL%8
copy = fixHook . props ? this . props . concat ( fixHook . props ) : this . props;%NWL%event = new jQuery . Event ( originalEvent ) ;%NWL%i = copy . length;%NWL%while ( i - -  )  {%NWL%prop = copy [ i ] ;%NWL%event [ prop ] = originalEvent [ prop ] ;%NWL%}%NWL%if ( !event . target )  {%NWL%event . target = originalEvent . srcElement || document;%NWL%}%NWL%event . target = event . target . parentNode;%NWL%5
i = copy . length;%NWL%while ( i - -  )  {%NWL%prop = copy [ i ] ;%NWL%event [ prop ] = originalEvent [ prop ] ;%NWL%}%NWL%if ( !event . target )  {%NWL%event . target = originalEvent . srcElement || document;%NWL%}%NWL%if ( event . target . nodeType === 3 )  {%NWL%event . target = event . target . parentNode;%NWL%event . metaKey = !!event . metaKey;%NWL%3
event . target = event . target . parentNode;%NWL%}%NWL%event . metaKey = !!event . metaKey;%NWL%return fixHook . filter ? fixHook . filter ( event , originalEvent ) : event;%NWL%} ,%NWL%props: " altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which " . split ( "  " ) ,%NWL%fixHooks: { } ,%NWL%keyHooks: {%NWL%props: " char charCode key keyCode " . split ( "  " ) ,%NWL%filter: function ( event , original )  {%NWL%event . which = original . charCode != null ? original . charCode : original . keyCode;%NWL%0
trigger: function ( )  {%NWL%if ( jQuery . nodeName ( this ,  " input "  ) && this . type === " checkbox " && this . click )  {%NWL%this . click ( ) ;%NWL%return false;%NWL%}%NWL%}%NWL%} ,%NWL%focus: {%NWL%trigger: function ( )  {%NWL%if ( this !== document . activeElement && this . focus )  {%NWL%this . focus ( ) ;%NWL%2
this . focus ( ) ;%NWL%return false;%NWL%} catch ( e )  {%NWL%}%NWL%}%NWL%} ,%NWL%delegateType: " focusin "%NWL%} ,%NWL%blur: {%NWL%trigger: function ( )  {%NWL%this . blur ( ) ;%NWL%0
handler = function ( event )  {%NWL%jQuery . event . simulate ( fix , event . target , jQuery . event . fix ( event ) , true ) ;%NWL%} ;%NWL%jQuery . event . special [ fix ] = {%NWL%setup: function ( )  {%NWL%if ( attaches + + === 0 )  {%NWL%document . addEventListener ( orig , handler , true ) ;%NWL%}%NWL%} ,%NWL%teardown: function ( )  {%NWL%document . removeEventListener ( orig , handler , true ) ;%NWL%6
} else {%NWL%curTop = parseFloat ( curCSSTop ) || 0;%NWL%curLeft = parseFloat ( curCSSLeft ) || 0;%NWL%}%NWL%if ( jQuery . isFunction ( options )  )  {%NWL%options = options . call ( elem , i , curOffset ) ;%NWL%}%NWL%if ( options . top != null )  {%NWL%props . top = ( options . top - curOffset . top )  + curTop;%NWL%}%NWL%props . left = ( options . left - curOffset . left )  + curLeft;%NWL%8
setter - - ;%NWL%}%NWL%if ( arguments . length < setter )  {%NWL%return jQuery . queue ( this [ 0 ] , type ) ;%NWL%}%NWL%return data === undefined ?%NWL%this :%NWL%this . each ( function ( )  {%NWL%var queue = jQuery . queue ( this , type , data ) ;%NWL%jQuery . _queueHooks ( this , type ) ;%NWL%jQuery . dequeue ( this , type ) ;%NWL%9
this :%NWL%this . each ( function ( )  {%NWL%var queue = jQuery . queue ( this , type , data ) ;%NWL%jQuery . _queueHooks ( this , type ) ;%NWL%if ( type === " fx " && queue [ 0 ] !== " inprogress "  )  {%NWL%jQuery . dequeue ( this , type ) ;%NWL%}%NWL%} ) ;%NWL%} ,%NWL%dequeue: function ( type )  {%NWL%jQuery . dequeue ( this , type ) ;%NWL%3
return this . map ( function ( ) {%NWL%var elements = jQuery . prop ( this ,  " elements "  ) ;%NWL%return elements ? jQuery . makeArray ( elements ) : this;%NWL%} )%NWL%. filter ( function ( ) {%NWL%var type = this . type;%NWL%return this . name && !jQuery ( this ) . is (  " :disabled "  ) &&%NWL%rsubmittable . test ( this . nodeName ) && !rsubmitterTypes . test ( type ) &&%NWL%( this . checked || !manipulation_rcheckableType . test ( type )  ) ;%NWL%} )%NWL%var val = jQuery ( this ) . val ( ) ;%NWL%1
Sizzle . attr = jQuery . attr;%NWL%jQuery . find = Sizzle;%NWL%jQuery . expr = Sizzle . selectors;%NWL%jQuery . expr [ " : " ] = jQuery . expr . pseudos;%NWL%jQuery . text = Sizzle . getText;%NWL%3
Sizzle . attr = jQuery . attr;%NWL%jQuery . find = Sizzle;%NWL%jQuery . expr = Sizzle . selectors;%NWL%jQuery . expr [ " : " ] = jQuery . expr . pseudos;%NWL%jQuery . unique = Sizzle . uniqueSort;%NWL%jQuery . isXMLDoc = Sizzle . isXML;%NWL%3
Sizzle . attr = jQuery . attr;%NWL%jQuery . find = Sizzle;%NWL%jQuery . expr = Sizzle . selectors;%NWL%jQuery . expr [ " : " ] = jQuery . expr . pseudos;%NWL%jQuery . unique = Sizzle . uniqueSort;%NWL%jQuery . text = Sizzle . getText;%NWL%jQuery . contains = Sizzle . contains;%NWL%3
support . optDisabled = !opt . disabled;%NWL%try {%NWL%delete div . test;%NWL%} catch ( e )  {%NWL%support . deleteExpando = false;%NWL%}%NWL%input = document . createElement ( " input " ) ;%NWL%input . setAttribute (  " value " ,  " "  ) ;%NWL%support . input = input . getAttribute (  " value "  ) === " " ;%NWL%input . value = " t " ;%NWL%support . radioValue = input . value === " t " ;%NWL%8
}%NWL%input = document . createElement ( " input " ) ;%NWL%input . setAttribute (  " value " ,  " "  ) ;%NWL%support . input = input . getAttribute (  " value "  ) === " " ;%NWL%input . value = " t " ;%NWL%input . setAttribute (  " type " ,  " radio "  ) ;%NWL%support . radioValue = input . value === " t " ;%NWL%input . setAttribute (  " checked " ,  " t "  ) ;%NWL%input . setAttribute (  " name " ,  " t "  ) ;%NWL%fragment = document . createDocumentFragment ( ) ;%NWL%support . appendChecked = input . checked;%NWL%3
input = document . createElement ( " input " ) ;%NWL%input . setAttribute (  " value " ,  " "  ) ;%NWL%support . input = input . getAttribute (  " value "  ) === " " ;%NWL%input . value = " t " ;%NWL%input . setAttribute (  " type " ,  " radio "  ) ;%NWL%support . radioValue = input . value === " t " ;%NWL%input . setAttribute (  " checked " ,  " t "  ) ;%NWL%input . setAttribute (  " name " ,  " t "  ) ;%NWL%fragment = document . createDocumentFragment ( ) ;%NWL%fragment . appendChild ( input ) ;%NWL%support . checkClone = fragment . cloneNode ( true ) . cloneNode ( true ) . lastChild . checked;%NWL%2
tds [ 1 ] . style . display = " none " ;%NWL%support . reliableHiddenOffsets = isSupported && ( tds [ 0 ] . offsetHeight === 0 ) ;%NWL%div . innerHTML = " " ;%NWL%div . style . cssText = " box - sizing:border - box; - moz - box - sizing:border - box; - webkit - box - sizing:border - box;padding:1px;border:1px;display:block;width:4px;margin - top:1%;position:absolute;top:1%; " ;%NWL%support . boxSizing = ( div . offsetWidth === 4 ) ;%NWL%support . doesNotIncludeMarginInBodyOffset = ( body . offsetTop !== 1 ) ;%NWL%if ( window . getComputedStyle )  {%NWL%support . pixelPosition = ( window . getComputedStyle ( div , null ) || { }  ) . top !== " 1% " ;%NWL%support . boxSizingReliable = ( window . getComputedStyle ( div , null ) || { width: " 4px "  }  ) . width === " 4px " ;%NWL%marginDiv = div . appendChild ( document . createElement ( " div " )  ) ;%NWL%marginDiv . style . marginRight = marginDiv . style . width = " 0 " ;%NWL%9
var color = d3 . scale . category10 ( ) ;%NWL%var xAxis = d3 . svg . axis ( )%NWL%. scale ( x )%NWL%. orient ( " bottom " ) ;%NWL%var yAxis = d3 . svg . axis ( )%NWL%. scale ( y )%NWL%. orient ( " left " ) ;%NWL%var line = d3 . svg . line ( )%NWL%. interpolate ( " basis " )%NWL%. x ( function ( d )  { return x ( d . date ) ; } )%NWL%var svg = d3 . select ( " body " ) . append ( " svg " )%NWL%7
} ;%NWL%} ) ;%NWL%x . domain ( d3 . extent ( data , function ( d )  { return d . date; } ) ) ;%NWL%y . domain ( [%NWL%d3 . min ( cities , function ( c )  { return d3 . min ( c . values , function ( v )  { return v . temperature; } ) ; } ) ,%NWL%d3 . max ( cities , function ( c )  { return d3 . max ( c . values , function ( v )  { return v . temperature; } ) ; } )%NWL%] ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " class " ,  " x axis " )%NWL%. attr ( " transform " ,  " translate ( 0 , "  + height +  " ) " )%NWL%svg . append ( " g " )%NWL%7
jsonProp = s . jsonp !== false && ( rjsonp . test ( s . url ) ?%NWL%" url " :%NWL%typeof s . data === " string " && ! ( s . contentType || " "  ) . indexOf ( " application / x - www - form - urlencoded " ) && rjsonp . test ( s . data ) && " data "%NWL%) ;%NWL%if ( jsonProp || s . dataTypes [ 0 ] === " jsonp "  )  {%NWL%callbackName = s . jsonpCallback = jQuery . isFunction ( s . jsonpCallback ) ?%NWL%s . jsonpCallback ( ) :%NWL%s . jsonpCallback;%NWL%if ( jsonProp )  {%NWL%s [ jsonProp ] = s [ jsonProp ] . replace ( rjsonp ,  " $1 "  + callbackName ) ;%NWL%s . url + = ( ajax_rquery . test ( s . url ) ? " & " : " ? "  )  + s . jsonp +  " = "  + callbackName;%NWL%9
asyncTest ( title , expect , function ( )  {%NWL%if ( options . setup )  {%NWL%options . setup ( ) ;%NWL%}%NWL%var completed = false ,%NWL%remaining = requestOptions . length ,%NWL%complete = function ( )  {%NWL%if ( !completed && - - remaining === 0 )  {%NWL%completed = true;%NWL%delete ajaxTest . abort;%NWL%options . teardown ( ) ;%NWL%2
$ ( " <script type= ' jquery / test ' src= ' #5 ' id= ' scriptSrc ' >< / script> " ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( jQuery ( " #tAnchor5 " ) . prop ( " href " ) , jQuery ( " #scriptSrc " ) . prop ( " src " ) ,  " Check for absolute src prop on a script "  ) ;%NWL%jQuery ( " #list - test " ) . attr (  " list " ,  " datalist "  ) ;%NWL%equal ( jQuery ( " #list - test " ) . attr ( " list " ) ,  " datalist " ,  " Check setting list attribute "  ) ;%NWL%var body = document . body , $body = jQuery ( body ) ;%NWL%strictEqual ( $body . attr ( " foo " ) , undefined ,  " Make sure that a non existent attribute returns undefined "  ) ;%NWL%body . setAttribute (  " foo " ,  " baz "  ) ;%NWL%equal ( $body . attr ( " foo " ) ,  " baz " ,  " Make sure the dom attribute is retrieved when no expando is found "  ) ;%NWL%$body . attr (  " foo " , " cool "  ) ;%NWL%equal ( $body . attr ( " foo " ) ,  " cool " ,  " Make sure that setting works well when both expando and dom attribute are available "  ) ;%NWL%var select = document . createElement ( " select " ) ,%NWL%4
equal ( element . attr ( " tabindex " ) ,  " 0 " ,  " set tabindex to 0 ( string ) "  ) ;%NWL%element . attr (  " tabindex " ,  " - 1 "  ) ;%NWL%equal ( element . attr ( " tabindex " ) ,  " - 1 " ,  " set tabindex to - 1 ( string ) "  ) ;%NWL%element . attr (  " tabindex " , 1 ) ;%NWL%equal ( element . attr ( " tabindex " ) ,  " 1 " ,  " set tabindex to 1 ( number ) "  ) ;%NWL%element . attr (  " tabindex " , 0 ) ;%NWL%equal ( element . attr ( " tabindex " ) ,  " 0 " ,  " set tabindex to 0 ( number ) " ) ;%NWL%element . attr (  " tabindex " ,  - 1 ) ;%NWL%equal ( element . attr ( " tabindex " ) ,  " - 1 " ,  " set tabindex to - 1 ( number ) "  ) ;%NWL%element = jQuery ( " #linkWithTabIndex " ) ;%NWL%element . attr (  " tabindex " ,  - 1 ) ;%NWL%7
equal ( jQuery ( " #table " ) . prop ( " useMap " ) , 1 ,  " Check setting and retrieving useMap "  ) ;%NWL%jQuery ( " #table " ) . prop (  " frameborder " , 1 ) ;%NWL%equal ( jQuery ( " #table " ) . prop ( " frameBorder " ) , 1 ,  " Check setting and retrieving frameBorder "  ) ;%NWL%QUnit . reset ( ) ;%NWL%var body = document . body ,%NWL%$body = jQuery ( body ) ;%NWL%ok ( $body . prop ( " nextSibling " ) === null ,  " Make sure a null expando returns null "  ) ;%NWL%body [ " foo " ] = " bar " ;%NWL%equal ( $body . prop ( " foo " ) ,  " bar " ,  " Make sure the expando is preferred over the dom attribute "  ) ;%NWL%body [ " foo " ] = undefined;%NWL%var select = document . createElement ( " select " ) ,%NWL%4
equal ( element . prop ( " tabindex " ) , 0 ,  " set tabindex to 0 ( string ) "  ) ;%NWL%element . prop (  " tabindex " ,  " - 1 "  ) ;%NWL%equal ( element . prop ( " tabindex " ) ,  - 1 ,  " set tabindex to - 1 ( string ) "  ) ;%NWL%element . prop (  " tabindex " , 1 ) ;%NWL%equal ( element . prop ( " tabindex " ) , 1 ,  " set tabindex to 1 ( number ) "  ) ;%NWL%element . prop (  " tabindex " , 0 ) ;%NWL%equal ( element . prop ( " tabindex " ) , 0 ,  " set tabindex to 0 ( number ) "  ) ;%NWL%element . prop (  " tabindex " ,  - 1 ) ;%NWL%equal ( element . prop ( " tabindex " ) ,  - 1 ,  " set tabindex to - 1 ( number ) "  ) ;%NWL%element = jQuery ( " #linkWithTabIndex " ) ;%NWL%element . prop (  " tabindex " ,  - 1 ) ;%NWL%7
jQuery (  " #firstp "  ) . prop (  " nonexisting " ,  " foo "  ) . removeProp (  " nonexisting "  ) [ 0 ] [ " nonexisting " ] ,%NWL%undefined ,%NWL%" removeprop works correctly on DOM element nodes "%NWL%) ;%NWL%jQuery . each (  [ document , obj ] , function ( i , ele )  {%NWL%var $ele = jQuery ( ele ) ;%NWL%$ele . prop (  " nonexisting " ,  " foo "  ) . removeProp ( " nonexisting " ) ;%NWL%strictEqual ( ele [ " nonexisting " ] , undefined ,  " removeProp works correctly on non DOM element nodes ( bug #7500 ) . "  ) ;%NWL%} ) ;%NWL%jQuery . each (  [ commentNode , textNode , attributeNode ] , function ( i , ele )  {%NWL%$ele . prop (  " nonexisting " ,  " foo "  ) . removeProp ( " nonexisting " ) ;%NWL%6
pass = false;%NWL%}%NWL%}%NWL%ok ( pass ,  " Add Class "  ) ;%NWL%var j = jQuery ( " #nonnodes " ) . contents ( ) ;%NWL%j . addClass ( valueObj ( " asdf " )  ) ;%NWL%ok ( j . hasClass ( " asdf " ) ,  " Check node , textnode , comment for addClass "  ) ;%NWL%div = jQuery ( " <div / > " ) ;%NWL%div . addClass ( valueObj ( " test " )  ) ;%NWL%equal ( div . attr ( " class " ) ,  " test " ,  " Make sure there ' s no extra whitespace . "  ) ;%NWL%div . addClass ( valueObj ( " test " )  ) ;%NWL%8
}%NWL%ok ( pass ,  " Add Class "  ) ;%NWL%var j = jQuery ( " #nonnodes " ) . contents ( ) ;%NWL%j . addClass ( valueObj ( " asdf " )  ) ;%NWL%ok ( j . hasClass ( " asdf " ) ,  " Check node , textnode , comment for addClass "  ) ;%NWL%div = jQuery ( " <div / > " ) ;%NWL%div . addClass ( valueObj ( " test " )  ) ;%NWL%equal ( div . attr ( " class " ) ,  " test " ,  " Make sure there ' s no extra whitespace . "  ) ;%NWL%div . attr (  " class " ,  " foo "  ) ;%NWL%div . addClass ( valueObj ( " test " )  ) ;%NWL%div . attr (  " class " ,  " foo "  ) ;%NWL%8
equal ( div . attr ( " class " ) ,  " foo test " ,  " Make sure there ' s no extra whitespace . "  ) ;%NWL%div . attr (  " class " ,  " foo "  ) ;%NWL%div . addClass ( valueObj ( " bar baz " )  ) ;%NWL%equal ( div . attr ( " class " ) ,  " foo bar baz " ,  " Make sure there isn ' t too much trimming . "  ) ;%NWL%div . removeClass ( ) ;%NWL%div . addClass ( valueObj ( " foo " )  ) . addClass ( valueObj ( " foo " )  ) ;%NWL%equal ( div . attr ( " class " ) ,  " foo " ,  " Do not add the same class twice in separate calls . "  ) ;%NWL%div . addClass ( valueObj ( " fo " )  ) ;%NWL%equal ( div . attr ( " class " ) ,  " foo fo " ,  " Adding a similar class does not get interrupted . "  ) ;%NWL%div . removeClass ( ) . addClass ( " wrap2 " ) ;%NWL%div . removeClass ( ) ;%NWL%4
expect ( 1 ) ;%NWL%var $div = jQuery ( " <div class= ' base second ' >< / div> " ) ;%NWL%$div . removeClass ( undefined ) ;%NWL%ok ( $div . hasClass ( " base " ) && $div . hasClass ( " second " ) ,  " Element still has classes after removeClass ( undefined ) "  ) ;%NWL%} ) ;%NWL%var testToggleClass = function ( valueObj )  {%NWL%expect ( 17 ) ;%NWL%var e = jQuery ( " #firstp " ) ;%NWL%ok ( !e . is ( " . test " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( valueObj ( " test " )  ) ;%NWL%e . toggleClass ( valueObj ( " test " )  ) ;%NWL%9
expect ( 17 ) ;%NWL%var e = jQuery ( " #firstp " ) ;%NWL%ok ( !e . is ( " . test " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( valueObj ( " test " )  ) ;%NWL%ok ( e . is ( " . test " ) ,  " Assert class present "  ) ;%NWL%e . toggleClass ( valueObj ( " test " )  ) ;%NWL%ok ( !e . is ( " . test " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( valueObj ( " test " ) , false ) ;%NWL%ok ( !e . is ( " . test " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( valueObj ( " test " ) , true ) ;%NWL%e . toggleClass ( valueObj ( " test " ) , false ) ;%NWL%7
e . toggleClass ( valueObj ( " testB testC " )  ) ;%NWL%ok (  ( e . is ( " . testA . testC " ) && !e . is ( " . testB " ) ) ,  " Assert 1 class added , 1 class removed , and 1 class kept "  ) ;%NWL%e . toggleClass ( valueObj ( " testA testC " )  ) ;%NWL%ok (  ( !e . is ( " . testA " ) && !e . is ( " . testB " ) && !e . is ( " . testC " ) ) ,  " Assert no class present "  ) ;%NWL%e . toggleClass ( true ) ;%NWL%ok ( e [ 0 ] . className === " " ,  " Assert class is empty ( data was empty ) "  ) ;%NWL%e . addClass ( " testD testE " ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( ) ;%NWL%8
e . toggleClass ( true ) ;%NWL%ok ( e [ 0 ] . className === " " ,  " Assert class is empty ( data was empty ) "  ) ;%NWL%e . addClass ( " testD testE " ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%ok ( jQuery . _data ( e [ 0 ] ,  " __className__ " ) === " testD testE " ,  " Assert data was stored "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present ( restored from data ) "  ) ;%NWL%e . toggleClass ( false ) ;%NWL%e . toggleClass ( true ) ;%NWL%0
e . addClass ( " testD testE " ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%ok ( jQuery . _data ( e [ 0 ] ,  " __className__ " ) === " testD testE " ,  " Assert data was stored "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present ( restored from data ) "  ) ;%NWL%e . toggleClass ( false ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( true ) ;%NWL%e . toggleClass ( ) ;%NWL%2
ok ( e . is ( " . testD . testE " ) ,  " Assert class present "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%ok ( jQuery . _data ( e [ 0 ] ,  " __className__ " ) === " testD testE " ,  " Assert data was stored "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present ( restored from data ) "  ) ;%NWL%e . toggleClass ( false ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( true ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present ( restored from data ) "  ) ;%NWL%e . toggleClass ( false ) ;%NWL%6
e . toggleClass ( ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%ok ( jQuery . _data ( e [ 0 ] ,  " __className__ " ) === " testD testE " ,  " Assert data was stored "  ) ;%NWL%e . toggleClass ( ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present ( restored from data ) "  ) ;%NWL%e . toggleClass ( false ) ;%NWL%ok ( !e . is ( " . testD . testE " ) ,  " Assert class not present "  ) ;%NWL%e . toggleClass ( true ) ;%NWL%ok ( e . is ( " . testD . testE " ) ,  " Assert class present ( restored from data ) "  ) ;%NWL%e . toggleClass ( ) ;%NWL%e . toggleClass ( ) ;%NWL%0
output + = str;%NWL%} ) ;%NWL%cblist . fire ( " A " ) ;%NWL%strictEqual ( output ,  " XA " ,  " Basic binding and firing "  ) ;%NWL%strictEqual ( cblist . fired ( ) , true ,  " . fired ( ) detects firing "  ) ;%NWL%output = " X " ;%NWL%cblist . disable ( ) ;%NWL%cblist . add ( function ( str )  {%NWL%output + = str;%NWL%} ) ;%NWL%cblist . fire ( " A " ) ;%NWL%2
output = " " ;%NWL%cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( function ( )  {%NWL%equal ( this , window ,  " fireWith with no arguments ( context is window ) "  ) ;%NWL%strictEqual ( arguments . length , 0 ,  " fireWith with no arguments ( no arguments ) "  ) ;%NWL%} ) ;%NWL%cblist . fireWith ( ) ;%NWL%output = " X " ;%NWL%cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( outputA , outputB , outputC ) ;%NWL%cblist . fire ( ) ;%NWL%6
output = " X " ;%NWL%cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( outputA , outputB , outputC ) ;%NWL%cblist . remove ( outputB , outputC ) ;%NWL%cblist . fire ( ) ;%NWL%strictEqual ( output ,  " XA " ,  " Basic binding , removing and firing "  ) ;%NWL%output = " X " ;%NWL%cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( outputA ) ;%NWL%cblist . add ( outputB ) ;%NWL%cblist . empty ( ) ;%NWL%4
cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( outputA , outputB , outputC ) ;%NWL%cblist . remove ( outputB , outputC ) ;%NWL%cblist . fire ( ) ;%NWL%strictEqual ( output ,  " XA " ,  " Basic binding , removing and firing "  ) ;%NWL%output = " X " ;%NWL%cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( outputA ) ;%NWL%cblist . add ( outputB ) ;%NWL%cblist . add ( outputC ) ;%NWL%cblist . fire ( ) ;%NWL%3
cblist . add ( outputA ) ;%NWL%cblist . add ( outputB ) ;%NWL%cblist . add ( outputC ) ;%NWL%cblist . empty ( ) ;%NWL%cblist . fire ( ) ;%NWL%strictEqual ( output ,  " X " ,  " Empty "  ) ;%NWL%output = " X " ;%NWL%cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( function ( str )  {%NWL%output + = str;%NWL%cblist . lock ( ) ;%NWL%3
strictEqual ( output ,  " X " ,  " Lock early "  ) ;%NWL%output = " X " ;%NWL%cblist = jQuery . Callbacks ( flags ) ;%NWL%cblist . add ( function ( )  {%NWL%cblist . add ( outputC ) ;%NWL%outputA ( ) ;%NWL%} , outputB ) ;%NWL%cblist . fire ( ) ;%NWL%strictEqual ( output , results . shift ( ) ,  " Proper ordering "  ) ;%NWL%output = " X " ;%NWL%cblist . add ( outputC ) ;%NWL%4
outputA ( ) ;%NWL%} , outputB ) ;%NWL%cblist . fire ( ) ;%NWL%strictEqual ( output , results . shift ( ) ,  " Proper ordering "  ) ;%NWL%output = " X " ;%NWL%cblist . add ( function ( )  {%NWL%cblist . add ( outputC ) ;%NWL%outputA ( ) ;%NWL%} , outputB ) ;%NWL%strictEqual ( output , results . shift ( ) ,  " Add after fire "  ) ;%NWL%cblist . fire ( ) ;%NWL%2
cb . remove ( getB ) ;%NWL%strictEqual ( cb . has ( getB ) , false ,  " Remove a specific callback function and make sure its no longer there "  ) ;%NWL%strictEqual ( cb . has ( getA ) , true ,  " Remove a specific callback function and make sure other callback function is still there "  ) ;%NWL%cb . empty ( ) ;%NWL%strictEqual ( cb . has ( ) , false ,  " Empty list and make sure there are no callback function ( s ) "  ) ;%NWL%strictEqual ( cb . has ( getA ) , false ,  " Check for a specific function in an empty ( ) list "  ) ;%NWL%cb . add ( getA , getB , function ( ) {%NWL%strictEqual ( cb . has ( ) , true ,  " Check if list has callback function ( s ) from within a callback function "  ) ;%NWL%strictEqual ( cb . has ( getA ) , true ,  " Check if list has a specific callback from within a callback function "  ) ;%NWL%} ) . fire ( ) ;%NWL%cb . disable ( ) ;%NWL%3
strictEqual ( cb . has ( ) , true ,  " Check if list has callback function ( s ) from within a callback function "  ) ;%NWL%strictEqual ( cb . has ( getA ) , true ,  " Check if list has a specific callback from within a callback function "  ) ;%NWL%} ) . fire ( ) ;%NWL%strictEqual ( cb . has ( ) , true ,  " Callbacks list has callback function ( s ) after firing "  ) ;%NWL%cb . disable ( ) ;%NWL%strictEqual ( cb . has ( ) , false ,  " disabled ( ) list has no callback functions ( returns false ) "  ) ;%NWL%strictEqual ( cb . has ( getA ) , false ,  " Check for a specific function in a disabled ( ) list "  ) ;%NWL%cb = jQuery . Callbacks ( " unique " ) ;%NWL%cb . add ( getA ) ;%NWL%cb . add ( getA ) ;%NWL%cb . lock ( ) ;%NWL%4
equal ( elem [ 0 ] . childNodes . length , 1 ,  " jQuery quick setter text " ) ;%NWL%equal ( elem [ 0 ] . firstChild . nodeValue ,  " test " ,  " jQuery quick setter text " ) ;%NWL%equal ( elem [ 0 ] . className ,  " test2 " ,  " jQuery ( ) quick setter class " ) ;%NWL%equal ( elem [ 0 ] . id ,  " test3 " ,  " jQuery ( ) quick setter id " ) ;%NWL%exec = true;%NWL%elem . trigger ( " click " ) ;%NWL%elem . remove ( ) ;%NWL%for ( i = 0; i < 3; + + i )  {%NWL%elem = jQuery ( " <input type= ' text ' value= ' TEST '  / > " ) ;%NWL%}%NWL%elem . remove ( ) ;%NWL%6
window . iframeCallback = function ( otherObject , detail )  {%NWL%window . iframeCallback = undefined;%NWL%iframe . parentNode . removeChild ( iframe ) ;%NWL%ok ( jQuery . isPlainObject ( new otherObject ( ) ) ,  " new otherObject "  +  ( detail ? "  -  "  + detail : " "  )  ) ;%NWL%start ( ) ;%NWL%} ;%NWL%try {%NWL%iframe = jQuery ( " #qunit - fixture " ) [ 0 ] . appendChild ( document . createElement ( " iframe " )  ) ;%NWL%doc = iframe . contentDocument || iframe . contentWindow . document;%NWL%doc . open ( ) ;%NWL%doc . close ( ) ;%NWL%9
ok ( jQuery . isFunction ( fn ) ,  " Normal Function "  ) ;%NWL%var obj = document . createElement ( " object " ) ;%NWL%ok ( !jQuery . isFunction ( obj ) ,  " Object Element "  ) ;%NWL%var nodes = document . body . childNodes;%NWL%ok ( !jQuery . isFunction ( nodes ) ,  " childNodes Property "  ) ;%NWL%var first = document . body . firstChild;%NWL%ok ( !jQuery . isFunction ( first ) ,  " A normal DOM Element "  ) ;%NWL%var input = document . createElement ( " input " ) ;%NWL%input . type = " text " ;%NWL%document . body . appendChild ( input ) ;%NWL%var a = document . createElement ( " a " ) ;%NWL%7
jQuery . extend ( true , empty , optionsWithDate ) ;%NWL%deepEqual ( empty [ " foo " ] , optionsWithDate [ " foo " ] ,  " Dates copy correctly "  ) ;%NWL%%NWL%var myKlass = function ( )  { } ;%NWL%var customObject = new myKlass ( ) ;%NWL%var optionsWithCustomObject = {  " foo " : {  " date " : customObject }  } ;%NWL%empty = { } ;%NWL%jQuery . extend ( true , empty , optionsWithCustomObject ) ;%NWL%ok ( empty [ " foo " ] && empty [ " foo " ] [ " date " ] === customObject ,  " Custom objects copy correctly ( no methods ) "  ) ;%NWL%myKlass . prototype = {  " someMethod " : function ( ) { }  } ;%NWL%jQuery . extend ( true , empty , optionsWithCustomObject ) ;%NWL%7
deepEqual ( seen ,  { name: " name " , lang: " lang "  } ,  " Object iteration "  ) ;%NWL%seen = [ ] ;%NWL%jQuery . each (  [ 1 , 2 , 3 ] , function ( k , v )  {%NWL%seen . push ( v ) ;%NWL%if ( k === 1 )  {%NWL%return false;%NWL%}%NWL%} ) ;%NWL%deepEqual ( seen ,  [ 1 , 2 ]  ,  " Broken array iteration "  ) ;%NWL%seen = [ ] ;%NWL%seen . push ( v ) ;%NWL%3
equal ( computedSize , expectedSize ,  " Div # "  + index +  " should be "  + expectedSize ) ;%NWL%index + + ;%NWL%return computedSize;%NWL%} } ) ;%NWL%jQuery ( " #cssFunctionTest " ) . remove ( ) ;%NWL%} ) ;%NWL%test ( " show ( ) ; hide ( ) " , function ( )  {%NWL%expect ( 22 ) ;%NWL%var hiddendiv = jQuery ( " div . hidden " ) ;%NWL%hiddendiv . hide ( ) ;%NWL%hiddendiv . show ( ) ;%NWL%9
hiddendiv . show ( ) ;%NWL%equal ( hiddendiv . css ( " display " ) ,  " block " ,  " Pre - hidden div shown "  ) ;%NWL%var div = jQuery ( " <div> " ) . hide ( ) ;%NWL%equal ( div . css ( " display " ) ,  " none " ,  " Detached div hidden "  ) ;%NWL%div . appendTo ( " #qunit - fixture " ) . show ( ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Pre - hidden div shown "  ) ;%NWL%QUnit . reset ( ) ;%NWL%hiddendiv = jQuery ( " div . hidden " ) ;%NWL%equal ( jQuery . css ( hiddendiv [ 0 ] ,  " display " ) ,  " none " ,  " hiddendiv is display: none " ) ;%NWL%hiddendiv . css ( " display " ,  " block " ) ;%NWL%hiddendiv . show ( ) ;%NWL%0
equal ( dfn8099 . show ( ) . css ( " display " ) ,  " inline " ,  " Correctly resolves display:inline "  ) ;%NWL%tt8099 . remove ( ) ;%NWL%dfn8099 . remove ( ) ;%NWL%} ) ;%NWL%test (  " show ( ) resolves correct default display for detached nodes " , function ( ) {%NWL%expect ( 13 ) ;%NWL%var div , span , tr , trDisplay;%NWL%div = jQuery ( " <div class= ' hidden ' > " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through stylesheets ) div is visible . "  ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%8
var div , span , tr , trDisplay;%NWL%div = jQuery ( " <div class= ' hidden ' > " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through stylesheets ) div is visible . "  ) ;%NWL%div = jQuery ( " <div style= ' display: none ' > " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through inline style ) div is visible . "  ) ;%NWL%span = jQuery ( " <span class= ' hidden ' / > " ) ;%NWL%span . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached , pre - hidden ( through stylesheets ) span has default display . "  ) ;%NWL%span . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%8
equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through stylesheets ) div is visible . "  ) ;%NWL%div = jQuery ( " <div style= ' display: none ' > " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through inline style ) div is visible . "  ) ;%NWL%span = jQuery ( " <span class= ' hidden ' / > " ) ;%NWL%span . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached , pre - hidden ( through stylesheets ) span has default display . "  ) ;%NWL%span = jQuery ( " <span style= ' display: inline ' / > " ) ;%NWL%span . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached , pre - hidden ( through inline style ) span has default display . "  ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%2
equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through inline style ) div is visible . "  ) ;%NWL%span = jQuery ( " <span class= ' hidden ' / > " ) ;%NWL%span . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached , pre - hidden ( through stylesheets ) span has default display . "  ) ;%NWL%span = jQuery ( " <span style= ' display: inline ' / > " ) ;%NWL%span . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached , pre - hidden ( through inline style ) span has default display . "  ) ;%NWL%div = jQuery ( " <div><div class= ' hidden ' >< / div>< / div> " ) . children ( " div " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through stylesheets ) div inside another visible div is visible . "  ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%8
div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached , pre - hidden ( through inline style ) div inside another visible div is visible . "  ) ;%NWL%div = jQuery ( " div . hidden " ) ;%NWL%div . detach ( ) . show ( ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden div is visible . "  ) ;%NWL%div . remove ( ) ;%NWL%span = jQuery ( " <span> " ) ;%NWL%span . appendTo ( " #qunit - fixture " ) . detach ( ) . show ( ) . appendTo ( " #qunit - fixture "  ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden span has default display . "  ) ;%NWL%span . remove ( ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%0
div = jQuery ( " div . hidden " ) ;%NWL%div . detach ( ) . show ( ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden div is visible . "  ) ;%NWL%div . remove ( ) ;%NWL%span = jQuery ( " <span> " ) ;%NWL%span . appendTo ( " #qunit - fixture " ) . detach ( ) . show ( ) . appendTo ( " #qunit - fixture "  ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden span has default display . "  ) ;%NWL%span . remove ( ) ;%NWL%div = jQuery ( " <div> " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%div . remove ( ) ;%NWL%3
equal ( div . css ( " display " ) ,  " block " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden div is visible . "  ) ;%NWL%div . remove ( ) ;%NWL%span = jQuery ( " <span> " ) ;%NWL%span . appendTo ( " #qunit - fixture " ) . detach ( ) . show ( ) . appendTo ( " #qunit - fixture "  ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden span has default display . "  ) ;%NWL%span . remove ( ) ;%NWL%div = jQuery ( " <div> " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%ok ( !!div . get ( 0 ) . style . display ,  " Make sure not hidden div has a inline style . "  ) ;%NWL%div . remove ( ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%7
span = jQuery ( " <span> " ) ;%NWL%span . appendTo ( " #qunit - fixture " ) . detach ( ) . show ( ) . appendTo ( " #qunit - fixture "  ) ;%NWL%equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden span has default display . "  ) ;%NWL%span . remove ( ) ;%NWL%div = jQuery ( " <div> " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%ok ( !!div . get ( 0 ) . style . display ,  " Make sure not hidden div has a inline style . "  ) ;%NWL%div . remove ( ) ;%NWL%div = jQuery ( document . createElement ( " div " )  ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%div . remove ( ) ;%NWL%7
equal ( span . css ( " display " ) ,  " inline " ,  " Make sure a detached ( through detach ( )  ) , pre - hidden span has default display . "  ) ;%NWL%span . remove ( ) ;%NWL%div = jQuery ( " <div> " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%ok ( !!div . get ( 0 ) . style . display ,  " Make sure not hidden div has a inline style . "  ) ;%NWL%div . remove ( ) ;%NWL%div = jQuery ( document . createElement ( " div " )  ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a pre - created element has default display . "  ) ;%NWL%div . remove ( ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%3
div = jQuery ( " <div> " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%ok ( !!div . get ( 0 ) . style . display ,  " Make sure not hidden div has a inline style . "  ) ;%NWL%div . remove ( ) ;%NWL%div = jQuery ( document . createElement ( " div " )  ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " block " ,  " Make sure a pre - created element has default display . "  ) ;%NWL%div . remove ( ) ;%NWL%div = jQuery ( " <div style= ' display: inline ' / > " ) ;%NWL%div . show ( ) . appendTo ( " #qunit - fixture " ) ;%NWL%div . remove ( ) ;%NWL%3
jQuery ( " #ddisplay " ) . remove ( ) ;%NWL%QUnit . expectJqData ( body [ 0 ] ,  " olddisplay "  ) ;%NWL%} ) ;%NWL%test ( " show ( ) resolves correct default display when iframe display:none #12904 " , function ( )  {%NWL%expect ( 2 ) ;%NWL%var ddisplay = jQuery (%NWL%" <p id= ' ddisplay ' >a<style>p { display:none } iframe { display:none !important } < / style>< / p> "%NWL%) . appendTo ( " body " ) ;%NWL%equal ( ddisplay . css ( " display " ) ,  " none " ,  " Initial display: none "  ) ;%NWL%ddisplay . show ( ) ;%NWL%ddisplay . remove ( ) ;%NWL%9
ddisplay . show ( ) ;%NWL%equal ( ddisplay . css ( " display " ) ,  " block " ,  " Correct display: block "  ) ;%NWL%ddisplay . remove ( ) ;%NWL%} ) ;%NWL%test ( " toggle ( ) " , function ( )  {%NWL%expect ( 9 ) ;%NWL%var div ,%NWL%x = jQuery ( " #foo " ) ;%NWL%ok ( x . is ( " :visible " ) ,  " is visible "  ) ;%NWL%x . toggle ( ) ;%NWL%x . toggle ( ) ;%NWL%9
var div ,%NWL%x = jQuery ( " #foo " ) ;%NWL%ok ( x . is ( " :visible " ) ,  " is visible "  ) ;%NWL%x . toggle ( ) ;%NWL%ok ( x . is ( " :hidden " ) ,  " is hidden "  ) ;%NWL%x . toggle ( ) ;%NWL%ok ( x . is ( " :visible " ) ,  " is visible again "  ) ;%NWL%x . toggle ( true ) ;%NWL%ok ( x . is ( " :visible " ) ,  " is visible "  ) ;%NWL%x . toggle ( false ) ;%NWL%x . toggle ( true ) ;%NWL%7
} ;%NWL%x . toggle ( name === " show "  ) ;%NWL%jQuery . fn . hide = oldHide;%NWL%} ) ;%NWL%test ( " hide hidden elements ( bug #7141 ) " , function ( )  {%NWL%expect ( 3 ) ;%NWL%QUnit . reset ( ) ;%NWL%var div = jQuery ( " <div style= ' display:none ' >< / div> " ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " none " ,  " Element is hidden by default "  ) ;%NWL%div . hide ( ) ;%NWL%div . show ( ) ;%NWL%9
jQuery . fn . hide = oldHide;%NWL%} ) ;%NWL%test ( " hide hidden elements ( bug #7141 ) " , function ( )  {%NWL%expect ( 3 ) ;%NWL%QUnit . reset ( ) ;%NWL%var div = jQuery ( " <div style= ' display:none ' >< / div> " ) . appendTo ( " #qunit - fixture " ) ;%NWL%equal ( div . css ( " display " ) ,  " none " ,  " Element is hidden by default "  ) ;%NWL%div . hide ( ) ;%NWL%ok ( !jQuery . _data ( div ,  " olddisplay " ) ,  " olddisplay is undefined after hiding an already - hidden element "  ) ;%NWL%div . show ( ) ;%NWL%div . remove ( ) ;%NWL%7
} , 100 ) ;%NWL%} ) ;%NWL%window . setTimeout ( start , 1000 ) ;%NWL%} ) ;%NWL%asyncTest (  " Make sure initialized display value for disconnected nodes is correct ( #13310 ) " , 4 , function ( )  {%NWL%var display = jQuery ( " #display " ) . css ( " display " ) ,%NWL%div = jQuery ( " <div / > " ) ;%NWL%equal ( div . css (  " display " ,  " inline "  ) . hide ( ) . show ( ) . appendTo ( " body " ) . css (  " display "  ) ,  " inline " ,  " Initialized display value has returned "  ) ;%NWL%div . remove ( ) ;%NWL%div . css (  " display " ,  " none "  ) . hide ( ) ;%NWL%div . remove ( ) ;%NWL%8
} ) ;%NWL%asyncTest (  " Make sure initialized display value for disconnected nodes is correct ( #13310 ) " , 4 , function ( )  {%NWL%var display = jQuery ( " #display " ) . css ( " display " ) ,%NWL%div = jQuery ( " <div / > " ) ;%NWL%equal ( div . css (  " display " ,  " inline "  ) . hide ( ) . show ( ) . appendTo ( " body " ) . css (  " display "  ) ,  " inline " ,  " Initialized display value has returned "  ) ;%NWL%div . remove ( ) ;%NWL%div . css (  " display " ,  " none "  ) . hide ( ) ;%NWL%equal ( jQuery . _data ( div [ 0 ] ,  " olddisplay "  ) , undefined ,  " olddisplay is undefined after hiding a detached and hidden element "  ) ;%NWL%div . remove ( ) ;%NWL%div . css (  " display " ,  " inline - block "  ) . hide ( ) . appendTo ( " body " ) . fadeIn ( function ( )  {%NWL%div . remove ( ) ;%NWL%5
notStrictEqual ( dataObj , internalDataObj ,  " Internal data object is not the same as user data object "  ) ;%NWL%strictEqual ( elem . boom , undefined ,  " Data is never stored directly on the object "  ) ;%NWL%jQuery . removeData ( elem ,  " foo " ) ;%NWL%strictEqual ( jQuery . data ( elem ,  " foo " ) , undefined ,  " jQuery . removeData removes single properties "  ) ;%NWL%jQuery . removeData ( elem ) ;%NWL%strictEqual ( jQuery . _data ( elem ) , internalDataObj ,  " jQuery . removeData does not remove internal data if it exists "  ) ;%NWL%jQuery . data ( elem ,  " foo " ,  " foo1 " ) ;%NWL%jQuery . _data ( elem ,  " foo " ,  " foo2 " ) ;%NWL%equal ( jQuery . data ( elem ,  " foo " ) ,  " foo1 " ,  " ( sanity check ) Ensure data is set in user data object "  ) ;%NWL%equal ( jQuery . _data ( elem ,  " foo " ) ,  " foo2 " ,  " ( sanity check ) Ensure data is set in internal data object "  ) ;%NWL%jQuery . _data ( elem ,  " foo " ,  " foo2 " ) ;%NWL%7
jQuery . removeData ( elem ,  " foo " ) ;%NWL%strictEqual ( jQuery . data ( elem ,  " foo " ) , undefined ,  " jQuery . removeData removes single properties "  ) ;%NWL%jQuery . removeData ( elem ) ;%NWL%strictEqual ( jQuery . _data ( elem ) , internalDataObj ,  " jQuery . removeData does not remove internal data if it exists "  ) ;%NWL%jQuery . data ( elem ,  " foo " ,  " foo1 " ) ;%NWL%jQuery . _data ( elem ,  " foo " ,  " foo2 " ) ;%NWL%equal ( jQuery . data ( elem ,  " foo " ) ,  " foo1 " ,  " ( sanity check ) Ensure data is set in user data object "  ) ;%NWL%equal ( jQuery . _data ( elem ,  " foo " ) ,  " foo2 " ,  " ( sanity check ) Ensure data is set in internal data object "  ) ;%NWL%strictEqual ( jQuery . _data ( elem , jQuery . expando ) , undefined ,  " Removing the last item in internal data destroys the internal data object "  ) ;%NWL%jQuery . _data ( elem ,  " foo " ,  " foo2 " ) ;%NWL%jQuery . removeData ( elem ,  " foo " ) ;%NWL%0
equal ( jQuery . data ( obj ,  " test " ) , undefined ,  " Check removal of data on plain object "  ) ;%NWL%jQuery . data ( window ,  " BAD " , true ) ;%NWL%jQuery . removeData ( window ,  " BAD "  ) ;%NWL%ok ( !jQuery . data ( window ,  " BAD "  ) ,  " Make sure that the value was not still set . "  ) ;%NWL%} ) ;%NWL%test ( " . removeData ( ) " , function ( )  {%NWL%expect ( 6 ) ;%NWL%var div = jQuery ( " #foo " ) ;%NWL%div . data ( " test " ,  " testing " ) ;%NWL%div . removeData ( " test " ) ;%NWL%div . data ( " test " ,  " testing " ) ;%NWL%8
test ( " . removeData ( ) " , function ( )  {%NWL%expect ( 6 ) ;%NWL%var div = jQuery ( " #foo " ) ;%NWL%div . data ( " test " ,  " testing " ) ;%NWL%div . removeData ( " test " ) ;%NWL%equal ( div . data ( " test " ) , undefined ,  " Check removal of data "  ) ;%NWL%div . data ( " test " ,  " testing " ) ;%NWL%div . data ( " test . foo " ,  " testing2 " ) ;%NWL%div . removeData ( " test . bar " ) ;%NWL%equal ( div . data ( " test . foo " ) ,  " testing2 " ,  " Make sure data is intact "  ) ;%NWL%div . removeData ( " test " ) ;%NWL%4
ok (%NWL%jQuery . isFunction (%NWL%jQuery . when ( value ) . done ( function ( resolveValue )  {%NWL%strictEqual ( this , window ,  " Context is the global object with "  + message ) ;%NWL%strictEqual ( resolveValue , value ,  " Test the promise was resolved with "  + message ) ;%NWL%} ) . promise%NWL%) ,%NWL%" Test "  + message +  " triggers the creation of a new Promise "%NWL%) ;%NWL%}  ) ;%NWL%jQuery . isFunction (%NWL%1
return function ( )  {%NWL%return val;%NWL%} ;%NWL%} ;%NWL%var testWidth = function ( val )  {%NWL%expect ( 9 ) ;%NWL%var $div = jQuery ( " #nothiddendiv " ) ;%NWL%$div . width ( val ( 30 )  ) ;%NWL%equal ( $div . width ( ) , 30 ,  " Test set to 30 correctly " ) ;%NWL%$div . hide ( ) ;%NWL%$div . show ( ) ;%NWL%9
return width + 1;%NWL%} ) ;%NWL%equal ( $div . width ( ) , 31 ,  " Make sure value was modified correctly . "  ) ;%NWL%} ) ;%NWL%var testHeight = function ( val )  {%NWL%expect ( 9 ) ;%NWL%var $div = jQuery ( " #nothiddendiv " ) ;%NWL%$div . height ( val ( 30 )  ) ;%NWL%equal ( $div . height ( ) , 30 ,  " Test set to 30 correctly " ) ;%NWL%$div . hide ( ) ;%NWL%$div . show ( ) ;%NWL%9
forceScroll . appendTo ( " body " ) ;%NWL%window . scrollTo ( 200 , 200 ) ;%NWL%supportsScroll = document . documentElement . scrollTop || document . body . scrollTop;%NWL%forceScroll . detach ( ) ;%NWL%supportsFixedPosition = checkFixed [ 0 ] . offsetTop === 20 || checkFixed [ 0 ] . offsetTop === 15;%NWL%checkFixed . remove ( ) ;%NWL%} ;%NWL%module ( " offset " ,  { setup: function ( ) {%NWL%if ( typeof checkSupport === " function "  )  {%NWL%checkSupport ( ) ;%NWL%forceScroll . appendTo ( " body " ) ;%NWL%0
supportsScroll = document . documentElement . scrollTop || document . body . scrollTop;%NWL%forceScroll . detach ( ) ;%NWL%supportsFixedPosition = checkFixed [ 0 ] . offsetTop === 20 || checkFixed [ 0 ] . offsetTop === 15;%NWL%checkFixed . remove ( ) ;%NWL%} ;%NWL%module ( " offset " ,  { setup: function ( ) {%NWL%if ( typeof checkSupport === " function "  )  {%NWL%checkSupport ( ) ;%NWL%}%NWL%forceScroll . appendTo ( " body " ) ;%NWL%forceScroll . detach ( ) ;%NWL%1
equal (  + + counter , 4 ,  " Dequeuing "  ) ;%NWL%} ) ;%NWL%defer = $div . promise ( " foo " ) . done ( function ( )  {%NWL%equal ( counter , 4 ,  " Testing previous call to dequeue in deferred "  ) ;%NWL%start ( ) ;%NWL%} ) ;%NWL%equal ( $div . queue ( " foo " ) . length , 4 ,  " Testing queue length "  ) ;%NWL%equal ( $div . queue ( " foo " , undefined ) . queue ( " foo " ) . length , 4 ,  " . queue ( ' name ' , undefined ) does nothing but is chainable ( #5571 ) " ) ;%NWL%$div . dequeue ( " foo " ) ;%NWL%equal ( counter , 3 ,  " Testing previous call to dequeue "  ) ;%NWL%$div . dequeue ( " foo " ) ;%NWL%8
equal ( counter , 4 ,  " Testing previous call to dequeue in deferred "  ) ;%NWL%start ( ) ;%NWL%} ) ;%NWL%equal ( $div . queue ( " foo " ) . length , 4 ,  " Testing queue length "  ) ;%NWL%equal ( $div . queue ( " foo " , undefined ) . queue ( " foo " ) . length , 4 ,  " . queue ( ' name ' , undefined ) does nothing but is chainable ( #5571 ) " ) ;%NWL%$div . dequeue ( " foo " ) ;%NWL%equal ( counter , 3 ,  " Testing previous call to dequeue "  ) ;%NWL%equal ( $div . queue ( " foo " ) . length , 1 ,  " Testing queue length "  ) ;%NWL%$div . dequeue ( " foo " ) ;%NWL%equal ( counter , 4 ,  " Testing previous call to dequeue "  ) ;%NWL%$div . dequeue ( " foo " ) ;%NWL%5
var result = target . apply (%NWL%self ,%NWL%args . concat ( slice . call ( arguments ) )%NWL%) ;%NWL%if ( Object ( result ) === result )  {%NWL%return result;%NWL%}%NWL%return self;%NWL%} else {%NWL%return target . apply (%NWL%args . concat ( slice . call ( arguments ) )%NWL%2
tests [ ' svgclippaths ' ] = function ( )  {%NWL%return !!document . createElementNS && / SVGClipPath / . test ( toString . call ( document . createElementNS ( ns . svg ,  ' clipPath ' ) ) ) ;%NWL%} ;%NWL%%NWL%function webforms ( )  {%NWL%%NWL%Modernizr [ ' input ' ] = ( function ( props )  {%NWL%for ( var i = 0 , len = props . length; i < len; i + +  )  {%NWL%attrs [ props [ i ]  ] = !! ( props [ i ] in inputElem ) ;%NWL%}%NWL%attrs . list = !! ( document . createElement ( ' datalist ' ) && window . HTMLDataListElement ) ;%NWL%8
inputElem . setAttribute ( ' type ' , inputElemType = props [ i ] ) ;%NWL%bool = inputElem . type !== ' text ' ;%NWL%if ( bool )  {%NWL%inputElem . value     = smile;%NWL%inputElem . style . cssText = ' position:absolute;visibility:hidden; ' ;%NWL%if (  / ^range$ / . test ( inputElemType ) && inputElem . style . WebkitAppearance !== undefined )  {%NWL%docElement . appendChild ( inputElem ) ;%NWL%defaultView = document . defaultView;%NWL%bool = defaultView . getComputedStyle &&%NWL%defaultView . getComputedStyle ( inputElem , null ) . WebkitAppearance !== ' textfield ' &&%NWL%docElement . removeChild ( inputElem ) ;%NWL%6
var artboardBounds = jQuery ( ' . artboard ' ) [ 0 ] . getBoundingClientRect ( ) ;%NWL%var width = artboardBounds . width ,%NWL%height = artboardBounds . height;%NWL%var stack = d3 . layout . stack ( ) . offset ( " wiggle " ) ,%NWL%1
} else {%NWL%x = appearance . scene . x - 0 . 5 * scale;%NWL%y = appearance . scene . y + appearance . y;%NWL%if ( x - labelSize [ 0 ] < labelSize [ 0 ] )  {%NWL%x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%introduction . x = appearance . character . _x || Math . max ( 0 , Math . min ( size [ 0 ] - labelSize [ 0 ] , x ) ) ;%NWL%8
x = appearance . scene . x - 0 . 5 * scale;%NWL%y = appearance . scene . y + appearance . y;%NWL%if ( x - labelSize [ 0 ] < labelSize [ 0 ] )  {%NWL%x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%} else {%NWL%introduction . y = appearance . character . _y || Math . max ( 0 + labelSize [ 1 ] / 2 , Math . min ( size [ 1 ] - labelSize [ 1 ] / 2 , y ) ) ;%NWL%7
if ( x - labelSize [ 0 ] < labelSize [ 0 ] )  {%NWL%x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%} else {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 , Math . min ( size [ 0 ] - labelSize [ 0 ] , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 + labelSize [ 1 ] / 2 , Math . min ( size [ 1 ] - labelSize [ 1 ] / 2 , y ) ) ;%NWL%introduction . width = appearance . character . _width || labelSize [ 0 ] ;%NWL%5
x = labelSize [ 0 ] ;%NWL%}%NWL%}%NWL%if ( orientation === ' vertical ' )  {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 + labelSize [ 0 ] / 2 , Math . min ( size [ 0 ] - labelSize [ 0 ] / 2 , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 , Math . min ( size [ 1 ] - labelSize [ 1 ] , y ) ) ;%NWL%} else {%NWL%introduction . x = appearance . character . _x || Math . max ( 0 , Math . min ( size [ 0 ] - labelSize [ 0 ] , x ) ) ;%NWL%introduction . y = appearance . character . _y || Math . max ( 0 + labelSize [ 1 ] / 2 , Math . min ( size [ 1 ] - labelSize [ 1 ] / 2 , y ) ) ;%NWL%}%NWL%introduction . height = appearance . character . _height || labelSize [ 1 ] ;%NWL%4
documentElement = document . documentElement ,%NWL%getComputedStyle = window . getComputedStyle ,%NWL%supports;%NWL%if ( ! ( ' pointerEvents ' in element . style ) ) {%NWL%return false;%NWL%}%NWL%element . style . pointerEvents = ' auto ' ;%NWL%element . style . pointerEvents = ' x ' ;%NWL%documentElement . appendChild ( element ) ;%NWL%supports = getComputedStyle &&%NWL%documentElement . removeChild ( element ) ;%NWL%8
radius = Math . min ( width , height )  / 2;%NWL%var x = d3 . scale . linear ( )%NWL%. range ( [ 0 , 2 * Math . PI ] ) ;%NWL%var y = d3 . scale . sqrt ( )%NWL%. range ( [ 0 , radius ] ) ;%NWL%var color = d3 . scale . category20c ( ) ;%NWL%var svg = d3 . select ( " body " ) . append ( " svg " )%NWL%. attr ( " width " , width )%NWL%. attr ( " height " , height )%NWL%. append ( " g " )%NWL%var partition = d3 . layout . partition ( )%NWL%6
. range ( [ 0 , 2 * Math . PI ] ) ;%NWL%var y = d3 . scale . sqrt ( )%NWL%. range ( [ 0 , radius ] ) ;%NWL%var color = d3 . scale . category20c ( ) ;%NWL%var svg = d3 . select ( " body " ) . append ( " svg " )%NWL%. attr ( " width " , width )%NWL%. attr ( " height " , height )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + width / 2 +  " , "  +  ( height / 2 + 10 )  +  " ) " ) ;%NWL%var partition = d3 . layout . partition ( )%NWL%var arc = d3 . svg . arc ( )%NWL%4
. attr ( " height " , height )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + width / 2 +  " , "  +  ( height / 2 + 10 )  +  " ) " ) ;%NWL%var partition = d3 . layout . partition ( )%NWL%. value ( function ( d )  { return d . size; } ) ;%NWL%var arc = d3 . svg . arc ( )%NWL%. startAngle ( function ( d )  { return Math . max ( 0 , Math . min ( 2 * Math . PI , x ( d . x ) ) ) ; } )%NWL%. endAngle ( function ( d )  { return Math . max ( 0 , Math . min ( 2 * Math . PI , x ( d . x + d . dx ) ) ) ; } )%NWL%. innerRadius ( function ( d )  { return Math . max ( 0 , y ( d . y ) ) ; } )%NWL%. outerRadius ( function ( d )  { return Math . max ( 0 , y ( d . y + d . dy ) ) ; } ) ;%NWL%var path = svg . selectAll ( " path " )%NWL%3
root = doc . body || ( function ( )  {%NWL%var de = doc . documentElement;%NWL%fake = true;%NWL%return de . insertBefore ( doc . createElement ( ' body ' ) , de . firstElementChild || de . firstChild ) ;%NWL%} ( ) ) ;%NWL%el . innerHTML = ' <summary>a< / summary>b ' ;%NWL%el . style . display = ' block ' ;%NWL%root . appendChild ( el ) ;%NWL%diff = el . offsetHeight;%NWL%el . open = true;%NWL%root . removeChild ( el ) ;%NWL%7
return de . insertBefore ( doc . createElement ( ' body ' ) , de . firstElementChild || de . firstChild ) ;%NWL%} ( ) ) ;%NWL%el . innerHTML = ' <input type= " number " value= " 1 . 0 " step= " 0 . 1 " / > ' ;%NWL%input = el . childNodes [ 0 ] ;%NWL%root . appendChild ( el ) ;%NWL%input . focus ( ) ;%NWL%try {%NWL%doc . execCommand ( ' InsertText ' , false ,  ' 1 , 1 ' ) ;%NWL%} catch ( e )  {  / / prevent warnings in IE%NWL%}%NWL%root . removeChild ( el ) ;%NWL%4
( function ( )  {%NWL%var DPI ,%NWL%e = document . body . appendChild ( document . createElement ( ' DIV ' ) ) ;%NWL%e . style . padding = ' 0 ' ;%NWL%2
( function ( document , Modernizr ) {%NWL%Modernizr . formvalidationapi = false;%NWL%Modernizr . formvalidationmessage = false;%NWL%Modernizr . addTest ( ' formvalidation ' , function ( ) {%NWL%var form = document . createElement ( ' form ' ) ;%NWL%if ( ! ( ' checkValidity ' in form )  )  {%NWL%return false;%NWL%var body = document . body ,%NWL%4
}%NWL%var body = document . body ,%NWL%html = document . documentElement ,%NWL%bodyFaked = false ,%NWL%invaildFired = false ,%NWL%input;%NWL%Modernizr . formvalidationapi = true;%NWL%form . onsubmit = function ( e )  {%NWL%if ( !window . opera )  {%NWL%e . preventDefault ( ) ;%NWL%e . stopPropagation ( ) ;%NWL%9
html . appendChild ( body ) ;%NWL%}%NWL%body . appendChild ( form ) ;%NWL%input = form . getElementsByTagName ( ' input ' ) [ 0 ] ;%NWL%input . oninvalid = function ( e )  {%NWL%invaildFired = true;%NWL%e . preventDefault ( ) ;%NWL%e . stopPropagation ( ) ;%NWL%} ;%NWL%Modernizr . formvalidationmessage = !!input . validationMessage;%NWL%body . removeChild ( form ) ;%NWL%2
Modernizr . addTest ( ' mathml ' , function ( ) {%NWL%var hasMathML = false;%NWL%if ( document . createElementNS )  {%NWL%var ns = " http: / / www . w3 . org / 1998 / Math / MathML " ,%NWL%div = document . createElement ( " div " ) ;%NWL%div . style . position = " absolute " ;%NWL%var mfrac = div . appendChild ( document . createElementNS ( ns , " math " ) )%NWL%. appendChild ( document . createElementNS ( ns , " mfrac " ) ) ;%NWL%mfrac . appendChild ( document . createElementNS ( ns , " mi " ) )%NWL%mfrac . appendChild ( document . createElementNS ( ns , " mi " ) )%NWL%8
} ;%NWL%%NWL%unitlessDefault = unitlessDefault === undefined ? ' px ' : unitlessDefault;  / / assume px%NWL%var factors = { } ;  / / holds ratios%NWL%var units = { } ;  / / holds calculated values%NWL%var value = getStyle ( target , prop ) ;  / / get the computed style value%NWL%%NWL%if ( value === null )  {%NWL%return null;%NWL%}%NWL%var numeric = value . match ( / \d + / ) ;  / / get the numeric component%NWL%5
var value = getStyle ( target , prop ) ;  / / get the computed style value%NWL%%NWL%if ( value === null )  {%NWL%return null;%NWL%}%NWL%%NWL%var numeric = value . match ( / \d + / ) ;  / / get the numeric component%NWL%if ( numeric === null )  {  / / if match returns null , throw error . . .  use === so 0 values are accepted%NWL%throw " Invalid property value returned " ;%NWL%}%NWL%var unit = value . match ( / \D + $ / ) ;  / / get the existing unit%NWL%0
worker . onmessage = function ( e )  {%NWL%worker . terminate ( ) ;%NWL%URL . revokeObjectURL ( url ) ;%NWL%Modernizr . addTest ( ' blobworkers ' , data === e . data ) ;%NWL%worker = null;%NWL%} ;%NWL%worker . onerror = function ( )  {%NWL%Modernizr . addTest ( ' blobworkers ' , false ) ;%NWL%worker = null;%NWL%} ;%NWL%Modernizr . addTest ( ' blobworkers ' , false ) ;%NWL%7
worker = null;%NWL%} ;%NWL%worker . onerror = function ( )  {%NWL%Modernizr . addTest ( ' blobworkers ' , false ) ;%NWL%worker = null;%NWL%} ;%NWL%setTimeout ( function ( )  {%NWL%Modernizr . addTest ( ' blobworkers ' , false ) ;%NWL%} , 200 ) ;%NWL%worker . postMessage ( data ) ;%NWL%Modernizr . addTest ( ' blobworkers ' , false ) ;%NWL%3
worker = new Worker ( ' data:text / javascript;base64 , dGhpcy5vbm1lc3NhZ2U9ZnVuY3Rpb24oZSl7cG9zdE1lc3NhZ2UoZS5kYXRhKX0= ' ) ;%NWL%worker . onmessage = function ( e )  {%NWL%worker . terminate ( ) ;%NWL%Modernizr . addTest ( ' dataworkers ' , data === e . data ) ;%NWL%worker = null;%NWL%} ;%NWL%worker . onerror = function ( )  {%NWL%Modernizr . addTest ( ' dataworkers ' , false ) ;%NWL%worker = null;%NWL%} ;%NWL%Modernizr . addTest ( ' dataworkers ' , false ) ;%NWL%7
worker = null;%NWL%} ;%NWL%worker . onerror = function ( )  {%NWL%Modernizr . addTest ( ' dataworkers ' , false ) ;%NWL%worker = null;%NWL%} ;%NWL%setTimeout ( function ( )  {%NWL%Modernizr . addTest ( ' dataworkers ' , false ) ;%NWL%} , 200 ) ;%NWL%worker . postMessage ( data ) ;%NWL%Modernizr . addTest ( ' dataworkers ' , false ) ;%NWL%3
stringMode = currentM [ 0 ] . trim ( ) . toLowerCase ( ) ;%NWL%params = currentM [ 1 ] . substring ( 0 , currentM [ 1 ] . length - 1 ) . split ( ' , ' ) ;%NWL%%NWL%if ( stringMode === ' translate ' )  {%NWL%currentM = [ 1 , 0 , 0 , 1 , Number ( params [ 0 ] ) , Number ( params [ 1 ] ) ] ;%NWL%} else if ( stringMode === ' matrix ' )  {%NWL%currentM = params;%NWL%} else if ( stringMode === ' rotate ' )  {%NWL%currentM = [ Math . cos ( params [ 0 ] ) ,%NWL%Math . sin ( params [ 0 ] ) ,%NWL%Math . cos ( params [ 0 ] ) ,%NWL%9
if ( phantom . args . length === 0 || phantom . args . length > 2 )  {%NWL%console . log ( ' Usage: run - qunit . js URL ' ) ;%NWL%phantom . exit ( ) ;%NWL%}%NWL%var page = new WebPage ( ) ;%NWL%page . onConsoleMessage = function ( msg )  {%NWL%console . log ( msg ) ;%NWL%} ;%NWL%page . open ( phantom . args [ 0 ] , function ( status ) {%NWL%if ( status !== " success " )  {%NWL%phantom . exit ( ) ;%NWL%2
mat [ edge . source ] = mat [ edge . source ] || { } ;%NWL%mat [ edge . source ] [ edge . target ] = edge . weight;%NWL%mat [ edge . target ] = mat [ edge . target ] || { } ;%NWL%mat [ edge . target ] [ edge . source ] = edge . weight;%NWL%} ) ;%NWL%return mat;%NWL%}%NWL%function update_assoc_mat ( graph , edge ) {%NWL%graph . _assoc_mat [ edge . source ] = graph . _assoc_mat [ edge . source ] || { } ;%NWL%graph . _assoc_mat [ edge . source ] [ edge . target ] = edge . weight;%NWL%graph . _assoc_mat [ edge . target ] [ edge . source ] = edge . weight;%NWL%8
status [ ' total_weight ' ] = get_graph_size ( graph ) ;%NWL%if ( typeof part === ' undefined ' ) {%NWL%graph . nodes . forEach ( function ( node , i ) {%NWL%status . nodes_to_com [ node ] = i;%NWL%var deg = get_degree_for_node ( graph , node ) ;%NWL%if ( deg < 0 )  {%NWL%throw ' Bad graph type , use positive weights! ' ;%NWL%}%NWL%status . degrees [ i ] = deg;%NWL%status . gdegrees [ node ] = deg;%NWL%status . internals [ i ] = status . loops [ node ] ;%NWL%0
weights [ neighbourcom ] = ( weights [ neighbourcom ] || 0 )  + weight;%NWL%}%NWL%} ) ;%NWL%return weights;%NWL%}%NWL%function __insert ( node , com , weight , status ) {%NWL%status . nodes_to_com [ node ] = + com;%NWL%status . degrees [ com ] = ( status . degrees [ com ] || 0 )  +  ( status . gdegrees [ node ] ||0 ) ;%NWL%status . internals [ com ] = ( status . internals [ com ] || 0 )  + weight +  ( status . loops [ node ] ||0 ) ;%NWL%}%NWL%status . degrees [ com ] = ( ( status . degrees [ com ] || 0 )  -  ( status . gdegrees [ node ] || 0 ) ) ;%NWL%7
}%NWL%} ) ;%NWL%return weights;%NWL%}%NWL%function __insert ( node , com , weight , status ) {%NWL%status . nodes_to_com [ node ] = + com;%NWL%status . degrees [ com ] = ( status . degrees [ com ] || 0 )  +  ( status . gdegrees [ node ] ||0 ) ;%NWL%status . internals [ com ] = ( status . internals [ com ] || 0 )  + weight +  ( status . loops [ node ] ||0 ) ;%NWL%}%NWL%function __remove ( node , com , weight , status ) {%NWL%status . internals [ com ] = ( ( status . internals [ com ] || 0 )  - weight - ( status . loops [ node ] ||0 ) ) ;%NWL%6
status_list . push ( partition ) ;%NWL%mod = new_mod;%NWL%var current_graph = induced_graph ( partition , original_graph ) ;%NWL%init_status ( current_graph , status ) ;%NWL%while ( true ) {%NWL%__one_level ( current_graph , status ) ;%NWL%new_mod = __modularity ( status ) ;%NWL%if ( new_mod - mod < __MIN )  {%NWL%break;%NWL%}%NWL%status_list . push ( partition ) ;%NWL%0
v = str ( k , value ) ;%NWL%if ( v )  {%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%}%NWL%}%NWL%}%NWL%} else {%NWL%for ( k in value )  {%NWL%if ( Object . prototype . hasOwnProperty . call ( value , k ) )  {%NWL%v = str ( k , value ) ;%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%2
codeString = ' var doc = d3 . select ( " # '  + docName +  ' " ) ;\n '  + codeString;%NWL%}%NWL%ejQuery ( ' #jsTextEditor ' ) . val ( codeString ) ;%NWL%EXTENSION . displayMessage ( ' Updated JS ' ) ;%NWL%} ,%NWL%cache: false%NWL%} ) ;%NWL%} ;%NWL%CodeManager . prototype . loadSampleJS = function ( codeString )  {%NWL%" use strict " ;%NWL%EXTENSION . displayMessage ( ' Updated JS ' ) ;%NWL%3
CodeManager . prototype . loadSampleJS = function ( codeString )  {%NWL%" use strict " ;%NWL%ejQuery ( ' #jsTextEditor ' ) . val ( codeString ) ;%NWL%EXTENSION . displayMessage ( ' Updated JS ' ) ;%NWL%} ;%NWL%CodeManager . prototype . loadJSFile = function ( )  {%NWL%" use strict " ;%NWL%var newFile = ejQuery ( ' #jsFileInput ' ) [ 0 ] . files [ 0 ] ,%NWL%fileReader = new FileReader ( ) ;%NWL%fileReader . onload = function ( e )  {%NWL%EXTENSION . displayMessage ( ' Updated JS ' ) ;%NWL%3
ejQuery ( ' #cssTextEditor ' ) . val ( codeString ) ;%NWL%EXTENSION . displayMessage ( ' Updated CSS ' ) ;%NWL%self . updateCSS ( ) ;%NWL%} ,%NWL%cache: false%NWL%} ) ;%NWL%} ;%NWL%CodeManager . prototype . loadSampleCSS = function ( codeString )  {%NWL%" use strict " ;%NWL%var self = this;%NWL%EXTENSION . displayMessage ( ' Updated CSS ' ) ;%NWL%1
EXTENSION . displayMessage ( ' Updated CSS ' ) ;%NWL%self . updateCSS ( ) ;%NWL%} ,%NWL%cache: false%NWL%} ) ;%NWL%} ;%NWL%CodeManager . prototype . loadSampleCSS = function ( codeString )  {%NWL%" use strict " ;%NWL%var self = this;%NWL%ejQuery ( ' #cssTextEditor ' ) . val ( codeString ) ;%NWL%self . updateCSS ( ) ;%NWL%1
" use strict " ;%NWL%var self = this;%NWL%ejQuery ( ' #cssTextEditor ' ) . val ( codeString ) ;%NWL%EXTENSION . displayMessage ( ' Updated CSS ' ) ;%NWL%self . updateCSS ( ) ;%NWL%} ;%NWL%CodeManager . prototype . editCSS = function ( )  {%NWL%" use strict " ;%NWL%var self = this;%NWL%clearTimeout ( self . cssTypingTimer ) ;%NWL%self . updateCSS ( ) ;%NWL%4
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 ' ,  ' 30 ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 ' ,  ' 31 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = " Gener Gen . _Febrer Febr . _Mar Mar . _Abril Abr . _Maig Mai . _Juny Jun . _Juliol Jul . _Agost Ag . _Setembre Set . _Octubre Oct . _Novembre Nov . _Desembre Des . " . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = " Diumenge Dg . Dg_Dilluns Dl . Dl_Dimarts Dt . Dt_Dimecres Dc . Dc_Dijous Dj . Dj_Divendres Dv . Dv_Dissabte Ds . Ds " . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " un any " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " un any " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 anys " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un any " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anys " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en uns segons " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en uns segons " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fa uns segons " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en uns segons " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fa uns segons " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " fa uns segons " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " fa uns segons " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " en uns segons " ,  " en uns segons " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' leden led_nor no_bezen be_duben dub_kvten kv_erven vn_ervenec vc_srpen srp_z z_jen j_listopad lis_prosinec pro ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' nedle ne ne_pondl po po_ter t t_steda st st_tvrtek t t_ptek p p_sobota so so ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " rok " ,       " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " rok " ,       " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 roky " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " rok " ,       " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 let " ,      " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " za pr vtein " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " za pr vtein " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " ped pr vteinami " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " dnes v 2:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " dnes v 2:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " dnes v 3:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " ztra v 2:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " dnes v 1:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
weeksFromNow = moment ( ) . add ( { w: 2 } ) ;%NWL%test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" humanize duration " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%test . equal ( moment . duration ( 1 ,  " minutes " ) . humanize ( ) ,  " minuta " ,  " a minute ( future ) " ) ;%NWL%test . equal ( moment . duration ( 1 ,  " minutes " ) . humanize ( true ) ,  " za minutu " ,  " in a minute " ) ;%NWL%test . equal ( moment . duration ( - 1 ,  " minutes " ) . humanize ( ) ,  " minuta " ,  " a minute ( past ) " ) ;%NWL%test . done ( ) ;%NWL%3
test . equal ( moment . duration ( - 1 ,  " minutes " ) . humanize ( ) ,  " minuta " ,  " a minute ( past ) " ) ;%NWL%test . equal ( moment . duration ( - 1 ,  " minutes " ) . humanize ( true ) ,  " ped minutou " ,  " a minute ago " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Januar Jan_Februar Feb_Marts Mar_April Apr_Maj Maj_Juni Jun_Juli Jul_August Aug_September Sep_Oktober Okt_November Nov_December Dec ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Sndag Sn S_Mandag Man Ma_Tirsdag Tir Ti_Onsdag Ons On_Torsdag Tor To_Fredag Fre Fr_Lrdag Lr L ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " r " ,      " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " r " ,      " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 r " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " r " ,      " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 r " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om f sekunder " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om f sekunder " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " f sekunder siden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om f sekunder " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " f sekunder siden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " f sekunder siden " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " f sekunder siden " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " om f sekunder " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " om f sekunder " ,  " in a few seconds " ) ;%NWL%test . equal ( moment ( ) . add ( { d:5 } ) . fromNow ( ) ,  " om 5 dage " ,  " in 5 days " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Januar Jan . _Februar Febr . _Mrz Mrz . _April Apr . _Mai Mai_Juni Jun . _Juli Jul . _August Aug . _September Sept . _Oktober Okt . _November Nov . _Dezember Dez . ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Sonntag So . So_Montag Mo . Mo_Dienstag Di . Di_Mittwoch Mi . Mi_Donnerstag Do . Do_Freitag Fr . Fr_Samstag Sa . Sa ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " einem Jahr " ,      " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " einem Jahr " ,      " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 Jahren " ,       " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " einem Jahr " ,      " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 Jahren " ,       " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in ein paar Sekunden " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " einem Jahr " ,      " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 Jahren " ,       " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in ein paar Sekunden " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " vor ein paar Sekunden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in ein paar Sekunden " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " vor ein paar Sekunden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " in ein paar Sekunden " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Heute um 2:00 Uhr " ,   " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Heute um 2:25 Uhr " ,   " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Heute um 3:00 Uhr " ,   " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Morgen um 2:00 Uhr " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Heute um 1:00 Uhr " ,   " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30th ' ,  ' 30th ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31st ' ,  ' 31st ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var i ,%NWL%expected = ' January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec ' . split ( " _ " ) ;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var i ,%NWL%expected = ' Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa ' . split ( " _ " ) ;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " a year " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " a year " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 years " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " a year " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 years " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " a few seconds ago " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " a few seconds ago " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " a few seconds ago " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " a few seconds ago " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " in a few seconds " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Today at 2:00 AM " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Today at 2:25 AM " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Today at 3:00 AM " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Tomorrow at 2:00 AM " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Today at 1:00 AM " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . week ( ) , 1 ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday format " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1st ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1st ' ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2nd ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2nd ' ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30th ' ,  ' 30th ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31st ' ,  ' 31st ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " a year " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " a year " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 years " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " a year " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 years " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " a few seconds ago " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " a few seconds ago " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " a few seconds ago " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " a few seconds ago " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " in a few seconds " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Today at 2:00 AM " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Today at 2:25 AM " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Today at 3:00 AM " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Tomorrow at 2:00 AM " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Today at 1:00 AM " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52nd ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1st '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1st '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2nd '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
optionText + = ' > '  + f . name +  ' < / option> ' ;%NWL%currentDataFile . append ( optionText ) ;%NWL%}%NWL%currentDataFile . append ( ' <option value= " loadNewFile " >Load . . . < / option> ' ) ;%NWL%} ;%NWL%DataManager . prototype . edit = function ( )  {%NWL%" use strict " ;%NWL%var self = this ,%NWL%f = self . getFile ( self . currentFile ) ;%NWL%clearTimeout ( self . typingTimer ) ;%NWL%f . raw = ejQuery ( ' #dataTextEditor ' ) . val ( ) ;%NWL%8
ejQuery ( ' #currentDataFile ' ) . val ( self . currentFile ) ;%NWL%ejQuery ( ' #dataFileInput ' ) . click ( ) ;%NWL%} else {%NWL%self . currentFile = newFile;%NWL%self . updatePanel ( ) ;%NWL%}%NWL%} ;%NWL%DataManager . prototype . changeEmbed = function ( )  {%NWL%" use strict " ;%NWL%var self = this;%NWL%self . updatePanel ( ) ;%NWL%4
" use strict " ;%NWL%var self = this;%NWL%self . getFile ( self . currentFile ) . embed = ejQuery ( ' #embedFileCheckBox ' ) . prop ( ' checked ' ) ;%NWL%self . updatePanel ( ) ;%NWL%} ;%NWL%DataManager . prototype . changeType = function ( )  {%NWL%" use strict " ;%NWL%var self = this ,%NWL%current = self . getFile ( self . currentFile ) ,%NWL%newType = ejQuery ( ' #dataTypeSelect ' ) . val ( ) ;%NWL%self . updatePanel ( ) ;%NWL%3
var moment = require ( " . . / . . / moment " ) ;%NWL%%NWL%exports [ " lang:en " ] = {%NWL%setUp : function ( cb )  {%NWL%moment . lang ( ' en ' ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%moment . lang ( ' en ' ) ;%NWL%4
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30th ' ,  ' 30th ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31st ' ,  ' 31st ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var i ,%NWL%expected = ' January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec ' . split ( " _ " ) ;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var i ,%NWL%expected = ' Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa ' . split ( " _ " ) ;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " a year " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " a year " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 years " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " a year " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 years " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " a few seconds ago " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in a few seconds " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " a few seconds ago " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " a few seconds ago " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " a few seconds ago " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " in a few seconds " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Today at 2:00 AM " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Today at 2:25 AM " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Today at 3:00 AM " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Tomorrow at 2:00 AM " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Today at 1:00 AM " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . week ( ) , 1 ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday format " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1st ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1st ' ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2nd ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2nd ' ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30a ' ,  ' 30a ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31a ' ,  ' 31a ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_agusto ag_septembro sep_oktobro okt_novembro nov_decembro dec ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Dimano Dim Di_Lundo Lun Lu_Mardo Mard Ma_Merkredo Merk Me_ado a a_Vendredo Ven Ve_Sabato Sab Sa ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " jaro " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " jaro " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 jaroj " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " jaro " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 jaroj " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " je sekundoj " ,  " je prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " je sekundoj " ,  " je prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " anta sekundoj " ,  " anta prefix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " je sekundoj " ,  " je prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " anta sekundoj " ,  " anta prefix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " anta sekundoj " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " anta sekundoj " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " je sekundoj " ,  " je sekundoj " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Hodia je 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Hodia je 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Hodia je 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Morga je 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Hodia je 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1a ' ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1a ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2a ' ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2a ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 ' ,  ' 30 ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 ' ,  ' 31 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' enero ene . _febrero feb . _marzo mar . _abril abr . _mayo may . _junio jun . _julio jul . _agosto ago . _septiembre sep . _octubre oct . _noviembre nov . _diciembre dic . ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' domingo dom . Do_lunes lun . Lu_martes mar . Ma_mircoles mi . Mi_jueves jue . Ju_viernes vie . Vi_sbado sb . S ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " un ao " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " un ao " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 aos " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un ao " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 aos " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en unos segundos " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en unos segundos " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " hace unos segundos " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en unos segundos " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " hace unos segundos " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " hace unos segundos " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " hace unos segundos " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " en unos segundos " ,  " en unos segundos " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' jaanuar jaan_veebruar veebr_mrts mrts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' phapev P P_esmaspev E E_teisipev T T_kolmapev K K_neljapev N N_reede R R_laupev L L ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " aasta " ,     " 345 days = aasta " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " aasta " ,     " 547 days = aasta " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 aastat " ,     " 548 days = 2 aastat " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " aasta " ,     " 1 year = aasta " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 aastat " ,     " 5 years = 5 aastat " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " paari sekundi prast " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " paari sekundi prast " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " paar sekundit tagasi " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " paari sekundi prast " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " paar sekundit tagasi " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " paar sekundit tagasi " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " paar sekundit tagasi " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " paari sekundi prast " ,  " paari sekundi prast " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Tna , 2:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Tna , 2:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Tna , 3:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Homme , 2:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Tna , 1:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 ndalat tagasi " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " 2 ndala prast " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' urtarrila urt . _otsaila ots . _martxoa mar . _apirila api . _maiatza mai . _ekaina eka . _uztaila uzt . _abuztua abu . _iraila ira . _urria urr . _azaroa aza . _abendua abe . ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' igandea ig . ig_astelehena al . al_asteartea ar . ar_asteazkena az . az_osteguna og . og_ostirala ol . ol_larunbata lr . lr ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " urte bat " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " urte bat " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 urte " ,      " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " urte bat " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 urte " ,      " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " segundo batzuk barru " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " segundo batzuk barru " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " duela segundo batzuk " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " segundo batzuk barru " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " duela segundo batzuk " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " duela segundo batzuk " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " duela segundo batzuk " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " segundo batzuk barru " ,  " in seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " gaur 02:00etan " ,  " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " gaur 02:25etan " ,  " now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " gaur 03:00etan " ,  " now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " bihar 02:00etan " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " gaur 01:00etan " ,  " now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . ' ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . ' ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30th ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31st ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' tammikuu tam_helmikuu hel_maaliskuu maa_huhtikuu huh_toukokuu tou_keskuu kes_heinkuu hei_elokuu elo_syyskuu syy_lokakuu lok_marraskuu mar_joulukuu jou ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' sunnuntai su su_maanantai ma ma_tiistai ti ti_keskiviikko ke ke_torstai to to_perjantai pe pe_lauantai la la ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " vuosi " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " vuosi " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " kaksi vuotta " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " vuosi " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " viisi vuotta " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " muutaman sekunnin pst " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " muutaman sekunnin pst " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " muutama sekunti sitten " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " muutaman sekunnin pst " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " muutama sekunti sitten " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " muutama sekunti sitten " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " muutama sekunti sitten " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " muutaman sekunnin pst " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " tnn klo 02 . 00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " tnn klo 02 . 25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " tnn klo 03 . 00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " huomenna klo 02 . 00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " tnn klo 01 . 00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " kaksi viikkoa sitten " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " kaden viikon pst " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30me ' ,  ' 30me ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31me ' ,  ' 31me ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var i ,%NWL%expected = ' janvier janv . _fvrier fvr . _mars mars_avril avr . _mai mai_juin juin_juillet juil . _aot aot_septembre sept . _octobre oct . _novembre nov . _dcembre dc . ' . split ( " _ " ) ;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var i ,%NWL%expected = ' dimanche dim . Di_lundi lun . Lu_mardi mar . Ma_mercredi mer . Me_jeudi jeu . Je_vendredi ven . Ve_samedi sam . Sa ' . split ( " _ " ) ;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " un an " ,    " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " un an " ,    " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 ans " ,   " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un an " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 ans " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dans quelques secondes " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un an " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 ans " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dans quelques secondes " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " il y a quelques secondes " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dans quelques secondes " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " il y a quelques secondes " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " dans quelques secondes " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" same day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Aujourd ' hui  02:00 " ,   " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Aujourd ' hui  02:25 " ,   " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Aujourd ' hui  03:00 " ,   " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Demain  02:00 " ,      " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Aujourd ' hui  01:00 " ,   " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . week ( ) , 1 ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday format " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1er ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1er ' ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2me ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2me ' ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30me ' ,  ' 30me ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31me ' ,  ' 31me ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' janvier janv . _fvrier fvr . _mars mars_avril avr . _mai mai_juin juin_juillet juil . _aot aot_septembre sept . _octobre oct . _novembre nov . _dcembre dc . ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' dimanche dim . Di_lundi lun . Lu_mardi mar . Ma_mercredi mer . Me_jeudi jeu . Je_vendredi ven . Ve_samedi sam . Sa ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " un an " ,    " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " un an " ,    " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 ans " ,   " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un an " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 ans " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dans quelques secondes " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un an " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 ans " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dans quelques secondes " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " il y a quelques secondes " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dans quelques secondes " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " il y a quelques secondes " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " dans quelques secondes " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" same day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Aujourd ' hui  02:00 " ,   " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Aujourd ' hui  02:25 " ,   " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Aujourd ' hui  03:00 " ,   " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Demain  02:00 " ,      " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Aujourd ' hui  01:00 " ,   " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52me ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1er '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1er '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2me '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 ' ,  ' 30 ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 ' ,  ' 31 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = " Xaneiro Xan . _Febreiro Feb . _Marzo Mar . _Abril Abr . _Maio Mai . _Xuo Xu . _Xullo Xul . _Agosto Ago . _Setembro Set . _Octubro Out . _Novembro Nov . _Decembro Dec . " . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = " Domingo Dom . Do_Luns Lun . Lu_Martes Mar . Ma_Mrcores Mr . M_Xoves Xov . Xo_Venres Ven . Ve_Sbado Sb . S " . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " un ano " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " un ano " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 anos " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un ano " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anos " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en uns segundo " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en uns segundo " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fai uns segundo " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " en uns segundo " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fai uns segundo " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " fai uns segundo " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " fai uns segundo " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " en uns segundo " ,  " en unos segundos " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 1 week " ) ;%NWL%weeksAgo = moment ( ) . subtract ( { w: 2 } ) ;%NWL%weeksFromNow = moment ( ) . add ( { w: 2 } ) ;%NWL%test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" regression tests " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var lastWeek = moment ( ) . subtract ( { d: 4 } ) . hours ( 1 ) ;%NWL%test . done ( ) ;%NWL%5
var lastWeek = moment ( ) . subtract ( { d: 4 } ) . hours ( 1 ) ;%NWL%test . equal ( lastWeek . calendar ( ) , lastWeek . format ( ' [ o ] dddd [ pasado a ] LT ' ) ,  " 1 o ' clock bug " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
targetDiv . innerHTML = " " ;%NWL%self . iframe = document . createElement ( ' iframe ' ) ;%NWL%targetDiv . appendChild ( self . iframe ) ;%NWL%%NWL%element = self . iframe . contentDocument . createElement ( ' style ' ) ;%NWL%element . setAttribute ( ' type ' ,  ' text / css ' ) ;%NWL%element . setAttribute ( ' id ' ,  ' illustratorFeel ' ) ;%NWL%self . iframe . contentDocument . head . appendChild ( element ) ;%NWL%element . innerText = " text { font - family: ' Myriad Pro ' , sans - serif; font - size: 12px; } " ;%NWL%%NWL%element . setAttribute ( ' type ' ,  ' text / css ' ) ;%NWL%5
targetDiv . appendChild ( self . iframe ) ;%NWL%%NWL%element = self . iframe . contentDocument . createElement ( ' style ' ) ;%NWL%element . setAttribute ( ' type ' ,  ' text / css ' ) ;%NWL%element . setAttribute ( ' id ' ,  ' illustratorFeel ' ) ;%NWL%self . iframe . contentDocument . head . appendChild ( element ) ;%NWL%element . innerText = " text { font - family: ' Myriad Pro ' , sans - serif; font - size: 12px; } " ;%NWL%%NWL%element = self . iframe . contentDocument . createElement ( ' style ' ) ;%NWL%element . setAttribute ( ' type ' ,  ' text / css ' ) ;%NWL%self . iframe . contentDocument . head . appendChild ( element ) ;%NWL%5
zIndex : z ,%NWL%groups : [ ] ,%NWL%paths : [ ] ,%NWL%text : [ ] ,%NWL%opacity : parseFloat ( computedStyle . opacity )%NWL%} ,%NWL%s ,%NWL%z2 = 1;%NWL%output . opacity = isNaN ( output . opacity ) ? 1 : output . opacity;%NWL%%NWL%output . data = d3 . select ( ' # '  + g . getAttribute ( ' id ' ) ) . data ( ) [ 0 ] ;%NWL%8
opacity : parseFloat ( computedStyle . opacity )%NWL%} ,%NWL%s ,%NWL%z2 = 1;%NWL%output . opacity = isNaN ( output . opacity ) ? 1 : output . opacity;%NWL%%NWL%if ( iType === ' group ' )  {%NWL%output . data = d3 . select ( ' # '  + g . getAttribute ( ' id ' ) ) . data ( ) [ 0 ] ;%NWL%if ( output . data === undefined )  {%NWL%output . data = null;%NWL%output . data = JsonCircular . stringify ( output . data ) ;%NWL%4
} ,%NWL%s ,%NWL%z2 = 1;%NWL%output . opacity = isNaN ( output . opacity ) ? 1 : output . opacity;%NWL%%NWL%if ( iType === ' group ' )  {%NWL%output . data = d3 . select ( ' # '  + g . getAttribute ( ' id ' ) ) . data ( ) [ 0 ] ;%NWL%if ( output . data === undefined )  {%NWL%output . data = null;%NWL%}%NWL%output . classNames = g . getAttribute ( ' class ' ) === null ? " " : g . getAttribute ( ' class ' ) ;%NWL%3
s ,%NWL%z2 = 1;%NWL%output . opacity = isNaN ( output . opacity ) ? 1 : output . opacity;%NWL%%NWL%if ( iType === ' group ' )  {%NWL%output . data = d3 . select ( ' # '  + g . getAttribute ( ' id ' ) ) . data ( ) [ 0 ] ;%NWL%if ( output . data === undefined )  {%NWL%output . data = null;%NWL%}%NWL%output . data = JsonCircular . stringify ( output . data ) ;%NWL%output . reverseTransform = g . getAttribute ( ' hanpuku_reverseTransform ' ) === null ? " " : g . getAttribute ( ' hanpuku_reverseTransform ' ) ;%NWL%2
var self = this ,%NWL%i;%NWL%%NWL%if ( self . animationFrame !== null )  {%NWL%for ( i = window . requestAnimationFrame ( DomManager . NOOP ) ; i > self . animationFrame; i - = 1 )  {%NWL%window . cancelAnimationFrame ( i ) ;%NWL%}%NWL%}%NWL%self . animationFrame = null;%NWL%if ( self . interval !== null )  {%NWL%window . clearInterval ( i ) ;%NWL%5
}%NWL%self . animationFrame = null;%NWL%if ( self . interval !== null )  {%NWL%for ( i = window . setInterval ( DomManager . NOOP ) ; i > self . interval; i - = 1 )  {%NWL%window . clearInterval ( i ) ;%NWL%}%NWL%}%NWL%self . interval = null;%NWL%if ( self . timeout !== null )  {%NWL%for ( i = window . setTimeout ( DomManager . NOOP ) ; i > self . timeout; i - = 1 )  {%NWL%window . clearTimeout ( i ) ;%NWL%4
sinTheta ,%NWL%cosTheta ,%NWL%container;%NWL%%NWL%if ( text . justification === ' LEFT ' )  {%NWL%t . attr ( ' text - anchor ' ,  ' start ' ) ;%NWL%} else if ( text . justification === ' CENTER ' )  {%NWL%t . attr ( ' text - anchor ' ,  ' middle ' ) ;%NWL%} else if ( text . justification === ' RIGHT ' )  {%NWL%t . attr ( ' text - anchor ' ,  ' end ' ) ;%NWL%t . attr ( ' text - anchor ' ,  ' start ' ) ;%NWL%5
t . attr ( ' class ' , text . classNames ) ;%NWL%}%NWL%%NWL%%NWL%if ( text . reverseTransform !== ' null ' )  {%NWL%t . attr ( ' transform ' , text . reverseTransform ) ;%NWL%}%NWL%%NWL%text . internalX = !text . internalX ? ' 0 ' : text . internalX;%NWL%text . internalY = !text . internalY ? ' 0 ' : text . internalY;%NWL%text . internalX = parseFloat ( convertUnits ( t [ 0 ] [ 0 ] , text . internalX ,  ' px ' ) ) ; / / need to send the actual DOM element , not the d3 selection%NWL%8
}%NWL%%NWL%%NWL%if ( text . reverseTransform !== ' null ' )  {%NWL%t . attr ( ' transform ' , text . reverseTransform ) ;%NWL%}%NWL%%NWL%text . internalX = !text . internalX ? ' 0 ' : text . internalX;%NWL%text . internalY = !text . internalY ? ' 0 ' : text . internalY;%NWL%%NWL%text . internalY = parseFloat ( convertUnits ( t [ 0 ] [ 0 ] , text . internalY ,  ' px ' ) ) ;%NWL%7
if ( group . reverseTransform !== null )  {%NWL%g . attr ( ' transform ' , group . reverseTransform ) ;%NWL%}%NWL%if ( group . hasOwnProperty ( ' data ' ) )  {%NWL%d3 . select ( ' # '  + group . name ) . datum ( JsonCircular . parse ( JSON . parse ( group . data ) ) ) ;%NWL%}%NWL%%NWL%for ( c = 0; c < children . length; c + = 1 )  {%NWL%if ( children [ c ] . itemType === ' group ' )  {%NWL%self . addGroup ( g , children [ c ] ) ;%NWL%self . addPath ( g , children [ c ] ) ;%NWL%9
}%NWL%if ( group . hasOwnProperty ( ' data ' ) )  {%NWL%d3 . select ( ' # '  + group . name ) . datum ( JsonCircular . parse ( JSON . parse ( group . data ) ) ) ;%NWL%}%NWL%%NWL%for ( c = 0; c < children . length; c + = 1 )  {%NWL%if ( children [ c ] . itemType === ' group ' )  {%NWL%self . addGroup ( g , children [ c ] ) ;%NWL%} else if ( children [ c ] . itemType === ' path ' )  {%NWL%self . addPath ( g , children [ c ] ) ;%NWL%self . addText ( g , children [ c ] ) ;%NWL%7
if ( datum === undefined )  {%NWL%node . attr ( ' __data__ ' , null ) ;%NWL%} else {%NWL%node . attr ( ' __data__ ' , JSON . stringify ( datum ) ) ;%NWL%}%NWL%}%NWL%%NWL%result = window . cep . fs . writeFile ( filePath ,%NWL%' <!DOCTYPE html><html><head>\n '  +%NWL%contentDoc . head . innerHTML +%NWL%contentDoc . body . innerHTML +%NWL%9
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' janur jan_februr feb_mrcius mrc_prilis pr_mjus mj_jnius jn_jlius jl_augusztus aug_szeptember szept_oktber okt_november nov_december dec ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' vasrnap v_htf h_kedd k_szerda sze_cstrtk cs_pntek p_szombat szo ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " egy v " ,       " 345 nap = egy v " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " egy v " ,       " 547 nap = egy v " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 v " ,        " 548 nap = 2 v " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " egy v " ,       " 1 v = egy v " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 v " ,        " 5 v = 5 v " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " nhny msodperc mlva " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " nhny msodperc mlva " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " nhny msodperce " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " nhny msodperc mlva " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " nhny msodperce " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " nhny msodperce " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " nhny msodperce " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " nhny msodperc mlva " ,  " nhny msodperc mlva " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " ma 2:00 - kor " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " ma 2:25 - kor " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " ma 3:00 - kor " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " holnap 2:00 - kor " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " ma 1:00 - kor " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 hete " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " 2 ht mlva " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . ' ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . ' ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( b . format ( a [ i ] [ 0 ] ) , a [ i ] [ 1 ] , a [ i ] [ 0 ]  +  '  - - - > '  + a [ i ] [ 1 ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Minggu Min Mg_Senin Sen Sn_Selasa Sel Sl_Rabu Rab Rb_Kamis Kam Km_Jumat Jum Jm_Sabtu Sab Sb ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " setahun " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " setahun " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 tahun " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " setahun " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 tahun " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dalam beberapa detik " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dalam beberapa detik " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " beberapa detik yang lalu " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " dalam beberapa detik " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " beberapa detik yang lalu " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " beberapa detik yang lalu " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " beberapa detik yang lalu " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " dalam beberapa detik " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Hari ini pukul 02 . 00 " ,  " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Hari ini pukul 02 . 25 " ,  " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Hari ini pukul 03 . 00 " ,  " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Besok pukul 02 . 00 " ,   " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Hari ini pukul 01 . 00 " ,  " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' janar jan_febrar feb_mars mar_aprl apr_ma ma_jn jn_jl jl_gst g_september sep_oktber okt_nvember nv_desember des ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' sunnudagur sun Su_mnudagur mn M_rijudagur ri r_mivikudagur mi Mi_fimmtudagur fim Fi_fstudagur fs F_laugardagur lau La ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 r " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " r " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 r " ,     " 5 years = 5 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:21 } ) , true ) ,  " 21 r " ,     " 21 years = 21 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " eftir nokkrar sekndur " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fyrir nokkrum sekndum san " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%4
} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " eftir nokkrar sekndur " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fyrir nokkrum sekndum san " ,  " suffix " ) ;%NWL%test . equal ( moment ( ) . subtract ( { m:1 } ) . fromNow ( ) ,  " fyrir mntu san " ,  " a minute ago " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " fyrir nokkrum sekndum san " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " eftir nokkrar sekndur " ,  " in a few seconds " ) ;%NWL%test . equal ( moment ( ) . add ( { m:1 } ) . fromNow ( ) ,  " eftir mntu " ,  " in a minute " ) ;%NWL%test . done ( ) ;%NWL%4
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            "  dag kl . 2:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    "  dag kl . 2:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     "  dag kl . 3:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     "  morgun kl . 2:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  "  dag kl . 1:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 ' ,  ' 30 ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 ' ,  ' 31 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Gennaio Gen_Febbraio Feb_Marzo Mar_Aprile Apr_Maggio Mag_Giugno Giu_Luglio Lug_Agosto Ago_Settembre Set_Ottobre Ott_Novembre Nov_Dicembre Dic ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Domenica Dom D_Luned Lun L_Marted Mar Ma_Mercoled Mer Me_Gioved Gio G_Venerd Ven V_Sabato Sab S ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " un anno " ,    " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " un anno " ,    " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 anni " ,   " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un anno " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anni " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in secondi " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un anno " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anni " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in secondi " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " secondi fa " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " in secondi " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " secondi fa " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " in secondi " ,  " in seconds " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Oggi alle 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Oggi alle 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Oggi alle 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Domani alle 02:00 " ,   " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Oggi alle 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' janvris jan_februris feb_marts mar_aprlis apr_maijs mai_jnijs jn_jlijs jl_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' svtdiena Sv Sv_pirmdiena P P_otrdiena O O_trediena T T_ceturtdiena C C_piektdiena Pk Pk_sestdiena S S ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " gadu " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " gadu " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 gadi " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " gadu " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 gadi " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " daas sekundes vlk " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " daas sekundes vlk " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " daas sekundes agrk " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " daas sekundes vlk " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " daas sekundes agrk " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " daas sekundes agrk " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " daas sekundes agrk " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " daas sekundes vlk " ,  " in seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " odien pulksten 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " odien pulksten 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " odien pulksten 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Rt pulksten 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " odien pulksten 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' sndag sn s_mandag man ma_tirsdag tir ti_onsdag ons on_torsdag tor to_fredag fre fr_lrdag lr l ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " ett r " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " ett r " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 r " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " ett r " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 r " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om noen sekunder " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om noen sekunder " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " for noen sekunder siden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om noen sekunder " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " for noen sekunder siden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " for noen sekunder siden " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " for noen sekunder siden " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " om noen sekunder " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " I dag klokken 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " I dag klokken 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " I dag klokken 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " I morgen klokken 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " I dag klokken 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30ste ' ,  ' 30ste ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31ste ' ,  ' 31ste ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' januari jan . _februari feb . _maart mrt . _april apr . _mei mei_juni jun . _juli jul . _augustus aug . _september sep . _oktober okt . _november nov . _december dec . ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' zondag zo . Zo_maandag ma . Ma_dinsdag di . Di_woensdag wo . Wo_donderdag do . Do_vrijdag vr . Vr_zaterdag za . Za ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " n jaar " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " n jaar " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 jaar " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " n jaar " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 jaar " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " over een paar seconden " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " over een paar seconden " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " een paar seconden geleden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " over een paar seconden " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " een paar seconden geleden " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " een paar seconden geleden " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " een paar seconden geleden " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " over een paar seconden " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Vandaag om 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Vandaag om 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Vandaag om 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Morgen om 02:00 " ,   " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Vandaag om 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 1 week " ) ;%NWL%weeksAgo = moment ( ) . subtract ( { w: 2 } ) ;%NWL%weeksFromNow = moment ( ) . add ( { w: 2 } ) ;%NWL%test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" month abbreviation " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( [ 2012 , 5 , 23 ] ) . format ( ' D - MMM - YYYY ' ) ,  ' 23 - jun - 2012 ' ,  ' format month abbreviation surrounded by dashes should not include a dot ' ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( moment ( [ 2012 , 5 , 23 ] ) . format ( ' D - MMM - YYYY ' ) ,  ' 23 - jun - 2012 ' ,  ' format month abbreviation surrounded by dashes should not include a dot ' ) ;%NWL%test . equal ( moment ( [ 2012 , 5 , 23 ] ) . format ( ' D MMM YYYY ' ) ,  ' 23 jun . 2012 ' ,  ' format month abbreviation not surrounded by dashes should include a dot ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52ste ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1ste '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1ste '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2de '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' stycze sty_luty lut_marzec mar_kwiecie kwi_maj maj_czerwiec cze_lipiec lip_sierpie sie_wrzesie wrz_padziernik pa_listopad lis_grudzie gru ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' niedziela nie N_poniedziaek pon Pn_wtorek wt Wt_roda r r_czwartek czw Cz_pitek pt Pt_sobota sb So ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " rok " ,       " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " rok " ,       " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 lata " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " rok " ,       " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 lat " ,      " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " za kilka sekund " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " za kilka sekund " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " kilka sekund temu " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " kilka sekund temu " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " za kilka sekund " ,  " in a few seconds " ) ;%NWL%test . equal ( moment ( ) . add ( { h:1 } ) . fromNow ( ) ,  " za godzin " ,  " in an hour " ) ;%NWL%test . done ( ) ;%NWL%4
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Dzi o 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Dzi o 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Dzi o 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Jutro o 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Dzi o 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 . ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 ' ,  ' 30 ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 ' ,  ' 31 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Janeiro Jan_Fevereiro Fev_Maro Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Domingo Dom_Segunda - feira Seg_Tera - feira Ter_Quarta - feira Qua_Quinta - feira Qui_Sexta - feira Sex_Sbado Sb ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " um ano " ,    " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " um ano " ,    " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 anos " ,   " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " um ano " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anos " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " em segundos " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " um ano " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anos " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " em segundos " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " segundos atrs " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " em segundos " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " segundos atrs " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " em segundos " ,  " in seconds " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Hoje s 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Hoje s 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Hoje s 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Amanh s 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Hoje s 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . week ( ) , 1 ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2006 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2006 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2007 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2011 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday format " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 ' ,  ' 30 ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 ' ,  ' 31 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Janeiro Jan_Fevereiro Fev_Maro Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Domingo Dom Dom_Segunda - feira Seg 2_Tera - feira Ter 3_Quarta - feira Qua 4_Quinta - feira Qui 5_Sexta - feira Sex 6_Sbado Sb Sb ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " um ano " ,    " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " um ano " ,    " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 anos " ,   " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " um ano " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anos " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " em segundos " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " um ano " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 anos " ,   " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " em segundos " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " segundos atrs " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " em segundos " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " segundos atrs " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " em segundos " ,  " in seconds " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Hoje s 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Hoje s 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Hoje s 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Amanh s 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Hoje s 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52 ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 ' ,  ' 30 ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 ' ,  ' 31 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Ianuarie Ian_Februarie Feb_Martie Mar_Aprilie Apr_Mai Mai_Iunie Iun_Iulie Iul_August Aug_Septembrie Sep_Octombrie Oct_Noiembrie Noi_Decembrie Dec ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Duminic Dum Du_Luni Lun Lu_Mari Mar Ma_Miercuri Mie Mi_Joi Joi Jo_Vineri Vin Vi_Smbt Sm S ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " un an " ,      " 345 zile = un an " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " un an " ,      " 547 zile = un an " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 ani " ,      " 548 zile = 2 ani " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " un an " ,      " 1 an = un an " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 ani " ,      " 5 ani = 5 ani " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " peste cteva secunde " ,   " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " peste cteva secunde " ,   " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " cteva secunde n urm " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " peste cteva secunde " ,   " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " cteva secunde n urm " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " cteva secunde n urm " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " cteva secunde n urm " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " peste cteva secunde " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " azi la 2:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " azi la 2:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " azi la 3:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " mine la 2:00 " ,   " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " azi la 1:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30 . ' ,  ' 30 . ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31 . ' ,  ' 31 . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' januar jan . _februar feb . _marec mar . _april apr . _maj maj . _junij jun . _julij jul . _avgust avg . _september sep . _oktober okt . _november nov . _december dec . ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' nedelja ned . ne_ponedeljek pon . po_torek tor . to_sreda sre . sr_etrtek et . e_petek pet . pe_sobota sob . so ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " eno leto " ,    " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " eno leto " ,    " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 leti " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " eno leto " ,    " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 let " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " ez nekaj sekund " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " ez nekaj sekund " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " nekaj sekund nazaj " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " ez nekaj sekund " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " nekaj sekund nazaj " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " nekaj sekund nazaj " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " nekaj sekund nazaj " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " ez nekaj sekund " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " danes ob 2:00 " ,  " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " danes ob 2:25 " ,  " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " danes ob 3:00 " ,  " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " jutri ob 2:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " danes ob 1:00 " ,  " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . ' ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1 . ' ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . ' ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2 . ' ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30e ' ,  ' 30e ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31a ' ,  ' 31a ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' sndag sn s_mndag mn m_tisdag tis ti_onsdag ons on_torsdag tor to_fredag fre fr_lrdag lr l ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " ett r " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " ett r " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 r " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " ett r " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 r " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om ngra sekunder " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om ngra sekunder " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fr ngra sekunder sedan " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " om ngra sekunder " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " fr ngra sekunder sedan " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " fr ngra sekunder sedan " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " fr ngra sekunder sedan " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " om ngra sekunder " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Idag klockan 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Idag klockan 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Idag klockan 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Imorgon klockan 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Idag klockan 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . week ( ) , 52 ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . week ( ) ,  1 ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . week ( ) ,  1 ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . week ( ) ,  2 ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( ) , 2 ,  " Jan 15 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 53 ,  " Dec 28 2009 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 53 ,  " Jan 1 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 53 ,  " Jan 3 2010 should be week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) ,  1 ,  " Jan 4 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) ,  1 ,  " Jan 10 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) ,  2 ,  " Jan 11 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 52 ,  " Dec 27 2010 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 52 ,  " Jan 1 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 52 ,  " Jan 2 2011 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) ,  1 ,  " Jan 3 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) ,  1 ,  " Jan 9 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) ,  2 ,  " Jan 10 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' w ww wo ' ) ,  ' 52 52 52a ' ,  " Jan 1 2012 should be week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1a '  ,  " Jan 2 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' w ww wo ' ) ,  ' 1 01 1a '  ,  " Jan 8 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' w ww wo ' ) ,  ' 2 02 2a '  ,  " Jan 9 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , 0 , 30 ] ) . format ( ' DDDo ' ) ,  ' 30\ ' uncu ' ,  ' 30th ' ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . format ( ' DDDo ' ) ,  ' 31\ ' inci ' ,  ' 31st ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format month " : function ( test )  {%NWL%test . expect ( 12 ) ;%NWL%var expected = ' Ocak Oca_ubat ub_Mart Mar_Nisan Nis_Mays May_Haziran Haz_Temmuz Tem_Austos Au_Eyll Eyl_Ekim Eki_Kasm Kas_Aralk Ara ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2011 , i , 1 ] ) . format ( ' MMMM MMM ' ) , expected [ i ] , expected [ i ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" format week " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var expected = ' Pazar Paz Pz_Pazartesi Pts Pt_Sal Sal Sa_aramba ar a_Perembe Per Pe_Cuma Cum Cu_Cumartesi Cts Ct ' . split ( " _ " ) ;%NWL%var i;%NWL%for ( i = 0; i < expected . length; i + + )  {%NWL%test . equal ( moment ( [ 2011 , 0 , 2 + i ] ) . format ( ' dddd ddd dd ' ) , expected [ i ] , expected [ i ] ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:345 } ) , true ) ,  " bir yl " ,     " 345 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:547 } ) , true ) ,  " bir yl " ,     " 547 days = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { d:548 } ) , true ) ,  " 2 yl " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:1 } ) , true ) ,   " bir yl " ,     " 1 year = a year " ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { y:5 } ) , true ) ,   " 5 yl " ,     " 5 years = 5 years " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " birka saniye sonra " ,  " prefix " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " birka saniye sonra " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " birka saniye nce " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( 30000 ) . from ( 0 ) ,  " birka saniye sonra " ,  " prefix " ) ;%NWL%test . equal ( moment ( 0 ) . from ( 30000 ) ,  " birka saniye nce " ,  " suffix " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " birka saniye nce " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" now from now " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ) . fromNow ( ) ,  " birka saniye nce " ,  " now from now should display as in the past " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" fromNow " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ) . add ( { s:30 } ) . fromNow ( ) ,  " birka saniye sonra " ,  " in a few seconds " ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " bugn saat 02:00 " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " bugn saat 02:25 " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " bugn saat 03:00 " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " yarn saat 02:00 " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " bugn saat 01:00 " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( weeksAgo . calendar ( ) ,    weeksAgo . format ( ' L ' ) ,  " 2 weeks ago " ) ;%NWL%test . equal ( weeksFromNow . calendar ( ) ,  weeksFromNow . format ( ' L ' ) ,  " in 2 weeks " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . week ( ) , 1 ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . week ( ) , 2 ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . week ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  9 ] ) . week ( ) , 3 ,  " Jan 9 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . week ( ) ,  1 ,  " Jan 1 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . week ( ) ,  1 ,  " Jan 7 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . week ( ) ,  2 ,  " Jan 8 2007 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . week ( ) , 2 ,  " Jan 14 2007 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . week ( ) , 3 ,  " Jan 15 2007 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . week ( ) , 1 ,  " Dec 31 2007 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . week ( ) , 1 ,  " Jan 6 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . week ( ) , 2 ,  " Jan 7 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . week ( ) , 2 ,  " Jan 13 2008 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . week ( ) , 3 ,  " Jan 14 2008 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . week ( ) , 1 ,  " Dec 30 2002 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . week ( ) , 1 ,  " Jan 5 2003 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . week ( ) , 2 ,  " Jan 6 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . week ( ) , 2 ,  " Jan 12 2003 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . week ( ) , 3 ,  " Jan 13 2003 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . week ( ) , 1 ,  " Dec 29 2008 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . week ( ) , 1 ,  " Jan 4 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . week ( ) , 2 ,  " Jan 5 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . week ( ) , 2 ,  " Jan 11 2009 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 12 ] ) . week ( ) , 3 ,  " Jan 12 2009 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . week ( ) , 1 ,  " Dec 28 2009 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . week ( ) , 1 ,  " Jan 3 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . week ( ) , 2 ,  " Jan 4 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . week ( ) , 2 ,  " Jan 10 2010 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . week ( ) , 3 ,  " Jan 11 2010 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . week ( ) , 1 ,  " Dec 27 2010 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . week ( ) , 1 ,  " Jan 1 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . week ( ) , 1 ,  " Jan 2 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . week ( ) , 2 ,  " Jan 3 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . week ( ) , 2 ,  " Jan 9 2011 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . week ( ) , 3 ,  " Jan 10 2011 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2011 , 11 , 26 ] ) . format ( ' w ww wo ' ) ,  " 1 01 1 ' inci " ,  " Dec 26 2011 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  1 ] ) . format ( ' w ww wo ' ) ,  " 1 01 1 ' inci " ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  2 ] ) . format ( ' w ww wo ' ) ,  " 2 02 2 ' nci " ,  " Jan 2 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 ,  0 ,  8 ] ) . format ( ' w ww wo ' ) ,  " 2 02 2 ' nci " ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
self . oppositeTextColor = useWhite ? ' #000 ' : ' #fff ' ;%NWL%self . fontFamily = i . baseFontFamily;%NWL%self . fontSize = i . baseFontSize;%NWL%self . largeFontSize = self . fontSize + 2;%NWL%%NWL%self . backgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 5 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%6
self . fontFamily = i . baseFontFamily;%NWL%self . fontSize = i . baseFontSize;%NWL%self . largeFontSize = self . fontSize + 2;%NWL%%NWL%self . backgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 5 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%%NWL%self . textBackgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%6
%NWL%self . backgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 5 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%%NWL%self . textBackgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%2
self . backgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 5 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%%NWL%self . textBackgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . bodyColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%2
Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 5 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%%NWL%self . textBackgroundColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . bodyColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%0 . 75 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%2
Math . floor ( background . blue )  +  ' , '  +%NWL%( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . bodyColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 75 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . haloColor = ' rgba ( '  +  ( 255 - Math . floor ( background . red ) )  +  ' , '  +%NWL%( 255 - Math . floor ( background . green ) )  +  ' , '  +%NWL%( 255 - Math . floor ( background . blue ) )  +  ' , '  +%NWL%( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%3
( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . bodyColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 75 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . haloColor = ' rgba ( '  +  ( 255 - Math . floor ( background . red ) )  +  ' , '  +%NWL%( 255 - Math . floor ( background . green ) )  +  ' , '  +%NWL%( 255 - Math . floor ( background . blue ) )  +  ' , '  +%NWL%( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . buttonColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%3
self . bodyColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%Math . floor ( background . blue )  +  ' , '  +%NWL%0 . 75 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . haloColor = ' rgba ( '  +  ( 255 - Math . floor ( background . red ) )  +  ' , '  +%NWL%( 255 - Math . floor ( background . green ) )  +  ' , '  +%NWL%( 255 - Math . floor ( background . blue ) )  +  ' , '  +%NWL%( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%self . buttonColor = ' rgba ( '  + Math . floor ( background . red )  +  ' , '  +%NWL%Math . floor ( background . green )  +  ' , '  +%NWL%0 . 25 *  ( background . alpha / 255 . 0 )  +  ' ) ' ;%NWL%3
%NWL%%NWL%ExtensionManager . prototype . notifyRefresh = function ( )  {%NWL%var self = this;%NWL%%NWL%if ( DOM . docName === undefined )  {%NWL%self . disableUI ( ) ;%NWL%DOM . disableUI ( ) ;%NWL%CODE . disableUI ( ) ;%NWL%MAP . disableUI ( ) ;%NWL%self . onRefresh ( ) ;%NWL%6
%NWL%ExtensionManager . prototype . notifyRefresh = function ( )  {%NWL%var self = this;%NWL%%NWL%if ( DOM . docName === undefined )  {%NWL%self . disableUI ( ) ;%NWL%DOM . disableUI ( ) ;%NWL%CODE . disableUI ( ) ;%NWL%MAP . disableUI ( ) ;%NWL%} else {%NWL%DOM . onRefresh ( ) ;%NWL%6
ExtensionManager . prototype . notifyRefresh = function ( )  {%NWL%var self = this;%NWL%%NWL%if ( DOM . docName === undefined )  {%NWL%self . disableUI ( ) ;%NWL%DOM . disableUI ( ) ;%NWL%CODE . disableUI ( ) ;%NWL%MAP . disableUI ( ) ;%NWL%} else {%NWL%self . onRefresh ( ) ;%NWL%CODE . onRefresh ( ) ;%NWL%6
var self = this;%NWL%%NWL%if ( DOM . docName === undefined )  {%NWL%self . disableUI ( ) ;%NWL%DOM . disableUI ( ) ;%NWL%CODE . disableUI ( ) ;%NWL%MAP . disableUI ( ) ;%NWL%} else {%NWL%self . onRefresh ( ) ;%NWL%DOM . onRefresh ( ) ;%NWL%MAP . onRefresh ( ) ;%NWL%6
MAP . onRefresh ( ) ;%NWL%}%NWL%} ;%NWL%ExtensionManager . prototype . disableUI = function ( )  {%NWL%ejQuery ( ' #applyButton , #combinedApplyButton ' ) . attr ( ' disabled ' , true ) ;%NWL%} ;%NWL%ExtensionManager . prototype . onRefresh = function ( )  {%NWL%ejQuery ( ' #applyButton , #combinedApplyButton ' ) . attr ( ' disabled ' , false ) ;%NWL%} ;%NWL%%NWL%MAP . onNewData ( ) ;%NWL%0
%NWL%extensionScope . EXTENSION = new ExtensionManager ( ) ;%NWL%extensionScope . EXAMPLES = new ExamplesManager ( ) ;%NWL%extensionScope . ILLUSTRATOR = new IllustratorConnection ( ) ;%NWL%extensionScope . DATA = new DataManager ( ) ;%NWL%extensionScope . MAP = new MappingManager ( ) ;%NWL%extensionScope . DOM = new DomManager ( ) ;%NWL%extensionScope . CODE = new CodeManager ( ) ;%NWL%%NWL%extensionScope . EXTENSION . init ( ) ;%NWL%extensionScope . ILLUSTRATOR . init ( ) ;%NWL%9
extensionScope . EXTENSION = new ExtensionManager ( ) ;%NWL%extensionScope . EXAMPLES = new ExamplesManager ( ) ;%NWL%extensionScope . ILLUSTRATOR = new IllustratorConnection ( ) ;%NWL%extensionScope . DATA = new DataManager ( ) ;%NWL%extensionScope . MAP = new MappingManager ( ) ;%NWL%extensionScope . DOM = new DomManager ( ) ;%NWL%extensionScope . CODE = new CodeManager ( ) ;%NWL%%NWL%extensionScope . EXTENSION . init ( ) ;%NWL%extensionScope . EXAMPLES . init ( ) ;%NWL%extensionScope . DATA . init ( ) ;%NWL%8
extensionScope . EXAMPLES = new ExamplesManager ( ) ;%NWL%extensionScope . ILLUSTRATOR = new IllustratorConnection ( ) ;%NWL%extensionScope . DATA = new DataManager ( ) ;%NWL%extensionScope . MAP = new MappingManager ( ) ;%NWL%extensionScope . DOM = new DomManager ( ) ;%NWL%extensionScope . CODE = new CodeManager ( ) ;%NWL%%NWL%extensionScope . EXTENSION . init ( ) ;%NWL%extensionScope . EXAMPLES . init ( ) ;%NWL%extensionScope . ILLUSTRATOR . init ( ) ;%NWL%extensionScope . MAP . init ( ) ;%NWL%7
extensionScope . ILLUSTRATOR = new IllustratorConnection ( ) ;%NWL%extensionScope . DATA = new DataManager ( ) ;%NWL%extensionScope . MAP = new MappingManager ( ) ;%NWL%extensionScope . DOM = new DomManager ( ) ;%NWL%extensionScope . CODE = new CodeManager ( ) ;%NWL%%NWL%extensionScope . EXTENSION . init ( ) ;%NWL%extensionScope . EXAMPLES . init ( ) ;%NWL%extensionScope . ILLUSTRATOR . init ( ) ;%NWL%extensionScope . DATA . init ( ) ;%NWL%extensionScope . DOM . init ( ) ;%NWL%6
extensionScope . DATA = new DataManager ( ) ;%NWL%extensionScope . MAP = new MappingManager ( ) ;%NWL%extensionScope . DOM = new DomManager ( ) ;%NWL%extensionScope . CODE = new CodeManager ( ) ;%NWL%%NWL%extensionScope . EXTENSION . init ( ) ;%NWL%extensionScope . EXAMPLES . init ( ) ;%NWL%extensionScope . ILLUSTRATOR . init ( ) ;%NWL%extensionScope . DATA . init ( ) ;%NWL%extensionScope . MAP . init ( ) ;%NWL%extensionScope . CODE . init ( ) ;%NWL%5
test . ok ( moment ( [ 2010 , 1 , 12 , 1 , 1 ] ) . toDate ( ) instanceof Date ,  " [ 2010 , 1 , 12 , 1 , 1 ] " ) ;%NWL%test . ok ( moment ( [ 2010 , 1 , 12 , 1 , 1 , 1 ] ) . toDate ( ) instanceof Date ,  " [ 2010 , 1 , 12 , 1 , 1 , 1 ] " ) ;%NWL%test . ok ( moment ( [ 2010 , 1 , 12 , 1 , 1 , 1 , 1 ] ) . toDate ( ) instanceof Date ,  " [ 2010 , 1 , 12 , 1 , 1 , 1 , 1 ] " ) ;%NWL%test . equal ( + moment ( new Date ( 2010 , 1 , 14 , 15 , 25 , 50 , 125 ) ) ,  + moment ( [ 2010 , 1 , 14 , 15 , 25 , 50 , 125 ] ) ,  " constructing with array === constructing with new Date ( ) " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" array copying " : function ( test )  {%NWL%var importantArray = [ 2009 , 11 ] ;%NWL%test . expect ( 1 ) ;%NWL%moment ( importantArray ) ;%NWL%test . done ( ) ;%NWL%4
var importantArray = [ 2009 , 11 ] ;%NWL%test . expect ( 1 ) ;%NWL%moment ( importantArray ) ;%NWL%test . deepEqual ( importantArray ,  [ 2009 , 11 ] ,  " initializer should not mutate the original array " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" number " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . ok ( moment ( 1000 ) . toDate ( ) instanceof Date ,  " 1000 " ) ;%NWL%test . ok ( ( moment ( 1000 ) . valueOf ( ) === 1000 ) ,  " testing valueOf " ) ;%NWL%test . done ( ) ;%NWL%4
test . equal ( moment . unix ( 1000 ) . valueOf ( ) , 1000000 ,  " 1000 unix timestamp == 1000000 Date . valueOf " ) ;%NWL%test . equal ( moment ( 1500 ) . unix ( ) , 1 ,  " 1500 Date . valueOf == 1 unix timestamp " ) ;%NWL%test . equal ( moment ( 1900 ) . unix ( ) , 1 ,  " 1900 Date . valueOf == 1 unix timestamp " ) ;%NWL%test . equal ( moment ( 2100 ) . unix ( ) , 2 ,  " 2100 Date . valueOf == 2 unix timestamp " ) ;%NWL%test . equal ( moment ( 1333129333524 ) . unix ( ) , 1333129333 ,  " 1333129333524 Date . valueOf == 1333129333 unix timestamp " ) ;%NWL%test . equal ( moment ( 1333129333524000 ) . unix ( ) , 1333129333524 ,  " 1333129333524000 Date . valueOf == 1333129333524 unix timestamp " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" date " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
test . equal ( moment ( 2100 ) . unix ( ) , 2 ,  " 2100 Date . valueOf == 2 unix timestamp " ) ;%NWL%test . equal ( moment ( 1333129333524 ) . unix ( ) , 1333129333 ,  " 1333129333524 Date . valueOf == 1333129333 unix timestamp " ) ;%NWL%test . equal ( moment ( 1333129333524000 ) . unix ( ) , 1333129333524 ,  " 1333129333524000 Date . valueOf == 1333129333524 unix timestamp " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" date " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . ok ( moment ( new Date ( ) ) . toDate ( ) instanceof Date ,  " new Date ( ) " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 1 ) ;%NWL%6
test . done ( ) ;%NWL%} ,%NWL%" date " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . ok ( moment ( new Date ( ) ) . toDate ( ) instanceof Date ,  " new Date ( ) " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" date mutation " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var a = new Date ( ) ;%NWL%test . done ( ) ;%NWL%0
} ,%NWL%" date mutation " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var a = new Date ( ) ;%NWL%test . ok ( moment ( a ) . toDate ( ) !== a ,  " the date moment uses should not be the date passed in " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" moment " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . ok ( moment ( moment ( ) ) . toDate ( ) instanceof Date ,  " moment ( moment ( ) ) " ) ;%NWL%test . done ( ) ;%NWL%5
var a = new Date ( ) ;%NWL%test . ok ( moment ( a ) . toDate ( ) !== a ,  " the date moment uses should not be the date passed in " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" moment " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . ok ( moment ( moment ( ) ) . toDate ( ) instanceof Date ,  " moment ( moment ( ) ) " ) ;%NWL%test . ok ( moment ( moment ( moment ( ) ) ) . toDate ( ) instanceof Date ,  " moment ( moment ( moment ( ) ) ) " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%" moment " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . ok ( moment ( moment ( ) ) . toDate ( ) instanceof Date ,  " moment ( moment ( ) ) " ) ;%NWL%test . ok ( moment ( moment ( moment ( ) ) ) . toDate ( ) instanceof Date ,  " moment ( moment ( moment ( ) ) ) " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" cloning moment should only copy own properties " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . ok ( !moment ( ) . clone ( ) . hasOwnProperty ( ' month ' ) ,  " Should not clone prototype methods " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" cloning moment should only copy own properties " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . ok ( !moment ( ) . clone ( ) . hasOwnProperty ( ' month ' ) ,  " Should not clone prototype methods " ) ;%NWL%test . ok ( !moment ( ) . clone ( ) . hasOwnProperty ( ' _lang ' ) ,  " Should not clone prototype objects " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" undefined " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . ok ( !moment ( ) . clone ( ) . hasOwnProperty ( ' month ' ) ,  " Should not clone prototype methods " ) ;%NWL%test . ok ( !moment ( ) . clone ( ) . hasOwnProperty ( ' _lang ' ) ,  " Should not clone prototype objects " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" undefined " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . ok ( moment ( ) . toDate ( ) instanceof Date ,  " undefined " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" undefined " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . ok ( moment ( ) . toDate ( ) instanceof Date ,  " undefined " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string without format " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . ok ( moment ( " Aug 9 , 1995 " ) . toDate ( ) instanceof Date ,  " Aug 9 , 1995 " ) ;%NWL%test . done ( ) ;%NWL%0
test . ok ( moment ( " Aug 9 , 1995 " ) . toDate ( ) instanceof Date ,  " Aug 9 , 1995 " ) ;%NWL%test . ok ( moment ( " Mon , 25 Dec 1995 13:30:00 GMT " ) . toDate ( ) instanceof Date ,  " Mon , 25 Dec 1995 13:30:00 GMT " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string without format - json " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( " Date ( 1325132654000 ) " ) . valueOf ( ) , 1325132654000 ,  " Date ( 1325132654000 ) " ) ;%NWL%test . equal ( moment ( " Date ( - 1325132654000 ) " ) . valueOf ( ) ,  - 1325132654000 ,  " Date ( - 1325132654000 ) " ) ;%NWL%test . equal ( moment ( " / Date ( 1325132654000 ) / " ) . valueOf ( ) , 1325132654000 ,  " / Date ( 1325132654000 ) / " ) ;%NWL%test . equal ( moment ( " / Date ( 1325132654000 + 0700 ) / " ) . valueOf ( ) , 1325132654000 ,  " / Date ( 1325132654000 + 0700 ) / " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( " / Date ( 1325132654000 ) / " ) . valueOf ( ) , 1325132654000 ,  " / Date ( 1325132654000 ) / " ) ;%NWL%test . equal ( moment ( " / Date ( 1325132654000 + 0700 ) / " ) . valueOf ( ) , 1325132654000 ,  " / Date ( 1325132654000 + 0700 ) / " ) ;%NWL%test . equal ( moment ( " / Date ( 1325132654000 - 0700 ) / " ) . valueOf ( ) , 1325132654000 ,  " / Date ( 1325132654000 - 0700 ) / " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string with format dropped am / pm bug " : function ( test )  {%NWL%moment . lang ( ' en ' ) ;%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 12:25:00 am ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . done ( ) ;%NWL%3
test . done ( ) ;%NWL%} ,%NWL%" string with format dropped am / pm bug " : function ( test )  {%NWL%moment . lang ( ' en ' ) ;%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 12:25:00 am ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 12:25:00 pm ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 3 ) ;%NWL%4
test . expect ( 3 ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 12:25:00 am ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . equal ( moment ( ' 05 / 1 / 2012 12:25:00 pm ' ,  ' MM / DD / YYYY h:m:s a ' ) . format ( ' MM / DD / YYYY ' ) ,  ' 05 / 01 / 2012 ' ,  ' should not break if am / pm is left off from the parsing tokens ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" empty string with formats " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( '  ' ,  ' MM ' ) . format ( ' YYYY - MM - DD HH:mm:ss ' ) ,  ' 0000 - 01 - 01 00:00:00 ' ,  ' should not break if input is an empty string ' ) ;%NWL%test . equal ( moment ( '  ' ,  ' DD ' ) . format ( ' YYYY - MM - DD HH:mm:ss ' ) ,  ' 0000 - 01 - 01 00:00:00 ' ,  ' should not break if input is an empty string ' ) ;%NWL%test . done ( ) ;%NWL%4
} ,%NWL%" empty string with formats " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( '  ' ,  ' MM ' ) . format ( ' YYYY - MM - DD HH:mm:ss ' ) ,  ' 0000 - 01 - 01 00:00:00 ' ,  ' should not break if input is an empty string ' ) ;%NWL%test . equal ( moment ( '  ' ,  ' DD ' ) . format ( ' YYYY - MM - DD HH:mm:ss ' ) ,  ' 0000 - 01 - 01 00:00:00 ' ,  ' should not break if input is an empty string ' ) ;%NWL%test . equal ( moment ( '  ' ,  [ ' MM ' ,  " DD " ] ) . format ( ' YYYY - MM - DD HH:mm:ss ' ) ,  ' 0000 - 01 - 01 00:00:00 ' ,  ' should not break if input is an empty string ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" matching am / pm " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
test . equal ( c . hours ( ) , d . hours ( ) ,  ' 10 am central time == 8 am pacific time ' ) ;%NWL%var e = moment . utc ( ' Fri , 20 Jul 2012 17:15:00 ' ,  ' ddd , DD MMM YYYY HH:mm:ss ' ) ;%NWL%var f = moment . utc ( ' Fri , 20 Jul 2012 10:15:00 - 0700 ' ,  ' ddd , DD MMM YYYY HH:mm:ss ZZ ' ) ;%NWL%test . equal ( e . hours ( ) , f . hours ( ) ,  ' parse timezone offset in utc ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string with array of formats " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( ' 13 - 02 - 1999 ' ,  [ ' MM - DD - YYYY ' ,  ' DD - MM - YYYY ' ] ) . format ( ' MM DD YYYY ' ) ,  ' 02 13 1999 ' ,  ' switching month and day ' ) ;%NWL%test . equal ( moment ( ' 02 - 13 - 1999 ' ,  [ ' MM / DD / YYYY ' ,  ' YYYY - MM - DD ' ,  ' MM - DD - YYYY ' ] ) . format ( ' MM DD YYYY ' ) ,  ' 02 13 1999 ' ,  ' year last ' ) ;%NWL%test . done ( ) ;%NWL%4
test . equal ( moment ( ' 13 - 02 - 1999 ' ,  [ ' MM - DD - YYYY ' ,  ' DD - MM - YYYY ' ] ) . format ( ' MM DD YYYY ' ) ,  ' 02 13 1999 ' ,  ' switching month and day ' ) ;%NWL%test . equal ( moment ( ' 02 - 13 - 1999 ' ,  [ ' MM / DD / YYYY ' ,  ' YYYY - MM - DD ' ,  ' MM - DD - YYYY ' ] ) . format ( ' MM DD YYYY ' ) ,  ' 02 13 1999 ' ,  ' year last ' ) ;%NWL%test . equal ( moment ( ' 1999 - 02 - 13 ' ,  [ ' MM / DD / YYYY ' ,  ' YYYY - MM - DD ' ,  ' MM - DD - YYYY ' ] ) . format ( ' MM DD YYYY ' ) ,  ' 02 13 1999 ' ,  ' year first ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string with format - years " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%test . equal ( moment ( ' 67 ' ,  ' YY ' ) . format ( ' YYYY ' ) ,  ' 2067 ' ,  ' 67 > 2067 ' ) ;%NWL%test . equal ( moment ( ' 68 ' ,  ' YY ' ) . format ( ' YYYY ' ) ,  ' 2068 ' ,  ' 68 > 2068 ' ) ;%NWL%test . equal ( moment ( ' 69 ' ,  ' YY ' ) . format ( ' YYYY ' ) ,  ' 1969 ' ,  ' 69 > 1969 ' ) ;%NWL%test . done ( ) ;%NWL%3
test . equal ( moment ( ' 69 ' ,  ' YY ' ) . format ( ' YYYY ' ) ,  ' 1969 ' ,  ' 69 > 1969 ' ) ;%NWL%test . equal ( moment ( ' 70 ' ,  ' YY ' ) . format ( ' YYYY ' ) ,  ' 1970 ' ,  ' 70 > 1970 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" implicit cloning " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var momentA = moment ( [ 2011 , 10 , 10 ] ) ;%NWL%var momentB = moment ( momentA ) ;%NWL%momentA . month ( 5 ) ;%NWL%test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" implicit cloning " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var momentA = moment ( [ 2011 , 10 , 10 ] ) ;%NWL%var momentB = moment ( momentA ) ;%NWL%momentA . month ( 5 ) ;%NWL%test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . equal ( momentA . month ( ) , 5 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%2
var momentA = moment ( [ 2011 , 10 , 10 ] ) ;%NWL%var momentB = moment ( momentA ) ;%NWL%momentA . month ( 5 ) ;%NWL%test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . equal ( momentA . month ( ) , 5 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" explicit cloning " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var momentA = moment ( [ 2011 , 10 , 10 ] ) ;%NWL%momentA . month ( 5 ) ;%NWL%2
var momentB = moment ( momentA ) ;%NWL%momentA . month ( 5 ) ;%NWL%test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . equal ( momentA . month ( ) , 5 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" explicit cloning " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var momentA = moment ( [ 2011 , 10 , 10 ] ) ;%NWL%var momentB = momentA . clone ( ) ;%NWL%test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%2
momentA . month ( 5 ) ;%NWL%test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . equal ( momentA . month ( ) , 5 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" explicit cloning " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var momentA = moment ( [ 2011 , 10 , 10 ] ) ;%NWL%var momentB = momentA . clone ( ) ;%NWL%momentA . month ( 5 ) ;%NWL%test . equal ( momentA . month ( ) , 5 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%2
test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . equal ( momentA . month ( ) , 5 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" explicit cloning " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var momentA = moment ( [ 2011 , 10 , 10 ] ) ;%NWL%var momentB = momentA . clone ( ) ;%NWL%momentA . month ( 5 ) ;%NWL%test . equal ( momentB . month ( ) , 10 ,  " Calling moment ( ) on a moment will create a clone " ) ;%NWL%test . done ( ) ;%NWL%2
] ;%NWL%test . expect ( formats . length ) ;%NWL%for ( i = 0; i < formats . length; i + + )  {%NWL%test . equal ( moment . utc ( formats [ i ] [ 0 ] ) . format ( ' YYYY - MM - DDTHH:mm:ss . SSSZ ' ) , formats [ i ] [ 1 ] ,  " moment should be able to parse ISO "  + formats [ i ] [ 0 ] ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" parsing iso Z timezone into local " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var m = moment ( ' 2011 - 10 - 08T18:04:20 . 111Z ' ) ;%NWL%test . done ( ) ;%NWL%5
" parsing iso Z timezone into local " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var m = moment ( ' 2011 - 10 - 08T18:04:20 . 111Z ' ) ;%NWL%test . equal ( m . utc ( ) . format ( ' YYYY - MM - DDTHH:mm:ss . SSS ' ) ,  ' 2011 - 10 - 08T18:04:20 . 111 ' ,  " moment should be able to parse ISO 2011 - 10 - 08T18:04:20 . 111Z " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" null " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment ( ' ' ) , null ,  " Calling moment ( ' ' ) " ) ;%NWL%test . equal ( moment ( null ) , null ,  " Calling moment ( null ) " ) ;%NWL%test . done ( ) ;%NWL%4
test . equal ( moment ( " 270000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getFullYear ( ) , 270000 ,  " parse AD 270 , 000 " ) ;%NWL%test . equal ( moment ( " + 270000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getFullYear ( ) , 270000 ,  " parse AD + 270 , 000 " ) ;%NWL%test . equal ( moment . utc ( " - 270000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getUTCFullYear ( ) ,  - 270000 ,  " parse utc BC 270 , 001 " ) ;%NWL%test . equal ( moment . utc ( " 270000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getUTCFullYear ( ) , 270000 ,  " parse utc AD 270 , 000 " ) ;%NWL%test . equal ( moment . utc ( " + 270000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getUTCFullYear ( ) , 270000 ,  " parse utc AD + 270 , 000 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" negative four digit years " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( " - 1000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getFullYear ( ) ,  - 1000 ,  " parse BC 1 , 001 " ) ;%NWL%test . done ( ) ;%NWL%5
test . equal ( moment . utc ( " 270000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getUTCFullYear ( ) , 270000 ,  " parse utc AD 270 , 000 " ) ;%NWL%test . equal ( moment . utc ( " + 270000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getUTCFullYear ( ) , 270000 ,  " parse utc AD + 270 , 000 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" negative four digit years " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( " - 1000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getFullYear ( ) ,  - 1000 ,  " parse BC 1 , 001 " ) ;%NWL%test . equal ( moment . utc ( " - 1000 - 01 - 01 " ,  " YYYYY - MM - DD " ) . toDate ( ) . getUTCFullYear ( ) ,  - 1000 ,  " parse utc BC 1 , 001 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
months [ i ] ,%NWL%moment ( [ 2012 , i , months [ i ] ] ) . format ( ' L ' )  +  " should have "  + months [ i ]  +  " days .  ( end of month "  + i +  ' ) ' )%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" days in month leap years " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%test . equal ( moment ( [ 2010 , 1 ] ) . daysInMonth ( ) , 28 ,  " Feb 2010 should have 28 days " ) ;%NWL%test . equal ( moment ( [ 2100 , 1 ] ) . daysInMonth ( ) , 28 ,  " Feb 2100 should have 28 days " ) ;%NWL%test . equal ( moment ( [ 2008 , 1 ] ) . daysInMonth ( ) , 29 ,  " Feb 2008 should have 29 days " ) ;%NWL%test . done ( ) ;%NWL%3
test . equal ( moment ( [ 2010 , 0 , 8 ] ) . diff ( [ 2010 ] ,  ' week ' ) , 1 ,  " week diff singular " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 21 ] ) . diff ( [ 2010 ] ,  ' week ' ) , 2 ,  " week diff singular " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 22 ] ) . diff ( [ 2010 ] ,  ' week ' ) , 3 ,  " week diff singular " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 4 ] ) . diff ( [ 2010 ] ,  ' hour ' ) , 4 ,  " hour diff singular " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 0 , 5 ] ) . diff ( [ 2010 ] ,  ' minute ' ) , 5 ,  " minute diff singular " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 0 , 0 , 6 ] ) . diff ( [ 2010 ] ,  ' second ' ) , 6 ,  " second diff singular " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" diff month " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
test . done ( ) ;%NWL%} ,%NWL%" diff month " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 31 ] ) . diff ( [ 2011 , 2 , 1 ] ,  ' months ' ) ,  - 1 ,  " month diff " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" diff across DST " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( [ 2012 , 2 , 24 ] ) . diff ( [ 2012 , 2 , 10 ] ,  ' weeks ' , true ) , 2 ,  " diff weeks across DST " ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( [ 2012 , 2 , 24 ] ) . diff ( [ 2012 , 2 , 10 ] ,  ' weeks ' , true ) , 2 ,  " diff weeks across DST " ) ;%NWL%test . equal ( moment ( [ 2012 , 2 , 24 ] ) . diff ( [ 2012 , 2 , 10 ] ,  ' days ' , true ) , 14 ,  " diff weeks across DST " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" diff overflow " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%test . equal ( moment ( [ 2011 ] ) . diff ( [ 2010 ] ,  ' months ' ) , 12 ,  " month diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 2 ] ) . diff ( [ 2010 ] ,  ' hours ' ) , 24 ,  " hour diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 2 ] ) . diff ( [ 2010 ] ,  ' minutes ' ) , 120 ,  " minute diff " ) ;%NWL%test . done ( ) ;%NWL%3
test . done ( ) ;%NWL%} ,%NWL%" diff between utc and local " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%test . equal ( moment ( [ 2011 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' years ' ) , 1 ,  " year diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 2 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' months ' ) , 2 ,  " month diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 4 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' days ' ) , 3 ,  " day diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 22 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' weeks ' ) , 3 ,  " week diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 4 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' hours ' ) , 4 ,  " hour diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 0 , 5 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' minutes ' ) , 5 ,  " minute diff " ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 7 ) ;%NWL%test . equal ( moment ( [ 2011 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' years ' ) , 1 ,  " year diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 2 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' months ' ) , 2 ,  " month diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 4 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' days ' ) , 3 ,  " day diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 22 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' weeks ' ) , 3 ,  " week diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 4 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' hours ' ) , 4 ,  " hour diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 0 , 5 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' minutes ' ) , 5 ,  " minute diff " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 0 , 0 , 6 ] ) . utc ( ) . diff ( [ 2010 ] ,  ' seconds ' ) , 6 ,  " second diff " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 7 ) ;%NWL%0
test . done ( ) ;%NWL%} ,%NWL%" diff floored " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 23 ] ) . diff ( [ 2010 ] ,  ' day ' ) , 0 ,  " 23 hours = 0 days " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 23 , 59 ] ) . diff ( [ 2010 ] ,  ' day ' ) , 0 ,  " 23:59 hours = 0 days " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 24 ] ) . diff ( [ 2010 ] ,  ' day ' ) , 1 ,  " 24 hours = 1 day " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 2 ] ) . diff ( [ 2011 , 0 , 1 ] ,  ' year ' ) , 0 ,  " year rounded down " ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 1 ] ) . diff ( [ 2010 , 0 , 2 ] ,  ' year ' ) , 0 ,  " year rounded down " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 2 ] ) . diff ( [ 2011 , 0 , 2 ] ,  ' year ' ) ,  - 1 ,  " year rounded down " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( moment ( [ 2010 , 0 , 1 , 23 , 59 ] ) . diff ( [ 2010 ] ,  ' day ' ) , 0 ,  " 23:59 hours = 0 days " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 1 , 24 ] ) . diff ( [ 2010 ] ,  ' day ' ) , 1 ,  " 24 hours = 1 day " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 2 ] ) . diff ( [ 2011 , 0 , 1 ] ,  ' year ' ) , 0 ,  " year rounded down " ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 1 ] ) . diff ( [ 2010 , 0 , 2 ] ,  ' year ' ) , 0 ,  " year rounded down " ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 2 ] ) . diff ( [ 2011 , 0 , 2 ] ,  ' year ' ) ,  - 1 ,  " year rounded down " ) ;%NWL%test . equal ( moment ( [ 2011 , 0 , 2 ] ) . diff ( [ 2010 , 0 , 2 ] ,  ' year ' ) , 1 ,  " year rounded down " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" year diffs include dates " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
test . equal ( d . weeks ( ) ,     2 ,  " weeks " ) ;%NWL%test . equal ( d . days ( ) ,     15 ,  " days " ) ; / / two weeks + 1 day%NWL%test . equal ( d . hours ( ) ,     8 ,  " hours " ) ;%NWL%test . equal ( d . minutes ( ) ,    9 ,  " minutes " ) ;%NWL%test . equal ( d . seconds ( ) ,    20 ,  " seconds " ) ;%NWL%test . equal ( d . milliseconds ( ) , 12 ,  " milliseconds " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" milliseconds instantiation " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
test . equal ( moment . duration ( { days: 548 } ) . humanize ( ) ,   " 2 years " ,     " 548 days = 2 years " ) ;%NWL%test . equal ( moment . duration ( { years: 1 } ) . humanize ( ) ,    " a year " ,     " 1 year = a year " ) ;%NWL%test . equal ( moment . duration ( { years: 5 } ) . humanize ( ) ,    " 5 years " ,     " 5 years = 5 years " ) ;%NWL%test . equal ( moment . duration ( 7200000 ) . humanize ( ) ,     " 2 hours " ,     " 7200000 = 2 minutes " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" humanize duration with suffix " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%moment . lang ( ' en ' ) ;%NWL%test . equal ( moment . duration ( { seconds: 44 } ) . humanize ( true ) ,  " in a few seconds " ,  " 44 seconds = a few seconds " ) ;%NWL%test . done ( ) ;%NWL%4
test . equal ( moment . duration ( { seconds: 44 } ) . humanize ( true ) ,  " in a few seconds " ,  " 44 seconds = a few seconds " ) ;%NWL%test . equal ( moment . duration ( { seconds: - 44 } ) . humanize ( true ) ,  " a few seconds ago " ,  " 44 seconds = a few seconds " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" bubble value up " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment . duration ( { milliseconds: 61001 } ) . milliseconds ( ) , 1 ,  " 61001 milliseconds has 1 millisecond left over " ) ;%NWL%test . equal ( moment . duration ( { milliseconds: 61001 } ) . seconds ( ) ,    1 ,  " 61001 milliseconds has 1 second left over " ) ;%NWL%test . equal ( moment . duration ( { milliseconds: 61001 } ) . minutes ( ) ,    1 ,  " 61001 milliseconds has 1 minute left over " ) ;%NWL%test . equal ( moment . duration ( { minutes: 350 } ) . minutes ( ) , 50 ,  " 350 minutes has 50 minutes left over " ) ;%NWL%test . done ( ) ;%NWL%2
test . done ( ) ;%NWL%} ,%NWL%" effective equivalency " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%test . deepEqual ( moment . duration ( { seconds: 1 } ) . _data ,  moment . duration ( { milliseconds: 1000 } ) . _data ,  " 1 second is the same as 1000 milliseconds " ) ;%NWL%test . deepEqual ( moment . duration ( { seconds: 60 } ) . _data , moment . duration ( { minutes: 1 } ) . _data ,      " 1 minute is the same as 60 seconds " ) ;%NWL%test . deepEqual ( moment . duration ( { minutes: 60 } ) . _data , moment . duration ( { hours: 1 } ) . _data ,       " 1 hour is the same as 60 minutes " ) ;%NWL%test . deepEqual ( moment . duration ( { hours: 24 } ) . _data ,  moment . duration ( { days: 1 } ) . _data ,       " 1 day is the same as 24 hours " ) ;%NWL%test . deepEqual ( moment . duration ( { days: 7 } ) . _data ,   moment . duration ( { weeks: 1 } ) . _data ,       " 1 week is the same as 7 days " ) ;%NWL%test . deepEqual ( moment . duration ( { days: 30 } ) . _data ,   moment . duration ( { months: 1 } ) . _data ,      " 1 month is the same as 30 days " ) ;%NWL%test . done ( ) ;%NWL%0
test . equal ( Math . round ( d . asHours ( )  * 100 )  / 100 ,  19808 . 16 ,   " hours " ) ;%NWL%test . equal ( Math . round ( d . asMinutes ( )  * 100 )  / 100 , 1188489 . 33 ,  " minutes " ) ;%NWL%test . equal ( Math . round ( d . asSeconds ( )  * 100 )  / 100 , 71309360 . 01 ,  " seconds " ) ;%NWL%test . equal ( d . asMilliseconds ( ) ,           71309360012 ,  " milliseconds " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" isDuration " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . ok ( moment . isDuration ( moment . duration ( 12345678 ) ) ,  " correctly says true " ) ;%NWL%test . ok ( !moment . isDuration ( moment ( ) ) ,  " moment object is not a duration " ) ;%NWL%test . done ( ) ;%NWL%4
test . done ( ) ;%NWL%} ,%NWL%" format timezone " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var b = moment ( new Date ( 2010 , 1 , 14 , 15 , 25 , 50 , 125 ) ) ;%NWL%var explanation = ' moment ( ) . format ( " z " ) = '  + b . format ( ' z ' )  +  ' It should be something like " PST " '%NWL%if ( moment ( ) . zone ( ) === - 60 )  {%NWL%explanation + = " For UTC + 1 this is a known issue , see https: / / github . com / timrwood / moment / issues / 162 " ;%NWL%}%NWL%test . ok ( b . format ( ' Z ' ) . match ( / ^ [ \ + \ - ] \d\d:\d\d$ / ) , b . format ( ' Z ' )  +  ' should be something like " + 07:30 " ' ) ;%NWL%test . done ( ) ;%NWL%0
if ( moment ( ) . zone ( ) === - 60 )  {%NWL%explanation + = " For UTC + 1 this is a known issue , see https: / / github . com / timrwood / moment / issues / 162 " ;%NWL%}%NWL%test . ok ( b . format ( ' Z ' ) . match ( / ^ [ \ + \ - ] \d\d:\d\d$ / ) , b . format ( ' Z ' )  +  ' should be something like " + 07:30 " ' ) ;%NWL%test . ok ( b . format ( ' ZZ ' ) . match ( / ^ [ \ + \ - ] \d { 4 } $ / ) , b . format ( ' ZZ ' )  +  ' should be something like " + 0700 " ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" format multiple with zone " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var b = moment ( ' 2012 - 10 - 08 - 1200 ' ,  [ ' YYYY ZZ ' ,  ' YYYY - MM - DD ZZ ' ] ) ;%NWL%test . done ( ) ;%NWL%5
jul1 = moment ( [ 2011 , 6 ] ) ;%NWL%if ( janIsDst && julIsDst )  {%NWL%test . ok ( 0 ,  ' January and July cannot both be in DST ' ) ;%NWL%test . ok ( 0 ,  ' January and July cannot both be in DST ' ) ;%NWL%} else if ( janIsDst )  {%NWL%test . ok ( jan1 . isDST ( ) ,  ' January 1 is DST ' ) ;%NWL%test . ok ( !jul1 . isDST ( ) ,  ' July 1 is not DST ' ) ;%NWL%} else if ( julIsDst )  {%NWL%test . ok ( !jan1 . isDST ( ) ,  ' January 1 is not DST ' ) ;%NWL%test . ok ( jul1 . isDST ( ) ,  ' July 1 is DST ' ) ;%NWL%test . ok ( !jan1 . isDST ( ) ,  ' January 1 is not DST ' ) ;%NWL%8
if ( janIsDst && julIsDst )  {%NWL%test . ok ( 0 ,  ' January and July cannot both be in DST ' ) ;%NWL%test . ok ( 0 ,  ' January and July cannot both be in DST ' ) ;%NWL%} else if ( janIsDst )  {%NWL%test . ok ( jan1 . isDST ( ) ,  ' January 1 is DST ' ) ;%NWL%test . ok ( !jul1 . isDST ( ) ,  ' July 1 is not DST ' ) ;%NWL%} else if ( julIsDst )  {%NWL%test . ok ( !jan1 . isDST ( ) ,  ' January 1 is not DST ' ) ;%NWL%test . ok ( jul1 . isDST ( ) ,  ' July 1 is DST ' ) ;%NWL%} else {%NWL%test . ok ( !jul1 . isDST ( ) ,  ' July 1 is not DST ' ) ;%NWL%5
test . ok ( !jul1 . isDST ( ) ,  ' July 1 is not DST ' ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" unix timestamp " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%var m = moment ( ' 1234567890 . 123 ' ,  ' X ' ) ;%NWL%test . equals ( m . format ( ' X ' ) ,  ' 1234567890 ' ,  ' unix timestamp without milliseconds ' ) ;%NWL%test . equals ( m . format ( ' X . S ' ) ,  ' 1234567890 . 1 ' ,  ' unix timestamp with deciseconds ' ) ;%NWL%test . equals ( m . format ( ' X . SS ' ) ,  ' 1234567890 . 12 ' ,  ' unix timestamp with centiseconds ' ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( ) . zone ( ) , 0 ,  ' moment . fn . zone should be a multiple of 15 ( was '  + moment ( ) . zone ( )  +  ' ) ' ) ;%NWL%} else {%NWL%test . equal ( moment ( ) . zone ( ) % 15 , 0 ,  ' moment . fn . zone should be a multiple of 15 ( was '  + moment ( ) . zone ( )  +  ' ) ' ) ;%NWL%}%NWL%test . equal ( moment ( ) . zone ( ) , new Date ( ) . getTimezoneOffset ( ) ,  ' zone should equal getTimezoneOffset ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" default format " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var isoRegex = / \d { 4 } . \d\d . \d\dT\d\d . \d\d . \d\d [ \ + \ - ] \d\d:\d\d / ;%NWL%test . done ( ) ;%NWL%5
test . ok ( isoRegex . exec ( moment ( ) . format ( ) ) ,  " default format ( "  + moment ( ) . format ( )  +  " ) should match ISO " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" escaping quotes " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%moment . lang ( ' en ' ) ;%NWL%var date = moment ( [ 2012 , 0 ] ) ;%NWL%test . equal ( date . format ( ' MMM \ ' YY ' ) ,  " Jan ' 12 " ,  " Should be able to format with single parenthesis " ) ;%NWL%test . equal ( date . format ( ' MMM " YY ' ) ,  ' Jan " 12 ' ,  " Should be able to format with double parenthesis " ) ;%NWL%test . equal ( date . format ( " MMM ' YY " ) ,  " Jan ' 12 " ,  " Should be able to format with single parenthesis " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( date . format ( " MMM \ " YY " ) ,  ' Jan " 12 ' ,  " Should be able to format with double parenthesis " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" toJSON " : function ( test )  {%NWL%var supportsJson = typeof JSON !== " undefined " && JSON . stringify && JSON . stringify . call ,%NWL%date = moment . utc ( " 2012 - 10 - 09T20:30:40 . 678 " ) ;%NWL%test . expect ( supportsJson ? 2 : 1 ) ;%NWL%test . equal ( date . toJSON ( ) ,  " 2012 - 10 - 09T20:30:40 . 678Z " ,  " should output ISO8601 on moment . fn . toJSON " ) ;%NWL%test . equal ( JSON . stringify ( {%NWL%date : date%NWL%test . done ( ) ;%NWL%1
for ( var i in cases )  {%NWL%var iso = cases [ i ] . split ( ' - ' ) . pop ( ) ;%NWL%var the = moment ( i ) . format ( ' WW ' ) ;%NWL%test . equal ( iso , the , i +  " : should be "  + iso +  " , but "  + the ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" toString is just human readable format " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var b = moment ( new Date ( 2009 , 1 , 5 , 15 , 25 , 50 , 125 ) ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" setters plural " : function ( test )  {%NWL%test . expect ( 8 ) ;%NWL%var a = moment ( ) ;%NWL%a . years ( 2011 ) ;%NWL%a . months ( 9 ) ;%NWL%a . dates ( 12 ) ;%NWL%a . hours ( 6 ) ;%NWL%a . minutes ( 7 ) ;%NWL%a . milliseconds ( 9 ) ;%NWL%6
test . done ( ) ;%NWL%} ,%NWL%" setters singular " : function ( test )  {%NWL%test . expect ( 8 ) ;%NWL%var a = moment ( ) ;%NWL%a . year ( 2011 ) ;%NWL%a . month ( 9 ) ;%NWL%a . date ( 12 ) ;%NWL%a . hour ( 6 ) ;%NWL%a . minute ( 7 ) ;%NWL%a . millisecond ( 9 ) ;%NWL%6
test . done ( ) ;%NWL%} ,%NWL%" setters " : function ( test )  {%NWL%test . expect ( 8 ) ;%NWL%var a = moment ( ) ;%NWL%a . year ( 2011 ) ;%NWL%a . month ( 9 ) ;%NWL%a . date ( 12 ) ;%NWL%a . hours ( 6 ) ;%NWL%a . minutes ( 7 ) ;%NWL%a . milliseconds ( 9 ) ;%NWL%6
test . equal ( a . minutes ( ) , 7 ,  ' minute ' ) ;%NWL%test . equal ( a . seconds ( ) , 8 ,  ' second ' ) ;%NWL%test . equal ( a . milliseconds ( ) , 9 ,  ' milliseconds ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" setters - falsey values " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var a = moment ( ) ;%NWL%a . minutes ( 1 ) ;%NWL%a . minutes ( 0 ) ;%NWL%test . done ( ) ;%NWL%3
var moment = require ( " . . / . . / moment " ) ;%NWL%exports . is_after = {%NWL%" is after without units " : function ( test )  {%NWL%var m = moment ( new Date ( 2011 , 3 , 2 , 3 , 4 , 5 , 10 ) ) , mCopy = moment ( m ) ;%NWL%0
var moment = require ( " . . / . . / moment " ) ;%NWL%exports . is_before = {%NWL%" is after without units " : function ( test )  {%NWL%var m = moment ( new Date ( 2011 , 3 , 2 , 3 , 4 , 5 , 10 ) ) , mCopy = moment ( m ) ;%NWL%0
var moment = require ( " . . / . . / moment " ) ;%NWL%exports . is_same = {%NWL%" is same without units " : function ( test )  {%NWL%var m = moment ( new Date ( 2011 , 3 , 2 , 3 , 4 , 5 , 10 ) ) , mCopy = moment ( m ) ;%NWL%0
test . expect ( 2 ) ;%NWL%test . equal ( moment ( [ 2010 ,  - 1 ] ) . isValid ( ) , false ,  ' month - 1 ' ) ;%NWL%test . equal ( moment ( [ 2100 , 12 ] ) . isValid ( ) , false ,  ' month 12 ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" array good month " : function ( test )  {%NWL%test . expect ( 24 ) ;%NWL%for ( var i = 0; i < 12; i + + )  {%NWL%test . equal ( moment ( [ 2010 , i ] ) . isValid ( ) , true ,  ' month '  + i ) ;%NWL%test . equal ( moment . utc ( [ 2010 , i ] ) . isValid ( ) , true ,  ' month '  + i ) ;%NWL%test . done ( ) ;%NWL%3
test . equal ( moment ( [ 2010 , i ] ) . isValid ( ) , true ,  ' month '  + i ) ;%NWL%test . equal ( moment . utc ( [ 2010 , i ] ) . isValid ( ) , true ,  ' month '  + i ) ;%NWL%}%NWL%test . done ( ) ;%NWL%} ,%NWL%" array bad date " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%test . equal ( moment ( [ 2010 , 0 , 0 ] ) . isValid ( ) , false ,  ' date 0 ' ) ;%NWL%test . equal ( moment ( [ 2100 , 0 , 32 ] ) . isValid ( ) , false ,  ' date 32 ' ) ;%NWL%test . equal ( moment . utc ( [ 2010 , 0 , 0 ] ) . isValid ( ) , false ,  ' utc date 0 ' ) ;%NWL%test . done ( ) ;%NWL%3
test . equal ( moment ( ' 2020 - 01 - 01 ' ,  [ ' DD - MM - YYYY ' ,  ' YYYY - MM - DD ' ] ) . isValid ( ) , true ,  ' valid on last ' ) ;%NWL%test . equal ( moment ( ' 2020 - 01 - 01 ' ,  [ ' YYYY - MM - DD ' ,  ' YYYY - DD - MM ' ] ) . isValid ( ) , true ,  ' valid on both ' ) ;%NWL%test . equal ( moment ( ' 2020 - 13 - 01 ' ,  [ ' YYYY - MM - DD ' ,  ' YYYY - DD - MM ' ] ) . isValid ( ) , true ,  ' valid on last ' ) ;%NWL%test . equal ( moment ( ' 12 - 13 - 2012 ' ,  [ ' DD - MM - YYYY ' ,  ' YYYY - MM - DD ' ] ) . isValid ( ) , false ,  ' month rollover ' ) ;%NWL%test . equal ( moment ( ' 12 - 13 - 2012 ' ,  [ ' DD - MM - YYYY ' ,  ' DD - MM - YYYY ' ] ) . isValid ( ) , false ,  ' month rollover ' ) ;%NWL%test . equal ( moment ( ' 38 - 12 - 2012 ' ,  [ ' DD - MM - YYYY ' ] ) . isValid ( ) , false ,  ' day rollover ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string nonsensical " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
test . done ( ) ;%NWL%} ,%NWL%" string nonsensical " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . equal ( moment ( ' fail ' ) . isValid ( ) , false ,  ' string " fail " ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string nonsensical with format " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ' fail ' ,  " MM - DD - YYYY " ) . isValid ( ) , false ,  ' string " fail " with format " MM - DD - YYYY " ' ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 1 ) ;%NWL%test . equal ( moment ( ' fail ' ) . isValid ( ) , false ,  ' string " fail " ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string nonsensical with format " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ' fail ' ,  " MM - DD - YYYY " ) . isValid ( ) , false ,  ' string " fail " with format " MM - DD - YYYY " ' ) ;%NWL%test . equal ( moment ( " xx - xx - 2001 " ,  ' DD - MM - YYY ' ) . isValid ( ) , false ,  ' string " xx - xx - 2001 " with format " MM - DD - YYYY " ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
" string nonsensical with format " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . equal ( moment ( ' fail ' ,  " MM - DD - YYYY " ) . isValid ( ) , false ,  ' string " fail " with format " MM - DD - YYYY " ' ) ;%NWL%test . equal ( moment ( " xx - xx - 2001 " ,  ' DD - MM - YYY ' ) . isValid ( ) , false ,  ' string " xx - xx - 2001 " with format " MM - DD - YYYY " ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string with bad month name " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%moment . lang ( ' en ' ) ;%NWL%test . equal ( moment ( ' 01 - Nam - 2012 ' ,  ' DD - MMM - YYYY ' ) . isValid ( ) , false ,  ' " Nam " is an invalid month ' ) ;%NWL%test . done ( ) ;%NWL%4
} ,%NWL%" string with bad month name " : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%moment . lang ( ' en ' ) ;%NWL%test . equal ( moment ( ' 01 - Nam - 2012 ' ,  ' DD - MMM - YYYY ' ) . isValid ( ) , false ,  ' " Nam " is an invalid month ' ) ;%NWL%test . equal ( moment ( ' 01 - Aug - 2012 ' ,  ' DD - MMM - YYYY ' ) . isValid ( ) , true ,  ' " Aug " is a valid month ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" string with spaceless format " : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . done ( ) ;%NWL%6
moment . lang ( ' en - gb ' ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" transform " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%test . equal ( moment . utc ( ' @ ) !@ - ) * - @& ' ,  ' YYYY - MM - DD ' ) . unix ( ) , 1346025600 ,  " preparse string + format " ) ;%NWL%test . equal ( moment . utc ( ' @ ) !@ - ) * - @& ' ) . unix ( ) , 1346025600 ,  " preparse ISO8601 string " ) ;%NWL%test . equal ( moment . unix ( 1346025600 ) . utc ( ) . format ( ' YYYY - MM - DD ' ) ,  ' @ ) !@ - ) * - @& ' ,  " postformat " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 3 ) ;%NWL%4
test . equal ( moment . utc ( ' @ ) !@ - ) * - @& ' ,  ' YYYY - MM - DD ' ) . unix ( ) , 1346025600 ,  " preparse string + format " ) ;%NWL%test . equal ( moment . utc ( ' @ ) !@ - ) * - @& ' ) . unix ( ) , 1346025600 ,  " preparse ISO8601 string " ) ;%NWL%test . equal ( moment . unix ( 1346025600 ) . utc ( ) . format ( ' YYYY - MM - DD ' ) ,  ' @ ) !@ - ) * - @& ' ,  " postformat " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" transform from " : function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%var start = moment ( [ 2007 , 1 , 28 ] ) ;%NWL%test . equal ( start . from ( moment ( [ 2007 , 1 , 28 ] ) . add ( { s:90 } ) , true ) ,  " @ minutes " ,  " postformat should work on moment . fn . from " ) ;%NWL%test . equal ( moment ( ) . add ( ' d ' , 6 ) . fromNow ( true ) ,  " ^ days " ,  " postformat should work on moment . fn . fromNow " ) ;%NWL%test . done ( ) ;%NWL%3
test . done ( ) ;%NWL%} ,%NWL%" calendar day " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%var a = moment ( ) . hours ( 2 ) . minutes ( 0 ) . seconds ( 0 ) ;%NWL%test . equal ( moment ( a ) . calendar ( ) ,            " Today at @: ) ) AM " ,    " today at the same time " ) ;%NWL%test . equal ( moment ( a ) . add ( { m: 25 } ) . calendar ( ) ,    " Today at @:@% AM " ,    " Now plus 25 min " ) ;%NWL%test . equal ( moment ( a ) . add ( { h: 1 } ) . calendar ( ) ,     " Today at #: ) ) AM " ,    " Now plus 1 hour " ) ;%NWL%test . equal ( moment ( a ) . add ( { d: 1 } ) . calendar ( ) ,     " Tomorrow at @: ) ) AM " ,  " tomorrow at the same time " ) ;%NWL%test . equal ( moment ( a ) . subtract ( { h: 1 } ) . calendar ( ) ,  " Today at !: ) ) AM " ,    " Now minus 1 hour " ) ;%NWL%test . done ( ) ;%NWL%0
self . aliases = [ ] ;%NWL%%NWL%self . visibleRow = null; / / Where I can be found in the preview ( DataRow object ) , or null if I ' m hidden%NWL%%NWL%self . name = name;  / / User - readable label; this was the index that people used to get here , and the tail end of the key%NWL%%NWL%self . bindable = bindable === undefined ? true : bindable;%NWL%self . isError = false;%NWL%%NWL%if ( typeof data === ' object ' )  {%NWL%self . objType = Datum . ARRAY;%NWL%6
%NWL%self . name = name;  / / User - readable label; this was the index that people used to get here , and the tail end of the key%NWL%%NWL%self . bindable = bindable === undefined ? true : bindable;%NWL%self . isError = false;%NWL%%NWL%if ( typeof data === ' object ' )  {%NWL%if ( data instanceof Array )  {%NWL%self . objType = Datum . ARRAY;%NWL%self . children = [ ] ;%NWL%self . objType = Datum . OBJECT;%NWL%3
for ( childIndex = 0; childIndex < row . datum . children . length; childIndex + = 1 )  {%NWL%childRow = new DataRow ( row , row . datum . children [ childIndex ] ) ;%NWL%row . childRows . push ( childRow ) ;%NWL%if ( !childRow . isClone )  {%NWL%queue . push ( childRow ) ;%NWL%}%NWL%}%NWL%} else if ( row . datum . objType === Datum . OBJECT )  {%NWL%for ( childIndex in row . datum . children )  {%NWL%if ( row . datum . children . hasOwnProperty ( childIndex ) )  {%NWL%row . childRows . push ( childRow ) ;%NWL%2
row . childRows . push ( childRow ) ;%NWL%if ( !childRow . isClone )  {%NWL%queue . push ( childRow ) ;%NWL%}%NWL%}%NWL%} else if ( row . datum . objType === Datum . OBJECT )  {%NWL%for ( childIndex in row . datum . children )  {%NWL%if ( row . datum . children . hasOwnProperty ( childIndex ) )  {%NWL%childRow = new DataRow ( row , row . datum . children [ childIndex ] ) ;%NWL%row . childRows . push ( childRow ) ;%NWL%queue . push ( childRow ) ;%NWL%2
MappingManager . ERROR_COLOR = ' #f00 ' ;%NWL%MappingManager . prototype . init = function ( )  {%NWL%} ;%NWL%MappingManager . prototype . disableUI = function ( )  {%NWL%var self = this;%NWL%self . onRefresh ( ) ;%NWL%} ;%NWL%MappingManager . prototype . onNewData = function ( )  {%NWL%var self = this;%NWL%%NWL%self . onRefresh ( ) ;%NWL%5
self . onRefresh ( ) ;%NWL%} ;%NWL%MappingManager . prototype . onNewData = function ( )  {%NWL%var self = this;%NWL%%NWL%self . staleDatum = true;%NWL%self . onRefresh ( ) ;%NWL%} ;%NWL%MappingManager . prototype . toggleCollapse = function ( row )  {%NWL%var self = this;%NWL%self . onRefresh ( ) ;%NWL%0
var moment = require ( " . . / . . / moment " ) ;%NWL%exports . utc = {%NWL%" utc and local " : function ( test )  {%NWL%test . expect ( 7 ) ;%NWL%var m = moment ( Date . UTC ( 2011 , 1 , 2 , 3 , 4 , 5 , 6 ) ) ;%NWL%m . utc ( ) ;%NWL%test . equal ( m . date ( ) , 2 ,  " the day should be correct for utc " ) ;%NWL%test . equal ( m . day ( ) , 3 ,  " the date should be correct for utc " ) ;%NWL%m . local ( ) ;%NWL%5
test . equal ( m . hours ( ) , 3 ,  " the hours should be correct for utc parsing iso " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" creating with utc without timezone " : function ( test )  {%NWL%test . expect ( 4 ) ;%NWL%var m = moment . utc ( " 2012 - 01 - 02T08:20:00 " ) ;%NWL%test . equal ( m . date ( ) , 2 ,  " the day should be correct for utc parse without timezone " ) ;%NWL%test . equal ( m . hours ( ) , 8 ,  " the hours should be correct for utc parse without timezone " ) ;%NWL%m = moment . utc ( " 2012 - 01 - 02T08:20:00 + 09:00 " ) ;%NWL%test . equal ( m . date ( ) , 1 ,  " the day should be correct for utc parse with timezone " ) ;%NWL%test . done ( ) ;%NWL%1
var moment = require ( " . . / . . / moment " ) ;%NWL%exports . utc = {%NWL%setUp : function ( cb )  {%NWL%moment . lang ( ' en ' ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%moment . lang ( ' en ' ) ;%NWL%3
test . equal ( moment ( ) . dayOfYear ( 60 ) . dayOfYear ( ) ,  60 ,  " Setting day of the year to 60 should work " ) ;%NWL%test . equal ( moment ( ) . dayOfYear ( 365 ) . dayOfYear ( ) , 365 ,  " Setting day of the year to 365 should work " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . isoWeek ( ) , 52 ,  " Jan 1 2012 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . isoWeek ( ) ,  1 ,  " Jan 2 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . isoWeek ( ) ,  1 ,  " Jan 8 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . isoWeek ( ) ,  2 ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" iso weeks year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . isoWeek ( ) , 52 ,  " Jan 1 2012 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . isoWeek ( ) ,  1 ,  " Jan 2 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . isoWeek ( ) ,  1 ,  " Jan 8 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . isoWeek ( ) ,  2 ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . isoWeek ( ) , 2 ,  " Jan 15 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . isoWeek ( ) ,  2 ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . isoWeek ( ) , 2 ,  " Jan 15 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting monday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 1 ] ) . isoWeek ( ) ,  1 ,  " Jan 1 2007 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 7 ] ) . isoWeek ( ) ,  1 ,  " Jan 7 2007 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 8 ] ) . isoWeek ( ) ,  2 ,  " Jan 8 2007 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2007 , 0 , 14 ] ) . isoWeek ( ) , 2 ,  " Jan 14 2007 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2007 , 0 , 15 ] ) . isoWeek ( ) , 3 ,  " Jan 15 2007 should be iso week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . isoWeek ( ) , 1 ,  " Dec 31 2007 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . isoWeek ( ) , 1 ,  " Jan 1 2008 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . isoWeek ( ) , 1 ,  " Jan 6 2008 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . isoWeek ( ) , 2 ,  " Jan 7 2008 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . isoWeek ( ) , 2 ,  " Jan 13 2008 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" iso weeks year starting tuesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2007 , 11 , 31 ] ) . isoWeek ( ) , 1 ,  " Dec 31 2007 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  1 ] ) . isoWeek ( ) , 1 ,  " Jan 1 2008 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  6 ] ) . isoWeek ( ) , 1 ,  " Jan 6 2008 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 ,  7 ] ) . isoWeek ( ) , 2 ,  " Jan 7 2008 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 13 ] ) . isoWeek ( ) , 2 ,  " Jan 13 2008 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . isoWeek ( ) , 3 ,  " Jan 14 2008 should be iso week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2008 ,  0 , 14 ] ) . isoWeek ( ) , 3 ,  " Jan 14 2008 should be iso week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . isoWeek ( ) , 1 ,  " Dec 30 2002 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . isoWeek ( ) , 1 ,  " Jan 1 2003 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . isoWeek ( ) , 1 ,  " Jan 5 2003 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . isoWeek ( ) , 2 ,  " Jan 6 2003 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . isoWeek ( ) , 2 ,  " Jan 12 2003 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" iso weeks year starting wednesday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2002 , 11 , 30 ] ) . isoWeek ( ) , 1 ,  " Dec 30 2002 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  1 ] ) . isoWeek ( ) , 1 ,  " Jan 1 2003 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  5 ] ) . isoWeek ( ) , 1 ,  " Jan 5 2003 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 ,  6 ] ) . isoWeek ( ) , 2 ,  " Jan 6 2003 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 12 ] ) . isoWeek ( ) , 2 ,  " Jan 12 2003 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . isoWeek ( ) , 3 ,  " Jan 13 2003 should be iso week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2003 ,  0 , 13 ] ) . isoWeek ( ) , 3 ,  " Jan 13 2003 should be iso week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . isoWeek ( ) , 1 ,  " Dec 29 2008 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . isoWeek ( ) , 1 ,  " Jan 1 2009 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . isoWeek ( ) , 1 ,  " Jan 4 2009 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . isoWeek ( ) , 2 ,  " Jan 5 2009 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . isoWeek ( ) , 2 ,  " Jan 11 2009 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%1
" iso weeks year starting thursday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2008 , 11 , 29 ] ) . isoWeek ( ) , 1 ,  " Dec 29 2008 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  1 ] ) . isoWeek ( ) , 1 ,  " Jan 1 2009 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  4 ] ) . isoWeek ( ) , 1 ,  " Jan 4 2009 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 ,  5 ] ) . isoWeek ( ) , 2 ,  " Jan 5 2009 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 11 ] ) . isoWeek ( ) , 2 ,  " Jan 11 2009 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . isoWeek ( ) , 3 ,  " Jan 12 2009 should be iso week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2009 ,  0 , 13 ] ) . isoWeek ( ) , 3 ,  " Jan 12 2009 should be iso week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . isoWeek ( ) , 53 ,  " Dec 28 2009 should be iso week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . isoWeek ( ) , 53 ,  " Jan 1 2010 should be iso week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . isoWeek ( ) , 53 ,  " Jan 3 2010 should be iso week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . isoWeek ( ) ,  1 ,  " Jan 4 2010 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . isoWeek ( ) ,  1 ,  " Jan 10 2010 should be iso week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
" iso weeks year starting friday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2009 , 11 , 28 ] ) . isoWeek ( ) , 53 ,  " Dec 28 2009 should be iso week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  1 ] ) . isoWeek ( ) , 53 ,  " Jan 1 2010 should be iso week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  3 ] ) . isoWeek ( ) , 53 ,  " Jan 3 2010 should be iso week 53 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 ,  4 ] ) . isoWeek ( ) ,  1 ,  " Jan 4 2010 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 10 ] ) . isoWeek ( ) ,  1 ,  " Jan 10 2010 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . isoWeek ( ) ,  2 ,  " Jan 11 2010 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . equal ( moment ( [ 2010 ,  0 , 11 ] ) . isoWeek ( ) ,  2 ,  " Jan 11 2010 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting saturday " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2010 , 11 , 27 ] ) . isoWeek ( ) , 52 ,  " Dec 27 2010 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  1 ] ) . isoWeek ( ) , 52 ,  " Jan 1 2011 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  2 ] ) . isoWeek ( ) , 52 ,  " Jan 2 2011 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  3 ] ) . isoWeek ( ) ,  1 ,  " Jan 3 2011 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . isoWeek ( ) ,  1 ,  " Jan 9 2011 should be iso week 1 " ) ;%NWL%test . done ( ) ;%NWL%1
test . equal ( moment ( [ 2011 ,  0 ,  9 ] ) . isoWeek ( ) ,  1 ,  " Jan 9 2011 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2011 ,  0 , 10 ] ) . isoWeek ( ) ,  2 ,  " Jan 10 2011 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' W WW Wo ' ) ,  ' 52 52 52nd ' ,  " Jan 1 2012 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' W WW Wo ' ) ,  ' 1 01 1st '  ,  " Jan 2 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' W WW Wo ' ) ,  ' 1 01 1st '  ,  " Jan 8 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' W WW Wo ' ) ,  ' 2 02 2nd '  ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" iso weeks year starting sunday formatted " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . format ( ' W WW Wo ' ) ,  ' 52 52 52nd ' ,  " Jan 1 2012 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . format ( ' W WW Wo ' ) ,  ' 1 01 1st '  ,  " Jan 2 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . format ( ' W WW Wo ' ) ,  ' 1 01 1st '  ,  " Jan 8 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' W WW Wo ' ) ,  ' 2 02 2nd '  ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . format ( ' W WW Wo ' ) ,  ' 2 02 2nd '  ,  " Jan 15 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . format ( ' W WW Wo ' ) ,  ' 2 02 2nd '  ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . format ( ' W WW Wo ' ) ,  ' 2 02 2nd '  ,  " Jan 15 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks plural year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . weeks ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . weeks ( ) , 1 ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . weeks ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . weeks ( ) , 2 ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks plural year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . weeks ( ) , 1 ,  " Jan 1 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . weeks ( ) , 1 ,  " Jan 7 2012 should be week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . weeks ( ) , 2 ,  " Jan 8 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . weeks ( ) , 2 ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . weeks ( ) , 3 ,  " Jan 15 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 14 ] ) . weeks ( ) , 2 ,  " Jan 14 2012 should be week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . weeks ( ) , 3 ,  " Jan 15 2012 should be week 3 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks plural year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . isoWeeks ( ) , 52 ,  " Jan 1 2012 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . isoWeeks ( ) ,  1 ,  " Jan 2 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . isoWeeks ( ) ,  1 ,  " Jan 8 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . isoWeeks ( ) ,  2 ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" iso weeks plural year starting sunday " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 1 ] ) . isoWeeks ( ) , 52 ,  " Jan 1 2012 should be iso week 52 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 2 ] ) . isoWeeks ( ) ,  1 ,  " Jan 2 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 8 ] ) . isoWeeks ( ) ,  1 ,  " Jan 8 2012 should be iso week 1 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 9 ] ) . isoWeeks ( ) ,  2 ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . isoWeeks ( ) , 2 ,  " Jan 15 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 9 ] ) . isoWeeks ( ) ,  2 ,  " Jan 9 2012 should be iso week 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . isoWeeks ( ) , 2 ,  " Jan 15 2012 should be iso week 2 " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" weeks setter " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 1 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 7 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 8 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 14 2012 to week 30 should work " ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" weeks setter " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 1 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  7 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 7 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 8 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 14 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 14 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 15 2012 to week 30 should work " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 5 ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 14 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 14 2012 to week 30 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 , 15 ] ) . week ( 30 ) . week ( ) , 30 ,  " Setting Jan 15 2012 to week 30 should work " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks setter " : function ( test )  {%NWL%test . expect ( 5 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . isoWeeks ( 25 ) . isoWeeks ( ) , 25 ,  " Setting Jan 1 2012 to week 25 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . isoWeeks ( 24 ) . isoWeeks ( ) , 24 ,  " Setting Jan 2 2012 to week 24 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . isoWeeks ( 23 ) . isoWeeks ( ) , 23 ,  " Setting Jan 8 2012 to week 23 should work " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . isoWeeks ( 22 ) . isoWeeks ( ) , 22 ,  " Setting Jan 9 2012 to week 22 should work " ) ;%NWL%test . done ( ) ;%NWL%2
test . equal ( moment ( [ 2012 , 0 , 15 ] ) . isoWeeks ( 21 ) . isoWeeks ( ) , 21 ,  " Setting Jan 15 2012 to week 21 should work " ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" iso weeks setter day of year " : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . isoWeek ( 1 ) . dayOfYear ( ) , 9 ,  " Setting Jan 1 2012 to week 1 should be day of year 8 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  1 ] ) . isoWeek ( 1 ) . year ( ) ,  2011 ,  " Setting Jan 1 2012 to week 1 should be year 2011 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  2 ] ) . isoWeek ( 1 ) . dayOfYear ( ) , 2 ,  " Setting Jan 2 2012 to week 1 should be day of year 2 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  8 ] ) . isoWeek ( 1 ) . dayOfYear ( ) , 8 ,  " Setting Jan 8 2012 to week 1 should be day of year 8 " ) ;%NWL%test . equal ( moment ( [ 2012 , 0 ,  9 ] ) . isoWeek ( 1 ) . dayOfYear ( ) , 2 ,  " Setting Jan 9 2012 to week 1 should be day of year 2 " ) ;%NWL%test . done ( ) ;%NWL%1
' <div class= " slider - handle " >< / div> ' +%NWL%' < / div> ' +%NWL%' <div id= " tooltip " class= " tooltip " ><div class= " tooltip - arrow " >< / div><div class= " tooltip - inner " >< / div>< / div> ' +%NWL%' <div id= " tooltip_min " class= " tooltip " ><div class= " tooltip - arrow " >< / div><div class= " tooltip - inner " >< / div>< / div> ' +%NWL%' <div id= " tooltip_max " class= " tooltip " ><div class= " tooltip - arrow " >< / div><div class= " tooltip - inner " >< / div>< / div> ' +%NWL%' < / div> ' )%NWL%. insertBefore ( this . element )%NWL%. append ( this . element ) ;%NWL%}%NWL%this . id = this . element . data ( ' slider - id ' ) ||options . id;%NWL%this . picker [ 0 ] . id = this . id;%NWL%9
. insertBefore ( this . element )%NWL%. append ( this . element ) ;%NWL%}%NWL%this . id = this . element . data ( ' slider - id ' ) ||options . id;%NWL%if ( this . id )  {%NWL%this . picker [ 0 ] . id = this . id;%NWL%}%NWL%if ( ( ' ontouchstart ' in window ) || window . DocumentTouch && document instanceof window . DocumentTouch )  {%NWL%this . touchCapable = true;%NWL%}%NWL%this . tooltip = this . picker . find ( ' #tooltip ' ) ;%NWL%3
. append ( this . element ) ;%NWL%}%NWL%this . id = this . element . data ( ' slider - id ' ) ||options . id;%NWL%if ( this . id )  {%NWL%this . picker [ 0 ] . id = this . id;%NWL%}%NWL%if ( ( ' ontouchstart ' in window ) || window . DocumentTouch && document instanceof window . DocumentTouch )  {%NWL%this . touchCapable = true;%NWL%}%NWL%var tooltip = this . element . data ( ' slider - tooltip ' ) ||options . tooltip;%NWL%this . tooltipInner = this . tooltip . find ( ' div . tooltip - inner ' ) ;%NWL%2
}%NWL%this . id = this . element . data ( ' slider - id ' ) ||options . id;%NWL%if ( this . id )  {%NWL%this . picker [ 0 ] . id = this . id;%NWL%}%NWL%if ( ( ' ontouchstart ' in window ) || window . DocumentTouch && document instanceof window . DocumentTouch )  {%NWL%this . touchCapable = true;%NWL%}%NWL%var tooltip = this . element . data ( ' slider - tooltip ' ) ||options . tooltip;%NWL%this . tooltip = this . picker . find ( ' #tooltip ' ) ;%NWL%this . tooltip_min = this . picker . find ( ' #tooltip_min ' ) ;%NWL%1
this . id = this . element . data ( ' slider - id ' ) ||options . id;%NWL%if ( this . id )  {%NWL%this . picker [ 0 ] . id = this . id;%NWL%}%NWL%if ( ( ' ontouchstart ' in window ) || window . DocumentTouch && document instanceof window . DocumentTouch )  {%NWL%this . touchCapable = true;%NWL%}%NWL%var tooltip = this . element . data ( ' slider - tooltip ' ) ||options . tooltip;%NWL%this . tooltip = this . picker . find ( ' #tooltip ' ) ;%NWL%this . tooltipInner = this . tooltip . find ( ' div . tooltip - inner ' ) ;%NWL%this . tooltipInner_min = this . tooltip_min . find ( ' div . tooltip - inner ' ) ;%NWL%0
this . tooltip = this . picker . find ( ' #tooltip ' ) ;%NWL%this . tooltipInner = this . tooltip . find ( ' div . tooltip - inner ' ) ;%NWL%this . tooltip_min = this . picker . find ( ' #tooltip_min ' ) ;%NWL%this . tooltipInner_min = this . tooltip_min . find ( ' div . tooltip - inner ' ) ;%NWL%this . tooltip_max = this . picker . find ( ' #tooltip_max ' ) ;%NWL%this . tooltipInner_max= this . tooltip_max . find ( ' div . tooltip - inner ' ) ;%NWL%if ( updateSlider === true )  {%NWL%this . picker . removeClass ( ' slider - horizontal ' ) ;%NWL%this . picker . removeClass ( ' slider - vertical ' ) ;%NWL%this . tooltip . removeClass ( ' hide ' ) ;%NWL%this . tooltip_max . removeClass ( ' hide ' ) ;%NWL%9
this . tooltip . removeClass ( ' hide ' ) ;%NWL%this . tooltip_min . removeClass ( ' hide ' ) ;%NWL%this . tooltip_max . removeClass ( ' hide ' ) ;%NWL%}%NWL%this . orientation = this . element . data ( ' slider - orientation ' ) ||options . orientation;%NWL%switch ( this . orientation )  {%NWL%case ' vertical ' :%NWL%this . picker . addClass ( ' slider - vertical ' ) ;%NWL%this . stylePos = ' top ' ;%NWL%this . mousePos = ' pageY ' ;%NWL%this . tooltip . addClass ( ' right ' ) [ 0 ] . style . left = ' 100% ' ;%NWL%4
this . tooltip_min . removeClass ( ' hide ' ) ;%NWL%this . tooltip_max . removeClass ( ' hide ' ) ;%NWL%}%NWL%this . orientation = this . element . data ( ' slider - orientation ' ) ||options . orientation;%NWL%switch ( this . orientation )  {%NWL%case ' vertical ' :%NWL%this . picker . addClass ( ' slider - vertical ' ) ;%NWL%this . stylePos = ' top ' ;%NWL%this . mousePos = ' pageY ' ;%NWL%this . sizePos = ' offsetHeight ' ;%NWL%this . tooltip_min . addClass ( ' right ' ) [ 0 ] . style . left = ' 100% ' ;%NWL%3
this . tooltip_max . removeClass ( ' hide ' ) ;%NWL%}%NWL%this . orientation = this . element . data ( ' slider - orientation ' ) ||options . orientation;%NWL%switch ( this . orientation )  {%NWL%case ' vertical ' :%NWL%this . picker . addClass ( ' slider - vertical ' ) ;%NWL%this . stylePos = ' top ' ;%NWL%this . mousePos = ' pageY ' ;%NWL%this . sizePos = ' offsetHeight ' ;%NWL%this . tooltip . addClass ( ' right ' ) [ 0 ] . style . left = ' 100% ' ;%NWL%this . tooltip_max . addClass ( ' right ' ) [ 0 ] . style . left = ' 100% ' ;%NWL%2
break;%NWL%default:%NWL%this . picker%NWL%. addClass ( ' slider - horizontal ' )%NWL%. css ( ' width ' , origWidth ) ;%NWL%this . orientation = ' horizontal ' ;%NWL%this . stylePos = ' left ' ;%NWL%this . mousePos = ' pageX ' ;%NWL%this . sizePos = ' offsetWidth ' ;%NWL%this . tooltip . addClass ( ' top ' ) [ 0 ] . style . top = - this . tooltip . outerHeight ( )  - 14 +  ' px ' ;%NWL%this . tooltip_max . addClass ( ' top ' ) [ 0 ] . style . top = - this . tooltip_max . outerHeight ( )  - 14 +  ' px ' ;%NWL%9
} else {%NWL%self [ attr ] = 0; / / to prevent empty string issues in calculations in IE%NWL%}%NWL%} ) ;%NWL%if ( this . value instanceof Array )  {%NWL%if ( updateSlider && !this . range )  {%NWL%this . value = this . value [ 0 ] ;%NWL%} else {%NWL%this . range = true;%NWL%}%NWL%this . value = [ this . value , this . max ] ;%NWL%6
}%NWL%} ) ;%NWL%if ( this . value instanceof Array )  {%NWL%if ( updateSlider && !this . range )  {%NWL%this . value = this . value [ 0 ] ;%NWL%} else {%NWL%this . range = true;%NWL%}%NWL%} else if ( this . range )  {%NWL%this . value = [ this . value , this . max ] ;%NWL%this . selection = this . element . data ( ' slider - selection ' ) ||options . selection;%NWL%4
} ) ;%NWL%if ( this . value instanceof Array )  {%NWL%if ( updateSlider && !this . range )  {%NWL%this . value = this . value [ 0 ] ;%NWL%} else {%NWL%this . range = true;%NWL%}%NWL%} else if ( this . range )  {%NWL%this . value = [ this . value , this . max ] ;%NWL%}%NWL%this . selectionEl = this . picker . find ( ' . slider - selection ' ) ;%NWL%3
} else {%NWL%this . range = true;%NWL%}%NWL%} else if ( this . range )  {%NWL%this . value = [ this . value , this . max ] ;%NWL%}%NWL%this . selection = this . element . data ( ' slider - selection ' ) ||options . selection;%NWL%this . selectionEl = this . picker . find ( ' . slider - selection ' ) ;%NWL%if ( this . selection === ' none ' )  {%NWL%this . selectionEl . addClass ( ' hide ' ) ;%NWL%this . selectionElStyle = this . selectionEl [ 0 ] . style;%NWL%4
this . range = true;%NWL%}%NWL%} else if ( this . range )  {%NWL%this . value = [ this . value , this . max ] ;%NWL%}%NWL%this . selection = this . element . data ( ' slider - selection ' ) ||options . selection;%NWL%this . selectionEl = this . picker . find ( ' . slider - selection ' ) ;%NWL%if ( this . selection === ' none ' )  {%NWL%this . selectionEl . addClass ( ' hide ' ) ;%NWL%}%NWL%this . handle1 = this . picker . find ( ' . slider - handle:first ' ) ;%NWL%3
}%NWL%} else if ( this . range )  {%NWL%this . value = [ this . value , this . max ] ;%NWL%}%NWL%this . selection = this . element . data ( ' slider - selection ' ) ||options . selection;%NWL%this . selectionEl = this . picker . find ( ' . slider - selection ' ) ;%NWL%if ( this . selection === ' none ' )  {%NWL%this . selectionEl . addClass ( ' hide ' ) ;%NWL%}%NWL%this . selectionElStyle = this . selectionEl [ 0 ] . style;%NWL%this . handle1Stype = this . handle1 [ 0 ] . style;%NWL%2
} else if ( this . range )  {%NWL%this . value = [ this . value , this . max ] ;%NWL%}%NWL%this . selection = this . element . data ( ' slider - selection ' ) ||options . selection;%NWL%this . selectionEl = this . picker . find ( ' . slider - selection ' ) ;%NWL%if ( this . selection === ' none ' )  {%NWL%this . selectionEl . addClass ( ' hide ' ) ;%NWL%}%NWL%this . selectionElStyle = this . selectionEl [ 0 ] . style;%NWL%this . handle1 = this . picker . find ( ' . slider - handle:first ' ) ;%NWL%this . handle2 = this . picker . find ( ' . slider - handle:last ' ) ;%NWL%1
this . value = [ this . value , this . max ] ;%NWL%}%NWL%this . selection = this . element . data ( ' slider - selection ' ) ||options . selection;%NWL%this . selectionEl = this . picker . find ( ' . slider - selection ' ) ;%NWL%if ( this . selection === ' none ' )  {%NWL%this . selectionEl . addClass ( ' hide ' ) ;%NWL%}%NWL%this . selectionElStyle = this . selectionEl [ 0 ] . style;%NWL%this . handle1 = this . picker . find ( ' . slider - handle:first ' ) ;%NWL%this . handle1Stype = this . handle1 [ 0 ] . style;%NWL%this . handle2Stype = this . handle2 [ 0 ] . style;%NWL%0
this . handle2 . addClass ( ' round ' ) ;%NWL%break;%NWL%case ' triangle ' :%NWL%this . handle1 . addClass ( ' triangle ' ) ;%NWL%this . handle2 . addClass ( ' triangle ' ) ;%NWL%break;%NWL%}%NWL%if ( this . range )  {%NWL%this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%8
this . handle1 . addClass ( ' triangle ' ) ;%NWL%this . handle2 . addClass ( ' triangle ' ) ;%NWL%break;%NWL%}%NWL%if ( this . range )  {%NWL%this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%} else {%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%this . handle2 . addClass ( ' hide ' ) ;%NWL%this . value [ 1 ] = this . max;%NWL%5
break;%NWL%}%NWL%if ( this . range )  {%NWL%this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%} else {%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%this . handle2 . addClass ( ' hide ' ) ;%NWL%if ( this . selection === ' after ' )  {%NWL%this . value [ 1 ] = this . max;%NWL%this . value [ 1 ] = this . min;%NWL%3
this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%} else {%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%this . handle2 . addClass ( ' hide ' ) ;%NWL%if ( this . selection === ' after ' )  {%NWL%this . value [ 1 ] = this . max;%NWL%} else {%NWL%this . value [ 1 ] = this . min;%NWL%}%NWL%this . diff = this . max - this . min;%NWL%0
if ( this . diff > 0 )  {%NWL%this . percentage = [%NWL%( this . value [ 0 ]  - this . min )  * 100 / this . diff ,%NWL%( this . value [ 1 ]  - this . min )  * 100 / this . diff ,%NWL%this . step * 100 / this . diff%NWL%] ;%NWL%} else {%NWL%this . percentage = [ 0 , 0 , 100 ] ;%NWL%}%NWL%this . offset = this . picker . offset ( ) ;%NWL%this . formater = options . formater;%NWL%9
this . percentage = [%NWL%( this . value [ 0 ]  - this . min )  * 100 / this . diff ,%NWL%( this . value [ 1 ]  - this . min )  * 100 / this . diff ,%NWL%this . step * 100 / this . diff%NWL%] ;%NWL%} else {%NWL%this . percentage = [ 0 , 0 , 100 ] ;%NWL%}%NWL%this . offset = this . picker . offset ( ) ;%NWL%this . size = this . picker [ 0 ] [ this . sizePos ] ;%NWL%this . tooltip_separator = options . tooltip_separator;%NWL%8
( this . value [ 0 ]  - this . min )  * 100 / this . diff ,%NWL%( this . value [ 1 ]  - this . min )  * 100 / this . diff ,%NWL%this . step * 100 / this . diff%NWL%] ;%NWL%} else {%NWL%this . percentage = [ 0 , 0 , 100 ] ;%NWL%}%NWL%this . offset = this . picker . offset ( ) ;%NWL%this . size = this . picker [ 0 ] [ this . sizePos ] ;%NWL%this . formater = options . formater;%NWL%this . tooltip_split = options . tooltip_split;%NWL%7
( this . value [ 1 ]  - this . min )  * 100 / this . diff ,%NWL%this . step * 100 / this . diff%NWL%] ;%NWL%} else {%NWL%this . percentage = [ 0 , 0 , 100 ] ;%NWL%}%NWL%this . offset = this . picker . offset ( ) ;%NWL%this . size = this . picker [ 0 ] [ this . sizePos ] ;%NWL%this . formater = options . formater;%NWL%this . tooltip_separator = options . tooltip_separator;%NWL%this . reversed = this . element . data ( ' slider - reversed ' ) ||options . reversed;%NWL%6
if ( this . touchCapable )  {%NWL%this . picker . on ( {%NWL%touchstart: $ . proxy ( this . mousedown , this )%NWL%} ) ;%NWL%}%NWL%this . picker . on ( {%NWL%mousedown: $ . proxy ( this . mousedown , this )%NWL%} ) ;%NWL%if ( tooltip === ' hide ' )  {%NWL%this . tooltip . addClass ( ' hide ' ) ;%NWL%this . tooltip_max . addClass ( ' hide ' ) ;%NWL%9
} ) ;%NWL%this . handle2 . on ( {%NWL%focus: $ . proxy ( this . showTooltip , this ) ,%NWL%blur: $ . proxy ( this . hideTooltip , this )%NWL%} ) ;%NWL%}%NWL%this . enabled = options . enabled &&%NWL%( this . element . data ( ' slider - enabled ' ) === undefined || this . element . data ( ' slider - enabled ' ) === true ) ;%NWL%if ( this . enabled )  {%NWL%this . enable ( ) ;%NWL%this . disable ( ) ;%NWL%9
this . disable ( ) ;%NWL%}%NWL%} ;%NWL%Slider . prototype = {%NWL%constructor: Slider ,%NWL%over: false ,%NWL%inDrag: false ,%NWL%showTooltip: function ( ) {%NWL%if ( this . tooltip_split === false ) {%NWL%this . tooltip . addClass ( ' in ' ) ;%NWL%this . tooltip_min . addClass ( ' in ' ) ;%NWL%9
}%NWL%} ;%NWL%Slider . prototype = {%NWL%constructor: Slider ,%NWL%over: false ,%NWL%inDrag: false ,%NWL%showTooltip: function ( ) {%NWL%if ( this . tooltip_split === false ) {%NWL%this . tooltip . addClass ( ' in ' ) ;%NWL%} else {%NWL%this . tooltip_max . addClass ( ' in ' ) ;%NWL%8
this . tooltip . addClass ( ' in ' ) ;%NWL%} else {%NWL%this . tooltip_min . addClass ( ' in ' ) ;%NWL%this . tooltip_max . addClass ( ' in ' ) ;%NWL%}%NWL%this . over = true;%NWL%} ,%NWL%hideTooltip: function ( ) {%NWL%if ( this . inDrag === false && this . alwaysShowTooltip !== true )  {%NWL%this . tooltip . removeClass ( ' in ' ) ;%NWL%this . tooltip_max . removeClass ( ' in ' ) ;%NWL%9
this . tooltip_max . addClass ( ' bottom ' ) [ 0 ] . style . top = 18 +  ' px ' ;%NWL%} else {%NWL%this . tooltip_max . removeClass ( ' bottom ' ) ;%NWL%this . tooltip_max . addClass ( ' top ' ) [ 0 ] . style . top = - 30 +  ' px ' ;%NWL%}%NWL%}%NWL%if ( this . range )  {%NWL%this . tooltipInner . text (%NWL%this . formater ( this . value [ 0 ] )  + this . tooltip_separator + this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltipInner_min . text (%NWL%7
this . tooltip_max . addClass ( ' top ' ) [ 0 ] . style . top = - 30 +  ' px ' ;%NWL%}%NWL%}%NWL%if ( this . range )  {%NWL%this . tooltipInner . text (%NWL%this . formater ( this . value [ 0 ] )  + this . tooltip_separator + this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltip [ 0 ] . style [ this . stylePos ] = this . size *  ( positionPercentages [ 0 ]  +  ( positionPercentages [ 1 ]  - positionPercentages [ 0 ] ) / 2 ) / 100 -  ( this . orientation === ' vertical ' ? this . tooltip . outerHeight ( ) / 2 : this . tooltip . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltipInner_min . text (%NWL%this . formater ( this . value [ 0 ] )%NWL%this . tooltipInner_max . text (%NWL%4
if ( this . range )  {%NWL%this . tooltipInner . text (%NWL%this . formater ( this . value [ 0 ] )  + this . tooltip_separator + this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltip [ 0 ] . style [ this . stylePos ] = this . size *  ( positionPercentages [ 0 ]  +  ( positionPercentages [ 1 ]  - positionPercentages [ 0 ] ) / 2 ) / 100 -  ( this . orientation === ' vertical ' ? this . tooltip . outerHeight ( ) / 2 : this . tooltip . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltipInner_min . text (%NWL%this . formater ( this . value [ 0 ] )%NWL%) ;%NWL%this . tooltipInner_max . text (%NWL%this . formater ( this . value [ 1 ] )%NWL%this . tooltip_min [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 0 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_min . outerHeight ( ) / 2 : this . tooltip_min . outerWidth ( ) / 2 )  + ' px ' ;%NWL%4
this . tooltipInner . text (%NWL%this . formater ( this . value [ 0 ] )  + this . tooltip_separator + this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltip [ 0 ] . style [ this . stylePos ] = this . size *  ( positionPercentages [ 0 ]  +  ( positionPercentages [ 1 ]  - positionPercentages [ 0 ] ) / 2 ) / 100 -  ( this . orientation === ' vertical ' ? this . tooltip . outerHeight ( ) / 2 : this . tooltip . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltipInner_min . text (%NWL%this . formater ( this . value [ 0 ] )%NWL%) ;%NWL%this . tooltipInner_max . text (%NWL%this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltip_max [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 1 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_max . outerHeight ( ) / 2 : this . tooltip_max . outerWidth ( ) / 2 )  + ' px ' ;%NWL%3
) ;%NWL%this . tooltip [ 0 ] . style [ this . stylePos ] = this . size *  ( positionPercentages [ 0 ]  +  ( positionPercentages [ 1 ]  - positionPercentages [ 0 ] ) / 2 ) / 100 -  ( this . orientation === ' vertical ' ? this . tooltip . outerHeight ( ) / 2 : this . tooltip . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltipInner_min . text (%NWL%this . formater ( this . value [ 0 ] )%NWL%) ;%NWL%this . tooltipInner_max . text (%NWL%this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltip_min [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 0 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_min . outerHeight ( ) / 2 : this . tooltip_min . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltip_max [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 1 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_max . outerHeight ( ) / 2 : this . tooltip_max . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltipInner . text (%NWL%2
this . tooltip [ 0 ] . style [ this . stylePos ] = this . size *  ( positionPercentages [ 0 ]  +  ( positionPercentages [ 1 ]  - positionPercentages [ 0 ] ) / 2 ) / 100 -  ( this . orientation === ' vertical ' ? this . tooltip . outerHeight ( ) / 2 : this . tooltip . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltipInner_min . text (%NWL%this . formater ( this . value [ 0 ] )%NWL%) ;%NWL%this . tooltipInner_max . text (%NWL%this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltip_min [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 0 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_min . outerHeight ( ) / 2 : this . tooltip_min . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltip_max [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 1 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_max . outerHeight ( ) / 2 : this . tooltip_max . outerWidth ( ) / 2 )  + ' px ' ;%NWL%} else {%NWL%this . formater ( this . value [ 0 ] )%NWL%2
this . formater ( this . value [ 0 ] )%NWL%) ;%NWL%this . tooltipInner_max . text (%NWL%this . formater ( this . value [ 1 ] )%NWL%) ;%NWL%this . tooltip_min [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 0 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_min . outerHeight ( ) / 2 : this . tooltip_min . outerWidth ( ) / 2 )  + ' px ' ;%NWL%this . tooltip_max [ 0 ] . style [ this . stylePos ] = this . size *  (  ( positionPercentages [ 1 ] ) / 100 )  -  ( this . orientation === ' vertical ' ? this . tooltip_max . outerHeight ( ) / 2 : this . tooltip_max . outerWidth ( ) / 2 )  + ' px ' ;%NWL%} else {%NWL%this . tooltipInner . text (%NWL%this . formater ( this . value [ 0 ] )%NWL%this . tooltip [ 0 ] . style [ this . stylePos ] = this . size * positionPercentages [ 0 ] / 100 -  ( this . orientation === ' vertical ' ? this . tooltip . outerHeight ( ) / 2 : this . tooltip . outerWidth ( ) / 2 )  + ' px ' ;%NWL%5
this . tooltip [ 0 ] . style [ this . stylePos ] = this . size * positionPercentages [ 0 ] / 100 -  ( this . orientation === ' vertical ' ? this . tooltip . outerHeight ( ) / 2 : this . tooltip . outerWidth ( ) / 2 )  + ' px ' ;%NWL%}%NWL%} ,%NWL%mousedown: function ( ev )  {%NWL%if ( !this . isEnabled ( ) )  {%NWL%return false;%NWL%}%NWL%if ( this . touchCapable && ev . type === ' touchstart ' )  {%NWL%ev = ev . originalEvent;%NWL%}%NWL%this . offset = this . picker . offset ( ) ;%NWL%0
this . triggerFocusOnHandle ( ) ;%NWL%this . offset = this . picker . offset ( ) ;%NWL%this . size = this . picker [ 0 ] [ this . sizePos ] ;%NWL%var percentage = this . getPercentage ( ev ) ;%NWL%if ( this . range )  {%NWL%var diff1 = Math . abs ( this . percentage [ 0 ]  - percentage ) ;%NWL%var diff2 = Math . abs ( this . percentage [ 1 ]  - percentage ) ;%NWL%this . dragged = ( diff1 < diff2 ) ? 0 : 1;%NWL%} else {%NWL%this . dragged = 0;%NWL%this . percentage [ this . dragged ] = this . reversed ? 100 - percentage : percentage;%NWL%1
value: val%NWL%} )%NWL%. data ( ' value ' , val )%NWL%. prop ( ' value ' , val ) ;%NWL%return true;%NWL%} ,%NWL%triggerFocusOnHandle: function ( handleIdx )  {%NWL%if ( handleIdx === 0 )  {%NWL%this . handle1 . focus ( ) ;%NWL%}%NWL%this . handle2 . focus ( ) ;%NWL%8
var percentage = this . getPercentage ( ev ) ;%NWL%this . adjustPercentageForRangeSliders ( percentage ) ;%NWL%this . percentage [ this . dragged ] = this . reversed ? 100 - percentage : percentage;%NWL%this . layout ( ) ;%NWL%var val = this . calculateValue ( ) ;%NWL%this . setValue ( val ) ;%NWL%return false;%NWL%} ,%NWL%adjustPercentageForRangeSliders: function ( percentage )  {%NWL%if ( this . range )  {%NWL%this . percentage [ 0 ] = this . percentage [ 1 ] ;%NWL%2
this . layout ( ) ;%NWL%var val = this . calculateValue ( ) ;%NWL%this . setValue ( val ) ;%NWL%return false;%NWL%} ,%NWL%adjustPercentageForRangeSliders: function ( percentage )  {%NWL%if ( this . range )  {%NWL%if ( this . dragged === 0 && this . percentage [ 1 ] < percentage )  {%NWL%this . percentage [ 0 ] = this . percentage [ 1 ] ;%NWL%this . dragged = 1;%NWL%this . percentage [ 1 ] = this . percentage [ 0 ] ;%NWL%8
} ) ;%NWL%}%NWL%$ ( document ) . off ( {%NWL%mousemove: this . mousemove ,%NWL%mouseup: this . mouseup%NWL%} ) ;%NWL%this . inDrag = false;%NWL%if ( this . over === false )  {%NWL%this . hideTooltip ( ) ;%NWL%}%NWL%this . layout ( ) ;%NWL%8
return this . value [ 0 ] ;%NWL%} ,%NWL%setValue: function ( val )  {%NWL%if ( !val )  {%NWL%val = 0;%NWL%}%NWL%this . value = this . validateInputValue ( val ) ;%NWL%if ( this . range )  {%NWL%this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%8
if ( !val )  {%NWL%val = 0;%NWL%}%NWL%this . value = this . validateInputValue ( val ) ;%NWL%if ( this . range )  {%NWL%this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%} else {%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%this . handle2 . addClass ( ' hide ' ) ;%NWL%this . value [ 1 ] = this . max;%NWL%5
}%NWL%this . value = this . validateInputValue ( val ) ;%NWL%if ( this . range )  {%NWL%this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%} else {%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%this . handle2 . addClass ( ' hide ' ) ;%NWL%if ( this . selection === ' after ' )  {%NWL%this . value [ 1 ] = this . max;%NWL%this . value [ 1 ] = this . min;%NWL%3
this . value [ 0 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 0 ] ) ) ;%NWL%this . value [ 1 ] = Math . max ( this . min , Math . min ( this . max , this . value [ 1 ] ) ) ;%NWL%} else {%NWL%this . value = [ Math . max ( this . min , Math . min ( this . max , this . value ) ) ] ;%NWL%this . handle2 . addClass ( ' hide ' ) ;%NWL%if ( this . selection === ' after ' )  {%NWL%this . value [ 1 ] = this . max;%NWL%} else {%NWL%this . value [ 1 ] = this . min;%NWL%}%NWL%this . diff = this . max - this . min;%NWL%0
enable: function ( )  {%NWL%this . enabled = true;%NWL%this . handle1 . attr ( " tabindex " , 0 ) ;%NWL%this . handle2 . attr ( " tabindex " , 0 ) ;%NWL%this . picker . removeClass ( ' slider - disabled ' ) ;%NWL%this . element . trigger ( ' slideEnabled ' ) ;%NWL%} ,%NWL%toggle: function ( )  {%NWL%if ( this . enabled )  {%NWL%this . disable ( ) ;%NWL%this . enable ( ) ;%NWL%9
it ( " ' slideStart ' event is triggered properly and can be binded to " , function ( )  {%NWL%testSlider . on ( ' slideStart ' , function ( )  {%NWL%flag = true;%NWL%} ) ;%NWL%testSlider . data ( ' slider ' ) . mousedown ( mouse ) ;%NWL%expect ( flag ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( " ' slide ' event is triggered properly and can be binded to " , function ( )  {%NWL%testSlider . on ( ' slide ' , function ( )  {%NWL%flag = true;%NWL%testSlider . data ( ' slider ' ) . mousedown ( mouse ) ;%NWL%4
it ( " should not trigger ' slideStart ' event when disabled " , function ( )  {%NWL%testSlider . on ( ' slideStart ' , function ( )  {%NWL%flag = true;%NWL%} ) ;%NWL%testSlider . data ( ' slider ' ) . mousedown ( mouse ) ;%NWL%expect ( flag ) . not . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( " should not trigger ' slide ' event when disabled " , function ( )  {%NWL%testSlider . on ( ' slide ' , function ( )  {%NWL%flag = true;%NWL%testSlider . data ( ' slider ' ) . mousedown ( mouse ) ;%NWL%4
it ( " ' slideDisabled ' event is triggered properly and can be binded to " , function ( )  {%NWL%testSlider . on ( ' slideDisabled ' , function ( )  {%NWL%flag = true;%NWL%} ) ;%NWL%testSlider . slider ( ' disable ' ) ;%NWL%expect ( flag ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( " ' slideDisabled ' event is triggered properly and can be binded to " , function ( )  {%NWL%testSlider . on ( ' slideEnabled ' , function ( )  {%NWL%flag = true;%NWL%testSlider . slider ( ' disable ' ) ;%NWL%4
var rightArrowKeyDownEvent = $ . Event ( ' keydown ' ) ;%NWL%rightArrowKeyDownEvent . which = 39;%NWL%handle1 . trigger ( rightArrowKeyDownEvent ) ;%NWL%} ) ;%NWL%it ( " handle1 ' s value remains unchanged " , function ( )  {%NWL%var sliderValue = testSlider . slider ( ' getValue ' ) ;%NWL%handle1 . on ( " keydown " , function ( )  {%NWL%expect ( sliderValue [ 0 ] ) . toBe ( initialSliderVal ) ;%NWL%} ) ;%NWL%var rightArrowKeyDownEvent = $ . Event ( ' keydown ' ) ;%NWL%handle1 . trigger ( rightArrowKeyDownEvent ) ;%NWL%2
var leftArrowKeyDownEvent = $ . Event ( ' keydown ' ) ;%NWL%leftArrowKeyDownEvent . which = 37;%NWL%handle2 . trigger ( leftArrowKeyDownEvent ) ;%NWL%} ) ;%NWL%it ( " handle2 ' s value remains unchanged " , function ( )  {%NWL%var sliderValue = testSlider . slider ( ' getValue ' ) ;%NWL%handle2 . on ( " keydown " , function ( )  {%NWL%expect ( sliderValue [ 1 ] ) . toBe ( initialSliderVal ) ;%NWL%} ) ;%NWL%var leftArrowKeyDownEvent = $ . Event ( ' keydown ' ) ;%NWL%handle2 . trigger ( leftArrowKeyDownEvent ) ;%NWL%2
flag = true;%NWL%} ) ;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%expect ( flag ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( " unbinds from ' slide ' event " , function ( )  {%NWL%evtName = ' slide ' ;%NWL%testSlider . on ( evtName , function ( )  {%NWL%flag = true;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%2
} ) ;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%expect ( flag ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( " unbinds from ' slide ' event " , function ( )  {%NWL%evtName = ' slide ' ;%NWL%testSlider . on ( evtName , function ( )  {%NWL%flag = true;%NWL%} ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%2
flag = true;%NWL%} ) ;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%expect ( flag ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( " unbinds from ' slideStop ' event " , function ( )  {%NWL%evtName = ' slideStop ' ;%NWL%testSlider . on ( evtName , function ( )  {%NWL%flag = true;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%2
} ) ;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%expect ( flag ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( " unbinds from ' slideStop ' event " , function ( )  {%NWL%evtName = ' slideStop ' ;%NWL%testSlider . on ( evtName , function ( )  {%NWL%flag = true;%NWL%} ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%2
flag = true;%NWL%} ) ;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%expect ( flag ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( " unbinds from ' slideChange ' event " , function ( )  {%NWL%evtName = ' slideChange ' ;%NWL%testSlider . on ( evtName , function ( )  {%NWL%flag = true;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%2
} ) ;%NWL%testSlider . slider ( ' destroy ' ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%expect ( flag ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( " unbinds from ' slideChange ' event " , function ( )  {%NWL%evtName = ' slideChange ' ;%NWL%testSlider . on ( evtName , function ( )  {%NWL%flag = true;%NWL%} ) ;%NWL%testSlider . trigger ( evtName ) ;%NWL%2
describe ( " ' toggle ( ) ' tests " , function ( )  {%NWL%it ( " correctly enables a disabled slider " , function ( )  {%NWL%testSlider = $ ( " #testSlider1 " ) . slider ( {%NWL%enabled: false%NWL%} ) ;%NWL%testSlider . slider ( " toggle " ) ;%NWL%var isEnabled = testSlider . slider ( " isEnabled " ) ;%NWL%expect ( isEnabled ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( " correctly disables an enabled slider " , function ( )  {%NWL%testSlider . slider ( " toggle " ) ;%NWL%5
it ( " correctly enables a disabled slider " , function ( )  {%NWL%testSlider = $ ( " #testSlider1 " ) . slider ( {%NWL%enabled: false%NWL%} ) ;%NWL%testSlider . slider ( " toggle " ) ;%NWL%var isEnabled = testSlider . slider ( " isEnabled " ) ;%NWL%expect ( isEnabled ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( " correctly disables an enabled slider " , function ( )  {%NWL%testSlider = $ ( " #testSlider1 " ) . slider ( ) ;%NWL%var isEnabled = testSlider . slider ( " isEnabled " ) ;%NWL%5
it ( " returns true for an enabled slider " , function ( )  {%NWL%testSlider = $ ( " #testSlider1 " ) . slider ( ) ;%NWL%var isEnabled = testSlider . slider ( " isEnabled " ) ;%NWL%var hasDisabledClass = testSlider . parent ( ) . hasClass ( " slider " ) && testSlider . parent ( ) . hasClass ( " slider - disabled " ) ;%NWL%expect ( isEnabled ) . toBeTruthy ( ) ;%NWL%expect ( hasDisabledClass ) . not . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( " returns false for a disabled slider " , function ( )  {%NWL%testSlider = $ ( " #testSlider1 " ) . slider ( {%NWL%enabled: false%NWL%var isEnabled = testSlider . slider ( " isEnabled " ) ;%NWL%2
( function ( jQuery )  {%NWL%jQuery . eventEmitter = {%NWL%_JQInit: function ( )  {%NWL%this . _JQ = jQuery ( this ) ;%NWL%} ,%NWL%emit: function ( evt , data )  {%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%this . _JQ . trigger ( evt , data ) ;%NWL%} ,%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%6
this . _JQ = jQuery ( this ) ;%NWL%} ,%NWL%emit: function ( evt , data )  {%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%this . _JQ . trigger ( evt , data ) ;%NWL%} ,%NWL%once: function ( evt , handler )  {%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%this . _JQ . one ( evt , handler ) ;%NWL%} ,%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%3
this . _JQ . trigger ( evt , data ) ;%NWL%} ,%NWL%once: function ( evt , handler )  {%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%this . _JQ . one ( evt , handler ) ;%NWL%} ,%NWL%on: function ( evt , handler )  {%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%this . _JQ . bind ( evt , handler ) ;%NWL%} ,%NWL%!this . _JQ && this . _JQInit ( ) ;%NWL%3
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . parent = params . parent;%NWL%2
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . geoData = params . geoData;%NWL%this . colors = params . colors;%NWL%2
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . geoData = params . geoData;%NWL%this . parent = params . parent;%NWL%this . title = params . title;%NWL%2
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . geoData = params . geoData;%NWL%this . parent = params . parent;%NWL%this . colors = params . colors;%NWL%this . width = params . width || 600;%NWL%2
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . geoData = params . geoData;%NWL%this . parent = params . parent;%NWL%this . colors = params . colors;%NWL%this . title = params . title;%NWL%this . height = params . height || 400;%NWL%2
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . geoData = params . geoData;%NWL%this . parent = params . parent;%NWL%this . colors = params . colors;%NWL%this . title = params . title;%NWL%this . width = params . width || 600;%NWL%this . duration = params . duration || 2000;%NWL%2
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . geoData = params . geoData;%NWL%this . parent = params . parent;%NWL%this . colors = params . colors;%NWL%this . title = params . title;%NWL%this . width = params . width || 600;%NWL%this . height = params . height || 400;%NWL%this . factor = params . factor || 0 . 4;%NWL%2
window . France = ( function ( )  {%NWL%function Constructor ( params )  {%NWL%this . data = _ . clone ( params . data ) ;%NWL%this . geoData = params . geoData;%NWL%this . parent = params . parent;%NWL%this . colors = params . colors;%NWL%this . title = params . title;%NWL%this . width = params . width || 600;%NWL%this . height = params . height || 400;%NWL%this . duration = params . duration || 2000;%NWL%this . group = params . group;%NWL%2
this . parent = params . parent;%NWL%this . colors = params . colors;%NWL%this . title = params . title;%NWL%this . width = params . width || 600;%NWL%this . height = params . height || 400;%NWL%this . duration = params . duration || 2000;%NWL%this . factor = params . factor || 0 . 4;%NWL%this . group = params . group;%NWL%}%NWL%Constructor . prototype . init = function ( )  {%NWL%this . container = this . parent . append ( ' g ' )%NWL%3
this . width = params . width || 600;%NWL%this . height = params . height || 400;%NWL%this . duration = params . duration || 2000;%NWL%this . factor = params . factor || 0 . 4;%NWL%this . group = params . group;%NWL%}%NWL%Constructor . prototype . init = function ( )  {%NWL%var self = this;%NWL%this . container = this . parent . append ( ' g ' )%NWL%. attr ( ' transform ' ,  ' matrix ( ' + this . factor + ' , 0 , 0 , ' + this . factor + ' , - 110 , - 80 ) ' )%NWL%this . quantile = d3 . scale . quantile ( )%NWL%0
this . factor = params . factor || 0 . 4;%NWL%this . group = params . group;%NWL%}%NWL%Constructor . prototype . init = function ( )  {%NWL%var self = this;%NWL%this . container = this . parent . append ( ' g ' )%NWL%. attr ( ' transform ' ,  ' matrix ( ' + this . factor + ' , 0 , 0 , ' + this . factor + ' , - 110 , - 80 ) ' )%NWL%. append ( ' g ' ) ;%NWL%this . quantile = d3 . scale . quantile ( )%NWL%. domain ( _ . values ( _ . pick ( this . data [ this . data . length - 1 ] , this . group ) ) )%NWL%this . cValue = this . data . length - 1;%NWL%0
tspans . call ( tspanStyle ) ;%NWL%tspans . exit ( ) . remove ( ) ;%NWL%tspans . enter ( ) . append ( " tspan " )%NWL%. attr ( " dominant - baseline " ,  " alphabetic " )%NWL%. style ( " baseline - shift " ,  " 0% " )%NWL%. call ( tspanStyle ) ;%NWL%}%NWL%else {%NWL%tspans . transition ( t ) . call ( tspanStyle ) ;%NWL%tspans . exit ( ) . transition ( t )%NWL%tspans . enter ( ) . append ( " tspan " )%NWL%2
window_open: false ,%NWL%active_pane: ' ' ,%NWL%start: function ( )  {%NWL%anbu . el . close . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . zoom . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . tab_pane . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . close . click ( function ( event )  {%NWL%anbu . close_window ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . hide ( ) ;%NWL%7
active_pane: ' ' ,%NWL%start: function ( )  {%NWL%anbu . el . close . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . zoom . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . tab_pane . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . close . click ( function ( event )  {%NWL%anbu . close_window ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . hide . click ( function ( event )  {%NWL%event . preventDefault ( ) ;%NWL%7
anbu . el . zoom . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . tab_pane . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . close . click ( function ( event )  {%NWL%anbu . close_window ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . hide . click ( function ( event )  {%NWL%anbu . hide ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . show ( ) ;%NWL%3
anbu . el . tab_pane . css ( ' visibility ' ,  ' visible ' ) . hide ( ) ;%NWL%anbu . el . close . click ( function ( event )  {%NWL%anbu . close_window ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . hide . click ( function ( event )  {%NWL%anbu . hide ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . show . click ( function ( event )  {%NWL%event . preventDefault ( ) ;%NWL%3
event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . hide . click ( function ( event )  {%NWL%anbu . hide ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . show . click ( function ( event )  {%NWL%anbu . show ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . zoom ( ) ;%NWL%3
} ) ;%NWL%anbu . el . hide . click ( function ( event )  {%NWL%anbu . hide ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . show . click ( function ( event )  {%NWL%anbu . show ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . zoom . click ( function ( event )  {%NWL%event . preventDefault ( ) ;%NWL%3
} ) ;%NWL%anbu . el . show . click ( function ( event )  {%NWL%anbu . show ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . zoom . click ( function ( event )  {%NWL%anbu . zoom ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . tab . click ( function ( event )  {%NWL%event . preventDefault ( ) ;%NWL%3
anbu . el . zoom . click ( function ( event )  {%NWL%anbu . zoom ( ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%anbu . el . tab . click ( function ( event )  {%NWL%anbu . clicked_tab ( anbu . jq ( this ) ) ;%NWL%event . preventDefault ( ) ;%NWL%} ) ;%NWL%} ,%NWL%clicked_tab: function ( tab )  {%NWL%anbu . close_window ( ) ;%NWL%1
show: function ( )  {%NWL%anbu . el . closed_tabs . fadeOut ( 600 , function ( )  {%NWL%anbu . el . main . removeClass ( ' anbu - hidden ' ) ;%NWL%anbu . el . open_tabs . fadeIn ( 200 ) ;%NWL%} ) ;%NWL%anbu . el . main . animate ( { width: ' 100% ' } , 700 ) ;%NWL%} ,%NWL%hide: function ( )  {%NWL%anbu . close_window ( ) ;%NWL%setTimeout ( function ( )  {%NWL%anbu . close_window ( ) ;%NWL%8
this . stats = this . calc . run ( ) ;%NWL%} ,%NWL%renderAgain: function ( )  {%NWL%var build = this;%NWL%$ ( " . pt - adjustor " ) . val ( " 1 " ) ;%NWL%this . calc . setBuild ( this ) ;%NWL%this . stats = this . calc . run ( ) ;%NWL%$ . each ( this . elems , function ( k , v )  {%NWL%build . renderTo ( v ) ;%NWL%} ) ;%NWL%build . renderSkillsTo ( v ) ;%NWL%8
var build = this;%NWL%$ ( " . pt - adjustor " ) . val ( " 1 " ) ;%NWL%this . calc . setBuild ( this ) ;%NWL%this . stats = this . calc . run ( ) ;%NWL%$ . each ( this . elems , function ( k , v )  {%NWL%build . renderTo ( v ) ;%NWL%} ) ;%NWL%$ . each ( this . skillElems , function ( k , v )  {%NWL%build . renderSkillsTo ( v ) ;%NWL%} ) ;%NWL%build . renderSkillCatalog ( v ) ;%NWL%5
}%NWL%var hiddenVals = [ ' sharpshooter - dps ' ,  ' dps - demon ' ,  ' tdps ' ,  ' tickRate - mh ' ,  ' tickRate - oh ' ,  ' dps - elites ' ,  ' scram - a - mh ' ,  ' scram - a - oh ' ,  ' 3sec - dps ' ] ;%NWL%if ( id == ' dps - speed - display ' || id == ' hp - ehp - ratio ' )  {%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%} else if ( _ . indexOf ( hiddenVals , id ) >= 0 && parseFloat ( value ) )  {%NWL%stat . parent ( ) . show ( ) ;%NWL%value = Math . round ( value * 100 )  / 100;%NWL%value = value . toString ( ) . replace ( / ( \d ) ( ?= ( \d\d\d ) + ( ?!\d ) ) / g ,  " $1 , " ) ;%NWL%if ( id == ' tickRate ' )  {%NWL%suffix = " ticks / sec " ;%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%3
value = Math . round ( value * 100 )  / 100;%NWL%value = value . toString ( ) . replace ( / ( \d ) ( ?= ( \d\d\d ) + ( ?!\d ) ) / g ,  " $1 , " ) ;%NWL%if ( id == ' tickRate ' )  {%NWL%suffix = " ticks / sec " ;%NWL%}%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%} else if ( type == ' long - round ' )  {%NWL%if ( typeof ( value ) == ' undefined ' )  {%NWL%value = 0;%NWL%}%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%5
suffix = " ticks / sec " ;%NWL%}%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%} else if ( type == ' long - round ' )  {%NWL%if ( typeof ( value ) == ' undefined ' )  {%NWL%value = 0;%NWL%}%NWL%value = Math . round ( value * 10000 )  / 10000;%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%} else {%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%2
value = Math . round ( value * 10000 )  / 10000;%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%} else {%NWL%if ( isNaN ( parseFloat ( value ) ) && value )  {%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%} else if ( value )  {%NWL%if ( stat . data ( " multiply " ) )  {%NWL%value = value * 100;%NWL%}%NWL%value = Math . round ( value * 100 )  / 100;%NWL%stat . prepend ( prefix + value + suffix ) ;%NWL%1
skill = build . stats . skillData [ slug ] ;%NWL%if ( !stacks )  {%NWL%stacks = 1;%NWL%if ( data . effect . stackable && data . effect . stackable . limit )  {%NWL%stacks = data . effect . stackable . limit;%NWL%}%NWL%}%NWL%if ( d3up . builds [ ' build ' ] . skills . enabled [ slug ] )  {%NWL%skillIcon . addClass ( " skill - activated " ) ;%NWL%checkbox . attr ( " checked " ,  " checked " ) ;%NWL%skillIcon . removeClass ( " skill - activated " ) ;%NWL%8
$ ( " . simulate - change " ) . trigger ( " change " ) ;%NWL%$ . each ( d3up . builds , function ( k )  {%NWL%d3up . builds [ k ] . renderAgain ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%select . bind ( ' change ' , function ( )  {%NWL%var stacks = $ ( this ) . val ( )%NWL%checkbox . attr ( " data - stacks " , stacks ) ;%NWL%$ . each ( d3up . builds , function ( k )  {%NWL%if ( d3up . builds [ k ] . skills . enabled [ slug ] )  {%NWL%d3up . builds [ k ] . renderAgain ( ) ;%NWL%2
var xAxis = d3 . svg . axis ( ) . orient ( " bottom " ) . scale ( xScale ) . ticks ( 12 , d3 . format ( " , d " ) ) ,%NWL%yAxis = d3 . svg . axis ( ) . scale ( yScale ) . orient ( " left " ) ;%NWL%var svg = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , width + margin . left + margin . right )%NWL%. attr ( " height " , height + margin . top + margin . bottom )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + margin . left +  " , "  + margin . top +  " ) " ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " class " ,  " x axis " )%NWL%. attr ( " transform " ,  " translate ( 0 , "  + height +  " ) " )%NWL%svg . append ( " g " )%NWL%7
. attr ( " transform " ,  " translate ( 0 , "  + height +  " ) " )%NWL%. call ( xAxis ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " class " ,  " y axis " )%NWL%. call ( yAxis ) ;%NWL%svg . append ( " text " )%NWL%. attr ( " class " ,  " x label " )%NWL%. attr ( " text - anchor " ,  " end " )%NWL%. attr ( " x " , width )%NWL%. attr ( " y " , height - 6 )%NWL%svg . append ( " text " )%NWL%5
else if ( allBindingsAccessor ( ) . options && allBindingsAccessor ( ) . options ( ) . length !== ms . originalOptions . length )  {%NWL%ms . updateOriginalOptions ( ) ;%NWL%$ ( element ) . multiselect ( ' rebuild ' ) ;%NWL%}%NWL%}%NWL%} ;%NWL%}%NWL%function Multiselect ( select , options )  {%NWL%%NWL%this . options = this . getOptions ( options ) ;%NWL%this . originalOptions = this . $select . clone ( ) [ 0 ] . options; / / we have to clone to create a new reference%NWL%9
}%NWL%} ;%NWL%}%NWL%function Multiselect ( select , options )  {%NWL%%NWL%this . options = this . getOptions ( options ) ;%NWL%this . $select = $ ( select ) ;%NWL%this . originalOptions = this . $select . clone ( ) [ 0 ] . options; / / we have to clone to create a new reference%NWL%this . query = ' ' ;%NWL%this . searchTimeout = null;%NWL%this . options . multiple = this . $select . attr ( ' multiple ' ) == " multiple " ;%NWL%5
}%NWL%function Multiselect ( select , options )  {%NWL%%NWL%this . options = this . getOptions ( options ) ;%NWL%this . $select = $ ( select ) ;%NWL%this . originalOptions = this . $select . clone ( ) [ 0 ] . options; / / we have to clone to create a new reference%NWL%this . query = ' ' ;%NWL%this . searchTimeout = null;%NWL%%NWL%this . options . multiple = this . $select . attr ( ' multiple ' ) == " multiple " ;%NWL%this . $container = $ ( this . options . buttonContainer )%NWL%3
$ ( element ) . hide ( ) ;%NWL%}%NWL%}%NWL%} , this ) ) ;%NWL%}%NWL%} , this ) , 300 , this ) ;%NWL%} , this ) ) ;%NWL%}%NWL%%NWL%this . buildDropdown ( ) ;%NWL%this . updateButtonText ( ) ;%NWL%9
constructor: Multiselect ,%NWL%%NWL%createOptionValue: function ( element )  {%NWL%if ( $ ( element ) . is ( ' :selected ' ) )  {%NWL%$ ( element ) . attr ( ' selected ' ,  ' selected ' ) . prop ( ' selected ' , true ) ;%NWL%}%NWL%%NWL%var label = $ ( element ) . attr ( ' label ' ) || $ ( element ) . text ( ) ;%NWL%var value = $ ( element ) . val ( ) ;%NWL%var inputType = this . options . multiple ? " checkbox " : " radio " ;%NWL%var selected = $ ( element ) . prop ( ' selected ' ) || false;%NWL%7
var groupName = $ ( group ) . prop ( ' label ' ) ;%NWL%%NWL%var $li = $ ( ' <li><label style= " margin:0;padding:3px 20px 3px 20px;height:100%; " class= " multiselect - group " >< / label>< / li> ' ) ;%NWL%$ ( ' label ' , $li ) . text ( groupName ) ;%NWL%$ ( ' . multiselect - container ul ' , this . $container ) . append ( $li ) ;%NWL%%NWL%$ ( ' option ' , group ) . each ( $ . proxy ( function ( index , element )  {%NWL%this . createOptionValue ( element ) ;%NWL%} , this ) ) ;%NWL%}%NWL%this . createOptionValue ( element ) ;%NWL%7
}%NWL%$checkbox . prop ( ' checked ' , false ) ;%NWL%%NWL%$option . removeAttr ( ' selected ' ) . prop ( ' selected ' , false ) ;%NWL%%NWL%this . updateButtonText ( ) ;%NWL%} ,%NWL%%NWL%rebuild: function ( )  {%NWL%$ ( ' . multiselect - container ul ' , this . $container ) . html ( ' ' ) ;%NWL%this . updateButtonText ( ) ;%NWL%5
var data = $ ( this ) . data ( ' multiselect ' ) ,%NWL%options = typeof option == ' object ' && option;%NWL%if ( !data )  {%NWL%$ ( this ) . data ( ' multiselect ' ,  ( data = new Multiselect ( this , options ) ) ) ;%NWL%}%NWL%if ( typeof option == ' string ' )  {%NWL%data [ option ] ( parameter ) ;%NWL%}%NWL%} ) ;%NWL%} ;%NWL%$ . fn . multiselect . Constructor = Multiselect;%NWL%3
this . qualitySelect = element;%NWL%} ,%NWL%bindQualitySelect: function ( )  {%NWL%var selector = this . qualitySelect ,%NWL%builder = this;%NWL%if ( selector )  {%NWL%selector . bind ( ' change ' , function ( )  {%NWL%builder . item . quality = $ ( this ) . val ( ) ;%NWL%if ( builder . item . quality == 7 )  {%NWL%builder . addSetBonusSelect ( ) ;%NWL%builder . removeSetBonusSelect ( ) ;%NWL%9
bindQualitySelect: function ( )  {%NWL%var selector = this . qualitySelect ,%NWL%builder = this;%NWL%if ( selector )  {%NWL%selector . bind ( ' change ' , function ( )  {%NWL%builder . item . quality = $ ( this ) . val ( ) ;%NWL%if ( builder . item . quality == 7 )  {%NWL%builder . addSetBonusSelect ( ) ;%NWL%} else {%NWL%builder . removeSetBonusSelect ( ) ;%NWL%builder . updatePreview ( ) ;%NWL%7
bindAttributeSelect: function ( )  {%NWL%var selector = this . attributeSelect ,%NWL%builder = this;%NWL%if ( selector )  {%NWL%selector . bind ( ' change ' , function ( )  {%NWL%var attributes = selector . val ( ) ;%NWL%_ . each ( attributes , function ( v )  {%NWL%builder . addAttribute ( v ) ;%NWL%} , builder ) ;%NWL%_ . each ( builder . attrsSelected , function ( v )  {%NWL%builder . removeAttribute ( v ) ;%NWL%7
dpsMax = this . item . stats . damage . max ,%NWL%dpsSpeed = this . item . stats . speed;%NWL%dpsDisplay . val ( ( dpsMin + dpsMax )  / 2 * dpsSpeed ) ;%NWL%}%NWL%if ( this . changeCallback )  {%NWL%this . changeCallback ( this ) ;%NWL%}%NWL%} ,%NWL%removeStat: function ( name )  {%NWL%delete this . item . stats [ name ] ;%NWL%this . changeCallback ( this ) ;%NWL%5
}%NWL%} ,%NWL%removeStat: function ( name )  {%NWL%delete this . item . stats [ name ] ;%NWL%if ( this . changeCallback )  {%NWL%this . changeCallback ( this ) ;%NWL%}%NWL%} ,%NWL%removeStats: function ( name )  {%NWL%this . item . stats = { } ;%NWL%this . changeCallback ( this ) ;%NWL%5
default:%NWL%this . item . attrs [ name ] = parseFloat ( value ) ;%NWL%break;%NWL%}%NWL%if ( this . changeCallback )  {%NWL%this . changeCallback ( this ) ;%NWL%}%NWL%} ,%NWL%removeAttribute: function ( name )  {%NWL%delete this . item . attrs [ name ] ;%NWL%this . changeCallback ( this ) ;%NWL%5
}%NWL%} ,%NWL%removeAttribute: function ( name )  {%NWL%delete this . item . attrs [ name ] ;%NWL%if ( this . changeCallback )  {%NWL%this . changeCallback ( this ) ;%NWL%}%NWL%} ,%NWL%removeAttributes: function ( name )  {%NWL%this . item . attrs = { } ;%NWL%this . changeCallback ( this ) ;%NWL%5
}%NWL%if ( _ . indexOf ( builder . attrsSelected , nameCheck ) < 0 )  {%NWL%$ ( this ) . remove ( ) ;%NWL%}%NWL%} ) ;%NWL%} ,%NWL%init: function ( )  {%NWL%this . preview = { } ;%NWL%this . skillText = this . skillText;%NWL%this . bindNameInput ( ) ;%NWL%this . bindItemTypeSelect ( ) ;%NWL%9
if ( _ . indexOf ( builder . attrsSelected , nameCheck ) < 0 )  {%NWL%$ ( this ) . remove ( ) ;%NWL%}%NWL%} ) ;%NWL%} ,%NWL%init: function ( )  {%NWL%this . preview = { } ;%NWL%this . skillText = this . skillText;%NWL%this . bindNameInput ( ) ;%NWL%this . bindQualitySelect ( ) ;%NWL%this . bindAttributeSelect ( ) ;%NWL%8
$ ( this ) . remove ( ) ;%NWL%}%NWL%} ) ;%NWL%} ,%NWL%init: function ( )  {%NWL%this . preview = { } ;%NWL%this . skillText = this . skillText;%NWL%this . bindNameInput ( ) ;%NWL%this . bindQualitySelect ( ) ;%NWL%this . bindItemTypeSelect ( ) ;%NWL%this . bindSocketSelect ( ) ;%NWL%7
}%NWL%} ) ;%NWL%} ,%NWL%init: function ( )  {%NWL%this . preview = { } ;%NWL%this . skillText = this . skillText;%NWL%this . bindNameInput ( ) ;%NWL%this . bindQualitySelect ( ) ;%NWL%this . bindItemTypeSelect ( ) ;%NWL%this . bindAttributeSelect ( ) ;%NWL%this . bindSetBonusSelect ( ) ;%NWL%6
this . bindItemTypeSelect ( ) ;%NWL%this . bindAttributeSelect ( ) ;%NWL%this . bindSocketSelect ( ) ;%NWL%this . bindSetBonusSelect ( ) ;%NWL%this . gemEffect = d3up . gameData . gemEffects;%NWL%if ( !this . item )  {%NWL%this . item = {%NWL%attrs: { } ,%NWL%stats: { } ,%NWL%} ;%NWL%this . initPreview ( ) ;%NWL%0
attrs: { } ,%NWL%stats: { } ,%NWL%} ;%NWL%}%NWL%this . initPreview ( ) ;%NWL%} ,%NWL%addHeader: function ( element )  {%NWL%this . headerElements . push ( element ) ;%NWL%this . preview . header . append ( element ) ;%NWL%} ,%NWL%this . footerElements . push ( element ) ;%NWL%7
if ( _ . indexOf ( v , type ) >= 0 )  {%NWL%itemClass = k;%NWL%}%NWL%} , this ) ;%NWL%return itemClass;%NWL%} ,%NWL%setItem: function ( slot , item )  {%NWL%this . slot = slot;%NWL%this . item = _ . clone ( item , true ) ;%NWL%if ( this . item )  {%NWL%this . item . socketCount = item . sockets . length;%NWL%8
}%NWL%} , this ) ;%NWL%return itemClass;%NWL%} ,%NWL%setItem: function ( slot , item )  {%NWL%this . slot = slot;%NWL%this . item = _ . clone ( item , true ) ;%NWL%if ( this . item )  {%NWL%if ( this . item . sockets )  {%NWL%this . item . socketCount = item . sockets . length;%NWL%this . item . itemClass = this . getItemClass ( item . type )%NWL%6
} , this ) ;%NWL%return itemClass;%NWL%} ,%NWL%setItem: function ( slot , item )  {%NWL%this . slot = slot;%NWL%this . item = _ . clone ( item , true ) ;%NWL%if ( this . item )  {%NWL%if ( this . item . sockets )  {%NWL%this . item . socketCount = item . sockets . length;%NWL%}%NWL%this . item . setBonus = item . set;%NWL%5
this . itemSetBonusSelect . find ( " option " ) . each ( function ( )  {%NWL%if ( item . set == $ ( this ) . val ( ) )  {%NWL%$ ( this ) . attr ( " selected " ,  " selected " ) ;%NWL%}%NWL%} ) ;%NWL%}%NWL%}%NWL%if ( this . qualitySelect )  {%NWL%this . qualitySelect . trigger ( " change " ) ;%NWL%}%NWL%this . itemTypeSelect . trigger ( " change " ) ;%NWL%8
}%NWL%} ) ;%NWL%}%NWL%}%NWL%if ( this . qualitySelect )  {%NWL%this . qualitySelect . trigger ( " change " ) ;%NWL%}%NWL%if ( this . itemTypeSelect )  {%NWL%this . itemTypeSelect . trigger ( " change " ) ;%NWL%}%NWL%this . attributeSelect . trigger ( " change " ) ;%NWL%5
$ . fn . skillTip = function ( )  {%NWL%var tooltip = $ ( " #d3up - tooltip " ) ,%NWL%container = $ ( " <div class= ' d3 - tooltip ' / > " ) ,%NWL%header = $ ( " <div class= ' top skill ' / > " ) ,%NWL%content = $ ( " <div class= ' item ' / > " ) ,%NWL%footer = $ ( " <div class= ' bottom ' / > " ) ,%NWL%desc = $ ( " <p class= ' skill - desc ' > " ) . append ( $ ( this ) . data ( " tooltip " ) ) ;%NWL%var icon = $ ( " <span class= ' passive - icon ' ><img src= ' "  + $ ( this ) . data ( " icon " )  +  " ' >< / span> " ) ;%NWL%1
$ . fn . skillTip = function ( )  {%NWL%var tooltip = $ ( " #d3up - tooltip " ) ,%NWL%container = $ ( " <div class= ' d3 - tooltip ' / > " ) ,%NWL%header = $ ( " <div class= ' top skill ' / > " ) ,%NWL%content = $ ( " <div class= ' item ' / > " ) ,%NWL%footer = $ ( " <div class= ' bottom ' / > " ) ,%NWL%desc = $ ( " <p class= ' skill - desc ' > " ) . append ( $ ( this ) . data ( " tooltip " ) ) ;%NWL%if ( $ ( this ) . data ( " type " ) == ' passive ' )  {%NWL%var icon = $ ( " <span class= ' passive - icon ' ><img src= ' "  + $ ( this ) . data ( " icon " )  +  " ' >< / span> " ) ;%NWL%var icon = $ ( " <span class= ' d3 - icon d3 - icon - skill d3 - icon - skill - 42 ' style= ' background - image: url ( "  + $ ( this ) . data ( " icon " )  +  " ) ' ><span class= ' frame ' >< / span> " ) ;%NWL%1
' ehp '%NWL%]%NWL%} ,%NWL%_create: function ( )  {%NWL%var params = this . getParameterByName ( ' filter ' ) ;%NWL%if ( params )  {%NWL%this . replaceState ( $ . parseJSON ( $ . base64 . decode ( params ) ) ) ;%NWL%}%NWL%this . _on ( window ,  { statechange: " update "  } ) ;%NWL%this . _createFilters ( ) ;%NWL%this . _buildColumnHeaders ( ) ;%NWL%9
} ,%NWL%_create: function ( )  {%NWL%var params = this . getParameterByName ( ' filter ' ) ;%NWL%if ( params )  {%NWL%this . replaceState ( $ . parseJSON ( $ . base64 . decode ( params ) ) ) ;%NWL%}%NWL%this . _on ( window ,  { statechange: " update "  } ) ;%NWL%this . _createFilters ( ) ;%NWL%this . _createPaginators ( ) ;%NWL%this . _buildColumnHeaders ( ) ;%NWL%this . _addSearchSource ( ) ;%NWL%7
var params = this . getParameterByName ( ' filter ' ) ;%NWL%if ( params )  {%NWL%this . replaceState ( $ . parseJSON ( $ . base64 . decode ( params ) ) ) ;%NWL%}%NWL%this . _on ( window ,  { statechange: " update "  } ) ;%NWL%this . _createFilters ( ) ;%NWL%this . _createPaginators ( ) ;%NWL%this . _buildColumnHeaders ( ) ;%NWL%if ( this . getState ( ) . data . battletag )  {%NWL%this . _addSearchSource ( ) ;%NWL%this . updateSkillFilters ( ) ;%NWL%5
if ( params )  {%NWL%this . replaceState ( $ . parseJSON ( $ . base64 . decode ( params ) ) ) ;%NWL%}%NWL%this . _on ( window ,  { statechange: " update "  } ) ;%NWL%this . _createFilters ( ) ;%NWL%this . _createPaginators ( ) ;%NWL%this . _buildColumnHeaders ( ) ;%NWL%if ( this . getState ( ) . data . battletag )  {%NWL%this . _addSearchSource ( ) ;%NWL%}%NWL%this . update ( ) ;%NWL%4
} ,%NWL%update: function ( )  {%NWL%var container = this . options . container ,%NWL%row = $ ( " <tr> " ) ,%NWL%state = this . getState ( ) ;%NWL%container . empty ( ) ;%NWL%row . append ( $ ( " <td colspan= ' 100 ' class= ' loading ' > " ) . html ( " Loading " ) ) ;%NWL%container . append ( row ) ;%NWL%if ( !state . data . battlenet )  {%NWL%this . _showBattlenetSearch ( ) ;%NWL%this . _showD3UpcomSearch ( ) ;%NWL%9
if ( state . data . battletag )  {%NWL%content . append ( $ ( " <p class= ' label label - info ' > " ) . append ( " Click ' Search Battle . net ' below to search through Battle . net Characters . " ) ) ;%NWL%}%NWL%}%NWL%row . append ( cell . html ( content ) ) ;%NWL%container . append ( row ) ;%NWL%$ ( " . btn . next " ) . hide ( ) ;%NWL%return;%NWL%}%NWL%if ( data . error )  {%NWL%container . append ( row ) ;%NWL%5
case " name " :%NWL%if ( data [ 1 ] )  {%NWL%date = new Date ( data [ 2 ] . updated * 1000 ) ;%NWL%updated . attr ( " title " , date . toISOString ( ) ) ;%NWL%updated . timeago ( ) ;%NWL%td . append ( link , updated ) ;%NWL%} else {%NWL%td . html ( data [ 0 ] ) ;%NWL%}%NWL%break;%NWL%td . html ( data [ 0 ] ) ;%NWL%7
el . on ( ' click ' , this . options . modifyToggle , $ . proxy ( this ,  ' _modifyToggle ' ) ) ;%NWL%} ,%NWL%_modifyToggle: function ( event )  {%NWL%this . _log ( " _modifyToggle " ) ;%NWL%var toggle = $ ( event . currentTarget ) ,%NWL%slot = toggle . data ( ' modify - toggle ' ) ;%NWL%toggle . closest ( ' tr . item ' ) . toggleClass ( ' active - modify ' ) ;%NWL%toggle . toggleClass ( " icon - flip - horizontal " ) ;%NWL%if ( this . _modifyIs ( slot ) )  {%NWL%this . _modifyEnd ( slot ) ;%NWL%this . _modifyStart ( slot ) ;%NWL%9
} ) ;%NWL%}%NWL%this . modifying [ slot ] = false;%NWL%this . _modifyUpdate ( ) ;%NWL%this . _log ( " _modifyStart @ Currently: "  + JSON . stringify ( this . modifying ) ) ;%NWL%} ,%NWL%_modifyEnd: function ( slot )  {%NWL%this . _log ( " _modifyEnd @ "  + slot ) ;%NWL%var item = this . options . modify . find ( " [ data - slot= "  + slot +  " ] " ) ;%NWL%delete this . modifying [ slot ] ;%NWL%this . _modifyUpdate ( ) ;%NWL%3
console . log ( " reverting " , original ) ;%NWL%} else {%NWL%this . modified . gear [ slot ] = _ . merge ( original , modifications ) ;%NWL%}%NWL%this . simulate ( ) ;%NWL%} ,%NWL%simulate: function ( )  {%NWL%console . log ( " _simulate " , this . modified ) ;%NWL%this . sandbox . reset ( ) ;%NWL%this . sandbox . add ( new d3up . Calc ( this . modified , true ) ,  ' compare ' ) ;%NWL%this . _simulateRender ( ) ;%NWL%4
search . attr ( " placeholder " ,  " Start typing the name and press enter " ) ;%NWL%search . typeahead ( {%NWL%source: function ( )  {%NWL%var existing = _ . keys ( $this . options . item . attrs ) ,%NWL%all = _ . keys ( d3up . gameData . attributes ) ,%NWL%searchable = _ . difference ( all , existing ) ,%NWL%results = [ ] ;%NWL%_ . each ( searchable , function ( attr )  {%NWL%results . push ( d3up . gameData . attributes [ attr ] ) ;%NWL%} ) ;%NWL%results . push ( d3up . gameData . attributes [ attr ] ) ;%NWL%8
if ( !modified . sockets )  {%NWL%modified . sockets = { } ;%NWL%}%NWL%modified . sockets [ nextIdx ] = " empty " ;%NWL%if ( !item . sockets )  {%NWL%item . sockets = { } ;%NWL%}%NWL%item . sockets [ nextIdx ] = " empty " ;%NWL%if ( nextIdx > 0 )  {%NWL%sockets . append ( li . append ( this . _createSocketSelect ( nextIdx ) ) ) ;%NWL%sockets . prepend ( li . append ( this . _createSocketSelect ( nextIdx ) ) ) ;%NWL%9
}%NWL%this . _update ( ) ;%NWL%} ,%NWL%_modifyType: function ( event )  {%NWL%console . log ( " _modifyType " ) ;%NWL%var modified = this . options . modified ,%NWL%target = $ ( event . currentTarget ) ,%NWL%key = target . data ( " type " ) ,%NWL%value = target . val ( ) ;%NWL%if ( key === ' quality ' )  {%NWL%this . _modifyItemQuality ( ) ;%NWL%1
_modifyType: function ( event )  {%NWL%console . log ( " _modifyType " ) ;%NWL%var modified = this . options . modified ,%NWL%target = $ ( event . currentTarget ) ,%NWL%key = target . data ( " type " ) ,%NWL%value = target . val ( ) ;%NWL%if ( key === ' quality ' )  {%NWL%modified [ key ] = Number ( value ) ;%NWL%this . _modifyItemQuality ( ) ;%NWL%} else if ( key === ' type ' )  {%NWL%this . _modifyItemType ( ) ;%NWL%8
var modified = this . options . modified ,%NWL%target = $ ( event . currentTarget ) ,%NWL%key = target . data ( " type " ) ,%NWL%value = target . val ( ) ;%NWL%if ( key === ' quality ' )  {%NWL%modified [ key ] = Number ( value ) ;%NWL%this . _modifyItemQuality ( ) ;%NWL%} else if ( key === ' type ' )  {%NWL%modified [ key ] = value;%NWL%this . _modifyItemType ( ) ;%NWL%this . _update ( ) ;%NWL%6
this . options . modified . stats = { } ;%NWL%_ . each ( _ . keys ( this . options . item . stats ) , function ( k )  {%NWL%console . log ( " nulling " , k ) ;%NWL%this . options . modified . stats [ k ] = null;%NWL%} , this ) ;%NWL%this . options . item . stats = { } ;%NWL%this . options . item . type = this . options . modified . type;%NWL%var itemClass = d3up . Calc . prototype . itemClass ( this . options . modified . type ) ;%NWL%_ . each ( d3up . gameData . itemStats [ itemClass ] , function ( stat )  {%NWL%var parts = stat . split ( " ~ " ) ;%NWL%this . options . item . stats [ parts [ 0 ]  +  " ~ "  + parts [ 1 ] ] = 1;%NWL%6
console . log ( " nulling " , k ) ;%NWL%this . options . modified . stats [ k ] = null;%NWL%} , this ) ;%NWL%this . options . item . stats = { } ;%NWL%this . options . item . type = this . options . modified . type;%NWL%var itemClass = d3up . Calc . prototype . itemClass ( this . options . modified . type ) ;%NWL%_ . each ( d3up . gameData . itemStats [ itemClass ] , function ( stat )  {%NWL%var parts = stat . split ( " ~ " ) ;%NWL%if ( parts . length > 1 )  {%NWL%this . options . item . stats [ parts [ 0 ]  +  " ~ "  + parts [ 1 ] ] = 1;%NWL%this . options . item . stats [ stat ] = 1;%NWL%4
}%NWL%modified . stats [ stat ] = Number ( value ) ;%NWL%this . _update ( ) ;%NWL%console . log ( JSON . stringify ( modified ) ) ;%NWL%} ,%NWL%_modifyName: function ( event )  {%NWL%console . log ( " _modifyName " ) ;%NWL%var modified = this . options . modified ,%NWL%target = $ ( event . currentTarget ) ,%NWL%value = target . val ( ) ;%NWL%this . _update ( ) ;%NWL%2
} ,%NWL%_modifyName: function ( event )  {%NWL%console . log ( " _modifyName " ) ;%NWL%var modified = this . options . modified ,%NWL%target = $ ( event . currentTarget ) ,%NWL%value = target . val ( ) ;%NWL%modified . name = value;%NWL%this . _update ( ) ;%NWL%} ,%NWL%_modifyAttr: function ( event )  {%NWL%var modified = this . options . modified ,%NWL%3
group . append ( $ ( " <a class= ' btn ' href= ' # ' data - for= ' revert ' >Revert< / a> " ) ) ;%NWL%group . append ( $ ( " <a class= ' btn ' href= ' # ' data - for= ' cancel ' >Cancel< / a> " ) ) ;%NWL%controls . append ( group ) ;%NWL%titlebar . append ( $ ( " <div class= ' item ' > " ) . append ( icon . addClass ( " item - icon - box pull - left " ) ) ) ;%NWL%this . elements . top . after ( titlebar ) ;%NWL%this . elements . item . after ( editor ) ;%NWL%this . elements . bottom . append ( controls ) ;%NWL%this . elements . top . hide ( ) ;%NWL%this . elements . item . hide ( ) ;%NWL%this . _createPaneName ( ) ;%NWL%this . _createPaneStats ( ) ;%NWL%9
group . append ( $ ( " <a class= ' btn ' href= ' # ' data - for= ' cancel ' >Cancel< / a> " ) ) ;%NWL%controls . append ( group ) ;%NWL%titlebar . append ( $ ( " <div class= ' item ' > " ) . append ( icon . addClass ( " item - icon - box pull - left " ) ) ) ;%NWL%this . elements . top . after ( titlebar ) ;%NWL%this . elements . item . after ( editor ) ;%NWL%this . elements . bottom . append ( controls ) ;%NWL%this . elements . top . hide ( ) ;%NWL%this . elements . item . hide ( ) ;%NWL%this . _createPaneName ( ) ;%NWL%this . _createPaneTypes ( ) ;%NWL%this . _createPaneAttrs ( ) ;%NWL%8
controls . append ( group ) ;%NWL%titlebar . append ( $ ( " <div class= ' item ' > " ) . append ( icon . addClass ( " item - icon - box pull - left " ) ) ) ;%NWL%this . elements . top . after ( titlebar ) ;%NWL%this . elements . item . after ( editor ) ;%NWL%this . elements . bottom . append ( controls ) ;%NWL%this . elements . top . hide ( ) ;%NWL%this . elements . item . hide ( ) ;%NWL%this . _createPaneName ( ) ;%NWL%this . _createPaneTypes ( ) ;%NWL%this . _createPaneStats ( ) ;%NWL%this . _createPaneSockets ( ) ;%NWL%7
console . log ( " _createPaneName " ) ;%NWL%var item = this . options . item ,%NWL%titlebar = this . elements . titlebar ,%NWL%wrapper = $ ( " <p> " ) ,%NWL%collapse = $ ( " <i data - for= ' collapse ' class= ' icon - collapse pull - left ' >< / i> " ) ,%NWL%input = $ ( " <input type= ' text ' data - for= ' name ' > " ) ;%NWL%input . val ( item . name ) ;%NWL%titlebar . append ( wrapper . append ( collapse , input ) ) ;%NWL%} ,%NWL%_createPaneTypes: function ( )  {%NWL%var item = this . options . item ,%NWL%1
_ . each ( types , function ( display , key )  {%NWL%var li = $ ( " <option> " ) ;%NWL%li . attr ( " value " , key ) ;%NWL%li . html ( display ) ;%NWL%if ( item . type === key )  {%NWL%li . attr ( " selected " ,  " selected " ) ;%NWL%}%NWL%type . append ( li ) ;%NWL%} , this ) ;%NWL%_ . each ( qualities , function ( display , key )  {%NWL%li . attr ( " value " , key ) ;%NWL%2
var li = $ ( " <option> " ) ;%NWL%li . attr ( " value " , key ) ;%NWL%li . html ( display ) ;%NWL%if ( item . type === key )  {%NWL%li . attr ( " selected " ,  " selected " ) ;%NWL%}%NWL%type . append ( li ) ;%NWL%} , this ) ;%NWL%_ . each ( qualities , function ( display , key )  {%NWL%var li = $ ( " <option> " ) ;%NWL%li . html ( display ) ;%NWL%2
li . html ( display ) ;%NWL%if ( item . type === key )  {%NWL%li . attr ( " selected " ,  " selected " ) ;%NWL%}%NWL%type . append ( li ) ;%NWL%} , this ) ;%NWL%_ . each ( qualities , function ( display , key )  {%NWL%var li = $ ( " <option> " ) ;%NWL%li . attr ( " value " , key ) ;%NWL%li . html ( display ) ;%NWL%li . attr ( " selected " ,  " selected " ) ;%NWL%2
this . elements . editor . remove ( ) ;%NWL%this . elements . controls . remove ( ) ;%NWL%this . elements . top . show ( ) ;%NWL%this . elements . item . show ( ) ;%NWL%this . elements . top . find ( " p " ) . show ( ) ;%NWL%} ,%NWL%_cancel: function ( )  {%NWL%this . _revert ( ) ;%NWL%if ( this . options . onCancel )  {%NWL%this . options . onCancel ( ) ;%NWL%this . destroy ( ) ;%NWL%7
this . elements . item . show ( ) ;%NWL%this . elements . top . find ( " p " ) . show ( ) ;%NWL%} ,%NWL%_cancel: function ( )  {%NWL%this . _revert ( ) ;%NWL%if ( this . options . onCancel )  {%NWL%this . options . onCancel ( ) ;%NWL%}%NWL%this . destroy ( ) ;%NWL%} ,%NWL%this . _removePane ( ) ;%NWL%4
this . elements . top . find ( " p " ) . show ( ) ;%NWL%} ,%NWL%_cancel: function ( )  {%NWL%this . _revert ( ) ;%NWL%if ( this . options . onCancel )  {%NWL%this . options . onCancel ( ) ;%NWL%}%NWL%this . destroy ( ) ;%NWL%} ,%NWL%_revertPane: function ( )  {%NWL%this . _createPane ( ) ;%NWL%3
this . destroy ( ) ;%NWL%} ,%NWL%_revertPane: function ( )  {%NWL%this . _removePane ( ) ;%NWL%this . _createPane ( ) ;%NWL%} ,%NWL%_revertItem: function ( )  {%NWL%this . options . item = _ . cloneDeep ( this . original ) ;%NWL%this . options . modified = { } ;%NWL%} ,%NWL%this . _revertItem ( ) ;%NWL%0
} ,%NWL%_revertPane: function ( )  {%NWL%this . _removePane ( ) ;%NWL%this . _createPane ( ) ;%NWL%} ,%NWL%_revertItem: function ( )  {%NWL%this . options . item = _ . cloneDeep ( this . original ) ;%NWL%this . options . modified = { } ;%NWL%} ,%NWL%_revert: function ( )  {%NWL%this . _revertPane ( ) ;%NWL%2
_revertPane: function ( )  {%NWL%this . _removePane ( ) ;%NWL%this . _createPane ( ) ;%NWL%} ,%NWL%_revertItem: function ( )  {%NWL%this . options . item = _ . cloneDeep ( this . original ) ;%NWL%this . options . modified = { } ;%NWL%} ,%NWL%_revert: function ( )  {%NWL%this . _revertItem ( ) ;%NWL%this . _update ( ) ;%NWL%1
this . options . item = _ . cloneDeep ( this . original ) ;%NWL%this . options . modified = { } ;%NWL%} ,%NWL%_revert: function ( )  {%NWL%this . _revertItem ( ) ;%NWL%this . _revertPane ( ) ;%NWL%this . _update ( ) ;%NWL%} ,%NWL%_save: function ( )  {%NWL%console . log ( " _save " ) ;%NWL%this . _removePane ( ) ;%NWL%4
this . _revertPane ( ) ;%NWL%this . _update ( ) ;%NWL%} ,%NWL%_save: function ( )  {%NWL%console . log ( " _save " ) ;%NWL%if ( $ . isEmptyObject ( this . options . modified ) )  {%NWL%this . _removePane ( ) ;%NWL%} else {%NWL%if ( this . options . authentic )  {%NWL%this . elements . saveModal . modal ( ) ;%NWL%this . _saveAction ( ) ;%NWL%0
} ) . done ( function ( data )  {%NWL%var json = $ . parseJSON ( data ) , 	 / / JSON Response%NWL%html = json . html , 	 / / HTML Render of the new Item%NWL%item = json . item;	 / / JSON Data of the new Item%NWL%$this . _removePane ( ) ;%NWL%if ( $this . options . onSave )  {%NWL%$this . options . onSave ( ) ;%NWL%}%NWL%$this . element . html ( $ ( html ) ) ;%NWL%$this . options . item = item;%NWL%$this . _reinit ( ) ;%NWL%4
var json = $ . parseJSON ( data ) , 	 / / JSON Response%NWL%html = json . html , 	 / / HTML Render of the new Item%NWL%item = json . item;	 / / JSON Data of the new Item%NWL%$this . _removePane ( ) ;%NWL%if ( $this . options . onSave )  {%NWL%$this . options . onSave ( ) ;%NWL%}%NWL%$this . element . html ( $ ( html ) ) ;%NWL%$this . options . item = item;%NWL%$this . options . modified = { } ;%NWL%$this . _addToggle ( ) ;%NWL%3
html = json . html , 	 / / HTML Render of the new Item%NWL%item = json . item;	 / / JSON Data of the new Item%NWL%$this . _removePane ( ) ;%NWL%if ( $this . options . onSave )  {%NWL%$this . options . onSave ( ) ;%NWL%}%NWL%$this . element . html ( $ ( html ) ) ;%NWL%$this . options . item = item;%NWL%$this . options . modified = { } ;%NWL%$this . _reinit ( ) ;%NWL%$this . _update ( ) ;%NWL%2
} ;%NWL%} ,%NWL%_reinit: function ( )  {%NWL%this . _assignElements ( ) ;%NWL%if ( !this . options . modified )  {%NWL%this . options . modified = { } ;%NWL%}%NWL%this . original = _ . cloneDeep ( this . options . item ) ;%NWL%} ,%NWL%_init: function ( )  {%NWL%this . _reinit ( ) ;%NWL%3
} ,%NWL%_reinit: function ( )  {%NWL%this . _assignElements ( ) ;%NWL%if ( !this . options . modified )  {%NWL%this . options . modified = { } ;%NWL%}%NWL%this . original = _ . cloneDeep ( this . options . item ) ;%NWL%} ,%NWL%_init: function ( )  {%NWL%console . log ( " _init " , this . options ) ;%NWL%this . _addToggle ( ) ;%NWL%2
_reinit: function ( )  {%NWL%this . _assignElements ( ) ;%NWL%if ( !this . options . modified )  {%NWL%this . options . modified = { } ;%NWL%}%NWL%this . original = _ . cloneDeep ( this . options . item ) ;%NWL%} ,%NWL%_init: function ( )  {%NWL%console . log ( " _init " , this . options ) ;%NWL%this . _reinit ( ) ;%NWL%this . _createSaveModal ( ) ;%NWL%1
this . _assignElements ( ) ;%NWL%if ( !this . options . modified )  {%NWL%this . options . modified = { } ;%NWL%}%NWL%this . original = _ . cloneDeep ( this . options . item ) ;%NWL%} ,%NWL%_init: function ( )  {%NWL%console . log ( " _init " , this . options ) ;%NWL%this . _reinit ( ) ;%NWL%this . _addToggle ( ) ;%NWL%this . _addBindings ( ) ;%NWL%0
this . options . modified = { } ;%NWL%}%NWL%this . original = _ . cloneDeep ( this . options . item ) ;%NWL%} ,%NWL%_init: function ( )  {%NWL%console . log ( " _init " , this . options ) ;%NWL%this . _reinit ( ) ;%NWL%this . _addToggle ( ) ;%NWL%this . _createSaveModal ( ) ;%NWL%this . _addBindings ( ) ;%NWL%this . _createPane ( ) ;%NWL%6
_init: function ( )  {%NWL%console . log ( " _init " , this . options ) ;%NWL%this . _reinit ( ) ;%NWL%this . _addToggle ( ) ;%NWL%this . _createSaveModal ( ) ;%NWL%this . _addBindings ( ) ;%NWL%if ( this . options . modding )  {%NWL%this . _createPane ( ) ;%NWL%}%NWL%} ,%NWL%this . _revert ( ) ;%NWL%2
console . log ( " _init " , this . options ) ;%NWL%this . _reinit ( ) ;%NWL%this . _addToggle ( ) ;%NWL%this . _createSaveModal ( ) ;%NWL%this . _addBindings ( ) ;%NWL%if ( this . options . modding )  {%NWL%this . _createPane ( ) ;%NWL%}%NWL%} ,%NWL%_destroy: function ( )  {%NWL%this . _removePane ( ) ;%NWL%1
} ;%NWL%return decorate;%NWL%}%NWL%%NWL%function sourceDecorator ( options )  {%NWL%var shortcutStylePatterns = [ ] , fallthroughStylePatterns = [ ] ;%NWL%if ( options [ ' tripleQuotedStrings ' ] )  {%NWL%shortcutStylePatterns . push (%NWL%[ PR_STRING ,  / ^ ( ?:\ ' \ ' \ ' ( ?: [ ^\ ' \\ ] |\\ [ \s\S ] |\ ' { 1 , 2 } ( ?= [ ^\ ' ] ) ) * ( ?:\ ' \ ' \ ' |$ ) |\ " \ " \ " ( ?: [ ^\ " \\ ] |\\ [ \s\S ] |\ " { 1 , 2 } ( ?= [ ^\ " ] ) ) * ( ?:\ " \ " \ " |$ ) |\ ' ( ?: [ ^\\\ ' ] |\\ [ \s\S ] ) * ( ?:\ ' |$ ) |\ " ( ?: [ ^\\\ " ] |\\ [ \s\S ] ) * ( ?:\ " |$ ) ) / ,%NWL%null ,  ' \ ' " ' ] ) ;%NWL%shortcutStylePatterns . push (%NWL%7
function sourceDecorator ( options )  {%NWL%var shortcutStylePatterns = [ ] , fallthroughStylePatterns = [ ] ;%NWL%if ( options [ ' tripleQuotedStrings ' ] )  {%NWL%shortcutStylePatterns . push (%NWL%[ PR_STRING ,  / ^ ( ?:\ ' \ ' \ ' ( ?: [ ^\ ' \\ ] |\\ [ \s\S ] |\ ' { 1 , 2 } ( ?= [ ^\ ' ] ) ) * ( ?:\ ' \ ' \ ' |$ ) |\ " \ " \ " ( ?: [ ^\ " \\ ] |\\ [ \s\S ] |\ " { 1 , 2 } ( ?= [ ^\ " ] ) ) * ( ?:\ " \ " \ " |$ ) |\ ' ( ?: [ ^\\\ ' ] |\\ [ \s\S ] ) * ( ?:\ ' |$ ) |\ " ( ?: [ ^\\\ " ] |\\ [ \s\S ] ) * ( ?:\ " |$ ) ) / ,%NWL%null ,  ' \ ' " ' ] ) ;%NWL%} else if ( options [ ' multiLineStrings ' ] )  {%NWL%shortcutStylePatterns . push (%NWL%[ PR_STRING ,  / ^ ( ?:\ ' ( ?: [ ^\\\ ' ] |\\ [ \s\S ] ) * ( ?:\ ' |$ ) |\ " ( ?: [ ^\\\ " ] |\\ [ \s\S ] ) * ( ?:\ " |$ ) |\` ( ?: [ ^\\\` ] |\\ [ \s\S ] ) * ( ?:\`|$ ) ) / ,%NWL%null ,  ' \ ' " ` ' ] ) ;%NWL%shortcutStylePatterns . push (%NWL%3
if ( options [ ' verbatimStrings ' ] )  {%NWL%fallthroughStylePatterns . push (%NWL%[ PR_STRING ,  / ^@\ " ( ?: [ ^\ " ] |\ " \ " ) * ( ?:\ " |$ ) / , null ] ) ;%NWL%}%NWL%var hc = options [ ' hashComments ' ] ;%NWL%if ( hc )  {%NWL%if ( options [ ' cStyleComments ' ] )  {%NWL%if ( hc > 1 )  {  / / multiline hash comments%NWL%shortcutStylePatterns . push (%NWL%[ PR_COMMENT ,  / ^# ( ?:## ( ?: [ ^# ] |# ( ?!## ) ) * ( ?:###|$ ) | . * ) / , null ,  ' # ' ] ) ;%NWL%shortcutStylePatterns . push (%NWL%8
}%NWL%fallthroughStylePatterns . push (%NWL%[ PR_STRING ,%NWL%/ ^< ( ?: ( ?: ( ?:\ . \ . \ / ) * |\ / ? ) ( ?: [ \w - ] + ( ?:\ / [ \w - ] + ) + ) ? [ \w - ] + \ . h| [ a - z ] \w * ) > / ,%NWL%null ] ) ;%NWL%} else {%NWL%shortcutStylePatterns . push ( [ PR_COMMENT ,  / ^# [ ^\r\n ] * / , null ,  ' # ' ] ) ;%NWL%}%NWL%}%NWL%if ( options [ ' cStyleComments ' ] )  {%NWL%fallthroughStylePatterns . push (%NWL%1
this . _xAccessor = " x " ;%NWL%this . _yAccessor = " y " ;%NWL%this . colorVar = " fill " ;%NWL%this . isNewStylePlot = false;%NWL%this . hasDeployed = false;%NWL%if ( datasets instanceof Array )%NWL%datasets = {  " " : datasets } ;%NWL%datasets = d3 . entries ( datasets ) ;%NWL%this . datasets = datasets . map ( function ( kv )  { return makeDataset ( kv . key , kv . value ) ; } ) ;%NWL%}%NWL%this . _xType = this . setType ( t , true ) ;%NWL%8
this . hasDeployed = false;%NWL%if ( datasets instanceof Array )%NWL%datasets = {  " " : datasets } ;%NWL%datasets = d3 . entries ( datasets ) ;%NWL%this . datasets = datasets . map ( function ( kv )  { return makeDataset ( kv . key , kv . value ) ; } ) ;%NWL%}%NWL%Chart . prototype . xType = function ( t )  {%NWL%this . _xType = this . setType ( t , true ) ;%NWL%return this;%NWL%} ;%NWL%this . _yType = this . setType ( t , false ) ;%NWL%4
function LineChart ( )  {%NWL%_super . apply ( this , arguments ) ;%NWL%this . plotType = " Line " ;%NWL%this . colorVar = " stroke " ;%NWL%}%NWL%return LineChart;%NWL%} ) ( Chart ) ;%NWL%Chartographer . LineChart = LineChart;%NWL%var ScatterChart = ( function ( _super )  {%NWL%__extends ( ScatterChart , _super ) ;%NWL%_super . apply ( this , arguments ) ;%NWL%1
__extends ( ScatterChart , _super ) ;%NWL%function ScatterChart ( )  {%NWL%_super . apply ( this , arguments ) ;%NWL%this . plotType = " Scatter " ;%NWL%}%NWL%return ScatterChart;%NWL%} ) ( Chart ) ;%NWL%Chartographer . ScatterChart = ScatterChart;%NWL%var BarChart = ( function ( _super )  {%NWL%__extends ( BarChart , _super ) ;%NWL%_super . apply ( this , arguments ) ;%NWL%2
function BarChart ( )  {%NWL%_super . apply ( this , arguments ) ;%NWL%this . plotType = " ClusteredBar " ;%NWL%this . isNewStylePlot = true;%NWL%}%NWL%return BarChart;%NWL%} ) ( Chart ) ;%NWL%Chartographer . BarChart = BarChart;%NWL%var StackedBarChart = ( function ( _super )  {%NWL%__extends ( StackedBarChart , _super ) ;%NWL%_super . apply ( this , arguments ) ;%NWL%1
var sigmaGrapher = function ( )  {%NWL%var grapher = {%NWL%colors: [ ' #d73027 ' ,  ' #f46d43 ' ,  ' #fdae61 ' ,  ' #fee090 ' ,  ' #e0f3f8 ' ,  ' #abd9e9 ' ,  ' #74add1 ' ,  ' #4575b4 ' ,  ' #FFFFFF ' ] ,%NWL%initialize: function ( )  {%NWL%this . brush = d3 . svg . brush ( ) . on ( ' brushend ' , this . onBrushEnd . bind ( this ) ) ;%NWL%this . $el = $ ( ' div . network - container ' ) ;%NWL%this . $header = $ ( ' header ' ) ;%NWL%this . $brush = this . $svg . append ( ' g ' ) . attr ( ' class ' ,  ' brush ' ) ;%NWL%4
l . prevColor = l . prevColor !== undefined ? l . prevColor : l . color;%NWL%l . color = this . colors [ 8 ] ;%NWL%} else l . color = l . prevColor !== undefined ? l . prevColor : l . color;%NWL%} . bind ( this ) ) ;%NWL%this . s . refresh ( ) ;%NWL%} ,%NWL%updateColorings: function ( )  {  / / random colors%NWL%_ . each ( this . s . graph . nodes ( ) , function ( n )  {%NWL%n . color = this . colors [ Math . floor ( Math . random ( )  * 8 ) ] ;%NWL%} . bind ( this ) ) ;%NWL%l . color = this . colors [ Math . floor ( Math . random ( )  * 8 ) ] ;%NWL%0
} else l . color = l . prevColor !== undefined ? l . prevColor : l . color;%NWL%} . bind ( this ) ) ;%NWL%this . s . refresh ( ) ;%NWL%} ,%NWL%updateColorings: function ( )  {  / / random colors%NWL%_ . each ( this . s . graph . nodes ( ) , function ( n )  {%NWL%n . color = this . colors [ Math . floor ( Math . random ( )  * 8 ) ] ;%NWL%} . bind ( this ) ) ;%NWL%_ . each ( this . s . graph . edges ( ) , function ( l )  {%NWL%l . color = this . colors [ Math . floor ( Math . random ( )  * 8 ) ] ;%NWL%this . s . refresh ( ) ;%NWL%2
var svgGrapher = function ( )  {%NWL%var grapher = {%NWL%colors: [ ' #d73027 ' ,  ' #f46d43 ' ,  ' #fdae61 ' ,  ' #fee090 ' ,  ' #e0f3f8 ' ,  ' #abd9e9 ' ,  ' #74add1 ' ,  ' #4575b4 ' ] ,%NWL%initialize: function ( )  {%NWL%this . brush = d3 . svg . brush ( ) . on ( ' brushend ' , this . onBrushEnd . bind ( this ) ) ;%NWL%this . $el = $ ( ' div . network - container ' ) ;%NWL%4
var svgGrapher = function ( )  {%NWL%var grapher = {%NWL%colors: [ ' #d73027 ' ,  ' #f46d43 ' ,  ' #fdae61 ' ,  ' #fee090 ' ,  ' #e0f3f8 ' ,  ' #abd9e9 ' ,  ' #74add1 ' ,  ' #4575b4 ' ] ,%NWL%initialize: function ( )  {%NWL%this . brush = d3 . svg . brush ( ) . on ( ' brushend ' , this . onBrushEnd . bind ( this ) ) ;%NWL%this . zoom = d3 . behavior . zoom ( ) ;%NWL%this . $el = $ ( ' div . network - container ' ) ;%NWL%this . $header = $ ( ' header ' ) ;%NWL%this . $network = this . $svg . append ( ' g ' ) ;%NWL%4
var svgGrapher = function ( )  {%NWL%var grapher = {%NWL%colors: [ ' #d73027 ' ,  ' #f46d43 ' ,  ' #fdae61 ' ,  ' #fee090 ' ,  ' #e0f3f8 ' ,  ' #abd9e9 ' ,  ' #74add1 ' ,  ' #4575b4 ' ] ,%NWL%initialize: function ( )  {%NWL%this . brush = d3 . svg . brush ( ) . on ( ' brushend ' , this . onBrushEnd . bind ( this ) ) ;%NWL%this . zoom = d3 . behavior . zoom ( ) ;%NWL%this . $el = $ ( ' div . network - container ' ) ;%NWL%this . $header = $ ( ' header ' ) ;%NWL%this . $svg = d3 . select ( this . $el . get ( 0 ) ) . append ( ' svg ' ) . attr ( { width: ' 100% ' , height: ' 100% ' } ) ;%NWL%this . $brush = this . $network . append ( ' g ' ) . attr ( ' class ' ,  ' brush ' ) ;%NWL%4
cx: function ( d )  { return d . x; } ,%NWL%cy: function ( d )  { return d . y; }%NWL%} ) ;%NWL%this . data = data;%NWL%this . updateTransform ( ) ;%NWL%this . updateColorings ( ) ;%NWL%return this;%NWL%} ,%NWL%onZoom: function ( )  {%NWL%if ( this . transform . scale !== d3 . event . scale || d3 . event . sourceEvent . altKey || d3 . event . sourceEvent . ctrlKey )  {%NWL%this . updateTransform ( ) ;%NWL%4
this . updateTransform ( ) ;%NWL%} else this . zoom . translate ( this . transform . translate ) ;%NWL%} ,%NWL%onBrushEnd: function ( )  {  / / Select the brushed nodes then remove the brush%NWL%var r = this . brush . extent ( ) ,%NWL%selectedNodes = { } ;%NWL%this . $nodes . each ( function ( d )  {%NWL%if ( r [ 0 ] [ 0 ] <= d . x && d . x < r [ 1 ] [ 0 ] && r [ 0 ] [ 1 ] <= d . y && d . y < r [ 1 ] [ 1 ] ) selectedNodes [ d . id ] = true;%NWL%} ) ;%NWL%this . selectedNodes = selectedNodes;%NWL%this . updateSelectedNodes ( ) ;%NWL%0
var webglGrapher = function ( )  {%NWL%var grapher = {%NWL%colors: [ ' #d73027 ' ,  ' #f46d43 ' ,  ' #fdae61 ' ,  ' #fee090 ' ,  ' #e0f3f8 ' ,  ' #abd9e9 ' ,  ' #74add1 ' ,  ' #4575b4 ' ,  ' #FFFFFF ' ] ,%NWL%previous: { } ,%NWL%initialize: function ( )  {%NWL%this . brush = d3 . svg . brush ( ) . on ( ' brushend ' , this . onBrushEnd . bind ( this ) ) ;%NWL%this . $el = $ ( ' div . network - container ' ) ;%NWL%5
var webglGrapher = function ( )  {%NWL%var grapher = {%NWL%colors: [ ' #d73027 ' ,  ' #f46d43 ' ,  ' #fdae61 ' ,  ' #fee090 ' ,  ' #e0f3f8 ' ,  ' #abd9e9 ' ,  ' #74add1 ' ,  ' #4575b4 ' ,  ' #FFFFFF ' ] ,%NWL%previous: { } ,%NWL%initialize: function ( )  {%NWL%this . brush = d3 . svg . brush ( ) . on ( ' brushend ' , this . onBrushEnd . bind ( this ) ) ;%NWL%this . zoom = d3 . behavior . zoom ( ) . on ( ' zoom ' , this . onZoom . bind ( this ) ) ;%NWL%this . $el = $ ( ' div . network - container ' ) ;%NWL%this . $header = $ ( ' header ' ) ;%NWL%this . $brush = this . $svg . append ( ' g ' ) . attr ( ' class ' ,  ' brush ' ) ;%NWL%5
var attrs = { } ;%NWL%var styles = { } ;%NWL%var _tooltip = function _tooltip ( selection )  {%NWL%selection%NWL%. on ( ' mouseover . tooltip ' , function ( d , i )  {%NWL%_tooltip . show ( d , i ) ;%NWL%} )%NWL%. on ( ' mousedown . tooltip ' , function ( )  {%NWL%_tooltip . show ( null )%NWL%} )%NWL%_tooltip . show ( null )%NWL%8
} )%NWL%. on ( ' mousedown . tooltip ' , function ( )  {%NWL%_tooltip . show ( null )%NWL%} )%NWL%. on ( ' mouseup . tooltip ' , function ( )  {%NWL%_tooltip . show ( null )%NWL%} )%NWL%. on ( ' mousemove . tooltip ' , function ( )  {%NWL%_tooltip . _update ( ) ;%NWL%} )%NWL%_tooltip . show ( null )%NWL%2
_tooltip . show ( null )%NWL%} )%NWL%. on ( ' mousemove . tooltip ' , function ( )  {%NWL%_tooltip . _update ( ) ;%NWL%} )%NWL%. on ( ' mouseout . tooltip ' , function ( )  {%NWL%_tooltip . show ( null )%NWL%} ) ;%NWL%} ;%NWL%_tooltip . _build = function _build ( )  {%NWL%_tooltip . fadeOut ( ) ;%NWL%3
var progress = tipSel . style ( ' opacity ' )  / 1 . 0;%NWL%var duration = progress * _fadeOutDuration;%NWL%tipSel . transition ( ) . delay ( 50 ) . duration ( duration ) . style ( ' opacity ' , 0 ) ;%NWL%} ;%NWL%_tooltip . activate = function ( ) {%NWL%activated = true;%NWL%_tooltip . fadeIn ( ) ;%NWL%} ;%NWL%_tooltip . deactivate = function ( ) {%NWL%lastSourceDataShown = null;%NWL%_tooltip . fadeOut ( ) ;%NWL%6
_tooltip . fadeOut ( ) ;%NWL%} ;%NWL%_tooltip . activateAfter = function ( ) {%NWL%baseSel . interrupt ( ) . transition ( ) ;%NWL%if ( !activated )  {%NWL%baseSel . transition ( )%NWL%. delay ( _holdDuration )%NWL%. duration ( 0 )%NWL%. on ( ' start ' , _tooltip . activate )%NWL%. style ( ' visibility ' , ' visible ' ) ;%NWL%_tooltip . fadeIn ( ) ;%NWL%0
} ;%NWL%_tooltip . show = function ( sourceData , sourceKey ) {%NWL%_sourceData = sourceData;%NWL%_sourceKey = sourceKey;%NWL%if ( _sourceData !== lastSourceDataShown || _formatFunc !== lastFormatFuncShown ) {%NWL%lastFormatFuncShown = _formatFunc;%NWL%lastSourceDataShown = _sourceData;%NWL%tipDisplayData = ( _formatFunc && _sourceData ) ? _formatFunc ( _sourceData , _sourceKey ) : _sourceData;%NWL%_tooltip . options ( tipDisplayData ) ;%NWL%_tooltip . _build ( ) ;%NWL%_tooltip . _update ( ) ;%NWL%9
var mixinDocs = ( function ( )  {%NWL%' use strict ' ;%NWL%var esprima = require ( ' esprima ' ) ,%NWL%escodegen = require ( ' escodegen ' ) ,%NWL%var DOC = md . DOC = ' __doc__ ' ;%NWL%2
missing: [ ]%NWL%} ;%NWL%if ( !chart || chart . render === undefined ) return;%NWL%Object . keys ( chart ) . filter ( function ( m )  {%NWL%return typeof chart [ m ] == ' function ' &&%NWL%( m [ 0 ] != ' _ ' || chart [ m ] [ mixinDocs . DOC ] ) ;%NWL%} ) . forEach ( function ( m )  {%NWL%var method = m [ 0 ] == ' _ ' ? m . substr ( 1 ) : m;%NWL%if ( chart [ m ] [ mixinDocs . DOC ] )%NWL%model . covered . push ( method ) ;%NWL%model . missing . push ( method ) ;%NWL%9
var op = ops [ i ] ;%NWL%var firstDiff = firstLines . slice ( op [ 1 ] , op [ 2 ] ) . join ( " \n " ) ;%NWL%var secondDiff = secondLines . slice ( op [ 3 ] , op [ 4 ] ) . join ( " \n " ) ;%NWL%if ( op [ 0 ] === ' replace ' )  {%NWL%if ( !onlyDiffersByDelta ( firstDiff , secondDiff , 0 . 01 ) )  {%NWL%diffs . push ( " Replacement: " ) ;%NWL%diffs . push ( firstDiff . red ) ;%NWL%diffs . push ( secondDiff . green ) ;%NWL%}%NWL%} else if ( op [ 0 ] === ' insert ' )  {%NWL%diffs . push ( secondDiff . green ) ;%NWL%7
if ( op [ 0 ] === ' replace ' )  {%NWL%if ( !onlyDiffersByDelta ( firstDiff , secondDiff , 0 . 01 ) )  {%NWL%diffs . push ( " Replacement: " ) ;%NWL%diffs . push ( firstDiff . red ) ;%NWL%diffs . push ( secondDiff . green ) ;%NWL%}%NWL%} else if ( op [ 0 ] === ' insert ' )  {%NWL%diffs . push ( " Insertion: " ) ;%NWL%diffs . push ( secondDiff . green ) ;%NWL%} else if ( op [ 0 ] === ' delete ' )  {%NWL%diffs . push ( firstDiff . red ) ;%NWL%3
chart . renderlet ( secondRenderlet ) ;%NWL%chart . on ( ' renderlet . third ' , thirdRenderlet ) ;%NWL%chart . on ( ' pretransition . pret ' , pretransition ) ;%NWL%} ) ;%NWL%it ( ' should not execute a renderlet until after the render transitions ' , function ( )  {%NWL%chart . render ( ) ;%NWL%expect ( firstRenderlet ) . not . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%5
expect ( firstRenderlet ) . not . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should not execute a renderlet until after the redraw transitions ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%expect ( firstRenderlet ) . not . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . render ( ) ;%NWL%5
chart . redraw ( ) ;%NWL%expect ( firstRenderlet ) . not . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should execute pretransition event before the render transitions ' , function ( )  {%NWL%chart . render ( ) ;%NWL%expect ( pretransition ) . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%0
it ( ' should execute pretransition event before the render transitions ' , function ( )  {%NWL%chart . render ( ) ;%NWL%expect ( pretransition ) . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%} ) ;%NWL%it ( ' should execute pretransition event before the redraw transitions ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%expect ( pretransition ) . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%} ) ;%NWL%chart . render ( ) ;%NWL%1
chart . redraw ( ) ;%NWL%expect ( pretransition ) . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%} ) ;%NWL%it ( ' should execute each renderlet after a render ' , function ( )  {%NWL%chart . render ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%expect ( secondRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%0
flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%expect ( secondRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should execute each renderlet after a redraw ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%expect ( secondRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . render ( ) ;%NWL%5
chart . redraw ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( firstRenderlet ) . toHaveBeenCalled ( ) ;%NWL%expect ( secondRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should execute a named renderlet after a render ' , function ( )  {%NWL%chart . render ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( thirdRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%0
chart . render ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( thirdRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should execute a named renderlet after a redraw ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( thirdRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should remove a named renderlet expect no call after a redraw ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%0
flushAllD3Transitions ( ) ;%NWL%expect ( thirdRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should remove a named renderlet expect no call after a redraw ' , function ( )  {%NWL%chart . on ( ' renderlet . third ' ) ;%NWL%chart . redraw ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( secondRenderlet ) . toHaveBeenCalled ( ) ;%NWL%expect ( thirdRenderlet ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . on ( ' renderlet . third ' ) ;%NWL%4
expect ( thirdRenderlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should remove a named renderlet expect no call after a redraw ' , function ( )  {%NWL%chart . on ( ' renderlet . third ' ) ;%NWL%chart . redraw ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( secondRenderlet ) . toHaveBeenCalled ( ) ;%NWL%expect ( thirdRenderlet ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' should remove a named renderlet and expect no call after a redraw ' , function ( )  {%NWL%chart . render ( ) ;%NWL%4
preRenderSpy = jasmine . createSpy ( ) . and . callFake ( expectedCallbackSignature ) ;%NWL%postRenderSpy = jasmine . createSpy ( ) . and . callFake ( expectedCallbackSignature ) ;%NWL%chart . on ( ' preRender ' , preRenderSpy ) ;%NWL%chart . on ( ' postRender ' , postRenderSpy ) ;%NWL%} ) ;%NWL%it ( ' should execute the preRender callback ' , function ( )  {%NWL%chart . render ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%expect ( preRenderSpy ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . render ( ) ;%NWL%6
} ;%NWL%filterSpy = jasmine . createSpy ( ) . and . callFake ( expectedCallbackSignature ) ;%NWL%filterSpy2 = jasmine . createSpy ( ) . and . callFake ( expectedCallbackSignature ) ;%NWL%chart . on ( ' filtered . one ' , filterSpy ) ;%NWL%chart . on ( ' filtered . two ' , filterSpy2 ) ;%NWL%} ) ;%NWL%it ( ' should execute first callback after setting through #filter ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%expect ( filterSpy ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%7
preRedrawSpy = jasmine . createSpy ( ) . and . callFake ( expectedCallbackSignature ) ;%NWL%postRedrawSpy = jasmine . createSpy ( ) . and . callFake ( expectedCallbackSignature ) ;%NWL%chart . on ( ' preRedraw ' , preRedrawSpy ) ;%NWL%chart . on ( ' postRedraw ' , postRedrawSpy ) ;%NWL%} ) ;%NWL%it ( ' should execute the preRedraw callback before transitions ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%expect ( preRedrawSpy ) . toHaveBeenCalled ( ) ;%NWL%flushAllD3Transitions ( ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%6
chart . hasFilterHandler ( hasFilterHandler ) ;%NWL%chart . removeFilterHandler ( removeFilterHandler ) ;%NWL%chart . resetFilterHandler ( resetFilterHandler ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' with the default hasFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%6
chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( ' with a truthy hasFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . hasFilterHandler ( function ( )  { return true; } ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%0
chart . hasFilterHandler ( function ( )  { return true; } ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' with a falsy hasFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . hasFilterHandler ( function ( )  { return false; } ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%5
expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( ' with the default addFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%it ( ' with a noop addFilterHandler ' , function ( )  {%NWL%chart . addFilterHandler ( function ( filters , filter )  {%NWL%return filters;%NWL%chart . filter ( filter ) ;%NWL%3
} ) ;%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%it ( ' with a static addFilterHandler ' , function ( )  {%NWL%chart . addFilterHandler ( function ( filters , filter )  {%NWL%filters . push ( notFilter ) ;%NWL%return filters;%NWL%chart . filter ( filter ) ;%NWL%1
it ( ' with a static addFilterHandler ' , function ( )  {%NWL%chart . addFilterHandler ( function ( filters , filter )  {%NWL%filters . push ( notFilter ) ;%NWL%return filters;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%5
return filters;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%it ( ' with the default removeFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . filter ( filter ) ;%NWL%2
expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%it ( ' with the default removeFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%chart . filter ( notFilter ) ;%NWL%5
expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%chart . filter ( notFilter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%1
chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%chart . filter ( notFilter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%it ( ' with a noop removeFilterHandler ' , function ( )  {%NWL%chart . filter ( notFilter ) ;%NWL%4
expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%it ( ' with a noop removeFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . removeFilterHandler ( function ( filters , filter )  {%NWL%return filters;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%5
it ( ' with a noop removeFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . removeFilterHandler ( function ( filters , filter )  {%NWL%return filters;%NWL%} ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%chart . filter ( notFilter ) ;%NWL%2
expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%chart . filter ( notFilter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%1
chart . filter ( filter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%chart . filter ( notFilter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%it ( ' with a shift removeFilterHandler ' , function ( )  {%NWL%chart . filter ( notFilter ) ;%NWL%4
} ) ;%NWL%it ( ' with a shift removeFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . removeFilterHandler ( function ( filters , filter )  {%NWL%if ( filters . length > 0 )  {%NWL%filters . shift ( ) ;%NWL%}%NWL%return filters;%NWL%} ) ;%NWL%chart . filter ( notFilter ) ;%NWL%3
chart . removeFilterHandler ( function ( filters , filter )  {%NWL%if ( filters . length > 0 )  {%NWL%filters . shift ( ) ;%NWL%}%NWL%return filters;%NWL%} ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%chart . filter ( notFilter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%chart . filter ( notFilter ) ;%NWL%7
chart . filter ( notFilter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%chart . filter ( notFilter ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%it ( ' with the default resetFilterHandler ' , function ( )  {%NWL%chart . filter ( notFilter ) ;%NWL%0
expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%it ( ' with the default resetFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . filter ( null ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%3
} ) ;%NWL%it ( ' with the default resetFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . filter ( null ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%it ( ' with a noop resetFilterHandler ' , function ( )  {%NWL%chart . filter ( notFilter ) ;%NWL%3
chart . filter ( null ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 0 ) ;%NWL%} ) ;%NWL%it ( ' with a noop resetFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . resetFilterHandler ( function ( filters )  {%NWL%return filters;%NWL%chart . filter ( null ) ;%NWL%0
chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . resetFilterHandler ( function ( filters )  {%NWL%return filters;%NWL%} ) ;%NWL%chart . filter ( null ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%chart . filter ( filter ) ;%NWL%0
chart . filter ( notFilter ) ;%NWL%chart . resetFilterHandler ( function ( filters )  {%NWL%return filters;%NWL%} ) ;%NWL%chart . filter ( null ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%it ( ' with a shift resetFilterHandler ' , function ( )  {%NWL%chart . filter ( notFilter ) ;%NWL%0
it ( ' with a shift resetFilterHandler ' , function ( )  {%NWL%chart . filter ( filter ) ;%NWL%chart . filter ( notFilter ) ;%NWL%chart . resetFilterHandler ( function ( filters )  {%NWL%filters . shift ( ) ;%NWL%return filters;%NWL%} ) ;%NWL%chart . filter ( null ) ;%NWL%expect ( chart . hasFilter ( filter ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . hasFilter ( notFilter ) ) . toBeTruthy ( ) ;%NWL%chart . filter ( null ) ;%NWL%7
} ) ;%NWL%it ( ' handles multi - selection highlight ' , function ( )  {%NWL%chart . filter ( ' T ' ) ;%NWL%chart . redraw ( ) ;%NWL%chart . selectAll ( ' g . node ' ) . each ( function ( d , i )  {%NWL%expect ( d3 . select ( this ) . attr ( ' class ' ) ) . toBe ( ' node selected ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' update ' , function ( )  {%NWL%chart . render ( ) ;%NWL%3
chart . filter ( ' T ' ) ;%NWL%chart . redraw ( ) ;%NWL%chart . selectAll ( ' g . node ' ) . each ( function ( d , i )  {%NWL%expect ( d3 . select ( this ) . attr ( ' class ' ) ) . toBe ( ' node selected ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' update ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%chart . redraw ( ) ;%NWL%1
expect ( d3 . select ( chart . selectAll ( ' g . node text ' ) [ 0 ] [ 3 ] ) . text ( ) ) . toEqual ( ' Ontario ' ) ;%NWL%} ) ;%NWL%it ( ' should generate the label only once ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%expect ( chart . selectAll ( ' g . node text ' ) [ 0 ] . length ) . toEqual ( 6 ) ;%NWL%} ) ;%NWL%it ( ' generate the correct titles ' , function ( )  {%NWL%expect ( d3 . select ( chart . selectAll ( ' g . node title ' ) [ 0 ] [ 0 ] ) . text ( ) ) . toEqual ( ' Title: California ' ) ;%NWL%expect ( d3 . select ( chart . selectAll ( ' g . node title ' ) [ 0 ] [ 3 ] ) . text ( ) ) . toEqual ( ' Title: Ontario ' ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%3
it ( ' should only generate titles once ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%expect ( chart . selectAll ( ' g . node title ' ) [ 0 ] . length ) . toEqual ( 6 ) ;%NWL%} ) ;%NWL%it ( ' should fill circles with the specified colors ' , function ( )  {%NWL%expect ( d3 . select ( chart . selectAll ( ' circle . bubble ' ) [ 0 ] [ 0 ] ) . attr ( ' fill ' ) ) . toEqual ( ' blue ' ) ;%NWL%expect ( d3 . select ( chart . selectAll ( ' circle . bubble ' ) [ 0 ] [ 3 ] ) . attr ( ' fill ' ) ) . toEqual ( ' blue ' ) ;%NWL%} ) ;%NWL%it ( ' should highlight the filtered bubbles ' , function ( )  {%NWL%chart . filter ( ' Colorado ' ) ;%NWL%chart . redraw ( ) ;%NWL%1
}%NWL%else if ( data_range [ 1 ] > 0 && data_range [ 0 ] >= 0 )  {%NWL%var color_range = vars . color . heatmap%NWL%data_range = buckets ( data_range , color_range . length )%NWL%}%NWL%else {%NWL%var color_range = vars . color . range . slice ( 0 )%NWL%if ( data_range [ 0 ] < 0 )  {%NWL%color_range . pop ( )%NWL%}%NWL%color_range . shift ( )%NWL%8
. width ( 500 )%NWL%. height ( 150 )%NWL%. x ( d3 . time . scale . utc ( ) . domain ( [ makeDate ( 2012 , 4 , 20 ) , makeDate ( 2012 , 7 , 15 ) ] ) )%NWL%. transitionDuration ( 0 )%NWL%. xUnits ( d3 . time . days . utc )%NWL%. shareColors ( true )%NWL%. compose ( [%NWL%dc . barChart ( chart )%NWL%. centerBar ( true )%NWL%. group ( dateValueSumGroup ,  ' Date Value Group Bar ' )%NWL%dc . lineChart ( chart )%NWL%7
. shareColors ( true )%NWL%. compose ( [%NWL%dc . barChart ( chart )%NWL%. centerBar ( true )%NWL%. group ( dateValueSumGroup ,  ' Date Value Group Bar ' )%NWL%. gap ( 1 ) ,%NWL%dc . lineChart ( chart )%NWL%. group ( dateIdSumGroup ,  ' Date ID Group ' )%NWL%. stack ( dateValueSumGroup ,  ' Date Value Group Line 1 ' )%NWL%. stack ( dateValueSumGroup ,  ' Date Value Group Line 2 ' )%NWL%dc . lineChart ( chart )%NWL%2
chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should trigger the sub - chart renderlet ' , function ( )  {%NWL%expect ( d3 . select ( chart . selectAll ( ' rect ' ) [ 0 ] [ 0 ] ) . attr ( ' width ' ) ) . toBe ( ' 10 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' when two subcharts share the same group ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%var dimension = data . dimension ( function ( d )  {%NWL%return d . status;%NWL%var group = dimension . group ( ) . reduce (%NWL%8
} ) ;%NWL%describe ( ' horizontal gridlines ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . yAxis ( ) . ticks ( 3 ) ;%NWL%chart . rightYAxis ( ) . ticks ( 6 ) ;%NWL%chart . renderHorizontalGridLines ( true ) . render ( ) ;%NWL%} ) ;%NWL%it ( ' should draw left horizontal gridlines by default ' , function ( )  {%NWL%expect ( chart . selectAll ( ' . grid - line . horizontal line ' ) . size ( ) ) . toBe ( 3 ) ;%NWL%} ) ;%NWL%chart . useRightAxisGridLines ( true ) . render ( ) ;%NWL%5
otherDimension = data . dimension ( function ( d )  { return [ + d . value ,  + d . nvalue ] ; } ) ;%NWL%chart . brush ( ) . extent ( [ 22 , 35 ] ) ;%NWL%chart . brush ( ) . on ( ' brush ' ) ( ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should filter the child charts ' , function ( )  {%NWL%expect ( otherDimension . top ( Infinity ) . length ) . toBe ( 4 ) ;%NWL%} ) ;%NWL%describe ( ' brush decreases in size ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . brush ( ) . on ( ' brush ' ) ( ) ;%NWL%2
chart . brush ( ) . extent ( [ 22 , 35 ] ) ;%NWL%chart . brush ( ) . on ( ' brush ' ) ( ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should filter the child charts ' , function ( )  {%NWL%expect ( otherDimension . top ( Infinity ) . length ) . toBe ( 4 ) ;%NWL%} ) ;%NWL%describe ( ' brush decreases in size ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . brush ( ) . extent ( [ 22 , 33 ] ) ;%NWL%chart . redraw ( ) ;%NWL%2
chart . brush ( ) . extent ( [ 22 , 33 ] ) ;%NWL%chart . brush ( ) . on ( ' brush ' ) ( ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should filter down to fewer points ' , function ( )  {%NWL%expect ( otherDimension . top ( Infinity ) . length ) . toBe ( 2 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' brush disappears ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . brush ( ) . on ( ' brush ' ) ( ) ;%NWL%1
chart . brush ( ) . on ( ' brush ' ) ( ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should filter down to fewer points ' , function ( )  {%NWL%expect ( otherDimension . top ( Infinity ) . length ) . toBe ( 2 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' brush disappears ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . brush ( ) . extent ( [ 22 , 22 ] ) ;%NWL%chart . redraw ( ) ;%NWL%1
chart . selectAll ( ' path ' ) . attr ( ' fill ' ,  ' red ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' should not run immediately ' , function ( )  {%NWL%expect ( chart . selectAll ( ' path ' ) . attr ( ' fill ' ) ) . not . toBe ( ' red ' ) ;%NWL%} ) ;%NWL%it ( ' should run when render is invoked ' , function ( )  {%NWL%chart . render ( ) ;%NWL%expect ( chart . selectAll ( ' path ' ) . attr ( ' fill ' ) ) . toBe ( ' red ' ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%7
expect ( chart . selectAll ( ' defs #coordinate - grid - chart - clip ' ) . size ( ) ) . toBe ( 1 ) ;%NWL%} ) ;%NWL%it ( ' should only create one clip rect ' , function ( )  {%NWL%expect ( chart . selectAll ( ' defs #coordinate - grid - chart - clip rect ' ) . size ( ) ) . toBe ( 1 ) ;%NWL%} ) ;%NWL%it ( ' should create a clip rect based on the graph size ' , function ( )  {%NWL%var rect = chart . select ( ' defs #coordinate - grid - chart - clip rect ' ) ;%NWL%expect ( rect . attr ( ' width ' ) ) . toBe ( ' 490 ' ) ;%NWL%expect ( rect . attr ( ' height ' ) ) . toBe ( ' 130 ' ) ;%NWL%} ) ;%NWL%var rect = chart . select ( ' defs #coordinate - grid - chart - clip rect ' ) ;%NWL%6
describe ( ' setting clipPadding ( 20 ) ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . clipPadding ( 20 ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should update the clip rect based on the graph size and clipPadding ' , function ( )  {%NWL%var rect = chart . select ( ' defs #coordinate - grid - chart - clip rect ' ) ;%NWL%expect ( rect . attr ( ' width ' ) ) . toBe ( ' 530 ' ) ;%NWL%expect ( rect . attr ( ' height ' ) ) . toBe ( ' 170 ' ) ;%NWL%} ) ;%NWL%var rect = chart . select ( ' defs #coordinate - grid - chart - clip rect ' ) ;%NWL%6
} ) ;%NWL%it ( ' should generate a valid clippath id ' , function ( )  {%NWL%var rect = chart . select ( ' defs #coordinate - grid - - chart - foo - - 5bar - - - clip rect ' ) ;%NWL%expect ( rect . empty ( ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' redrawing at a different size ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . width ( 300 ) . height ( 400 ) . redraw ( ) ;%NWL%} ) ;%NWL%var rect = chart . select ( ' defs #coordinate - grid - chart - clip rect ' ) ;%NWL%2
expect ( chart . y ( ) . domain ( ) [ 0 ] ) . toBe ( 0 ) ;%NWL%expect ( chart . y ( ) . domain ( ) [ 1 ] ) . toBe ( 0 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' rescaling ' , function ( )  {%NWL%var originalUnitCount;%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%originalUnitCount = chart . xUnitCount ( ) ;%NWL%chart . rescale ( ) ;%NWL%8
chart . rescale ( ) ;%NWL%} ) ;%NWL%it ( ' should reset x unit count to reflect updated x domain ' , function ( )  {%NWL%expect ( chart . xUnitCount ( ) ) . not . toEqual ( originalUnitCount ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' range chart setup ' , function ( )  {%NWL%var rangeChart;%NWL%beforeEach ( function ( )  {%NWL%rangeChart = buildRangeChart ( ) ;%NWL%chart . render ( ) ;%NWL%0
beforeEach ( function ( )  {%NWL%chart . brushOn ( true ) ;%NWL%chart . render ( ) ;%NWL%chart . filter ( filter ) ;%NWL%} ) ;%NWL%it ( ' should update the brush extent ' , function ( )  {%NWL%expect ( chart . brush ( ) . extent ( ) ) . toEqual ( filter ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' removing the filter ' , function ( )  {%NWL%chart . brushOn ( true ) ;%NWL%1
chart . brushOn ( true ) ;%NWL%chart . render ( ) ;%NWL%chart . filter ( filter ) ;%NWL%} ) ;%NWL%it ( ' should update the brush extent ' , function ( )  {%NWL%expect ( chart . brush ( ) . extent ( ) ) . toEqual ( filter ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' removing the filter ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%1
chart . mouseZoomable ( false ) ;%NWL%spyOn ( chart ,  ' _disableMouseZoom ' ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should not explicitly disable mouse zooming ' , function ( )  {%NWL%expect ( chart . _disableMouseZoom ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' rendering with mouse zoom disabled after it was previously enabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%2
} ) ;%NWL%it ( ' should not explicitly disable mouse zooming ' , function ( )  {%NWL%expect ( chart . _disableMouseZoom ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' rendering with mouse zoom disabled after it was previously enabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . mouseZoomable ( true ) ;%NWL%chart . render ( ) ;%NWL%chart . mouseZoomable ( false ) ;%NWL%chart . render ( ) ;%NWL%8
chart . render ( ) ;%NWL%chart . mouseZoomable ( false ) ;%NWL%spyOn ( chart ,  ' _disableMouseZoom ' ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should explicitly disable mouse zooming ' , function ( )  {%NWL%expect ( chart . _disableMouseZoom ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with mouse zoom disabled ' , function ( )  {%NWL%chart . mouseZoomable ( false ) ;%NWL%1
chart . mouseZoomable ( false ) ;%NWL%spyOn ( chart ,  ' _disableMouseZoom ' ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should explicitly disable mouse zooming ' , function ( )  {%NWL%expect ( chart . _disableMouseZoom ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with mouse zoom disabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%2
chart = context ( ) . chart;%NWL%zoomCallback = context ( ) . zoomCallback;%NWL%} ) ;%NWL%it ( ' should be flagged as refocused ' , function ( )  {%NWL%expect ( chart . refocused ( ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' should update chart filter to match new x domain ' , function ( )  {%NWL%var filter = cleanDateRange ( chart . filter ( ) ) ;%NWL%expect ( filter ) . toEqual ( chart . x ( ) . domain ( ) ) ;%NWL%} ) ;%NWL%var domain = chart . x ( ) . domain ( ) ;%NWL%7
expect ( chart . refocused ( ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' brushing ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . brushOn ( true ) ;%NWL%} ) ;%NWL%describe ( ' with mouse zoom enabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%spyOn ( chart ,  ' _disableMouseZoom ' ) ;%NWL%chart . mouseZoomable ( true ) ;%NWL%5
} ) ;%NWL%describe ( ' with mouse zoom enabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%spyOn ( chart ,  ' _disableMouseZoom ' ) ;%NWL%spyOn ( chart ,  ' _enableMouseZoom ' ) ;%NWL%chart . mouseZoomable ( true ) ;%NWL%chart . render ( ) ;%NWL%chart . brush ( ) . extent ( [ makeDate ( 2012 , 6 , 1 ) , makeDate ( 2012 , 6 , 15 ) ] ) ;%NWL%chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%} ) ;%NWL%chart . brush ( ) . extent ( [ makeDate ( 2012 , 6 , 1 ) , makeDate ( 2012 , 6 , 15 ) ] ) ;%NWL%7
describe ( ' with mouse zoom enabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%spyOn ( chart ,  ' _disableMouseZoom ' ) ;%NWL%spyOn ( chart ,  ' _enableMouseZoom ' ) ;%NWL%chart . mouseZoomable ( true ) ;%NWL%chart . render ( ) ;%NWL%chart . brush ( ) . extent ( [ makeDate ( 2012 , 6 , 1 ) , makeDate ( 2012 , 6 , 15 ) ] ) ;%NWL%chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%} ) ;%NWL%it ( ' should disable mouse zooming on brush start , and re - enables it afterwards ' , function ( )  {%NWL%chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%7
chart . brush ( ) . extent ( [ makeDate ( 2012 , 6 , 1 ) , makeDate ( 2012 , 6 , 15 ) ] ) ;%NWL%chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%expect ( chart . _disableMouseZoom ) . toHaveBeenCalled ( ) ;%NWL%expect ( chart . _enableMouseZoom ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with mouse zoom disabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%spyOn ( chart ,  ' _enableMouseZoom ' ) ;%NWL%chart . mouseZoomable ( false ) ;%NWL%chart . brush ( ) . extent ( [ makeDate ( 2012 , 6 , 1 ) , makeDate ( 2012 , 6 , 15 ) ] ) ;%NWL%0
chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%expect ( chart . _disableMouseZoom ) . toHaveBeenCalled ( ) ;%NWL%expect ( chart . _enableMouseZoom ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with mouse zoom disabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%spyOn ( chart ,  ' _enableMouseZoom ' ) ;%NWL%chart . mouseZoomable ( false ) ;%NWL%chart . render ( ) ;%NWL%chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%0
chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%} ) ;%NWL%it ( ' should not enable mouse zooming ' , function ( )  {%NWL%expect ( chart . _enableMouseZoom ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with equal dates ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%spyOn ( chart ,  ' filter ' ) ;%NWL%chart . brush ( ) . clear ( ) ;%NWL%chart . brush ( ) . event ( chart . root ( ) ) ;%NWL%0
rangeChart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should zoom the focus chart when range chart is brushed ' , function ( )  {%NWL%spyOn ( chart ,  ' focus ' ) . and . callThrough ( ) ;%NWL%rangeChart . brush ( ) . extent ( selectedRange ) ;%NWL%rangeChart . brush ( ) . event ( rangeChart . g ( ) ) ;%NWL%jasmine . clock ( ) . tick ( 100 ) ;%NWL%var focus = cleanDateRange ( chart . focus . calls . argsFor ( 0 ) [ 0 ] ) ;%NWL%expect ( focus ) . toEqual ( selectedRange ) ;%NWL%} ) ;%NWL%rangeChart . brush ( ) . extent ( selectedRange ) ;%NWL%4
} ) ;%NWL%it ( ' should zoom the focus chart when range chart is brushed ' , function ( )  {%NWL%spyOn ( chart ,  ' focus ' ) . and . callThrough ( ) ;%NWL%rangeChart . brush ( ) . extent ( selectedRange ) ;%NWL%rangeChart . brush ( ) . event ( rangeChart . g ( ) ) ;%NWL%jasmine . clock ( ) . tick ( 100 ) ;%NWL%var focus = cleanDateRange ( chart . focus . calls . argsFor ( 0 ) [ 0 ] ) ;%NWL%expect ( focus ) . toEqual ( selectedRange ) ;%NWL%} ) ;%NWL%it ( ' should zoom the focus chart back out when range chart is un - brushed ' , function ( )  {%NWL%rangeChart . brush ( ) . event ( rangeChart . g ( ) ) ;%NWL%4
it ( ' should zoom the focus chart when range chart is brushed ' , function ( )  {%NWL%spyOn ( chart ,  ' focus ' ) . and . callThrough ( ) ;%NWL%rangeChart . brush ( ) . extent ( selectedRange ) ;%NWL%rangeChart . brush ( ) . event ( rangeChart . g ( ) ) ;%NWL%jasmine . clock ( ) . tick ( 100 ) ;%NWL%var focus = cleanDateRange ( chart . focus . calls . argsFor ( 0 ) [ 0 ] ) ;%NWL%expect ( focus ) . toEqual ( selectedRange ) ;%NWL%} ) ;%NWL%it ( ' should zoom the focus chart back out when range chart is un - brushed ' , function ( )  {%NWL%rangeChart . brush ( ) . extent ( selectedRange ) ;%NWL%jasmine . clock ( ) . tick ( 100 ) ;%NWL%4
rangeChart . brush ( ) . event ( rangeChart . g ( ) ) ;%NWL%jasmine . clock ( ) . tick ( 100 ) ;%NWL%var focus = cleanDateRange ( chart . focus . calls . argsFor ( 0 ) [ 0 ] ) ;%NWL%expect ( focus ) . toEqual ( selectedRange ) ;%NWL%} ) ;%NWL%it ( ' should zoom the focus chart back out when range chart is un - brushed ' , function ( )  {%NWL%rangeChart . brush ( ) . extent ( selectedRange ) ;%NWL%rangeChart . brush ( ) . event ( rangeChart . g ( ) ) ;%NWL%jasmine . clock ( ) . tick ( 100 ) ;%NWL%expect ( chart . x ( ) . domain ( ) ) . toEqual ( selectedRange ) ;%NWL%jasmine . clock ( ) . tick ( 100 ) ;%NWL%1
chart . render ( ) ;%NWL%chart . focus ( [ makeDate ( 2012 , 8 , 20 ) , makeDate ( 2012 , 8 , 25 ) ] ) ;%NWL%} ) ;%NWL%it ( ' should not be able to zoom out past its original x domain ' , function ( )  {%NWL%chart . focus ( [ makeDate ( 2012 , 2 , 20 ) , makeDate ( 2012 , 9 , 15 ) ] ) ;%NWL%expect ( chart . x ( ) . domain ( ) ) . toEqual ( chart . xOriginalDomain ( ) ) ;%NWL%} ) ;%NWL%describe ( ' with a range chart ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%var rangeChart = buildRangeChart ( ) ;%NWL%chart . render ( ) ;%NWL%0
} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with zoom restriction disabled ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . zoomOutRestrict ( false ) ;%NWL%chart . render ( ) ;%NWL%chart . focus ( [ makeDate ( 2012 , 8 , 20 ) , makeDate ( 2012 , 8 , 25 ) ] ) ;%NWL%} ) ;%NWL%it ( ' should be able to zoom out past its original x domain ' , function ( )  {%NWL%chart . render ( ) ;%NWL%6
chart . render ( ) ;%NWL%chart . focus ( [ makeDate ( 2012 , 8 , 20 ) , makeDate ( 2012 , 8 , 25 ) ] ) ;%NWL%} ) ;%NWL%it ( ' should be able to zoom out past its original x domain ' , function ( )  {%NWL%chart . focus ( [ makeDate ( 2012 , 2 , 20 ) , makeDate ( 2012 , 9 , 15 ) ] ) ;%NWL%chart . render ( ) ;%NWL%expect ( chart . x ( ) . domain ( ) ) . toEqual ( [ makeDate ( 2012 , 2 , 20 ) , makeDate ( 2012 , 9 , 15 ) ] ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' focus ' , function ( )  {%NWL%chart . render ( ) ;%NWL%0
spyOn ( chart ,  ' redraw ' ) ;%NWL%return chart;%NWL%} ) ;%NWL%it ( ' should register chart object ' , function ( )  {%NWL%expect ( dc . hasChart ( chart ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' filterAll should invoke filter on each chart ' , function ( )  {%NWL%dc . filterAll ( ) ;%NWL%expect ( chart . filterAll ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%dc . renderAll ( ) ;%NWL%7
expect ( dc . hasChart ( chart ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' filterAll should invoke filter on each chart ' , function ( )  {%NWL%dc . filterAll ( ) ;%NWL%expect ( chart . filterAll ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' renderAll should invoke filter on each chart ' , function ( )  {%NWL%dc . renderAll ( ) ;%NWL%expect ( chart . render ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%dc . deregisterAllCharts ( ) ;%NWL%3
dc . dataTable ( ' #b4 ' ,  ' groupB ' ) . dimension ( valueDimension ) . group ( valueGroup ) ;%NWL%return chart;%NWL%} ) ;%NWL%it ( ' should register chart object ' , function ( )  {%NWL%expect ( dc . hasChart ( chart ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' filterAll by group should invoke filter on each chart within the group ' , function ( )  {%NWL%dc . filterAll ( ' groupA ' ) ;%NWL%expect ( chart . filterAll ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%dc . renderAll ( ' groupA ' ) ;%NWL%7
expect ( chart . filterAll ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' renderAll by group should invoke filter on each chart within the group ' , function ( )  {%NWL%dc . renderAll ( ' groupA ' ) ;%NWL%expect ( chart . render ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' filterAll should not invoke filter on chart in groupA ' , function ( )  {%NWL%dc . filterAll ( ) ;%NWL%expect ( chart . filterAll ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%dc . renderAll ( ) ;%NWL%7
expect ( chart . render ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' filterAll should not invoke filter on chart in groupA ' , function ( )  {%NWL%dc . filterAll ( ) ;%NWL%expect ( chart . filterAll ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' renderAll should not invoke filter on chart in groupA ' , function ( )  {%NWL%dc . renderAll ( ) ;%NWL%expect ( chart . render ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%dc . deregisterAllCharts ( ) ;%NWL%3
beforeEach ( function ( )  {%NWL%dc . renderlet ( function ( group )  {%NWL%result . called = group ? group : true;%NWL%} ) ;%NWL%result = { called: false } ;%NWL%} ) ;%NWL%it ( ' renderAll call back should be triggered ' , function ( )  {%NWL%dc . renderAll ( ) ;%NWL%expect ( result . called ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%dc . redrawAll ( ) ;%NWL%7
expect ( result . called ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' redrawAll call back should be triggered ' , function ( )  {%NWL%dc . redrawAll ( ) ;%NWL%expect ( result . called ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' renderAll by group call back should be triggered ' , function ( )  {%NWL%dc . renderAll ( ' group ' ) ;%NWL%expect ( ' group ' ) . toEqual ( result . called ) ;%NWL%} ) ;%NWL%dc . redrawAll ( ' group ' ) ;%NWL%7
div . append ( ' a ' ) . attr ( ' class ' ,  ' reset ' ) . style ( ' display ' ,  ' none ' ) ;%NWL%div . append ( ' span ' ) . attr ( ' class ' ,  ' filter ' ) . style ( ' display ' ,  ' none ' ) ;%NWL%var chart = dc . pieChart ( ' # '  + id ) ;%NWL%chart . dimension ( valueDimension ) . group ( valueGroup )%NWL%. width ( width )%NWL%. height ( height )%NWL%. radius ( radius )%NWL%. ordering ( function ( kv )  { return kv . key; } )%NWL%. transitionDuration ( 0 ) ;%NWL%chart . render ( ) ;%NWL%chart . expireCache ( ) ;%NWL%9
chart . render ( ) ;%NWL%baseData . add ( moreData ) ;%NWL%chart . expireCache ( ) ;%NWL%return chart;%NWL%}%NWL%beforeEach ( function ( )  {%NWL%valueDimension = baseData . dimension ( function ( d )  {%NWL%return d . value;%NWL%} ) ;%NWL%valueGroup = valueDimension . group ( ) ;%NWL%chart . redraw ( ) ;%NWL%0
var chart = dc . lineChart ( ' # '  + id ) ;%NWL%chart . dimension ( timeDimension ) . group ( timeGroup )%NWL%. width ( width ) . height ( height )%NWL%. x ( d3 . time . scale . utc ( ) . domain ( [ makeDate ( 2012 , 4 , 20 ) , makeDate ( 2012 , 7 , 15 ) ] ) )%NWL%. transitionDuration ( 0 )%NWL%. xUnits ( d3 . time . days . utc )%NWL%. brushOn ( false )%NWL%. renderArea ( true )%NWL%. renderTitle ( true ) ;%NWL%chart . render ( ) ;%NWL%chart . expireCache ( ) ;%NWL%9
chart . render ( ) ;%NWL%baseData . add ( moreData ) ;%NWL%chart . expireCache ( ) ;%NWL%return chart;%NWL%}%NWL%beforeEach ( function ( )  {%NWL%timeDimension = baseData . dimension ( function ( d )  {%NWL%return d . dd;%NWL%} ) ;%NWL%timeGroup = timeDimension . group ( ) ;%NWL%chart . render ( ) ;%NWL%0
chart = buildLineChart ( ' line - chart ' ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' number of dots should equal the size of the group ' , function ( )  {%NWL%expect ( chart . selectAll ( ' circle . dot ' ) [ 0 ] . length ) . toEqual ( timeGroup . size ( ) ) ;%NWL%} ) ;%NWL%it ( ' number of line segments should equal the size of the group ' , function ( )  {%NWL%var path = chart . selectAll ( ' path . line ' ) . attr ( ' d ' ) ;%NWL%expect ( occurrences ( path ,  ' L ' )  + 1 ) . toEqual ( timeGroup . size ( ) ) ;%NWL%} ) ;%NWL%var path = chart . selectAll ( ' path . area ' ) . attr ( ' d ' ) ;%NWL%7
} ) ;%NWL%it ( ' number of line segments should equal the size of the group ' , function ( )  {%NWL%var path = chart . selectAll ( ' path . line ' ) . attr ( ' d ' ) ;%NWL%expect ( occurrences ( path ,  ' L ' )  + 1 ) . toEqual ( timeGroup . size ( ) ) ;%NWL%} ) ;%NWL%it ( ' number of area segments should equal twice the size of the group ' , function ( )  {%NWL%var path = chart . selectAll ( ' path . area ' ) . attr ( ' d ' ) ;%NWL%expect ( occurrences ( path ,  ' L ' )  + 1 ) . toEqual ( timeGroup . size ( )  * 2 ) ;%NWL%} ) ;%NWL%describe ( ' resetting line chart with fewer data points ' , function ( )  {%NWL%var chart = buildLineChart ( ' stackable - line - chart ' ) ;%NWL%2
it ( ' number of area segments should equal twice the size of the group ' , function ( )  {%NWL%var path = chart . selectAll ( ' path . area ' ) . attr ( ' d ' ) ;%NWL%expect ( occurrences ( path ,  ' L ' )  + 1 ) . toEqual ( timeGroup . size ( )  * 2 ) ;%NWL%} ) ;%NWL%describe ( ' resetting line chart with fewer data points ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%var chart = buildLineChart ( ' stackable - line - chart ' ) ;%NWL%chart . render ( ) ;%NWL%timeDimension . filterAll ( ) ;%NWL%baseData . remove ( ) ;%NWL%chart . render ( ) ;%NWL%7
chart . render ( ) ;%NWL%timeDimension . filterAll ( ) ;%NWL%baseData . remove ( ) ;%NWL%baseData . add ( moreData ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' it should not contain stale data points ' , function ( )  {%NWL%expect ( chart . data ( ) [ 0 ] . values . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%timeDimension . filterAll ( ) ;%NWL%1
describe ( ' when all selected ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%countryDimension . filterAll ( ) ;%NWL%chart . redraw ( ) ;%NWL%return chart;%NWL%} ) ;%NWL%it ( ' should use html . all ' , function ( )  {%NWL%expect ( chart . root ( ) . text ( ) ) . toEqual ( ' All Records Selected ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%countryDimension . filterAll ( ) ;%NWL%2
div . append ( ' span ' ) . attr ( ' class ' ,  ' total - count ' ) ;%NWL%chart = buildChart ( id ) ;%NWL%chart . html ( { some: ' %filter - count selected from %total - count ' } ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should fill the element replacing %filter - count and %total - count ' , function ( )  {%NWL%expect ( chart . root ( ) . text ( ) ) . toEqual ( ' 2 selected from 10 ' ) ;%NWL%} ) ;%NWL%describe ( ' when all selected ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%3
describe ( ' when all selected ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%countryDimension . filterAll ( ) ;%NWL%chart . redraw ( ) ;%NWL%return chart;%NWL%} ) ;%NWL%it ( ' should use html . some for all ' , function ( )  {%NWL%expect ( chart . root ( ) . text ( ) ) . toEqual ( ' 10 selected from 10 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%countryDimension . filterAll ( ) ;%NWL%2
chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should fill in the total count ' , function ( )  {%NWL%expect ( chart . select ( ' span . total - count ' ) . text ( ) ) . toEqual ( ' 10 ' ) ;%NWL%} ) ;%NWL%it ( ' should fill in the filter count ' , function ( )  {%NWL%expect ( chart . select ( ' span . filter - count ' ) . text ( ) ) . toEqual ( ' 2 ' ) ;%NWL%} ) ;%NWL%describe ( ' when all selected ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%0
describe ( ' when all selected ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%countryDimension . filterAll ( ) ;%NWL%chart . redraw ( ) ;%NWL%return chart;%NWL%} ) ;%NWL%it ( ' should use html . all for all ' , function ( )  {%NWL%expect ( chart . root ( ) . text ( ) ) . toEqual ( ' All Records Selected ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%countryDimension . filterAll ( ) ;%NWL%2
} ) ;%NWL%describe ( ' slicing entries ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . beginSlice ( 1 ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' slice beginning ' , function ( )  {%NWL%expect ( chart . selectAll ( ' . dc - grid - item ' ) [ 0 ] . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%it ( ' slice beginning and end ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%4
expect ( chart . selectAll ( ' . dc - grid - item ' ) [ 0 ] . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%it ( ' slice beginning and end ' , function ( )  {%NWL%chart . endSlice ( 2 ) ;%NWL%chart . redraw ( ) ;%NWL%expect ( chart . selectAll ( ' . dc - grid - item ' ) [ 0 ] . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' external filter ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%4
chart . selectAll ( ' . dc - grid - label ' ) . text ( ' changed ' ) ;%NWL%} ) ;%NWL%derlet . and . callThrough ( ) ;%NWL%chart . on ( ' renderlet ' , derlet ) ;%NWL%} ) ;%NWL%it ( ' custom renderlet should be invoked with render ' , function ( )  {%NWL%chart . render ( ) ;%NWL%expect ( chart . selectAll ( ' . dc - grid - label ' ) . text ( ) ) . toEqual ( ' changed ' ) ;%NWL%expect ( derlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%6
} ) ;%NWL%describe ( ' slicing entries ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . beginSlice ( 1 ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' slice beginning ' , function ( )  {%NWL%expect ( chart . selectAll ( ' tr . dc - table - row ' ) [ 0 ] . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%it ( ' slice beginning and end ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%4
expect ( chart . selectAll ( ' tr . dc - table - row ' ) [ 0 ] . length ) . toEqual ( 2 ) ;%NWL%} ) ;%NWL%it ( ' slice beginning and end ' , function ( )  {%NWL%chart . endSlice ( 2 ) ;%NWL%chart . redraw ( ) ;%NWL%expect ( chart . selectAll ( ' tr . dc - table - row ' ) [ 0 ] . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' external filter ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%4
chart . selectAll ( ' td . dc - table - label ' ) . text ( ' changed ' ) ;%NWL%} ) ;%NWL%derlet . and . callThrough ( ) ;%NWL%chart . on ( ' renderlet ' , derlet ) ;%NWL%} ) ;%NWL%it ( ' custom renderlet should be invoked with render ' , function ( )  {%NWL%chart . render ( ) ;%NWL%expect ( chart . selectAll ( ' td . dc - table - label ' ) . text ( ) ) . toEqual ( ' changed ' ) ;%NWL%expect ( derlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%6
expect ( derlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( ' custom renderlet should be invoked with redraw ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%expect ( chart . selectAll ( ' td . dc - table - label ' ) . text ( ) ) . toEqual ( ' changed ' ) ;%NWL%expect ( derlet ) . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' specifying chart columns with label ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%3
chart . columns ( [ {%NWL%label: ' Test ID ' ,%NWL%format: function ( d )  {%NWL%return ' test '  + d . id;%NWL%}%NWL%} ] ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should produce correct table header with single column ' , function ( )  {%NWL%var thead = chart . selectAll ( ' thead ' ) ;%NWL%var tr = thead . selectAll ( ' tr ' ) ;%NWL%9
chart . columns ( [ {%NWL%label: ' Test ID ' ,%NWL%format: function ( d )  {%NWL%return ' test '  + d . id;%NWL%}%NWL%} ] ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should produce correct table header with single column ' , function ( )  {%NWL%var thead = chart . selectAll ( ' thead ' ) ;%NWL%var tr = thead . selectAll ( ' tr ' ) ;%NWL%9
var times = 0;%NWL%var i = 0;%NWL%var increment = function ( )  {%NWL%times + + ;%NWL%} ;%NWL%while ( i < 10 )  {%NWL%engine . trigger ( increment . bind ( null ) , 10 ) ;%NWL%i + + ;%NWL%}%NWL%jasmine . clock ( ) . tick ( 5 ) ;%NWL%jasmine . clock ( ) . tick ( 5 ) ;%NWL%9
if ( vars . dev . value ) print . time ( " filtering edges " )%NWL%vars . edges . restricted = vars . edges . value . filter ( function ( d ) {%NWL%var points = filter_data ( [ d [ vars . edges . source ] , d [ vars . edges . target ] ] ) ;%NWL%return points . length === 2;%NWL%} )%NWL%if ( vars . dev . value ) print . timeEnd ( " filtering edges " )%NWL%}%NWL%}%NWL%} )%NWL%}%NWL%vars . nodes . restricted = undefined;%NWL%1
vars . edges . restricted = vars . edges . value . filter ( function ( d ) {%NWL%var points = filter_data ( [ d [ vars . edges . source ] , d [ vars . edges . target ] ] ) ;%NWL%return points . length === 2;%NWL%} )%NWL%if ( vars . dev . value ) print . timeEnd ( " filtering edges " )%NWL%}%NWL%}%NWL%} )%NWL%}%NWL%else if ( " nodes " in vars )  {%NWL%vars . edges . restricted = undefined;%NWL%0
expect ( this . getAttribute ( ' ry ' ) ) . toBe ( ' 6 . 75 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' should set the radius to an overridden x ' , function ( )  {%NWL%chart . xBorderRadius ( 7 ) ;%NWL%chart . render ( ) ;%NWL%chart . select ( ' rect . heat - box ' ) . each ( function ( )  {%NWL%expect ( this . getAttribute ( ' rx ' ) ) . toBe ( ' 7 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%chart . yBorderRadius ( 7 ) ;%NWL%4
} ) ;%NWL%} ) ;%NWL%it ( ' should set the radius to an overridden x ' , function ( )  {%NWL%chart . xBorderRadius ( 7 ) ;%NWL%chart . render ( ) ;%NWL%chart . select ( ' rect . heat - box ' ) . each ( function ( )  {%NWL%expect ( this . getAttribute ( ' rx ' ) ) . toBe ( ' 7 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' should set the radius to an overridden y ' , function ( )  {%NWL%chart . render ( ) ;%NWL%4
chart . render ( ) ;%NWL%chart . select ( ' rect . heat - box ' ) . each ( function ( )  {%NWL%expect ( this . getAttribute ( ' ry ' ) ) . toBe ( ' 7 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' override scale domains ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . rows ( [ 1 ] ) ;%NWL%chart . render ( ) ;%NWL%0
expect ( xaxisTexts [ 0 ] [ 0 ] . textContent ) . toEqual ( ' 1 ' ) ;%NWL%} ) ;%NWL%it ( ' should reset the rows to using the chart data on the y axis ' , function ( )  {%NWL%chart . rows ( null ) ;%NWL%chart . redraw ( ) ;%NWL%var yaxisTexts = chart . selectAll ( ' . rows . axis text ' ) ;%NWL%expect ( yaxisTexts [ 0 ] . length ) . toEqual ( 2 ) ;%NWL%expect ( yaxisTexts [ 0 ] [ 0 ] . textContent ) . toEqual ( ' 1 ' ) ;%NWL%expect ( yaxisTexts [ 0 ] [ 1 ] . textContent ) . toEqual ( ' 2 ' ) ;%NWL%} ) ;%NWL%chart . cols ( null ) ;%NWL%3
} ) ;%NWL%it ( ' should reset the rows to using the chart data on the y axis ' , function ( )  {%NWL%chart . rows ( null ) ;%NWL%chart . redraw ( ) ;%NWL%var yaxisTexts = chart . selectAll ( ' . rows . axis text ' ) ;%NWL%expect ( yaxisTexts [ 0 ] . length ) . toEqual ( 2 ) ;%NWL%expect ( yaxisTexts [ 0 ] [ 0 ] . textContent ) . toEqual ( ' 1 ' ) ;%NWL%expect ( yaxisTexts [ 0 ] [ 1 ] . textContent ) . toEqual ( ' 2 ' ) ;%NWL%} ) ;%NWL%it ( ' should reset the cols to using the chart data on the y axis ' , function ( )  {%NWL%chart . redraw ( ) ;%NWL%3
chart . redraw ( ) ;%NWL%var xaxisTexts = chart . selectAll ( ' . cols . axis text ' ) ;%NWL%expect ( xaxisTexts [ 0 ] . length ) . toEqual ( 2 ) ;%NWL%expect ( xaxisTexts [ 0 ] [ 0 ] . textContent ) . toEqual ( ' 1 ' ) ;%NWL%expect ( xaxisTexts [ 0 ] [ 1 ] . textContent ) . toEqual ( ' 2 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' use a custom ordering on x and y axes ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . rowOrdering ( d3 . descending ) ;%NWL%chart . render ( ) ;%NWL%0
} ,  { cols: d3 . set ( ) , rows: d3 . set ( ) } ) ;%NWL%} ;%NWL%beforeEach ( function ( )  {%NWL%data2 = crossfilter ( loadColorFixture2 ( ) ) ;%NWL%dimension2 = data2 . dimension ( function ( d )  { return [ + d . colData ,  + d . rowData ] ; } ) ;%NWL%group2 = dimension2 . group ( ) . reduceSum ( function ( d )  { return + d . colorData; } ) ;%NWL%originalDomain = reduceDimensionValues ( dimension ) ;%NWL%newDomain = reduceDimensionValues ( dimension2 ) ;%NWL%chart . dimension ( dimension2 ) . group ( group2 ) ;%NWL%chart . render ( ) ;%NWL%chart . redraw ( ) ;%NWL%9
} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' indirect filtering ' , function ( )  {%NWL%var dimension2 , group2;%NWL%beforeEach ( function ( )  {%NWL%dimension2 = data . dimension ( function ( d )  { return + d . colorData; } ) ;%NWL%group2 = dimension2 . group ( ) . reduceSum ( function ( d )  { return + d . colorData; } ) ;%NWL%chart . dimension ( dimension ) . group ( group ) ;%NWL%chart . render ( ) ;%NWL%chart . redraw ( ) ;%NWL%9
} ) ;%NWL%} ) ;%NWL%describe ( ' click events ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should toggle a filter for the clicked box ' , function ( )  {%NWL%chart . selectAll ( ' . box - group ' ) . each ( function ( d )  {%NWL%var cell = d3 . select ( this ) . select ( ' rect ' ) ;%NWL%cell . on ( ' click ' ) ( d ) ;%NWL%cell . on ( ' click ' ) ( d ) ;%NWL%9
} else {%NWL%expect ( chart . hasFilter ( d . key ) ) . toBeFalsy ( ) ;%NWL%}%NWL%} ) ;%NWL%}%NWL%describe ( ' with nothing previously filtered ' , function ( )  {%NWL%it ( ' should filter all cells on that axis ' , function ( )  {%NWL%chart . selectAll ( ' . cols . axis text ' ) . each ( function ( d )  {%NWL%var axisLabel = d3 . select ( this ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%9
}%NWL%describe ( ' with nothing previously filtered ' , function ( )  {%NWL%it ( ' should filter all cells on that axis ' , function ( )  {%NWL%chart . selectAll ( ' . cols . axis text ' ) . each ( function ( d )  {%NWL%var axisLabel = d3 . select ( this ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%assertOnlyThisAxisIsFiltered ( chart , 0 , d ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%} ) ;%NWL%chart . selectAll ( ' . rows . axis text ' ) . each ( function ( d )  {%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%5
it ( ' should filter all cells on that axis ' , function ( )  {%NWL%chart . selectAll ( ' . cols . axis text ' ) . each ( function ( d )  {%NWL%var axisLabel = d3 . select ( this ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%assertOnlyThisAxisIsFiltered ( chart , 0 , d ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%} ) ;%NWL%chart . selectAll ( ' . rows . axis text ' ) . each ( function ( d )  {%NWL%var axisLabel = d3 . select ( this ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%axisLabel . on ( ' click ' ) ( d ) ;%NWL%3
var boxes = chart . selectAll ( ' . box - group ' ) ;%NWL%var box = d3 . select ( boxes [ 0 ] [ Math . floor ( Math . random ( )  * boxes . length ) ] ) ;%NWL%box . select ( ' rect ' ) . on ( ' click ' ) ( box . datum ( ) ) ;%NWL%expect ( chart . hasFilter ( box . datum ( ) . key ) ) . toBeTruthy ( ) ;%NWL%var xVal = box . datum ( ) . key [ 0 ] ;%NWL%var columns = chart . selectAll ( ' . cols . axis text ' ) ;%NWL%var column = columns . filter ( function ( columnData )  {%NWL%return columnData === xVal;%NWL%} ) ;%NWL%column . on ( ' click ' ) ( column . datum ( ) ) ;%NWL%column . on ( ' click ' ) ( column . datum ( ) ) ;%NWL%9
} ) ;%NWL%} ) ;%NWL%describe ( ' with . horizontal ( true ) and . autoItemWidth ( true ) ' , function ( )  {%NWL%var fixedWidthOffset1 , fixedWidthOffset2 ,%NWL%autoWidthCoords;%NWL%beforeEach ( function ( )  {%NWL%chart . legend ( dc . legend ( ) . horizontal ( true ) . itemWidth ( 30 ) . autoItemWidth ( false ) ) ;%NWL%chart . render ( ) ;%NWL%fixedWidthOffset1 = coordsFromTranslate ( legendItem ( 1 ) . attr ( ' transform ' ) ) . x;%NWL%fixedWidthOffset2 = coordsFromTranslate ( legendItem ( 2 ) . attr ( ' transform ' ) ) . x;%NWL%chart . render ( ) ;%NWL%7
beforeEach ( function ( )  {%NWL%chart . legend ( )%NWL%. maxItems ( 2 ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should display two items ' , function ( )  {%NWL%expect ( chart . select ( ' g . dc - legend ' ) . selectAll ( ' g . dc - legend - item ' ) . size ( ) ) . toBe ( 2 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with invalid . maxItems ' , function ( )  {%NWL%chart . legend ( )%NWL%1
. maxItems ( 2 ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should display two items ' , function ( )  {%NWL%expect ( chart . select ( ' g . dc - legend ' ) . selectAll ( ' g . dc - legend - item ' ) . size ( ) ) . toBe ( 2 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with invalid . maxItems ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . legend ( )%NWL%chart . render ( ) ;%NWL%1
} ) ;%NWL%it ( ' should change the radius on mousemove ' , function ( )  {%NWL%chart . selectAll ( ' circle . dot ' ) . each ( function ( )  {%NWL%var dot = d3 . select ( this ) ;%NWL%dot . on ( ' mousemove ' ) . call ( this ) ;%NWL%expect ( dot . attr ( ' r ' ) ) . toBe ( ' 5 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' should revert to original radius on mouseout ' , function ( )  {%NWL%chart . selectAll ( ' circle . dot ' ) . each ( function ( )  {%NWL%dot . on ( ' mousemove ' ) . call ( this ) ;%NWL%4
it ( ' should not change showing the data point on mousemove ' , function ( )  {%NWL%chart . selectAll ( ' circle . dot ' ) . each ( function ( )  {%NWL%var dot = d3 . select ( this ) ;%NWL%dot . on ( ' mousemove ' ) . call ( this ) ;%NWL%expect ( dot . style ( ' fill - opacity ' ) ) . toBeWithinDelta ( 0 . 8 ) ;%NWL%expect ( dot . style ( ' stroke - opacity ' ) ) . toBeWithinDelta ( 0 . 8 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' should not change returning to extremely low opacity on hover out ' , function ( )  {%NWL%chart . selectAll ( ' circle . dot ' ) . each ( function ( )  {%NWL%dot . on ( ' mousemove ' ) . call ( this ) ;%NWL%3
chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should not render dots and tips when boolean flag is false ' , function ( )  {%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot ' ) . empty ( ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot title ' ) . empty ( ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' title rendering with brushOn ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . brushOn ( true )%NWL%chart . render ( ) ;%NWL%0
beforeEach ( function ( )  {%NWL%chart . brushOn ( true )%NWL%. xyTipsOn ( true ) ; / / default , for exposition%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should not render tips ' , function ( )  {%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot ' ) . empty ( ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot title ' ) . empty ( ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%describe ( ' with xyTipsOn always ' , function ( )  {%NWL%chart . brushOn ( true )%NWL%1
. xyTipsOn ( true ) ; / / default , for exposition%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should not render tips ' , function ( )  {%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot ' ) . empty ( ) ) . toBeTruthy ( ) ;%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot title ' ) . empty ( ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%describe ( ' with xyTipsOn always ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . brushOn ( true )%NWL%chart . render ( ) ;%NWL%1
chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should render dots ' , function ( )  {%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot ' ) . empty ( ) ) . toBeFalsy ( ) ;%NWL%expect ( chart . select ( ' . dc - tooltip . _0 . dot title ' ) . empty ( ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' label rendering off ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%0
beforeEach ( function ( )  {%NWL%chart . renderLabel ( false ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should produce no labels ' , function ( )  {%NWL%expect ( chart . selectAll ( ' . lineLabel ' ) . empty ( ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' label rendering ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%2
it ( ' should become visible when hovered over ' , function ( )  {%NWL%chart . selectAll ( ' circle . dot ' ) . each ( function ( )  {%NWL%var dot = d3 . select ( this ) ;%NWL%dot . on ( ' mousemove ' ) . call ( this ) ;%NWL%expect ( dot . style ( ' fill - opacity ' ) ) . toBeWithinDelta ( 0 . 8 ) ;%NWL%expect ( dot . style ( ' stroke - opacity ' ) ) . toBeWithinDelta ( 0 . 8 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' should return to extremely low opacity on hover out ' , function ( )  {%NWL%chart . selectAll ( ' circle . dot ' ) . each ( function ( )  {%NWL%dot . on ( ' mousemove ' ) . call ( this ) ;%NWL%3
} ) ;%NWL%} ) ;%NWL%describe ( ' stack hiding ' , function ( )  {%NWL%describe ( ' first stack ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . hideStack ( ' stack 0 ' ) . render ( ) ;%NWL%} ) ;%NWL%it ( ' should hide the stack ' , function ( )  {%NWL%expect ( chart . select ( ' g . _0 path . line ' ) . attr ( ' d ' ) ) . toMatchPath ( ' M58 133L222 120L246 80L492 133L597 127L961 113 ' ) ;%NWL%} ) ;%NWL%chart . showStack ( ' stack 0 ' ) . render ( ) ;%NWL%5
} ) ;%NWL%} ) ;%NWL%describe ( ' any other stack ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . title ( ' stack 2 ' , function ( d )  { return ' stack 2: '  + d . value; } ) ;%NWL%chart . hideStack ( ' stack 1 ' ) . render ( ) ;%NWL%} ) ;%NWL%it ( ' should hide the stack ' , function ( )  {%NWL%expect ( chart . select ( ' g . _1 path . line ' ) . attr ( ' d ' ) ) . toMatchPath ( ' M58 112L222 83L246 0L492 108L597 85L961 64 ' ) ;%NWL%} ) ;%NWL%chart . showStack ( ' stack 1 ' ) . render ( ) ;%NWL%5
expect ( nthLine ( 1 ) . classed ( ' fadeout ' ) ) . toBeTruthy ( ) ;%NWL%expect ( nthArea ( 1 ) . classed ( ' fadeout ' ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' when a legend item is hovered out ' , function ( )  {%NWL%it ( ' should remove highlighting from corresponding lines and areas ' , function ( )  {%NWL%firstItem . on ( ' mouseout ' ) ( firstItem . datum ( ) ) ;%NWL%expect ( nthLine ( 0 ) . classed ( ' highlight ' ) ) . toBeFalsy ( ) ;%NWL%expect ( nthArea ( 0 ) . classed ( ' highlight ' ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%firstItem . on ( ' mouseout ' ) ( firstItem . datum ( ) ) ;%NWL%6
spyOn ( console ,  ' warn ' ) ;%NWL%dc . logger . warn ( message ) ;%NWL%} ) ;%NWL%it ( ' should log the message using console . warn ' , function ( )  {%NWL%expect ( console . warn ) . toHaveBeenCalledWith ( message ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' when console . warn is not defined but console . log is ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%console . warn = undefined;%NWL%dc . logger . warn ( message ) ;%NWL%1
spyOn ( console ,  ' debug ' ) ;%NWL%dc . logger . debug ( message ) ;%NWL%} ) ;%NWL%it ( ' should log the message using console . debug ' , function ( )  {%NWL%expect ( console . debug ) . toHaveBeenCalledWith ( message ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' when console . debug is not defined ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%console . debug = undefined;%NWL%dc . logger . debug ( message ) ;%NWL%1
countryDimension . filterAll ( ) ;%NWL%chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should update value ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 41 . 8 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with one , some and none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%1
chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should update value ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 41 . 8 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with one , some and none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { one: ' %number number ' , none: ' no number ' , some: ' %number numbers ' } ) ;%NWL%d3 . timer . flush ( ) ;%NWL%1
chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use some for some ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 38 . 5 numbers ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with one , some and none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { one: ' %number number ' , none: ' no number ' , some: ' %number numbers ' } ) ;%NWL%chart . redraw ( ) ;%NWL%0
d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use some for some ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 38 . 5 numbers ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with one , some and none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { one: ' %number number ' , none: ' no number ' , some: ' %number numbers ' } ) ;%NWL%chart . valueAccessor ( function ( d )  { return 1; } ) ;%NWL%d3 . timer . flush ( ) ;%NWL%0
chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use one for one ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 1 . 00 number ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with one , some and none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { one: ' %number number ' , none: ' no number ' , some: ' %number numbers ' } ) ;%NWL%chart . redraw ( ) ;%NWL%0
d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use one for one ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 1 . 00 number ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with one , some and none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { one: ' %number number ' , none: ' no number ' , some: ' %number numbers ' } ) ;%NWL%chart . valueAccessor ( function ( d )  { return 0; } ) ;%NWL%d3 . timer . flush ( ) ;%NWL%0
chart . valueAccessor ( function ( d )  { return 0; } ) ;%NWL%chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use zero for zero ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' no number ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with just one ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%1
chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use zero for zero ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' no number ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with just one ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { one: ' %number number ' } ) ;%NWL%d3 . timer . flush ( ) ;%NWL%1
chart . html ( { one: ' %number number ' } ) ;%NWL%chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use one for showing some ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 38 . 5 number ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with just some ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%1
chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use one for showing some ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 38 . 5 number ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with just some ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { some: ' %number numbers ' } ) ;%NWL%d3 . timer . flush ( ) ;%NWL%1
chart . html ( { some: ' %number numbers ' } ) ;%NWL%chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use some for showing one ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 38 . 5 numbers ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with just none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . redraw ( ) ;%NWL%1
chart . redraw ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should use some for showing one ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 38 . 5 numbers ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' html with just none ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . html ( { } ) ;%NWL%d3 . timer . flush ( ) ;%NWL%1
. toMatch ( new RegExp ( ' <p>There are <em ( ?:id= " nonspan " class= " dc - chart " |class= " dc - chart " id= " nonspan " ) > '  +%NWL%' <span class= " number - display " >38 . 5< / span>< / em> Total Widgets . < / p> ' ) ) ;%NWL%} ) ;%NWL%afterEach ( function ( )  {%NWL%countryDimension . filterAll ( ) ;%NWL%d3 . select ( ' #number - display - test - section ' ) . remove ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with group with multiple values ' , function ( )  {%NWL%var group , chart;%NWL%countryDimension . filterAll ( ) ;%NWL%4
. valueAccessor ( function ( kv )  { return kv . value; } )%NWL%. render ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should show the largest value ' , function ( )  {%NWL%expect ( chart . select ( ' span . number - display ' ) . text ( ) ) . toEqual ( ' 341 ' ) ;%NWL%} ) ;%NWL%describe ( ' with reversed ordering ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . ordering ( function ( kv )  { return - kv . value; } )%NWL%d3 . timer . flush ( ) ;%NWL%2
. formatNumber ( function ( d )  { return d; } )%NWL%. render ( ) ;%NWL%d3 . timer . flush ( ) ;%NWL%} ) ;%NWL%it ( ' should display as Infinity ' , function ( )  {%NWL%expect ( chart . root ( ) . text ( ) ) . toEqual ( ' Infinity ' ) ;%NWL%} ) ;%NWL%describe ( ' returning to finite ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . group ( { value: function ( )  { return 17; } } )%NWL%d3 . timer . flush ( ) ;%NWL%2
. radius ( radius )%NWL%. transitionDuration ( 0 ) ;%NWL%chart . render ( ) ;%NWL%return chart;%NWL%}%NWL%describe ( ' generation ' , function ( )  {%NWL%var chart ,%NWL%countryChart;%NWL%beforeEach ( function ( )  {%NWL%chart = buildChart ( ' pie - chart - age ' ) ;%NWL%chart . render ( ) ;%NWL%2
beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%return chart;%NWL%} ) ;%NWL%it ( ' multiple invocation of render should update chart ' , function ( )  {%NWL%expect ( d3 . selectAll ( ' #pie - chart - age svg ' ) [ 0 ] . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' filter ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%1
expect ( chart . hasFilter ( ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%it ( ' be able to set selected slice ' , function ( )  {%NWL%expect ( chart . filter ( ' 66 ' ) . filter ( ) ) . toEqual ( ' 66 ' ) ;%NWL%expect ( chart . hasFilter ( ) ) . toBeTruthy ( ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension by single selection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%5
expect ( chart . hasFilter ( ) ) . toBeTruthy ( ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension by single selection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension by multiple selections ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%4
it ( ' should filter dimension by single selection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension by multiple selections ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%4
expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension by multiple selections ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 2 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%5
chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension by multiple selections ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 2 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension with deselection ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%3
} ) ;%NWL%it ( ' should filter dimension by multiple selections ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 2 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension with deselection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%3
chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 1 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 2 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension with deselection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 0 ) ;%NWL%chart . filterAll ( ) ;%NWL%3
chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should filter dimension with deselection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 0 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%chart . filter ( ' 66 ' ) ;%NWL%4
} ) ;%NWL%it ( ' should filter dimension with deselection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 0 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should highlight selected slices ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%2
it ( ' should filter dimension with deselection ' , function ( )  {%NWL%chart . filter ( ' 22 ' ) ;%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%expect ( countryGroup . all ( ) [ 0 ] . value ) . toEqual ( 0 ) ;%NWL%expect ( countryGroup . all ( ) [ 1 ] . value ) . toEqual ( 1 ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' should highlight selected slices ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . render ( ) ;%NWL%6
it ( ' should highlight selected slices ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . filter ( ' 22 ' ) ;%NWL%chart . render ( ) ;%NWL%chart . selectAll ( ' g . pie - slice ' ) . each ( function ( d )  {%NWL%if ( d . data . key === ' 66 ' || d . data . key === ' 22 ' )  {%NWL%expect ( d3 . select ( this ) . attr ( ' class ' ) . indexOf ( ' selected ' ) > 0 ) . toBeTruthy ( ) ;%NWL%} else {%NWL%expect ( d3 . select ( this ) . attr ( ' class ' ) . indexOf ( ' deselected ' ) > 0 ) . toBeTruthy ( ) ;%NWL%}%NWL%chart . filterAll ( ) ;%NWL%3
expect ( d3 . select ( this ) . attr ( ' class ' ) . indexOf ( ' deselected ' ) > 0 ) . toBeTruthy ( ) ;%NWL%}%NWL%} ) ;%NWL%chart . filterAll ( ) ;%NWL%} ) ;%NWL%it ( ' reset link shown after slice selection ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%expect ( chart . select ( ' a . reset ' ) . style ( ' display ' ) ) . not . toEqual ( ' none ' ) ;%NWL%} ) ;%NWL%it ( ' filter info shown after slice selection ' , function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%6
var cls = d3 . select ( this ) . attr ( ' class ' ) ;%NWL%expect ( cls === null || cls === ' ' ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' filter through clicking ' , function ( )  {%NWL%it ( ' onClick should trigger filtering of according group ' , function ( )  {%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%expect ( chart . filter ( ) ) . toEqual ( ' 22 ' ) ;%NWL%} ) ;%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%7
expect ( cls === null || cls === ' ' ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' filter through clicking ' , function ( )  {%NWL%it ( ' onClick should trigger filtering of according group ' , function ( )  {%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%expect ( chart . filter ( ) ) . toEqual ( ' 22 ' ) ;%NWL%} ) ;%NWL%it ( ' onClick should reset filter if clicked twice ' , function ( )  {%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%6
describe ( ' filter through clicking ' , function ( )  {%NWL%it ( ' onClick should trigger filtering of according group ' , function ( )  {%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%expect ( chart . filter ( ) ) . toEqual ( ' 22 ' ) ;%NWL%} ) ;%NWL%it ( ' onClick should reset filter if clicked twice ' , function ( )  {%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%expect ( chart . filter ( ) ) . toEqual ( null ) ;%NWL%} ) ;%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%2
describe ( ' with cap ( 1 ) ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%countryChart . cap ( 1 ) . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should show the top value , and others ' , function ( )  {%NWL%expect ( countryChart . data ( ) . map ( dc . pluck ( ' key ' ) ) ) . toEqual ( [ ' CA ' ,  ' Others ' ] ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with default ordering and cap ( 1 ) ' , function ( )  {%NWL%countryChart . cap ( 1 ) . redraw ( ) ;%NWL%2
} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' redraw after empty selection ' , function ( )  {%NWL%var chart;%NWL%beforeEach ( function ( )  {%NWL%chart = buildChart ( ' pie - chart2 ' ) ;%NWL%dateDimension . filter ( [ makeDate ( 2010 , 0 , 1 ) , makeDate ( 2010 , 0 , 3 ) ] ) ;%NWL%chart . redraw ( ) ;%NWL%chart . redraw ( ) ;%NWL%9
var event;%NWL%beforeEach ( function ( )  {%NWL%event = document . createEvent ( ' MouseEvents ' ) ;%NWL%event . initEvent ( ' click ' , true , true ) ;%NWL%chart . selectAll ( ' . pie - slice path ' ) [ 0 ] [ 2 ] . dispatchEvent ( event ) ;%NWL%} ) ;%NWL%it ( ' should filter three smallest ' , function ( )  {%NWL%expect ( chart . filters ( ) ) . toEqual ( [ ' 33 ' ,  ' 55 ' ,  ' 66 ' , ' small ' ] ) ;%NWL%} ) ;%NWL%describe ( ' clicking again ' , function ( )  {%NWL%chart . selectAll ( ' . pie - slice path ' ) [ 0 ] [ 2 ] . dispatchEvent ( event ) ;%NWL%4
beforeEach ( function ( )  {%NWL%chart = buildChart ( ' chart - renderlet ' ) ;%NWL%chart . on ( ' renderlet ' , function ( )  {%NWL%chart . selectAll ( ' path ' ) . attr ( ' fill ' ,  ' red ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' custom renderlet should be invoked with render ' , function ( )  {%NWL%chart . render ( ) ;%NWL%expect ( chart . selectAll ( ' path ' ) . attr ( ' fill ' ) ) . toEqual ( ' red ' ) ;%NWL%} ) ;%NWL%chart . redraw ( ) ;%NWL%7
it ( ' hovering on label should highlight corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' #pie - chart - external - labeling text . pie - slice ' ) . each ( function ( d , i )  {%NWL%var legendItem = d3 . select ( this ) ;%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) , i ) ;%NWL%expect ( chart . select ( ' g . pie - slice . _ '  + i ) . classed ( ' highlight ' ) ) . toBeTruthy ( ) ;%NWL%legendItem . on ( ' mouseout ' ) ( legendItem . datum ( ) ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' unhovering label removes highlight from corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' #pie - chart - external - labeling text . pie - slice ' ) . each ( function ( d , i )  {%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) , i ) ;%NWL%3
it ( ' unhovering label removes highlight from corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' #pie - chart - external - labeling text . pie - slice ' ) . each ( function ( d , i )  {%NWL%var legendItem = d3 . select ( this ) ;%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) , i ) ;%NWL%legendItem . on ( ' mouseout ' ) ( legendItem . datum ( ) , i ) ;%NWL%expect ( chart . select ( ' . pie - slice . _ '  + i ) . classed ( ' highlight ' ) ) . toBeFalsy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' hovering on path should highlight corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' #pie - chart - external - labeling polyline . pie - path ' ) . each ( function ( d , i )  {%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) , i ) ;%NWL%3
it ( ' hovering on path should highlight corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' #pie - chart - external - labeling polyline . pie - path ' ) . each ( function ( d , i )  {%NWL%var legendItem = d3 . select ( this ) ;%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) , i ) ;%NWL%expect ( chart . select ( ' g . pie - slice . _ '  + i ) . classed ( ' highlight ' ) ) . toBeTruthy ( ) ;%NWL%legendItem . on ( ' mouseout ' ) ( legendItem . datum ( ) ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' unhovering label removes highlight from corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' #pie - chart - external - labeling polyline . pie - path ' ) . each ( function ( d , i )  {%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) , i ) ;%NWL%3
it ( ' hovering on items should highlight corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' g . dc - legend g . dc - legend - item ' ) . each ( function ( d , i )  {%NWL%var legendItem = d3 . select ( this ) ;%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) ) ;%NWL%expect ( chart . select ( ' g . pie - slice . _ '  + i ) . classed ( ' highlight ' ) ) . toBeTruthy ( ) ;%NWL%legendItem . on ( ' mouseout ' ) ( legendItem . datum ( ) ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' unhovering removes highlight from corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' g . dc - legend g . dc - legend - item ' ) . each ( function ( d , i )  {%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) ) ;%NWL%3
chart . selectAll ( ' g . dc - legend g . dc - legend - item ' ) . each ( function ( d , i )  {%NWL%var legendItem = d3 . select ( this ) ;%NWL%legendItem . on ( ' mouseover ' ) ( legendItem . datum ( ) ) ;%NWL%expect ( chart . select ( ' g . pie - slice . _ '  + i ) . classed ( ' highlight ' ) ) . toBeTruthy ( ) ;%NWL%legendItem . on ( ' mouseout ' ) ( legendItem . datum ( ) ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' unhovering removes highlight from corresponding slice ' , function ( )  {%NWL%chart . selectAll ( ' g . dc - legend g . dc - legend - item ' ) . each ( function ( d , i )  {%NWL%var legendItem = d3 . select ( this ) ;%NWL%legendItem . on ( ' mouseout ' ) ( legendItem . datum ( ) ) ;%NWL%4
chart . group ( positiveGroupHolder . group ) ;%NWL%chart . elasticX ( false ) ;%NWL%chart . x ( d3 . scale . log ( ) ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should render valid rect widths ' , function ( )  {%NWL%expect ( chart . select ( ' g . row rect ' ) . attr ( ' width ' ) ) . toBeWithinDelta ( 1 , 0 . 5 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with a fixedBarHeight ' , function ( )  {%NWL%chart . group ( positiveGroupHolder . group ) ;%NWL%0
chart . elasticX ( false ) ;%NWL%chart . x ( d3 . scale . log ( ) ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should render valid rect widths ' , function ( )  {%NWL%expect ( chart . select ( ' g . row rect ' ) . attr ( ' width ' ) ) . toBeWithinDelta ( 1 , 0 . 5 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with a fixedBarHeight ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . elasticX ( false ) ;%NWL%0
chart . x ( d3 . scale . log ( ) ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should render valid rect widths ' , function ( )  {%NWL%expect ( chart . select ( ' g . row rect ' ) . attr ( ' width ' ) ) . toBeWithinDelta ( 1 , 0 . 5 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' with a fixedBarHeight ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . group ( positiveGroupHolder . group ) ;%NWL%chart . x ( d3 . scale . log ( ) ) ;%NWL%0
describe ( ' re - rendering the chart ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should leave a single instance of the chart ' , function ( )  {%NWL%expect ( d3 . selectAll ( ' #row - chart svg ' ) . size ( ) ) . toBe ( 1 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' chart filters ' , function ( )  {%NWL%chart . render ( ) ;%NWL%2
describe ( ' filtering a row ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . filter ( ' 66 ' ) ;%NWL%chart . render ( ) ;%NWL%} ) ;%NWL%it ( ' should apply a filter to the chart ' , function ( )  {%NWL%expect ( chart . filter ( ) ) . toBe ( ' 66 ' ) ;%NWL%expect ( chart . hasFilter ( ) ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%it ( ' should highlight any selected rows ' , function ( )  {%NWL%chart . render ( ) ;%NWL%3
chart . render ( ) ;%NWL%data . dimension ( function ( d )  { return d . status; } ) . filter ( ' E ' ) ;%NWL%} ) ;%NWL%it ( ' should preserve the labels ' , function ( )  {%NWL%chart . selectAll ( ' svg g text . row ' ) . each ( function ( )  {%NWL%expect ( d3 . select ( this ) . text ( ) ) . not . toBe ( ' ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' clicking on a row ' , function ( )  {%NWL%chart . render ( ) ;%NWL%0
} ) ;%NWL%describe ( ' clicking on a row ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%} ) ;%NWL%it ( ' should filter the corresponding group ' , function ( )  {%NWL%expect ( chart . filter ( ) ) . toBe ( chart . group ( ) . all ( ) [ 0 ] . key ) ;%NWL%} ) ;%NWL%describe ( ' clicking again ' , function ( )  {%NWL%chart . onClick ( chart . group ( ) . all ( ) [ 0 ] ) ;%NWL%4
expect ( chart . data ( ) . map ( dc . pluck ( ' value ' ) ) . sort ( d3 . ascending ) ) . toEqual ( chart . data ( ) . map ( dc . pluck ( ' value ' ) ) ) ;%NWL%} ) ;%NWL%it ( ' should order keys when by keys ' , function ( )  {%NWL%chart . ordering ( dc . pluck ( ' key ' ) ) ;%NWL%expect ( chart . data ( ) . map ( dc . pluck ( ' key ' ) ) . sort ( d3 . ascending ) ) . toEqual ( chart . data ( ) . map ( dc . pluck ( ' key ' ) ) ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' redrawing after an empty selection ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%chart . redraw ( ) ;%NWL%9
it ( ' should order keys when by keys ' , function ( )  {%NWL%chart . ordering ( dc . pluck ( ' key ' ) ) ;%NWL%expect ( chart . data ( ) . map ( dc . pluck ( ' key ' ) ) . sort ( d3 . ascending ) ) . toEqual ( chart . data ( ) . map ( dc . pluck ( ' key ' ) ) ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' redrawing after an empty selection ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%groupHolder . dimension . filter ( [ makeDate ( 2010 , 0 , 1 ) , makeDate ( 2010 , 0 , 3 ) ] ) ;%NWL%chart . redraw ( ) ;%NWL%chart . redraw ( ) ;%NWL%7
groupHolder . dimension . filter ( [ makeDate ( 2012 , 0 , 1 ) , makeDate ( 2012 , 11 , 30 ) ] ) ;%NWL%chart . redraw ( ) ;%NWL%} ) ;%NWL%it ( ' should restore the row chart ' , function ( )  {%NWL%chart . selectAll ( ' g . row rect ' ) . each ( function ( p )  {%NWL%expect ( d3 . select ( this ) . attr ( ' width ' ) . indexOf ( ' NaN ' ) < 0 ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' removing all the data and restoring the data ' , function ( )  {%NWL%chart . render ( ) ;%NWL%1
} ) ;%NWL%it ( ' should restore the row chart ' , function ( )  {%NWL%chart . selectAll ( ' g . row rect ' ) . each ( function ( p )  {%NWL%expect ( d3 . select ( this ) . attr ( ' width ' ) . indexOf ( ' NaN ' ) < 0 ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' removing all the data and restoring the data ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%chart . redraw ( ) ;%NWL%9
chart . selectAll ( ' g . row rect ' ) . each ( function ( p )  {%NWL%expect ( d3 . select ( this ) . attr ( ' width ' ) . indexOf ( ' NaN ' ) < 0 ) . toBeTruthy ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' removing all the data and restoring the data ' , function ( )  {%NWL%beforeEach ( function ( )  {%NWL%chart . render ( ) ;%NWL%chart . group ( { all: function ( )  { return [ ] ; } } ) ;%NWL%chart . redraw ( ) ;%NWL%chart . redraw ( ) ;%NWL%7
} ) ;%NWL%it ( ' can have size set ' , function ( )  {%NWL%chart . numberVisible ( 10 ) . redraw ( ) ;%NWL%expect ( chart . selectAll ( ' select ' ) . attr ( ' size ' ) ) . toEqual ( ' 10 ' ) ;%NWL%} ) ;%NWL%it ( ' creates prompt option with empty value ' , function ( )  {%NWL%var option = chart . selectAll ( ' option ' ) [ 0 ] [ 0 ] ;%NWL%expect ( option ) . not . toBeNull ( ) ;%NWL%expect ( option . value ) . toEqual ( ' ' ) ;%NWL%} ) ;%NWL%var option = chart . selectAll ( ' option ' ) [ 0 ] [ 0 ] ;%NWL%6
lastOption = getOption ( chart , lastIndex ) ;%NWL%expect ( lastOption . text ) . toEqual ( ' Mississippi: 2 ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' regular single select ' , function ( )  {%NWL%describe ( ' selecting an option ' , function ( )  {%NWL%it ( ' filters dimension based on selected option\ ' s value ' , function ( )  {%NWL%chart . onChange ( stateGroup . all ( ) [ 0 ] . key ) ;%NWL%expect ( chart . filter ( ) ) . toEqual ( ' California ' ) ;%NWL%} ) ;%NWL%chart . onChange ( stateGroup . all ( ) [ 0 ] . key ) ;%NWL%7
it ( ' filters dimension based on selected option\ ' s value ' , function ( )  {%NWL%chart . onChange ( stateGroup . all ( ) [ 0 ] . key ) ;%NWL%expect ( chart . filter ( ) ) . toEqual ( ' California ' ) ;%NWL%} ) ;%NWL%it ( ' replaces filter on second selection ' , function ( )  {%NWL%chart . onChange ( stateGroup . all ( ) [ 0 ] . key ) ;%NWL%chart . onChange ( stateGroup . all ( ) [ 1 ] . key ) ;%NWL%expect ( chart . filter ( ) ) . toEqual ( ' Colorado ' ) ;%NWL%expect ( chart . filters ( ) . length ) . toEqual ( 1 ) ;%NWL%} ) ;%NWL%chart . onChange ( stateGroup . all ( ) [ 0 ] . key ) ;%NWL%1
chart . onChange ( null ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( ' filterDisplayed ' , function ( )  {%NWL%it ( ' only displays options whose value > 0 by default ' , function ( )  {%NWL%regionDimension . filter ( ' South ' ) ;%NWL%chart . redraw ( ) ;%NWL%expect ( chart . selectAll ( ' option . dc - select - option ' ) [ 0 ] . length ) . toEqual ( 1 ) ;%NWL%expect ( getOption ( chart , 0 ) . text ) . toEqual ( ' California: 2 ' ) ;%NWL%} ) ;%NWL%regionDimension . filter ( ' South ' ) ;%NWL%5
timerString = " analyzing time periods " ;%NWL%print . time ( timerString ) ;%NWL%}%NWL%vars . data . time . values = uniques ( vars . data . value , vars . time . value , fetchValue , vars ) ;%NWL%vars . data . time . values . sort ( function ( a , b ) { return a - b; } ) ;%NWL%var step = [ ] ;%NWL%vars . data . time . values . forEach ( function ( y , i ) {%NWL%if ( i !== 0 )  {%NWL%var prev = vars . data . time . values [ i - 1 ] ;%NWL%step . push ( y - prev ) ;%NWL%vars . data . time . total = y - vars . data . time . values [ 0 ] ;%NWL%3
var step = [ ] ;%NWL%vars . data . time . values . forEach ( function ( y , i ) {%NWL%if ( i !== 0 )  {%NWL%var prev = vars . data . time . values [ i - 1 ] ;%NWL%step . push ( y - prev ) ;%NWL%if ( i === vars . data . time . values . length - 1 )  {%NWL%vars . data . time . total = y - vars . data . time . values [ 0 ] ;%NWL%}%NWL%}%NWL%} ) ;%NWL%vars . data . time . step = step;%NWL%6
var prev = vars . data . time . values [ i - 1 ] ;%NWL%step . push ( y - prev ) ;%NWL%if ( i === vars . data . time . values . length - 1 )  {%NWL%vars . data . time . total = y - vars . data . time . values [ 0 ] ;%NWL%}%NWL%}%NWL%} ) ;%NWL%step = d3 . min ( step ) ;%NWL%vars . data . time . step = step;%NWL%var periods = [ " Milliseconds " , " Seconds " , " Minutes " , " Hours " , " Date " , " Month " , " FullYear " ] ,%NWL%vars . data . time . periods = periods;%NWL%3
multi . push ( [ format , functions [ p ] ] ) ;%NWL%}%NWL%vars . data . time . format = d3 . locale ( locale . format ) . timeFormat ( getFormat ( stepType , totalType ) ) ;%NWL%if ( multi . length > 1 )  {%NWL%multi [ multi . length - 1 ] [ 1 ] = function ( d )  { return true; }%NWL%vars . data . time . multiFormat = d3 . locale ( locale . format ) . timeFormat . multi ( multi ) ;%NWL%}%NWL%else {%NWL%vars . data . time . multiFormat = vars . data . time . format;%NWL%}%NWL%vars . data . time . ticks = [ ] ;%NWL%8
{ colData: 3 , rowData: 1 , colorData: 5 } ,%NWL%{ colData: 3 , rowData: 2 , colorData: 6 }%NWL%] ;%NWL%var colorData2;%NWL%beforeEach ( function ( )  {%NWL%colorData2 = crossfilter ( colorRows2 ) ;%NWL%chart . brushOn ( false ) ;%NWL%chart . render ( ) ;%NWL%var dimensionData = colorData2 . dimension ( function ( d )  { return [ + d . colData ,  + d . rowData ] ; } ) ;%NWL%var groupData = dimensionData . group ( ) . reduceSum ( function ( d )  { return + d . colorData; } ) ;%NWL%chart . redraw ( ) ;%NWL%7
" { \ " value\ " :\ " 55\ " , \ " nvalue\ " :\ " - 3\ " , \ " countrycode\ " :\ " US\ " , \ " state\ " :\ " Oklahoma\ " , \ " status\ " :\ " F\ " , \ " id\ " :10 , \ " region\ " :\ " \ " , \ " date\ " :\ " 2012 - 06 - 10T16:10:39Z\ " } "  +%NWL%" ] " ) ;%NWL%fixture . forEach ( dateCleaner ) ;%NWL%return fixture;%NWL%}%NWL%function loadDateFixture2 ( )  {%NWL%var fixture = JSON . parse (%NWL%" [ "  +%NWL%" { \ " value\ " :\ " 11\ " , \ " nvalue\ " :\ " - 4\ " , \ " countrycode\ " :\ " UK\ " , \ " state\ " :\ " Liverpool\ " , \ " status\ " :\ " T\ " , \ " id\ " :11 , \ " region\ " :\ " South\ " , \ " date\ " :\ " 2012 - 05 - 25T16:20:09Z\ " } ,  "  +%NWL%" { \ " value\ " :\ " 76\ " , \ " nvalue\ " :\ " - 1\ " , \ " countrycode\ " :\ " UK\ " , \ " state\ " :\ " London\ " , \ " status\ " :\ " F\ " , \ " id\ " :12 , \ " region\ " :\ " \ " , \ " date\ " :\ " 2012 - 06 - 10T16:20:39Z\ " } "  +%NWL%fixture . forEach ( dateCleaner ) ;%NWL%2
}%NWL%} ;%NWL%function removePassingTests ( suites )  {%NWL%return suites . filter ( specFailed )%NWL%. map ( mapSuite ) ;%NWL%}%NWL%function mapSuite ( suite )  {%NWL%var result = { } ;%NWL%for ( var s in suite )  {%NWL%result [ s ] = suite [ s ] ;%NWL%result . specs = suite . specs . filter ( specFailed ) ;%NWL%9
} ;%NWL%function removePassingTests ( suites )  {%NWL%return suites . filter ( specFailed )%NWL%. map ( mapSuite ) ;%NWL%}%NWL%function mapSuite ( suite )  {%NWL%var result = { } ;%NWL%for ( var s in suite )  {%NWL%result [ s ] = suite [ s ] ;%NWL%}%NWL%result . suites = removePassingTests ( suite . suites ) ;%NWL%8
labels . attr ( ' cursor ' ,  ' pointer ' ) ;%NWL%}%NWL%dc . transition ( labels , _chart . transitionDuration ( ) , _chart . transitionDelay ( ) )%NWL%. attr ( ' x ' , function ( d )  {%NWL%var x = _chart . x ( ) ( d . x ) ;%NWL%if ( !_centerBar )  {%NWL%x + = _barWidth / 2;%NWL%}%NWL%return dc . utils . safeNumber ( x ) ;%NWL%} )%NWL%var y = _chart . y ( ) ( d . y + d . y0 ) ;%NWL%4
. attr ( ' x ' , function ( d )  {%NWL%var x = _chart . x ( ) ( d . x ) ;%NWL%if ( _centerBar )  {%NWL%x - = _barWidth / 2;%NWL%}%NWL%if ( _chart . isOrdinal ( ) && _gap !== undefined )  {%NWL%x + = _gap / 2;%NWL%}%NWL%return dc . utils . safeNumber ( x ) ;%NWL%} )%NWL%var y = _chart . y ( ) ( d . y + d . y0 ) ;%NWL%1
bars . classed ( dc . constants . SELECTED_CLASS , false ) ;%NWL%bars . classed ( dc . constants . DESELECTED_CLASS , false ) ;%NWL%}%NWL%} else {%NWL%if ( !_chart . brushIsEmpty ( extent ) )  {%NWL%var start = extent [ 0 ] ;%NWL%var end = extent [ 1 ] ;%NWL%bars . classed ( dc . constants . DESELECTED_CLASS , function ( d )  {%NWL%return d . x < start || d . x >= end;%NWL%} ) ;%NWL%bars . classed ( dc . constants . DESELECTED_CLASS , false ) ;%NWL%1
return inv ? !match : match;%NWL%} ;%NWL%}%NWL%_chart . legendHighlight = function ( d )  {%NWL%if ( !_chart . isLegendableHidden ( d ) )  {%NWL%_chart . g ( ) . selectAll ( ' rect . bar ' )%NWL%. classed ( ' highlight ' , colorFilter ( d . color ) )%NWL%. classed ( ' fadeout ' , colorFilter ( d . color , true ) ) ;%NWL%}%NWL%} ;%NWL%_chart . g ( ) . selectAll ( ' rect . bar ' )%NWL%5
' renderlet ' ,%NWL%' pretransition ' ) ;%NWL%var _legend;%NWL%var _commitHandler;%NWL%var _filters = [ ] ;%NWL%var _filterHandler = function ( dimension , filters )  {%NWL%if ( filters . length === 0 )  {%NWL%dimension . filter ( null ) ;%NWL%} else if ( filters . length === 1 && !filters [ 0 ] . isFiltered )  {%NWL%dimension . filterExact ( filters [ 0 ] ) ;%NWL%dimension . filterRange ( filters [ 0 ] ) ;%NWL%9
}%NWL%_dimension = dimension;%NWL%_chart . expireCache ( ) ;%NWL%return _chart;%NWL%} ;%NWL%%NWL%_chart . data = function ( callback )  {%NWL%if ( !arguments . length )  {%NWL%return _data . call ( _chart , _group ) ;%NWL%}%NWL%_chart . expireCache ( ) ;%NWL%2
_data = d3 . functor ( callback ) ;%NWL%_chart . expireCache ( ) ;%NWL%return _chart;%NWL%} ;%NWL%%NWL%_chart . group = function ( group , name )  {%NWL%if ( !arguments . length )  {%NWL%return _group;%NWL%}%NWL%_group = group;%NWL%_chart . expireCache ( ) ;%NWL%1
_chart . _groupName = name;%NWL%_chart . expireCache ( ) ;%NWL%return _chart;%NWL%} ;%NWL%%NWL%_chart . ordering = function ( orderFunction )  {%NWL%if ( !arguments . length )  {%NWL%return _ordering;%NWL%}%NWL%_ordering = orderFunction;%NWL%_chart . expireCache ( ) ;%NWL%1
if ( _legend )  {%NWL%_legend . render ( ) ;%NWL%}%NWL%_chart . _activateRenderlets ( ' postRender ' ) ;%NWL%return result;%NWL%} ;%NWL%_chart . _activateRenderlets = function ( event )  {%NWL%_listeners . pretransition ( _chart ) ;%NWL%if ( _chart . transitionDuration ( ) > 0 && _svg )  {%NWL%_svg . transition ( ) . duration ( _chart . transitionDuration ( ) ) . delay ( _chart . transitionDelay ( ) )%NWL%_listeners . renderlet ( _chart ) ;%NWL%7
_chart . _activateRenderlets = function ( event )  {%NWL%_listeners . pretransition ( _chart ) ;%NWL%if ( _chart . transitionDuration ( ) > 0 && _svg )  {%NWL%_svg . transition ( ) . duration ( _chart . transitionDuration ( ) ) . delay ( _chart . transitionDelay ( ) )%NWL%. each ( ' end ' , function ( )  {%NWL%_listeners . renderlet ( _chart ) ;%NWL%if ( event )  {%NWL%_listeners [ event ] ( _chart ) ;%NWL%}%NWL%} ) ;%NWL%_listeners . renderlet ( _chart ) ;%NWL%1
} ) ;%NWL%} else {%NWL%_listeners . renderlet ( _chart ) ;%NWL%if ( event )  {%NWL%_listeners [ event ] ( _chart ) ;%NWL%}%NWL%}%NWL%} ;%NWL%%NWL%_chart . redraw = function ( )  {%NWL%_listeners . preRedraw ( _chart ) ;%NWL%2
%NWL%_chart . redrawGroup = function ( )  {%NWL%if ( _commitHandler )  {%NWL%_commitHandler ( false , function ( error , result )  {%NWL%if ( error )  {%NWL%console . log ( error ) ;%NWL%} else {%NWL%dc . redrawAll ( _chart . chartGroup ( ) ) ;%NWL%}%NWL%} ) ;%NWL%dc . redrawAll ( _chart . chartGroup ( ) ) ;%NWL%7
dc . redrawAll ( _chart . chartGroup ( ) ) ;%NWL%}%NWL%return _chart;%NWL%} ;%NWL%%NWL%_chart . renderGroup = function ( )  {%NWL%if ( _commitHandler )  {%NWL%_commitHandler ( false , function ( error , result )  {%NWL%if ( error )  {%NWL%console . log ( error ) ;%NWL%dc . renderAll ( _chart . chartGroup ( ) ) ;%NWL%0
%NWL%_chart . renderGroup = function ( )  {%NWL%if ( _commitHandler )  {%NWL%_commitHandler ( false , function ( error , result )  {%NWL%if ( error )  {%NWL%console . log ( error ) ;%NWL%} else {%NWL%dc . renderAll ( _chart . chartGroup ( ) ) ;%NWL%}%NWL%} ) ;%NWL%dc . renderAll ( _chart . chartGroup ( ) ) ;%NWL%7
if ( _hasFilterHandler ( filters , filter ) )  {%NWL%filters = _removeFilterHandler ( filters , filter ) ;%NWL%} else {%NWL%filters = _addFilterHandler ( filters , filter ) ;%NWL%}%NWL%}%NWL%_filters = applyFilters ( filters ) ;%NWL%_chart . _invokeFilteredListener ( filter ) ;%NWL%if ( _root !== null && _chart . hasFilter ( ) )  {%NWL%_chart . turnOnControls ( ) ;%NWL%_chart . turnOffControls ( ) ;%NWL%9
return _filters;%NWL%} ;%NWL%_chart . highlightSelected = function ( e )  {%NWL%d3 . select ( e ) . classed ( dc . constants . SELECTED_CLASS , true ) ;%NWL%d3 . select ( e ) . classed ( dc . constants . DESELECTED_CLASS , false ) ;%NWL%} ;%NWL%_chart . fadeDeselected = function ( e )  {%NWL%d3 . select ( e ) . classed ( dc . constants . SELECTED_CLASS , false ) ;%NWL%d3 . select ( e ) . classed ( dc . constants . DESELECTED_CLASS , true ) ;%NWL%} ;%NWL%d3 . select ( e ) . classed ( dc . constants . SELECTED_CLASS , false ) ;%NWL%7
} ;%NWL%_chart . highlightSelected = function ( e )  {%NWL%d3 . select ( e ) . classed ( dc . constants . SELECTED_CLASS , true ) ;%NWL%d3 . select ( e ) . classed ( dc . constants . DESELECTED_CLASS , false ) ;%NWL%} ;%NWL%_chart . fadeDeselected = function ( e )  {%NWL%d3 . select ( e ) . classed ( dc . constants . SELECTED_CLASS , false ) ;%NWL%d3 . select ( e ) . classed ( dc . constants . DESELECTED_CLASS , true ) ;%NWL%} ;%NWL%_chart . resetHighlight = function ( e )  {%NWL%d3 . select ( e ) . classed ( dc . constants . DESELECTED_CLASS , false ) ;%NWL%3
} ,  ' chart . renderlet has been deprecated .  Please use chart . on ( " renderlet . <renderletKey> " , renderletFunction ) ' ) ;%NWL%%NWL%_chart . chartGroup = function ( chartGroup )  {%NWL%if ( !arguments . length )  {%NWL%return _chartGroup;%NWL%}%NWL%if ( !_isChild )  {%NWL%dc . deregisterChart ( _chart , _chartGroup ) ;%NWL%}%NWL%_chartGroup = chartGroup;%NWL%dc . registerChart ( _chart , _chartGroup ) ;%NWL%7
removeBoxes ( boxesG ) ;%NWL%_chart . fadeDeselectedArea ( ) ;%NWL%} ;%NWL%function renderBoxes ( boxesG )  {%NWL%var boxesGEnter = boxesG . enter ( ) . append ( ' g ' ) ;%NWL%boxesGEnter%NWL%. attr ( ' class ' ,  ' box ' )%NWL%. attr ( ' transform ' , boxTransform )%NWL%. call ( _box )%NWL%. on ( ' click ' , function ( d )  {%NWL%_chart . redrawGroup ( ) ;%NWL%1
}%NWL%function removeBoxes ( boxesG )  {%NWL%boxesG . exit ( ) . remove ( ) . call ( _box ) ;%NWL%}%NWL%_chart . fadeDeselectedArea = function ( )  {%NWL%if ( _chart . hasFilter ( ) )  {%NWL%if ( _chart . isOrdinal ( ) )  {%NWL%_chart . g ( ) . selectAll ( ' g . box ' ) . each ( function ( d )  {%NWL%if ( _chart . isSelectedNode ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%_chart . fadeDeselected ( this ) ;%NWL%9
_chart . g ( ) . selectAll ( ' g . box ' ) . each ( function ( d )  {%NWL%if ( _chart . isSelectedNode ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%} else {%NWL%_chart . fadeDeselected ( this ) ;%NWL%}%NWL%} ) ;%NWL%} else {%NWL%var extent = _chart . brush ( ) . extent ( ) ;%NWL%var start = extent [ 0 ] ;%NWL%var keyAccessor = _chart . keyAccessor ( ) ;%NWL%8
_chart . fadeDeselected ( this ) ;%NWL%}%NWL%} ) ;%NWL%} else {%NWL%var extent = _chart . brush ( ) . extent ( ) ;%NWL%var start = extent [ 0 ] ;%NWL%var end = extent [ 1 ] ;%NWL%var keyAccessor = _chart . keyAccessor ( ) ;%NWL%_chart . g ( ) . selectAll ( ' g . box ' ) . each ( function ( d )  {%NWL%var key = keyAccessor ( d ) ;%NWL%_chart . fadeDeselected ( this ) ;%NWL%0
} ) ;%NWL%} else {%NWL%var extent = _chart . brush ( ) . extent ( ) ;%NWL%var start = extent [ 0 ] ;%NWL%var end = extent [ 1 ] ;%NWL%var keyAccessor = _chart . keyAccessor ( ) ;%NWL%_chart . g ( ) . selectAll ( ' g . box ' ) . each ( function ( d )  {%NWL%var key = keyAccessor ( d ) ;%NWL%if ( key < start || key >= end )  {%NWL%_chart . fadeDeselected ( this ) ;%NWL%_chart . highlightSelected ( this ) ;%NWL%9
_chart . g ( ) . selectAll ( ' g . box ' ) . each ( function ( d )  {%NWL%var key = keyAccessor ( d ) ;%NWL%if ( key < start || key >= end )  {%NWL%_chart . fadeDeselected ( this ) ;%NWL%} else {%NWL%_chart . highlightSelected ( this ) ;%NWL%}%NWL%} ) ;%NWL%}%NWL%} else {%NWL%_chart . resetHighlight ( this ) ;%NWL%3
_chart . calculateRadiusDomain ( ) ;%NWL%_chart . r ( ) . range ( [ _chart . MIN_RADIUS , _chart . xAxisLength ( )  * _chart . maxBubbleRelativeSize ( ) ] ) ;%NWL%var data = _chart . data ( ) ;%NWL%var bubbleG = _chart . chartBodyG ( ) . selectAll ( ' g . '  + _chart . BUBBLE_NODE_CLASS )%NWL%. data ( data , function ( d )  { return d . key; } ) ;%NWL%if ( _chart . sortBubbleSize ( ) )  {%NWL%bubbleG . order ( ) ;%NWL%}%NWL%renderNodes ( bubbleG ) ;%NWL%updateNodes ( bubbleG ) ;%NWL%_chart . fadeDeselectedArea ( ) ;%NWL%0
function removeNodes ( bubbleG )  {%NWL%bubbleG . exit ( ) . remove ( ) ;%NWL%}%NWL%function bubbleX ( d )  {%NWL%var x = _chart . x ( ) ( _chart . keyAccessor ( ) ( d ) ) ;%NWL%if ( isNaN ( x ) )  {%NWL%x = 0;%NWL%}%NWL%return x;%NWL%}%NWL%var y = _chart . y ( ) ( _chart . valueAccessor ( ) ( d ) ) ;%NWL%4
} ) ;%NWL%return min;%NWL%} ;%NWL%_chart . rMax = function ( )  {%NWL%var max = d3 . max ( _chart . data ( ) , function ( e )  {%NWL%return _chart . radiusValueAccessor ( ) ( e ) ;%NWL%} ) ;%NWL%return max;%NWL%} ;%NWL%_chart . bubbleR = function ( d )  {%NWL%var r = _chart . r ( ) ( value ) ;%NWL%4
} ;%NWL%_chart . _doRenderTitles = function ( g )  {%NWL%if ( _chart . renderTitle ( ) )  {%NWL%var title = g . select ( ' title ' ) ;%NWL%if ( title . empty ( ) )  {%NWL%g . append ( ' title ' ) . text ( titleFunction ) ;%NWL%}%NWL%}%NWL%} ;%NWL%_chart . doUpdateTitles = function ( g )  {%NWL%g . select ( ' title ' ) . text ( titleFunction ) ;%NWL%5
return _maxBubbleRelativeSize;%NWL%}%NWL%_maxBubbleRelativeSize = relativeSize;%NWL%return _chart;%NWL%} ;%NWL%_chart . fadeDeselectedArea = function ( )  {%NWL%if ( _chart . hasFilter ( ) )  {%NWL%_chart . selectAll ( ' g . '  + _chart . BUBBLE_NODE_CLASS ) . each ( function ( d )  {%NWL%if ( _chart . isSelectedNode ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%_chart . fadeDeselected ( this ) ;%NWL%9
_chart . fadeDeselectedArea = function ( )  {%NWL%if ( _chart . hasFilter ( ) )  {%NWL%_chart . selectAll ( ' g . '  + _chart . BUBBLE_NODE_CLASS ) . each ( function ( d )  {%NWL%if ( _chart . isSelectedNode ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%} else {%NWL%_chart . fadeDeselected ( this ) ;%NWL%}%NWL%} ) ;%NWL%} else {%NWL%_chart . resetHighlight ( this ) ;%NWL%4
}%NWL%nodeG . datum ( data [ point . name ] ) ;%NWL%return nodeG;%NWL%}%NWL%_chart . _doRedraw = function ( )  {%NWL%updateBubbles ( ) ;%NWL%_chart . fadeDeselectedArea ( ) ;%NWL%return _chart;%NWL%} ;%NWL%function updateBubbles ( )  {%NWL%_chart . calculateRadiusDomain ( ) ;%NWL%6
var child = _children [ i ] ;%NWL%child . brush ( _chart . brush ( ) ) ;%NWL%child . fadeDeselectedArea ( ) ;%NWL%}%NWL%} ;%NWL%%NWL%_chart . rightYAxisLabel = function ( rightYAxisLabel , padding )  {%NWL%if ( !arguments . length )  {%NWL%return _rightYAxisLabel;%NWL%}%NWL%_chart . margins ( ) . right - = _rightYAxisLabelPadding;%NWL%6
child . fadeDeselectedArea ( ) ;%NWL%}%NWL%} ;%NWL%%NWL%_chart . rightYAxisLabel = function ( rightYAxisLabel , padding )  {%NWL%if ( !arguments . length )  {%NWL%return _rightYAxisLabel;%NWL%}%NWL%_rightYAxisLabel = rightYAxisLabel;%NWL%_chart . margins ( ) . right - = _rightYAxisLabelPadding;%NWL%_chart . margins ( ) . right + = _rightYAxisLabelPadding;%NWL%4
}%NWL%_rightY = yScale;%NWL%_chart . rescale ( ) ;%NWL%return _chart;%NWL%} ;%NWL%%NWL%_chart . alignYAxes = function ( alignYAxes )  {%NWL%if ( !arguments . length )  {%NWL%return _alignYAxes;%NWL%}%NWL%_chart . rescale ( ) ;%NWL%2
} ,  [ ] ) ;%NWL%} ;%NWL%_chart . legendHighlight = function ( d )  {%NWL%for ( var j = 0; j < _children . length; + + j )  {%NWL%var child = _children [ j ] ;%NWL%child . legendHighlight ( d ) ;%NWL%}%NWL%} ;%NWL%_chart . legendReset = function ( d )  {%NWL%for ( var j = 0; j < _children . length; + + j )  {%NWL%child . legendReset ( d ) ;%NWL%5
var extent = _chart . extendBrush ( ) ;%NWL%_chart . redrawBrush ( _g , false ) ;%NWL%if ( _chart . brushIsEmpty ( extent ) )  {%NWL%dc . events . trigger ( function ( )  {%NWL%_chart . filter ( null ) ;%NWL%_chart . redrawGroup ( ) ;%NWL%} , dc . constants . EVENT_DELAY ) ;%NWL%} else {%NWL%var rangedFilter = dc . filters . RangedFilter ( extent [ 0 ] , extent [ 1 ] ) ;%NWL%dc . events . trigger ( function ( )  {%NWL%_chart . redrawGroup ( ) ;%NWL%5
var chartBodyClip = dc . utils . appendOrSelect ( defs ,  ' # '  + id ,  ' clipPath ' ) . attr ( ' id ' , id ) ;%NWL%var padding = _clipPadding * 2;%NWL%dc . utils . appendOrSelect ( chartBodyClip ,  ' rect ' )%NWL%. attr ( ' width ' , _chart . xAxisLength ( )  + padding )%NWL%. attr ( ' height ' , _chart . yAxisHeight ( )  + padding )%NWL%. attr ( ' transform ' ,  ' translate ( - '  + _clipPadding +  ' ,  - '  + _clipPadding +  ' ) ' ) ;%NWL%}%NWL%_chart . _preprocessData = function ( )  { } ;%NWL%_chart . _doRender = function ( )  {%NWL%_chart . resetSvg ( ) ;%NWL%_chart . _generateG ( ) ;%NWL%9
_chart . _preprocessData = function ( )  { } ;%NWL%_chart . _doRender = function ( )  {%NWL%_chart . resetSvg ( ) ;%NWL%_chart . _preprocessData ( ) ;%NWL%_chart . _generateG ( ) ;%NWL%generateClipPath ( ) ;%NWL%drawChart ( true ) ;%NWL%configureMouseZoom ( ) ;%NWL%return _chart;%NWL%} ;%NWL%_chart . _preprocessData ( ) ;%NWL%2
_chart . _preprocessData ( ) ;%NWL%drawChart ( false ) ;%NWL%generateClipPath ( ) ;%NWL%return _chart;%NWL%} ;%NWL%function drawChart ( render )  {%NWL%if ( _chart . isOrdinal ( ) )  {%NWL%_brushOn = false;%NWL%}%NWL%prepareXAxis ( _chart . g ( ) , render ) ;%NWL%_chart . plotData ( ) ;%NWL%0
generateClipPath ( ) ;%NWL%return _chart;%NWL%} ;%NWL%function drawChart ( render )  {%NWL%if ( _chart . isOrdinal ( ) )  {%NWL%_brushOn = false;%NWL%}%NWL%prepareXAxis ( _chart . g ( ) , render ) ;%NWL%_chart . _prepareYAxis ( _chart . g ( ) ) ;%NWL%_chart . plotData ( ) ;%NWL%_chart . renderXAxis ( _chart . g ( ) ) ;%NWL%8
function drawChart ( render )  {%NWL%if ( _chart . isOrdinal ( ) )  {%NWL%_brushOn = false;%NWL%}%NWL%prepareXAxis ( _chart . g ( ) , render ) ;%NWL%_chart . _prepareYAxis ( _chart . g ( ) ) ;%NWL%_chart . plotData ( ) ;%NWL%if ( _chart . elasticX ( ) || _resizing || render )  {%NWL%_chart . renderXAxis ( _chart . g ( ) ) ;%NWL%}%NWL%_chart . renderYAxis ( _chart . g ( ) ) ;%NWL%5
}%NWL%if ( render )  {%NWL%_chart . renderBrush ( _chart . g ( ) , false ) ;%NWL%} else {%NWL%_chart . redrawBrush ( _chart . g ( ) , _resizing ) ;%NWL%}%NWL%_chart . fadeDeselectedArea ( ) ;%NWL%_resizing = false;%NWL%}%NWL%function configureMouseZoom ( )  {%NWL%_chart . _enableMouseZoom ( ) ;%NWL%6
_chart . renderBrush ( _chart . g ( ) , false ) ;%NWL%} else {%NWL%_chart . redrawBrush ( _chart . g ( ) , _resizing ) ;%NWL%}%NWL%_chart . fadeDeselectedArea ( ) ;%NWL%_resizing = false;%NWL%}%NWL%function configureMouseZoom ( )  {%NWL%if ( _mouseZoomable )  {%NWL%_chart . _enableMouseZoom ( ) ;%NWL%_chart . _disableMouseZoom ( ) ;%NWL%4
var domain = _chart . x ( ) . domain ( ) ;%NWL%var domFilter = dc . filters . RangedFilter ( domain [ 0 ] , domain [ 1 ] ) ;%NWL%_chart . replaceFilter ( domFilter ) ;%NWL%_chart . rescale ( ) ;%NWL%_chart . redraw ( ) ;%NWL%if ( _rangeChart && !rangesEqual ( _chart . filter ( ) , _rangeChart . filter ( ) ) )  {%NWL%dc . events . trigger ( function ( )  {%NWL%_rangeChart . replaceFilter ( domFilter ) ;%NWL%_rangeChart . redraw ( ) ;%NWL%} ) ;%NWL%_chart . _invokeZoomedListener ( ) ;%NWL%3
_chart . replaceFilter ( domFilter ) ;%NWL%_chart . rescale ( ) ;%NWL%_chart . redraw ( ) ;%NWL%if ( _rangeChart && !rangesEqual ( _chart . filter ( ) , _rangeChart . filter ( ) ) )  {%NWL%dc . events . trigger ( function ( )  {%NWL%_rangeChart . replaceFilter ( domFilter ) ;%NWL%_rangeChart . redraw ( ) ;%NWL%} ) ;%NWL%}%NWL%_chart . _invokeZoomedListener ( ) ;%NWL%_chart . redrawGroup ( ) ;%NWL%1
}%NWL%if ( dc . _renderlet !== null )  {%NWL%dc . _renderlet ( group ) ;%NWL%}%NWL%} ;%NWL%dc . redrawAll = function ( group )  {%NWL%var charts = dc . chartRegistry . list ( group ) ;%NWL%for ( var i = 0; i < charts . length; + + i )  {%NWL%charts [ i ] . redraw ( ) ;%NWL%}%NWL%dc . _renderlet ( group ) ;%NWL%2
}%NWL%} ;%NWL%dc . afterTransition = function ( transition , callback )  {%NWL%if ( transition . empty ( ) || !transition . duration )  {%NWL%callback . call ( transition ) ;%NWL%} else {%NWL%var n = 0;%NWL%transition%NWL%. each ( function ( )  {  + + n; } )%NWL%. each ( ' end ' , function ( )  {%NWL%callback . call ( transition ) ;%NWL%4
} ;%NWL%HealthAndWealthDataSource . prototype . _setLoading = function ( isLoading )  {%NWL%if ( this . _isLoading !== isLoading )  {%NWL%this . _isLoading = isLoading;%NWL%this . _loading . raiseEvent ( this , isLoading ) ;%NWL%}%NWL%} ;%NWL%HealthAndWealthDataSource . prototype . _setInfoDialog = function ( time )  {%NWL%if ( Cesium . defined ( this . _selectedEntity ) )  {%NWL%var lifeExpectancy = this . _selectedEntity . lifeExpectancy . getValue ( time ) ;%NWL%var population = this . _selectedEntity . population . getValue ( time ) ;%NWL%9
if ( vars . depth . value === 0 )  {%NWL%m [ vars . color . value ] = vars . color . missing;%NWL%}%NWL%else {%NWL%m [ vars . color . value ] = fetchValue ( vars , p_id , vars . color . value , parent ) ;%NWL%}%NWL%}%NWL%if ( vars . icon . value )  {%NWL%m [ vars . icon . value ] = fetchValue ( vars , p_id , vars . icon . value , parent ) ;%NWL%}%NWL%m . d3plus . depth = vars . depth . value;%NWL%1
this . message = _msg;%NWL%this . toString = function ( )  {%NWL%return _msg;%NWL%} ;%NWL%this . stack = ( new Error ( ) ) . stack;%NWL%} ;%NWL%dc . errors . Exception . prototype = Object . create ( Error . prototype ) ;%NWL%dc . errors . Exception . prototype . constructor = dc . errors . Exception;%NWL%dc . errors . InvalidStateException = function ( )  {%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%dc . errors . InvalidStateException . prototype = Object . create ( dc . errors . Exception . prototype ) ;%NWL%7
this . toString = function ( )  {%NWL%return _msg;%NWL%} ;%NWL%this . stack = ( new Error ( ) ) . stack;%NWL%} ;%NWL%dc . errors . Exception . prototype = Object . create ( Error . prototype ) ;%NWL%dc . errors . Exception . prototype . constructor = dc . errors . Exception;%NWL%dc . errors . InvalidStateException = function ( )  {%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%} ;%NWL%dc . errors . InvalidStateException . prototype . constructor = dc . errors . InvalidStateException;%NWL%6
} ;%NWL%this . stack = ( new Error ( ) ) . stack;%NWL%} ;%NWL%dc . errors . Exception . prototype = Object . create ( Error . prototype ) ;%NWL%dc . errors . Exception . prototype . constructor = dc . errors . Exception;%NWL%dc . errors . InvalidStateException = function ( )  {%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%} ;%NWL%dc . errors . InvalidStateException . prototype = Object . create ( dc . errors . Exception . prototype ) ;%NWL%dc . errors . InvalidStateException . prototype . constructor = dc . errors . InvalidStateException;%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%6
} ;%NWL%dc . errors . Exception . prototype = Object . create ( Error . prototype ) ;%NWL%dc . errors . Exception . prototype . constructor = dc . errors . Exception;%NWL%dc . errors . InvalidStateException = function ( )  {%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%} ;%NWL%dc . errors . InvalidStateException . prototype = Object . create ( dc . errors . Exception . prototype ) ;%NWL%dc . errors . InvalidStateException . prototype . constructor = dc . errors . InvalidStateException;%NWL%dc . errors . BadArgumentException = function ( )  {%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%dc . errors . BadArgumentException . prototype = Object . create ( dc . errors . Exception . prototype ) ;%NWL%2
dc . errors . Exception . prototype = Object . create ( Error . prototype ) ;%NWL%dc . errors . Exception . prototype . constructor = dc . errors . Exception;%NWL%dc . errors . InvalidStateException = function ( )  {%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%} ;%NWL%dc . errors . InvalidStateException . prototype = Object . create ( dc . errors . Exception . prototype ) ;%NWL%dc . errors . InvalidStateException . prototype . constructor = dc . errors . InvalidStateException;%NWL%dc . errors . BadArgumentException = function ( )  {%NWL%dc . errors . Exception . apply ( this , arguments ) ;%NWL%} ;%NWL%dc . errors . BadArgumentException . prototype . constructor = dc . errors . BadArgumentException;%NWL%1
. on ( ' click ' , _chart . yAxisOnClick ( ) )%NWL%. text ( _chart . rowsLabel ( ) ) ;%NWL%dc . transition ( gRowsText , _chart . transitionDuration ( ) , _chart . transitionDelay ( ) )%NWL%. text ( _chart . rowsLabel ( ) )%NWL%. attr ( ' y ' , function ( d )  { return rows ( d )  + boxHeight / 2; } ) ;%NWL%gRowsText . exit ( ) . remove ( ) ;%NWL%if ( _chart . hasFilter ( ) )  {%NWL%_chart . selectAll ( ' g . box - group ' ) . each ( function ( d )  {%NWL%if ( _chart . isSelectedNode ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%_chart . fadeDeselected ( this ) ;%NWL%9
gRowsText . exit ( ) . remove ( ) ;%NWL%if ( _chart . hasFilter ( ) )  {%NWL%_chart . selectAll ( ' g . box - group ' ) . each ( function ( d )  {%NWL%if ( _chart . isSelectedNode ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%} else {%NWL%_chart . fadeDeselected ( this ) ;%NWL%}%NWL%} ) ;%NWL%} else {%NWL%_chart . resetHighlight ( this ) ;%NWL%4
cacheID = new Date ( ) . getTime ( )  +  " _ "  + cacheID;%NWL%vars . data . cache [ cacheID ] = vars . data . cache [ cacheKeys [ c ] ] ;%NWL%delete vars . data . cache [ cacheKeys [ c ] ] ;%NWL%break;%NWL%}%NWL%}%NWL%var returnData;%NWL%if ( vars . data . cache [ cacheID ]  )  {%NWL%if ( vars . dev . value ) print . comment ( " data already cached " ) ;%NWL%returnData = vars . data . cache [ cacheID ] . data;%NWL%vars . nodes . restricted = vars . data . cache [ cacheID ] . nodes;%NWL%1
vars . data . cache [ cacheID ] = vars . data . cache [ cacheKeys [ c ] ] ;%NWL%delete vars . data . cache [ cacheKeys [ c ] ] ;%NWL%break;%NWL%}%NWL%}%NWL%var returnData;%NWL%if ( vars . data . cache [ cacheID ]  )  {%NWL%if ( vars . dev . value ) print . comment ( " data already cached " ) ;%NWL%returnData = vars . data . cache [ cacheID ] . data;%NWL%if ( " nodes " in vars )  {%NWL%vars . edges . restricted = vars . data . cache [ cacheID ] . edges;%NWL%0
}%NWL%else {%NWL%returnData = dataFilter ( vars , returnData ) ;%NWL%}%NWL%if ( cacheKeys . length === 20 )  {%NWL%cacheKeys . sort ( ) ;%NWL%delete vars . data . cache [ cacheKeys [ 0 ] ] ;%NWL%}%NWL%cacheID = new Date ( ) . getTime ( )  +  " _ "  + cacheID;%NWL%vars . data . cache [ cacheID ] = { " data " : returnData } ;%NWL%vars . data . cache [ cacheID ] . nodes = vars . nodes . restricted;%NWL%9
else {%NWL%returnData = dataFilter ( vars , returnData ) ;%NWL%}%NWL%if ( cacheKeys . length === 20 )  {%NWL%cacheKeys . sort ( ) ;%NWL%delete vars . data . cache [ cacheKeys [ 0 ] ] ;%NWL%}%NWL%cacheID = new Date ( ) . getTime ( )  +  " _ "  + cacheID;%NWL%vars . data . cache [ cacheID ] = { " data " : returnData } ;%NWL%if ( " nodes " in vars )  {%NWL%vars . data . cache [ cacheID ] . edges = vars . edges . restricted;%NWL%8
legendables = legendables . slice ( 0 , _maxItems ) ;%NWL%}%NWL%var itemEnter = _g . selectAll ( ' g . dc - legend - item ' )%NWL%. data ( legendables )%NWL%. enter ( )%NWL%. append ( ' g ' )%NWL%. attr ( ' class ' ,  ' dc - legend - item ' )%NWL%. on ( ' mouseover ' , function ( d )  {%NWL%_parent . legendHighlight ( d ) ;%NWL%} )%NWL%_parent . legendReset ( d ) ;%NWL%8
return inv ? !match : match;%NWL%} ;%NWL%}%NWL%_chart . legendHighlight = function ( d )  {%NWL%if ( !_chart . isLegendableHidden ( d ) )  {%NWL%_chart . g ( ) . selectAll ( ' path . line , path . area ' )%NWL%. classed ( ' highlight ' , colorFilter ( d . color , d . dashstyle ) )%NWL%. classed ( ' fadeout ' , colorFilter ( d . color , d . dashstyle , true ) ) ;%NWL%}%NWL%} ;%NWL%_chart . g ( ) . selectAll ( ' path . line , path . area ' )%NWL%5
dc . logger = { } ;%NWL%dc . logger . enableDebugLog = false;%NWL%dc . logger . warn = function ( msg )  {%NWL%if ( console )  {%NWL%if ( console . warn )  {%NWL%console . warn ( msg ) ;%NWL%console . log ( msg ) ;%NWL%5
if ( console . warn )  {%NWL%console . warn ( msg ) ;%NWL%} else if ( console . log )  {%NWL%console . log ( msg ) ;%NWL%}%NWL%}%NWL%return dc . logger;%NWL%} ;%NWL%dc . logger . debug = function ( msg )  {%NWL%if ( dc . logger . enableDebugLog && console )  {%NWL%console . debug ( msg ) ;%NWL%1
} else if ( console . log )  {%NWL%console . log ( msg ) ;%NWL%}%NWL%}%NWL%return dc . logger;%NWL%} ;%NWL%dc . logger . debug = function ( msg )  {%NWL%if ( dc . logger . enableDebugLog && console )  {%NWL%if ( console . debug )  {%NWL%console . debug ( msg ) ;%NWL%console . log ( msg ) ;%NWL%1
var _lastValue;%NWL%_chart . _mandatoryAttributes ( [ ' group ' ] ) ;%NWL%_chart . ordering ( function ( kv )  { return kv . value; } ) ;%NWL%%NWL%_chart . html = function ( html )  {%NWL%if ( !arguments . length )  {%NWL%return _html;%NWL%}%NWL%if ( html . none )  {%NWL%_html . none = html . none; / / if none available%NWL%_html . none = html . one; / / if none not available use one%NWL%9
_chart . ordering ( function ( kv )  { return kv . value; } ) ;%NWL%%NWL%_chart . html = function ( html )  {%NWL%if ( !arguments . length )  {%NWL%return _html;%NWL%}%NWL%if ( html . none )  {%NWL%_html . none = html . none; / / if none available%NWL%} else if ( html . one )  {%NWL%_html . none = html . one; / / if none not available use one%NWL%_html . none = html . some; / / if none and one not available use some%NWL%7
if ( !arguments . length )  {%NWL%return _html;%NWL%}%NWL%if ( html . none )  {%NWL%_html . none = html . none; / / if none available%NWL%} else if ( html . one )  {%NWL%_html . none = html . one; / / if none not available use one%NWL%} else if ( html . some )  {%NWL%_html . none = html . some; / / if none and one not available use some%NWL%}%NWL%_html . one = html . one; / / if one available%NWL%4
}%NWL%if ( html . none )  {%NWL%_html . none = html . none; / / if none available%NWL%} else if ( html . one )  {%NWL%_html . none = html . one; / / if none not available use one%NWL%} else if ( html . some )  {%NWL%_html . none = html . some; / / if none and one not available use some%NWL%}%NWL%if ( html . one )  {%NWL%_html . one = html . one; / / if one available%NWL%_html . one = html . some; / / if one not available use some%NWL%2
} else if ( html . one )  {%NWL%_html . none = html . one; / / if none not available use one%NWL%} else if ( html . some )  {%NWL%_html . none = html . some; / / if none and one not available use some%NWL%}%NWL%if ( html . one )  {%NWL%_html . one = html . one; / / if one available%NWL%} else if ( html . some )  {%NWL%_html . one = html . some; / / if one not available use some%NWL%}%NWL%_html . some = html . some; / / if some available%NWL%1
} else if ( html . some )  {%NWL%_html . none = html . some; / / if none and one not available use some%NWL%}%NWL%if ( html . one )  {%NWL%_html . one = html . one; / / if one available%NWL%} else if ( html . some )  {%NWL%_html . one = html . some; / / if one not available use some%NWL%}%NWL%if ( html . some )  {%NWL%_html . some = html . some; / / if some available%NWL%_html . some = html . one; / / if some not available use one%NWL%1
var _cy;%NWL%var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;%NWL%var _externalLabelRadius;%NWL%var _drawPaths = false;%NWL%var _chart = dc . capMixin ( dc . colorMixin ( dc . baseMixin ( { } ) ) ) ;%NWL%_chart . colorAccessor ( _chart . cappedKeyAccessor ) ;%NWL%_chart . title ( function ( d )  {%NWL%return _chart . cappedKeyAccessor ( d )  +  ' : '  + _chart . cappedValueAccessor ( d ) ;%NWL%} ) ;%NWL%%NWL%_chart . label ( _chart . cappedKeyAccessor ) ;%NWL%5
} ) ;%NWL%polyline . exit ( ) . remove ( ) ;%NWL%var arc2 = d3 . svg . arc ( )%NWL%. outerRadius ( _radius - _externalRadiusPadding + _externalLabelRadius )%NWL%. innerRadius ( _radius - _externalRadiusPadding ) ;%NWL%var transition = dc . transition ( polyline , _chart . transitionDuration ( ) , _chart . transitionDelay ( ) ) ;%NWL%if ( transition . attrTween )  {%NWL%transition%NWL%. attrTween ( ' points ' , function ( d )  {%NWL%var current = this . _current || d;%NWL%var interpolate = d3 . interpolate ( current , d ) ;%NWL%5
}%NWL%function removeElements ( slices , labels )  {%NWL%slices . exit ( ) . remove ( ) ;%NWL%labels . exit ( ) . remove ( ) ;%NWL%}%NWL%function highlightFilter ( )  {%NWL%if ( _chart . hasFilter ( ) )  {%NWL%_chart . selectAll ( ' g . '  + _sliceCssClass ) . each ( function ( d )  {%NWL%if ( isSelectedSlice ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%_chart . fadeDeselected ( this ) ;%NWL%9
function highlightFilter ( )  {%NWL%if ( _chart . hasFilter ( ) )  {%NWL%_chart . selectAll ( ' g . '  + _sliceCssClass ) . each ( function ( d )  {%NWL%if ( isSelectedSlice ( d ) )  {%NWL%_chart . highlightSelected ( this ) ;%NWL%} else {%NWL%_chart . fadeDeselected ( this ) ;%NWL%}%NWL%} ) ;%NWL%} else {%NWL%_chart . resetHighlight ( this ) ;%NWL%4
_chart . x = function ( scale )  {%NWL%if ( !arguments . length )  {%NWL%return _x;%NWL%}%NWL%_x = scale;%NWL%return _chart;%NWL%} ;%NWL%function drawGridLines ( )  {%NWL%_g . selectAll ( ' g . tick ' )%NWL%. select ( ' line . grid - line ' )%NWL%_g . selectAll ( ' g . tick ' )%NWL%8
if ( _chart . renderTitle ( ) )  {%NWL%rows . select ( ' title ' ) . remove ( ) ;%NWL%rows . append ( ' title ' ) . text ( _chart . title ( ) ) ;%NWL%}%NWL%}%NWL%function createLabels ( rowEnter )  {%NWL%if ( _chart . renderLabel ( ) )  {%NWL%rowEnter . append ( ' text ' )%NWL%. on ( ' click ' , onClick ) ;%NWL%}%NWL%rowEnter . append ( ' text ' )%NWL%7
_chart . _brushing = function ( )  {%NWL%var extent = _chart . extendBrush ( ) ;%NWL%_chart . redrawBrush ( _chart . g ( ) ) ;%NWL%if ( _chart . brushIsEmpty ( extent ) )  {%NWL%dc . events . trigger ( function ( )  {%NWL%_chart . filter ( null ) ;%NWL%_chart . redrawGroup ( ) ;%NWL%} ) ;%NWL%} else {%NWL%var ranged2DFilter = dc . filters . RangedTwoDimensionalFilter ( extent ) ;%NWL%_chart . filter ( null ) ;%NWL%5
_chart . redrawBrush ( _chart . g ( ) ) ;%NWL%if ( _chart . brushIsEmpty ( extent ) )  {%NWL%dc . events . trigger ( function ( )  {%NWL%_chart . filter ( null ) ;%NWL%_chart . redrawGroup ( ) ;%NWL%} ) ;%NWL%} else {%NWL%var ranged2DFilter = dc . filters . RangedTwoDimensionalFilter ( extent ) ;%NWL%dc . events . trigger ( function ( )  {%NWL%_chart . filter ( null ) ;%NWL%_chart . redrawGroup ( ) ;%NWL%4
return options;%NWL%}%NWL%function onChange ( d , i )  {%NWL%var values;%NWL%var target = d3 . event . target;%NWL%if ( target . selectedOptions )  {%NWL%var selectedOptions = Array . prototype . slice . call ( target . selectedOptions ) ;%NWL%values = selectedOptions . map ( function ( d )  {%NWL%return d . value;%NWL%} ) ;%NWL%var options = [ ] . slice . call ( d3 . event . target . options ) ;%NWL%6
_chart . onChange ( values ) ;%NWL%}%NWL%_chart . onChange = function ( val )  {%NWL%if ( val && _multiple )  {%NWL%_chart . replaceFilter ( [ val ] ) ;%NWL%} else if ( val )  {%NWL%_chart . replaceFilter ( val ) ;%NWL%} else {%NWL%_chart . filterAll ( ) ;%NWL%}%NWL%_chart . redrawGroup ( ) ;%NWL%8
_promptValue = promptValue;%NWL%return _chart;%NWL%} ;%NWL%%NWL%_chart . numberVisible = function ( numberVisible )  {%NWL%if ( !arguments . length )  {%NWL%return _numberVisible;%NWL%}%NWL%_numberVisible = numberVisible;%NWL%return _chart;%NWL%_chart . size = dc . logger . deprecate ( _chart . numberVisible ,  ' selectMenu . size is ambiguous - use numberVisible instead ' ) ;%NWL%4
var valAccessor = layer . accessor || _chart . valueAccessor ( ) ;%NWL%layer . name = String ( layer . name || layerIdx ) ;%NWL%layer . values = layer . group . all ( ) . map ( function ( d , i )  {%NWL%return {%NWL%x: _chart . keyAccessor ( ) ( d , i ) ,%NWL%y: layer . hidden ? null : valAccessor ( d , i ) ,%NWL%data: d ,%NWL%layer: layer . name ,%NWL%hidden: layer . hidden%NWL%} ;%NWL%layer . values = layer . values . filter ( domainFilter ( ) ) ;%NWL%1
_chart . yAxisMax = function ( )  {%NWL%var max = d3 . max ( flattenStack ( ) , function ( p )  {%NWL%return ( p . y > 0 ) ? ( p . y + p . y0 ) : p . y0;%NWL%} ) ;%NWL%return dc . utils . add ( max , _chart . yAxisPadding ( ) ) ;%NWL%} ;%NWL%function flattenStack ( )  {%NWL%var valueses = _chart . data ( ) . map ( function ( layer )  { return layer . values; } ) ;%NWL%return Array . prototype . concat . apply ( [ ] , valueses ) ;%NWL%}%NWL%var min = d3 . min ( flattenStack ( ) , dc . pluck ( ' x ' ) ) ;%NWL%1
return dc . utils . add ( max , _chart . yAxisPadding ( ) ) ;%NWL%} ;%NWL%function flattenStack ( )  {%NWL%var valueses = _chart . data ( ) . map ( function ( layer )  { return layer . values; } ) ;%NWL%return Array . prototype . concat . apply ( [ ] , valueses ) ;%NWL%}%NWL%_chart . xAxisMin = function ( )  {%NWL%var min = d3 . min ( flattenStack ( ) , dc . pluck ( ' x ' ) ) ;%NWL%return dc . utils . subtract ( min , _chart . xAxisPadding ( ) , _chart . xAxisPaddingUnit ( ) ) ;%NWL%} ;%NWL%var max = d3 . max ( flattenStack ( ) , dc . pluck ( ' x ' ) ) ;%NWL%7
} ) ;%NWL%} ;%NWL%_chart . isLegendableHidden = function ( d )  {%NWL%var layer = findLayerByName ( d . name ) ;%NWL%return layer ? layer . hidden : false;%NWL%} ;%NWL%_chart . legendToggle = function ( d )  {%NWL%if ( _hidableStacks )  {%NWL%if ( _chart . isLegendableHidden ( d ) )  {%NWL%_chart . showStack ( d . name ) ;%NWL%_chart . hideStack ( d . name ) ;%NWL%9
var volumeChart = dc . barChart ( ' #monthly - volume - chart ' ) ;%NWL%var yearlyBubbleChart = dc . bubbleChart ( ' #yearly - bubble - chart ' ) ;%NWL%var nasdaqCount = dc . dataCount ( ' . dc - data - count ' ) ;%NWL%var nasdaqTable = dc . dataTable ( ' . dc - data - table ' ) ;%NWL%d3 . csv ( ' ndx . csv ' , function ( data )  {%NWL%var dateFormat = d3 . time . format ( ' %m / %d / %Y ' ) ;%NWL%var numberFormat = d3 . format ( ' . 2f ' ) ;%NWL%data . forEach ( function ( d )  {%NWL%d . dd = dateFormat . parse ( d . date ) ;%NWL%d . month = d3 . time . month ( d . dd ) ; / / pre - calculate month for better performance%NWL%d . open = + d . open;%NWL%9
eq: compileBoundsSearch ( " - " , true ,  " EQ " , true )%NWL%}%NWL%var NOT_FOUND = 0%NWL%var SUCCESS = 1%NWL%var EMPTY = 2%NWL%function IntervalTreeNode ( mid , left , right , leftPoints , rightPoints )  {%NWL%this . mid = mid%NWL%this . left = left%NWL%this . right = right%NWL%this . leftPoints = leftPoints%NWL%this . count = ( left ? left . count : 0 )  +  ( right ? right . count : 0 )  + leftPoints . length%NWL%6
this . mid = mid%NWL%this . left = left%NWL%this . right = right%NWL%this . leftPoints = leftPoints%NWL%this . rightPoints = rightPoints%NWL%this . count = ( left ? left . count : 0 )  +  ( right ? right . count : 0 )  + leftPoints . length%NWL%}%NWL%var proto = IntervalTreeNode . prototype%NWL%function copy ( a , b )  {%NWL%a . mid = b . mid%NWL%a . right = b . right%NWL%9
this . left = left%NWL%this . right = right%NWL%this . leftPoints = leftPoints%NWL%this . rightPoints = rightPoints%NWL%this . count = ( left ? left . count : 0 )  +  ( right ? right . count : 0 )  + leftPoints . length%NWL%}%NWL%var proto = IntervalTreeNode . prototype%NWL%function copy ( a , b )  {%NWL%a . mid = b . mid%NWL%a . left = b . left%NWL%a . leftPoints = b . leftPoints%NWL%8
this . right = right%NWL%this . leftPoints = leftPoints%NWL%this . rightPoints = rightPoints%NWL%this . count = ( left ? left . count : 0 )  +  ( right ? right . count : 0 )  + leftPoints . length%NWL%}%NWL%var proto = IntervalTreeNode . prototype%NWL%function copy ( a , b )  {%NWL%a . mid = b . mid%NWL%a . left = b . left%NWL%a . right = b . right%NWL%a . rightPoints = b . rightPoints%NWL%7
this . leftPoints = leftPoints%NWL%this . rightPoints = rightPoints%NWL%this . count = ( left ? left . count : 0 )  +  ( right ? right . count : 0 )  + leftPoints . length%NWL%}%NWL%var proto = IntervalTreeNode . prototype%NWL%function copy ( a , b )  {%NWL%a . mid = b . mid%NWL%a . left = b . left%NWL%a . right = b . right%NWL%a . leftPoints = b . leftPoints%NWL%a . count = b . count%NWL%6
a . mid = b . mid%NWL%a . left = b . left%NWL%a . right = b . right%NWL%a . leftPoints = b . leftPoints%NWL%a . rightPoints = b . rightPoints%NWL%a . count = b . count%NWL%}%NWL%function rebuild ( node , intervals )  {%NWL%var ntree = createIntervalTree ( intervals )%NWL%node . mid = ntree . mid%NWL%node . right = ntree . right%NWL%9
a . left = b . left%NWL%a . right = b . right%NWL%a . leftPoints = b . leftPoints%NWL%a . rightPoints = b . rightPoints%NWL%a . count = b . count%NWL%}%NWL%function rebuild ( node , intervals )  {%NWL%var ntree = createIntervalTree ( intervals )%NWL%node . mid = ntree . mid%NWL%node . left = ntree . left%NWL%node . leftPoints = ntree . leftPoints%NWL%8
a . right = b . right%NWL%a . leftPoints = b . leftPoints%NWL%a . rightPoints = b . rightPoints%NWL%a . count = b . count%NWL%}%NWL%function rebuild ( node , intervals )  {%NWL%var ntree = createIntervalTree ( intervals )%NWL%node . mid = ntree . mid%NWL%node . left = ntree . left%NWL%node . right = ntree . right%NWL%node . rightPoints = ntree . rightPoints%NWL%7
a . leftPoints = b . leftPoints%NWL%a . rightPoints = b . rightPoints%NWL%a . count = b . count%NWL%}%NWL%function rebuild ( node , intervals )  {%NWL%var ntree = createIntervalTree ( intervals )%NWL%node . mid = ntree . mid%NWL%node . left = ntree . left%NWL%node . right = ntree . right%NWL%node . leftPoints = ntree . leftPoints%NWL%node . count = ntree . count%NWL%6
node . right = ntree . right%NWL%node . leftPoints = ntree . leftPoints%NWL%node . rightPoints = ntree . rightPoints%NWL%node . count = ntree . count%NWL%}%NWL%function rebuildWithInterval ( node , interval )  {%NWL%var intervals = node . intervals ( [ ] )%NWL%intervals . push ( interval )%NWL%rebuild ( node , intervals )%NWL%}%NWL%var intervals = node . intervals ( [ ] )%NWL%6
}%NWL%intervals . splice ( idx , 1 )%NWL%rebuild ( node , intervals )%NWL%return SUCCESS%NWL%}%NWL%proto . intervals = function ( result )  {%NWL%result . push . apply ( result , this . leftPoints )%NWL%if ( this . left )  {%NWL%this . left . intervals ( result )%NWL%}%NWL%this . right . intervals ( result )%NWL%8
} else {%NWL%this . left . insert ( interval )%NWL%}%NWL%} else {%NWL%this . left = createIntervalTree ( [ interval ] )%NWL%}%NWL%} else if ( interval [ 0 ] > this . mid )  {%NWL%if ( this . right )  {%NWL%if ( 4 * ( this . right . count + 1 ) > 3 * ( weight + 1 ) )  {%NWL%rebuildWithInterval ( this , interval )%NWL%this . right . insert ( interval )%NWL%1
skipped : specs [ i ] . results ( ) . skipped ,%NWL%passedCount : specs [ i ] . results ( ) . passedCount ,%NWL%failedCount : specs [ i ] . results ( ) . failedCount ,%NWL%totalCount : specs [ i ] . results ( ) . totalCount ,%NWL%failures: failures ( specs [ i ] . results ( ) . getItems ( ) )%NWL%} ;%NWL%suiteData . passed = !suiteData . specs [ i ] . passed ? false : suiteData . passed;%NWL%suiteData . durationSec + = suiteData . specs [ i ] . durationSec;%NWL%}%NWL%for ( i = 0 , ilen = suites . length; i < ilen; + + i )  {%NWL%suiteData . passed = !suiteData . suites [ i ] . passed ? false : suiteData . passed;%NWL%6
passedCount : specs [ i ] . results ( ) . passedCount ,%NWL%failedCount : specs [ i ] . results ( ) . failedCount ,%NWL%totalCount : specs [ i ] . results ( ) . totalCount ,%NWL%failures: failures ( specs [ i ] . results ( ) . getItems ( ) )%NWL%} ;%NWL%suiteData . passed = !suiteData . specs [ i ] . passed ? false : suiteData . passed;%NWL%suiteData . durationSec + = suiteData . specs [ i ] . durationSec;%NWL%}%NWL%for ( i = 0 , ilen = suites . length; i < ilen; + + i )  {%NWL%suiteData . suites [ i ] = getSuiteData ( suites [ i ] ) ; / / < recursive population%NWL%suiteData . durationSec + = suiteData . suites [ i ] . durationSec;%NWL%5
totalCount : specs [ i ] . results ( ) . totalCount ,%NWL%failures: failures ( specs [ i ] . results ( ) . getItems ( ) )%NWL%} ;%NWL%suiteData . passed = !suiteData . specs [ i ] . passed ? false : suiteData . passed;%NWL%suiteData . durationSec + = suiteData . specs [ i ] . durationSec;%NWL%}%NWL%for ( i = 0 , ilen = suites . length; i < ilen; + + i )  {%NWL%suiteData . suites [ i ] = getSuiteData ( suites [ i ] ) ; / / < recursive population%NWL%suiteData . passed = !suiteData . suites [ i ] . passed ? false : suiteData . passed;%NWL%suiteData . durationSec + = suiteData . suites [ i ] . durationSec;%NWL%suiteData . durationSec = round ( suiteData . durationSec , 4 ) ;%NWL%3
JSR . suiteStarted = function ( suite )  {%NWL%suite = this . _cacheSuite ( suite ) ;%NWL%suite . specs = [ ] ;%NWL%suite . suites = [ ] ;%NWL%suite . passed = true;%NWL%suite . parentId = this . suiteStack . slice ( this . suiteStack . length - 1 ) [ 0 ] ;%NWL%if ( suite . parentId )  {%NWL%this . suites [ suite . parentId ] . suites . push ( suite ) ;%NWL%} else {%NWL%this . rootSuites . push ( suite . id ) ;%NWL%this . suiteStack . push ( suite . id ) ;%NWL%9
spec . timer = new Timer ( ) . start ( ) ;%NWL%spec . suiteId = this . suiteStack . slice ( this . suiteStack . length - 1 ) [ 0 ] ;%NWL%this . suites [ spec . suiteId ] . specs . push ( spec ) ;%NWL%} ;%NWL%JSR . specDone = function ( spec )  {%NWL%spec = this . _cacheSpec ( spec ) ;%NWL%spec . duration = spec . timer . elapsed ( ) ;%NWL%spec . durationSec = spec . duration / 1000;%NWL%spec . skipped = spec . status === ' pending ' ;%NWL%spec . passed = spec . skipped || spec . status === ' passed ' ;%NWL%spec . passedCount = spec . passedExpectations ? spec . passedExpectations . length : 0;%NWL%9
spec . suiteId = this . suiteStack . slice ( this . suiteStack . length - 1 ) [ 0 ] ;%NWL%this . suites [ spec . suiteId ] . specs . push ( spec ) ;%NWL%} ;%NWL%JSR . specDone = function ( spec )  {%NWL%spec = this . _cacheSpec ( spec ) ;%NWL%spec . duration = spec . timer . elapsed ( ) ;%NWL%spec . durationSec = spec . duration / 1000;%NWL%spec . skipped = spec . status === ' pending ' ;%NWL%spec . passed = spec . skipped || spec . status === ' passed ' ;%NWL%spec . totalCount = spec . totalExpectations || 0;%NWL%spec . failedCount = spec . failedExpectations . length;%NWL%8
function oscillate ( f1 , f2 )  {%NWL%return function ( )  {%NWL%stop ( ) ;%NWL%var which = false;%NWL%f1 ( ) ;%NWL%dc . redrawAll ( ) ;%NWL%inter = window . setInterval ( function ( )  {%NWL%if ( ( which = !which ) )%NWL%f2 ( ) ;%NWL%else%NWL%dc . redrawAll ( ) ;%NWL%5
var basis = _data . length ?%NWL%_data [ _reverse ? 0 : _data . length - 1 ] :%NWL%{ key: 0 , value: startval ( ) } ;%NWL%var obs = [ ] , key = basis . key +  ( _reverse ? - 1 : 1 )  * _interval;%NWL%for ( var i = 0; i<N; + + i )  {%NWL%obs [ i ] = Math . max ( basis . value [ i ]  + rand ( )  * _magnitude , 0 ) ;%NWL%}%NWL%var datum = { key: key , value: obs } ;%NWL%if ( _reverse )%NWL%_data . unshift ( datum ) ;%NWL%_data . push ( datum ) ;%NWL%9
_reverse = reverse;%NWL%return this;%NWL%} ,%NWL%start: function ( )  {%NWL%stop ( ) ;%NWL%dc . redrawAll ( ) ;%NWL%inter = window . setInterval ( function ( )  {%NWL%for ( var i = 0; i < _steps; + + i )  {%NWL%generate ( ) ;%NWL%drop ( ) ;%NWL%dc . redrawAll ( ) ;%NWL%5
var grad = defs . append ( " radialGradient " )%NWL%. attr ( " id " , " metal - bump " )%NWL%. attr ( " cx " , " 50% " )%NWL%. attr ( " cy " , " 50% " )%NWL%. attr ( " r " , " 50% " )%NWL%. attr ( " fx " , " 50% " )%NWL%. attr ( " fy " , " 50% " ) ;%NWL%grad . append ( " stop " )%NWL%. attr ( " offset " , " 0% " )%NWL%. style ( " stop - color " , " rgb ( 170 , 170 , 170 ) " )%NWL%grad . append ( " stop " )%NWL%7
} ) ;%NWL%}%NWL%function __init_controls ( selection )  {%NWL%selection . each ( function ( )  {%NWL%var controls = d3 . select ( this ) ;%NWL%controls . append ( " path " )%NWL%. attr ( " class " ,  " ui - show - hide " )%NWL%. attr ( " d " ,  " M10 , 3 v40 h - 7 a3 , 3 0 0 , 1 - 3 , - 3 v - 34 a3 , 3 0 0 , 1 3 , - 3 Z " )%NWL%. attr ( " fill " , " url ( #grip - texture ) " )%NWL%. attr ( " stroke " ,  " none " )%NWL%controls . append ( " path " )%NWL%5
. attr ( " class " ,  " ui - show - hide " )%NWL%. attr ( " d " ,  " M10 , 3 v40 h - 7 a3 , 3 0 0 , 1 - 3 , - 3 v - 34 a3 , 3 0 0 , 1 3 , - 3 Z " )%NWL%. attr ( " fill " , " url ( #grip - texture ) " )%NWL%. attr ( " stroke " ,  " none " )%NWL%. style ( " opacity " , 0 . 5 ) ;%NWL%controls . append ( " path " )%NWL%. attr ( " class " ,  " show ui - show - hide " )%NWL%. attr ( " d " ,  " M2 , 23 l6 , - 15 v30 Z " )%NWL%. attr ( " fill " , " rgb ( 204 , 204 , 204 ) " )%NWL%. attr ( " stroke " ,  " none " )%NWL%controls . append ( " path " )%NWL%5
. attr ( " class " ,  " show ui - show - hide " )%NWL%. attr ( " d " ,  " M2 , 23 l6 , - 15 v30 Z " )%NWL%. attr ( " fill " , " rgb ( 204 , 204 , 204 ) " )%NWL%. attr ( " stroke " ,  " none " )%NWL%. style ( " opacity " , 0 . 5 ) ;%NWL%controls . append ( " path " )%NWL%. attr ( " class " ,  " hide " )%NWL%. attr ( " d " ,  " M8 , 23 l - 6 , - 15 v30 Z " )%NWL%. attr ( " fill " , " rgb ( 204 , 204 , 204 ) " )%NWL%. attr ( " stroke " ,  " none " )%NWL%controls . append ( " path " )%NWL%5
controls . select ( " . show " )%NWL%. style ( " opacity " , 1 )%NWL%. classed ( " ui - show - hide " , true ) ;%NWL%controls . selectAll ( " path . ui - show - hide " )%NWL%. style ( " opacity " , 0 . 5 ) ;%NWL%} ) ;%NWL%} else {%NWL%controls . transition ( )%NWL%. duration ( 1000 )%NWL%. attr ( " transform " ,  " translate ( " + ( controls . attr ( " view - width " ) - 95 ) + " , 0 ) " )%NWL%controls . select ( " . show " )%NWL%0
var center = { x:0 , y:0 } ;%NWL%var area = 0;%NWL%for ( var i=0; i<d . points . length; + + i )  {%NWL%var p1 = d . points [ i ] ;%NWL%var p2 = d . points [ i + 1 ] || d . points [ 0 ] ;%NWL%var ai = ( p1 . x * p2 . y - p2 . x * p1 . y ) ;%NWL%center . x + = ( p1 . x + p2 . x ) * ai;%NWL%center . y + = ( p1 . y + p2 . y ) * ai;%NWL%area + = ai;%NWL%}%NWL%center . x = center . x / ( 6 * area ) ;%NWL%6
var area = 0;%NWL%for ( var i=0; i<d . points . length; + + i )  {%NWL%var p1 = d . points [ i ] ;%NWL%var p2 = d . points [ i + 1 ] || d . points [ 0 ] ;%NWL%var ai = ( p1 . x * p2 . y - p2 . x * p1 . y ) ;%NWL%center . x + = ( p1 . x + p2 . x ) * ai;%NWL%center . y + = ( p1 . y + p2 . y ) * ai;%NWL%area + = ai;%NWL%}%NWL%area = area / 2;%NWL%center . y = center . y / ( 6 * area ) ;%NWL%5
this . annotations = null;%NWL%this . annotationURL = annotationURL;%NWL%this . tooltip = null;%NWL%this . x = null;%NWL%this . y = null;%NWL%this . z = d3 . scaleSequential ( d3 . interpolateViridis ) ;%NWL%this . animation = null;%NWL%this . isAnimatable = isAnimatable;%NWL%this . isZoomable = isZoomable;%NWL%this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . div = d3 . select ( id ) ;%NWL%9
this . annotationURL = annotationURL;%NWL%this . tooltip = null;%NWL%this . x = null;%NWL%this . y = null;%NWL%this . z = d3 . scaleSequential ( d3 . interpolateViridis ) ;%NWL%this . animation = null;%NWL%this . isAnimatable = isAnimatable;%NWL%this . isZoomable = isZoomable;%NWL%this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . image = null;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%8
this . tooltip = null;%NWL%this . x = null;%NWL%this . y = null;%NWL%this . z = d3 . scaleSequential ( d3 . interpolateViridis ) ;%NWL%this . animation = null;%NWL%this . isAnimatable = isAnimatable;%NWL%this . isZoomable = isZoomable;%NWL%this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . image = null;%NWL%this . div = d3 . select ( id ) ;%NWL%this . svg = this . div . append ( " svg " ) ;%NWL%7
this . x = null;%NWL%this . y = null;%NWL%this . z = d3 . scaleSequential ( d3 . interpolateViridis ) ;%NWL%this . animation = null;%NWL%this . isAnimatable = isAnimatable;%NWL%this . isZoomable = isZoomable;%NWL%this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . image = null;%NWL%this . div = d3 . select ( id ) ;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%this . svgGroup = this . svg . append ( " g " ) ;%NWL%6
this . y = null;%NWL%this . z = d3 . scaleSequential ( d3 . interpolateViridis ) ;%NWL%this . animation = null;%NWL%this . isAnimatable = isAnimatable;%NWL%this . isZoomable = isZoomable;%NWL%this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . image = null;%NWL%this . div = d3 . select ( id ) ;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%this . svg = this . div . append ( " svg " ) ;%NWL%this . rectangle = this . svgGroup . append ( " rect " ) ;%NWL%5
this . isAnimatable = isAnimatable;%NWL%this . isZoomable = isZoomable;%NWL%this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . image = null;%NWL%this . div = d3 . select ( id ) ;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%this . svg = this . div . append ( " svg " ) ;%NWL%this . svgGroup = this . svg . append ( " g " ) ;%NWL%this . rectangle = this . svgGroup . append ( " rect " ) ;%NWL%this . xAxis = null;%NWL%this . xAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%2
this . isZoomable = isZoomable;%NWL%this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . image = null;%NWL%this . div = d3 . select ( id ) ;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%this . svg = this . div . append ( " svg " ) ;%NWL%this . svgGroup = this . svg . append ( " g " ) ;%NWL%this . rectangle = this . svgGroup . append ( " rect " ) ;%NWL%this . xAxis = null;%NWL%this . yAxis = null;%NWL%this . yAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%1
this . zoom = d3 . zoom ( ) . on ( " zoom " , onZoom ) ;%NWL%this . image = null;%NWL%this . div = d3 . select ( id ) ;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%this . svg = this . div . append ( " svg " ) ;%NWL%this . svgGroup = this . svg . append ( " g " ) ;%NWL%this . rectangle = this . svgGroup . append ( " rect " ) ;%NWL%this . xAxis = null;%NWL%this . yAxis = null;%NWL%this . xAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%this . xAxisLabel = this . svgGroup . append ( " text " ) ;%NWL%0
this . image = null;%NWL%this . div = d3 . select ( id ) ;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%this . svg = this . div . append ( " svg " ) ;%NWL%this . svgGroup = this . svg . append ( " g " ) ;%NWL%this . rectangle = this . svgGroup . append ( " rect " ) ;%NWL%this . xAxis = null;%NWL%this . yAxis = null;%NWL%this . xAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%this . yAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%this . yAxisLabel = this . svgGroup . append ( " text " ) ;%NWL%2
this . div = d3 . select ( id ) ;%NWL%this . canvas = this . div . append ( " canvas " ) ;%NWL%this . svg = this . div . append ( " svg " ) ;%NWL%this . svgGroup = this . svg . append ( " g " ) ;%NWL%this . rectangle = this . svgGroup . append ( " rect " ) ;%NWL%this . xAxis = null;%NWL%this . yAxis = null;%NWL%this . xAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%this . yAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%this . xAxisLabel = this . svgGroup . append ( " text " ) ;%NWL%this . tooltipGroup = this . svgGroup . append ( " g " ) ;%NWL%1
this . svg = this . div . append ( " svg " ) ;%NWL%this . svgGroup = this . svg . append ( " g " ) ;%NWL%this . rectangle = this . svgGroup . append ( " rect " ) ;%NWL%this . xAxis = null;%NWL%this . yAxis = null;%NWL%this . xAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%this . yAxisGroup = this . svgGroup . append ( " g " ) ;%NWL%this . xAxisLabel = this . svgGroup . append ( " text " ) ;%NWL%this . yAxisLabel = this . svgGroup . append ( " text " ) ;%NWL%this . tooltipGroup = this . svgGroup . append ( " g " ) ;%NWL%this . interpolateSelect = ( isSelectable === true ) ? this . div . append ( " select " )%NWL%0
context . clearRect ( 0 , 0 , context . canvas . width , context . canvas . height ) ;%NWL%renderDisplay ( w ) ;%NWL%}%NWL%function onZoom ( )  {%NWL%if ( !w . image || !w . isZoomable ) return;%NWL%w . xAxisGroup . call ( w . xAxis . scale ( d3 . event . transform . rescaleX ( w . x ) ) ) ;%NWL%w . yAxisGroup . call ( w . yAxis . scale ( d3 . event . transform . rescaleY ( w . y ) ) ) ;%NWL%if ( w . annotations )  {%NWL%w . tooltipGroup . attr ( " transform " ,  " translate ( "  + d3 . event . transform . x +  " , "  + d3 . event . transform . y +  " ) scale ( "  + d3 . event . transform . k +  " ) " ) ;%NWL%}%NWL%context . clearRect ( 0 , 0 , context . canvas . width , context . canvas . height ) ;%NWL%0
w . xAxisGroup . call ( w . xAxis . scale ( d3 . event . transform . rescaleX ( w . x ) ) ) ;%NWL%w . yAxisGroup . call ( w . yAxis . scale ( d3 . event . transform . rescaleY ( w . y ) ) ) ;%NWL%if ( w . annotations )  {%NWL%w . tooltipGroup . attr ( " transform " ,  " translate ( "  + d3 . event . transform . x +  " , "  + d3 . event . transform . y +  " ) scale ( "  + d3 . event . transform . k +  " ) " ) ;%NWL%}%NWL%var context = w . canvas . node ( ) . getContext ( " 2d " ) ;%NWL%context . clearRect ( 0 , 0 , context . canvas . width , context . canvas . height ) ;%NWL%context . save ( ) ;%NWL%context . translate ( d3 . event . transform . x , d3 . event . transform . y ) ;%NWL%context . scale ( d3 . event . transform . k , d3 . event . transform . k ) ;%NWL%context . restore ( ) ;%NWL%7
w . signal . style ( " opacity " , 0 . 5 ) ;%NWL%}%NWL%function onTooltipMouseout ( d , i )  {%NWL%onSignalMouseout ( d , i ) ;%NWL%}%NWL%function onSignalMouseover ( d , i )  {%NWL%w . signal = d3 . select ( this ) ;%NWL%w . signal . transition ( d3 . transition ( ) . duration ( 100 ) )%NWL%. style ( " opacity " , 0 . 5 ) ;%NWL%w . tooltip . style ( " left " , d3 . event . offsetX + 5 +  " px " )%NWL%w . tooltip . transition ( d3 . transition ( ) . duration ( 100 ) )%NWL%7
w . signal . transition ( d3 . transition ( ) . duration ( 100 ) )%NWL%. style ( " opacity " , 0 . 5 ) ;%NWL%w . tooltip . style ( " left " , d3 . event . offsetX + 5 +  " px " )%NWL%. style ( " top " , d3 . event . offsetY + 5 +  " px " ) ;%NWL%w . tooltip . transition ( d3 . transition ( ) . duration ( 100 ) )%NWL%. style ( " visibility " ,  " visible " ) ;%NWL%w . tooltip . html ( " <a href=\ " "  + d . url +  " \ " target=\ " _blank\ " ><strong> "  + d . description +  " < / strong>< / a><br><strong>Frequency:< / strong> "  + formatFrequency ( d . freqStart )  +  "  -  "  + formatFrequency ( d . freqStop ) ) ;%NWL%}%NWL%function onSignalMouseout ( d , i )  {%NWL%w . signal . transition ( d3 . transition ( ) . delay ( 100 ) . duration ( 100 ) )%NWL%w . tooltip . transition ( d3 . transition ( ) . delay ( 100 ) . duration ( 100 ) )%NWL%9
. style ( " position " ,  " absolute " ) ;%NWL%w . svgGroup . attr ( " transform " ,  " translate ( "  + w . margin +  " , "  + w . margin +  " ) " ) ;%NWL%w . x = d3 . scaleLinear ( ) . range ( [ 0 , elementWidth ] ) . interpolate ( d3 . interpolateRound ) ;%NWL%w . y = d3 . scaleTime ( ) . range ( [ 0 , elementHeight ] ) . interpolate ( d3 . interpolateRound ) ;%NWL%w . x . domain ( w . data . freqRange ) ;%NWL%w . y . domain ( w . data . timeRange ) ;%NWL%w . z . domain ( w . data . dbRange ) ;%NWL%w . canvas . attr ( " width " , elementWidth )%NWL%. attr ( " height " , elementHeight )%NWL%. style ( " padding " , w . margin +  " px " )%NWL%w . rectangle . attr ( " width " , elementWidth )%NWL%7
w . rectangle . attr ( " width " , elementWidth )%NWL%. attr ( " height " , elementHeight )%NWL%. style ( " fill " ,  " #fff " )%NWL%. style ( " opacity " , 0 )%NWL%. call ( w . zoom ) ;%NWL%w . xAxis = d3 . axisTop ( w . x ) . ticks ( 16 ) . tickFormat ( formatFrequency ) ;%NWL%w . xAxisGroup . attr ( " class " ,  " axis x - axis " )%NWL%. call ( w . xAxis ) ;%NWL%w . yAxis = d3 . axisLeft ( w . y ) ;%NWL%w . yAxisGroup . attr ( " class " ,  " axis y - axis " )%NWL%w . xAxisLabel . attr ( " class " ,  " axis x - axis " )%NWL%6
. call ( w . zoom ) ;%NWL%w . xAxis = d3 . axisTop ( w . x ) . ticks ( 16 ) . tickFormat ( formatFrequency ) ;%NWL%w . xAxisGroup . attr ( " class " ,  " axis x - axis " )%NWL%. call ( w . xAxis ) ;%NWL%w . yAxis = d3 . axisLeft ( w . y ) ;%NWL%w . yAxisGroup . attr ( " class " ,  " axis y - axis " )%NWL%. call ( w . yAxis ) ;%NWL%w . xAxisLabel . attr ( " class " ,  " axis x - axis " )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%. attr ( " transform " ,  " translate ( "  + elementWidth / 2 +  " , "  +  - w . margin / 2 +  " ) " )%NWL%w . yAxisLabel . attr ( " class " ,  " axis y - axis " )%NWL%5
var funnelId = this . _getFunnelId ( ) ;%NWL%if ( !this . _ensureFunnelLibrary ( $element ) )%NWL%return;%NWL%if ( !!data )  {%NWL%if ( !changeExisting || !this . funnelViewer )  {%NWL%$element . empty ( ) ;%NWL%$element . append ( $ ( ' <div / > ' ) . attr ( ' id ' , funnelId ) ) ;%NWL%this . funnelViewer = new D3Funnel ( ' # '  + funnelId ) ;%NWL%}%NWL%this . _update ( data ) ;%NWL%$element . empty ( ) ;%NWL%5
} ;%NWL%funnelD3Item . prototype . _getFunnelId = function ( )  {%NWL%return ' dx - d3 - funnel - '  + this . getName ( ) ;%NWL%} ;%NWL%funnelD3Item . prototype . _onClick = function ( e )  {%NWL%if ( !this . _hasArguments ( ) || !e . label )%NWL%return;%NWL%var row = e . label . raw . data;%NWL%if ( this . canDrillDown ( row ) )%NWL%this . drillDown ( row ) ;%NWL%this . setMasterFilter ( row ) ;%NWL%9
this . _update ( ) ;%NWL%}%NWL%} ;%NWL%funnelD3Item . prototype . _subscribeProperties = function ( )  {%NWL%var _this = this;%NWL%this . subscribe ( ' IsCurved ' , function ( isCurved )  { return _this . _update ( null ,  { chart: { curve: { enabled: isCurved }  }  } ) ; } ) ;%NWL%this . subscribe ( ' IsDynamicHeight ' , function ( isDynamicHeight )  { return _this . _update ( null ,  { block: { dynamicHeight: isDynamicHeight }  } ) ; } ) ;%NWL%this . subscribe ( ' PinchCount ' , function ( count )  { return _this . _update ( null ,  { chart: { bottomPinch: count }  } ) ; } ) ;%NWL%this . subscribe ( ' FillType ' , function ( type )  { return _this . _update ( null ,  { block: { fill: { type: type . toLowerCase ( )  }  }  } ) ; } ) ;%NWL%} ;%NWL%this . _ensureFunnelSettings ( ) ;%NWL%0
} ;%NWL%funnelD3Item . prototype . _update = function ( data , options )  {%NWL%this . _ensureFunnelSettings ( ) ;%NWL%if ( !!data )  {%NWL%this . funnelSettings . data = data;%NWL%}%NWL%if ( !!options )  {%NWL%$ . extend ( true , this . funnelSettings . options , options ) ;%NWL%}%NWL%if ( !!this . funnelViewer )  {%NWL%this . _updateExportingImage ( ) ;%NWL%2
. attr ( ' class ' ,  ' calendar - heatmap - legend ' )%NWL%. attr ( ' width ' , SQUARE_LENGTH )%NWL%. attr ( ' height ' , SQUARE_LENGTH )%NWL%. attr ( ' x ' , function ( d , i )  { return ( width - legendWidth )  +  ( i + 1 )  * 13; } )%NWL%. attr ( ' y ' , height + SQUARE_PADDING )%NWL%. attr ( ' fill ' , function ( d )  { return d; } ) ;%NWL%legendGroup . append ( ' text ' )%NWL%. attr ( ' class ' ,  ' calendar - heatmap - legend - text calendar - heatmap - legend - text - less ' )%NWL%. attr ( ' x ' , width - legendWidth - 13 )%NWL%. attr ( ' y ' , height + SQUARE_LENGTH )%NWL%legendGroup . append ( ' text ' )%NWL%6
. attr ( " spreadMethod " ,  " pad " ) ;%NWL%chart . gradientColors ( ) . forEach ( function ( color , index )  {%NWL%gradient . append ( " stop " )%NWL%. attr ( " offset " ,  ( ( index * 100 )  / chart . gradientColors ( ) . length )  +  ' % ' )%NWL%. attr ( " stop - color " , color )%NWL%. attr ( " stop - opacity " , 0 . 7 ) ;%NWL%} )%NWL%}%NWL%if ( chart . dataSourceType ( ) . toLowerCase ( ) === ' csv ' )  {%NWL%d3 . csv ( chart . dataSource ( ) , drawChart ) ;%NWL%d3 . tsv ( chart . dataSource ( ) , drawChart ) ;%NWL%9
gradient . append ( " stop " )%NWL%. attr ( " offset " ,  ( ( index * 100 )  / chart . gradientColors ( ) . length )  +  ' % ' )%NWL%. attr ( " stop - color " , color )%NWL%. attr ( " stop - opacity " , 0 . 7 ) ;%NWL%} )%NWL%}%NWL%if ( chart . dataSourceType ( ) . toLowerCase ( ) === ' csv ' )  {%NWL%d3 . csv ( chart . dataSource ( ) , drawChart ) ;%NWL%} else if ( chart . dataSourceType ( ) . toLowerCase ( ) === ' tsv ' )  {%NWL%d3 . tsv ( chart . dataSource ( ) , drawChart ) ;%NWL%d3 . json ( chart . dataSource ( ) , drawChart ) ;%NWL%7
}%NWL%scope . api = {%NWL%refresh: function ( map )  {%NWL%scope . api . updateWithOptions ( map ) ;%NWL%} ,%NWL%updateWithOptions: function ( map )  {%NWL%scope . api . clearElement ( ) ;%NWL%scope . width = ( map . options || { } ) . width || null;%NWL%scope . height = ( map . options || { } ) . height || ( scope . width ? scope . width * 0 . 5 : null ) ;%NWL%scope . legendHeight = ( map . options || { } ) . legendHeight || 50;%NWL%scope . mapOptions = angular . extend ( scope . mapOptions , map ) ;%NWL%7
scope . api = {%NWL%refresh: function ( map )  {%NWL%scope . api . updateWithOptions ( map ) ;%NWL%} ,%NWL%updateWithOptions: function ( map )  {%NWL%scope . api . clearElement ( ) ;%NWL%scope . width = ( map . options || { } ) . width || null;%NWL%scope . height = ( map . options || { } ) . height || ( scope . width ? scope . width * 0 . 5 : null ) ;%NWL%scope . legendHeight = ( map . options || { } ) . legendHeight || 50;%NWL%scope . mapOptions = mapOptions ( ) ;%NWL%scope . datamap = new Datamap ( scope . mapOptions ) ;%NWL%6
updateWithOptions: function ( map )  {%NWL%scope . api . clearElement ( ) ;%NWL%scope . width = ( map . options || { } ) . width || null;%NWL%scope . height = ( map . options || { } ) . height || ( scope . width ? scope . width * 0 . 5 : null ) ;%NWL%scope . legendHeight = ( map . options || { } ) . legendHeight || 50;%NWL%scope . mapOptions = mapOptions ( ) ;%NWL%scope . mapOptions = angular . extend ( scope . mapOptions , map ) ;%NWL%scope . datamap = new Datamap ( scope . mapOptions ) ;%NWL%if ( scope . mapOptions . responsive )  {%NWL%$window . addEventListener ( ' resize ' , scope . api . resize ) ;%NWL%$window . removeEventListener ( ' resize ' , scope . api . resize ) ;%NWL%9
}%NWL%} ;%NWL%scope . $watch ( ' map ' , function ( map , old )  {%NWL%if ( !map || angular . equals ( { } , map ) )  {%NWL%return;%NWL%}%NWL%if ( !scope . datamap || angular . equals ( map . data , old . data ) )  {%NWL%scope . api . refresh ( map ) ;%NWL%} else if ( ( map . options || { } ) . staticGeoData )  {%NWL%scope . api . updateWithData ( map . data ) ;%NWL%scope . api . refresh ( map ) ;%NWL%7
scope . api = {%NWL%refresh: function ( map )  {%NWL%scope . api . updateWithOptions ( map ) ;%NWL%} ,%NWL%updateWithOptions: function ( map )  {%NWL%scope . api . clearElement ( ) ;%NWL%scope . width = ( map . options || { } ) . width || null;%NWL%scope . height = ( map . options || { } ) . height || ( scope . width ? scope . width * 0 . 5 : null ) ;%NWL%scope . aspectRatio = ( map . options || { } ) . aspectRatio || null;%NWL%scope . legendHeight = ( map . options || { } ) . legendHeight || 50;%NWL%scope . mapOptions = angular . extend ( scope . mapOptions , map ) ;%NWL%6
refresh: function ( map )  {%NWL%scope . api . updateWithOptions ( map ) ;%NWL%} ,%NWL%updateWithOptions: function ( map )  {%NWL%scope . api . clearElement ( ) ;%NWL%scope . width = ( map . options || { } ) . width || null;%NWL%scope . height = ( map . options || { } ) . height || ( scope . width ? scope . width * 0 . 5 : null ) ;%NWL%scope . aspectRatio = ( map . options || { } ) . aspectRatio || null;%NWL%scope . legendHeight = ( map . options || { } ) . legendHeight || 50;%NWL%scope . mapOptions = mapOptions ( ) ;%NWL%scope . datamap = new Datamap ( scope . mapOptions ) ;%NWL%5
scope . api . clearElement ( ) ;%NWL%scope . width = ( map . options || { } ) . width || null;%NWL%scope . height = ( map . options || { } ) . height || ( scope . width ? scope . width * 0 . 5 : null ) ;%NWL%scope . aspectRatio = ( map . options || { } ) . aspectRatio || null;%NWL%scope . legendHeight = ( map . options || { } ) . legendHeight || 50;%NWL%scope . mapOptions = mapOptions ( ) ;%NWL%scope . mapOptions = angular . extend ( scope . mapOptions , map ) ;%NWL%scope . datamap = new Datamap ( scope . mapOptions ) ;%NWL%if ( scope . mapOptions . responsive )  {%NWL%$window . addEventListener ( ' resize ' , scope . api . resize ) ;%NWL%$window . removeEventListener ( ' resize ' , scope . api . resize ) ;%NWL%9
}%NWL%} ;%NWL%scope . $watch ( ' map ' , function ( map , old )  {%NWL%if ( !map || angular . equals ( { } , map ) )  {%NWL%return;%NWL%}%NWL%if ( !scope . datamap || angular . equals ( map . data , old . data ) )  {%NWL%scope . api . refresh ( map ) ;%NWL%} else if ( ( map . options || { } ) . staticGeoData )  {%NWL%scope . api . updateWithData ( map . data ) ;%NWL%scope . api . refresh ( map ) ;%NWL%7
template = require ( ' . / options . html ' ) ;%NWL%scope . build = function ( _scope )  {%NWL%if ( scope . node . isObject ( ) )  {%NWL%element . html ( ' ' ) . append ( $compile ( template ) ( _scope ) ) ;%NWL%}%NWL%} ;%NWL%scope . refresh = function ( )  {%NWL%childScope . $destroy ( ) ;%NWL%childScope = scope . $new ( ) ;%NWL%scope . build ( childScope ) ;%NWL%scope . build ( childScope ) ;%NWL%9
datasetSelector: function ( )  {%NWL%var selector = $compile ( ' <select ng - options= " idx as set . key for ( idx , set ) in data " ng - model= " selectedSet " ng - change= " api . selectDataSet ( selectedSet ) " ng - init= " selectedSet = \ ' 0\ ' " style= " position: absolute; top: 0 " >< / select> ' ) ( scope ) ;%NWL%element . append ( selector ) ;%NWL%} ,%NWL%updateWithOptions: function ( options , data )  {%NWL%var _options;%NWL%scope . api . clearElement ( ) ;%NWL%if ( !angular . isDefined ( options ) ) return;%NWL%scope . width = options . chart . width || 600;%NWL%scope . height = options . chart . height || scope . width * 0 . 6;%NWL%scope . geoCodeMap = getGeoCodeMap . get ( scope . mapOptions . scope ) ;%NWL%8
element . append ( selector ) ;%NWL%} ,%NWL%updateWithOptions: function ( options , data )  {%NWL%var _options;%NWL%scope . api . clearElement ( ) ;%NWL%if ( !angular . isDefined ( options ) ) return;%NWL%scope . width = options . chart . width || 600;%NWL%scope . height = options . chart . height || scope . width * 0 . 6;%NWL%scope . mapOptions = mapOptions ( ) ;%NWL%scope . geoCodeMap = getGeoCodeMap . get ( scope . mapOptions . scope ) ;%NWL%scope . mapOptions = mapData ( scope . mapOptions , data . values ) ;%NWL%6
var _options;%NWL%scope . api . clearElement ( ) ;%NWL%if ( !angular . isDefined ( options ) ) return;%NWL%scope . width = options . chart . width || 600;%NWL%scope . height = options . chart . height || scope . width * 0 . 6;%NWL%scope . mapOptions = mapOptions ( ) ;%NWL%scope . geoCodeMap = getGeoCodeMap . get ( scope . mapOptions . scope ) ;%NWL%if ( data . values . length )  {%NWL%scope . mapOptions = mapData ( scope . mapOptions , data . values ) ;%NWL%}%NWL%scope . map = new Datamap ( scope . mapOptions ) ;%NWL%3
element . find ( ' #map - container ' ) . empty ( ) ;%NWL%}%NWL%} ;%NWL%scope . $watch ( ' [ options , colors ] ' , function ( )  {%NWL%scope . api . refresh ( ) ;%NWL%} , true ) ;%NWL%scope . $watch ( ' data ' , function ( data , old )  {%NWL%if ( !data . length )  {%NWL%scope . api . updateWithData ( { values: [ ]  } ) ;%NWL%}%NWL%scope . api . refresh ( ) ;%NWL%4
} ) ;%NWL%}%NWL%} ,%NWL%updateWithOptions: function ( options )  {%NWL%scope . api . clearElement ( ) ;%NWL%if ( angular . isDefined ( options ) === false ) return;%NWL%if ( !scope . _config . visible ) return;%NWL%scope . chart = nv . models [ options . chart . type ] ( ) ;%NWL%if ( scope . colors && !scope . options . customColors )  {%NWL%scope . chart . color ( scope . colors ) ;%NWL%scope . options . chart . barColor = scope . colors;%NWL%7
} ,%NWL%updateWithOptions: function ( options )  {%NWL%scope . api . clearElement ( ) ;%NWL%if ( angular . isDefined ( options ) === false ) return;%NWL%if ( !scope . _config . visible ) return;%NWL%scope . chart = nv . models [ options . chart . type ] ( ) ;%NWL%if ( scope . colors && !scope . options . customColors )  {%NWL%scope . chart . color ( scope . colors ) ;%NWL%if ( scope . data . length === 1 && scope . options . chart . type === ' multiBarHorizontalChart ' )  {%NWL%scope . options . chart . barColor = scope . colors;%NWL%scope . options . chart . barColor = null;%NWL%5
scope . addGroup = function ( )  {%NWL%if ( !scope . newDataGroup )  {%NWL%return false;%NWL%}%NWL%chartbuilderData . addGroup ( scope . newDataGroup ) ;%NWL%scope . newDataGroup = ' ' ;%NWL%} ;%NWL%scope . duplicateGroup = function ( )  {%NWL%if ( !scope . newDataGroup )  {%NWL%return false;%NWL%chartbuilderData . duplicateGroup ( scope . newDataGroup ) ;%NWL%4
scope . editing = false;%NWL%scope . edit = function ( )  {%NWL%scope . editing = true;%NWL%element . addClass ( ' active ' ) ;%NWL%inputElement [ 0 ] . focus ( ) ;%NWL%} ;%NWL%inputElement . bind ( ' keydown keypress ' , function ( event )  {%NWL%if ( event . which === 13 )  {%NWL%if ( !scope . value . toString ( ) . length )  {%NWL%element . addClass ( ' empty ' ) ;%NWL%element . removeClass ( ' empty ' ) ;%NWL%9
element . addClass ( ' active ' ) ;%NWL%inputElement [ 0 ] . focus ( ) ;%NWL%} ;%NWL%inputElement . bind ( ' keydown keypress ' , function ( event )  {%NWL%if ( event . which === 13 )  {%NWL%if ( !scope . value . toString ( ) . length )  {%NWL%element . addClass ( ' empty ' ) ;%NWL%} else {%NWL%element . removeClass ( ' empty ' ) ;%NWL%}%NWL%element . removeClass ( ' active ' ) ;%NWL%0
if ( !scope . value . toString ( ) . length )  {%NWL%element . addClass ( ' empty ' ) ;%NWL%} else {%NWL%element . removeClass ( ' empty ' ) ;%NWL%}%NWL%scope . editing = false;%NWL%element . removeClass ( ' active ' ) ;%NWL%}%NWL%} ) ;%NWL%inputElement . bind ( ' blur ' , function ( )  {%NWL%element . addClass ( ' empty ' ) ;%NWL%1
} else {%NWL%element . removeClass ( ' empty ' ) ;%NWL%}%NWL%scope . editing = false;%NWL%element . removeClass ( ' active ' ) ;%NWL%}%NWL%} ) ;%NWL%inputElement . bind ( ' blur ' , function ( )  {%NWL%if ( !scope . value . toString ( ) . length )  {%NWL%element . addClass ( ' empty ' ) ;%NWL%element . removeClass ( ' empty ' ) ;%NWL%1
scope . editing = false;%NWL%element . removeClass ( ' active ' ) ;%NWL%}%NWL%} ) ;%NWL%inputElement . bind ( ' blur ' , function ( )  {%NWL%if ( !scope . value . toString ( ) . length )  {%NWL%element . addClass ( ' empty ' ) ;%NWL%} else {%NWL%element . removeClass ( ' empty ' ) ;%NWL%}%NWL%element . removeClass ( ' active ' ) ;%NWL%1
require ( ' RGBColor ' ) ;%NWL%require ( ' StackBlur ' ) ;%NWL%var canvg = require ( ' . . / . . / bower_components / canvg / canvg ' ) ;%NWL%function copySvg ( svgEl )  {%NWL%var copyEl = svgEl . cloneNode ( true ) ,%NWL%defs = document . createElement ( ' defs ' ) ;%NWL%copyEl . insertBefore ( defs , copyEl . firstChild ) ;%NWL%var appliedStyles = ' ' ,%NWL%sheets = document . styleSheets;%NWL%%NWL%var style = document . createElement ( ' style ' ) ;%NWL%2
!angular . isUndefined ( msgObj . data ) &&%NWL%msgObj . data%NWL%)  {%NWL%switch ( msgObj . msg )  {%NWL%case ' savedData ' :%NWL%console . log ( ' App iframe received savedData from WordPress ' ) ;%NWL%console . log ( msgObj . data ) ;%NWL%chartbuilderData . load ( msgObj . data ) ;%NWL%break;%NWL%case ' options ' :%NWL%console . log ( msgObj . data ) ;%NWL%6
} else if ( angular . isDefined ( init . highcharts ) )  {%NWL%this . type = ' highcharts ' ;%NWL%this . highcharts = init . highcharts;%NWL%}%NWL%if ( angular . isDefined ( init . meta ) )  {%NWL%this . meta = init . meta;%NWL%}%NWL%if ( angular . isDefined ( ( chartbuilderDefaultOptions . options || { } ) . meta ) )  {%NWL%this . meta = angular . extend ( this . meta , chartbuilderDefaultOptions . options . meta ) ;%NWL%}%NWL%this . options . chart = angular . extend ( this . options . chart , chartbuilderDefaultOptions . options . chart ) ;%NWL%8
}%NWL%if ( angular . isDefined ( init . meta ) )  {%NWL%this . meta = init . meta;%NWL%}%NWL%if ( angular . isDefined ( ( chartbuilderDefaultOptions . options || { } ) . meta ) )  {%NWL%this . meta = angular . extend ( this . meta , chartbuilderDefaultOptions . options . meta ) ;%NWL%}%NWL%if ( angular . isDefined ( ( chartbuilderDefaultOptions . options || { } ) . chart ) )  {%NWL%this . options . chart = angular . extend ( this . options . chart , chartbuilderDefaultOptions . options . chart ) ;%NWL%}%NWL%this . colors = init . colors;%NWL%5
}%NWL%if ( angular . isDefined ( ( chartbuilderDefaultOptions . options || { } ) . meta ) )  {%NWL%this . meta = angular . extend ( this . meta , chartbuilderDefaultOptions . options . meta ) ;%NWL%}%NWL%if ( angular . isDefined ( ( chartbuilderDefaultOptions . options || { } ) . chart ) )  {%NWL%this . options . chart = angular . extend ( this . options . chart , chartbuilderDefaultOptions . options . chart ) ;%NWL%}%NWL%if ( angular . isDefined ( init . colors ) )  {%NWL%this . colors = init . colors;%NWL%}%NWL%this . colors = chartbuilderDefaultOptions . options . colors;%NWL%2
var url = require ( ' url ' ) ;%NWL%var webpack = require ( ' webpack ' ) ;%NWL%var config = require ( ' . / webpack . config ' ) ;%NWL%0
var url = require ( ' url ' ) ;%NWL%var webpack = require ( ' webpack ' ) ;%NWL%var WebpackDevServer = require ( ' webpack - dev - server ' ) ;%NWL%var open = require ( ' open ' ) ;%NWL%0
var url = require ( ' url ' )%NWL%var express = require ( ' express ' ) ;%NWL%0
var url = require ( ' url ' )%NWL%var fs = require ( ' fs ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%var superagent = require ( ' superagent ' ) ;%NWL%0
var url = require ( ' url ' )%NWL%var fs = require ( ' fs ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%var _ = require ( ' lodash ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%0
var url = require ( ' url ' )%NWL%var fs = require ( ' fs ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%var _ = require ( ' lodash ' ) ;%NWL%var superagent = require ( ' superagent ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var url = require ( ' url ' )%NWL%var fs = require ( ' fs ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%var _ = require ( ' lodash ' ) ;%NWL%var superagent = require ( ' superagent ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var https = require ( ' https ' ) ;%NWL%0
var path = req . params [ 0 ] ;%NWL%var jsonData= { } ;%NWL%var options = {%NWL%path: ( ' / '  + path ) ,%NWL%method: ' GET '%NWL%}%NWL%var request = http . request;%NWL%if ( cert_path )  {%NWL%request = https . request;%NWL%options . ca = fs . readFileSync ( cert_path +  ' / ca . pem ' ) ;%NWL%options . key = fs . readFileSync ( cert_path +  ' / key . pem ' ) ;%NWL%9
if ( cert_path )  {%NWL%request = https . request;%NWL%options . ca = fs . readFileSync ( cert_path +  ' / ca . pem ' ) ;%NWL%options . cert = fs . readFileSync ( cert_path +  ' / cert . pem ' ) ;%NWL%options . key = fs . readFileSync ( cert_path +  ' / key . pem ' ) ;%NWL%}%NWL%if ( docker_host )  {%NWL%options . host = docker_host;%NWL%options . port = docker_port;%NWL%}%NWL%options . socketPath = ' / var / run / docker . sock ' ;%NWL%2
addNode ( node ) ;%NWL%} else {%NWL%for ( let currentnode of currentnodelist )  {%NWL%if ( node . ID == currentnode . ID )  {%NWL%name = node . Description . Hostname;%NWL%if ( name . length>0 )  {%NWL%currentnode . Description . Hostname = name ;%NWL%currentnode . name = name + " <br / > " + node . Spec . Role +%NWL%" <br / > " + ( currentnode . Description . Resources . MemoryBytes / 1024 / 1024 / 1024 ) . toFixed ( 3 ) + " G RAM <br / > " ;%NWL%for ( var key in node . Spec . Labels )  {%NWL%currentnode . name + = " <br / > "  + key +  " = "  + node . Spec . Labels [ key ] ;%NWL%7
tabPhysical . addEventListener ( ' click ' , ( ) => {%NWL%removeClass ( physical ,  ' hidden ' ) ;%NWL%removeClass ( tabPhysical ,  ' hidden ' ) ;%NWL%document . body . className = ' tab2 ' ;%NWL%} ) ;%NWL%function reload ( ) {%NWL%provider . reload ( ) ;%NWL%setTimeout ( reload , MS ) ;%NWL%}%NWL%console . log ( " Polling refresh: "  + MS ) ;%NWL%provider . start ( ) ;%NWL%6
clusterEnter%NWL%. append ( ' div ' )%NWL%. classed ( ' node - cluster - content ' , true ) ;%NWL%node = cluster%NWL%. select ( ' . node - cluster - content ' )%NWL%. selectAll ( ' . node ' ) . data ( ( d ) => d . children ) ;%NWL%nodeEnter = node . enter ( )%NWL%. append ( ' div ' )%NWL%. classed ( ' node ' , true )%NWL%nodeEnter . append ( ' div ' )%NWL%nodeEnter . append ( ' div ' )%NWL%9
else if ( elementTag === " input " && elementType === " radio "  )  {%NWL%var elementName = vars . data . element . value . node ( ) . getAttribute ( " name " )%NWL%if ( elementName )  {%NWL%vars . self . container ( { " id " : elementName } )%NWL%}%NWL%vars . data . element . value%NWL%. each ( function ( o , i ) {%NWL%var data_obj = { }%NWL%get_attributes ( data_obj , this )%NWL%var id = data_obj [ vars . id . value ] || this . id || false%NWL%var label = d3 . select ( " label [ for= " + id + " ] " )%NWL%9
return options [ maxProp ] ;%NWL%} else if ( valOk )  {%NWL%return options [ prop ] ;%NWL%} else {%NWL%return ' auto ' ;%NWL%}%NWL%}%NWL%export function updateSizeOptions ( options )  {%NWL%options = merge ( { } , options ) ;%NWL%options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . x = addMarginToX ( + ( options . x || 0 ) , options . align , options . margin ) ;%NWL%9
} else if ( valOk )  {%NWL%return options [ prop ] ;%NWL%} else {%NWL%return ' auto ' ;%NWL%}%NWL%}%NWL%export function updateSizeOptions ( options )  {%NWL%options = merge ( { } , options ) ;%NWL%options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . margin = toArrayLen4 ( options . margin ) ;%NWL%options . y = addMarginToY ( + ( options . y || 0 ) , options . verticalAlign , options . margin ) ;%NWL%8
return options [ prop ] ;%NWL%} else {%NWL%return ' auto ' ;%NWL%}%NWL%}%NWL%export function updateSizeOptions ( options )  {%NWL%options = merge ( { } , options ) ;%NWL%options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . margin = toArrayLen4 ( options . margin ) ;%NWL%options . x = addMarginToX ( + ( options . x || 0 ) , options . align , options . margin ) ;%NWL%options . width = isPosNum ( options . width ) ? options . width : ' auto ' ;%NWL%7
} else {%NWL%return ' auto ' ;%NWL%}%NWL%}%NWL%export function updateSizeOptions ( options )  {%NWL%options = merge ( { } , options ) ;%NWL%options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . margin = toArrayLen4 ( options . margin ) ;%NWL%options . x = addMarginToX ( + ( options . x || 0 ) , options . align , options . margin ) ;%NWL%options . y = addMarginToY ( + ( options . y || 0 ) , options . verticalAlign , options . margin ) ;%NWL%options . maxWidth = isPosNum ( options . maxWidth ) ? options . maxWidth : ' auto ' ;%NWL%6
return ' auto ' ;%NWL%}%NWL%}%NWL%export function updateSizeOptions ( options )  {%NWL%options = merge ( { } , options ) ;%NWL%options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . margin = toArrayLen4 ( options . margin ) ;%NWL%options . x = addMarginToX ( + ( options . x || 0 ) , options . align , options . margin ) ;%NWL%options . y = addMarginToY ( + ( options . y || 0 ) , options . verticalAlign , options . margin ) ;%NWL%options . width = isPosNum ( options . width ) ? options . width : ' auto ' ;%NWL%options . height = isPosNum ( options . height ) ? options . height : ' auto ' ;%NWL%5
}%NWL%}%NWL%export function updateSizeOptions ( options )  {%NWL%options = merge ( { } , options ) ;%NWL%options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . margin = toArrayLen4 ( options . margin ) ;%NWL%options . x = addMarginToX ( + ( options . x || 0 ) , options . align , options . margin ) ;%NWL%options . y = addMarginToY ( + ( options . y || 0 ) , options . verticalAlign , options . margin ) ;%NWL%options . width = isPosNum ( options . width ) ? options . width : ' auto ' ;%NWL%options . maxWidth = isPosNum ( options . maxWidth ) ? options . maxWidth : ' auto ' ;%NWL%options . maxHeight = isPosNum ( options . maxHeight ) ? options . maxHeight : ' auto ' ;%NWL%4
}%NWL%export function updateSizeOptions ( options )  {%NWL%options = merge ( { } , options ) ;%NWL%options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . margin = toArrayLen4 ( options . margin ) ;%NWL%options . x = addMarginToX ( + ( options . x || 0 ) , options . align , options . margin ) ;%NWL%options . y = addMarginToY ( + ( options . y || 0 ) , options . verticalAlign , options . margin ) ;%NWL%options . width = isPosNum ( options . width ) ? options . width : ' auto ' ;%NWL%options . maxWidth = isPosNum ( options . maxWidth ) ? options . maxWidth : ' auto ' ;%NWL%options . height = isPosNum ( options . height ) ? options . height : ' auto ' ;%NWL%options . maxLines = isPosNum ( options . maxLines ) ? options . maxLines : ' auto ' ;%NWL%3
options . padding = toArrayLen4 ( options . padding ) ;%NWL%options . margin = toArrayLen4 ( options . margin ) ;%NWL%options . x = addMarginToX ( + ( options . x || 0 ) , options . align , options . margin ) ;%NWL%options . y = addMarginToY ( + ( options . y || 0 ) , options . verticalAlign , options . margin ) ;%NWL%options . width = isPosNum ( options . width ) ? options . width : ' auto ' ;%NWL%options . maxWidth = isPosNum ( options . maxWidth ) ? options . maxWidth : ' auto ' ;%NWL%options . height = isPosNum ( options . height ) ? options . height : ' auto ' ;%NWL%options . maxHeight = isPosNum ( options . maxHeight ) ? options . maxHeight : ' auto ' ;%NWL%options . maxLines = isPosNum ( options . maxLines ) ? options . maxLines : ' auto ' ;%NWL%if ( isPosNum ( options . outerWidth ) )  {%NWL%options . maxWidth = isPosNum ( options . maxWidth ) ?%NWL%0
options . maxWidth = isPosNum ( options . maxWidth ) ? options . maxWidth : ' auto ' ;%NWL%options . height = isPosNum ( options . height ) ? options . height : ' auto ' ;%NWL%options . maxHeight = isPosNum ( options . maxHeight ) ? options . maxHeight : ' auto ' ;%NWL%options . maxLines = isPosNum ( options . maxLines ) ? options . maxLines : ' auto ' ;%NWL%if ( isPosNum ( options . outerWidth ) )  {%NWL%const maxWidth = options . outerWidth - options . margin [ 3 ]  - options . margin [ 1 ] ;%NWL%options . maxWidth = isPosNum ( options . maxWidth ) ?%NWL%Math . min ( maxWidth , options . maxWidth ) : maxWidth;%NWL%}%NWL%if ( isPosNum ( options . outerHeight ) )  {%NWL%options . maxHeight = isPosNum ( options . maxHeight ) ?%NWL%0
writeInnerHTML ( tspan , str ) ;%NWL%return tspan;%NWL%}%NWL%export function writeInnerHTML ( svgEl , content )  {%NWL%svgEl . innerHTML = content;%NWL%const tempEl = document . createElement ( ' div ' ) ;%NWL%tempEl . innerHTML = `<svg>$ { content } < / svg>`;%NWL%Array . prototype . slice . call ( svgEl . childNodes ) . forEach ( el => {%NWL%svgEl . removeChild ( el ) ;%NWL%} ) ;%NWL%svgEl . appendChild ( el ) ;%NWL%8
import { writeStyle } from ' . / style ' ;%NWL%import render from ' . / render ' ;%NWL%import isFinite from ' lodash . isfinite ' ;%NWL%import merge from ' lodash . merge ' ;%NWL%let _svgEl = null;%NWL%let _styleEl = null;%NWL%export default class SvgText {%NWL%%NWL%constructor ( options )  {%NWL%this . options = updateOptions ( options ) ;%NWL%this . rect = this . options . rect ? createRect ( this . options ) : null;%NWL%9
import render from ' . / render ' ;%NWL%import isFinite from ' lodash . isfinite ' ;%NWL%import merge from ' lodash . merge ' ;%NWL%let _svgEl = null;%NWL%let _styleEl = null;%NWL%export default class SvgText {%NWL%%NWL%constructor ( options )  {%NWL%this . options = updateOptions ( options ) ;%NWL%this . uid = this . options . uid;%NWL%this . text = createText ( this . options ) ;%NWL%8
let _svgEl = null;%NWL%let _styleEl = null;%NWL%export default class SvgText {%NWL%%NWL%constructor ( options )  {%NWL%this . options = updateOptions ( options ) ;%NWL%this . uid = this . options . uid;%NWL%this . rect = this . options . rect ? createRect ( this . options ) : null;%NWL%this . text = createText ( this . options ) ;%NWL%writeStyleAsCss ( this . options ) ;%NWL%this . fontSize = parseFloat ( compStyle . getPropertyValue ( ' font - size ' ) ) ;%NWL%5
let _styleEl = null;%NWL%export default class SvgText {%NWL%%NWL%constructor ( options )  {%NWL%this . options = updateOptions ( options ) ;%NWL%this . uid = this . options . uid;%NWL%this . rect = this . options . rect ? createRect ( this . options ) : null;%NWL%this . text = createText ( this . options ) ;%NWL%writeStyleAsCss ( this . options ) ;%NWL%const compStyle = window . getComputedStyle ( this . text , null ) ;%NWL%this . lineHeight = parseFloat ( compStyle . getPropertyValue ( ' line - height ' ) ) ||%NWL%4
%NWL%constructor ( options )  {%NWL%this . options = updateOptions ( options ) ;%NWL%this . uid = this . options . uid;%NWL%this . rect = this . options . rect ? createRect ( this . options ) : null;%NWL%this . text = createText ( this . options ) ;%NWL%writeStyleAsCss ( this . options ) ;%NWL%const compStyle = window . getComputedStyle ( this . text , null ) ;%NWL%this . fontSize = parseFloat ( compStyle . getPropertyValue ( ' font - size ' ) ) ;%NWL%this . lineHeight = parseFloat ( compStyle . getPropertyValue ( ' line - height ' ) ) ||%NWL%this . lines = render ( this . text , this . options , this . lineHeight ) ;%NWL%2
constructor ( options )  {%NWL%this . options = updateOptions ( options ) ;%NWL%this . uid = this . options . uid;%NWL%this . rect = this . options . rect ? createRect ( this . options ) : null;%NWL%this . text = createText ( this . options ) ;%NWL%writeStyleAsCss ( this . options ) ;%NWL%const compStyle = window . getComputedStyle ( this . text , null ) ;%NWL%this . fontSize = parseFloat ( compStyle . getPropertyValue ( ' font - size ' ) ) ;%NWL%this . lineHeight = parseFloat ( compStyle . getPropertyValue ( ' line - height ' ) ) ||%NWL%this . fontSize * 1 . 2;%NWL%this . bounds = sizeBounds ( this . text , this . options ) ;%NWL%1
if ( styleEl && SvgText . svg )  {%NWL%selector = `$ { getSelectorNamespace ( SvgText . svg ) } $ { selector } `;%NWL%writeStyle ( selector , css , styleEl ) ;%NWL%}%NWL%}%NWL%}%NWL%function updateOptions ( options )  {%NWL%options . uid = uid ( ) ;%NWL%options = updateEnvironment ( options ) ;%NWL%options = updateClassname ( options ) ;%NWL%options . attrs = ( options . attrs && typeof options . attrs === ' object ' ) ?%NWL%7
}%NWL%function updateOptions ( options )  {%NWL%options . uid = uid ( ) ;%NWL%options = updateEnvironment ( options ) ;%NWL%options = updateClassname ( options ) ;%NWL%options = updateSizeOptions ( options ) ;%NWL%options . attrs = ( options . attrs && typeof options . attrs === ' object ' ) ?%NWL%normalizeKeys ( options . attrs ,  ' css ' ) : { } ;%NWL%return options;%NWL%}%NWL%options . svg = options . svg || _svgEl || null;%NWL%2
function updateOptions ( options )  {%NWL%options . uid = uid ( ) ;%NWL%options = updateEnvironment ( options ) ;%NWL%options = updateClassname ( options ) ;%NWL%options = updateSizeOptions ( options ) ;%NWL%options . attrs = ( options . attrs && typeof options . attrs === ' object ' ) ?%NWL%normalizeKeys ( options . attrs ,  ' css ' ) : { } ;%NWL%return options;%NWL%}%NWL%function updateEnvironment ( options )  {%NWL%options . styleElement = options . styleElement || _styleEl || null;%NWL%1
( options . element || document . body ) . appendChild ( svgEl ) ;%NWL%}%NWL%options . svg = svgEl;%NWL%if ( !options . svg . hasAttribute ( ' data - svgtext ' ) )  {%NWL%options . svg . setAttribute ( ' data - svgtext ' , getSvgUid ( ) ) ;%NWL%}%NWL%if ( !options . selectorNamespace || typeof options . selectorNamespace !== ' string ' )  {%NWL%options . selectorNamespace = getSelectorNamespace ( options . svg ) ;%NWL%}%NWL%options . styleElement = options . styleElement || options . svg . querySelector ( ' style ' ) ;%NWL%options . styleElement = document . createElement ( ' style ' ) ;%NWL%9
}%NWL%options . styleElement = options . styleElement || options . svg . querySelector ( ' style ' ) ;%NWL%if ( !options . styleElement )  {%NWL%options . styleElement = document . createElement ( ' style ' ) ;%NWL%const firstChild = options . svg . childNodes [ 0 ] ;%NWL%if ( firstChild )  {%NWL%options . svg . insertBefore ( options . styleElement , firstChild ) ;%NWL%} else {%NWL%options . svg . appendChild ( options . styleElement ) ;%NWL%}%NWL%options . element = options . element || options . svg;%NWL%1
const textOptions = normalizeKeys ( merge ( { } , options . attrs ,%NWL%{  ' ai - id ' : options . uid } ) ) ;%NWL%const text = createElement ( ' text ' , textOptions ) ;%NWL%if ( options . className )  {%NWL%text . setAttribute ( ' class ' , options . className . replace ( / \ . / ,  '  ' ) ) ;%NWL%}%NWL%options . element . appendChild ( text ) ;%NWL%return text;%NWL%}%NWL%function writeStyleAsCss ( options )  {%NWL%const selectorNamespace = options . selectorNamespace || null;%NWL%2
{  ' ai - id ' : options . uid } ) ) ;%NWL%const text = createElement ( ' text ' , textOptions ) ;%NWL%if ( options . className )  {%NWL%text . setAttribute ( ' class ' , options . className . replace ( / \ . / ,  '  ' ) ) ;%NWL%}%NWL%options . element . appendChild ( text ) ;%NWL%return text;%NWL%}%NWL%function writeStyleAsCss ( options )  {%NWL%if ( options . style && options . styleElement )  {%NWL%const className = options . className ? ( ' . '  + options . className ) . replace ( '  ' ,  ' . ' ) : null;%NWL%1
function sizeBounds ( text , options )  {%NWL%const p = options . padding;%NWL%const textRect = text . getBoundingClientRect ( ) ;%NWL%const bounds = {%NWL%x: options . x ,%NWL%y: options . y ,%NWL%width: textRect . width ,%NWL%height: textRect . height ,%NWL%} ;%NWL%bounds . width = isPosNum ( options . width ) ? options . width : ( textRect . width + p [ 3 ]  + p [ 1 ] ) ;%NWL%bounds . x - = bounds . width;%NWL%9
const textRect = text . getBoundingClientRect ( ) ;%NWL%const bounds = {%NWL%x: options . x ,%NWL%y: options . y ,%NWL%width: textRect . width ,%NWL%height: textRect . height ,%NWL%} ;%NWL%bounds . width = isPosNum ( options . width ) ? options . width : ( textRect . width + p [ 3 ]  + p [ 1 ] ) ;%NWL%if ( options . align === ' right ' )  {%NWL%bounds . x - = bounds . width;%NWL%bounds . x - = bounds . width / 2;%NWL%7
x: options . x ,%NWL%y: options . y ,%NWL%width: textRect . width ,%NWL%height: textRect . height ,%NWL%} ;%NWL%bounds . width = isPosNum ( options . width ) ? options . width : ( textRect . width + p [ 3 ]  + p [ 1 ] ) ;%NWL%if ( options . align === ' right ' )  {%NWL%bounds . x - = bounds . width;%NWL%} else if ( options . align === ' center ' )  {%NWL%bounds . x - = bounds . width / 2;%NWL%bounds . height = isPosNum ( options . height ) ? options . height :%NWL%5
height: textRect . height ,%NWL%} ;%NWL%bounds . width = isPosNum ( options . width ) ? options . width : ( textRect . width + p [ 3 ]  + p [ 1 ] ) ;%NWL%if ( options . align === ' right ' )  {%NWL%bounds . x - = bounds . width;%NWL%} else if ( options . align === ' center ' )  {%NWL%bounds . x - = bounds . width / 2;%NWL%}%NWL%bounds . height = isPosNum ( options . height ) ? options . height :%NWL%( textRect . height + p [ 0 ]  + p [ 2 ] ) ;%NWL%bounds . y - = bounds . height;%NWL%2
bounds . width = isPosNum ( options . width ) ? options . width : ( textRect . width + p [ 3 ]  + p [ 1 ] ) ;%NWL%if ( options . align === ' right ' )  {%NWL%bounds . x - = bounds . width;%NWL%} else if ( options . align === ' center ' )  {%NWL%bounds . x - = bounds . width / 2;%NWL%}%NWL%bounds . height = isPosNum ( options . height ) ? options . height :%NWL%( textRect . height + p [ 0 ]  + p [ 2 ] ) ;%NWL%if ( options . verticalAlign === ' bottom ' )  {%NWL%bounds . y - = bounds . height;%NWL%bounds . y - = bounds . height / 2;%NWL%0
var set = vars . nodes . value . filter ( function ( n ) {%NWL%return typeof n . x === " number " && typeof n . y === " number " ;%NWL%} ) . length;%NWL%if ( set === vars . nodes . value . length )  {%NWL%vars . nodes . positions = true;%NWL%}%NWL%else {%NWL%var force = d3 . layout . force ( )%NWL%. size ( [ vars . width . viz , vars . height . viz ] )%NWL%. nodes ( vars . nodes . value )%NWL%var strength = vars . edges . strength . value;%NWL%7
}%NWL%}%NWL%var iterations = 50 ,%NWL%threshold = 0 . 01;%NWL%force . start ( ) ; / / Defaults to alpha = 0 . 1%NWL%for ( var i = iterations; i > 0; - - i )  {%NWL%force . tick ( ) ;%NWL%if ( force . alpha ( ) < threshold )  {%NWL%break;%NWL%}%NWL%force . stop ( ) ;%NWL%6
Backbone . d3 = {%NWL%PlotView: Backbone . View . extend ( {%NWL%initialize: function ( collection , settings )  {%NWL%_ . bindAll ( this ) ;%NWL%this . collection = collection;%NWL%this . collection . bind ( ' change ' , this . redraw ) ;%NWL%this . collection . bind ( ' add ' , this . redraw ) ;%NWL%this . collection . bind ( ' remove ' , this . redraw ) ;%NWL%this . collection . bind ( ' reset ' , this . draw ) ;%NWL%this . settings = settings || { } ;%NWL%this . div = d3 . select ( divname )%NWL%9
PlotView: Backbone . View . extend ( {%NWL%initialize: function ( collection , settings )  {%NWL%_ . bindAll ( this ) ;%NWL%this . collection = collection;%NWL%this . collection . bind ( ' change ' , this . redraw ) ;%NWL%this . collection . bind ( ' add ' , this . redraw ) ;%NWL%this . collection . bind ( ' remove ' , this . redraw ) ;%NWL%this . collection . bind ( ' reset ' , this . draw ) ;%NWL%this . settings = settings || { } ;%NWL%var divname = this . settings . div || " #plot " ;%NWL%this . duration = this . settings . duration || 500;%NWL%8
} ;%NWL%}%NWL%var captiondiv = $ ( ' <div / > ' ,  { class: " caption " , html: caption } ) ;%NWL%$ ( this . settings . div ) . append ( captiondiv ) ;%NWL%}%NWL%}%NWL%} ) ,%NWL%PlotCollection: Backbone . Collection . extend ( {%NWL%initialize: function ( models , settings )  {%NWL%this . settings = settings || { } ;%NWL%this . caption = this . settings . caption || false;%NWL%9
for ( var i = 0 , l = models . length; i < l; i + + )  {%NWL%this . _add ( models [ i ] , options ) ;%NWL%}%NWL%} else {%NWL%this . _add ( models , options ) ;%NWL%}%NWL%return this;%NWL%} ,%NWL%remove : function ( models , options )  {%NWL%if ( _ . isArray ( models ) )  {%NWL%this . _remove ( models [ i ] , options ) ;%NWL%1
} else {%NWL%this . _add ( models , options ) ;%NWL%}%NWL%return this;%NWL%} ,%NWL%remove : function ( models , options )  {%NWL%if ( _ . isArray ( models ) )  {%NWL%for ( var i = 0 , l = models . length; i < l; i + + )  {%NWL%this . _remove ( models [ i ] , options ) ;%NWL%}%NWL%this . _remove ( models , options ) ;%NWL%1
fragment = window . location . hash;%NWL%}%NWL%}%NWL%fragment = decodeURIComponent ( fragment . replace ( hashStrip ,  ' ' ) ) ;%NWL%if ( !fragment . indexOf ( this . options . root ) ) fragment = fragment . substr ( this . options . root . length ) ;%NWL%return fragment;%NWL%} ,%NWL%start : function ( options )  {%NWL%if ( historyStarted ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%this . options     = _ . extend ( { } ,  { root: ' / ' } , this . options , options ) ;%NWL%this . _hasPushState  = !! ( this . options . pushState && window . history && window . history . pushState ) ;%NWL%9
return fragment;%NWL%} ,%NWL%start : function ( options )  {%NWL%if ( historyStarted ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%this . options     = _ . extend ( { } ,  { root: ' / ' } , this . options , options ) ;%NWL%this . _wantsPushState = !!this . options . pushState;%NWL%this . _hasPushState  = !! ( this . options . pushState && window . history && window . history . pushState ) ;%NWL%var fragment     = this . getFragment ( ) ;%NWL%var docMode      = document . documentMode;%NWL%var oldIE       = ( isExplorer . exec ( navigator . userAgent . toLowerCase ( ) ) && ( !docMode || docMode <= 7 ) ) ;%NWL%this . iframe = $ ( ' <iframe src= " javascript:0 " tabindex= " - 1 "  / > ' ) . hide ( ) . appendTo ( ' body ' ) [ 0 ] . contentWindow;%NWL%4
} ;%NWL%vars . self = function ( selection )  {%NWL%var large = vars . data . value instanceof Array && vars . data . value . length > vars . data . large;%NWL%vars . draw . timing = vars . draw . first || large || ie ? 0 : vars . timing . ui;%NWL%if ( vars . data . value instanceof Array )  {%NWL%if ( vars . dev . value ) print . group ( " drawing \ " " + vars . type . value + " \ " " ) ;%NWL%if ( vars . data . changed )  {%NWL%vars . data . cache = { } ;%NWL%dataKeys ( vars ,  " data "  ) ;%NWL%dataFormat ( vars ) ;%NWL%vars . data . viz = fetchData ( vars ) ;%NWL%3
}%NWL%vars . data . viz = fetchData ( vars ) ;%NWL%if ( vars . data . sort . value && ( vars . data . changed || vars . order . changed || vars . order . sort . changed )  )  {%NWL%arraySort ( vars . data . viz , vars . order . value || vars . text . value ,%NWL%vars . order . sort . value , vars . color . value , vars ) ;%NWL%}%NWL%if ( vars . focus . value === false && [ " auto " ,  " button " ] . indexOf ( vars . type . value ) < 0 )  {%NWL%var element = vars . data . element . value;%NWL%if ( element && element . node ( ) . tagName . toLowerCase ( ) === " select "  )  {%NWL%var i = element . property ( " selectedIndex " ) ;%NWL%var option = element . selectAll ( " option " ) [ 0 ] [ i ] ,%NWL%7
var markerRe = / ~K ( \d + ) K / ;%NWL%var end = grafs . length;%NWL%for ( var i = 0; i < end; i + + )  {%NWL%var str = grafs [ i ] ;%NWL%if ( markerRe . test ( str ) )  {%NWL%grafsOut . push ( str ) ;%NWL%}%NWL%else if ( / \S / . test ( str ) )  {%NWL%str = _RunSpanGamut ( str ) ;%NWL%str = str . replace ( / ^ ( [ \t ] * ) / g ,  " <p> " ) ;%NWL%grafsOut . push ( str ) ;%NWL%5
Backbone . d3 . Canned [ ' Bar ' ] = {%NWL%View: Backbone . d3 . PlotView . extend (%NWL%{%NWL%initialize: function ( collection , settings )  {%NWL%Backbone . d3 . PlotView . prototype . initialize . apply ( this ,  [ collection , settings ] ) ;%NWL%this . w = settings . w || 20;%NWL%this . scrolling = settings . scrolling || false;%NWL%5
Backbone . d3 . Canned [ ' Bar ' ] = {%NWL%View: Backbone . d3 . PlotView . extend (%NWL%{%NWL%initialize: function ( collection , settings )  {%NWL%Backbone . d3 . PlotView . prototype . initialize . apply ( this ,  [ collection , settings ] ) ;%NWL%this . w = settings . w || 20;%NWL%this . h = settings . h || 80;%NWL%this . size = settings . size || 5;%NWL%5
. attr ( " x " , function ( d , i )  { return x ( i )  -  . 5; } )%NWL%. attr ( " y " , function ( d )  { return yval ( d )  } )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " ,%NWL%function ( d )  { return scale * d . y; } ) ;%NWL%chart . append ( " svg:line " )%NWL%. attr ( " x1 " , 0 )%NWL%. attr ( " x2 " , w *  ( 1 + data . length ) )%NWL%. attr ( " y1 " , h -  . 5 )%NWL%. attr ( " y2 " , h -  . 5 )%NWL%chart . append ( " svg:line " )%NWL%5
. attr ( " y " , function ( d )  { return yval ( d )  } )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , function ( d )  { return scale * d . y; } )%NWL%. transition ( )%NWL%. duration ( this . duration )%NWL%. attr ( " x " , function ( d , i )  { return x ( i )  -  . 5; } ) ;%NWL%rect . transition ( )%NWL%. duration ( this . duration )%NWL%. attr ( " x " , function ( d , i )  { return x ( i )  -  . 5; } )%NWL%. attr ( " y " , function ( d , i )  { return yval ( d )  } )%NWL%rect . exit ( )%NWL%6
var w = this . w;%NWL%var h = this . h;%NWL%var data = this . plotdata ( ) ;%NWL%var interpolation = this . settings . interpolation || " linear " ;%NWL%var x = d3 . scale . linear ( )%NWL%. domain ( [ 0 , this . size ] )%NWL%. range ( [ 10 , w - 10 ] ) ;%NWL%var y = d3 . scale . linear ( )%NWL%. domain ( [ - 1 , 1 ] )%NWL%. rangeRound ( [ 10 , h - 10 ] ) ;%NWL%var line = d3 . svg . line ( )%NWL%3
modelIds: [ ] ,  / / Store model IDs - needed to make sure the correct pie%NWL%layout: d3 . layout . pie ( ) ,%NWL%initialize: function ( collection , settings )  {%NWL%Backbone . d3 . PlotView . prototype . initialize . apply ( this ,  [ collection , settings ] ) ;%NWL%this . collection . unbind ( ' add ' ) ;%NWL%this . collection . bind ( ' add ' , this . add ) ;%NWL%this . collection . unbind ( ' remove ' ) ;%NWL%this . collection . bind ( ' remove ' , this . remove ) ;%NWL%this . m = 10;%NWL%this . radius = settings . radius || 100;%NWL%this . arc = d3 . svg . arc ( )%NWL%9
" use strict " ;%NWL%const gulp = require ( ' gulp ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%1
" use strict " ;%NWL%const gulp = require ( ' gulp ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%1
" use strict " ;%NWL%const gulp = require ( ' gulp ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%1
" use strict " ;%NWL%const gulp = require ( ' gulp ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const uglify = require ( ' gulp - uglify ' ) ;%NWL%1
" use strict " ;%NWL%const gulp = require ( ' gulp ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%1
" use strict " ;%NWL%const gulp = require ( ' gulp ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const uglify = require ( ' gulp - uglify ' ) ;%NWL%const eslint = require ( " gulp - eslint " ) ;%NWL%1
" use strict " ;%NWL%const gulp = require ( ' gulp ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const uglify = require ( ' gulp - uglify ' ) ;%NWL%const sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%const eslint = require ( " gulp - eslint " ) ;%NWL%const runSequence = require ( ' run - sequence ' ) . use ( gulp ) ;%NWL%const toc = require ( ' markdown - toc ' ) ;%NWL%1
const browserify = require ( ' browserify ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const uglify = require ( ' gulp - uglify ' ) ;%NWL%const sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%const eslint = require ( " gulp - eslint " ) ;%NWL%const runSequence = require ( ' run - sequence ' ) . use ( gulp ) ;%NWL%const jsdoc2md = require ( " jsdoc - to - markdown " ) ;%NWL%const toc = require ( ' markdown - toc ' ) ;%NWL%const fs = Promise . promisifyAll ( require ( " fs " ) ) ;%NWL%0
const babelify = require ( ' babelify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const uglify = require ( ' gulp - uglify ' ) ;%NWL%const sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%const eslint = require ( " gulp - eslint " ) ;%NWL%const runSequence = require ( ' run - sequence ' ) . use ( gulp ) ;%NWL%const jsdoc2md = require ( " jsdoc - to - markdown " ) ;%NWL%const toc = require ( ' markdown - toc ' ) ;%NWL%const Promise = require ( " bluebird " ) ;%NWL%const karma = require ( ' karma ' ) ;%NWL%0
" use strict " ;%NWL%const XlsxPopulate = require ( ' . . / . . / lib / XlsxPopulate ' ) ;%NWL%XlsxPopulate . fromFileAsync ( ' . / template . xlsx ' )%NWL%const sheet = workbook . sheet ( ' ClickThroughRateSheet ' ) ;%NWL%1
" use strict " ;%NWL%const XlsxPopulate = require ( ' . . / . . / lib / XlsxPopulate ' ) ;%NWL%XlsxPopulate . fromBlankAsync ( )%NWL%const sheet = workbook . sheet ( " Sheet1 " ) ;%NWL%1
var str = vars . format . locale . value . dev . noContainer%NWL%var selector = vars . container . selector || " " ;%NWL%print . warning ( stringFormat ( str ,  " \ " "  + selector +  " \ " " )  ,  " container "  )%NWL%}%NWL%else {%NWL%if ( vars . dev . value ) print . time ( " total draw time " ) ;%NWL%vars . container . value . call ( vars . self ) ;%NWL%}%NWL%if ( typeof value === " function " && vars . history . chain . length )  {%NWL%var changesObject = { }%NWL%var method = c . method%NWL%1
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%const dateConverter = require ( " . / dateConverter " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%const addressConverter = require ( " . / addressConverter " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%const addressConverter = require ( " . / addressConverter " ) ;%NWL%const dateConverter = require ( " . / dateConverter " ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%const addressConverter = require ( " . / addressConverter " ) ;%NWL%const dateConverter = require ( " . / dateConverter " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const FormulaError = require ( " . / FormulaError " ) ;%NWL%2
formula ( )  {%NWL%return new ArgHandler ( ' Cell . formula ' )%NWL%. case ( ( ) => {%NWL%if ( this . _formulaType === " shared " && !this . _formulaRef ) return " SHARED " ;%NWL%return this . _formula;%NWL%} )%NWL%. case ( ' nil ' ,  ( ) => {%NWL%this . clear ( ) ;%NWL%return this;%NWL%} )%NWL%this . clear ( ) ;%NWL%7
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const addressConverter = require ( ' . / addressConverter ' ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Column = require ( " . / Column " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Row = require ( " . / Row " ) ;%NWL%const Range = require ( " . / Range " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Row = require ( " . / Row " ) ;%NWL%const Column = require ( " . / Column " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Row = require ( " . / Row " ) ;%NWL%const Column = require ( " . / Column " ) ;%NWL%const Range = require ( " . / Range " ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Row = require ( " . / Row " ) ;%NWL%const Column = require ( " . / Column " ) ;%NWL%const Range = require ( " . / Range " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Row = require ( " . / Row " ) ;%NWL%const Column = require ( " . / Column " ) ;%NWL%const Range = require ( " . / Range " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const addressConverter = require ( " . / addressConverter " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Row = require ( " . / Row " ) ;%NWL%const Column = require ( " . / Column " ) ;%NWL%const Range = require ( " . / Range " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const Cell = require ( " . / Cell " ) ;%NWL%const Row = require ( " . / Row " ) ;%NWL%const Column = require ( " . / Column " ) ;%NWL%const Range = require ( " . / Range " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const addressConverter = require ( " . / addressConverter " ) ;%NWL%const colorIndexes = require ( " . / colorIndexes " ) ;%NWL%2
" use strict " ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%1
" use strict " ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%const _ = require ( " lodash " ) ;%NWL%const colorIndexes = require ( " . / colorIndexes " ) ;%NWL%1
return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " horizontal " ) ;%NWL%}%NWL%_set_horizontalAlignment ( alignment )  {%NWL%xmlq . setChildAttributes ( this . _xfNode ,  ' alignment ' ,  { horizontal: alignment } ) ;%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%}%NWL%_get_justifyLastLine ( )  {%NWL%return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " justifyLastLine " ) === 1;%NWL%}%NWL%_set_justifyLastLine ( justifyLastLine )  {%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%4
return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " justifyLastLine " ) === 1;%NWL%}%NWL%_set_justifyLastLine ( justifyLastLine )  {%NWL%xmlq . setChildAttributes ( this . _xfNode ,  ' alignment ' ,  { justifyLastLine: justifyLastLine ? 1 : null } ) ;%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%}%NWL%_get_indent ( )  {%NWL%return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " indent " ) ;%NWL%}%NWL%_set_indent ( indent )  {%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%4
return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " indent " ) ;%NWL%}%NWL%_set_indent ( indent )  {%NWL%xmlq . setChildAttributes ( this . _xfNode ,  ' alignment ' ,  { indent } ) ;%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%}%NWL%_get_verticalAlignment ( )  {%NWL%return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " vertical " ) ;%NWL%}%NWL%_set_verticalAlignment ( alignment )  {%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%4
return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " vertical " ) ;%NWL%}%NWL%_set_verticalAlignment ( alignment )  {%NWL%xmlq . setChildAttributes ( this . _xfNode ,  ' alignment ' ,  { vertical: alignment } ) ;%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%}%NWL%_get_wrapText ( )  {%NWL%return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " wrapText " ) === 1;%NWL%}%NWL%_set_wrapText ( wrapText )  {%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%4
return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " wrapText " ) === 1;%NWL%}%NWL%_set_wrapText ( wrapText )  {%NWL%xmlq . setChildAttributes ( this . _xfNode ,  ' alignment ' ,  { wrapText: wrapText ? 1 : null } ) ;%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%}%NWL%_get_shrinkToFit ( )  {%NWL%return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " shrinkToFit " ) === 1;%NWL%}%NWL%_set_shrinkToFit ( shrinkToFit )  {%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%4
let readingOrder;%NWL%if ( textDirection === " left - to - right " ) readingOrder = 1;%NWL%else if ( textDirection === " right - to - left " ) readingOrder = 2;%NWL%xmlq . setChildAttributes ( this . _xfNode ,  ' alignment ' ,  { readingOrder } ) ;%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%}%NWL%_getTextRotation ( )  {%NWL%return xmlq . getChildAttribute ( this . _xfNode ,  ' alignment ' ,  " textRotation " ) ;%NWL%}%NWL%_setTextRotation ( textRotation )  {%NWL%xmlq . removeChildIfEmpty ( this . _xfNode ,  ' alignment ' ) ;%NWL%4
} ;%NWL%this . _fillNode . children . push ( patternFill ) ;%NWL%this . _setColor ( patternFill ,  " fgColor " , fill . color ) ;%NWL%}%NWL%_getBorder ( )  {%NWL%const result = { } ;%NWL%[ " left " ,  " right " ,  " top " ,  " bottom " ,  " diagonal " ] . forEach ( side => {%NWL%const sideNode = xmlq . findChild ( this . _borderNode , side ) ;%NWL%const sideResult = { } ;%NWL%const style = xmlq . getChildAttribute ( this . _borderNode , side ,  ' style ' ) ;%NWL%const color = this . _getColor ( sideNode ,  ' color ' ) ;%NWL%9
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const ContentTypes = require ( " . / ContentTypes " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%2
" use strict " ;%NWL%const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%const ContentTypes = require ( " . / ContentTypes " ) ;%NWL%const SharedStrings = require ( " . / SharedStrings " ) ;%NWL%2
const _ = require ( " lodash " ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%const ContentTypes = require ( " . / ContentTypes " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const StyleSheet = require ( " . / StyleSheet " ) ;%NWL%1
const fs = require ( " fs " ) ;%NWL%const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%const ContentTypes = require ( " . / ContentTypes " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const SharedStrings = require ( " . / SharedStrings " ) ;%NWL%const XmlParser = require ( " . / XmlParser " ) ;%NWL%0
const JSZip = require ( ' jszip ' ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%const ContentTypes = require ( " . / ContentTypes " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const SharedStrings = require ( " . / SharedStrings " ) ;%NWL%const StyleSheet = require ( " . / StyleSheet " ) ;%NWL%const XmlBuilder = require ( " . / XmlBuilder " ) ;%NWL%1
const externals = require ( " . / externals " ) ;%NWL%const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%const ContentTypes = require ( " . / ContentTypes " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const SharedStrings = require ( " . / SharedStrings " ) ;%NWL%const StyleSheet = require ( " . / StyleSheet " ) ;%NWL%const XmlParser = require ( " . / XmlParser " ) ;%NWL%const ArgHandler = require ( " . / ArgHandler " ) ;%NWL%0
const regexify = require ( " . / regexify " ) ;%NWL%const blank = require ( " . / blank " ) ( ) ;%NWL%const xmlq = require ( " . / xmlq " ) ;%NWL%const Sheet = require ( " . / Sheet " ) ;%NWL%const ContentTypes = require ( " . / ContentTypes " ) ;%NWL%const Relationships = require ( " . / Relationships " ) ;%NWL%const SharedStrings = require ( " . / SharedStrings " ) ;%NWL%const StyleSheet = require ( " . / StyleSheet " ) ;%NWL%const XmlParser = require ( " . / XmlParser " ) ;%NWL%const XmlBuilder = require ( " . / XmlBuilder " ) ;%NWL%const addressConverter = require ( " . / addressConverter " ) ;%NWL%0
_setSheetRefs ( )  {%NWL%let bookViewsNode = xmlq . findChild ( this . _node ,  " bookViews " ) ;%NWL%if ( !bookViewsNode )  {%NWL%bookViewsNode = { name: ' bookViews ' , attributes: { } , children: [ ]  } ;%NWL%xmlq . insertInOrder ( this . _node , bookViewsNode , nodeOrder ) ;%NWL%}%NWL%let workbookViewNode = xmlq . findChild ( bookViewsNode ,  " workbookView " ) ;%NWL%if ( !workbookViewNode )  {%NWL%workbookViewNode = { name: ' workbookView ' , attributes: { } , children: [ ]  } ;%NWL%xmlq . appendChild ( bookViewsNode , workbookViewNode ) ;%NWL%workbookViewNode . attributes . activeTab = this . _sheets . indexOf ( this . _activeSheet ) ;%NWL%8
" use strict " ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const FormulaError = require ( " . / FormulaError " ) ;%NWL%1
" use strict " ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const Workbook = require ( " . / Workbook " ) ;%NWL%const dateConverter = require ( " . / dateConverter " ) ;%NWL%1
d . d3plus . form = form ( ) . container ( d3 . select ( this ) )%NWL%}%NWL%var id = vars . id . nesting . length > vars . depth . value ? vars . id . nesting [ vars . depth . value + 1 ] : vars . id . value%NWL%if ( d [ id ] instanceof Array )  {%NWL%d . d3plus . form%NWL%. container ( { " id " : vars . container . id + " _ " + d [ vars . id . value ] } )%NWL%. data ( d [ id ] )%NWL%. id ( vars . id . nesting . slice ( 1 ) )%NWL%. type ( " drop " )%NWL%}%NWL%d . d3plus . form%NWL%4
. container ( { " id " : vars . container . id + " _ " + d [ vars . id . value ] } )%NWL%. data ( d [ id ] )%NWL%. id ( vars . id . nesting . slice ( 1 ) )%NWL%. type ( " drop " )%NWL%}%NWL%else {%NWL%d . d3plus . form%NWL%. data ( [ d ] )%NWL%. id ( vars . id . value )%NWL%. type ( " button " )%NWL%d . d3plus . form%NWL%6
" use strict " ;%NWL%const sax = require ( " sax " ) ;%NWL%const externals = require ( " . / externals " ) ;%NWL%const allWhitespaceRegex = / ^\s + $ / ;%NWL%class XmlParser {%NWL%%NWL%parseAsync ( xmlText )  {%NWL%const parser = sax . parser ( true ) ;%NWL%1
} else {%NWL%parsed = child;%NWL%}%NWL%stack . push ( child ) ;%NWL%current = child;%NWL%} ;%NWL%parser . onclosetag = node => {%NWL%stack . pop ( ) ;%NWL%current = stack [ stack . length - 1 ] ;%NWL%} ;%NWL%current . attributes [ attribute . name ] = this . _covertToNumberIfNumber ( attribute . value ) ;%NWL%8
" use strict " ;%NWL%process . chdir ( __dirname ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const path = require ( " path " ) ;%NWL%2
" use strict " ;%NWL%process . chdir ( __dirname ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const glob = require ( " glob " ) ;%NWL%const edge = require ( ' edge ' ) ;%NWL%2
" use strict " ;%NWL%process . chdir ( __dirname ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const glob = require ( " glob " ) ;%NWL%const path = require ( " path " ) ;%NWL%const XlsxPopulate = require ( " . . / . . / lib / XlsxPopulate " ) ;%NWL%2
. each ( function ( d , i ) {%NWL%var children = [ " label " ]%NWL%if ( d [ vars . icon . value ] && vars . data . viz . length <= vars . data . large )  {%NWL%children . push ( " icon " )%NWL%}%NWL%var iconGraphic = vars . icon . button . value%NWL%if ( d [ vars . id . value ] === vars . focus . value && vars . icon . select . value )  {%NWL%iconGraphic = vars . icon . select . value%NWL%children . push ( " selected " )%NWL%}%NWL%children . push ( " selected " )%NWL%8
" use strict " ;%NWL%process . chdir ( __dirname ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const path = require ( " path " ) ;%NWL%2
" use strict " ;%NWL%process . chdir ( __dirname ) ;%NWL%const fs = require ( " fs " ) ;%NWL%const glob = require ( " glob " ) ;%NWL%const XlsxPopulate = require ( " . . / . . / lib / XlsxPopulate " ) ;%NWL%2
beforeEach ( ( ) => {%NWL%spyOn ( cell ,  ' value ' ) ;%NWL%} ) ;%NWL%it ( " should return true if substring found and false otherwise " ,  ( ) => {%NWL%cell . value . and . returnValue ( " Foo bar baz " ) ;%NWL%expect ( cell . find ( ' bar ' ) ) . toBe ( true ) ;%NWL%expect ( cell . find ( ' BAR ' ) ) . toBe ( true ) ;%NWL%expect ( cell . find ( ' goo ' ) ) . toBe ( false ) ;%NWL%expect ( cell . value ) . not . toHaveBeenCalledWith ( jasmine . anything ( ) ) ;%NWL%} ) ;%NWL%cell . value . and . returnValue ( " Foo bar baz " ) ;%NWL%4
expect ( cell . find ( ' goo ' ) ) . toBe ( false ) ;%NWL%expect ( cell . value ) . not . toHaveBeenCalledWith ( jasmine . anything ( ) ) ;%NWL%} ) ;%NWL%it ( " should return true if regex matches and false otherwise " ,  ( ) => {%NWL%cell . value . and . returnValue ( " Foo bar baz " ) ;%NWL%expect ( cell . find ( / \w { 3 } / ) ) . toBe ( true ) ;%NWL%expect ( cell . find ( / \w { 4 } / ) ) . toBe ( false ) ;%NWL%expect ( cell . find ( / Foo / ) ) . toBe ( true ) ;%NWL%expect ( cell . value ) . not . toHaveBeenCalledWith ( jasmine . anything ( ) ) ;%NWL%} ) ;%NWL%cell . value . and . returnValue ( " Foo bar baz " ) ;%NWL%4
cell . value . and . returnValue ( " Foo bar baz " ) ;%NWL%expect ( cell . find ( " foo " , undefined ) ) . toBe ( true ) ;%NWL%expect ( cell . value ) . not . toHaveBeenCalledWith ( jasmine . anything ( ) ) ;%NWL%expect ( cell . find ( " bar " , null ) ) . toBe ( true ) ;%NWL%expect ( cell . value ) . not . toHaveBeenCalledWith ( jasmine . anything ( ) ) ;%NWL%} ) ;%NWL%it ( " should replace all occurences of substring " ,  ( ) => {%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%expect ( cell . find ( ' foo ' ,  ' XXX ' ) ) . toBe ( true ) ;%NWL%expect ( cell . value ) . toHaveBeenCalledWith ( ' XXX bar baz XXX ' ) ;%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%7
} ) ;%NWL%it ( " should replace all occurences of substring " ,  ( ) => {%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%expect ( cell . find ( ' foo ' ,  ' XXX ' ) ) . toBe ( true ) ;%NWL%expect ( cell . value ) . toHaveBeenCalledWith ( ' XXX bar baz XXX ' ) ;%NWL%cell . value . calls . reset ( ) ;%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%expect ( cell . find ( ' foot ' ,  ' XXX ' ) ) . toBe ( false ) ;%NWL%expect ( cell . value ) . not . toHaveBeenCalledWith ( jasmine . any ( String ) ) ;%NWL%} ) ;%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%2
cell . value . calls . reset ( ) ;%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%expect ( cell . find ( ' foot ' ,  ' XXX ' ) ) . toBe ( false ) ;%NWL%expect ( cell . value ) . not . toHaveBeenCalledWith ( jasmine . any ( String ) ) ;%NWL%} ) ;%NWL%it ( " should replace regex matches " ,  ( ) => {%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%expect ( cell . find ( / [ a - z ] { 3 } / ,  ' XXX ' ) ) . toBe ( true ) ;%NWL%expect ( cell . value ) . toHaveBeenCalledWith ( ' Foo XXX baz foo ' ) ;%NWL%} ) ;%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%1
it ( " should replace regex matches " ,  ( ) => {%NWL%cell . value . and . returnValue ( " Foo bar baz foo " ) ;%NWL%const replacer = jasmine . createSpy ( ' replacer ' ) . and . returnValue ( " REPLACEMENT " ) ;%NWL%expect ( cell . find ( / ( \w ) ( o { 2 } ) / g , replacer ) ) . toBe ( true ) ;%NWL%expect ( cell . value ) . toHaveBeenCalledWith ( ' REPLACEMENT bar baz REPLACEMENT ' ) ;%NWL%expect ( replacer ) . toHaveBeenCalledWith ( ' Foo ' ,  ' F ' ,  ' oo ' , 0 ,  ' Foo bar baz foo ' ) ;%NWL%expect ( replacer ) . toHaveBeenCalledWith ( ' foo ' ,  ' f ' ,  ' oo ' , 12 ,  ' Foo bar baz foo ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " tap " ,  ( ) => {%NWL%const callback = jasmine . createSpy ( ' callback ' ) . and . returnValue ( " RETURN " ) ;%NWL%2
} ) ;%NWL%} ) ;%NWL%describe ( " tap " ,  ( ) => {%NWL%it ( " should call the callback and return the cell " ,  ( ) => {%NWL%const callback = jasmine . createSpy ( ' callback ' ) . and . returnValue ( " RETURN " ) ;%NWL%expect ( cell . tap ( callback ) ) . toBe ( cell ) ;%NWL%expect ( callback ) . toHaveBeenCalledWith ( cell ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " thru " ,  ( ) => {%NWL%const callback = jasmine . createSpy ( ' callback ' ) . and . returnValue ( " RETURN " ) ;%NWL%4
expect ( sheet . range ) . toHaveBeenCalledWith ( cell ,  " OTHER " ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " relativeCell " ,  ( ) => {%NWL%it ( " should call sheet . cell with the appropriate row / column " ,  ( ) => {%NWL%sheet . cell . and . returnValue ( " CELL " ) ;%NWL%expect ( cell . relativeCell ( 0 , 0 ) ) . toBe ( " CELL " ) ;%NWL%expect ( sheet . cell ) . toHaveBeenCalledWith ( 7 , 3 ) ;%NWL%sheet . cell . calls . reset ( ) ;%NWL%expect ( cell . relativeCell ( - 2 ,  - 1 ) ) . toBe ( " CELL " ) ;%NWL%sheet . cell . calls . reset ( ) ;%NWL%8
describe ( " relativeCell " ,  ( ) => {%NWL%it ( " should call sheet . cell with the appropriate row / column " ,  ( ) => {%NWL%sheet . cell . and . returnValue ( " CELL " ) ;%NWL%expect ( cell . relativeCell ( 0 , 0 ) ) . toBe ( " CELL " ) ;%NWL%expect ( sheet . cell ) . toHaveBeenCalledWith ( 7 , 3 ) ;%NWL%sheet . cell . calls . reset ( ) ;%NWL%expect ( cell . relativeCell ( - 2 ,  - 1 ) ) . toBe ( " CELL " ) ;%NWL%expect ( sheet . cell ) . toHaveBeenCalledWith ( 5 , 2 ) ;%NWL%sheet . cell . calls . reset ( ) ;%NWL%expect ( cell . relativeCell ( 5 , 2 ) ) . toBe ( " CELL " ) ;%NWL%sheet . cell . calls . reset ( ) ;%NWL%5
} ) ;%NWL%describe ( " style " ,  ( ) => {%NWL%it ( " should create a new style with the set style ID " ,  ( ) => {%NWL%cell . _styleId = 2;%NWL%expect ( cell . _style ) . toBeUndefined ( ) ;%NWL%cell . style ( " foo " ) ;%NWL%expect ( styleSheet . createStyle ) . toHaveBeenCalledWith ( 2 ) ;%NWL%expect ( cell . _style ) . toBe ( style ) ;%NWL%} ) ;%NWL%it ( " should not create a style if one already exists " ,  ( ) => {%NWL%cell . style ( " foo " ) ;%NWL%5
} ;%NWL%cell . clear ( ) ;%NWL%delete cell . _columnNumber;%NWL%sheet . updateMaxSharedFormulaId . calls . reset ( ) ;%NWL%} ) ;%NWL%it ( " should parse the column number " ,  ( ) => {%NWL%cell . _parseNode ( node ) ;%NWL%expect ( cell . _columnNumber ) . toBe ( 4 ) ;%NWL%} ) ;%NWL%it ( " should store the style ID " ,  ( ) => {%NWL%cell . _parseNode ( node ) ;%NWL%6
it ( " should store the style ID " ,  ( ) => {%NWL%node . attributes . s = " STYLE_ID " ;%NWL%cell . _parseNode ( node ) ;%NWL%expect ( cell . _styleId ) . toBe ( " STYLE_ID " ) ;%NWL%} ) ;%NWL%it ( " should parse a normal formula " ,  ( ) => {%NWL%node . children = [ {%NWL%name: ' f ' ,%NWL%attributes: { } ,%NWL%children: [ " FORMULA " ]%NWL%cell . _parseNode ( node ) ;%NWL%2
children: [ 1 ]%NWL%} ] ;%NWL%cell . _parseNode ( node ) ;%NWL%expect ( cell . _value ) . toBe ( true ) ;%NWL%} ) ;%NWL%it ( " should parse false values " ,  ( ) => {%NWL%node . attributes . t = " b " ;%NWL%node . children = [ {%NWL%name: ' v ' ,%NWL%children: [ 0 ]%NWL%cell . _parseNode ( node ) ;%NWL%2
children: [ 0 ]%NWL%} ] ;%NWL%cell . _parseNode ( node ) ;%NWL%expect ( cell . _value ) . toBe ( false ) ;%NWL%} ) ;%NWL%it ( " should parse error values " ,  ( ) => {%NWL%node . attributes . t = " e " ;%NWL%node . children = [ {%NWL%name: ' v ' ,%NWL%children: [ " #ERR " ]%NWL%cell . _parseNode ( node ) ;%NWL%2
children: [ " #ERR " ]%NWL%} ] ;%NWL%cell . _parseNode ( node ) ;%NWL%expect ( cell . _value ) . toBe ( " ERROR " ) ;%NWL%expect ( FormulaError . getError ) . toHaveBeenCalledWith ( " #ERR " ) ;%NWL%} ) ;%NWL%it ( " should parse number values " ,  ( ) => {%NWL%node . children = [ {%NWL%name: ' v ' ,%NWL%children: [ - 1 . 67 ]%NWL%cell . _parseNode ( node ) ;%NWL%2
it ( " should parse number values " ,  ( ) => {%NWL%node . children = [ {%NWL%name: ' v ' ,%NWL%children: [ - 1 . 67 ]%NWL%} ] ;%NWL%cell . _parseNode ( node ) ;%NWL%expect ( cell . _value ) . toBe ( - 1 . 67 ) ;%NWL%expect ( cell . _remainingAttributes ) . toBeUndefined ( ) ;%NWL%expect ( cell . _remainingChildren ) . toBeUndefined ( ) ;%NWL%} ) ;%NWL%cell . _parseNode ( node ) ;%NWL%5
spyOn ( column ,  " width " ) ;%NWL%columnNode . attributes . style = 3;%NWL%column . _createStyleIfNeeded ( ) ;%NWL%expect ( column . _style ) . toBe ( style ) ;%NWL%expect ( columnNode . attributes . style ) . toBe ( " STYLE_ID " ) ;%NWL%expect ( styleSheet . createStyle ) . toHaveBeenCalledWith ( 3 ) ;%NWL%expect ( column . width ) . toHaveBeenCalledWith ( 9 . 140625 ) ;%NWL%} ) ;%NWL%it ( " should NOT create a style " ,  ( ) => {%NWL%const existingStyle = { } ;%NWL%column . _createStyleIfNeeded ( ) ;%NWL%2
} ) ;%NWL%} ) ;%NWL%describe ( " tap " ,  ( ) => {%NWL%it ( " should call the callback and return the range " ,  ( ) => {%NWL%const callback = jasmine . createSpy ( ' callback ' ) . and . returnValue ( " RETURN " ) ;%NWL%expect ( range . tap ( callback ) ) . toBe ( range ) ;%NWL%expect ( callback ) . toHaveBeenCalledWith ( range ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " thru " ,  ( ) => {%NWL%const callback = jasmine . createSpy ( ' callback ' ) . and . returnValue ( " RETURN " ) ;%NWL%4
it ( " should set the next ID to 1 if no children " ,  ( ) => {%NWL%relationships . _node . children = [ ] ;%NWL%relationships . _getStartingId ( ) ;%NWL%expect ( relationships . _nextId ) . toBe ( 1 ) ;%NWL%} ) ;%NWL%it ( " should set the next ID to last found ID + 1 " ,  ( ) => {%NWL%relationships . _node . children = [%NWL%{ attributes: { Id: ' rId2 '  }  } ,%NWL%{ attributes: { Id: ' rId1 '  }  } ,%NWL%{ attributes: { Id: ' rId3 '  }  }%NWL%relationships . _getStartingId ( ) ;%NWL%2
it ( " should return an existing cell " ,  ( ) => {%NWL%expect ( row . cell ( ' B ' ) ) . toEqual ( jasmine . any ( Cell ) ) ;%NWL%expect ( Cell ) . not . toHaveBeenCalled ( ) ;%NWL%} ) ;%NWL%it ( " should create a new cell as needed " ,  ( ) => {%NWL%const cell = row . cell ( 5 ) ;%NWL%expect ( cell ) . toEqual ( jasmine . any ( Cell ) ) ;%NWL%expect ( Cell ) . toHaveBeenCalledWith ( row , 5 , undefined ) ;%NWL%expect ( row . _cells [ 5 ] ) . toBe ( cell ) ;%NWL%} ) ;%NWL%const cell = row . cell ( ' C ' ) ;%NWL%5
it ( " should create a new cell with an existing column style id " ,  ( ) => {%NWL%sheet . existingColumnStyleId . and . returnValue ( 5 ) ;%NWL%expect ( row . cell ( ' C ' ) ) . toEqual ( jasmine . any ( Cell ) ) ;%NWL%expect ( Cell ) . toHaveBeenCalledWith ( row , 3 , 5 ) ;%NWL%} ) ;%NWL%it ( " should create a new cell with an existing row style id " ,  ( ) => {%NWL%rowNode . attributes . s = 3;%NWL%expect ( row . cell ( ' C ' ) ) . toEqual ( jasmine . any ( Cell ) ) ;%NWL%expect ( Cell ) . toHaveBeenCalledWith ( row , 3 , 3 ) ;%NWL%} ) ;%NWL%sheet . existingColumnStyleId . and . returnValue ( 5 ) ;%NWL%1
describe ( " _createStyleIfNeeded " ,  ( ) => {%NWL%it ( " should create a style " ,  ( ) => {%NWL%rowNode . attributes . s = 3;%NWL%row . _createStyleIfNeeded ( ) ;%NWL%expect ( row . _style ) . toBe ( style ) ;%NWL%expect ( rowNode . attributes . s ) . toBe ( " STYLE_ID " ) ;%NWL%expect ( styleSheet . createStyle ) . toHaveBeenCalledWith ( 3 ) ;%NWL%} ) ;%NWL%it ( " should NOT create a style " ,  ( ) => {%NWL%const existingStyle = { } ;%NWL%row . _createStyleIfNeeded ( ) ;%NWL%3
expect ( sheet . _sheetPrNode . children ) . toEqualJson ( [ ] ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " tabSelected " ,  ( ) => {%NWL%let sheetViewNode;%NWL%beforeEach ( ( ) => {%NWL%sheetViewNode = { attributes: { }  } ;%NWL%spyOn ( sheet ,  " _getOrCreateSheetViewNode " ) . and . returnValue ( sheetViewNode ) ;%NWL%} ) ;%NWL%it ( " should return the tab selected state " ,  ( ) => {%NWL%sheetViewNode . attributes . tabSelected = 1;%NWL%6
sheet . _colNodes = [ null ,  " NODE1 " ,  " NODE2 " ] ;%NWL%const callback = jasmine . createSpy ( " callback " ) ;%NWL%sheet . forEachExistingColumnNumber ( callback ) ;%NWL%expect ( callback . calls . count ( ) ) . toBe ( 2 ) ;%NWL%expect ( callback ) . toHaveBeenCalledWith ( 1 ) ;%NWL%expect ( callback ) . toHaveBeenCalledWith ( 2 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " forEachExistingRow " ,  ( ) => {%NWL%it ( " should call the callback for each existing row " ,  ( ) => {%NWL%const callback = jasmine . createSpy ( " callback " ) ;%NWL%1
const callback = jasmine . createSpy ( " callback " ) ;%NWL%sheet . forEachExistingColumnNumber ( callback ) ;%NWL%expect ( callback . calls . count ( ) ) . toBe ( 2 ) ;%NWL%expect ( callback ) . toHaveBeenCalledWith ( 1 ) ;%NWL%expect ( callback ) . toHaveBeenCalledWith ( 2 ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " forEachExistingRow " ,  ( ) => {%NWL%it ( " should call the callback for each existing row " ,  ( ) => {%NWL%sheet . _rows = [ null ,  " ROW1 " ,  " ROW2 " ] ;%NWL%sheet . forEachExistingRow ( callback ) ;%NWL%1
it ( " should return the ID " ,  ( ) => {%NWL%expect ( style . id ( ) ) . toBe ( " ID " ) ;%NWL%} ) ;%NWL%} ) ;%NWL%describe ( " style " ,  ( ) => {%NWL%it ( " should get the style with the given name " ,  ( ) => {%NWL%style . _get_foo = jasmine . createSpy ( " _get_foo " ) . and . returnValue ( " FOO " ) ;%NWL%expect ( style . style ( " foo " ) ) . toBe ( " FOO " ) ;%NWL%expect ( style . _get_foo ) . toHaveBeenCalledWith ( ) ;%NWL%} ) ;%NWL%style . _set_foo = jasmine . createSpy ( " _set_foo " ) ;%NWL%6
} ) ;%NWL%} ) ;%NWL%describe ( " underline " ,  ( ) => {%NWL%it ( " should get / set underline " ,  ( ) => {%NWL%expect ( style . style ( " underline " ) ) . toBe ( false ) ;%NWL%style . style ( " underline " , true ) ;%NWL%expect ( style . style ( " underline " ) ) . toBe ( true ) ;%NWL%expect ( fontNode . children ) . toEqualJson ( [ { name: " u " , attributes: { } , children: [ ]  } ] ) ;%NWL%style . style ( " underline " ,  " double " ) ;%NWL%expect ( style . style ( " underline " ) ) . toBe ( " double " ) ;%NWL%style . style ( " underline " , true ) ;%NWL%5
describe ( " Workbook " ,  ( ) => {%NWL%let resolved , fs , externals , JSZip , workbookNode , Workbook , StyleSheet , Sheet , SharedStrings , Relationships , ContentTypes , XmlParser , XmlBuilder , blank;%NWL%beforeEach ( ( ) => {%NWL%resolved = val => {%NWL%return new Promise ( resolve => {%NWL%setTimeout ( resolve , Math . random ( )  * 10 ) ;%NWL%} ) . then ( ( ) => val ) ;%NWL%} ;%NWL%JSZip = jasmine . createSpy ( " JSZip " ) ;%NWL%JSZip . loadAsync = jasmine . createSpy ( " JSZip . loadAsync " ) . and . returnValue ( Promise . resolve ( new JSZip ( ) ) ) ;%NWL%JSZip . prototype . remove = jasmine . createSpy ( " JSZip . remove " ) ;%NWL%9
let resolved , fs , externals , JSZip , workbookNode , Workbook , StyleSheet , Sheet , SharedStrings , Relationships , ContentTypes , XmlParser , XmlBuilder , blank;%NWL%beforeEach ( ( ) => {%NWL%resolved = val => {%NWL%return new Promise ( resolve => {%NWL%setTimeout ( resolve , Math . random ( )  * 10 ) ;%NWL%} ) . then ( ( ) => val ) ;%NWL%} ;%NWL%JSZip = jasmine . createSpy ( " JSZip " ) ;%NWL%JSZip . loadAsync = jasmine . createSpy ( " JSZip . loadAsync " ) . and . returnValue ( Promise . resolve ( new JSZip ( ) ) ) ;%NWL%JSZip . prototype . file = jasmine . createSpy ( " JSZip . file " ) ;%NWL%JSZip . prototype . generateAsync = jasmine . createSpy ( " JSZip . generateAsync " ) . and . returnValue ( Promise . resolve ( " ZIP " ) ) ;%NWL%8
sheet3 = new Sheet ( ) ;%NWL%sheet1 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET1 " ) ;%NWL%sheet2 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET2 " ) ;%NWL%sheet3 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET3 " ) ;%NWL%workbook . _sheets = [ sheet1 , sheet2 , sheet3 ] ;%NWL%workbook . _activeSheet = sheet2;%NWL%} ) ;%NWL%it ( " should throw an error if the sheet doesn ' t exist " ,  ( ) => {%NWL%expect ( ( ) => workbook . deleteSheet ( " foo " ) ) . toThrow ( ) ;%NWL%} ) ;%NWL%sheet1 . hidden = jasmine . createSpy ( " hidden " ) . and . returnValue ( true ) ;%NWL%1
sheet1 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET1 " ) ;%NWL%sheet2 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET2 " ) ;%NWL%sheet3 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET3 " ) ;%NWL%workbook . _sheets = [ sheet1 , sheet2 , sheet3 ] ;%NWL%workbook . _activeSheet = sheet2;%NWL%} ) ;%NWL%it ( " should throw an error if the sheet doesn ' t exist " ,  ( ) => {%NWL%expect ( ( ) => workbook . deleteSheet ( " foo " ) ) . toThrow ( ) ;%NWL%} ) ;%NWL%it ( " should throw an error if we are trying to hide the only visible sheet " ,  ( ) => {%NWL%sheet2 . hidden = jasmine . createSpy ( " hidden " ) . and . returnValue ( false ) ;%NWL%1
sheet2 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET2 " ) ;%NWL%sheet3 . name = jasmine . createSpy ( " name " ) . and . returnValue ( " SHEET3 " ) ;%NWL%workbook . _sheets = [ sheet1 , sheet2 , sheet3 ] ;%NWL%workbook . _activeSheet = sheet2;%NWL%} ) ;%NWL%it ( " should throw an error if the sheet doesn ' t exist " ,  ( ) => {%NWL%expect ( ( ) => workbook . deleteSheet ( " foo " ) ) . toThrow ( ) ;%NWL%} ) ;%NWL%it ( " should throw an error if we are trying to hide the only visible sheet " ,  ( ) => {%NWL%sheet1 . hidden = jasmine . createSpy ( " hidden " ) . and . returnValue ( true ) ;%NWL%sheet3 . hidden = jasmine . createSpy ( " hidden " ) . and . returnValue ( true ) ;%NWL%1
const proxyquire = require ( " proxyquire " ) ;%NWL%const Promise = require ( " jszip " ) . external . Promise;%NWL%describe ( " XlsxPopulate " ,  ( ) => {%NWL%let dateConverter , Workbook , XlsxPopulate , FormulaError , externals;%NWL%beforeEach ( ( ) => {%NWL%dateConverter = jasmine . createSpyObj ( " dateConverter " ,  [ " dateToNumber " ,  " numberToDate " ] ) ;%NWL%dateConverter . dateToNumber . and . returnValue ( " NUMBER " ) ;%NWL%dateConverter . numberToDate . and . returnValue ( " DATE " ) ;%NWL%Workbook = jasmine . createSpyObj ( " Workbook " ,  [ " fromBlankAsync " ,  " fromDataAsync " ,  " fromFileAsync " ] ) ;%NWL%Workbook . fromBlankAsync . and . returnValue ( " WORKBOOK " ) ;%NWL%Workbook . fromFileAsync . and . returnValue ( " WORKBOOK " ) ;%NWL%9
} ) ;%NWL%describe ( " appendChild " ,  ( ) => {%NWL%it ( " should append the child " ,  ( ) => {%NWL%const node = { name: ' parent ' , children: [ { name: ' existing '  } ]  } ;%NWL%const child = { name: ' new '  } ;%NWL%xmlq . appendChild ( node , child ) ;%NWL%expect ( node ) . toEqualJson ( { name: ' parent ' , children: [ { name: ' existing '  } ,  { name: ' new '  } ]  } ) ;%NWL%} ) ;%NWL%it ( " should create the children array if needed " ,  ( ) => {%NWL%const node = { name: ' parent '  } ;%NWL%xmlq . appendChild ( node , child ) ;%NWL%5
data [ middle1 - 1 ] . forEach ( function ( d , i ) {%NWL%mid_data [ i ] . y0 = ( mid_data [ i ] . y0 + d . y0 ) / 2;%NWL%} ) ;%NWL%}%NWL%return mid_data;%NWL%} ;%NWL%var area = d3 . svg . area ( ) . x ( dxfunc ) . y0 ( dy0func ) . y1 ( dyfunc ) ;%NWL%var line = d3 . svg . line ( ) . x ( dxfunc ) . y ( dyfunc )%NWL%%NWL%this . addLine = function ( line_class , data , color , smoke )  {%NWL%var color = d3 . interpolateRgb ( color , smoke ) ;%NWL%6
if ( len != this . labelCount )  {%NWL%this . selectAll ( " text . label " ) . remove ( ) ;%NWL%this . labelCount = 0;%NWL%if ( !len ) return;%NWL%if ( !this . labelCount ) this . height ( h + 20 ) ;%NWL%}%NWL%if  ( this . labelCount )  {%NWL%this . selectAll ( " text . label " )%NWL%. data ( labels )%NWL%. text ( String ) ;%NWL%this . selectAll ( " text . label " )%NWL%7
%NWL%this . errors = this . selectAll ( " circle . errors " ) ;%NWL%this . showMarkers = function ( xline )  {%NWL%if ( !this . errors . empty ( ) ) this . errors . remove ( ) ;%NWL%var data = [ ] ;%NWL%var prev = - 1;%NWL%var cnt = 0;%NWL%xline . forEach ( function ( v , i ) { if ( prev != v )  { cnt=0;prev=v } data . push ( [ v , cnt + + ] )  } ) ;%NWL%%NWL%var rad = h / 500 + 1 . 1%NWL%this . errors = this . selectAll ( " circle . errors " )%NWL%1
var gulp = require ( ' gulp ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var browserify = require ( ' browserify ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%var babelify = require ( ' babelify ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%var browserify = require ( ' browserify ' ) ;%NWL%var uglify = require ( ' gulp - uglify ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%var browserify = require ( ' browserify ' ) ;%NWL%var babelify = require ( ' babelify ' ) ;%NWL%var less = require ( ' gulp - less ' ) ;%NWL%0
var gulp = require ( ' gulp ' ) ;%NWL%var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%var browserify = require ( ' browserify ' ) ;%NWL%var babelify = require ( ' babelify ' ) ;%NWL%var uglify = require ( ' gulp - uglify ' ) ;%NWL%var postcss = require ( ' gulp - postcss ' ) ;%NWL%0
var plumber = require ( ' gulp - plumber ' ) ;%NWL%var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%var browserify = require ( ' browserify ' ) ;%NWL%var babelify = require ( ' babelify ' ) ;%NWL%var uglify = require ( ' gulp - uglify ' ) ;%NWL%var less = require ( ' gulp - less ' ) ;%NWL%var autoprefixer = require ( ' autoprefixer ' ) ;%NWL%0
var buffer = require ( ' vinyl - buffer ' ) ;%NWL%var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%var browserify = require ( ' browserify ' ) ;%NWL%var babelify = require ( ' babelify ' ) ;%NWL%var uglify = require ( ' gulp - uglify ' ) ;%NWL%var less = require ( ' gulp - less ' ) ;%NWL%var postcss = require ( ' gulp - postcss ' ) ;%NWL%var mqpacker = require ( ' css - mqpacker ' ) ;%NWL%0
var source = require ( ' vinyl - source - stream ' ) ;%NWL%var sourcemaps = require ( ' gulp - sourcemaps ' ) ;%NWL%var browserSync = require ( ' browser - sync ' ) . create ( ) ;%NWL%var rename = require ( ' gulp - rename ' ) ;%NWL%var browserify = require ( ' browserify ' ) ;%NWL%var babelify = require ( ' babelify ' ) ;%NWL%var uglify = require ( ' gulp - uglify ' ) ;%NWL%var less = require ( ' gulp - less ' ) ;%NWL%var postcss = require ( ' gulp - postcss ' ) ;%NWL%var autoprefixer = require ( ' autoprefixer ' ) ;%NWL%var csswring = require ( ' csswring ' ) ;%NWL%0
' use strict ' ;%NWL%var debug = require ( ' debug ' ) ( ' scraper ' ) ;%NWL%var phantom = require ( ' phantom ' ) ;%NWL%var colors = require ( ' colors ' ) ;%NWL%1
' use strict ' ;%NWL%var debug = require ( ' debug ' ) ( ' scraper ' ) ;%NWL%var phantom = require ( ' phantom ' ) ;%NWL%var Promise = require ( ' bluebird ' ) ;%NWL%var progress = require ( ' progress ' ) ;%NWL%1
' use strict ' ;%NWL%var debug = require ( ' debug ' ) ( ' scraper ' ) ;%NWL%var phantom = require ( ' phantom ' ) ;%NWL%var Promise = require ( ' bluebird ' ) ;%NWL%var colors = require ( ' colors ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%1
' use strict ' ;%NWL%var debug = require ( ' debug ' ) ( ' scraper ' ) ;%NWL%var phantom = require ( ' phantom ' ) ;%NWL%var Promise = require ( ' bluebird ' ) ;%NWL%var colors = require ( ' colors ' ) ;%NWL%var progress = require ( ' progress ' ) ;%NWL%var fs = Promise . promisifyAll ( require ( ' fs ' ) ) ;%NWL%1
' use strict ' ;%NWL%var debug = require ( ' debug ' ) ( ' scraper ' ) ;%NWL%var phantom = require ( ' phantom ' ) ;%NWL%var Promise = require ( ' bluebird ' ) ;%NWL%var colors = require ( ' colors ' ) ;%NWL%var progress = require ( ' progress ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var mkdirp = Promise . promisify ( require ( ' mkdirp ' ) ) ;%NWL%1
' use strict ' ;%NWL%const debug = require ( ' debug ' ) ( ' stats ' ) ;%NWL%const fs = Promise . promisifyAll ( require ( ' fs ' ) ) ;%NWL%1
' use strict ' ;%NWL%const debug = require ( ' debug ' ) ( ' stats ' ) ;%NWL%const Promise = require ( ' bluebird ' ) ;%NWL%const fs = Promise . promisifyAll ( require ( ' fs ' ) ) ;%NWL%const highland = require ( ' highland ' ) ;%NWL%1
' use strict ' ;%NWL%const debug = require ( ' debug ' ) ( ' stats ' ) ;%NWL%const Promise = require ( ' bluebird ' ) ;%NWL%const fs = Promise . promisifyAll ( require ( ' fs ' ) ) ;%NWL%const _ = require ( ' lodash ' ) ;%NWL%const minimist = require ( ' minimist ' ) ;%NWL%1
' use strict ' ;%NWL%const debug = require ( ' debug ' ) ( ' stats ' ) ;%NWL%const Promise = require ( ' bluebird ' ) ;%NWL%const fs = Promise . promisifyAll ( require ( ' fs ' ) ) ;%NWL%const _ = require ( ' lodash ' ) ;%NWL%const highland = require ( ' highland ' ) ;%NWL%const colors = require ( ' colors ' ) ;%NWL%1
const highland = require ( ' highland ' ) ;%NWL%const minimist = require ( ' minimist ' ) ;%NWL%const colors = require ( ' colors ' ) ;%NWL%const argv = minimist ( process . argv . slice ( 2 ) ,  {%NWL%alias: {%NWL%file: ' f '%NWL%} ,%NWL%default: {%NWL%file: ' data / new . pgn '%NWL%}%NWL%const Openings = require ( ' . / lib / Openings . js ' ) ;%NWL%0
const minimist = require ( ' minimist ' ) ;%NWL%const colors = require ( ' colors ' ) ;%NWL%const argv = minimist ( process . argv . slice ( 2 ) ,  {%NWL%alias: {%NWL%file: ' f '%NWL%} ,%NWL%default: {%NWL%file: ' data / new . pgn '%NWL%}%NWL%} ) ;%NWL%const Heatmaps = require ( ' . / lib / Heatmaps . js ' ) ;%NWL%0
const colors = require ( ' colors ' ) ;%NWL%const argv = minimist ( process . argv . slice ( 2 ) ,  {%NWL%alias: {%NWL%file: ' f '%NWL%} ,%NWL%default: {%NWL%file: ' data / new . pgn '%NWL%}%NWL%} ) ;%NWL%const Openings = require ( ' . / lib / Openings . js ' ) ;%NWL%const Moves = require ( ' . / lib / Moves . js ' ) ;%NWL%0
} ,%NWL%interactive: true%NWL%} ;%NWL%options = options || { } ;%NWL%this . _options = _ . merge ( { } , defaultOptions , options ) ;%NWL%this . _width = this . _options . width - this . _options . margin . left - this . _options . margin . right;%NWL%this . _height = this . _options . height - this . _options . margin . top - this . _options . margin . bottom;%NWL%this . dispatch = d3 . dispatch ( ' mouseenter ' ,  ' mousemove ' ,  ' mouseleave ' ) ;%NWL%this . _xScale = d3 . scale . ordinal ( )%NWL%. rangeBands ( [ 0 , this . _width ] , 0 . 1 , 0 )%NWL%this . _yEvalScale = d3 . scale . linear ( )%NWL%7
this . _width = this . _options . width - this . _options . margin . left - this . _options . margin . right;%NWL%this . _height = this . _options . height - this . _options . margin . top - this . _options . margin . bottom;%NWL%this . dispatch = d3 . dispatch ( ' mouseenter ' ,  ' mousemove ' ,  ' mouseleave ' ) ;%NWL%this . _xScale = d3 . scale . ordinal ( )%NWL%. rangeBands ( [ 0 , this . _width ] , 0 . 1 , 0 )%NWL%;%NWL%this . _yEvalScale = d3 . scale . linear ( )%NWL%. range ( [ this . _height , 0 ] )%NWL%. domain ( [ - 5 , 5 ] )%NWL%. clamp ( true )%NWL%this . _yTimeScale = d3 . scale . linear ( )%NWL%2
. attr ( ' class ' ,  ' eval - guide - text ' )%NWL%;%NWL%svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' bars ' )%NWL%;%NWL%svg . append ( ' clipPath ' )%NWL%. attr ( ' id ' ,  ' clip - white ' )%NWL%. append ( ' rect ' )%NWL%. attr ( ' width ' , this . _width )%NWL%. attr ( ' height ' , this . _height / 2 )%NWL%svg . append ( ' clipPath ' )%NWL%5
;%NWL%svg . append ( ' clipPath ' )%NWL%. attr ( ' id ' ,  ' clip - black ' )%NWL%. append ( ' rect ' )%NWL%. attr ( ' y ' , this . _height / 2 )%NWL%. attr ( ' width ' , this . _width )%NWL%. attr ( ' height ' , this . _height / 2 )%NWL%;%NWL%svg . append ( ' g ' )%NWL%. attr ( ' class ' ,  ' lines ' )%NWL%svg . append ( ' g ' )%NWL%8
accessor: {%NWL%piece: ' all ' ,%NWL%color: ' w '%NWL%} ,%NWL%sizeScale: true ,%NWL%colorScale: false%NWL%} ;%NWL%options = options || { } ;%NWL%this . _options = _ . merge ( { } , defaultOptions , options ) ;%NWL%this . _options . boardWidth = this . _options . width - this . _options . margin * 2;%NWL%this . dispatch = d3 . dispatch ( ' mouseenter ' ,  ' mousemove ' ,  ' mouseleave ' ) ;%NWL%9
this . _data = data;%NWL%this . update ( ) ;%NWL%}%NWL%options ( options )  {%NWL%let omit = [%NWL%' width ' ,%NWL%' margin ' ,%NWL%' boardWidth ' ,%NWL%' squareWidth '%NWL%] ;%NWL%this . update ( ) ;%NWL%1
return match%NWL%} ) [ 0 ] )%NWL%if ( !buttonData )  {%NWL%buttonData = vars . container . button . data ( ) [ 0 ] || vars . data . viz [ 0 ]%NWL%}%NWL%vars . container . button%NWL%. data ( [ buttonData ] )%NWL%. id ( vars . id . nesting )%NWL%. depth ( depth )%NWL%}%NWL%vars . container . button%NWL%5
} ;%NWL%options = options || { } ;%NWL%this . _options = _ . merge ( { } , defaultOptions , options ) ;%NWL%this . dispatch = d3 . dispatch ( ' mouseenter ' ,  ' mousemove ' ,  ' mouseleave ' ) ;%NWL%this . _partition = d3 . layout . partition ( )%NWL%. sort ( null )%NWL%. value ( d => d . count )%NWL%;%NWL%let radius = Math . min ( this . _options . width , this . _options . height )  / 2;%NWL%let xScale = d3 . scale . linear ( ) . range ( [ 0 , 2 * Math . PI ] ) ;%NWL%this . _arc = d3 . svg . arc ( )%NWL%3
}%NWL%data ( data )  {%NWL%this . _data = data;%NWL%this . update ( ) ;%NWL%}%NWL%options ( options )  {%NWL%let omit = [%NWL%' width ' ,%NWL%' height '%NWL%] ;%NWL%this . update ( ) ;%NWL%3
. attr ( " x " ,  - h / 2 )%NWL%. attr ( " y " ,  - 30 )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%. text ( ylab )%NWL%%NWL%vis . append ( " line " )%NWL%. attr ( " class " ,  " boundingbox " )%NWL%. attr ( " x1 " , 0 )%NWL%. attr ( " x2 " , 0 )%NWL%. attr ( " y1 " , 0 )%NWL%vis . append ( " line " )%NWL%5
}%NWL%} ) ;%NWL%} ;%NWL%d3 . csv . parseRows = function ( text , f )  {%NWL%var EOL = { } ,  / / sentinel value for end - of - line%NWL%EOF = { } ,  / / sentinel value for end - of - file%NWL%rows = [ ] ,  / / output rows%NWL%re = / \r\n| [ , \r\n ] / g ,  / / field separator regex%NWL%n = 0 ,  / / the current line number%NWL%t ,  / / the current token%NWL%re . lastIndex = 0; / / work - around bug in FF 3 . 6%NWL%7
lower48 . scale ( x ) ;%NWL%alaska . scale ( x *  . 6 ) ;%NWL%hawaii . scale ( x ) ;%NWL%puertoRico . scale ( x * 1 . 5 ) ;%NWL%return albersUsa . translate ( lower48 . translate ( ) ) ;%NWL%} ;%NWL%albersUsa . translate = function ( x )  {%NWL%if ( !arguments . length ) return lower48 . translate ( ) ;%NWL%var dz = lower48 . scale ( )  / 1000 ,%NWL%dx = x [ 0 ] ,%NWL%lower48 . translate ( x ) ;%NWL%0
}%NWL%function d3_geo_boundsMultiLineString ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%for ( var b = a [ i ] , j = 0 , m = b . length; j < m; j + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%}%NWL%}%NWL%}%NWL%function d3_geo_boundsMultiPolygon ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%4
}%NWL%circle . clip = function ( d )  {%NWL%arc . source ( typeof origin === " function " ? origin . apply ( this , arguments ) : origin ) ;%NWL%return clipType ( d ) ;%NWL%} ;%NWL%var clipType = d3_geo_type ( {%NWL%FeatureCollection: function ( o )  {%NWL%var features = o . features . map ( clipType ) . filter ( Object ) ;%NWL%return features && ( o = Object . create ( o ) , o . features = features , o ) ;%NWL%} ,%NWL%var geometry = clipType ( o . geometry ) ;%NWL%7
var features = o . features . map ( clipType ) . filter ( Object ) ;%NWL%return features && ( o = Object . create ( o ) , o . features = features , o ) ;%NWL%} ,%NWL%Feature: function ( o )  {%NWL%var geometry = clipType ( o . geometry ) ;%NWL%return geometry && ( o = Object . create ( o ) , o . geometry = geometry , o ) ;%NWL%} ,%NWL%Point: function ( o )  {%NWL%return visible ( o . coordinates ) && o;%NWL%} ,%NWL%var coordinates = o . coordinates . filter ( visible ) ;%NWL%0
Point: function ( o )  {%NWL%return visible ( o . coordinates ) && o;%NWL%} ,%NWL%MultiPoint: function ( o )  {%NWL%var coordinates = o . coordinates . filter ( visible ) ;%NWL%return coordinates . length && {%NWL%type: o . type ,%NWL%coordinates: coordinates%NWL%} ;%NWL%} ,%NWL%var coordinates = clip ( o . coordinates ) ;%NWL%4
} ;%NWL%} ,%NWL%LineString: function ( o )  {%NWL%var coordinates = clip ( o . coordinates ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%MultiLineString: function ( o )  {%NWL%var coordinates = o . coordinates . map ( clip ) . filter ( function ( d )  { return d . length; } ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%var coordinates = o . coordinates . map ( clip ) ;%NWL%3
return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%Polygon: function ( o )  {%NWL%var coordinates = o . coordinates . map ( clip ) ;%NWL%return coordinates [ 0 ] . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%MultiPolygon: function ( o )  {%NWL%var coordinates = o . coordinates . map ( function ( d )  { return d . map ( clip ) ; } ) . filter ( function ( d )  { return d [ 0 ] . length; } ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%var geometries = o . geometries . map ( clipType ) . filter ( Object ) ;%NWL%3
stringStrip = require ( " . . / . . / . . / . . / string / strip . js " ) ;%NWL%module . exports = function ( vars )  {%NWL%if ( vars . data . url && !vars . data . loaded )  {%NWL%var loadingObject = { } ;%NWL%loadingObject [ vars . text . value || vars . id . value ] = vars . format . value ( vars . format . locale . value . ui . loading ) ;%NWL%vars . data . filtered = [ loadingObject ] ;%NWL%vars . data . changed = vars . data . lastFilter !== " loading " ;%NWL%vars . data . lastFilter = " loading " ;%NWL%}%NWL%else if ( vars . open . value )  {%NWL%vars . data . filtered = vars . data . viz;%NWL%6
module . exports = function ( vars )  {%NWL%if ( vars . data . url && !vars . data . loaded )  {%NWL%var loadingObject = { } ;%NWL%loadingObject [ vars . text . value || vars . id . value ] = vars . format . value ( vars . format . locale . value . ui . loading ) ;%NWL%vars . data . filtered = [ loadingObject ] ;%NWL%vars . data . changed = vars . data . lastFilter !== " loading " ;%NWL%vars . data . lastFilter = " loading " ;%NWL%}%NWL%else if ( vars . open . value )  {%NWL%if ( !vars . search . term )  {%NWL%vars . data . changed = vars . data . lastFilter !== " viz " ;%NWL%5
if ( vars . data . url && !vars . data . loaded )  {%NWL%var loadingObject = { } ;%NWL%loadingObject [ vars . text . value || vars . id . value ] = vars . format . value ( vars . format . locale . value . ui . loading ) ;%NWL%vars . data . filtered = [ loadingObject ] ;%NWL%vars . data . changed = vars . data . lastFilter !== " loading " ;%NWL%vars . data . lastFilter = " loading " ;%NWL%}%NWL%else if ( vars . open . value )  {%NWL%if ( !vars . search . term )  {%NWL%vars . data . filtered = vars . data . viz;%NWL%vars . data . lastFilter = " viz " ;%NWL%4
if ( !vars . search . term )  {%NWL%vars . data . filtered = vars . data . viz;%NWL%vars . data . changed = vars . data . lastFilter !== " viz " ;%NWL%vars . data . lastFilter = " viz " ;%NWL%if ( vars . id . nesting . length > 1 && vars . depth . value < vars . id . nesting . length - 1 )  {%NWL%vars . data . filtered = vars . data . filtered . filter ( function ( d ) {%NWL%if ( " endPoint " in d . d3plus && d . d3plus . endPoint === vars . depth . value )  {%NWL%d . d3plus . icon = false;%NWL%}%NWL%return true;%NWL%vars . data . changed = vars . data . lastFilter !== " depth " ;%NWL%1
vars . data . filtered = vars . data . viz;%NWL%vars . data . changed = vars . data . lastFilter !== " viz " ;%NWL%vars . data . lastFilter = " viz " ;%NWL%if ( vars . id . nesting . length > 1 && vars . depth . value < vars . id . nesting . length - 1 )  {%NWL%vars . data . filtered = vars . data . filtered . filter ( function ( d ) {%NWL%if ( " endPoint " in d . d3plus && d . d3plus . endPoint === vars . depth . value )  {%NWL%d . d3plus . icon = false;%NWL%}%NWL%return true;%NWL%} ) ;%NWL%vars . data . lastFilter = " depth " ;%NWL%0
} ;%NWL%}%NWL%d3 . time . second = function ( date )  {%NWL%return new Date ( ~~ ( date / 1e3 )  * 1e3 ) ;%NWL%} ;%NWL%d3 . time . second . utc = d3 . time . second;%NWL%d3 . time . seconds = d3_time_range ( d3 . time . second , function ( date )  {%NWL%date . setTime ( date . getTime ( )  + 1e3 ) ;%NWL%} , function ( date )  {%NWL%return date . getSeconds ( ) ;%NWL%d3 . time . seconds . utc = d3 . time . seconds;%NWL%5
. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + m [ 3 ]  +  " , "  + m [ 0 ]  +  " ) " )%NWL%. call ( chart ) ;%NWL%var title = vis . append ( " g " )%NWL%. attr ( " text - anchor " ,  " end " )%NWL%. attr ( " transform " ,  " translate ( - 6 , "  +  ( h - m [ 0 ]  - m [ 2 ] )  / 2 +  " ) " ) ;%NWL%title . append ( " text " )%NWL%. attr ( " class " ,  " title " )%NWL%title . append ( " text " )%NWL%8
. attr ( " dy " ,  " 1em " )%NWL%. text ( function ( d )  { return d . subtitle; } ) ;%NWL%chart . duration ( 1000 ) ;%NWL%window . transition = function ( )  {%NWL%vis . map ( randomize ) . call ( chart ) ;%NWL%} ;%NWL%} ) ;%NWL%function randomize ( d )  {%NWL%if ( !d . randomizer ) d . randomizer = randomizer ( d ) ;%NWL%d . ranges = d . ranges . map ( d . randomizer ) ;%NWL%d . measures = d . measures . map ( d . randomizer ) ;%NWL%9
var r = 960 / 2 ,%NWL%splines = [ ] ;%NWL%var cluster = d3 . layout . cluster ( )%NWL%. size ( [ 360 , r - 120 ] )%NWL%. sort ( null )%NWL%var bundle = d3 . layout . bundle ( ) ;%NWL%2
var r = 960 / 2 ,%NWL%splines = [ ] ;%NWL%var cluster = d3 . layout . cluster ( )%NWL%. size ( [ 360 , r - 120 ] )%NWL%. sort ( null )%NWL%. value ( function ( d )  { return d . size; } ) ;%NWL%var line = d3 . svg . line . radial ( )%NWL%2
var line = d3 . svg . line . radial ( )%NWL%. interpolate ( " bundle " )%NWL%. tension ( . 85 )%NWL%. radius ( function ( d )  { return d . y; } )%NWL%. angle ( function ( d )  { return d . x / 180 * Math . PI; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , r * 2 )%NWL%. attr ( " height " , r * 2 )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + r +  " , "  + r +  " ) " ) ;%NWL%var nodes = cluster . nodes ( packages . root ( classes ) ) ,%NWL%0
var w = 960 ,%NWL%h = 500 ,%NWL%fill = d3 . scale . ordinal ( ) . range ( colorbrewer . Greys [ 9 ] . slice ( 1 , 4 ) ) ,%NWL%stroke = d3 . scale . linear ( ) . domain ( [ 0 , 1e4 ] ) . range ( [ " brown " ,  " steelblue " ] ) ;%NWL%var treemap = d3 . layout . treemap ( )%NWL%. size ( [ w , h ] )%NWL%var bundle = d3 . layout . bundle ( ) ;%NWL%4
var w = 960 ,%NWL%h = 500 ,%NWL%fill = d3 . scale . ordinal ( ) . range ( colorbrewer . Greys [ 9 ] . slice ( 1 , 4 ) ) ,%NWL%stroke = d3 . scale . linear ( ) . domain ( [ 0 , 1e4 ] ) . range ( [ " brown " ,  " steelblue " ] ) ;%NWL%var treemap = d3 . layout . treemap ( )%NWL%. size ( [ w , h ] )%NWL%. value ( function ( d )  { return d . size; } ) ;%NWL%var div = d3 . select ( " #chart " ) . append ( " div " )%NWL%4
h = 500 ,%NWL%fill = d3 . scale . ordinal ( ) . range ( colorbrewer . Greys [ 9 ] . slice ( 1 , 4 ) ) ,%NWL%stroke = d3 . scale . linear ( ) . domain ( [ 0 , 1e4 ] ) . range ( [ " brown " ,  " steelblue " ] ) ;%NWL%var treemap = d3 . layout . treemap ( )%NWL%. size ( [ w , h ] )%NWL%. value ( function ( d )  { return d . size; } ) ;%NWL%var bundle = d3 . layout . bundle ( ) ;%NWL%var div = d3 . select ( " #chart " ) . append ( " div " )%NWL%. style ( " position " ,  " relative " )%NWL%. style ( " width " , w +  " px " )%NWL%var line = d3 . svg . line ( )%NWL%3
var bundle = d3 . layout . bundle ( ) ;%NWL%var div = d3 . select ( " #chart " ) . append ( " div " )%NWL%. style ( " position " ,  " relative " )%NWL%. style ( " width " , w +  " px " )%NWL%. style ( " height " , h +  " px " ) ;%NWL%var line = d3 . svg . line ( )%NWL%. interpolate ( " bundle " )%NWL%. tension ( . 85 )%NWL%. x ( function ( d )  { return d . x + d . dx / 2; } )%NWL%. y ( function ( d )  { return d . y + d . dy / 2; } ) ;%NWL%var nodes = treemap . nodes ( packages . root ( classes ) ) ,%NWL%0
var data = [%NWL%,  . 187 ,  . 198 ,  ,  . 133 ,  . 175 ,  . 151 ,  ,  . 1 ,  . 125 ,  . 171 ,  ,  . 172 ,  . 133 ,  ,  . 108 ,%NWL%. 142 ,  . 167 ,  . 201 ,  . 175 ,  . 159 ,  . 169 ,  . 177 ,  . 141 ,  . 163 ,  . 117 ,  . 182 ,  . 153 ,  . 195 ,%NWL%. 189 ,  . 134 ,  . 163 ,  . 133 ,  . 151 ,  . 145 ,  . 13 ,  . 139 ,  . 169 ,  . 164 ,  . 175 ,  . 135 ,  . 152 ,%NWL%. 169 ,  ,  . 132 ,  . 167 ,  . 139 ,  . 184 ,  . 159 ,  . 14 ,  . 146 ,  . 157 ,  ,  . 139 ,  . 183 ,  . 16 ,  . 143%NWL%] ;%NWL%var svg = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , 960 )%NWL%. attr ( " height " , 500 ) ;%NWL%var path = d3 . geo . path ( ) ;%NWL%6
var svg = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , 960 )%NWL%. attr ( " height " , 500 ) ;%NWL%d3 . json ( " . . / data / us - states . json " , function ( json )  {%NWL%var path = d3 . geo . path ( ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " class " ,  " black " )%NWL%. selectAll ( " path " )%NWL%. data ( json . features )%NWL%. enter ( ) . append ( " path " )%NWL%svg . append ( " g " )%NWL%5
. attr ( " class " ,  " black " )%NWL%. selectAll ( " path " )%NWL%. data ( json . features )%NWL%. enter ( ) . append ( " path " )%NWL%. attr ( " d " , path ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " class " ,  " white " )%NWL%. selectAll ( " path " )%NWL%. data ( json . features )%NWL%. enter ( ) . append ( " path " )%NWL%svg . append ( " g " )%NWL%5
. 142 ,  . 167 ,  . 201 ,  . 175 ,  . 159 ,  . 169 ,  . 177 ,  . 141 ,  . 163 ,  . 117 ,  . 182 ,  . 153 ,  . 195 ,%NWL%. 189 ,  . 134 ,  . 163 ,  . 133 ,  . 151 ,  . 145 ,  . 13 ,  . 139 ,  . 169 ,  . 164 ,  . 175 ,  . 135 ,  . 152 ,%NWL%. 169 ,  ,  . 132 ,  . 167 ,  . 139 ,  . 184 ,  . 159 ,  . 14 ,  . 146 ,  . 157 ,  ,  . 139 ,  . 183 ,  . 16 ,  . 143%NWL%] ;%NWL%var color = d3 . scale . linear ( )%NWL%. domain ( [ d3 . min ( data ) , d3 . max ( data ) ] )%NWL%. range ( [ " #aad " ,  " #556 " ] ) ;%NWL%var force = d3 . layout . force ( )%NWL%. charge ( 0 )%NWL%. gravity ( 0 )%NWL%var svg = d3 . select ( " #chart " ) . append ( " svg " ) ;%NWL%7
a . x - = dx;%NWL%a . y - = dy;%NWL%b . x + = dx;%NWL%b . y + = dy;%NWL%}%NWL%} ) ;%NWL%} ) ;%NWL%svg . selectAll ( " rect " )%NWL%. attr ( " x " , function ( d )  { return d . x - d . r; } )%NWL%. attr ( " y " , function ( d )  { return d . y - d . r; } ) ;%NWL%svg . selectAll ( " rect " )%NWL%7
. 142 ,  . 167 ,  . 201 ,  . 175 ,  . 159 ,  . 169 ,  . 177 ,  . 141 ,  . 163 ,  . 117 ,  . 182 ,  . 153 ,  . 195 ,%NWL%. 189 ,  . 134 ,  . 163 ,  . 133 ,  . 151 ,  . 145 ,  . 13 ,  . 139 ,  . 169 ,  . 164 ,  . 175 ,  . 135 ,  . 152 ,%NWL%. 169 ,  ,  . 132 ,  . 167 ,  . 139 ,  . 184 ,  . 159 ,  . 14 ,  . 146 ,  . 157 ,  ,  . 139 ,  . 183 ,  . 16 ,  . 143%NWL%] ;%NWL%var color = d3 . scale . linear ( )%NWL%. domain ( [ d3 . min ( data ) , d3 . max ( data ) ] )%NWL%. range ( [ " #aad " ,  " #556 " ] ) ;%NWL%var force = d3 . layout . force ( )%NWL%. charge ( 0 )%NWL%. gravity ( 0 )%NWL%var svg = d3 . select ( " #chart " ) . append ( " svg " )%NWL%7
a . x - = dx;%NWL%a . y - = dy;%NWL%b . x + = dx;%NWL%b . y + = dy;%NWL%}%NWL%} ) ;%NWL%} ) ;%NWL%svg . selectAll ( " circle " )%NWL%. attr ( " cx " , function ( d )  { return d . x; } )%NWL%. attr ( " cy " , function ( d )  { return d . y; } ) ;%NWL%svg . selectAll ( " circle " )%NWL%7
. interpolate ( d3 . interpolateHsl ) ;%NWL%var arc = d3 . svg . arc ( )%NWL%. startAngle ( 0 )%NWL%. endAngle ( function ( d )  { return d . value * 2 * Math . PI; } )%NWL%. innerRadius ( function ( d )  { return d . index * r; } )%NWL%. outerRadius ( function ( d )  { return ( d . index + s )  * r; } ) ;%NWL%var vis = d3 . select ( " #clock " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%var g = vis . selectAll ( " g " )%NWL%1
var g = vis . selectAll ( " g " )%NWL%. data ( fields )%NWL%. enter ( ) . append ( " g " ) ;%NWL%g . append ( " path " )%NWL%. style ( " fill " , function ( d )  { return fill ( d . value ) ; } )%NWL%. attr ( " d " , arc ) ;%NWL%g . append ( " text " )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%. attr ( " dy " ,  " 1em " )%NWL%. text ( function ( d )  { return d . text; } ) ;%NWL%var g = vis . selectAll ( " g " )%NWL%0
. enter ( ) . append ( " g " ) ;%NWL%g . append ( " path " )%NWL%. style ( " fill " , function ( d )  { return fill ( d . value ) ; } )%NWL%. attr ( " d " , arc ) ;%NWL%g . append ( " text " )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%. attr ( " dy " ,  " 1em " )%NWL%. text ( function ( d )  { return d . text; } ) ;%NWL%d3 . timer ( function ( )  {%NWL%var g = vis . selectAll ( " g " )%NWL%g . select ( " path " )%NWL%1
. attr ( " d " , arc ) ;%NWL%g . append ( " text " )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%. attr ( " dy " ,  " 1em " )%NWL%. text ( function ( d )  { return d . text; } ) ;%NWL%d3 . timer ( function ( )  {%NWL%var g = vis . selectAll ( " g " )%NWL%. data ( fields ) ;%NWL%g . select ( " path " )%NWL%. style ( " fill " , function ( d )  { return fill ( d . value ) ; } )%NWL%g . select ( " text " )%NWL%1
var r = 960 / 2;%NWL%var cluster = d3 . layout . cluster ( )%NWL%var diagonal = d3 . svg . diagonal . radial ( )%NWL%1
var r = 960 / 2;%NWL%var cluster = d3 . layout . cluster ( )%NWL%. size ( [ 360 , r - 120 ] ) ;%NWL%var diagonal = d3 . svg . diagonal . radial ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x / 180 * Math . PI ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , r * 2 )%NWL%. attr ( " height " , r * 2 )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + r +  " , "  + r +  " ) " ) ;%NWL%var nodes = cluster . nodes ( json ) ;%NWL%1
var cluster = d3 . layout . cluster ( )%NWL%. size ( [ 360 , r - 120 ] ) ;%NWL%var diagonal = d3 . svg . diagonal . radial ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x / 180 * Math . PI ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , r * 2 )%NWL%. attr ( " height " , r * 2 )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + r +  " , "  + r +  " ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var link = vis . selectAll ( " path . link " )%NWL%0
. attr ( " width " , r * 2 )%NWL%. attr ( " height " , r * 2 )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + r +  " , "  + r +  " ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var nodes = cluster . nodes ( json ) ;%NWL%var link = vis . selectAll ( " path . link " )%NWL%. data ( cluster . links ( nodes ) )%NWL%. enter ( ) . append ( " path " )%NWL%. attr ( " class " ,  " link " )%NWL%var node = vis . selectAll ( " g . node " )%NWL%5
var w = 960 ,%NWL%h = 2200;%NWL%var cluster = d3 . layout . cluster ( )%NWL%var diagonal = d3 . svg . diagonal ( )%NWL%2
h = 2200;%NWL%var cluster = d3 . layout . cluster ( )%NWL%. size ( [ h , w - 160 ] ) ;%NWL%var diagonal = d3 . svg . diagonal ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( 40 , 0 ) " ) ;%NWL%var nodes = cluster . nodes ( json ) ;%NWL%1
var cluster = d3 . layout . cluster ( )%NWL%. size ( [ h , w - 160 ] ) ;%NWL%var diagonal = d3 . svg . diagonal ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( 40 , 0 ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var link = vis . selectAll ( " path . link " )%NWL%0
. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( 40 , 0 ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var nodes = cluster . nodes ( json ) ;%NWL%var link = vis . selectAll ( " path . link " )%NWL%. data ( cluster . links ( nodes ) )%NWL%. enter ( ) . append ( " path " )%NWL%. attr ( " class " ,  " link " )%NWL%var node = vis . selectAll ( " g . node " )%NWL%5
var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h ) ;%NWL%d3 . json ( " miserables . json " , function ( json )  {%NWL%var force = d3 . layout . force ( )%NWL%. charge ( - 120 )%NWL%. linkDistance ( 30 )%NWL%. nodes ( json . nodes )%NWL%. links ( json . links )%NWL%. size ( [ w , h ] )%NWL%var link = vis . selectAll ( " line . link " )%NWL%4
. size ( [ w , h ] )%NWL%. start ( ) ;%NWL%var link = vis . selectAll ( " line . link " )%NWL%. data ( json . links )%NWL%. enter ( ) . append ( " line " )%NWL%. attr ( " class " ,  " link " )%NWL%. style ( " stroke - width " , function ( d )  { return Math . sqrt ( d . value ) ; } )%NWL%. attr ( " x1 " , function ( d )  { return d . source . x; } )%NWL%. attr ( " y1 " , function ( d )  { return d . source . y; } )%NWL%. attr ( " x2 " , function ( d )  { return d . target . x; } )%NWL%var node = vis . selectAll ( " circle . node " )%NWL%2
var w = 960 ,%NWL%h = 40;%NWL%var chart = d3 . chart . horizon ( )%NWL%. width ( w )%NWL%. height ( h )%NWL%. bands ( 5 )%NWL%. mode ( " offset " )%NWL%var svg = d3 . select ( " #chart " ) . append ( " svg " )%NWL%2
. attr ( " height " , h ) ;%NWL%d3 . json ( " unemployment . json " , function ( data )  {%NWL%var mean = data . rate . reduce ( function ( p , v )  { return p + v; } , 0 )  / data . rate . length;%NWL%data = data . rate . map ( function ( rate , i )  {%NWL%return [ Date . UTC ( data . year [ i ] , data . month [ i ]  - 1 ) , rate - mean ] ;%NWL%} ) ;%NWL%svg . data ( [ data ] ) . call ( chart ) ;%NWL%d3 . selectAll ( " #mode button " )%NWL%. data ( [ " offset " ,  " mirror " ] )%NWL%. on ( " click " , function ( m )  {%NWL%d3 . selectAll ( " #mode button " )%NWL%7
. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + p +  " , "  + p +  " ) " ) ;%NWL%var rules = vis . selectAll ( " g . rule " )%NWL%. data ( x . ticks ( 10 ) )%NWL%. enter ( ) . append ( " g " )%NWL%. attr ( " class " ,  " rule " ) ;%NWL%rules . append ( " line " )%NWL%. attr ( " x1 " , x )%NWL%. attr ( " x2 " , x )%NWL%. attr ( " y1 " , 0 )%NWL%rules . append ( " line " )%NWL%6
. attr ( " class " , function ( d )  { return d ? null : " axis " ; } )%NWL%. attr ( " y1 " , y )%NWL%. attr ( " y2 " , y )%NWL%. attr ( " x1 " , 0 )%NWL%. attr ( " x2 " , w + 1 ) ;%NWL%rules . append ( " text " )%NWL%. attr ( " x " , x )%NWL%. attr ( " y " , h + 3 )%NWL%. attr ( " dy " ,  " . 71em " )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%rules . append ( " text " )%NWL%5
vars . container . selector . style ( " height " , " auto " )%NWL%vars . container . list . style ( " max - height " , " 200000px " )%NWL%vars . container . listHeight = parseFloat ( vars . container . selector . style ( " height " ) , 10 )%NWL%vars . container . list%NWL%. style ( " max - height " , list_height )%NWL%. property ( " scrollTop " , list_scroll )%NWL%vars . container . selector%NWL%. style ( " height " , old_height )%NWL%. property ( " scrollTop " , old_scroll )%NWL%var scrolling = false%NWL%vars . container . listHeight = vars . height . secondary%NWL%2
require ( " . . / . . / test / env " ) ;%NWL%require ( " . . / . . / d3 " ) ;%NWL%require ( " . . / . . / d3 . geo " ) ;%NWL%var fs = require ( " fs " ) ,%NWL%util = require ( " util " ) ,%NWL%Canvas = require ( " canvas " ) ;%NWL%var w = 1920 ,%NWL%h = 1080;%NWL%var projection = d3 . geo . albersUsa ( )%NWL%. scale ( 2000 )%NWL%var path = d3 . geo . path ( )%NWL%3
render ( ) ;%NWL%context [ action ] ( ) ;%NWL%function render ( j )  {%NWL%switch ( d . charAt ( i ) )  {%NWL%case " M " : {%NWL%var p = d . substring ( i + 1 , j ) . split ( " , " ) . map ( Number ) ;%NWL%context . moveTo ( p [ 0 ] , p [ 1 ] ) ;%NWL%break;%NWL%}%NWL%case " L " : {%NWL%context . lineTo ( p [ 0 ] , p [ 1 ] ) ;%NWL%6
format = d3 . format ( " , d " ) ;%NWL%var pack = d3 . layout . pack ( )%NWL%. size ( [ w - 4 , h - 4 ] )%NWL%. value ( function ( d )  { return d . size; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. attr ( " class " ,  " pack " )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( 2 , 2 ) " ) ;%NWL%var node = vis . data ( [ json ] ) . selectAll ( " g . node " )%NWL%1
r = Math . min ( w , h )  / 2 ,%NWL%color = d3 . scale . category20c ( ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + w / 2 +  " , "  + h / 2 +  " ) " ) ;%NWL%var partition = d3 . layout . partition ( )%NWL%. sort ( null )%NWL%. size ( [ 2 * Math . PI , r * r ] )%NWL%var arc = d3 . svg . arc ( )%NWL%7
. attr ( " transform " ,  " translate ( "  + w / 2 +  " , "  + h / 2 +  " ) " ) ;%NWL%var partition = d3 . layout . partition ( )%NWL%. sort ( null )%NWL%. size ( [ 2 * Math . PI , r * r ] )%NWL%. value ( function ( d )  { return 1; } ) ;%NWL%var arc = d3 . svg . arc ( )%NWL%. startAngle ( function ( d )  { return d . x; } )%NWL%. endAngle ( function ( d )  { return d . x + d . dx; } )%NWL%. innerRadius ( function ( d )  { return Math . sqrt ( d . y ) ; } )%NWL%. outerRadius ( function ( d )  { return Math . sqrt ( d . y + d . dy ) ; } ) ;%NWL%var path = vis . data ( [ json ] ) . selectAll ( " path " )%NWL%1
var x = { } , y = { } ;%NWL%flower . traits . forEach ( function ( trait )  {%NWL%var value = function ( d )  { return d [ trait ] ; } ,%NWL%domain = [ d3 . min ( flower . values , value ) , d3 . max ( flower . values , value ) ] ,%NWL%range = [ padding / 2 , size - padding / 2 ] ;%NWL%x [ trait ] = d3 . scale . linear ( ) . domain ( domain ) . range ( range ) ;%NWL%y [ trait ] = d3 . scale . linear ( ) . domain ( domain ) . range ( range . reverse ( ) ) ;%NWL%} ) ;%NWL%var axis = d3 . svg . axis ( )%NWL%. ticks ( 5 )%NWL%var brush = d3 . svg . brush ( )%NWL%8
range = [ padding / 2 , size - padding / 2 ] ;%NWL%x [ trait ] = d3 . scale . linear ( ) . domain ( domain ) . range ( range ) ;%NWL%y [ trait ] = d3 . scale . linear ( ) . domain ( domain ) . range ( range . reverse ( ) ) ;%NWL%} ) ;%NWL%var axis = d3 . svg . axis ( )%NWL%. ticks ( 5 )%NWL%. tickSize ( size * n ) ;%NWL%var brush = d3 . svg . brush ( )%NWL%. on ( " brushstart " , brushstart )%NWL%. on ( " brush " , brush )%NWL%var svg = d3 . select ( " #chart " ) . append ( " svg " )%NWL%4
var prefix = require ( " . . / . . / . . / . . / client / prefix . coffee " ) ,%NWL%print = require ( " . . / . . / . . / . . / core / console / print . coffee " )%NWL%module . exports = function ( vars )  {%NWL%var data = require ( " . / data . js " )%NWL%0
items ( vars ) ;%NWL%update ( vars ) ;%NWL%}%NWL%} ) ;%NWL%vars . container . search . exit ( ) . remove ( )%NWL%var oldDisplay = vars . container . selector . style ( " display " )%NWL%vars . container . selector . style ( " display " ,  " block " )%NWL%vars . search . height = vars . search . enabled ? vars . container . search . node ( ) . offsetHeight ||%NWL%vars . container . search . node ( ) . getBoundingClientRect ( ) . height : 0;%NWL%vars . container . selector . style ( " display " , oldDisplay )%NWL%vars . margin . title + = vars . search . height%NWL%7
var r = 960 / 2;%NWL%var tree = d3 . layout . tree ( )%NWL%. size ( [ 360 , r - 120 ] )%NWL%var diagonal = d3 . svg . diagonal . radial ( )%NWL%1
var tree = d3 . layout . tree ( )%NWL%. size ( [ 360 , r - 120 ] )%NWL%. separation ( function ( a , b )  { return ( a . parent == b . parent ? 1 : 2 )  / a . depth; } ) ;%NWL%var diagonal = d3 . svg . diagonal . radial ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x / 180 * Math . PI ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , r * 2 )%NWL%. attr ( " height " , r * 2 - 150 )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + r +  " , "  + r +  " ) " ) ;%NWL%var nodes = tree . nodes ( json ) ;%NWL%0
. size ( [ 360 , r - 120 ] )%NWL%. separation ( function ( a , b )  { return ( a . parent == b . parent ? 1 : 2 )  / a . depth; } ) ;%NWL%var diagonal = d3 . svg . diagonal . radial ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x / 180 * Math . PI ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , r * 2 )%NWL%. attr ( " height " , r * 2 - 150 )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + r +  " , "  + r +  " ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var link = vis . selectAll ( " path . link " )%NWL%2
. attr ( " width " , r * 2 )%NWL%. attr ( " height " , r * 2 - 150 )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( "  + r +  " , "  + r +  " ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var nodes = tree . nodes ( json ) ;%NWL%var link = vis . selectAll ( " path . link " )%NWL%. data ( tree . links ( nodes ) )%NWL%. enter ( ) . append ( " path " )%NWL%. attr ( " class " ,  " link " )%NWL%var node = vis . selectAll ( " g . node " )%NWL%5
var w = 960 ,%NWL%h = 2000;%NWL%var tree = d3 . layout . tree ( )%NWL%var diagonal = d3 . svg . diagonal ( )%NWL%2
h = 2000;%NWL%var tree = d3 . layout . tree ( )%NWL%. size ( [ h , w - 160 ] ) ;%NWL%var diagonal = d3 . svg . diagonal ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( 40 , 0 ) " ) ;%NWL%var nodes = tree . nodes ( json ) ;%NWL%1
var tree = d3 . layout . tree ( )%NWL%. size ( [ h , w - 160 ] ) ;%NWL%var diagonal = d3 . svg . diagonal ( )%NWL%. projection ( function ( d )  { return [ d . y , d . x ] ; } ) ;%NWL%var vis = d3 . select ( " #chart " ) . append ( " svg " )%NWL%. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( 40 , 0 ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var link = vis . selectAll ( " path . link " )%NWL%0
. attr ( " width " , w )%NWL%. attr ( " height " , h )%NWL%. append ( " g " )%NWL%. attr ( " transform " ,  " translate ( 40 , 0 ) " ) ;%NWL%d3 . json ( " . . / data / flare . json " , function ( json )  {%NWL%var nodes = tree . nodes ( json ) ;%NWL%var link = vis . selectAll ( " path . link " )%NWL%. data ( tree . links ( nodes ) )%NWL%. enter ( ) . append ( " path " )%NWL%. attr ( " class " ,  " link " )%NWL%var node = vis . selectAll ( " g . node " )%NWL%5
var w = 960 ,%NWL%h = 500 ,%NWL%color = d3 . scale . category20c ( ) ;%NWL%var treemap = d3 . layout . treemap ( )%NWL%. padding ( 4 )%NWL%. size ( [ w , h ] )%NWL%var svg = d3 . select ( " body " ) . append ( " svg " )%NWL%3
var w = 960 ,%NWL%h = 500 ,%NWL%color = d3 . scale . category20c ( ) ;%NWL%var treemap = d3 . layout . treemap ( )%NWL%. size ( [ w , h ] )%NWL%. sticky ( true )%NWL%var div = d3 . select ( " #chart " ) . append ( " div " )%NWL%3
. text ( function ( d )  { return d . children ? null : d . name; } ) ;%NWL%d3 . select ( " #size " ) . on ( " click " , function ( )  {%NWL%div . selectAll ( " div " )%NWL%. data ( treemap . value ( function ( d )  { return d . size; } ) )%NWL%. transition ( )%NWL%. duration ( 1500 )%NWL%. call ( cell ) ;%NWL%d3 . select ( " #size " ) . classed ( " active " , true ) ;%NWL%d3 . select ( " #count " ) . classed ( " active " , false ) ;%NWL%} ) ;%NWL%div . selectAll ( " div " )%NWL%2
. attr ( " class " , function ( d , i )  { return i ? " q "  +  ( i % 9 )  +  " - 9 " : null; } )%NWL%. attr ( " d " , function ( d )  { return " M "  + d . join ( " L " )  +  " Z " ; } ) ;%NWL%svg . selectAll ( " circle " )%NWL%. data ( vertices )%NWL%. enter ( ) . append ( " circle " )%NWL%. attr ( " transform " , function ( d )  { return " translate ( "  + d +  " ) " ; } )%NWL%. attr ( " r " , 2 ) ;%NWL%d3 . timer ( function ( )  {%NWL%boids . forEach ( function ( boid , i )  {%NWL%vertices [ i ] = boid ( boids ) ;%NWL%svg . selectAll ( " circle " )%NWL%2
}%NWL%if ( vars . draw . timing )  {%NWL%vars . container . title . transition ( ) . duration ( vars . draw . timing )%NWL%. call ( boxStyle )%NWL%vars . container . title . select ( " div . d3plus_drop_title_text " )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. call ( titleStyle )%NWL%}%NWL%else {%NWL%vars . container . title%NWL%vars . container . title . select ( " div . d3plus_drop_title_text " )%NWL%4
. attr ( " class " , " d3plus_drop_title_text " )%NWL%. call ( titleStyle )%NWL%vars . container . title%NWL%. on ( events . over , function ( d , i ) {%NWL%var color = lighter ( vars . ui . color . secondary . value )%NWL%d3 . select ( this ) . style ( " cursor " , " pointer " )%NWL%. transition ( ) . duration ( vars . timing . mouseevents )%NWL%. style ( " background - color " , color )%NWL%. style ( " color " , textColor ( color ) )%NWL%} )%NWL%var color = vars . ui . color . secondary . value%NWL%4
d3_behavior_zoomTarget = this;%NWL%d3_behavior_zoomArguments = arguments;%NWL%}%NWL%function mousedown ( )  {%NWL%start . apply ( this , arguments ) ;%NWL%d3_behavior_zoomPanning = d3_behavior_zoomLocation ( d3 . svg . mouse ( d3_behavior_zoomTarget ) ) ;%NWL%d3_behavior_zoomMoved = 0;%NWL%d3 . event . preventDefault ( ) ;%NWL%window . focus ( ) ;%NWL%}%NWL%start . apply ( this , arguments ) ;%NWL%4
d3_behavior_zoomPanning = d3_behavior_zoomLocation ( d3 . svg . mouse ( d3_behavior_zoomTarget ) ) ;%NWL%d3_behavior_zoomMoved = 0;%NWL%d3 . event . preventDefault ( ) ;%NWL%window . focus ( ) ;%NWL%}%NWL%function mousewheel ( )  {%NWL%start . apply ( this , arguments ) ;%NWL%if ( !d3_behavior_zoomZooming ) d3_behavior_zoomZooming = d3_behavior_zoomLocation ( d3 . svg . mouse ( d3_behavior_zoomTarget ) ) ;%NWL%d3_behavior_zoomTo ( d3_behavior_zoomDelta ( )  + xyz [ 2 ] , d3 . svg . mouse ( d3_behavior_zoomTarget ) , d3_behavior_zoomZooming ) ;%NWL%}%NWL%start . apply ( this , arguments ) ;%NWL%6
function mousewheel ( )  {%NWL%start . apply ( this , arguments ) ;%NWL%if ( !d3_behavior_zoomZooming ) d3_behavior_zoomZooming = d3_behavior_zoomLocation ( d3 . svg . mouse ( d3_behavior_zoomTarget ) ) ;%NWL%d3_behavior_zoomTo ( d3_behavior_zoomDelta ( )  + xyz [ 2 ] , d3 . svg . mouse ( d3_behavior_zoomTarget ) , d3_behavior_zoomZooming ) ;%NWL%}%NWL%function dblclick ( )  {%NWL%start . apply ( this , arguments ) ;%NWL%var mouse = d3 . svg . mouse ( d3_behavior_zoomTarget ) ;%NWL%d3_behavior_zoomTo ( d3 . event . shiftKey ? Math . ceil ( xyz [ 2 ]  - 1 ) : Math . floor ( xyz [ 2 ]  + 1 ) , mouse , d3_behavior_zoomLocation ( mouse ) ) ;%NWL%}%NWL%start . apply ( this , arguments ) ;%NWL%1
return delta *  . 005;%NWL%}%NWL%function d3_behavior_zoomTouchup ( )  {%NWL%var touches = d3 . svg . touches ( d3_behavior_zoomTarget ) ,%NWL%i = - 1 ,%NWL%n = touches . length ,%NWL%touch;%NWL%while ( + + i < n ) d3_behavior_zoomLocations [ ( touch = touches [ i ] ) . identifier ] = d3_behavior_zoomLocation ( touch ) ;%NWL%return touches;%NWL%}%NWL%var touches = d3 . svg . touches ( d3_behavior_zoomTarget ) ;%NWL%3
for ( ; i < m; + + i )  {%NWL%enterNodes [ i ] = d3_selection_dataNode ( groupData [ i ] ) ;%NWL%updateNodes [ i ] = exitNodes [ i ] = null;%NWL%}%NWL%for ( ; i < n1; + + i )  {%NWL%exitNodes [ i ] = group [ i ] ;%NWL%enterNodes [ i ] = updateNodes [ i ] = null;%NWL%}%NWL%}%NWL%enterNodes . update%NWL%enterNodes . parentNode%NWL%9
rtl      = require ( " . . / client / rtl . coffee " ) ,%NWL%removeTooltip = require ( " . / remove . coffee " ) ,%NWL%scroll    = require ( " . . / client / scroll . js " ) ,%NWL%scrollBar   = require ( " . . / client / scrollbar . coffee " ) ,%NWL%stringList  = require ( " . . / string / list . coffee " ) ,%NWL%textColor   = require ( " . . / color / text . coffee " )%NWL%module . exports = function ( params )  {%NWL%var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . id = params . id || " default "%NWL%9
removeTooltip = require ( " . / remove . coffee " ) ,%NWL%scroll    = require ( " . . / client / scroll . js " ) ,%NWL%scrollBar   = require ( " . . / client / scrollbar . coffee " ) ,%NWL%stringList  = require ( " . . / string / list . coffee " ) ,%NWL%textColor   = require ( " . . / color / text . coffee " )%NWL%module . exports = function ( params )  {%NWL%var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%8
scroll    = require ( " . . / client / scroll . js " ) ,%NWL%scrollBar   = require ( " . . / client / scrollbar . coffee " ) ,%NWL%stringList  = require ( " . . / string / list . coffee " ) ,%NWL%textColor   = require ( " . . / color / text . coffee " )%NWL%module . exports = function ( params )  {%NWL%var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . offset = params . offset || 0%NWL%7
scrollBar   = require ( " . . / client / scrollbar . coffee " ) ,%NWL%stringList  = require ( " . . / string / list . coffee " ) ,%NWL%textColor   = require ( " . . / color / text . coffee " )%NWL%module . exports = function ( params )  {%NWL%var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%6
stringList  = require ( " . . / string / list . coffee " ) ,%NWL%textColor   = require ( " . . / color / text . coffee " )%NWL%module . exports = function ( params )  {%NWL%var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . x = params . x || 0%NWL%5
textColor   = require ( " . . / color / text . coffee " )%NWL%module . exports = function ( params )  {%NWL%var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . y = params . y || 0%NWL%4
module . exports = function ( params )  {%NWL%var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%3
var default_width = params . fullscreen ? 250 : 200%NWL%, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . curtain = params . curtain || " #fff "%NWL%2
, vendor = prefix ( )%NWL%params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%1
params . width = params . width || default_width%NWL%params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . background = params . background || " #fff "%NWL%0
params . max_width = params . max_width || 386%NWL%params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . fontcolor = params . fontcolor || " #444 "%NWL%0
params . id = params . id || " default "%NWL%params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . background = params . background || " #fff "%NWL%params . fontfamily = params . fontfamily || " sans - serif "%NWL%0
params . size = params . fullscreen || params . html ? " large " : " small "%NWL%params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . background = params . background || " #fff "%NWL%params . fontcolor = params . fontcolor || " #444 "%NWL%params . fontweight = params . fontweight || " normal "%NWL%1
params . offset = params . offset || 0%NWL%params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . background = params . background || " #fff "%NWL%params . fontcolor = params . fontcolor || " #444 "%NWL%params . fontfamily = params . fontfamily || " sans - serif "%NWL%params . fontsize = params . fontsize || " 12px "%NWL%0
params . arrow_offset = params . arrow ? 8 : 0%NWL%params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . background = params . background || " #fff "%NWL%params . fontcolor = params . fontcolor || " #444 "%NWL%params . fontfamily = params . fontfamily || " sans - serif "%NWL%params . fontweight = params . fontweight || " normal "%NWL%params . style = params . style || " default "%NWL%1
params . x = params . x || 0%NWL%params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . background = params . background || " #fff "%NWL%params . fontcolor = params . fontcolor || " #444 "%NWL%params . fontfamily = params . fontfamily || " sans - serif "%NWL%params . fontweight = params . fontweight || " normal "%NWL%params . fontsize = params . fontsize || " 12px "%NWL%params . zindex = params . size == " small " ? 2000 : 500%NWL%0
params . y = params . y || 0%NWL%params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . background = params . background || " #fff "%NWL%params . fontcolor = params . fontcolor || " #444 "%NWL%params . fontfamily = params . fontfamily || " sans - serif "%NWL%params . fontweight = params . fontweight || " normal "%NWL%params . fontsize = params . fontsize || " 12px "%NWL%params . style = params . style || " default "%NWL%params . locale = params . locale || defaultLocale%NWL%0
params . parent = params . parent || d3 . select ( " body " )%NWL%params . curtain = params . curtain || " #fff "%NWL%params . curtainopacity = params . curtainopacity || 0 . 8%NWL%params . background = params . background || " #fff "%NWL%params . fontcolor = params . fontcolor || " #444 "%NWL%params . fontfamily = params . fontfamily || " sans - serif "%NWL%params . fontweight = params . fontweight || " normal "%NWL%params . fontsize = params . fontsize || " 12px "%NWL%params . style = params . style || " default "%NWL%params . zindex = params . size == " small " ? 2000 : 500%NWL%params . stacked = params . stacked || false;%NWL%0
params . fontcolor = params . fontcolor || " #444 "%NWL%params . fontfamily = params . fontfamily || " sans - serif "%NWL%params . fontweight = params . fontweight || " normal "%NWL%params . fontsize = params . fontsize || " 12px "%NWL%params . style = params . style || " default "%NWL%params . zindex = params . size == " small " ? 2000 : 500%NWL%params . locale = params . locale || defaultLocale%NWL%params . stacked = params . stacked || false;%NWL%var parentHeight = params . parent ? params . parent . node ( ) . offsetHeight%NWL%|| params . parent . node ( ) . getBoundingClientRect ( ) . height : 0%NWL%params . iconsize = params . size == " small " ? 22 : 50%NWL%0
params . fontsize = params . fontsize || " 12px "%NWL%params . style = params . style || " default "%NWL%params . zindex = params . size == " small " ? 2000 : 500%NWL%params . locale = params . locale || defaultLocale%NWL%params . stacked = params . stacked || false;%NWL%var parentHeight = params . parent ? params . parent . node ( ) . offsetHeight%NWL%|| params . parent . node ( ) . getBoundingClientRect ( ) . height : 0%NWL%if ( !params . iconsize )  {%NWL%params . iconsize = params . size == " small " ? 22 : 50%NWL%}%NWL%params . limit = [ window . innerWidth + scroll . x ( ) , window . innerHeight + scroll . y ( ) ] ;%NWL%0
parseFloat ( params . parent . style ( " height " ) , 10 )%NWL%] ;%NWL%}%NWL%if ( params . title instanceof Array )  {%NWL%var and = params . locale . ui . and%NWL%, more = params . locale . ui . more%NWL%params . title = stringList ( params . title , and , 3 , more )%NWL%}%NWL%removeTooltip ( params . id )%NWL%params . anchor = { }%NWL%params . anchor . x = " center "%NWL%6
] ;%NWL%}%NWL%if ( params . title instanceof Array )  {%NWL%var and = params . locale . ui . and%NWL%, more = params . locale . ui . more%NWL%params . title = stringList ( params . title , and , 3 , more )%NWL%}%NWL%removeTooltip ( params . id )%NWL%params . anchor = { }%NWL%if ( params . fullscreen )  {%NWL%params . anchor . y = " center "%NWL%5
}%NWL%if ( params . title instanceof Array )  {%NWL%var and = params . locale . ui . and%NWL%, more = params . locale . ui . more%NWL%params . title = stringList ( params . title , and , 3 , more )%NWL%}%NWL%removeTooltip ( params . id )%NWL%params . anchor = { }%NWL%if ( params . fullscreen )  {%NWL%params . anchor . x = " center "%NWL%params . x = params . parent ? params . parent . node ( ) . offsetWidth / 2 : window . innerWidth / 2%NWL%4
if ( params . title instanceof Array )  {%NWL%var and = params . locale . ui . and%NWL%, more = params . locale . ui . more%NWL%params . title = stringList ( params . title , and , 3 , more )%NWL%}%NWL%removeTooltip ( params . id )%NWL%params . anchor = { }%NWL%if ( params . fullscreen )  {%NWL%params . anchor . x = " center "%NWL%params . anchor . y = " center "%NWL%params . y = params . parent ? parentHeight / 2 : window . innerHeight / 2%NWL%3
. style ( " right " , " 16px " )%NWL%. style ( " top " , " - 10px " )%NWL%. style ( " width " , " 18px " )%NWL%. style ( " z - index " , 10 )%NWL%. html ( " \&times; " )%NWL%. on ( events . over , function ( ) {%NWL%d3 . select ( this )%NWL%. style ( " cursor " , " pointer " )%NWL%. style ( vendor + " box - shadow " , " 0 1px 3px rgba ( 0 , 0 , 0 , 0 . 5 ) " )%NWL%} )%NWL%d3 . select ( this )%NWL%6
desc . style ( " height " , dh + " px " )%NWL%} )%NWL%. on ( events . out , function ( ) {%NWL%d3 . event . stopPropagation ( )%NWL%} )%NWL%name%NWL%. style ( " cursor " , " pointer " )%NWL%. on ( events . over , function ( ) {%NWL%close_descriptions ( )%NWL%var c = d3 . select ( this . parentNode ) . style ( " color " )%NWL%desc . style ( " height " , dh + " px " )%NWL%0
d3 . event . stopPropagation ( )%NWL%} )%NWL%name%NWL%. style ( " cursor " , " pointer " )%NWL%. on ( events . over , function ( ) {%NWL%close_descriptions ( )%NWL%var c = d3 . select ( this . parentNode ) . style ( " color " )%NWL%help . style ( " background - color " , c )%NWL%desc . style ( " height " , dh + " px " )%NWL%} )%NWL%d3 . event . stopPropagation ( )%NWL%0
data_container . selectAll ( " . d3plus_tooltip_data_name " )%NWL%. style ( " width " , function ( ) {%NWL%var w = parseFloat ( d3 . select ( this . parentNode ) . style ( " width " ) , 10 )%NWL%return ( w - val_width - 30 ) + " px "%NWL%} )%NWL%data_container . selectAll ( " . d3plus_tooltip_data_value " )%NWL%. style ( " width " , val_width + " px " )%NWL%. each ( function ( d ) {%NWL%var h = parseFloat ( d3 . select ( this ) . style ( " height " ) , 10 )%NWL%val_heights [ d . name ] = h%NWL%data_container . selectAll ( " . d3plus_tooltip_data_name " )%NWL%0
if ( vars . dev . value )  {%NWL%var timerString = year ? " fetching pool data " : " fetching data "%NWL%print . time ( timerString )%NWL%}%NWL%vars . data . pool = fetchData ( vars , year )%NWL%if ( vars . dev . value ) print . timeEnd ( timerString )%NWL%if ( !year )  {%NWL%vars . data . viz = vars . data . pool%NWL%}%NWL%else {%NWL%vars . data . viz = fetchData ( vars )%NWL%7
}%NWL%vars . data . pool = fetchData ( vars , year )%NWL%if ( vars . dev . value ) print . timeEnd ( timerString )%NWL%if ( !year )  {%NWL%vars . data . viz = vars . data . pool%NWL%}%NWL%else {%NWL%if ( vars . dev . value ) print . time ( " fetching data for current year " )%NWL%vars . data . viz = fetchData ( vars )%NWL%if ( vars . dev . value ) print . timeEnd ( " fetching data for current year " )%NWL%vars . draw . timing = vars . data . viz . length < vars . data . large ?%NWL%4
if ( vars . draw . update )  {%NWL%drawDrawer ( vars )%NWL%drawTimeline ( vars )%NWL%drawLegend ( vars )%NWL%}%NWL%else {%NWL%if ( vars . dev . value ) print . time ( " calculating margins " )%NWL%var drawer = vars . container . value . select ( " div#d3plus_drawer " ) . node ( ) . offsetHeight%NWL%|| vars . container . value . select ( " div#d3plus_drawer " ) . node ( ) . getBoundingClientRect ( ) . height%NWL%var timeline = vars . g . timeline . node ( ) . getBBox ( )%NWL%var legend = vars . g . legend . node ( ) . getBBox ( )%NWL%9
var str = vars . format . locale . value . error . lib%NWL%, app = vars . format . locale . value . visualization [ vars . type . value ]%NWL%vars . error . internal = stringFormat ( str , app , missing [ 0 ] )%NWL%}%NWL%var shapes = vars . shape . accepted ( vars ) ;%NWL%if ( ! ( shapes instanceof Array ) ) shapes = [ shapes ]%NWL%var shape = vars . shape . value;%NWL%if ( !shape || rejected ( vars , shapes , shape ,  " shape " ) )  {%NWL%vars . self . shape ( shapes [ 0 ] ) ;%NWL%}%NWL%var modes = vars . types [ vars . type . value ] . modes%NWL%6
vars . error . internal = stringFormat ( str , app , missing [ 0 ] )%NWL%}%NWL%var shapes = vars . shape . accepted ( vars ) ;%NWL%if ( ! ( shapes instanceof Array ) ) shapes = [ shapes ]%NWL%var shape = vars . shape . value;%NWL%if ( !shape || rejected ( vars , shapes , shape ,  " shape " ) )  {%NWL%vars . self . shape ( shapes [ 0 ] ) ;%NWL%}%NWL%if ( " modes " in vars . types [ vars . type . value ] )  {%NWL%var modes = vars . types [ vars . type . value ] . modes%NWL%var mode = vars . type . mode . value%NWL%4
var edges = require ( " . / shapes / edges . js " ) ,%NWL%paths    = require ( " . / shapes / paths . js " ) ,%NWL%flash    = require ( " . / ui / message . js " ) ,%NWL%focusViz  = require ( " . / focus / viz . js " ) ,%NWL%methodReset = require ( " . . / . . / core / methods / reset . coffee " ) ,%NWL%print    = require ( " . . / . . / core / console / print . coffee " ) ,%NWL%shapeLabels = require ( " . / shapes / labels . js " ) ,%NWL%var bounds = require ( " . / zoom / bounds . coffee " )%NWL%0
var edges = require ( " . / shapes / edges . js " ) ,%NWL%paths    = require ( " . / shapes / paths . js " ) ,%NWL%flash    = require ( " . / ui / message . js " ) ,%NWL%focusViz  = require ( " . / focus / viz . js " ) ,%NWL%methodReset = require ( " . . / . . / core / methods / reset . coffee " ) ,%NWL%print    = require ( " . . / . . / core / console / print . coffee " ) ,%NWL%shapeLabels = require ( " . / shapes / labels . js " ) ,%NWL%titleCase  = require ( " . . / . . / string / title . coffee " )%NWL%var labels = require ( " . / zoom / labels . coffee " )%NWL%0
var edges = require ( " . / shapes / edges . js " ) ,%NWL%paths    = require ( " . / shapes / paths . js " ) ,%NWL%flash    = require ( " . / ui / message . js " ) ,%NWL%focusViz  = require ( " . / focus / viz . js " ) ,%NWL%methodReset = require ( " . . / . . / core / methods / reset . coffee " ) ,%NWL%print    = require ( " . . / . . / core / console / print . coffee " ) ,%NWL%shapeLabels = require ( " . / shapes / labels . js " ) ,%NWL%titleCase  = require ( " . . / . . / string / title . coffee " )%NWL%var bounds = require ( " . / zoom / bounds . coffee " )%NWL%var mouse = require ( " . / zoom / mouse . coffee " )%NWL%0
var mouse = require ( " . / zoom / mouse . coffee " )%NWL%module . exports = function ( vars )  {%NWL%if ( vars . draw . first )  {%NWL%setTimeout ( function ( ) {%NWL%focusViz ( vars ) ;%NWL%} , vars . draw . timing ) ;%NWL%}%NWL%else {%NWL%focusViz ( vars ) ;%NWL%}%NWL%var zoom = vars . zoom . viewport || vars . zoom . bounds%NWL%0
. attr ( " opacity " , new_opacity ) ;%NWL%vars . g . edges . transition ( ) . duration ( timing )%NWL%. attr ( " opacity " , new_opacity ) ;%NWL%}%NWL%if ( vars . error . value )  {%NWL%flash ( vars , vars . error . value ) ;%NWL%}%NWL%else if ( vars . error . internal )  {%NWL%vars . error . internal = titleCase ( vars . error . internal ) ;%NWL%print . warning ( vars . error . internal ) ;%NWL%vars . error . internal = null;%NWL%8
}%NWL%else {%NWL%flash ( vars ) ;%NWL%}%NWL%setTimeout ( function ( ) {%NWL%methodReset ( vars )%NWL%if ( vars . types [ vars . type . value ] . zoom && vars . zoom . value )  {%NWL%vars . g . zoom%NWL%. datum ( vars )%NWL%. call ( vars . zoom . behavior . on ( " zoom " , mouse ) )%NWL%vars . g . zoom%NWL%7
. call ( vars . zoom . behavior . on ( " zoom " , mouse ) )%NWL%if ( !vars . zoom . scroll . value )  {%NWL%vars . g . zoom%NWL%. on ( " mousewheel . zoom " , null )%NWL%. on ( " MozMousePixelScroll . zoom " , null )%NWL%. on ( " wheel . zoom " , null )%NWL%}%NWL%if ( !vars . zoom . click . value )  {%NWL%vars . g . zoom . on ( " dblclick . zoom " , null )%NWL%}%NWL%vars . g . zoom%NWL%2
}%NWL%if ( !vars . zoom . click . value )  {%NWL%vars . g . zoom . on ( " dblclick . zoom " , null )%NWL%}%NWL%if ( !vars . zoom . pan . value )  {%NWL%vars . g . zoom%NWL%. on ( " mousedown . zoom " , null )%NWL%. on ( " mousemove . zoom " , null )%NWL%}%NWL%}%NWL%vars . g . zoom%NWL%5
vars . g . edge_focus%NWL%. selectAll ( " g " )%NWL%. remove ( )%NWL%vars . g . data_focus%NWL%. selectAll ( " g " )%NWL%. remove ( )%NWL%if ( vars . focus . value . length && vars . types [ vars . type . value ] . zoom && vars . zoom . value )  {%NWL%if ( vars . dev . value ) print . time ( " drawing focus elements " )%NWL%var edges = vars . g . edges . selectAll ( " g " )%NWL%if ( edges . size ( ) > 0 )  {%NWL%var source = l [ vars . edges . source ] [ vars . id . value ] ,%NWL%8
var direction = vars . edges . arrows . direction . value%NWL%if ( " bucket " in e . d3plus )  {%NWL%var d = " _ " + e . d3plus . bucket%NWL%}%NWL%else {%NWL%var d = " "%NWL%}%NWL%return direction == " source " && marker%NWL%? " url ( #d3plus_edge_marker_focus " + d + " ) " : " none "%NWL%} )%NWL%var direction = vars . edges . arrows . direction . value%NWL%0
}%NWL%} ) ;%NWL%} ;%NWL%d3 . csv . parseRows = function ( text , f )  {%NWL%var EOL = { } ,  / / sentinel value for end - of - line%NWL%EOF = { } ,  / / sentinel value for end - of - file%NWL%rows = [ ] ,  / / output rows%NWL%re = / \r\n| [ , \r\n ] / g ,  / / field separator regex%NWL%n = 0 ,  / / the current line number%NWL%t ,  / / the current token%NWL%re . lastIndex = 0; / / work - around bug in FF 3 . 6%NWL%7
lower48 . scale ( x ) ;%NWL%alaska . scale ( x *  . 6 ) ;%NWL%hawaii . scale ( x ) ;%NWL%puertoRico . scale ( x * 1 . 5 ) ;%NWL%return albersUsa . translate ( lower48 . translate ( ) ) ;%NWL%} ;%NWL%albersUsa . translate = function ( x )  {%NWL%if ( !arguments . length ) return lower48 . translate ( ) ;%NWL%var dz = lower48 . scale ( )  / 1000 ,%NWL%dx = x [ 0 ] ,%NWL%lower48 . translate ( x ) ;%NWL%0
}%NWL%function d3_geo_boundsMultiLineString ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%for ( var b = a [ i ] , j = 0 , m = b . length; j < m; j + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%}%NWL%}%NWL%}%NWL%function d3_geo_boundsMultiPolygon ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%4
}%NWL%}%NWL%return [ d ] ;%NWL%} )%NWL%if ( vars . draw . timing )  {%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. attr ( " d " , function ( d ) { return area ( d . values )  } )%NWL%. call ( shapeStyle , vars )%NWL%}%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%5
}%NWL%circle . clip = function ( d )  {%NWL%arc . source ( typeof origin === " function " ? origin . apply ( this , arguments ) : origin ) ;%NWL%return clipType ( d ) ;%NWL%} ;%NWL%var clipType = d3_geo_type ( {%NWL%FeatureCollection: function ( o )  {%NWL%var features = o . features . map ( clipType ) . filter ( Object ) ;%NWL%return features && ( o = Object . create ( o ) , o . features = features , o ) ;%NWL%} ,%NWL%var geometry = clipType ( o . geometry ) ;%NWL%7
var features = o . features . map ( clipType ) . filter ( Object ) ;%NWL%return features && ( o = Object . create ( o ) , o . features = features , o ) ;%NWL%} ,%NWL%Feature: function ( o )  {%NWL%var geometry = clipType ( o . geometry ) ;%NWL%return geometry && ( o = Object . create ( o ) , o . geometry = geometry , o ) ;%NWL%} ,%NWL%Point: function ( o )  {%NWL%return visible ( o . coordinates ) && o;%NWL%} ,%NWL%var coordinates = o . coordinates . filter ( visible ) ;%NWL%0
Point: function ( o )  {%NWL%return visible ( o . coordinates ) && o;%NWL%} ,%NWL%MultiPoint: function ( o )  {%NWL%var coordinates = o . coordinates . filter ( visible ) ;%NWL%return coordinates . length && {%NWL%type: o . type ,%NWL%coordinates: coordinates%NWL%} ;%NWL%} ,%NWL%var coordinates = clip ( o . coordinates ) ;%NWL%4
} ;%NWL%} ,%NWL%LineString: function ( o )  {%NWL%var coordinates = clip ( o . coordinates ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%MultiLineString: function ( o )  {%NWL%var coordinates = o . coordinates . map ( clip ) . filter ( function ( d )  { return d . length; } ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%var coordinates = o . coordinates . map ( clip ) ;%NWL%3
return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%Polygon: function ( o )  {%NWL%var coordinates = o . coordinates . map ( clip ) ;%NWL%return coordinates [ 0 ] . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%MultiPolygon: function ( o )  {%NWL%var coordinates = o . coordinates . map ( function ( d )  { return d . map ( clip ) ; } ) . filter ( function ( d )  { return d [ 0 ] . length; } ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%var geometries = o . geometries . map ( clipType ) . filter ( Object ) ;%NWL%3
} )%NWL%}%NWL%enter . append ( " path " ) . attr ( " class " , " d3plus_data " )%NWL%. attr ( " d " ,  " M5 - 6 . 844L3 . 594 - 5 . 407L - 2 , 0 . 188l - 1 . 594 - 1 . 594L - 5 - 2 . 844L - 7 . 844 , 0l1 . 438 , 1 . 406l3 , 3L - 2 , 5 . 843l1 . 406 - 1 . 438l7 - 7L7 . 844 - 4L5 - 6 . 844z " )%NWL%. call ( init )%NWL%. call ( shapeStyle , vars )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%6
selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%if ( vars . draw . timing )  {%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. call ( update )%NWL%. call ( shapeStyle , vars )%NWL%}%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%0
b = coordinates [ i ] ;%NWL%c = input [ ( m = input . length )  - 1 ] ;%NWL%j = - 1;%NWL%while ( + + j < m )  {%NWL%d = input [ j ] ;%NWL%if ( d3_geom_polygonInside ( d , a , b ) )  {%NWL%if ( !d3_geom_polygonInside ( c , a , b ) )  {%NWL%subject . push ( d3_geom_polygonIntersect ( c , d , a , b ) ) ;%NWL%}%NWL%subject . push ( d ) ;%NWL%subject . push ( d3_geom_polygonIntersect ( c , d , a , b ) ) ;%NWL%7
}%NWL%return points;%NWL%}%NWL%function d3_layout_bundleAncestors ( node )  {%NWL%var ancestors = [ ] ,%NWL%parent = node . parent;%NWL%while ( parent != null )  {%NWL%ancestors . push ( node ) ;%NWL%node = parent;%NWL%parent = parent . parent;%NWL%ancestors . push ( node ) ;%NWL%7
} else {%NWL%node . x = previousNode ? x + = separation ( node , previousNode ) : 0;%NWL%node . y = 0;%NWL%previousNode = node;%NWL%}%NWL%} ) ;%NWL%var left = d3_layout_clusterLeft ( root ) ,%NWL%right = d3_layout_clusterRight ( root ) ,%NWL%x0 = left . x - separation ( left , right )  / 2 ,%NWL%x1 = right . x + separation ( right , left )  / 2;%NWL%node . x = ( node . x - x0 )  /  ( x1 - x0 )  * size [ 0 ] ;%NWL%1
node . x = previousNode ? x + = separation ( node , previousNode ) : 0;%NWL%node . y = 0;%NWL%previousNode = node;%NWL%}%NWL%} ) ;%NWL%var left = d3_layout_clusterLeft ( root ) ,%NWL%right = d3_layout_clusterRight ( root ) ,%NWL%x0 = left . x - separation ( left , right )  / 2 ,%NWL%x1 = right . x + separation ( right , left )  / 2;%NWL%d3_layout_treeVisitAfter ( root , function ( node )  {%NWL%node . y = ( 1 - node . y / root . y )  * size [ 1 ] ;%NWL%0
return d3 . scale . pow ( ) . exponent ( 2 ) ( smaller_dim / 2 ) ;%NWL%} ) )%NWL%}%NWL%enter . append ( " path " ) . attr ( " class " , " d3plus_data " )%NWL%. call ( init )%NWL%. call ( shapeStyle , vars )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%6
selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%if ( vars . draw . timing )  {%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. call ( update )%NWL%. call ( shapeStyle , vars )%NWL%}%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%0
dy = b . y - a . y;%NWL%if ( db && ( dx || dy ) )  {%NWL%var da = b . r + c . r ,%NWL%dc = Math . sqrt ( dx * dx + dy * dy ) ,%NWL%cos = Math . max ( - 1 , Math . min ( 1 ,  ( db * db + dc * dc - da * da )  /  ( 2 * db * dc ) ) ) ,%NWL%theta = Math . acos ( cos ) ,%NWL%x = cos *  ( db / = dc ) ,%NWL%y = Math . sin ( theta )  * db;%NWL%c . x = a . x + x * dx + y * dy;%NWL%c . y = a . y + x * dy - y * dx;%NWL%c . x = a . x + db;%NWL%8
if ( db && ( dx || dy ) )  {%NWL%var da = b . r + c . r ,%NWL%dc = Math . sqrt ( dx * dx + dy * dy ) ,%NWL%cos = Math . max ( - 1 , Math . min ( 1 ,  ( db * db + dc * dc - da * da )  /  ( 2 * db * dc ) ) ) ,%NWL%theta = Math . acos ( cos ) ,%NWL%x = cos *  ( db / = dc ) ,%NWL%y = Math . sin ( theta )  * db;%NWL%c . x = a . x + x * dx + y * dy;%NWL%c . y = a . y + x * dy - y * dx;%NWL%} else {%NWL%c . y = a . y;%NWL%7
d3 . layout . tree = function ( )  {%NWL%var hierarchy = d3 . layout . hierarchy ( ) . sort ( null ) . value ( null ) ,%NWL%separation = d3_layout_treeSeparation ,%NWL%size = [ 1 , 1 ] ; / / width , height%NWL%function tree ( d , i )  {%NWL%var nodes = hierarchy . call ( this , d , i ) ,%NWL%root = nodes [ 0 ] ;%NWL%var children = node . children ,%NWL%1
}%NWL%d3_layout_treeShift ( node ) ;%NWL%var midpoint = . 5 *  ( firstChild . _tree . prelim + child . _tree . prelim ) ;%NWL%if ( previousSibling )  {%NWL%layout . prelim = previousSibling . _tree . prelim + separation ( node , previousSibling ) ;%NWL%layout . mod = layout . prelim - midpoint;%NWL%} else {%NWL%layout . prelim = midpoint;%NWL%}%NWL%} else {%NWL%layout . prelim = previousSibling . _tree . prelim + separation ( node , previousSibling ) ;%NWL%4
return d3 . scale . pow ( ) . exponent ( 2 ) ( smaller_dim / 2 ) ;%NWL%} ) )%NWL%}%NWL%enter . append ( " path " ) . attr ( " class " , " d3plus_data " )%NWL%. call ( init )%NWL%. call ( shapeStyle , vars )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%6
selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%if ( vars . draw . timing )  {%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. call ( update )%NWL%. call ( shapeStyle , vars )%NWL%}%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%0
ticks = [ ] ;%NWL%if ( extent . every ( isFinite ) )  {%NWL%var i = Math . floor ( extent [ 0 ] ) ,%NWL%j = Math . ceil ( extent [ 1 ] ) ,%NWL%u = pow ( extent [ 0 ] ) ,%NWL%v = pow ( extent [ 1 ] ) ;%NWL%if ( log === d3_scale_logn )  {%NWL%ticks . push ( pow ( i ) ) ;%NWL%for ( ; i + + < j; ) for ( var k = 9; k > 0; k - - ) ticks . push ( pow ( i )  * k ) ;%NWL%} else {%NWL%ticks . push ( pow ( i ) ) ;%NWL%7
d = ( ticks [ 1 ]  - ticks [ 0 ] )  /  + + m ,%NWL%j ,%NWL%v;%NWL%while ( + + i < n )  {%NWL%for ( j = m; - - j > 0; )  {%NWL%if ( ( v = + ticks [ i ]  - j * d ) >= extent [ 0 ] )  {%NWL%subticks . push ( v ) ;%NWL%}%NWL%}%NWL%}%NWL%subticks . push ( v ) ;%NWL%6
d . d3plus . id + = shape;%NWL%[ " x " ,  " y " ,  " x2 " ,  " y2 " ] . forEach ( function ( axis ) {%NWL%if ( vars [ axis ] . scale . value == " discrete " )  {%NWL%var val = fetchValue ( vars , d , vars [ axis ] . value )%NWL%if ( val . constructor === Date ) val = val . getTime ( )%NWL%d . d3plus . id + = " _ " + val%NWL%}%NWL%} )%NWL%if ( d . d3plus . suffix )  {%NWL%d . d3plus . id + = " _ "  + d . d3plus . suffix;%NWL%d . d3plus . id = stringStrip ( d . d3plus . id )%NWL%9
if ( total )  {%NWL%if ( active )  {%NWL%d . d3plus . segments . active = ( active / total )  *  ( Math . PI * 2 )%NWL%}%NWL%else {%NWL%d . d3plus . segments . active = 0%NWL%}%NWL%if ( temp )  {%NWL%d . d3plus . segments . temp = ( ( temp / total )  *  ( Math . PI * 2 ) )  + d . d3plus . segments . active%NWL%}%NWL%d . d3plus . segments . temp = 0%NWL%8
}%NWL%}%NWL%return d . d3plus ? d . d3plus . id : false;%NWL%} )%NWL%if ( vars . draw . timing )  {%NWL%var exit = selection . exit ( )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. attr ( " opacity " , 0 )%NWL%. remove ( )%NWL%}%NWL%var exit = selection . exit ( )%NWL%5
var direction = vars . edges . arrows . direction . value%NWL%if ( " bucket " in e . d3plus )  {%NWL%var d = " _ " + e . d3plus . bucket%NWL%}%NWL%else {%NWL%var d = " "%NWL%}%NWL%return direction == " source " && marker%NWL%? " url ( #d3plus_edge_marker_highlight " + d + " ) " : " none "%NWL%} )%NWL%var direction = vars . edges . arrows . direction . value%NWL%0
vars . g . edge_hover . selectAll ( " text " )%NWL%. style ( " fill " , vars . color . primary )%NWL%if ( vars . draw . timing )  {%NWL%vars . g . edge_hover%NWL%. transition ( ) . duration ( vars . timing . mouseevents )%NWL%. attr ( " opacity " , 1 )%NWL%vars . g . edges%NWL%. transition ( ) . duration ( vars . timing . mouseevents )%NWL%. attr ( " opacity " , 0 . 5 )%NWL%}%NWL%vars . g . edge_hover%NWL%3
vars . g . edges%NWL%. transition ( ) . duration ( vars . timing . mouseevents )%NWL%. attr ( " opacity " , 0 . 5 )%NWL%}%NWL%else {%NWL%vars . g . edge_hover%NWL%. attr ( " opacity " , 1 )%NWL%}%NWL%}%NWL%else {%NWL%vars . g . edge_hover%NWL%5
vars . g . edge_hover%NWL%. transition ( ) . duration ( vars . timing . mouseevents )%NWL%. attr ( " opacity " , 0 )%NWL%. transition ( )%NWL%. selectAll ( " * " )%NWL%. remove ( )%NWL%vars . g . edges%NWL%. transition ( ) . duration ( vars . timing . mouseevents )%NWL%. attr ( " opacity " , 1 )%NWL%}%NWL%vars . g . edge_hover%NWL%0
var mouseEvent = function ( )  {%NWL%touchEvent ( vars , d3 . event )%NWL%}%NWL%vars . g . data . selectAll ( " g " )%NWL%. on ( events . over , mouseEvent )%NWL%. on ( events . move , mouseEvent )%NWL%. on ( events . out , mouseEvent )%NWL%}%NWL%d3 . select ( window ) . on ( " scroll . d3plus " , function ( ) {%NWL%removeTooltip ( vars . type . value ) ;%NWL%vars . g . data . selectAll ( " g " )%NWL%3
var buckets = require ( " . . / . . / . . / util / buckets . coffee " ) ,%NWL%offset = require ( " . . / . . / . . / geom / offset . coffee " ) ;%NWL%var edges = vars . returned . edges || [ ] ,%NWL%0
var direction = vars . edges . arrows . direction . value;%NWL%if ( " bucket " in e . d3plus )  {%NWL%var d = " _ " + e . d3plus . bucket;%NWL%}%NWL%else {%NWL%var d = " " ;%NWL%}%NWL%return direction == " source " && marker%NWL%? " url ( #d3plus_edge_marker_default " + d + " ) " : " none "%NWL%} )%NWL%var direction = vars . edges . arrows . direction . value%NWL%0
if ( l . d3plus . spline !== true )  {%NWL%if ( strokeBuckets )  {%NWL%var size = l [ vars . edges . size . value ]%NWL%l . d3plus . bucket = size < strokeBuckets [ 1 ] ? 0%NWL%: size < strokeBuckets [ 2 ] ? 1 : 2%NWL%var marker = markerSize [ l . d3plus . bucket ] * . 85 / scale%NWL%}%NWL%else {%NWL%delete l . d3plus . bucket%NWL%var marker = markerSize * . 85 / scale%NWL%var source = l [ vars . edges . source ]%NWL%2
if ( l . d3plus . spline )  {%NWL%if ( strokeBuckets )  {%NWL%var size = l [ vars . edges . size . value ]%NWL%l . d3plus . bucket = size < strokeBuckets [ 1 ] ? 0%NWL%: size < strokeBuckets [ 2 ] ? 1 : 2%NWL%var marker = markerSize [ l . d3plus . bucket ] * . 85 / scale%NWL%}%NWL%else {%NWL%delete l . d3plus . bucket%NWL%var marker = markerSize * . 85 / scale%NWL%var source = l [ vars . edges . source ]%NWL%2
d3 . time . seconds = d3_time_range ( d3 . time . second , function ( date )  {%NWL%date . setTime ( date . getTime ( )  + 1e3 ) ;%NWL%} , function ( date )  {%NWL%return date . getSeconds ( ) ;%NWL%d3 . time . seconds . utc = d3 . time . seconds;%NWL%0
var fill_data = [ ] , hatch_data = [ ] ;%NWL%if ( total && vars . types [ vars . type . value ] . fill )  {%NWL%if ( temp )  {%NWL%var c = copy ( d ) ;%NWL%c . d3plus . shape = " temp " ;%NWL%fill_data . push ( c ) ;%NWL%hatch_data = [ " temp " ] ;%NWL%}%NWL%if ( active && ( active < total || temp ) )  {%NWL%var c = copy ( d ) ;%NWL%fill_data . push ( c ) ;%NWL%5
. attr ( " y " , " 0 " )%NWL%. attr ( " width " , " 10 " )%NWL%. attr ( " height " , " 10 " )%NWL%. attr ( " fill " , color )%NWL%. attr ( " fill - opacity " , 0 . 25 ) ;%NWL%pattern_enter . append ( " line " )%NWL%. attr ( " x1 " , " 0 " )%NWL%. attr ( " x2 " , " 10 " )%NWL%. attr ( " y1 " , " 0 " )%NWL%. attr ( " y2 " , " 10 " )%NWL%pattern_enter . append ( " line " )%NWL%5
. attr ( " x1 " , " 0 " )%NWL%. attr ( " x2 " , " 10 " )%NWL%. attr ( " y1 " , " 0 " )%NWL%. attr ( " y2 " , " 10 " )%NWL%. call ( hatch_lines ) ;%NWL%pattern_enter . append ( " line " )%NWL%. attr ( " x1 " , " - 1 " )%NWL%. attr ( " x2 " , " 1 " )%NWL%. attr ( " y1 " , " 9 " )%NWL%. attr ( " y2 " , " 11 " )%NWL%pattern_enter . append ( " line " )%NWL%5
else if ( d && " d3plus " in d )  {%NWL%var active = segments ( vars , d ,  " active " ) ,%NWL%temp  = segments ( vars , d ,  " temp " ) ,%NWL%total = segments ( vars , d ,  " total " ) ,%NWL%background = ( !temp && !active ) || ( active >= total ) || ( !active && temp >= total ) ;%NWL%}%NWL%}%NWL%if ( !disabled && ( ( label && label . force ) || background || !fill ) )  {%NWL%if ( share && d . d3plus . share && share . w - vars . labels . padding * 2 >= 10 && share . h - vars . labels . padding * 2 >= 10 && vars . labels . valign . value != " middle " )  {%NWL%share . resize = vars . labels . resize . value === false ? false :%NWL%share . padding = vars . labels . padding;%NWL%9
var active = segments ( vars , d ,  " active " ) ,%NWL%temp  = segments ( vars , d ,  " temp " ) ,%NWL%total = segments ( vars , d ,  " total " ) ,%NWL%background = ( !temp && !active ) || ( active >= total ) || ( !active && temp >= total ) ;%NWL%}%NWL%}%NWL%if ( !disabled && ( ( label && label . force ) || background || !fill ) )  {%NWL%if ( share && d . d3plus . share && share . w - vars . labels . padding * 2 >= 10 && share . h - vars . labels . padding * 2 >= 10 && vars . labels . valign . value != " middle " )  {%NWL%share . resize = vars . labels . resize . value === false ? false :%NWL%share && " resize " in share ? share . resize : true;%NWL%share . text = d . d3plus . share;%NWL%8
}%NWL%share_size = text . node ( ) . getBBox ( ) . height + vars . labels . padding;%NWL%text . exit ( ) . call ( remove ) ;%NWL%}%NWL%else {%NWL%group . selectAll ( " text . d3plus_share " )%NWL%. call ( remove ) ;%NWL%}%NWL%if ( label )  {%NWL%label . resize = vars . labels . resize . value === false ? false :%NWL%label . padding = typeof label . padding === " number " ? label . padding : vars . labels . padding;%NWL%9
. call ( bg_style ) ;%NWL%bg . enter ( ) . insert ( " rect " , " . d3plus_label " )%NWL%. attr ( " id " , " d3plus_label_bg_ " + d . d3plus . id )%NWL%. attr ( " class " , " d3plus_label_bg " )%NWL%. attr ( " opacity " , 0 )%NWL%. call ( bg_style )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. attr ( " opacity " , bg_opacity ) ;%NWL%}%NWL%else {%NWL%bg . enter ( ) . insert ( " rect " , " . d3plus_label " )%NWL%1
}%NWL%else {%NWL%delete d . d3plus_label;%NWL%d3 . select ( this ) . selectAll ( " text#d3plus_label_ " + d . d3plus . id + " , rect#d3plus_label_bg_ " + d . d3plus . id )%NWL%. call ( remove ) ;%NWL%vars . g . labels . selectAll ( " text#d3plus_label_ " + d . d3plus . id + " , rect#d3plus_label_bg_ " + d . d3plus . id )%NWL%. call ( remove ) ;%NWL%}%NWL%}%NWL%else {%NWL%d3 . select ( this ) . selectAll ( " text#d3plus_label_ " + d . d3plus . id + " , rect#d3plus_label_bg_ " + d . d3plus . id )%NWL%3
delete d . d3plus_label;%NWL%d3 . select ( this ) . selectAll ( " text#d3plus_label_ " + d . d3plus . id + " , rect#d3plus_label_bg_ " + d . d3plus . id )%NWL%. call ( remove ) ;%NWL%vars . g . labels . selectAll ( " text#d3plus_label_ " + d . d3plus . id + " , rect#d3plus_label_bg_ " + d . d3plus . id )%NWL%. call ( remove ) ;%NWL%}%NWL%}%NWL%else {%NWL%delete d . d3plus_label;%NWL%d3 . select ( this ) . selectAll ( " text#d3plus_label_ " + d . d3plus . id + " , rect#d3plus_label_bg_ " + d . d3plus . id )%NWL%vars . g . labels . selectAll ( " text#d3plus_label_ " + d . d3plus . id + " , rect#d3plus_label_bg_ " + d . d3plus . id )%NWL%3
topic: function ( )  {%NWL%return d3 . bisectLeft;%NWL%} ,%NWL%" finds the index of an exact match " : function ( bisect )  {%NWL%var array = [ 1 , 2 , 3 ] ;%NWL%assert . equal ( bisect ( array , 1 ) , 0 ) ;%NWL%assert . equal ( bisect ( array , 2 ) , 1 ) ;%NWL%assert . equal ( bisect ( array , 3 ) , 2 ) ;%NWL%} ,%NWL%" finds the index of the first match " : function ( bisect )  {%NWL%assert . equal ( bisect ( array , 1 ) , 0 ) ;%NWL%5
return d3 . bisectLeft;%NWL%} ,%NWL%" finds the index of an exact match " : function ( bisect )  {%NWL%var array = [ 1 , 2 , 3 ] ;%NWL%assert . equal ( bisect ( array , 1 ) , 0 ) ;%NWL%assert . equal ( bisect ( array , 2 ) , 1 ) ;%NWL%assert . equal ( bisect ( array , 3 ) , 2 ) ;%NWL%} ,%NWL%" finds the index of the first match " : function ( bisect )  {%NWL%var array = [ 1 , 2 , 2 , 3 ] ;%NWL%assert . equal ( bisect ( array , 2 ) , 1 ) ;%NWL%5
topic: function ( )  {%NWL%return d3 . bisectRight;%NWL%} ,%NWL%" finds the index after an exact match " : function ( bisect )  {%NWL%var array = [ 1 , 2 , 3 ] ;%NWL%assert . equal ( bisect ( array , 1 ) , 1 ) ;%NWL%assert . equal ( bisect ( array , 2 ) , 2 ) ;%NWL%assert . equal ( bisect ( array , 3 ) , 3 ) ;%NWL%} ,%NWL%" finds the index after the last match " : function ( bisect )  {%NWL%assert . equal ( bisect ( array , 1 ) , 1 ) ;%NWL%5
suite . addBatch ( {%NWL%" dispatch " : {%NWL%topic: function ( )  {%NWL%return d3 . dispatch;%NWL%} ,%NWL%" returns a map of dispatchers for each event type " : function ( dispatch )  {%NWL%assert . deepEqual ( dispatch ( ) ,  { } ) ;%NWL%var d = dispatch ( " foo " ) ;%NWL%assert . isTrue ( " foo " in d ) ;%NWL%assert . isFalse ( " bar " in d ) ;%NWL%assert . isTrue ( " foo " in d ) ;%NWL%8
" dispatch " : {%NWL%topic: function ( )  {%NWL%return d3 . dispatch;%NWL%} ,%NWL%" returns a map of dispatchers for each event type " : function ( dispatch )  {%NWL%assert . deepEqual ( dispatch ( ) ,  { } ) ;%NWL%var d = dispatch ( " foo " ) ;%NWL%assert . isTrue ( " foo " in d ) ;%NWL%assert . isFalse ( " bar " in d ) ;%NWL%var d = dispatch ( " foo " ,  " bar " ) ;%NWL%assert . isTrue ( " bar " in d ) ;%NWL%8
assert . isTrue ( " foo " in d ) ;%NWL%assert . isFalse ( " bar " in d ) ;%NWL%var d = dispatch ( " foo " ,  " bar " ) ;%NWL%assert . isTrue ( " foo " in d ) ;%NWL%assert . isTrue ( " bar " in d ) ;%NWL%} ,%NWL%" added listeners receive subsequent events " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , events = 0;%NWL%d . on ( " foo " , function ( )  {  + + events; } ) ;%NWL%d . foo ( ) ;%NWL%d . foo ( ) ;%NWL%9
assert . isFalse ( " bar " in d ) ;%NWL%var d = dispatch ( " foo " ,  " bar " ) ;%NWL%assert . isTrue ( " foo " in d ) ;%NWL%assert . isTrue ( " bar " in d ) ;%NWL%} ,%NWL%" added listeners receive subsequent events " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , events = 0;%NWL%d . on ( " foo " , function ( )  {  + + events; } ) ;%NWL%d . foo ( ) ;%NWL%assert . equal ( events , 1 ) ;%NWL%d . foo ( ) ;%NWL%8
assert . equal ( that , b ) ;%NWL%} ,%NWL%" listeners are notified in the order they are added " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , a = { } , b = { } , those = [ ] ;%NWL%function A ( )  { those . push ( a ) ; }%NWL%function B ( )  { those . push ( b ) ; }%NWL%d . on ( " foo . a " , A ) . on ( " foo . b " , B ) ;%NWL%d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ a , b ] ) ;%NWL%those = [ ] ;%NWL%d . foo ( ) ;%NWL%7
assert . deepEqual ( those ,  [ a , b ] ) ;%NWL%those = [ ] ;%NWL%d . on ( " foo . a " , A ) ; / / move to the end%NWL%d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ b , a ] ) ;%NWL%} ,%NWL%" removed listeners do not receive subsequent events " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , a = { } , b = { } , those = [ ] ;%NWL%function A ( )  { those . push ( a ) ; }%NWL%function B ( )  { those . push ( b ) ; }%NWL%d . foo ( ) ;%NWL%3
d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ b , a ] ) ;%NWL%} ,%NWL%" removed listeners do not receive subsequent events " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , a = { } , b = { } , those = [ ] ;%NWL%function A ( )  { those . push ( a ) ; }%NWL%function B ( )  { those . push ( b ) ; }%NWL%d . on ( " foo . a " , A ) . on ( " foo . b " , B ) ;%NWL%d . foo ( ) ;%NWL%those = [ ] ;%NWL%d . foo ( ) ;%NWL%0
d . on ( " foo . a " , A ) . on ( " foo . b " , B ) ;%NWL%d . foo ( ) ;%NWL%those = [ ] ;%NWL%d . on ( " foo . a " , null ) ;%NWL%d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ b ] ) ;%NWL%} ,%NWL%" removing a shared listener only affects the intended event " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ,  " bar " ) , a = 0;%NWL%function A ( )  {  + + a; }%NWL%d . foo ( ) ;%NWL%1
d . foo ( ) ;%NWL%those = [ ] ;%NWL%d . on ( " foo . a " , null ) ;%NWL%d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ b ] ) ;%NWL%} ,%NWL%" removing a shared listener only affects the intended event " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ,  " bar " ) , a = 0;%NWL%function A ( )  {  + + a; }%NWL%d . on ( " foo " , A ) . on ( " bar " , A ) ;%NWL%d . bar ( ) ;%NWL%0
d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ b ] ) ;%NWL%} ,%NWL%" removing a shared listener only affects the intended event " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ,  " bar " ) , a = 0;%NWL%function A ( )  {  + + a; }%NWL%d . on ( " foo " , A ) . on ( " bar " , A ) ;%NWL%d . foo ( ) ;%NWL%d . bar ( ) ;%NWL%assert . equal ( a , 2 ) ;%NWL%d . bar ( ) ;%NWL%0
d . foo ( ) ;%NWL%d . bar ( ) ;%NWL%assert . equal ( a , 2 ) ;%NWL%d . on ( " foo " , null ) ;%NWL%d . bar ( ) ;%NWL%assert . equal ( a , 3 ) ;%NWL%} ,%NWL%" adding an existing listener has no effect " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , events = 0;%NWL%function A ( )  {  + + events; }%NWL%d . foo ( ) ;%NWL%0
assert . equal ( a , 2 ) ;%NWL%d . on ( " foo " , null ) ;%NWL%d . bar ( ) ;%NWL%assert . equal ( a , 3 ) ;%NWL%} ,%NWL%" adding an existing listener has no effect " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , events = 0;%NWL%function A ( )  {  + + events; }%NWL%d . on ( " foo . a " , A ) ;%NWL%d . foo ( ) ;%NWL%d . foo ( ) ;%NWL%2
function A ( )  {  + + events; }%NWL%d . on ( " foo . a " , A ) ;%NWL%d . foo ( ) ;%NWL%d . on ( " foo . a " , A ) . on ( " foo . a " , A ) ;%NWL%d . foo ( ) ;%NWL%assert . equal ( events , 2 ) ;%NWL%} ,%NWL%" removing a missing listener has no effect " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , events = 0;%NWL%function A ( )  {  + + events; }%NWL%d . foo ( ) ;%NWL%2
var d = dispatch ( " foo " ) , events = 0;%NWL%function A ( )  {  + + events; }%NWL%d . on ( " foo . a " , null ) . on ( " foo " , A ) . on ( " foo " , null ) . on ( " foo " , null ) ;%NWL%d . foo ( ) ;%NWL%assert . equal ( events , 0 ) ;%NWL%} ,%NWL%" adding a listener does not affect the current event " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , a = { } , b = { } , those = [ ] ;%NWL%function A ( )  { d . on ( " foo . b " , B ) ; those . push ( a ) ; }%NWL%function B ( )  { those . push ( b ) ; }%NWL%d . foo ( ) ;%NWL%3
function A ( )  { d . on ( " foo . b " , B ) ; those . push ( a ) ; }%NWL%function B ( )  { those . push ( b ) ; }%NWL%d . on ( " foo . a " , A ) ;%NWL%d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ a ] ) ;%NWL%} ,%NWL%" removing a listener does affect the current event " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , a = { } , b = { } , those = [ ] ;%NWL%function A ( )  { d . on ( " foo . b " , null ) ; those . push ( a ) ; }%NWL%function B ( )  { those . push ( b ) ; }%NWL%d . foo ( ) ;%NWL%3
function B ( )  { those . push ( b ) ; }%NWL%d . on ( " foo . a " , A ) ;%NWL%d . foo ( ) ;%NWL%assert . deepEqual ( those ,  [ a ] ) ;%NWL%} ,%NWL%" removing a listener does affect the current event " : function ( dispatch )  {%NWL%var d = dispatch ( " foo " ) , a = { } , b = { } , those = [ ] ;%NWL%function A ( )  { d . on ( " foo . b " , null ) ; those . push ( a ) ; }%NWL%function B ( )  { those . push ( b ) ; }%NWL%d . on ( " foo . a " , A ) . on ( " foo . b " , B ) ;%NWL%assert . deepEqual ( those ,  [ a ] ) ;%NWL%3
} ,%NWL%" supports linear easing " : function ( ease )  {%NWL%var e = ease ( " linear " ) ;%NWL%assert . inDelta ( e ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%} ,%NWL%" supports polynomial easing " : function ( ease )  {%NWL%var e = ease ( " poly " , 2 ) ;%NWL%assert . inDelta ( e ( . 5 ) ,  . 25 , 1e - 6 ) ;%NWL%} ,%NWL%" supports quadratic easing " : function ( ease )  {%NWL%assert . inDelta ( e ( . 5 ) ,  . 25 , 1e - 6 ) ;%NWL%7
var copy    = require ( " . . / . . / . . / util / copy . coffee " ) ,%NWL%closest  = require ( " . . / . . / . . / util / closest . coffee " ) ,%NWL%events   = require ( " . . / . . / . . / client / pointer . coffee " ) ,%NWL%shapeStyle = require ( " . / style . coffee " ) ,%NWL%fetchValue = require ( " . . / . . / . . / core / fetch / value . coffee " ) ;%NWL%var line = d3 . svg . line ( )%NWL%0
var copy    = require ( " . . / . . / . . / util / copy . coffee " ) ,%NWL%closest  = require ( " . . / . . / . . / util / closest . coffee " ) ,%NWL%events   = require ( " . . / . . / . . / client / pointer . coffee " ) ,%NWL%shapeStyle = require ( " . / style . coffee " ) ,%NWL%fetchValue = require ( " . . / . . / . . / core / fetch / value . coffee " ) ;%NWL%module . exports = function ( vars , selection , enter , exit )  {%NWL%var line = d3 . svg . line ( )%NWL%. x ( function ( d ) { return d . d3plus . x; } )%NWL%. y ( function ( d ) { return d . d3plus . y; } )%NWL%var stroke = vars . size . value || vars . data . stroke . width ,%NWL%0
if ( temp . values . length > 1 )  {%NWL%segments . push ( temp ) ;%NWL%}%NWL%else {%NWL%nodes . push ( temp . values [ 0 ] ) ;%NWL%}%NWL%temp = copy ( d ) ;%NWL%temp . values = [ v ] ;%NWL%}%NWL%if ( i === arr . length - 1 )  {%NWL%segments . push ( temp ) ;%NWL%1
else {%NWL%nodes . push ( temp . values [ 0 ] ) ;%NWL%}%NWL%temp = copy ( d ) ;%NWL%temp . values = [ v ] ;%NWL%}%NWL%if ( i === arr . length - 1 )  {%NWL%if ( temp . values . length > 1 )  {%NWL%segments . push ( temp ) ;%NWL%}%NWL%nodes . push ( temp . values [ 0 ] ) ;%NWL%1
assert . equal ( interpolate ( d3 . rgb ( " steelblue " ) ,  " #f00 " ) ( . 2 ) ,  " #6b6890 " ) ;%NWL%assert . equal ( interpolate ( " steelblue " , d3 . rgb ( 255 , 0 , 0 ) ) ( . 6 ) ,  " #b53448 " ) ;%NWL%} ,%NWL%" parses d3 . hsl input " : function ( interpolate )  {%NWL%assert . equal ( interpolate ( d3 . hsl ( " steelblue " ) ,  " #f00 " ) ( . 2 ) ,  " #6b6890 " ) ;%NWL%assert . equal ( interpolate ( " steelblue " , d3 . hsl ( 0 , 1 ,  . 5 ) ) ( . 6 ) ,  " #b53448 " ) ;%NWL%} ,%NWL%" interpolates in RGB color space " : function ( interpolate )  {%NWL%assert . equal ( interpolate ( " steelblue " ,  " #f00 " ) ( . 2 ) ,  " #6b6890 " ) ;%NWL%} ,%NWL%assert . equal ( interpolate ( " steelblue " ,  " #f00 " ) ( . 2 ) ,  " #6b6890 " ) ;%NWL%8
assert . equal ( interpolate ( d3 . hsl ( " steelblue " ) ,  " #f00 " ) ( . 2 ) ,  " #38c3a2 " ) ;%NWL%assert . equal ( interpolate ( " steelblue " , d3 . hsl ( 0 , 1 ,  . 5 ) ) ( . 6 ) ,  " #96e11c " ) ;%NWL%} ,%NWL%" parses d3 . rgb input " : function ( interpolate )  {%NWL%assert . equal ( interpolate ( d3 . rgb ( " steelblue " ) ,  " #f00 " ) ( . 2 ) ,  " #38c3a2 " ) ;%NWL%assert . equal ( interpolate ( " steelblue " , d3 . rgb ( 255 , 0 , 0 ) ) ( . 6 ) ,  " #96e11c " ) ;%NWL%} ,%NWL%" interpolates in HSL color space " : function ( interpolate )  {%NWL%assert . equal ( interpolate ( " steelblue " ,  " #f00 " ) ( . 2 ) ,  " #38c3a2 " ) ;%NWL%} ,%NWL%assert . equal ( interpolate ( " steelblue " ,  " #f00 " ) ( . 2 ) ,  " #38c3a2 " ) ;%NWL%8
. entries ( [ { foo: 1 , bar: 2 } ,  { foo: 1 , bar: 0 } ,  { foo: 1 , bar: 1 } ,  { foo: 2 } ] ) ;%NWL%assert . deepEqual ( entries ,  [%NWL%{ key: " 1 " , values: [ { foo: 1 , bar: 0 } ,  { foo: 1 , bar: 1 } ,  { foo: 1 , bar: 2 } ] } ,%NWL%{ key: " 2 " , values: [ { foo: 2 } ] }%NWL%] ) ;%NWL%} ,%NWL%" values can be aggregated using an optional rollup " : function ( nest )  {%NWL%var entries = nest ( )%NWL%. key ( function ( d )  { return d . foo; } )%NWL%. rollup ( function ( values )  { return d3 . sum ( values , function ( d )  { return d . bar; } ) ; } )%NWL%assert . deepEqual ( entries ,  [%NWL%1
. entries ( [ { foo: 1 , bar: 2 } ,  { foo: 1 , bar: 0 } ,  { foo: 1 , bar: 1 } ,  { foo: 2 } ] ) ;%NWL%assert . deepEqual ( entries ,  [%NWL%{ key: " 1 " , values: 3 } ,%NWL%{ key: " 2 " , values: 0 }%NWL%] ) ;%NWL%} ,%NWL%" multiple key functions can be specified " : function ( nest )  {%NWL%var entries = nest ( )%NWL%. key ( function ( d )  { return d [ 0 ] ; } ) . sortKeys ( d3 . ascending )%NWL%. key ( function ( d )  { return d [ 1 ] ; } ) . sortKeys ( d3 . ascending )%NWL%assert . deepEqual ( entries ,  [%NWL%1
var name = d3 . ns . qualify ( " svg:path " ) ;%NWL%assert . equal ( name . space ,  " http: / / www . w3 . org / 2000 / svg " ) ;%NWL%assert . equal ( name . local ,  " path " ) ;%NWL%} ,%NWL%" unknown qualified name returns undefined and local " : function ( )  {%NWL%var name = d3 . ns . qualify ( " foo:bar " ) ;%NWL%assert . isUndefined ( name . space ) ;%NWL%assert . equal ( name . local ,  " bar " ) ;%NWL%} ,%NWL%" known local name returns space and local " : function ( )  {%NWL%assert . equal ( name . space ,  " http: / / www . w3 . org / 2000 / svg " ) ;%NWL%1
assert . equal ( quantile ( [ 4 , 3 , 2 , 1 ] , 0 ) , 4 ) ;%NWL%assert . equal ( quantile ( [ 4 , 3 , 2 , 1 ] , 1 ) , 1 ) ;%NWL%} ,%NWL%" uses the R - 7 algorithm " : function ( quantile )  {%NWL%var data = [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ;%NWL%assert . equal ( quantile ( data , 0 ) , 3 ) ;%NWL%assert . equal ( quantile ( data ,  . 25 ) , 7 . 25 ) ;%NWL%assert . equal ( quantile ( data ,  . 5 ) , 9 ) ;%NWL%assert . equal ( quantile ( data ,  . 75 ) , 14 . 5 ) ;%NWL%assert . equal ( quantile ( data , 1 ) , 20 ) ;%NWL%assert . equal ( quantile ( data , 0 ) , 3 ) ;%NWL%5
} ,%NWL%" uses the R - 7 algorithm " : function ( quantile )  {%NWL%var data = [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ;%NWL%assert . equal ( quantile ( data , 0 ) , 3 ) ;%NWL%assert . equal ( quantile ( data ,  . 25 ) , 7 . 25 ) ;%NWL%assert . equal ( quantile ( data ,  . 5 ) , 9 ) ;%NWL%assert . equal ( quantile ( data ,  . 75 ) , 14 . 5 ) ;%NWL%assert . equal ( quantile ( data , 1 ) , 20 ) ;%NWL%var data = [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ;%NWL%assert . equal ( quantile ( data , 0 ) , 3 ) ;%NWL%assert . equal ( quantile ( data ,  . 5 ) , 9 ) ;%NWL%5
var data = [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ;%NWL%assert . equal ( quantile ( data , 0 ) , 3 ) ;%NWL%assert . equal ( quantile ( data ,  . 25 ) , 7 . 25 ) ;%NWL%assert . equal ( quantile ( data ,  . 5 ) , 9 ) ;%NWL%assert . equal ( quantile ( data ,  . 75 ) , 14 . 5 ) ;%NWL%assert . equal ( quantile ( data , 1 ) , 20 ) ;%NWL%var data = [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ;%NWL%assert . equal ( quantile ( data , 0 ) , 3 ) ;%NWL%assert . equal ( quantile ( data ,  . 25 ) , 7 . 5 ) ;%NWL%assert . equal ( quantile ( data ,  . 5 ) , 9 ) ;%NWL%assert . equal ( quantile ( data , 1 ) , 20 ) ;%NWL%5
} ,%NWL%" exposes r , g and b properties " : function ( rgb )  {%NWL%var color = rgb ( " #abc " ) ;%NWL%assert . equal ( color . r , 170 ) ;%NWL%assert . equal ( color . g , 187 ) ;%NWL%assert . equal ( color . b , 204 ) ;%NWL%} ,%NWL%" changing r , g or b affects the string format " : function ( rgb )  {%NWL%var color = rgb ( " #abc " ) ;%NWL%color . r + + ;%NWL%color . b + + ;%NWL%9
return d3 . scale . pow ( ) . exponent ( 2 ) ( smaller_dim / 2 ) ;%NWL%} ) )%NWL%}%NWL%enter . append ( " path " ) . attr ( " class " , " d3plus_data " )%NWL%. call ( init )%NWL%. call ( shapeStyle , vars )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%6
selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%if ( vars . draw . timing )  {%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. call ( update )%NWL%. call ( shapeStyle , vars )%NWL%}%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%0
require ( " . . / env " ) ;%NWL%require ( " . . / . . / d3 " ) ;%NWL%var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . select " ) ;%NWL%suite . addBatch ( {%NWL%" select " : {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%2
assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . select " ) ;%NWL%suite . addBatch ( {%NWL%" select " : {%NWL%topic: function ( )  {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%body . append ( " span " ) . attr ( " class " ,  " f00 " ) . attr ( " id " ,  " b4r " ) . attr ( " name " ,  " b4z " ) ;%NWL%body . append ( " div " ) . attr ( " class " ,  " foo " ) . attr ( " id " ,  " bar " ) . attr ( " name " ,  " baz " ) ;%NWL%return body;%NWL%} ,%NWL%var div = d3 . select ( " div " ) ;%NWL%5
require ( " . . / env " ) ;%NWL%require ( " . . / . . / d3 " ) ;%NWL%var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . selectAll " ) ;%NWL%suite . addBatch ( {%NWL%" selectAll " : {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%2
assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . selectAll " ) ;%NWL%suite . addBatch ( {%NWL%" selectAll " : {%NWL%topic: function ( )  {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%body . append ( " span " ) . attr ( " class " ,  " f00 " ) . attr ( " id " ,  " b4r " ) . attr ( " name " ,  " b4z " ) ;%NWL%body . append ( " div " ) . attr ( " class " ,  " foo " ) . attr ( " id " ,  " bar " ) . attr ( " name " ,  " baz " ) ;%NWL%return body;%NWL%} ,%NWL%var div = d3 . selectAll ( " div " ) ;%NWL%5
} ,%NWL%" gets a namespaced attribute value " : function ( body )  {%NWL%document . body . setAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ,  " bar " ) ;%NWL%assert . equal ( body . attr ( " xlink:foo " ) ,  " bar " ) ;%NWL%} ,%NWL%" removes an attribute as null " : function ( body )  {%NWL%body . attr ( " bgcolor " ,  " red " ) . attr ( " bgcolor " , null ) ;%NWL%assert . equal ( body . attr ( " bgcolor " ) ,  " " ) ;%NWL%} ,%NWL%" removes an attribute as a function " : function ( body )  {%NWL%assert . equal ( body . attr ( " bgcolor " ) ,  " " ) ;%NWL%7
} ,%NWL%" removes an attribute as null " : function ( body )  {%NWL%body . attr ( " bgcolor " ,  " red " ) . attr ( " bgcolor " , null ) ;%NWL%assert . equal ( body . attr ( " bgcolor " ) ,  " " ) ;%NWL%} ,%NWL%" removes an attribute as a function " : function ( body )  {%NWL%body . attr ( " bgcolor " ,  " red " ) . attr ( " bgcolor " , function ( )  { return null; } ) ;%NWL%assert . equal ( body . attr ( " bgcolor " ) ,  " " ) ;%NWL%} ,%NWL%" removes a namespaced attribute as null " : function ( body )  {%NWL%assert . equal ( body . attr ( " bgcolor " ) ,  " " ) ;%NWL%3
" gets a namespaced attribute value " : function ( div )  {%NWL%div [ 0 ] [ 0 ] . setAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ,  " bar " ) ;%NWL%assert . equal ( div . attr ( " xlink:foo " ) ,  " bar " ) ;%NWL%} ,%NWL%" removes an attribute as null " : function ( div )  {%NWL%div . attr ( " href " ,  " url " ) . attr ( " href " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%} ,%NWL%" removes an attribute as a function " : function ( div )  {%NWL%assert . equal ( div [ 0 ] [ 0 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%6
div [ 0 ] [ 0 ] . setAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ,  " bar " ) ;%NWL%assert . equal ( div . attr ( " xlink:foo " ) ,  " bar " ) ;%NWL%} ,%NWL%" removes an attribute as null " : function ( div )  {%NWL%div . attr ( " href " ,  " url " ) . attr ( " href " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%} ,%NWL%" removes an attribute as a function " : function ( div )  {%NWL%div . attr ( " href " ,  " url " ) . attr ( " href " , function ( )  { return null; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%6
div . attr ( " href " ,  " url " ) . attr ( " href " , function ( )  { return null; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%} ,%NWL%" removes a namespaced attribute as null " : function ( div )  {%NWL%div . attr ( " xlink:foo " ,  " bar " ) . attr ( " xlink:foo " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . getAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ) ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ) ,  " " ) ;%NWL%} ,%NWL%" removes a namespaced attribute as a function " : function ( div )  {%NWL%assert . equal ( div [ 0 ] [ 0 ] . getAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ) ,  " " ) ;%NWL%6
assert . equal ( div [ 0 ] [ 0 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttribute ( " href " ) ,  " " ) ;%NWL%} ,%NWL%" removes a namespaced attribute as null " : function ( div )  {%NWL%div . attr ( " xlink:foo " ,  " bar " ) . attr ( " xlink:foo " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . getAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ) ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ) ,  " " ) ;%NWL%} ,%NWL%" removes a namespaced attribute as a function " : function ( div )  {%NWL%div . attr ( " xlink:foo " ,  " bar " ) . attr ( " xlink:foo " , function ( )  { return null; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . getAttributeNS ( " http: / / www . w3 . org / 1999 / xlink " ,  " foo " ) ,  " " ) ;%NWL%6
body . call ( function ( selection , a , b , c )  { abc = [ a , b , c ] ; } ,  " a " ,  " b " ,  " c " ) ;%NWL%assert . deepEqual ( abc ,  [ " a " ,  " b " ,  " c " ] ) ;%NWL%} ,%NWL%" passes the selection as the first argument " : function ( body )  {%NWL%var s;%NWL%body . call ( function ( selection )  { s = selection; } ) ;%NWL%assert . isTrue ( s === body ) ;%NWL%} ,%NWL%" uses the selection as the context " : function ( body )  {%NWL%var s;%NWL%assert . isTrue ( s === body ) ;%NWL%6
div . call ( function ( selection , a , b , c )  { abc = [ a , b , c ] ; } ,  " a " ,  " b " ,  " c " ) ;%NWL%assert . deepEqual ( abc ,  [ " a " ,  " b " ,  " c " ] ) ;%NWL%} ,%NWL%" passes the selection as the first argument " : function ( div )  {%NWL%var s;%NWL%div . call ( function ( selection )  { s = selection; } ) ;%NWL%assert . isTrue ( s === div ) ;%NWL%} ,%NWL%" uses the selection as the context " : function ( div )  {%NWL%var s;%NWL%assert . isTrue ( s === div ) ;%NWL%6
topic: function ( )  {%NWL%return d3 . select ( " body " ) . html ( " " ) ;%NWL%} ,%NWL%" adds a missing class as true " : function ( body )  {%NWL%body . attr ( " class " , null ) ;%NWL%body . classed ( " foo " , true ) ;%NWL%assert . equal ( document . body . className ,  " foo " ) ;%NWL%body . classed ( " bar " , true ) ;%NWL%assert . equal ( document . body . className ,  " foo bar " ) ;%NWL%} ,%NWL%body . attr ( " class " , null ) ;%NWL%4
} ,%NWL%" adds a missing class as true " : function ( body )  {%NWL%body . attr ( " class " , null ) ;%NWL%body . classed ( " foo " , true ) ;%NWL%assert . equal ( document . body . className ,  " foo " ) ;%NWL%body . classed ( " bar " , true ) ;%NWL%assert . equal ( document . body . className ,  " foo bar " ) ;%NWL%} ,%NWL%" adds a missing class as a function " : function ( body )  {%NWL%body . attr ( " class " , null ) ;%NWL%assert . equal ( document . body . className ,  " foo " ) ;%NWL%4
body . attr ( " class " , null ) ;%NWL%body . classed ( " foo " , true ) ;%NWL%assert . equal ( document . body . className ,  " foo " ) ;%NWL%body . classed ( " bar " , true ) ;%NWL%assert . equal ( document . body . className ,  " foo bar " ) ;%NWL%} ,%NWL%" adds a missing class as a function " : function ( body )  {%NWL%body . attr ( " class " , null ) ;%NWL%body . classed ( " foo " , function ( )  { return true; } ) ;%NWL%assert . equal ( document . body . className ,  " foo " ) ;%NWL%assert . equal ( document . body . className ,  " foo bar " ) ;%NWL%4
body . classed ( " bar " , function ( )  { return true; } ) ;%NWL%assert . equal ( document . body . className ,  " foo bar " ) ;%NWL%} ,%NWL%" removes an existing class as false " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , false ) ;%NWL%assert . equal ( document . body . className ,  " bar " ) ;%NWL%body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%4
} ,%NWL%" removes an existing class as false " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , false ) ;%NWL%assert . equal ( document . body . className ,  " bar " ) ;%NWL%body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" removes an existing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%assert . equal ( document . body . className ,  " bar " ) ;%NWL%4
body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , false ) ;%NWL%assert . equal ( document . body . className ,  " bar " ) ;%NWL%body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" removes an existing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " bar " ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%4
body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" removes an existing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " bar " ) ;%NWL%body . classed ( " bar " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%4
body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " bar " ) ;%NWL%body . classed ( " bar " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" preserves an existing class as true " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , true ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%9
body . classed ( " bar " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" preserves an existing class as true " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , true ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%body . classed ( " bar " , true ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%} ,%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%4
} ,%NWL%" preserves an existing class as true " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , true ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%body . classed ( " bar " , true ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%} ,%NWL%" preserves an existing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%4
body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , true ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%body . classed ( " bar " , true ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%} ,%NWL%" preserves an existing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " bar foo " ) ;%NWL%body . classed ( " foo " , function ( )  { return true; } ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%2
assert . equal ( document . body . className ,  " bar foo " ) ;%NWL%} ,%NWL%" preserves a missing class as false " : function ( body )  {%NWL%body . attr ( " class " ,  " baz " ) ;%NWL%body . classed ( " foo " , false ) ;%NWL%assert . equal ( document . body . className ,  " baz " ) ;%NWL%body . attr ( " class " , null ) ;%NWL%body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%body . attr ( " class " ,  " baz " ) ;%NWL%3
" preserves a missing class as false " : function ( body )  {%NWL%body . attr ( " class " ,  " baz " ) ;%NWL%body . classed ( " foo " , false ) ;%NWL%assert . equal ( document . body . className ,  " baz " ) ;%NWL%body . attr ( " class " , null ) ;%NWL%body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " baz " ) ;%NWL%assert . equal ( document . body . className ,  " baz " ) ;%NWL%3
body . attr ( " class " ,  " baz " ) ;%NWL%body . classed ( " foo " , false ) ;%NWL%assert . equal ( document . body . className ,  " baz " ) ;%NWL%body . attr ( " class " , null ) ;%NWL%body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " baz " ) ;%NWL%body . classed ( " foo " , function ( )  { return false; } ) ;%NWL%body . attr ( " class " , null ) ;%NWL%3
assert . equal ( document . body . className ,  " baz " ) ;%NWL%body . attr ( " class " , null ) ;%NWL%body . classed ( " bar " , false ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( body )  {%NWL%body . attr ( " class " ,  " baz " ) ;%NWL%body . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " baz " ) ;%NWL%body . attr ( " class " , null ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%3
body . attr ( " class " , null ) ;%NWL%body . classed ( " bar " , function ( )  { return false; } ) ;%NWL%assert . equal ( document . body . className ,  " " ) ;%NWL%} ,%NWL%" gets an existing class " : function ( body )  {%NWL%body . attr ( " class " ,  " foo\tbar baz " ) ;%NWL%assert . isTrue ( body . classed ( " foo " ) ) ;%NWL%assert . isTrue ( body . classed ( " bar " ) ) ;%NWL%assert . isTrue ( body . classed ( " baz " ) ) ;%NWL%} ,%NWL%body . attr ( " class " ,  " foo\tbar baz " ) ;%NWL%5
body . classed ( " foo bar " , true ) ;%NWL%assert . equal ( document . body . className ,  " foo bar " ) ;%NWL%} ,%NWL%" gets existing classes " : function ( body )  {%NWL%body . attr ( " class " ,  " foo\tbar baz " ) ;%NWL%assert . isTrue ( body . classed ( " foo " ) ) ;%NWL%assert . isTrue ( body . classed ( " foo bar " ) ) ;%NWL%assert . isTrue ( body . classed ( " bar baz " ) ) ;%NWL%assert . isTrue ( body . classed ( " foo bar baz " ) ) ;%NWL%} ,%NWL%body . attr ( " class " ,  " foo\tbar baz " ) ;%NWL%4
div . attr ( " class " , null ) ;%NWL%div . classed ( " foo " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " foo " ) ;%NWL%div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo bar " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " foo bar " ) ;%NWL%} ,%NWL%" adds a missing class as a function " : function ( div )  {%NWL%div . data ( [ 0 , 1 ] ) . attr ( " class " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%2
assert . equal ( div [ 0 ] [ 1 ] . className ,  " foo " ) ;%NWL%div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo bar " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " foo bar " ) ;%NWL%} ,%NWL%" adds a missing class as a function " : function ( div )  {%NWL%div . data ( [ 0 , 1 ] ) . attr ( " class " , null ) ;%NWL%div . classed ( " foo " , function ( d , i )  { return d === 0; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%8
div . classed ( " foo " , function ( d , i )  { return d === 0; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%div . classed ( " bar " , function ( d , i )  { return i === 1; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%} ,%NWL%" removes an existing class as false " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%5
div . classed ( " foo " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%div . classed ( " bar " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" removes an existing class as a function " : function ( div )  {%NWL%div . data ( [ 0 , 1 ] ) . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , function ( d , i )  { return d === 0; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%2
div . classed ( " bar " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" removes an existing class as a function " : function ( div )  {%NWL%div . data ( [ 0 , 1 ] ) . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , function ( d , i )  { return d === 0; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%div . classed ( " bar " , function ( d , i )  { return i === 1; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%8
} ,%NWL%" removes an existing class as a function " : function ( div )  {%NWL%div . data ( [ 0 , 1 ] ) . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , function ( d , i )  { return d === 0; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%div . classed ( " bar " , function ( d , i )  { return i === 1; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%div . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%5
div . data ( [ 0 , 1 ] ) . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , function ( d , i )  { return d === 0; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%div . classed ( " bar " , function ( d , i )  { return i === 1; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%div . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%8
assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar " ) ;%NWL%div . classed ( " bar " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" preserves an existing class as true " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%8
div . classed ( " bar " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" preserves an existing class as true " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%8
} ,%NWL%" preserves an existing class as true " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%} ,%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%2
div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%} ,%NWL%" preserves an existing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%2
div . classed ( " foo " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%} ,%NWL%" preserves an existing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , function ( )  { return true; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%2
assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%} ,%NWL%" preserves an existing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , function ( )  { return true; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%2
div . classed ( " bar " , true ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%} ,%NWL%" preserves an existing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " bar foo " ) ;%NWL%div . classed ( " foo " , function ( )  { return true; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " bar foo " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%div . classed ( " bar " , function ( )  { return true; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " bar foo " ) ;%NWL%2
" preserves a missing class as false " : function ( div )  {%NWL%div . attr ( " class " ,  " baz " ) ;%NWL%div . classed ( " foo " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " baz " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " baz " ) ;%NWL%div . attr ( " class " , null ) ;%NWL%div . classed ( " bar " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%div . attr ( " class " ,  " baz " ) ;%NWL%1
div . classed ( " foo " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " baz " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " baz " ) ;%NWL%div . attr ( " class " , null ) ;%NWL%div . classed ( " bar " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " baz " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " baz " ) ;%NWL%1
assert . equal ( div [ 0 ] [ 0 ] . className ,  " baz " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " baz " ) ;%NWL%div . attr ( " class " , null ) ;%NWL%div . classed ( " bar " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " baz " ) ;%NWL%div . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " baz " ) ;%NWL%1
assert . equal ( div [ 0 ] [ 1 ] . className ,  " baz " ) ;%NWL%div . attr ( " class " , null ) ;%NWL%div . classed ( " bar " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " baz " ) ;%NWL%div . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " baz " ) ;%NWL%div . attr ( " class " , null ) ;%NWL%1
div . classed ( " bar " , false ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " baz " ) ;%NWL%div . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " baz " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " baz " ) ;%NWL%div . attr ( " class " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%1
assert . equal ( div [ 0 ] [ 0 ] . className ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%} ,%NWL%" preserves a missing class as a function " : function ( div )  {%NWL%div . attr ( " class " ,  " baz " ) ;%NWL%div . classed ( " foo " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . className ,  " baz " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " baz " ) ;%NWL%div . attr ( " class " , null ) ;%NWL%div . classed ( " bar " , function ( )  { return false; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . className ,  " " ) ;%NWL%1
topic: function ( )  {%NWL%return d3 . select ( " body " ) . html ( " " ) ;%NWL%} ,%NWL%" assigns data as an array " : function ( body )  {%NWL%var data = new Object ( ) ;%NWL%body . data ( [ data ] ) ;%NWL%assert . strictEqual ( document . body . __data__ , data ) ;%NWL%} ,%NWL%" assigns data as a function " : function ( body )  {%NWL%var data = new Object ( ) ;%NWL%assert . strictEqual ( document . body . __data__ , data ) ;%NWL%6
return d3 . select ( " body " ) . html ( " " ) . selectAll ( " div " ) . data ( d3 . range ( 2 ) ) . enter ( ) . append ( " div " ) ;%NWL%} ,%NWL%" assigns data as an array " : function ( div )  {%NWL%var a = new Object ( ) , b = new Object ( ) ;%NWL%div . data ( [ a , b ] ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%} ,%NWL%" assigns data as a function " : function ( div )  {%NWL%var a = new Object ( ) , b = new Object ( ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%5
} ,%NWL%" assigns data as an array " : function ( div )  {%NWL%var a = new Object ( ) , b = new Object ( ) ;%NWL%div . data ( [ a , b ] ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%} ,%NWL%" assigns data as a function " : function ( div )  {%NWL%var a = new Object ( ) , b = new Object ( ) ;%NWL%div . data ( function ( )  { return [ a , b ] ; } ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%5
" assigns data as an array " : function ( span )  {%NWL%var a = new Object ( ) , b = new Object ( ) ;%NWL%span . data ( [ a , b ] ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%assert . strictEqual ( span [ 1 ] [ 0 ] . __data__ , a ) ;%NWL%assert . strictEqual ( span [ 1 ] [ 1 ] . __data__ , b ) ;%NWL%} ,%NWL%" assigns data as a function " : function ( span )  {%NWL%var a = new Object ( ) , b = new Object ( ) , c = new Object ( ) , d = new Object ( ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%3
var a = new Object ( ) , b = new Object ( ) ;%NWL%span . data ( [ a , b ] ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%assert . strictEqual ( span [ 1 ] [ 0 ] . __data__ , a ) ;%NWL%assert . strictEqual ( span [ 1 ] [ 1 ] . __data__ , b ) ;%NWL%} ,%NWL%" assigns data as a function " : function ( span )  {%NWL%var a = new Object ( ) , b = new Object ( ) , c = new Object ( ) , d = new Object ( ) ;%NWL%span . data ( function ( z , i )  { return i ? [ c , d ] : [ a , b ] ; } ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%3
assert . domNull ( update [ 0 ] [ 1 ] ) ;%NWL%assert . domEqual ( update [ 1 ] [ 0 ] , span [ 1 ] [ 1 ] ) ;%NWL%assert . domNull ( update [ 1 ] [ 1 ] ) ;%NWL%var enter = update . enter ( ) ;%NWL%assert . equal ( enter . length , 2 ) ;%NWL%assert . equal ( enter [ 0 ] . length , 2 ) ;%NWL%assert . equal ( enter [ 1 ] . length , 2 ) ;%NWL%assert . domNull ( enter [ 0 ] [ 0 ] ) ;%NWL%assert . deepEqual ( enter [ 0 ] [ 1 ] ,  { __data__: 2 } ) ;%NWL%assert . domNull ( enter [ 1 ] [ 0 ] ) ;%NWL%var exit = update . exit ( ) ;%NWL%3
return d3 . scale . pow ( ) . exponent ( 2 ) ( smaller_dim / 2 ) ;%NWL%} ) )%NWL%}%NWL%enter . append ( " path " ) . attr ( " class " , " d3plus_data " )%NWL%. call ( init )%NWL%. call ( shapeStyle , vars )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%6
selection . selectAll ( " path . d3plus_data " )%NWL%. data ( function ( d )  {%NWL%return [ d ] ;%NWL%} )%NWL%if ( vars . draw . timing )  {%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. call ( update )%NWL%. call ( shapeStyle , vars )%NWL%}%NWL%selection . selectAll ( " path . d3plus_data " )%NWL%0
assert . equal ( document . body . lastChild . tagName ,  " I " ) ;%NWL%assert . equal ( document . body . lastChild . textContent ,  " 0 " ) ;%NWL%} ,%NWL%%NWL%" clears the inner HTML as the empty string " : function ( body )  {%NWL%body . html ( " " ) ;%NWL%assert . equal ( document . body . innerHTML ,  " " ) ;%NWL%assert . isNull ( document . body . firstChild ) ;%NWL%} ,%NWL%" clears the inner HTML as a function " : function ( body )  {%NWL%assert . equal ( document . body . innerHTML ,  " " ) ;%NWL%6
assert . equal ( document . body . lastChild . textContent ,  " 0 " ) ;%NWL%} ,%NWL%%NWL%" clears the inner HTML as the empty string " : function ( body )  {%NWL%body . html ( " " ) ;%NWL%assert . equal ( document . body . innerHTML ,  " " ) ;%NWL%assert . isNull ( document . body . firstChild ) ;%NWL%} ,%NWL%" clears the inner HTML as a function " : function ( body )  {%NWL%body . text ( function ( )  { return " " ; } ) ;%NWL%assert . isNull ( document . body . firstChild ) ;%NWL%6
} ,%NWL%" gets a property value " : function ( body )  {%NWL%document . body . bgcolor = " yellow " ;%NWL%assert . equal ( body . property ( " bgcolor " ) ,  " yellow " ) ;%NWL%} ,%NWL%" removes a property as null " : function ( body )  {%NWL%body . property ( " bgcolor " ,  " yellow " ) . property ( " bgcolor " , null ) ;%NWL%assert . isFalse ( " bgcolor " in document . body ) ;%NWL%} ,%NWL%" removes a property as a function " : function ( body )  {%NWL%assert . isFalse ( " bgcolor " in document . body ) ;%NWL%7
" gets a property value " : function ( div )  {%NWL%div [ 0 ] [ 0 ] . bgcolor = " purple " ;%NWL%assert . equal ( div . property ( " bgcolor " ) ,  " purple " ) ;%NWL%} ,%NWL%" removes a property as null " : function ( div )  {%NWL%div . property ( " bgcolor " ,  " yellow " ) . property ( " bgcolor " , null ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 0 ] ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 1 ] ) ;%NWL%} ,%NWL%" removes a property as a function " : function ( div )  {%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 0 ] ) ;%NWL%6
div [ 0 ] [ 0 ] . bgcolor = " purple " ;%NWL%assert . equal ( div . property ( " bgcolor " ) ,  " purple " ) ;%NWL%} ,%NWL%" removes a property as null " : function ( div )  {%NWL%div . property ( " bgcolor " ,  " yellow " ) . property ( " bgcolor " , null ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 0 ] ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 1 ] ) ;%NWL%} ,%NWL%" removes a property as a function " : function ( div )  {%NWL%div . property ( " bgcolor " ,  " yellow " ) . property ( " bgcolor " , function ( )  { return null } ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 1 ] ) ;%NWL%6
} ,%NWL%" removes a property as a function " : function ( div )  {%NWL%div . property ( " bgcolor " ,  " yellow " ) . property ( " bgcolor " , function ( )  { return null } ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 0 ] ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 1 ] ) ;%NWL%} ,%NWL%" ignores null nodes " : function ( div )  {%NWL%var some = d3 . selectAll ( " div " ) ;%NWL%some [ 0 ] [ 1 ] = null;%NWL%some . property ( " bgcolor " , null ) . property ( " bgcolor " ,  " red " ) ;%NWL%assert . isFalse ( " bgcolor " in div [ 0 ] [ 1 ] ) ;%NWL%4
require ( " . . / env " ) ;%NWL%require ( " . . / . . / d3 " ) ;%NWL%var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " selection . remove " ) ;%NWL%suite . addBatch ( {%NWL%" select ( body ) " : {%NWL%topic: function ( )  {%NWL%return d3 . select ( " body " ) ;%NWL%} ,%NWL%var div = body . append ( " div " ) ;%NWL%2
" removes the matching elements " : function ( body )  {%NWL%var div = body . append ( " div " ) ;%NWL%div . remove ( ) ;%NWL%assert . domNull ( div [ 0 ] [ 0 ] . parentNode ) ;%NWL%} ,%NWL%" does not remove non - matching elements " : function ( body )  {%NWL%var div1 = body . append ( " div " ) , div2 = body . append ( " div " ) ;%NWL%div1 . remove ( ) ;%NWL%assert . domEqual ( div2 [ 0 ] [ 0 ] . parentNode , document . body ) ;%NWL%} ,%NWL%var div = body . html ( " " ) . selectAll ( " div " ) . data ( [ 0 , 1 ] ) . enter ( ) . append ( " div " ) ,%NWL%1
assert . domEqual ( div2 [ 0 ] [ 0 ] . parentNode , document . body ) ;%NWL%} ,%NWL%" ignores null nodes " : function ( body )  {%NWL%var div = body . html ( " " ) . selectAll ( " div " ) . data ( [ 0 , 1 ] ) . enter ( ) . append ( " div " ) ,%NWL%some = d3 . selectAll ( " div " ) ;%NWL%some [ 0 ] [ 0 ] = null;%NWL%some . remove ( ) ;%NWL%assert . domEqual ( div [ 0 ] [ 0 ] . parentNode , document . body ) ;%NWL%assert . domNull ( div [ 0 ] [ 1 ] . parentNode ) ;%NWL%} ,%NWL%var div = body . append ( " div " ) ;%NWL%3
require ( " . . / env " ) ;%NWL%require ( " . . / . . / d3 " ) ;%NWL%var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " selection . select " ) ;%NWL%suite . addBatch ( {%NWL%" select ( body ) " : {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%2
assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " selection . select " ) ;%NWL%suite . addBatch ( {%NWL%" select ( body ) " : {%NWL%topic: function ( )  {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%body . append ( " div " ) . attr ( " class " ,  " first " ) ;%NWL%body . append ( " div " ) . attr ( " class " ,  " second " ) ;%NWL%return body;%NWL%} ,%NWL%var div = body . select ( " div " ) ;%NWL%5
body . append ( " div " ) . attr ( " class " ,  " second " ) ;%NWL%return body;%NWL%} ,%NWL%" selects the first matching element " : function ( body )  {%NWL%var div = body . select ( " div " ) ;%NWL%assert . isTrue ( div [ 0 ] [ 0 ] === document . body . firstChild ) ;%NWL%assert . equal ( div . length , 1 ) ;%NWL%assert . equal ( div [ 0 ] . length , 1 ) ;%NWL%assert . equal ( div . attr ( " class " ) ,  " first " ) ;%NWL%} ,%NWL%var div = body . select ( " div " ) ;%NWL%4
assert . equal ( div . length , 1 ) ;%NWL%assert . equal ( div [ 0 ] . length , 1 ) ;%NWL%assert . equal ( div . attr ( " class " ) ,  " first " ) ;%NWL%} ,%NWL%" propagates parent node to the selected elements " : function ( body )  {%NWL%var div = body . select ( " div " ) ;%NWL%assert . isNotNull ( div [ 0 ] . parentNode ) ;%NWL%assert . isTrue ( div [ 0 ] . parentNode === document . documentElement ) ;%NWL%assert . isTrue ( div [ 0 ] . parentNode === body [ 0 ] . parentNode ) ;%NWL%} ,%NWL%var data = new Object ( ) , div = body . data ( [ data ] ) . select ( " div " ) ;%NWL%5
var div = body . select ( " div " ) ;%NWL%assert . isNotNull ( div [ 0 ] . parentNode ) ;%NWL%assert . isTrue ( div [ 0 ] . parentNode === document . documentElement ) ;%NWL%assert . isTrue ( div [ 0 ] . parentNode === body [ 0 ] . parentNode ) ;%NWL%} ,%NWL%" propagates data to the selected elements " : function ( body )  {%NWL%var data = new Object ( ) , div = body . data ( [ data ] ) . select ( " div " ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , data ) ;%NWL%} ,%NWL%" does not propagate data if no data was specified " : function ( body )  {%NWL%var data = new Object ( ) , div = body . select ( " div " ) . data ( [ data ] ) ;%NWL%0
assert . isTrue ( div [ 0 ] . parentNode === document . documentElement ) ;%NWL%assert . isTrue ( div [ 0 ] . parentNode === body [ 0 ] . parentNode ) ;%NWL%} ,%NWL%" propagates data to the selected elements " : function ( body )  {%NWL%var data = new Object ( ) , div = body . data ( [ data ] ) . select ( " div " ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , data ) ;%NWL%} ,%NWL%" does not propagate data if no data was specified " : function ( body )  {%NWL%delete document . body . __data__;%NWL%var data = new Object ( ) , div = body . select ( " div " ) . data ( [ data ] ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , data ) ;%NWL%5
var data = new Object ( ) , div = body . data ( [ data ] ) . select ( " div " ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , data ) ;%NWL%} ,%NWL%" does not propagate data if no data was specified " : function ( body )  {%NWL%delete document . body . __data__;%NWL%var data = new Object ( ) , div = body . select ( " div " ) . data ( [ data ] ) ;%NWL%div = body . select ( " div " ) ;%NWL%assert . strictEqual ( div [ 0 ] [ 0 ] . __data__ , data ) ;%NWL%assert . isUndefined ( document . body . __data__ ) ;%NWL%} ,%NWL%var span = body . select ( " span " ) ;%NWL%0
}%NWL%} ) ;%NWL%suite . addBatch ( {%NWL%" selectAll ( div ) " : {%NWL%topic: function ( )  {%NWL%var div = d3 . select ( " body " ) . html ( " " ) . selectAll ( " div " ) . data ( d3 . range ( 2 ) ) . enter ( ) . append ( " div " ) ;%NWL%div . append ( " span " ) . attr ( " class " ,  " first " ) ;%NWL%div . append ( " span " ) . attr ( " class " ,  " second " ) ;%NWL%return div;%NWL%} ,%NWL%var span = div . select ( " span " ) ;%NWL%5
return div;%NWL%} ,%NWL%" selects the first matching element " : function ( div )  {%NWL%var span = div . select ( " span " ) ;%NWL%assert . isTrue ( span [ 0 ] [ 0 ] . parentNode === div [ 0 ] [ 0 ] ) ;%NWL%assert . isTrue ( span [ 0 ] [ 1 ] . parentNode === div [ 0 ] [ 1 ] ) ;%NWL%assert . equal ( span . length , 1 ) ;%NWL%assert . equal ( span [ 0 ] . length , 2 ) ;%NWL%assert . equal ( span . attr ( " class " ) ,  " first " ) ;%NWL%} ,%NWL%var span = div . select ( " span " ) ;%NWL%3
assert . equal ( span . length , 1 ) ;%NWL%assert . equal ( span [ 0 ] . length , 2 ) ;%NWL%assert . equal ( span . attr ( " class " ) ,  " first " ) ;%NWL%} ,%NWL%" propagates parent node to the selected elements " : function ( div )  {%NWL%var span = div . select ( " span " ) ;%NWL%assert . isNotNull ( span [ 0 ] . parentNode ) ;%NWL%assert . isTrue ( span [ 0 ] . parentNode === document . body ) ;%NWL%assert . isTrue ( span [ 0 ] . parentNode === div [ 0 ] . parentNode ) ;%NWL%} ,%NWL%var data = new Object ( ) , span = div . data ( [ data ] ) . select ( " span " ) ;%NWL%5
assert . isNotNull ( span [ 0 ] . parentNode ) ;%NWL%assert . isTrue ( span [ 0 ] . parentNode === document . body ) ;%NWL%assert . isTrue ( span [ 0 ] . parentNode === div [ 0 ] . parentNode ) ;%NWL%} ,%NWL%" propagates data to the selected elements " : function ( div )  {%NWL%var data = new Object ( ) , span = div . data ( [ data ] ) . select ( " span " ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 0 ] . __data__ , data ) ;%NWL%} ,%NWL%" does not propagate data if no data was specified " : function ( div )  {%NWL%delete div [ 0 ] [ 0 ] . __data__;%NWL%var a = new Object ( ) , b = new Object ( ) , span = div . select ( " span " ) . data ( [ a , b ] ) ;%NWL%5
" does not propagate data if no data was specified " : function ( div )  {%NWL%delete div [ 0 ] [ 0 ] . __data__;%NWL%delete div [ 0 ] [ 1 ] . __data__;%NWL%var a = new Object ( ) , b = new Object ( ) , span = div . select ( " span " ) . data ( [ a , b ] ) ;%NWL%span = div . select ( " span " ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%assert . strictEqual ( span [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%assert . isUndefined ( div [ 0 ] [ 0 ] . __data__ ) ;%NWL%assert . isUndefined ( div [ 0 ] [ 1 ] . __data__ ) ;%NWL%} ,%NWL%var div = div . select ( " div " ) ;%NWL%3
} ,%NWL%" returns null if no match is found " : function ( div )  {%NWL%var div = div . select ( " div " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] , null ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] , null ) ;%NWL%assert . equal ( div . length , 1 ) ;%NWL%assert . equal ( div [ 0 ] . length , 2 ) ;%NWL%} ,%NWL%" ignores null nodes " : function ( div )  {%NWL%var some = d3 . selectAll ( " div " ) ;%NWL%var span = some . select ( " span " ) ;%NWL%2
require ( " . . / env " ) ;%NWL%require ( " . . / . . / d3 " ) ;%NWL%var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " selection . selectAll " ) ;%NWL%suite . addBatch ( {%NWL%" select ( body ) " : {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%2
var suite = vows . describe ( " selection . selectAll " ) ;%NWL%suite . addBatch ( {%NWL%" select ( body ) " : {%NWL%topic: function ( )  {%NWL%var body = d3 . select ( " body " ) . html ( " " ) ;%NWL%if ( " __data__ " in body [ 0 ] [ 0 ] ) delete body [ 0 ] [ 0 ] . __data__;%NWL%body . append ( " div " ) . attr ( " class " ,  " first " ) ;%NWL%body . append ( " div " ) . attr ( " class " ,  " second " ) ;%NWL%return body;%NWL%} ,%NWL%var div = body . selectAll ( " div " ) ;%NWL%4
body . append ( " div " ) . attr ( " class " ,  " second " ) ;%NWL%return body;%NWL%} ,%NWL%" selects all matching elements " : function ( body )  {%NWL%var div = body . selectAll ( " div " ) ;%NWL%assert . isTrue ( div [ 0 ] [ 0 ] === document . body . firstChild ) ;%NWL%assert . isTrue ( div [ 0 ] [ 1 ] === document . body . lastChild ) ;%NWL%assert . equal ( div . length , 1 ) ;%NWL%assert . equal ( div [ 0 ] . length , 2 ) ;%NWL%} ,%NWL%var div = body . selectAll ( " div " ) ;%NWL%4
assert . isTrue ( div [ 0 ] [ 0 ] === document . body . firstChild ) ;%NWL%assert . isTrue ( div [ 0 ] [ 1 ] === document . body . lastChild ) ;%NWL%assert . equal ( div . length , 1 ) ;%NWL%assert . equal ( div [ 0 ] . length , 2 ) ;%NWL%} ,%NWL%" propagates parent node to the selected elements " : function ( body )  {%NWL%var div = body . selectAll ( " div " ) ;%NWL%assert . isNotNull ( div [ 0 ] . parentNode ) ;%NWL%assert . isTrue ( div [ 0 ] . parentNode === document . body ) ;%NWL%} ,%NWL%var div = body . data ( [ new Object ( ) ] ) . selectAll ( " div " ) ;%NWL%6
" propagates parent node to the selected elements " : function ( body )  {%NWL%var div = body . selectAll ( " div " ) ;%NWL%assert . isNotNull ( div [ 0 ] . parentNode ) ;%NWL%assert . isTrue ( div [ 0 ] . parentNode === document . body ) ;%NWL%} ,%NWL%" does not propagate data if data was specified " : function ( body )  {%NWL%var div = body . data ( [ new Object ( ) ] ) . selectAll ( " div " ) ;%NWL%assert . isUndefined ( div [ 0 ] [ 0 ] . __data__ ) ;%NWL%assert . isUndefined ( div [ 0 ] [ 1 ] . __data__ ) ;%NWL%} ,%NWL%var div = body . selectAll ( " div " ) . data ( [ 1 , 2 ] ) ;%NWL%1
var div = body . data ( [ new Object ( ) ] ) . selectAll ( " div " ) ;%NWL%assert . isUndefined ( div [ 0 ] [ 0 ] . __data__ ) ;%NWL%assert . isUndefined ( div [ 0 ] [ 1 ] . __data__ ) ;%NWL%} ,%NWL%" does not propagate data if data was not specified " : function ( body )  {%NWL%var div = body . selectAll ( " div " ) . data ( [ 1 , 2 ] ) ;%NWL%div = body . data ( [ new Object ( ) ] ) . selectAll ( " div " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . __data__ , 1 ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . __data__ , 2 ) ;%NWL%} ,%NWL%var span = body . selectAll ( " span " ) ;%NWL%0
}%NWL%} ) ;%NWL%suite . addBatch ( {%NWL%" selectAll ( div ) " : {%NWL%topic: function ( )  {%NWL%var div = d3 . select ( " body " ) . html ( " " ) . selectAll ( " div " ) . data ( d3 . range ( 2 ) ) . enter ( ) . append ( " div " ) ;%NWL%div . append ( " span " ) . attr ( " class " ,  " first " ) ;%NWL%div . append ( " span " ) . attr ( " class " ,  " second " ) ;%NWL%return div;%NWL%} ,%NWL%var span = div . selectAll ( " span " ) ;%NWL%5
} ,%NWL%" selects all matching elements " : function ( div )  {%NWL%var span = div . selectAll ( " span " ) ;%NWL%assert . equal ( span . length , 2 ) ;%NWL%assert . equal ( span [ 0 ] . length , 2 ) ;%NWL%assert . isTrue ( span [ 0 ] [ 0 ] . parentNode === div [ 0 ] [ 0 ] ) ;%NWL%assert . isTrue ( span [ 0 ] [ 1 ] . parentNode === div [ 0 ] [ 0 ] ) ;%NWL%assert . isTrue ( span [ 1 ] [ 0 ] . parentNode === div [ 0 ] [ 1 ] ) ;%NWL%assert . isTrue ( span [ 1 ] [ 1 ] . parentNode === div [ 0 ] [ 1 ] ) ;%NWL%} ,%NWL%var span = div . selectAll ( " span " ) ;%NWL%2
assert . isTrue ( span [ 0 ] [ 1 ] . parentNode === div [ 0 ] [ 0 ] ) ;%NWL%assert . isTrue ( span [ 1 ] [ 0 ] . parentNode === div [ 0 ] [ 1 ] ) ;%NWL%assert . isTrue ( span [ 1 ] [ 1 ] . parentNode === div [ 0 ] [ 1 ] ) ;%NWL%} ,%NWL%" propagates parent node to the selected elements " : function ( div )  {%NWL%var span = div . selectAll ( " span " ) ;%NWL%assert . isNotNull ( span [ 0 ] . parentNode ) ;%NWL%assert . isTrue ( span [ 0 ] . parentNode === div [ 0 ] [ 0 ] ) ;%NWL%assert . isTrue ( span [ 1 ] . parentNode === div [ 0 ] [ 1 ] ) ;%NWL%} ,%NWL%var span = div . selectAll ( " span " ) ;%NWL%5
assert . isTrue ( span [ 1 ] . parentNode === div [ 0 ] [ 1 ] ) ;%NWL%} ,%NWL%" does not propagate data if data was specified " : function ( div )  {%NWL%var span = div . selectAll ( " span " ) ;%NWL%delete span [ 0 ] [ 0 ] . __data__;%NWL%delete span [ 0 ] [ 1 ] . __data__;%NWL%span = div . data ( [ new Object ( ) , new Object ( ) ] ) . selectAll ( " span " ) ;%NWL%assert . isUndefined ( span [ 0 ] [ 0 ] . __data__ ) ;%NWL%assert . isUndefined ( span [ 0 ] [ 1 ] . __data__ ) ;%NWL%} ,%NWL%var a = new Object ( ) , b = new Object ( ) , span = div . selectAll ( " span " ) . data ( [ a , b ] ) ;%NWL%3
assert . isUndefined ( span [ 0 ] [ 1 ] . __data__ ) ;%NWL%} ,%NWL%" does not propagate data if data was not specified " : function ( div )  {%NWL%var a = new Object ( ) , b = new Object ( ) , span = div . selectAll ( " span " ) . data ( [ a , b ] ) ;%NWL%delete div [ 0 ] [ 0 ] . __data__;%NWL%delete div [ 0 ] [ 1 ] . __data__;%NWL%span = div . selectAll ( " span " ) ;%NWL%assert . equal ( span [ 0 ] [ 0 ] . __data__ , a ) ;%NWL%assert . equal ( span [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%} ,%NWL%var div = div . selectAll ( " div " ) ;%NWL%3
assert . equal ( span [ 0 ] [ 1 ] . __data__ , b ) ;%NWL%} ,%NWL%" returns empty array if no match is found " : function ( div )  {%NWL%var div = div . selectAll ( " div " ) ;%NWL%assert . equal ( div . length , 2 ) ;%NWL%assert . equal ( div [ 0 ] . length , 0 ) ;%NWL%assert . equal ( div [ 1 ] . length , 0 ) ;%NWL%} ,%NWL%" ignores null nodes " : function ( div )  {%NWL%var some = d3 . selectAll ( " div " ) ;%NWL%var span = some . selectAll ( " span " ) ;%NWL%3
. append ( " rect " )%NWL%. attr ( " width " , vars . width . viz )%NWL%. attr ( " height " , vars . height . viz ) ;%NWL%vars . g . container = vars . svg . selectAll ( " g#container " ) . data ( [ " container " ] ) ;%NWL%vars . g . container . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " container " )%NWL%. attr ( " clip - path " , " url ( # "  + clipID +  " ) " )%NWL%. attr ( " transform " , " translate ( " + vars . margin . left + " , " + vars . margin . top + " ) " ) ;%NWL%vars . g . zoom = vars . g . container . selectAll ( " g#zoom " ) . data ( [ " zoom " ] ) ;%NWL%vars . g . zoom . enter ( ) . append ( " g " )%NWL%vars . g . viz = vars . g . zoom . selectAll ( " g#d3plus_viz " ) . data ( [ " d3plus_viz " ] ) ;%NWL%8
vars . zoom . behavior . scaleExtent ( ) [ 0 ] < vars . zoom . scale )  {%NWL%d3 . select ( this ) . style ( " cursor " , prefix ( ) + " grab " ) ;%NWL%}%NWL%else {%NWL%d3 . select ( this ) . style ( " cursor " , " auto " ) ;%NWL%}%NWL%} )%NWL%. on ( events . up , function ( d ) {%NWL%if ( touch ) touchEvent ( vars , d3 . event ) ;%NWL%if ( vars . types [ vars . type . value ] . zoom && vars . zoom . pan . value &&%NWL%d3 . select ( this ) . style ( " cursor " , prefix ( ) + " grab " ) ;%NWL%1
else {%NWL%d3 . select ( this ) . style ( " cursor " , " auto " ) ;%NWL%}%NWL%} )%NWL%. on ( events . up , function ( d ) {%NWL%if ( touch ) touchEvent ( vars , d3 . event ) ;%NWL%if ( vars . types [ vars . type . value ] . zoom && vars . zoom . pan . value &&%NWL%vars . zoom . behavior . scaleExtent ( ) [ 0 ] < vars . zoom . scale )  {%NWL%d3 . select ( this ) . style ( " cursor " , prefix ( ) + " grab " ) ;%NWL%}%NWL%d3 . select ( this ) . style ( " cursor " , " auto " ) ;%NWL%1
else {%NWL%d3 . select ( this ) . style ( " cursor " , " auto " ) ;%NWL%}%NWL%} )%NWL%. on ( events . down , function ( d ) {%NWL%if ( touch ) touchEvent ( vars , d3 . event ) ;%NWL%if ( vars . types [ vars . type . value ] . zoom && vars . zoom . pan . value &&%NWL%vars . zoom . behavior . scaleExtent ( ) [ 0 ] < vars . zoom . scale )  {%NWL%d3 . select ( this ) . style ( " cursor " , prefix ( ) + " grabbing " ) ;%NWL%}%NWL%d3 . select ( this ) . style ( " cursor " , " auto " ) ;%NWL%1
if ( vars . types [ vars . type . value ] . zoom && vars . zoom . pan . value &&%NWL%vars . zoom . behavior . scaleExtent ( ) [ 0 ] < vars . zoom . scale )  {%NWL%d3 . select ( this ) . style ( " cursor " , prefix ( ) + " grabbing " ) ;%NWL%}%NWL%else {%NWL%d3 . select ( this ) . style ( " cursor " , " auto " ) ;%NWL%}%NWL%} ) ;%NWL%vars . g . app = vars . g . viz . selectAll ( " g#app " ) . data ( [ " app " ] ) ;%NWL%vars . g . app . enter ( ) . append ( " g " )%NWL%vars . g . edges = vars . g . viz . selectAll ( " g#edges " ) . data ( [ " edges " ] ) ;%NWL%8
else {%NWL%d3 . select ( this ) . style ( " cursor " , " auto " ) ;%NWL%}%NWL%} ) ;%NWL%vars . g . app = vars . g . viz . selectAll ( " g#app " ) . data ( [ " app " ] ) ;%NWL%vars . g . app . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " app " ) ;%NWL%vars . g . edges = vars . g . viz . selectAll ( " g#edges " ) . data ( [ " edges " ] ) ;%NWL%vars . g . edges . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " edges " )%NWL%vars . g . edge_focus = vars . g . viz . selectAll ( " g#focus " ) . data ( [ " focus " ] ) ;%NWL%4
} ) ;%NWL%vars . g . app = vars . g . viz . selectAll ( " g#app " ) . data ( [ " app " ] ) ;%NWL%vars . g . app . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " app " ) ;%NWL%vars . g . edges = vars . g . viz . selectAll ( " g#edges " ) . data ( [ " edges " ] ) ;%NWL%vars . g . edges . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " edges " )%NWL%. attr ( " opacity " , 0 ) ;%NWL%vars . g . edge_focus = vars . g . viz . selectAll ( " g#focus " ) . data ( [ " focus " ] ) ;%NWL%vars . g . edge_focus . enter ( ) . append ( " g " )%NWL%vars . g . edge_hover = vars . g . viz . selectAll ( " g#edge_hover " ) . data ( [ " edge_hover " ] ) ;%NWL%1
vars . g . edges = vars . g . viz . selectAll ( " g#edges " ) . data ( [ " edges " ] ) ;%NWL%vars . g . edges . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " edges " )%NWL%. attr ( " opacity " , 0 ) ;%NWL%vars . g . edge_focus = vars . g . viz . selectAll ( " g#focus " ) . data ( [ " focus " ] ) ;%NWL%vars . g . edge_focus . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " focus " ) ;%NWL%vars . g . edge_hover = vars . g . viz . selectAll ( " g#edge_hover " ) . data ( [ " edge_hover " ] ) ;%NWL%vars . g . edge_hover . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " edge_hover " )%NWL%vars . g . data = vars . g . viz . selectAll ( " g#data " ) . data ( [ " data " ] ) ;%NWL%0
vars . g . edge_focus = vars . g . viz . selectAll ( " g#focus " ) . data ( [ " focus " ] ) ;%NWL%vars . g . edge_focus . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " focus " ) ;%NWL%vars . g . edge_hover = vars . g . viz . selectAll ( " g#edge_hover " ) . data ( [ " edge_hover " ] ) ;%NWL%vars . g . edge_hover . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " edge_hover " )%NWL%. attr ( " opacity " , 0 ) ;%NWL%vars . g . data = vars . g . viz . selectAll ( " g#data " ) . data ( [ " data " ] ) ;%NWL%vars . g . data . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " data " )%NWL%vars . g . data_focus = vars . g . viz . selectAll ( " g#data_focus " ) . data ( [ " data_focus " ] ) ;%NWL%0
vars . g . edge_hover = vars . g . viz . selectAll ( " g#edge_hover " ) . data ( [ " edge_hover " ] ) ;%NWL%vars . g . edge_hover . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " edge_hover " )%NWL%. attr ( " opacity " , 0 ) ;%NWL%vars . g . data = vars . g . viz . selectAll ( " g#data " ) . data ( [ " data " ] ) ;%NWL%vars . g . data . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " data " )%NWL%. attr ( " opacity " , 0 ) ;%NWL%vars . g . data_focus = vars . g . viz . selectAll ( " g#data_focus " ) . data ( [ " data_focus " ] ) ;%NWL%vars . g . data_focus . enter ( ) . append ( " g " )%NWL%vars . g . labels = vars . g . viz . selectAll ( " g#d3plus_labels " ) . data ( [ " d3plus_labels " ] ) ;%NWL%0
. attr ( " opacity " , 0 ) ;%NWL%vars . g . data = vars . g . viz . selectAll ( " g#data " ) . data ( [ " data " ] ) ;%NWL%vars . g . data . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " data " )%NWL%. attr ( " opacity " , 0 ) ;%NWL%vars . g . data_focus = vars . g . viz . selectAll ( " g#data_focus " ) . data ( [ " data_focus " ] ) ;%NWL%vars . g . data_focus . enter ( ) . append ( " g " )%NWL%. attr ( " id " , " data_focus " ) ;%NWL%vars . g . labels = vars . g . viz . selectAll ( " g#d3plus_labels " ) . data ( [ " d3plus_labels " ] ) ;%NWL%vars . g . labels . enter ( ) . append ( " g " )%NWL%vars . defs = vars . svg . selectAll ( " defs " ) . data ( [ " defs " ] ) ;%NWL%1
} ,%NWL%" observes the specified priority " : function ( body )  {%NWL%body . style ( " background - color " ,  " green " ,  " important " ) ;%NWL%assert . equal ( document . body . style . getPropertyPriority ( " background - color " ) ,  " important " ) ;%NWL%} ,%NWL%" removes a property as null " : function ( body )  {%NWL%body . style ( " background - color " ,  " green " ) . style ( " background - color " , null ) ;%NWL%assert . equal ( body . style ( " background - color " ) ,  " " ) ;%NWL%} ,%NWL%" removes a property as a function " : function ( body )  {%NWL%assert . equal ( body . style ( " background - color " ) ,  " " ) ;%NWL%7
div . style ( " background - color " ,  " blue " ,  " important " ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . style . getPropertyPriority ( " background - color " ) ,  " important " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . style . getPropertyPriority ( " background - color " ) ,  " important " ) ;%NWL%} ,%NWL%" removes a property as null " : function ( div )  {%NWL%div . style ( " background - color " ,  " red " ) . style ( " background - color " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . style [ " background - color " ] ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . style [ " background - color " ] ,  " " ) ;%NWL%} ,%NWL%" removes a property as a function " : function ( div )  {%NWL%assert . equal ( div [ 0 ] [ 0 ] . style [ " background - color " ] ,  " " ) ;%NWL%6
assert . equal ( div [ 0 ] [ 0 ] . style . getPropertyPriority ( " background - color " ) ,  " important " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . style . getPropertyPriority ( " background - color " ) ,  " important " ) ;%NWL%} ,%NWL%" removes a property as null " : function ( div )  {%NWL%div . style ( " background - color " ,  " red " ) . style ( " background - color " , null ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . style [ " background - color " ] ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . style [ " background - color " ] ,  " " ) ;%NWL%} ,%NWL%" removes a property as a function " : function ( div )  {%NWL%div . style ( " background - color " ,  " red " ) . style ( " background - color " , function ( )  { return null; } ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . style [ " background - color " ] ,  " " ) ;%NWL%6
} ,%NWL%" removes a property as a function " : function ( div )  {%NWL%div . style ( " background - color " ,  " red " ) . style ( " background - color " , function ( )  { return null; } ) ;%NWL%assert . equal ( div [ 0 ] [ 0 ] . style [ " background - color " ] ,  " " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . style [ " background - color " ] ,  " " ) ;%NWL%} ,%NWL%" ignores null nodes " : function ( div )  {%NWL%var some = d3 . selectAll ( " div " ) ;%NWL%some [ 0 ] [ 1 ] = null;%NWL%some . style ( " background - color " , null ) . style ( " background - color " ,  " red " ) ;%NWL%assert . equal ( div [ 0 ] [ 1 ] . style [ " background - color " ] ,  " " ) ;%NWL%4
. attr ( " xlink:type " , function ( )  { return null; } )%NWL%. each ( " end " , function ( )  { cb ( null ,  { selection: s , transition: t } ) ; } ) ;%NWL%} ,%NWL%" defines the corresponding attr tween " : function ( result )  {%NWL%assert . typeOf ( result . transition . tween ( " attr . width " ) ,  " function " ) ;%NWL%assert . typeOf ( result . transition . tween ( " attr . color " ) ,  " function " ) ;%NWL%} ,%NWL%" the last attr operator takes precedence " : function ( result )  {%NWL%assert . equal ( result . selection . attr ( " width " ) ,  " 200 " ) ;%NWL%} ,%NWL%assert . equal ( result . selection . attr ( " width " ) ,  " 200 " ) ;%NWL%8
transition . call ( function ( selection , a , b , c )  { abc = [ a , b , c ] ; } ,  " a " ,  " b " ,  " c " ) ;%NWL%assert . deepEqual ( abc ,  [ " a " ,  " b " ,  " c " ] ) ;%NWL%} ,%NWL%" passes the transition as the first argument " : function ( transition )  {%NWL%var t;%NWL%transition . call ( function ( x )  { t = x; } ) ;%NWL%assert . isTrue ( t === transition ) ;%NWL%} ,%NWL%" uses the transition as the context " : function ( transition )  {%NWL%var t;%NWL%assert . isTrue ( t === transition ) ;%NWL%6
} ,%NWL%" removes the selected elements " : function ( transition )  {%NWL%assert . domEqual ( transition [ 0 ] [ 0 ] . node . parentNode , null ) ;%NWL%} ,%NWL%" when the element is already removed " : {%NWL%topic: function ( )  {%NWL%var cb = this . callback ,%NWL%t = d3 . select ( " body " ) . append ( " div " ) . remove ( ) . transition ( ) . remove ( ) ;%NWL%t . each ( " end " , function ( )  { cb ( null , t ) ; } ) ;%NWL%} ,%NWL%assert . domEqual ( transition [ 0 ] [ 0 ] . node . parentNode , null ) ;%NWL%2
. style ( " color " , function ( )  { return " green " ; } ,  " important " )%NWL%. each ( " end " , function ( )  { cb ( null ,  { selection: s , transition: t } ) ; } ) ;%NWL%} ,%NWL%" defines the corresponding style tween " : function ( result )  {%NWL%assert . typeOf ( result . transition . tween ( " style . background - color " ) ,  " function " ) ;%NWL%assert . typeOf ( result . transition . tween ( " style . color " ) ,  " function " ) ;%NWL%} ,%NWL%" the last style operator takes precedence " : function ( result )  {%NWL%assert . equal ( result . selection . style ( " background - color " ) ,  " #ff0000 " ) ;%NWL%} ,%NWL%assert . equal ( result . selection . style ( " background - color " ) ,  " #ff0000 " ) ;%NWL%8
require ( " . . / . . / d3 " ) ;%NWL%var assert = require ( " assert " ) ;%NWL%module . exports = {%NWL%topic: function ( )  {%NWL%return d3 . select ( " body " ) . append ( " div " ) . transition ( ) ;%NWL%} ,%NWL%" is approximately equal to now " : function ( transition )  {%NWL%var time = transition . time;%NWL%assert . inDelta ( time , Date . now ( ) , 20 ) ;%NWL%} ,%NWL%var now = Date . now , then = Date . now ( ) ;%NWL%1
var now = Date . now , then = Date . now ( ) ;%NWL%try {%NWL%Date . now = function ( )  { return + + then; } ;%NWL%var t0 = d3 . select ( " body " ) . append ( " div " ) . transition ( ) ,%NWL%t1 = d3 . select ( " body " ) . append ( " div " ) . transition ( ) ;%NWL%assert . isTrue ( t1 . time > t0 . time ) ;%NWL%} finally {%NWL%Date . now = now;%NWL%}%NWL%} ,%NWL%var now = Date . now , then = Date . now ( ) ;%NWL%0
" value " : " "%NWL%} )%NWL%}%NWL%}%NWL%if ( vars . tooltip . connections . value && length === " long "  )  {%NWL%var connections = vars . edges . connections ( id [ vars . id . value ]  , vars . id . value , true )%NWL%if ( connections . length )  {%NWL%connections . forEach ( function ( conn ) {%NWL%var c = vars . data . viz . filter ( function ( d ) {%NWL%return d [ vars . id . value ] === conn [ vars . id . value ]%NWL%var c = c . length ? c [ 0 ] : conn%NWL%5
" format " : {%NWL%topic: function ( )  {%NWL%return d3 . csv . format;%NWL%} ,%NWL%" takes an array of arrays as input " : function ( format )  {%NWL%assert . equal ( format ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%} ,%NWL%" separates lines using unix newline " : function ( format )  {%NWL%assert . equal ( format ( [ [ ] ,  [ ] ] ) ,  " \n " ) ;%NWL%} ,%NWL%assert . equal ( format ( [ [ " a " ,  " b " ,  " c " ] ,  [ " 1 " ,  " 2 " ,  " 3 " ] ] ) ,  " a , b , c\n1 , 2 , 3 " ) ;%NWL%5
assert . inDelta ( coords [ 0 ] , 1031 . 393796 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 714 . 160436 , 1e - 6 ) ;%NWL%var lonlat = albers . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( albers )  {%NWL%var coords = albers ( [ 0 ,  - 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 2753 . 458335 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  317 . 371122 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 1 ] ,  209 . 571197 , 1e - 6 ) ;%NWL%var lonlat = albers . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] ,  - 180 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( albers )  {%NWL%var coords = albers ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] ,  894 . 435228 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 2927 . 636630 , 1e - 6 ) ;%NWL%var lonlat = albers . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" origin " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 91 . 633117 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 91 . 633117 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 91 . 633117 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 ,  - 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 91 . 633117 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] ,  - 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . equal ( coords [ 0 ] ,  - Infinity ) ;%NWL%assert . isTrue ( isNaN ( coords [ 1 ] ) ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . isTrue ( isNaN ( coords [ 1 ] ) ) ;%NWL%6
} ,%NWL%" origin " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 99 . 619469 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 99 . 619469 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 99 . 619469 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 ,  - 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 99 . 619469 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 ,  - 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 99 . 619469 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] ,  - 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 99 . 619469 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] ,  - 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Inversion works for non - zero translation " : function ( )  {%NWL%var azimuthal = d3 . geo . azimuthal ( ) . mode ( " orthographic " ) . translate ( [ 123 , 99 ] ) . scale ( 100 ) ,%NWL%coords = azimuthal ( [ 0 , 85 ] ) ,%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%4
} ,%NWL%" origin " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 1143 . 005230 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 1143 . 005230 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 1143 . 005230 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 ,  - 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 1143 . 005230 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 ,  - 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 1143 . 005230 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] ,  - 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 1143 . 005230 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] ,  - 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Inversion works for non - zero translation " : function ( )  {%NWL%var azimuthal = d3 . geo . azimuthal ( ) . mode ( " stereographic " ) . translate ( [ 123 , 99 ] ) . scale ( 100 ) ,%NWL%coords = azimuthal ( [ 0 , 85 ] ) ,%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%4
} ,%NWL%" origin " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 148 . 352986 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 148 . 352986 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 148 . 352986 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 ,  - 90 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 157 . 079632 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] ,  - 314 . 159265 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] ,  - 180 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] ,  - 180 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 314 . 159265 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" origin " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 135 . 118041 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
} ,%NWL%" Arctic " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 135 . 118041 , 1e - 6 ) ;%NWL%var lonlat = azimuthal . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( azimuthal )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( lonlat [ 0 ] , 180 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] ,  - 90 , 1e - 6 ) ;%NWL%} ,%NWL%" Hawaii " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ - 180 , 0 ] ) ;%NWL%assert . equal ( coords [ 0 ] ,  - Infinity ) ;%NWL%assert . isTrue ( isNaN ( coords [ 1 ] ) ) ;%NWL%} ,%NWL%" Phillipines " : function ( azimuthal )  {%NWL%var coords = azimuthal ( [ 180 , 0 ] ) ;%NWL%assert . isTrue ( isNaN ( coords [ 1 ] ) ) ;%NWL%6
} ,%NWL%" Arctic " : function ( bonne )  {%NWL%var lonlat = [ 0 , 85 ] ,%NWL%coords = bonne ( lonlat ) ;%NWL%assert . inDelta ( coords ,  [ 480 , 92 . 920367 ] , 1e - 6 ) ;%NWL%assert . inDelta ( bonne . invert ( coords ) , lonlat , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( bonne )  {%NWL%var lonlat = [ 0 ,  - 85 ] ,%NWL%coords = bonne ( lonlat ) ;%NWL%assert . inDelta ( bonne . invert ( coords ) , lonlat , 1e - 6 ) ;%NWL%5
} ,%NWL%" Antarctic " : function ( bonne )  {%NWL%var lonlat = [ 0 ,  - 85 ] ,%NWL%coords = bonne ( lonlat ) ;%NWL%assert . inDelta ( coords ,  [ 480 , 686 . 332312 ] , 1e - 6 ) ;%NWL%assert . inDelta ( bonne . invert ( coords ) , lonlat , 1e - 6 ) ;%NWL%} ,%NWL%" Hawaii " : function ( bonne )  {%NWL%var lonlat = [ - 180 , 0 ] ,%NWL%coords = bonne ( lonlat ) ;%NWL%assert . inDelta ( bonne . invert ( coords ) , lonlat , 1e - 6 ) ;%NWL%5
} ,%NWL%" Hawaii " : function ( bonne )  {%NWL%var lonlat = [ - 180 , 0 ] ,%NWL%coords = bonne ( lonlat ) ;%NWL%assert . inDelta ( coords ,  [ 103 . 604887 ,  - 22 . 895998 ] , 1e - 6 ) ;%NWL%assert . inDelta ( bonne . invert ( coords ) , lonlat , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( bonne )  {%NWL%var lonlat = [ 180 , 0 ] ,%NWL%coords = bonne ( lonlat ) ;%NWL%assert . inDelta ( bonne . invert ( coords ) , lonlat , 1e - 6 ) ;%NWL%5
} ,%NWL%" Arctic " : function ( mercator )  {%NWL%var coords = mercator ( [ 0 , 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 49 . 8362085 , 1e - 6 ) ;%NWL%var lonlat = mercator . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( mercator )  {%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] ,  - 49 . 8362085 , 1e - 6 ) ;%NWL%var lonlat = mercator . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 85 , 1e - 6 ) ;%NWL%} ,%NWL%" Antarctic " : function ( mercator )  {%NWL%var coords = mercator ( [ 0 ,  - 85 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 49 . 8362085 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 0 ] , 0 , 1e - 6 ) ;%NWL%3
" Hawaii " : function ( mercator )  {%NWL%var coords = mercator ( [ - 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] ,  - 50 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = mercator . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] ,  - 180 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( mercator )  {%NWL%var coords = mercator ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = mercator . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 0 ] ,  - 180 , 1e - 6 ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%} ,%NWL%" Phillipines " : function ( mercator )  {%NWL%var coords = mercator ( [ 180 , 0 ] ) ;%NWL%assert . inDelta ( coords [ 0 ] , 50 , 1e - 6 ) ;%NWL%assert . inDelta ( coords [ 1 ] , 0 , 1e - 6 ) ;%NWL%var lonlat = mercator . invert ( coords ) ;%NWL%assert . inDelta ( lonlat [ 1 ] , 0 , 1e - 6 ) ;%NWL%3
assert . equal ( polygon . area ( ) , 1 ) ;%NWL%} ,%NWL%" centroid " : function ( polygon )  {%NWL%assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%}%NWL%} ,%NWL%" counterclockwise polygon ( implicitly ending at start point ) " : {%NWL%topic: function ( )  {%NWL%return d3 . geom . polygon ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ] ) ;%NWL%} ,%NWL%assert . equal ( polygon . area ( ) , 1 ) ;%NWL%0
assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%}%NWL%} ,%NWL%" counterclockwise polygon ( implicitly ending at start point ) " : {%NWL%topic: function ( )  {%NWL%return d3 . geom . polygon ( [ [ 0 , 0 ] ,  [ 0 , 1 ] ,  [ 1 , 1 ] ,  [ 1 , 0 ] ] ) ;%NWL%} ,%NWL%" area " : function ( polygon )  {%NWL%assert . equal ( polygon . area ( ) , 1 ) ;%NWL%} ,%NWL%assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%0
assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%}%NWL%} ,%NWL%" clockwise polygon ( last point equal to start point ) " : {%NWL%topic: function ( )  {%NWL%return d3 . geom . polygon ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ,  [ 0 , 0 ] ] ) ;%NWL%} ,%NWL%" area " : function ( polygon )  {%NWL%assert . equal ( polygon . area ( ) ,  - 1 ) ;%NWL%} ,%NWL%assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%0
assert . equal ( polygon . area ( ) ,  - 1 ) ;%NWL%} ,%NWL%" centroid " : function ( polygon )  {%NWL%assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%}%NWL%} ,%NWL%" clockwise polygon ( implicitly ending at start point ) " : {%NWL%topic: function ( )  {%NWL%return d3 . geom . polygon ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ] ) ;%NWL%} ,%NWL%assert . equal ( polygon . area ( ) ,  - 1 ) ;%NWL%0
assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%}%NWL%} ,%NWL%" clockwise polygon ( implicitly ending at start point ) " : {%NWL%topic: function ( )  {%NWL%return d3 . geom . polygon ( [ [ 0 , 0 ] ,  [ 1 , 0 ] ,  [ 1 , 1 ] ,  [ 0 , 1 ] ] ) ;%NWL%} ,%NWL%" area " : function ( polygon )  {%NWL%assert . equal ( polygon . area ( ) ,  - 1 ) ;%NWL%} ,%NWL%assert . deepEqual ( polygon . centroid ( ) ,  [ . 5 ,  . 5 ] ) ;%NWL%0
assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . layout . hierarchy " ) ;%NWL%suite . addBatch ( {%NWL%" hierarchy " : {%NWL%topic: function ( )  {%NWL%return d3 . layout . treemap ( ) ; / / hierarchy is abstract , so test a subclass%NWL%} ,%NWL%" doesn ' t overwrite the value of a node that has an empty children array " : function ( hierarchy )  {%NWL%var nodes = hierarchy . sticky ( true ) . nodes ( { value: 1 , children: [ ] } ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 1 ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 1 ) ;%NWL%9
return d3 . layout . treemap ( ) ; / / hierarchy is abstract , so test a subclass%NWL%} ,%NWL%" doesn ' t overwrite the value of a node that has an empty children array " : function ( hierarchy )  {%NWL%var nodes = hierarchy . sticky ( true ) . nodes ( { value: 1 , children: [ ] } ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 1 ) ;%NWL%hierarchy . nodes ( nodes [ 0 ] ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 1 ) ;%NWL%} ,%NWL%" a valueless node that has an empty children array gets a value of 0 " : function ( hierarchy )  {%NWL%var nodes = hierarchy . sticky ( true ) . nodes ( { children: [ ] } ) ;%NWL%hierarchy . nodes ( nodes [ 0 ] ) ;%NWL%5
} ,%NWL%" doesn ' t overwrite the value of a node that has an empty children array " : function ( hierarchy )  {%NWL%var nodes = hierarchy . sticky ( true ) . nodes ( { value: 1 , children: [ ] } ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 1 ) ;%NWL%hierarchy . nodes ( nodes [ 0 ] ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 1 ) ;%NWL%} ,%NWL%" a valueless node that has an empty children array gets a value of 0 " : function ( hierarchy )  {%NWL%var nodes = hierarchy . sticky ( true ) . nodes ( { children: [ ] } ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 0 ) ;%NWL%assert . equal ( nodes [ 0 ] . value , 0 ) ;%NWL%9
suite . addBatch ( {%NWL%" histogram " : {%NWL%topic: function ( )  {%NWL%return d3 . layout . histogram;%NWL%} ,%NWL%" defaults to frequencies " : function ( histogram )  {%NWL%var h = histogram ( ) ;%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( elements ) ,  [ [ 0 , 0 , 0 ] ,  [ ] ,  [ 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%} ,%NWL%" each bin contains the matching source elements " : function ( histogram )  {%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( elements ) ,  [ [ 0 , 0 , 0 ] ,  [ ] ,  [ 1 ] ,  [ 2 , 2 ] ] ) ;%NWL%7
" each bin also has defined x , y and dx properties " : function ( histogram )  {%NWL%var h = histogram ( ) ;%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( metadata ) ,  [%NWL%{ x:  0 , y: 3 , dx: 0 . 5 } ,%NWL%{ x: 0 . 5 , y: 0 , dx: 0 . 5 } ,%NWL%{ x:  1 , y: 1 , dx: 0 . 5 } ,%NWL%{ x: 1 . 5 , y: 2 , dx: 0 . 5 }%NWL%] ) ;%NWL%} ,%NWL%" can output frequencies " : function ( histogram )  {%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( metadata ) ,  [%NWL%2
" can output frequencies " : function ( histogram )  {%NWL%var h = histogram ( ) . frequency ( true ) ;%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( metadata ) ,  [%NWL%{ x:  0 , y: 3 , dx: 0 . 5 } ,%NWL%{ x: 0 . 5 , y: 0 , dx: 0 . 5 } ,%NWL%{ x:  1 , y: 1 , dx: 0 . 5 } ,%NWL%{ x: 1 . 5 , y: 2 , dx: 0 . 5 }%NWL%] ) ;%NWL%} ,%NWL%" can output probabilities " : function ( histogram )  {%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( metadata ) ,  [%NWL%2
assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( elements ) ,  [%NWL%[ 0 , 0 , 0 ] ,%NWL%[ 1 , 2 , 2 ]%NWL%] ) ;%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( metadata ) ,  [%NWL%{ x: 0 , y: 3 , dx: 1 } ,%NWL%{ x: 1 , y: 3 , dx: 1 }%NWL%] ) ;%NWL%} ,%NWL%" can specify bin thresholds " : function ( histogram )  {%NWL%assert . deepEqual ( h ( [ 0 , 0 , 0 , 1 , 2 , 2 ] ) . map ( elements ) ,  [%NWL%0
" category20b " : category ( d3 . scale . category20b , 20 ) ,%NWL%" category20c " : category ( d3 . scale . category20c , 20 )%NWL%} ) ;%NWL%function category ( category , n )  {%NWL%return {%NWL%" is an ordinal scale " : function ( )  {%NWL%var x = category ( ) , colors = x . range ( ) ;%NWL%assert . lengthOf ( x . domain ( ) , 0 ) ;%NWL%assert . lengthOf ( x . range ( ) , n ) ;%NWL%assert . equal ( x ( 1 ) , colors [ 0 ] ) ;%NWL%assert . equal ( x ( 1 ) , colors [ 0 ] ) ;%NWL%9
assert . deepEqual ( y . range ( ) , x . range ( ) ) ;%NWL%x . domain ( d3 . range ( n ) ) ;%NWL%for ( var i = 0; i < n; + + i ) assert . equal ( x ( i + n ) , x ( i ) ) ;%NWL%assert . equal ( y ( 1 ) , colors [ 0 ] ) ;%NWL%assert . equal ( y ( 2 ) , colors [ 1 ] ) ;%NWL%} ,%NWL%" each instance is isolated " : function ( )  {%NWL%var a = category ( ) , b = category ( ) , colors = a . range ( ) ;%NWL%assert . equal ( a ( 1 ) , colors [ 0 ] ) ;%NWL%assert . equal ( b ( 2 ) , colors [ 0 ] ) ;%NWL%assert . equal ( a ( 1 ) , colors [ 0 ] ) ;%NWL%8
. call ( position )%NWL%. append ( " rect " )%NWL%. attr ( " class " , " d3plus_color " )%NWL%. attr ( " stroke " ,  " none " )%NWL%. call ( style ) ;%NWL%keys . order ( )%NWL%. transition ( ) . duration ( vars . draw . timing )%NWL%. call ( position )%NWL%. attr ( " opacity " , 1 )%NWL%. selectAll ( " rect . d3plus_color " )%NWL%keys . exit ( )%NWL%5
}%NWL%if ( vars . margin . bottom === 0 )  {%NWL%vars . margin . bottom + = vars . ui . padding;%NWL%}%NWL%vars . margin . bottom + = key_height;%NWL%vars . g . legend . transition ( ) . duration ( vars . draw . timing )%NWL%. attr ( " transform " , " translate ( 0 , " + ( vars . height . value - vars . margin . bottom ) + " ) " )%NWL%if ( vars . dev . value ) print . timeEnd ( " positioning legend " )%NWL%}%NWL%else {%NWL%vars . g . legend . transition ( ) . duration ( vars . draw . timing )%NWL%5
" coerces domain values to numbers " : function ( linear )  {%NWL%var x = linear ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( new Date ( 1989 , 09 , 20 ) ) ,  - . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%2
var x = linear ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( new Date ( 1989 , 09 , 20 ) ) ,  - . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = linear ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%2
assert . inDelta ( x ( new Date ( 1989 , 09 , 20 ) ) ,  - . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = linear ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%7
assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = linear ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%var x = linear ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%7
assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = linear ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%var x = linear ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%7
assert . inDelta ( x . invert ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%} ,%NWL%" does not coerce range to numbers " : function ( linear )  {%NWL%var x = linear ( ) . range ( [ " 0 " ,  " 2 " ] ) ;%NWL%assert . equal ( typeof x . range ( ) [ 0 ] ,  " string " ) ;%NWL%assert . equal ( typeof x . range ( ) [ 1 ] ,  " string " ) ;%NWL%} ,%NWL%" can specify range values as colors " : function ( linear )  {%NWL%var x = linear ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%9
" does not coerce range to numbers " : function ( linear )  {%NWL%var x = linear ( ) . range ( [ " 0 " ,  " 2 " ] ) ;%NWL%assert . equal ( typeof x . range ( ) [ 0 ] ,  " string " ) ;%NWL%assert . equal ( typeof x . range ( ) [ 1 ] ,  " string " ) ;%NWL%} ,%NWL%" can specify range values as colors " : function ( linear )  {%NWL%var x = linear ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = linear ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%7
assert . equal ( typeof x . range ( ) [ 0 ] ,  " string " ) ;%NWL%assert . equal ( typeof x . range ( ) [ 1 ] ,  " string " ) ;%NWL%} ,%NWL%" can specify range values as colors " : function ( linear )  {%NWL%var x = linear ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = linear ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = linear ( ) . range ( [ " #f00 " ,  " #00f " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%5
} ,%NWL%" can specify range values as colors " : function ( linear )  {%NWL%var x = linear ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = linear ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = linear ( ) . range ( [ " #f00 " ,  " #00f " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = linear ( ) . range ( [ d3 . rgb ( 255 , 0 , 0 ) , d3 . hsl ( 240 , 1 , . 5 ) ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%3
assert . isFalse ( x . clamp ( ) ) ;%NWL%assert . inDelta ( x ( - . 5 ) ,  - . 5 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) , 1 . 5 , 1e - 6 ) ;%NWL%} ,%NWL%" can clamp to the domain " : function ( linear )  {%NWL%var x = linear ( ) . clamp ( true ) ;%NWL%assert . inDelta ( x ( - . 5 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) , 1 , 1e - 6 ) ;%NWL%var x = linear ( ) . domain ( [ 1 , 0 ] ) . clamp ( true ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%7
assert . isNaN ( x . invert ( " #999 " ) ) ;%NWL%}%NWL%} ,%NWL%" ticks " : {%NWL%" generates ticks of varying degree " : function ( linear )  {%NWL%var x = linear ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%6
}%NWL%} ,%NWL%" ticks " : {%NWL%" generates ticks of varying degree " : function ( linear )  {%NWL%var x = linear ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%var x = linear ( ) . domain ( [ 1 , 0 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%6
} ,%NWL%" ticks " : {%NWL%" generates ticks of varying degree " : function ( linear )  {%NWL%var x = linear ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%var x = linear ( ) . domain ( [ 1 , 0 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%6
" ticks " : {%NWL%" generates ticks of varying degree " : function ( linear )  {%NWL%var x = linear ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%var x = linear ( ) . domain ( [ 1 , 0 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%6
assert . deepEqual ( x . range ( ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( y . range ( ) ,  [ 2 , 3 ] ) ;%NWL%} ,%NWL%" changes to the interpolator are isolated " : function ( linear )  {%NWL%var x = linear ( ) . range ( [ " red " ,  " blue " ] ) , y = x . copy ( ) ;%NWL%x . interpolate ( d3 . interpolateHsl ) ;%NWL%assert . equal ( x ( 0 . 5 ) ,  " #00ff00 " ) ;%NWL%assert . equal ( y ( 0 . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( y . interpolate ( ) , d3 . interpolate ) ;%NWL%} ,%NWL%var x = linear ( ) . clamp ( true ) , y = x . copy ( ) ;%NWL%4
assert . equal ( x ( 0 . 5 ) ,  " #00ff00 " ) ;%NWL%assert . equal ( y ( 0 . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( y . interpolate ( ) , d3 . interpolate ) ;%NWL%} ,%NWL%" changes to clamping are isolated " : function ( linear )  {%NWL%var x = linear ( ) . clamp ( true ) , y = x . copy ( ) ;%NWL%x . clamp ( false ) ;%NWL%assert . equal ( x ( 2 ) , 2 ) ;%NWL%assert . equal ( y ( 2 ) , 1 ) ;%NWL%assert . isTrue ( y . clamp ( ) ) ;%NWL%assert . equal ( x ( 2 ) , 2 ) ;%NWL%7
} ,%NWL%" domain " : {%NWL%" defaults to the empty array " : function ( ordinal )  {%NWL%assert . isEmpty ( ordinal ( ) . domain ( ) ) ;%NWL%} ,%NWL%" new input values are added to the domain " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " foo " ,  " bar " ] ) ;%NWL%assert . equal ( x ( 0 ) ,  " foo " ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ " 0 " ] ) ;%NWL%assert . equal ( x ( 1 ) ,  " bar " ) ;%NWL%assert . equal ( x ( 0 ) ,  " foo " ) ;%NWL%7
" domain " : {%NWL%" defaults to the empty array " : function ( ordinal )  {%NWL%assert . isEmpty ( ordinal ( ) . domain ( ) ) ;%NWL%} ,%NWL%" new input values are added to the domain " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " foo " ,  " bar " ] ) ;%NWL%assert . equal ( x ( 0 ) ,  " foo " ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ " 0 " ] ) ;%NWL%assert . equal ( x ( 1 ) ,  " bar " ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ " 0 " ,  " 1 " ] ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ " 0 " ,  " 1 " ] ) ;%NWL%9
assert . equal ( x ( 0 ) ,  " foo " ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ " 0 " ,  " 1 " ] ) ;%NWL%} ,%NWL%" setting the domain forgets previous values " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " foo " ,  " bar " ] ) ;%NWL%assert . equal ( x ( 1 ) ,  " foo " ) ;%NWL%assert . equal ( x ( 0 ) ,  " bar " ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ 1 , 0 ] ) ;%NWL%x . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( x ( 0 ) ,  " foo " ) ; / / it changed!%NWL%assert . deepEqual ( x . domain ( ) ,  [ " 0 " ,  " 1 " ] ) ;%NWL%1
assert . typeOf ( x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%}%NWL%} ,%NWL%" range " : {%NWL%" defaults to the empty array " : function ( ordinal )  {%NWL%var x = ordinal ( ) ;%NWL%assert . isEmpty ( x . range ( ) ) ;%NWL%assert . isUndefined ( x ( 0 ) ) ;%NWL%} ,%NWL%" setting the range remembers previous values " : function ( ordinal )  {%NWL%assert . isUndefined ( x ( 0 ) ) ;%NWL%7
assert . equal ( x ( 0 ) ,  " foo " ) ;%NWL%assert . equal ( x ( 1 ) ,  " bar " ) ;%NWL%} ,%NWL%" recycles values when exhausted " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%assert . equal ( x ( 3 ) ,  " a " ) ;%NWL%assert . equal ( x ( 4 ) ,  " b " ) ;%NWL%assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%7
assert . equal ( x ( 1 ) ,  " bar " ) ;%NWL%} ,%NWL%" recycles values when exhausted " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%assert . equal ( x ( 3 ) ,  " a " ) ;%NWL%assert . equal ( x ( 4 ) ,  " b " ) ;%NWL%assert . equal ( x ( 5 ) ,  " c " ) ;%NWL%assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%5
} ,%NWL%" recycles values when exhausted " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%assert . equal ( x ( 3 ) ,  " a " ) ;%NWL%assert . equal ( x ( 4 ) ,  " b " ) ;%NWL%assert . equal ( x ( 5 ) ,  " c " ) ;%NWL%assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%3
assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%assert . equal ( x ( 3 ) ,  " a " ) ;%NWL%assert . equal ( x ( 4 ) ,  " b " ) ;%NWL%assert . equal ( x ( 5 ) ,  " c " ) ;%NWL%assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%}%NWL%} ,%NWL%" maps distinct values to discrete values " : function ( ordinal )  {%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%6
assert . equal ( x ( 5 ) ,  " c " ) ;%NWL%assert . equal ( x ( 2 ) ,  " c " ) ;%NWL%assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%}%NWL%} ,%NWL%" maps distinct values to discrete values " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%assert . equal ( x ( 0 ) ,  " a " ) ;%NWL%assert . equal ( x ( " 0 " ) ,  " a " ) ;%NWL%assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%2
assert . equal ( x ( 1 ) ,  " b " ) ;%NWL%assert . equal ( x ( 2 . 0 ) ,  " c " ) ;%NWL%assert . equal ( x ( new Number ( 2 ) ) ,  " c " ) ;%NWL%} ,%NWL%" rangePoints " : {%NWL%" computes discrete points in a continuous range " : function ( ordinal )  {%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangePoints ( [ 0 , 120 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 0 , 60 , 120 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 0 ) ;%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangePoints ( [ 0 , 120 ] , 1 ) ;%NWL%assert . equal ( x . rangeBand ( ) , 0 ) ;%NWL%8
} ,%NWL%" rangePoints " : {%NWL%" computes discrete points in a continuous range " : function ( ordinal )  {%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangePoints ( [ 0 , 120 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 0 , 60 , 120 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 0 ) ;%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangePoints ( [ 0 , 120 ] , 1 ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 20 , 60 , 100 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 0 ) ;%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangePoints ( [ 0 , 120 ] , 2 ) ;%NWL%assert . equal ( x . rangeBand ( ) , 0 ) ;%NWL%5
var x = ordinal ( ) . rangeRoundBands ( [ 0 , 100 ] ) . domain ( [ " a " ,  " b " ,  " c " ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 1 , 34 , 67 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 33 ) ;%NWL%x . domain ( [ " a " ,  " b " ,  " c " ,  " d " ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 0 , 25 , 50 , 75 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 25 ) ;%NWL%}%NWL%} ,%NWL%" rangeRoundBands " : {%NWL%" computes discrete rounded bands in a continuous range " : function ( ordinal )  {%NWL%assert . deepEqual ( x . range ( ) ,  [ 1 , 34 , 67 ] ) ;%NWL%1
assert . deepEqual ( x . range ( ) ,  [ 1 , 34 , 67 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 33 ) ;%NWL%x . domain ( [ " a " ,  " b " ,  " c " ,  " d " ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 0 , 25 , 50 , 75 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 25 ) ;%NWL%}%NWL%} ,%NWL%" rangeRoundBands " : {%NWL%" computes discrete rounded bands in a continuous range " : function ( ordinal )  {%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangeRoundBands ( [ 0 , 100 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 33 ) ;%NWL%1
assert . deepEqual ( x . range ( ) ,  [ 0 , 25 , 50 , 75 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 25 ) ;%NWL%}%NWL%} ,%NWL%" rangeRoundBands " : {%NWL%" computes discrete rounded bands in a continuous range " : function ( ordinal )  {%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangeRoundBands ( [ 0 , 100 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 1 , 34 , 67 ] ) ;%NWL%assert . equal ( x . rangeBand ( ) , 33 ) ;%NWL%var x = ordinal ( ) . domain ( [ " a " ,  " b " ,  " c " ] ) . rangeRoundBands ( [ 0 , 100 ] ,  . 2 ) ;%NWL%assert . equal ( x . rangeBand ( ) , 25 ) ;%NWL%1
assert . equal ( y ( 1 ) ,  " foo " ) ;%NWL%y . domain ( [ 2 , 3 ] ) ;%NWL%assert . equal ( x ( 2 ) ,  " bar " ) ;%NWL%assert . equal ( y ( 2 ) ,  " foo " ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ " 1 " ,  " 2 " ] ) ;%NWL%assert . deepEqual ( y . domain ( ) ,  [ " 2 " ,  " 3 " ] ) ;%NWL%} ,%NWL%" changes to the range are isolated " : function ( ordinal )  {%NWL%var x = ordinal ( ) . range ( [ " foo " ,  " bar " ] ) , y = x . copy ( ) ;%NWL%x . range ( [ " bar " ,  " foo " ] ) ;%NWL%assert . equal ( y ( 1 ) ,  " foo " ) ;%NWL%0
} ,%NWL%" changes to the range type are isolated " : function ( ordinal )  {%NWL%var x = ordinal ( ) . domain ( [ 0 , 1 ] ) . rangeBands ( [ 0 , 1 ] ,  . 2 ) , y = x . copy ( ) ;%NWL%x . rangePoints ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 0 ) , 1 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 ) , 2 , 1e - 6 ) ;%NWL%assert . inDelta ( x . rangeBand ( ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( 0 ) , 1 / 11 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( 1 ) , 6 / 11 , 1e - 6 ) ;%NWL%assert . inDelta ( y . rangeBand ( ) , 4 / 11 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 0 ) , 1 , 1e - 6 ) ;%NWL%4
" changes to the range type are isolated " : function ( ordinal )  {%NWL%var x = ordinal ( ) . domain ( [ 0 , 1 ] ) . rangeBands ( [ 0 , 1 ] ,  . 2 ) , y = x . copy ( ) ;%NWL%x . rangePoints ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 0 ) , 1 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 ) , 2 , 1e - 6 ) ;%NWL%assert . inDelta ( x . rangeBand ( ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( 0 ) , 1 / 11 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( 1 ) , 6 / 11 , 1e - 6 ) ;%NWL%assert . inDelta ( y . rangeBand ( ) , 4 / 11 , 1e - 6 ) ;%NWL%y . rangeBands ( [ 0 , 1 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 2 , 1e - 6 ) ;%NWL%4
var x = ordinal ( ) . domain ( [ 0 , 1 ] ) . rangeBands ( [ 0 , 1 ] ,  . 2 ) , y = x . copy ( ) ;%NWL%x . rangePoints ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 0 ) , 1 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 ) , 2 , 1e - 6 ) ;%NWL%assert . inDelta ( x . rangeBand ( ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( 0 ) , 1 / 11 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( 1 ) , 6 / 11 , 1e - 6 ) ;%NWL%assert . inDelta ( y . rangeBand ( ) , 4 / 11 , 1e - 6 ) ;%NWL%y . rangeBands ( [ 0 , 1 ] ) ;%NWL%assert . inDelta ( x ( 0 ) , 1 , 1e - 6 ) ;%NWL%assert . inDelta ( x . rangeBand ( ) , 0 , 1e - 6 ) ;%NWL%4
" coerces domain to numbers " : function ( pow )  {%NWL%var x = pow ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( new Date ( 1989 , 09 , 20 ) ) ,  - . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%2
var x = pow ( ) . domain ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( new Date ( 1989 , 09 , 20 ) ) ,  - . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = pow ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%2
assert . inDelta ( x ( new Date ( 1989 , 09 , 20 ) ) ,  - . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = pow ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%7
assert . inDelta ( x ( new Date ( 1990 , 00 , 01 ) ) , 0 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = pow ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%var x = pow ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%7
assert . inDelta ( x ( new Date ( 1990 , 02 , 15 ) ) ,  . 2 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1990 , 04 , 27 ) ) ,  . 4 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 00 , 01 ) ) , 1 , 1e - 2 ) ;%NWL%assert . inDelta ( x ( new Date ( 1991 , 02 , 15 ) ) , 1 . 2 , 1e - 2 ) ;%NWL%var x = pow ( ) . domain ( [ " 0 " ,  " 1 " ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 1 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%var x = pow ( ) . domain ( [ new Number ( 0 ) , new Number ( 1 ) ] ) ;%NWL%assert . equal ( typeof x . domain ( ) [ 0 ] ,  " number " ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%7
var x = pow ( ) . range ( [ " 0 " ,  " 2 " ] ) ;%NWL%assert . inDelta ( x . invert ( " 1 " ) ,  . 5 , 1e - 6 ) ;%NWL%var x = pow ( ) . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%assert . inDelta ( x . invert ( new Date ( 1990 , 6 , 2 , 13 ) ) ,  . 5 , 1e - 6 ) ;%NWL%var x = pow ( ) . range ( [ " #000 " ,  " #fff " ] ) ;%NWL%assert . isNaN ( x . invert ( " #999 " ) ) ;%NWL%} ,%NWL%" can specify range values as colors " : function ( pow )  {%NWL%var x = pow ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%9
var x = pow ( ) . range ( [ new Date ( 1990 , 0 , 1 ) , new Date ( 1991 , 0 , 1 ) ] ) ;%NWL%assert . inDelta ( x . invert ( new Date ( 1990 , 6 , 2 , 13 ) ) ,  . 5 , 1e - 6 ) ;%NWL%var x = pow ( ) . range ( [ " #000 " ,  " #fff " ] ) ;%NWL%assert . isNaN ( x . invert ( " #999 " ) ) ;%NWL%} ,%NWL%" can specify range values as colors " : function ( pow )  {%NWL%var x = pow ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = pow ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%7
var x = pow ( ) . range ( [ " #000 " ,  " #fff " ] ) ;%NWL%assert . isNaN ( x . invert ( " #999 " ) ) ;%NWL%} ,%NWL%" can specify range values as colors " : function ( pow )  {%NWL%var x = pow ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = pow ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = pow ( ) . range ( [ " #f00 " ,  " #00f " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%5
} ,%NWL%" can specify range values as colors " : function ( pow )  {%NWL%var x = pow ( ) . range ( [ " red " ,  " blue " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = pow ( ) . range ( [ " #ff0000 " ,  " #0000ff " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = pow ( ) . range ( [ " #f00 " ,  " #00f " ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%var x = pow ( ) . range ( [ d3 . rgb ( 255 , 0 , 0 ) , d3 . hsl ( 240 , 1 , . 5 ) ] ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( x ( . 5 ) ,  " #800080 " ) ;%NWL%3
" defaults to one " : function ( pow )  {%NWL%var x = pow ( ) ;%NWL%assert . equal ( x . exponent ( ) , 1 ) ;%NWL%} ,%NWL%" observes the specified exponent " : function ( pow )  {%NWL%var x = pow ( ) . exponent ( . 5 ) . domain ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%6
assert . equal ( x . exponent ( ) , 1 ) ;%NWL%} ,%NWL%" observes the specified exponent " : function ( pow )  {%NWL%var x = pow ( ) . exponent ( . 5 ) . domain ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%var x = pow ( ) . exponent ( 2 ) . domain ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%6
var x = pow ( ) . exponent ( . 5 ) . domain ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%var x = pow ( ) . exponent ( 2 ) . domain ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) ,  . 41666667 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) , 2 ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%1
assert . inDelta ( x ( 1 . 5 ) , 0 . 5425821 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%var x = pow ( ) . exponent ( 2 ) . domain ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) ,  . 41666667 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) , 2 ) ;%NWL%var x = pow ( ) . exponent ( - 1 ) . domain ( [ 1 , 2 ] ) ;%NWL%assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%1
assert . inDelta ( x ( 1 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) ,  . 6666667 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  - 1 ) ;%NWL%} ,%NWL%" changing the exponent does not change the domain or range " : function ( pow )  {%NWL%var x = pow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) , f = d3 . format ( " . 6f " ) ;%NWL%x . exponent ( . 5 ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%8
assert . inDelta ( x ( 1 . 5 ) ,  . 6666667 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  - 1 ) ;%NWL%} ,%NWL%" changing the exponent does not change the domain or range " : function ( pow )  {%NWL%var x = pow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) , f = d3 . format ( " . 6f " ) ;%NWL%x . exponent ( . 5 ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( 2 ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%8
assert . equal ( x . exponent ( ) ,  - 1 ) ;%NWL%} ,%NWL%" changing the exponent does not change the domain or range " : function ( pow )  {%NWL%var x = pow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) , f = d3 . format ( " . 6f " ) ;%NWL%x . exponent ( . 5 ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( 2 ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%5
} ,%NWL%" changing the exponent does not change the domain or range " : function ( pow )  {%NWL%var x = pow ( ) . domain ( [ 1 , 2 ] ) . range ( [ 3 , 4 ] ) , f = d3 . format ( " . 6f " ) ;%NWL%x . exponent ( . 5 ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( 2 ) ;%NWL%assert . deepEqual ( x . domain ( ) . map ( f ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%x . exponent ( - 1 ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 3 , 4 ] ) ;%NWL%5
assert . isFalse ( x . clamp ( ) ) ;%NWL%assert . inDelta ( x ( - . 5 ) ,  - . 5 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) , 1 . 5 , 1e - 6 ) ;%NWL%} ,%NWL%" can clamp to the domain " : function ( pow )  {%NWL%var x = pow ( ) . clamp ( true ) ;%NWL%assert . inDelta ( x ( - . 5 ) , 0 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 1 . 5 ) , 1 , 1e - 6 ) ;%NWL%var x = pow ( ) . domain ( [ 1 , 0 ] ) . clamp ( true ) ;%NWL%assert . inDelta ( x ( . 5 ) ,  . 5 , 1e - 6 ) ;%NWL%7
assert . inDelta ( x ( 2 ) , 1 , 1e - 6 ) ;%NWL%assert . inDelta ( x ( 2 . 5 ) , 1 . 5 , 1e - 6 ) ;%NWL%} ,%NWL%" ticks " : {%NWL%" can generate ticks of varying degree " : function ( pow )  {%NWL%var x = pow ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%6
assert . inDelta ( x ( 2 . 5 ) , 1 . 5 , 1e - 6 ) ;%NWL%} ,%NWL%" ticks " : {%NWL%" can generate ticks of varying degree " : function ( pow )  {%NWL%var x = pow ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%var x = pow ( ) . domain ( [ 1 , 0 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%6
} ,%NWL%" ticks " : {%NWL%" can generate ticks of varying degree " : function ( pow )  {%NWL%var x = pow ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%var x = pow ( ) . domain ( [ 1 , 0 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%6
" ticks " : {%NWL%" can generate ticks of varying degree " : function ( pow )  {%NWL%var x = pow ( ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 5 ) . map ( x . tickFormat ( 5 ) ) ,  [ 0 ,  . 2 ,  . 4 ,  . 6 ,  . 8 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%var x = pow ( ) . domain ( [ 1 , 0 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 1 ) . map ( x . tickFormat ( 1 ) ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 2 ) . map ( x . tickFormat ( 2 ) ) ,  [ 0 ,  . 5 , 1 ] ) ;%NWL%assert . deepEqual ( x . ticks ( 10 ) . map ( x . tickFormat ( 10 ) ) ,  [ 0 ,  . 1 ,  . 2 ,  . 3 ,  . 4 ,  . 5 ,  . 6 ,  . 7 ,  . 8 ,  . 9 , 1 ] ) ;%NWL%6
assert . deepEqual ( x . range ( ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( y . range ( ) ,  [ 2 , 3 ] ) ;%NWL%} ,%NWL%" changes to the exponent are isolated " : function ( pow )  {%NWL%var x = pow ( ) . exponent ( 2 ) , y = x . copy ( ) ;%NWL%x . exponent ( . 5 ) ;%NWL%assert . inDelta ( x ( . 5 ) , Math . SQRT1_2 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( . 5 ) , 0 . 25 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%assert . equal ( y . exponent ( ) , 2 ) ;%NWL%assert . inDelta ( x ( . 5 ) , Math . SQRT1_2 , 1e - 6 ) ;%NWL%6
} ,%NWL%" changes to the exponent are isolated " : function ( pow )  {%NWL%var x = pow ( ) . exponent ( 2 ) , y = x . copy ( ) ;%NWL%x . exponent ( . 5 ) ;%NWL%assert . inDelta ( x ( . 5 ) , Math . SQRT1_2 , 1e - 6 ) ;%NWL%assert . inDelta ( y ( . 5 ) , 0 . 25 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%assert . equal ( y . exponent ( ) , 2 ) ;%NWL%y . exponent ( 3 ) ;%NWL%assert . inDelta ( x ( . 5 ) , Math . SQRT1_2 , 1e - 6 ) ;%NWL%assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%6
assert . equal ( x . exponent ( ) ,  . 5 ) ;%NWL%assert . equal ( y . exponent ( ) , 3 ) ;%NWL%} ,%NWL%" changes to the interpolator are isolated " : function ( pow )  {%NWL%var x = pow ( ) . range ( [ " red " ,  " blue " ] ) , y = x . copy ( ) ;%NWL%x . interpolate ( d3 . interpolateHsl ) ;%NWL%assert . equal ( x ( 0 . 5 ) ,  " #00ff00 " ) ;%NWL%assert . equal ( y ( 0 . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( y . interpolate ( ) , d3 . interpolate ) ;%NWL%} ,%NWL%var x = pow ( ) . clamp ( true ) , y = x . copy ( ) ;%NWL%4
assert . equal ( x ( 0 . 5 ) ,  " #00ff00 " ) ;%NWL%assert . equal ( y ( 0 . 5 ) ,  " #800080 " ) ;%NWL%assert . equal ( y . interpolate ( ) , d3 . interpolate ) ;%NWL%} ,%NWL%" changes to clamping are isolated " : function ( pow )  {%NWL%var x = pow ( ) . clamp ( true ) , y = x . copy ( ) ;%NWL%x . clamp ( false ) ;%NWL%assert . equal ( x ( 2 ) , 2 ) ;%NWL%assert . equal ( y ( 2 ) , 1 ) ;%NWL%assert . isTrue ( y . clamp ( ) ) ;%NWL%assert . equal ( x ( 2 ) , 2 ) ;%NWL%7
} ,%NWL%" has the empty range by default " : function ( quantile )  {%NWL%assert . isEmpty ( quantile ( ) . range ( ) ) ;%NWL%} ,%NWL%" uses the R - 7 algorithm to compute quantiles " : function ( quantile )  {%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%assert . deepEqual ( [ 8 , 8 . 9 ] . map ( x ) ,  [ 1 , 1 ] ) ;%NWL%assert . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( x ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%assert . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( x ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%6
" has the empty range by default " : function ( quantile )  {%NWL%assert . isEmpty ( quantile ( ) . range ( ) ) ;%NWL%} ,%NWL%" uses the R - 7 algorithm to compute quantiles " : function ( quantile )  {%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%assert . deepEqual ( [ 8 , 8 . 9 ] . map ( x ) ,  [ 1 , 1 ] ) ;%NWL%assert . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( x ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%assert . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( x ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%assert . deepEqual ( [ 8 , 8 . 9 ] . map ( x ) ,  [ 1 , 1 ] ) ;%NWL%6
assert . isEmpty ( quantile ( ) . range ( ) ) ;%NWL%} ,%NWL%" uses the R - 7 algorithm to compute quantiles " : function ( quantile )  {%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%assert . deepEqual ( [ 8 , 8 . 9 ] . map ( x ) ,  [ 1 , 1 ] ) ;%NWL%assert . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( x ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%assert . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( x ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%assert . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( x ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%6
} ,%NWL%" uses the R - 7 algorithm to compute quantiles " : function ( quantile )  {%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%assert . deepEqual ( [ 8 , 8 . 9 ] . map ( x ) ,  [ 1 , 1 ] ) ;%NWL%assert . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( x ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%assert . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( x ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 3 , 6 , 7 , 8 , 8 , 9 , 10 , 13 , 15 , 16 , 20 ] ) . range ( [ 0 , 1 , 2 , 3 ] ) ;%NWL%assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%assert . deepEqual ( [ 8 , 8 . 9 ] . map ( x ) ,  [ 1 , 1 ] ) ;%NWL%assert . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( x ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%6
assert . deepEqual ( [ 3 , 6 , 6 . 9 , 7 , 7 . 1 ] . map ( x ) ,  [ 0 , 0 , 0 , 0 , 0 ] ) ;%NWL%assert . deepEqual ( [ 8 , 8 . 9 ] . map ( x ) ,  [ 1 , 1 ] ) ;%NWL%assert . deepEqual ( [ 9 , 9 . 1 , 10 , 13 ] . map ( x ) ,  [ 2 , 2 , 2 , 2 ] ) ;%NWL%assert . deepEqual ( [ 14 . 9 , 15 , 15 . 1 , 16 , 20 ] . map ( x ) ,  [ 3 , 3 , 3 , 3 , 3 ] ) ;%NWL%} ,%NWL%" domain values are sorted in ascending order " : function ( quantile )  {%NWL%var x = d3 . scale . quantile ( ) . domain ( [ 6 , 3 , 7 , 8 , 8 , 13 , 20 , 15 , 16 , 10 ] ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) ;%NWL%} ,%NWL%" non - numeric domain values are ignored " : function ( quantile )  {%NWL%assert . deepEqual ( x . domain ( ) ,  [ 3 , 6 , 7 , 8 , 8 , 10 , 13 , 15 , 16 , 20 ] ) ;%NWL%7
} ,%NWL%" radius is an alias for setting innerRadius and outerRadius " : function ( area )  {%NWL%var a = area ( ) . radius ( f ) ;%NWL%function f ( )  { }%NWL%assert . equal ( a . radius ( ) , f ) ;%NWL%assert . equal ( a . innerRadius ( ) , f ) ;%NWL%assert . equal ( a . outerRadius ( ) , f ) ;%NWL%} ,%NWL%" radius is an alias for getting outerRadius " : function ( area )  {%NWL%var a = area ( ) . outerRadius ( f ) ;%NWL%assert . equal ( a . radius ( ) , f ) ;%NWL%4
} ,%NWL%" angle is an alias for setting startAngle and endAngle " : function ( area )  {%NWL%var a = area ( ) . angle ( f ) ;%NWL%function f ( )  { }%NWL%assert . equal ( a . angle ( ) , f ) ;%NWL%assert . equal ( a . startAngle ( ) , f ) ;%NWL%assert . equal ( a . endAngle ( ) , f ) ;%NWL%} ,%NWL%" angle is an alias for getting endAngle " : function ( area )  {%NWL%var a = area ( ) . endAngle ( f ) ;%NWL%assert . equal ( a . angle ( ) , f ) ;%NWL%4
} ,%NWL%" x is an alias for setting x0 and x1 " : function ( area )  {%NWL%var a = area ( ) . x ( f ) ;%NWL%function f ( )  { }%NWL%assert . equal ( a . x ( ) , f ) ;%NWL%assert . equal ( a . x0 ( ) , f ) ;%NWL%assert . equal ( a . x1 ( ) , f ) ;%NWL%} ,%NWL%" x is an alias for getting x1 " : function ( area )  {%NWL%var a = area ( ) . x1 ( f ) ;%NWL%assert . equal ( a . x ( ) , f ) ;%NWL%4
} ,%NWL%" y is an alias for setting y0 and y1 " : function ( area )  {%NWL%var a = area ( ) . y ( f ) ;%NWL%function f ( )  { }%NWL%assert . equal ( a . y ( ) , f ) ;%NWL%assert . equal ( a . y0 ( ) , f ) ;%NWL%assert . equal ( a . y1 ( ) , f ) ;%NWL%} ,%NWL%" y is an alias for getting x1 " : function ( area )  {%NWL%var a = area ( ) . y1 ( f ) ;%NWL%assert . equal ( a . y ( ) , f ) ;%NWL%4
} )%NWL%. style ( " margin - top " , function ( ) {%NWL%if ( size == " large " )  {%NWL%var height = this . offsetHeight || this . getBoundingClientRect ( ) . height%NWL%return - height / 2 + " px "%NWL%}%NWL%return " 0px "%NWL%} )%NWL%}%NWL%vars . g . message = vars . container . value . selectAll ( " div#d3plus_message " )%NWL%var enter = vars . g . message . enter ( ) . append ( " div " )%NWL%3
require ( " . . / . . / d3 " ) ;%NWL%var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . svg . axis " ) ;%NWL%suite . addBatch ( {%NWL%" axis " : {%NWL%topic: function ( )  {%NWL%return d3 . svg . axis;%NWL%} ,%NWL%" scale " : {%NWL%var a = axis ( ) , x = a . scale ( ) ;%NWL%1
topic: function ( )  {%NWL%return d3 . svg . axis;%NWL%} ,%NWL%" scale " : {%NWL%" defaults to a linear scale " : function ( axis )  {%NWL%var a = axis ( ) , x = a . scale ( ) ;%NWL%assert . deepEqual ( x . domain ( ) ,  [ 0 , 1 ] ) ;%NWL%assert . deepEqual ( x . range ( ) ,  [ 0 , 1 ] ) ;%NWL%assert . equal ( x ( 0 . 5 ) , 0 . 5 ) ;%NWL%} ,%NWL%var x = d3 . scale . linear ( ) , a = axis ( ) . scale ( x ) ;%NWL%5
" tickSize " : {%NWL%" defaults to six pixels " : function ( axis )  {%NWL%var a = axis ( ) ;%NWL%assert . equal ( a . tickSize ( ) , 6 ) ;%NWL%} ,%NWL%" can be defined as a number " : function ( axis )  {%NWL%var a = axis ( ) . tickSize ( 3 ) ;%NWL%assert . equal ( a . tickSize ( ) , 3 ) ;%NWL%} ,%NWL%" coerces input value to a number " : function ( axis )  {%NWL%assert . strictEqual ( a . tickSize ( ) , 3 ) ;%NWL%7
" tickPadding " : {%NWL%" defaults to three pixels " : function ( axis )  {%NWL%var a = axis ( ) ;%NWL%assert . equal ( a . tickPadding ( ) , 3 ) ;%NWL%} ,%NWL%" can be defined as a number " : function ( axis )  {%NWL%var a = axis ( ) . tickPadding ( 6 ) ;%NWL%assert . equal ( a . tickPadding ( ) , 6 ) ;%NWL%} ,%NWL%" coerces input value to a number " : function ( axis )  {%NWL%assert . strictEqual ( a . tickPadding ( ) , 6 ) ;%NWL%7
var a = symbol ( ) . type ( " cross " ) . size ( Number ) ;%NWL%assert . pathEqual ( a ( 0 ) ,  " M0 , 0H0V0H0V0H0V0H0V0H0V0H0Z " ) ;%NWL%assert . pathEqual ( a ( 20 ) ,  " M - 3 , - 1H - 1V - 3H1V - 1H3V1H1V3H - 1V1H - 3Z " ) ;%NWL%} ,%NWL%" supports diamond symbol type " : function ( symbol )  {%NWL%var a = symbol ( ) . type ( " diamond " ) . size ( Number ) ;%NWL%assert . pathEqual ( a ( 0 ) ,  " M0 , 0L0 , 0 0 , 0 0 , 0Z " ) ;%NWL%assert . pathEqual ( a ( 10 ) ,  " M0 , - 2 . 9428309563827124L1 . 6990442448471224 , 0 0 , 2 . 9428309563827124 - 1 . 6990442448471224 , 0Z " ) ;%NWL%} ,%NWL%" supports square symbol type " : function ( symbol )  {%NWL%assert . pathEqual ( a ( 0 ) ,  " M0 , 0L0 , 0 0 , 0 0 , 0Z " ) ;%NWL%6
assert . pathEqual ( a ( 0 ) ,  " M0 , 0L0 , 0 0 , 0 0 , 0Z " ) ;%NWL%assert . pathEqual ( a ( 4 ) ,  " M - 1 , - 1L1 , - 1 1 , 1 - 1 , 1Z " ) ;%NWL%assert . pathEqual ( a ( 16 ) ,  " M - 2 , - 2L2 , - 2 2 , 2 - 2 , 2Z " ) ;%NWL%} ,%NWL%" supports triangle - down symbol type " : function ( symbol )  {%NWL%var a = symbol ( ) . type ( " triangle - down " ) . size ( Number ) ;%NWL%assert . pathEqual ( a ( 0 ) ,  " M0 , 0L0 , 0 0 , 0Z " ) ;%NWL%assert . pathEqual ( a ( 10 ) ,  " M0 , 2 . 0808957251439084L2 . 4028114141347543 , - 2 . 0808957251439084 - 2 . 4028114141347543 , - 2 . 0808957251439084Z " ) ;%NWL%} ,%NWL%" supports triangle - up symbol type " : function ( symbol )  {%NWL%assert . pathEqual ( a ( 0 ) ,  " M0 , 0L0 , 0 0 , 0Z " ) ;%NWL%6
assert . deepEqual ( p ( " Wednesday 02 / 03 / 1991 " ) , local ( 1991 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " Caturday 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses numeric date " : function ( format )  {%NWL%var p = format ( " %m / %d / %y " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , local ( 2090 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , local ( 2091 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses locale date " : function ( format )  {%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , local ( 2090 , 0 , 1 ) ) ;%NWL%5
assert . isNull ( p ( " Caturday 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses numeric date " : function ( format )  {%NWL%var p = format ( " %m / %d / %y " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , local ( 2090 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , local ( 2091 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses locale date " : function ( format )  {%NWL%var p = format ( " %x " ) . parse;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , local ( 2091 , 1 , 3 ) ) ;%NWL%5
} ,%NWL%" parses numeric date " : function ( format )  {%NWL%var p = format ( " %m / %d / %y " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , local ( 2090 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , local ( 2091 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses locale date " : function ( format )  {%NWL%var p = format ( " %x " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , local ( 2090 , 0 , 1 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%5
" parses month , date and year " : function ( format )  {%NWL%var p = format ( " %B %d , %Y " ) . parse;%NWL%assert . deepEqual ( p ( " january 01 , 1990 " ) , local ( 1990 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " February 2 , 2010 " ) , local ( 2010 , 1 , 2 ) ) ;%NWL%assert . isNull ( p ( " jan 1 , 1990 " ) ) ;%NWL%} ,%NWL%" parses locale date and time " : function ( format )  {%NWL%var p = format ( " %c " ) . parse;%NWL%assert . deepEqual ( p ( " Mon Jan 1 00:00:00 1990 " ) , local ( 1990 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " Sun Jan 1 00:00:00 1990 " ) , local ( 1990 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " Mon Jan 1 00:00:00 1990 " ) , local ( 1990 , 0 , 1 ) ) ;%NWL%8
} ,%NWL%" parses twenty - four hour , minute and second " : function ( format )  {%NWL%var p = format ( " %H:%M:%S " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%3
" parses twenty - four hour , minute and second " : function ( format )  {%NWL%var p = format ( " %H:%M:%S " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%3
var p = format ( " %H:%M:%S " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%3
assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%3
assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , local ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , local ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , local ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , local ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%3
assert . deepEqual ( p ( " Wednesday 02 / 03 / 1991 " ) , utc ( 1991 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " Caturday 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses numeric date " : function ( format )  {%NWL%var p = format ( " %m / %d / %y " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , utc ( 2090 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , utc ( 2091 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses locale date " : function ( format )  {%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , utc ( 2090 , 0 , 1 ) ) ;%NWL%5
assert . isNull ( p ( " Caturday 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses numeric date " : function ( format )  {%NWL%var p = format ( " %m / %d / %y " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , utc ( 2090 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , utc ( 2091 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses locale date " : function ( format )  {%NWL%var p = format ( " %x " ) . parse;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , utc ( 2091 , 1 , 3 ) ) ;%NWL%5
} ,%NWL%" parses numeric date " : function ( format )  {%NWL%var p = format ( " %m / %d / %y " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , utc ( 2090 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 02 / 03 / 91 " ) , utc ( 2091 , 1 , 3 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%} ,%NWL%" parses locale date " : function ( format )  {%NWL%var p = format ( " %x " ) . parse;%NWL%assert . deepEqual ( p ( " 01 / 01 / 90 " ) , utc ( 2090 , 0 , 1 ) ) ;%NWL%assert . isNull ( p ( " 03 / 10 / 2010 " ) ) ;%NWL%5
" parses month , date and year " : function ( format )  {%NWL%var p = format ( " %B %d , %Y " ) . parse;%NWL%assert . deepEqual ( p ( " january 01 , 1990 " ) , utc ( 1990 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " February 2 , 2010 " ) , utc ( 2010 , 1 , 2 ) ) ;%NWL%assert . isNull ( p ( " jan 1 , 1990 " ) ) ;%NWL%} ,%NWL%" parses locale date and time " : function ( format )  {%NWL%var p = format ( " %c " ) . parse;%NWL%assert . deepEqual ( p ( " Mon Jan 1 00:00:00 1990 " ) , utc ( 1990 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " Sun Jan 1 00:00:00 1990 " ) , utc ( 1990 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " Mon Jan 1 00:00:00 1990 " ) , utc ( 1990 , 0 , 1 ) ) ;%NWL%8
} ,%NWL%" parses twenty - four hour , minute and second " : function ( format )  {%NWL%var p = format ( " %H:%M:%S " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%3
" parses twenty - four hour , minute and second " : function ( format )  {%NWL%var p = format ( " %H:%M:%S " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%3
var p = format ( " %H:%M:%S " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%3
assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%3
assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:01 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 1 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%} ,%NWL%" parses locale time " : function ( format )  {%NWL%var p = format ( " %X " ) . parse;%NWL%assert . deepEqual ( p ( " 00:00:00 " ) , utc ( 1900 , 0 , 1 , 0 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 11:59:59 " ) , utc ( 1900 , 0 , 1 , 11 , 59 , 59 ) ) ;%NWL%assert . deepEqual ( p ( " 12:00:00 " ) , utc ( 1900 , 0 , 1 , 12 , 0 , 0 ) ) ;%NWL%assert . deepEqual ( p ( " 23:59:59 " ) , utc ( 1900 , 0 , 1 , 23 , 59 , 59 ) ) ;%NWL%3
" NPT " : {%NWL%" observes 15 - minute offset " : tz ( " Asia / Kathmandu " , function ( range )  {%NWL%assert . deepEqual ( range ( local ( 2011 , 10 , 7 , 0 ) , local ( 2011 , 10 , 7 , 3 ) ) ,  [%NWL%utc ( 2011 , 10 , 6 , 18 , 15 ) ,%NWL%utc ( 2011 , 10 , 6 , 19 , 15 ) ,%NWL%utc ( 2011 , 10 , 6 , 20 , 15 )%NWL%] ) ;%NWL%} )%NWL%} ,%NWL%" IST " : {%NWL%assert . deepEqual ( range ( local ( 2011 , 10 , 7 , 0 ) , local ( 2011 , 10 , 7 , 3 ) ) ,  [%NWL%2
if ( vars . title . value )  {%NWL%var title = vars . title . value;%NWL%if ( typeof title === " function " ) title = title ( vars . self ) ;%NWL%title_data . push ( {%NWL%" link " : vars . title . link ,%NWL%" style " : vars . title ,%NWL%" type " : " title " ,%NWL%" value " : title%NWL%} )%NWL%}%NWL%var title = vars . title . sub . value;%NWL%1
require ( " . . / . . / d3 . time " ) ;%NWL%var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " d3 . time . scale " ) ;%NWL%suite . addBatch ( {%NWL%" scale " : {%NWL%topic: function ( )  {%NWL%return d3 . time . scale;%NWL%} ,%NWL%" copy " : {%NWL%var x = scale ( ) . domain ( [ local ( 2009 , 0 , 1 ) , local ( 2010 , 0 , 1 ) ] ) , y = x . copy ( ) ;%NWL%1
assert . deepEqual ( x . range ( ) ,  [ 1 , 2 ] ) ;%NWL%assert . deepEqual ( y . range ( ) ,  [ 2 , 3 ] ) ;%NWL%} ,%NWL%" changes to the interpolator are isolated " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2009 , 0 , 1 ) , local ( 2010 , 0 , 1 ) ] ) . range ( [ " red " ,  " blue " ] ) , y = x . copy ( ) ;%NWL%x . interpolate ( d3 . interpolateHsl ) ;%NWL%assert . equal ( x ( local ( 2009 , 6 , 1 ) ) ,  " #04ff00 " ) ;%NWL%assert . equal ( y ( local ( 2009 , 6 , 1 ) ) ,  " #81007e " ) ;%NWL%assert . equal ( y . interpolate ( ) , d3 . interpolate ) ;%NWL%} ,%NWL%var x = scale ( ) . domain ( [ local ( 2009 , 0 , 1 ) , local ( 2010 , 0 , 1 ) ] ) . clamp ( true ) , y = x . copy ( ) ;%NWL%4
assert . equal ( x ( local ( 2009 , 6 , 1 ) ) ,  " #04ff00 " ) ;%NWL%assert . equal ( y ( local ( 2009 , 6 , 1 ) ) ,  " #81007e " ) ;%NWL%assert . equal ( y . interpolate ( ) , d3 . interpolate ) ;%NWL%} ,%NWL%" changes to clamping are isolated " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2009 , 0 , 1 ) , local ( 2010 , 0 , 1 ) ] ) . clamp ( true ) , y = x . copy ( ) ;%NWL%x . clamp ( false ) ;%NWL%assert . equal ( x ( local ( 2011 , 0 , 1 ) ) , 2 ) ;%NWL%assert . equal ( y ( local ( 2011 , 0 , 1 ) ) , 1 ) ;%NWL%assert . isTrue ( y . clamp ( ) ) ;%NWL%assert . equal ( x ( local ( 2011 , 0 , 1 ) ) , 2 ) ;%NWL%7
" generates 1 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , local ( 2011 , 0 , 1 , 12 , 0 , 4 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 3 )%NWL%] ) ;%NWL%} ,%NWL%" generates 5 - second ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 5 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , local ( 2011 , 0 , 1 , 12 , 0 , 20 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 15 )%NWL%] ) ;%NWL%} ,%NWL%" generates 15 - second ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 15 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , local ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%} ,%NWL%" generates 30 - second ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 30 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 0 , 0 ) , local ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 1 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 1 , 30 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 0 , 27 ) , local ( 2011 , 0 , 1 , 12 , 4 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%} ,%NWL%" generates 5 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 5 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 3 , 27 ) , local ( 2011 , 0 , 1 , 12 , 21 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 20 )%NWL%] ) ;%NWL%} ,%NWL%" generates 15 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 15 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 8 , 27 ) , local ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%local ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%local ( 2011 , 0 , 1 , 13 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 30 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 30 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , local ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%local ( 2011 , 0 , 1 , 14 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 12 , 28 , 27 ) , local ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 16 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 3 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 3 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 14 , 28 , 27 ) , local ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%local ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%local ( 2011 , 0 , 2 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 6 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 6 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , local ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%local ( 2011 , 0 , 2 , 12 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 12 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 12 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , local ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - day ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - day ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , local ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 5 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 2 - day ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 2 - day ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 2 , 16 , 28 , 27 ) , local ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 5 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 7 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 9 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - week ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - week ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 1 , 16 , 28 , 27 ) , local ( 2011 , 0 , 23 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 9 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 16 , 0 , 0 ) ,%NWL%local ( 2011 , 0 , 23 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - month ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - month ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2011 , 0 , 18 ) , local ( 2011 , 4 , 2 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%local ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%local ( 2011 , 4 , 1 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 3 - month ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 3 - month ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ local ( 2010 , 11 , 18 ) , local ( 2011 , 10 , 2 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%local ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%local ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%local ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%local ( 2011 , 9 , 1 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - year ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , utc ( 2011 , 0 , 1 , 12 , 0 , 4 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 1 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 2 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 3 )%NWL%] ) ;%NWL%} ,%NWL%" generates 5 - second ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 5 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , utc ( 2011 , 0 , 1 , 12 , 0 , 20 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 5 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 10 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 15 )%NWL%] ) ;%NWL%} ,%NWL%" generates 15 - second ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 15 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , utc ( 2011 , 0 , 1 , 12 , 0 , 50 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 15 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 45 )%NWL%] ) ;%NWL%} ,%NWL%" generates 30 - second ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 30 - second ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) , utc ( 2011 , 0 , 1 , 12 , 1 , 50 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 0 , 30 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 1 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 1 , 30 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 0 , 27 ) , utc ( 2011 , 0 , 1 , 12 , 4 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 1 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 2 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 3 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 4 )%NWL%] ) ;%NWL%} ,%NWL%" generates 5 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 5 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 3 , 27 ) , utc ( 2011 , 0 , 1 , 12 , 21 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 5 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 10 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 20 )%NWL%] ) ;%NWL%} ,%NWL%" generates 15 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 15 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 8 , 27 ) , utc ( 2011 , 0 , 1 , 13 , 4 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 15 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%utc ( 2011 , 0 , 1 , 12 , 45 ) ,%NWL%utc ( 2011 , 0 , 1 , 13 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 30 - minute ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 30 - minute ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , utc ( 2011 , 0 , 1 , 14 , 4 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 12 , 30 ) ,%NWL%utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 13 , 30 ) ,%NWL%utc ( 2011 , 0 , 1 , 14 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 12 , 28 , 27 ) , utc ( 2011 , 0 , 1 , 16 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 13 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 14 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 16 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 3 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 3 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 14 , 28 , 27 ) , utc ( 2011 , 0 , 2 , 1 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 15 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%utc ( 2011 , 0 , 1 , 21 , 0 ) ,%NWL%utc ( 2011 , 0 , 2 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 6 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 6 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , utc ( 2011 , 0 , 2 , 14 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 18 , 0 ) ,%NWL%utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 2 , 6 , 0 ) ,%NWL%utc ( 2011 , 0 , 2 , 12 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 12 - hour ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 12 - hour ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , utc ( 2011 , 0 , 3 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 2 , 12 , 0 ) ,%NWL%utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 3 , 12 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - day ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - day ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , utc ( 2011 , 0 , 5 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 4 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 5 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 2 - day ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 2 - day ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 2 , 16 , 28 , 27 ) , utc ( 2011 , 0 , 9 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 3 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 5 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 7 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 9 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - week ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - week ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 1 , 16 , 28 , 27 ) , utc ( 2011 , 0 , 23 , 21 , 34 , 12 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 2 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 9 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 16 , 0 , 0 ) ,%NWL%utc ( 2011 , 0 , 23 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - month ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 1 - month ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2011 , 0 , 18 ) , utc ( 2011 , 4 , 2 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 1 , 1 , 0 , 0 ) ,%NWL%utc ( 2011 , 2 , 1 , 0 , 0 ) ,%NWL%utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%utc ( 2011 , 4 , 1 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 3 - month ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
" generates 3 - month ticks " : function ( scale )  {%NWL%var x = scale ( ) . domain ( [ utc ( 2010 , 11 , 18 ) , utc ( 2011 , 10 , 2 ) ] ) ;%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%utc ( 2011 , 0 , 1 , 0 , 0 ) ,%NWL%utc ( 2011 , 3 , 1 , 0 , 0 ) ,%NWL%utc ( 2011 , 6 , 1 , 0 , 0 ) ,%NWL%utc ( 2011 , 9 , 1 , 0 , 0 )%NWL%] ) ;%NWL%} ,%NWL%" generates 1 - year ticks " : function ( scale )  {%NWL%assert . deepEqual ( x . ticks ( 4 ) ,  [%NWL%2
module . exports = function ( )  {%NWL%d3 . select ( " #d3plus . utilsts . zoom_controls " ) . remove ( )%NWL%if ( !vars . small )  {%NWL%var zoom_enter = vars . container . value . append ( " div " )%NWL%. attr ( " id " , " d3plus . utilsts . zoom_controls " )%NWL%. style ( " top " , ( vars . margin . top + 5 ) + " px " )%NWL%zoom_enter . append ( " div " )%NWL%. attr ( " id " , " zoom_in " )%NWL%. attr ( " unselectable " , " on " )%NWL%. on ( events . click , function ( ) { vars . zoom ( " in " )  } )%NWL%zoom_enter . append ( " div " )%NWL%6
. style ( " top " , ( vars . margin . top + 5 ) + " px " )%NWL%zoom_enter . append ( " div " )%NWL%. attr ( " id " , " zoom_in " )%NWL%. attr ( " unselectable " , " on " )%NWL%. on ( events . click , function ( ) { vars . zoom ( " in " )  } )%NWL%. text ( " + " )%NWL%zoom_enter . append ( " div " )%NWL%. attr ( " id " , " zoom_out " )%NWL%. attr ( " unselectable " , " on " )%NWL%. on ( events . click , function ( ) { vars . zoom ( " out " )  } )%NWL%zoom_enter . append ( " div " )%NWL%1
_mouseDown: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . element . getDocument ( ) . addEvents ( {%NWL%mousemove: this . _mouseBound . mouseMove ,%NWL%mouseup: this . _mouseBound . mouseUp%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%event . stop ( ) ;%NWL%1
this . element . getDocument ( ) . addEvents ( {%NWL%mousemove: this . _mouseBound . mouseMove ,%NWL%mouseup: this . _mouseBound . mouseUp%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%6
} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%event . stop ( ) ;%NWL%6
%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%_mouseUp: function ( event )  {%NWL%this . touches . updateWithEvent ( event ) ;%NWL%6
this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%_mouseUp: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidGoUp ( this . touches ) ;%NWL%0
touchcancel: this . _mouseBound . touchCancel%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touchDidMove ( this . touches ) ;%NWL%4
this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%%NWL%event . stop ( ) ;%NWL%4
_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchEnd: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touchDidGoUp ( this . touches ) ;%NWL%4
else if ( ( match = / ^\x25 { 2 } / . exec ( _fmt ) ) !== null )  {%NWL%parse_tree . push ( ' % ' ) ;%NWL%}%NWL%else if ( ( match = / ^\x25 ( ?: ( [ 1 - 9 ] \d * ) \$|\ ( ( [ ^\ ) ] + ) \ ) ) ? ( \ + ) ? ( 0| ' [ ^$ ] ) ? ( - ) ? ( \d + ) ? ( ?:\ . ( \d + ) ) ? ( [ b - fosuxX ] ) / . exec ( _fmt ) ) !== null )  {%NWL%if ( match [ 2 ] )  {%NWL%arg_names |= 1;%NWL%var field_list = [ ] , replacement_field = match [ 2 ] , field_match = [ ] ;%NWL%if ( ( field_match = / ^ ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%while ( ( replacement_field = replacement_field . substring ( field_match [ 0 ] . length ) ) !== ' ' )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%8
else if ( ( match = / ^\x25 ( ?: ( [ 1 - 9 ] \d * ) \$|\ ( ( [ ^\ ) ] + ) \ ) ) ? ( \ + ) ? ( 0| ' [ ^$ ] ) ? ( - ) ? ( \d + ) ? ( ?:\ . ( \d + ) ) ? ( [ b - fosuxX ] ) / . exec ( _fmt ) ) !== null )  {%NWL%if ( match [ 2 ] )  {%NWL%arg_names |= 1;%NWL%var field_list = [ ] , replacement_field = match [ 2 ] , field_match = [ ] ;%NWL%if ( ( field_match = / ^ ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%while ( ( replacement_field = replacement_field . substring ( field_match [ 0 ] . length ) ) !== ' ' )  {%NWL%if ( ( field_match = / ^\ . ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%}%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%5
if ( value !== currentValue )  { this . input . set ( " value " ,  " "  + value ) ; }%NWL%}%NWL%} ;%NWL%var isAnyAdjustableNumberDragging = false;  / / hack for dragging one value over another one%NWL%Tangle . classes . TKAdjustableNumber = {%NWL%initialize: function ( element , options , tangle , variable )  {%NWL%this . element = element;%NWL%this . tangle = tangle;%NWL%this . variable = variable;%NWL%this . min = ( options . min !== undefined ) ? parseFloat ( options . min ) : 1;%NWL%this . step = ( options . step !== undefined ) ? parseFloat ( options . step ) : 1;%NWL%9
Tangle . classes . TKAdjustableNumber = {%NWL%initialize: function ( element , options , tangle , variable )  {%NWL%this . element = element;%NWL%this . tangle = tangle;%NWL%this . variable = variable;%NWL%this . min = ( options . min !== undefined ) ? parseFloat ( options . min ) : 1;%NWL%this . max = ( options . max !== undefined ) ? parseFloat ( options . max ) : 10;%NWL%this . step = ( options . step !== undefined ) ? parseFloat ( options . step ) : 1;%NWL%%NWL%this . initializeHover ( ) ;%NWL%this . initializeDrag ( ) ;%NWL%9
this . initializeHelp ( ) ;%NWL%this . initializeDrag ( ) ;%NWL%} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%this . updateStyle ( ) ;%NWL%0
this . initializeDrag ( ) ;%NWL%} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%updateRolloverEffects: function ( )  {%NWL%this . updateCursor ( ) ;%NWL%0
} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%updateRolloverEffects: function ( )  {%NWL%this . updateStyle ( ) ;%NWL%this . updateHelp ( ) ;%NWL%9
this . valueAtMouseDown = this . tangle . getValue ( this . variable ) ;%NWL%this . isDragging = true;%NWL%isAnyAdjustableNumberDragging = true;%NWL%this . updateRolloverEffects ( ) ;%NWL%this . updateStyle ( ) ;%NWL%} ,%NWL%%NWL%touchDidMove: function ( touches )  {%NWL%var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . updateHelp ( ) ;%NWL%3
touchDidMove: function ( touches )  {%NWL%var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . tangle . setValue ( this . variable , value ) ;%NWL%this . updateHelp ( ) ;%NWL%} ,%NWL%%NWL%touchDidGoUp: function ( touches )  {%NWL%this . helpElement . setStyle ( " display " ,  " none " ) ;%NWL%this . isDragging = false;%NWL%this . updateRolloverEffects ( ) ;%NWL%4
var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . tangle . setValue ( this . variable , value ) ;%NWL%this . updateHelp ( ) ;%NWL%} ,%NWL%%NWL%touchDidGoUp: function ( touches )  {%NWL%this . helpElement . setStyle ( " display " ,  " none " ) ;%NWL%this . isDragging = false;%NWL%isAnyAdjustableNumberDragging = false;%NWL%this . updateStyle ( ) ;%NWL%3
import d3 from ' d3 '%NWL%import topojson from ' topojson '%NWL%import data from ' . / day10_assets / cn . json '%NWL%const currentDay = 10%NWL%const svgArea = document . querySelectorAll ( ' svg ' ) [ currentDay - 1 ]%NWL%const subunits = topojson . feature ( data , data . objects . subunits )%NWL%const projection = d3 . geo . mercator ( )%NWL%. translate ( [ - 290 , 350 ] )%NWL%const path = d3 . geo . path ( ) . projection ( projection ) . pointRadius ( 1 )%NWL%5
import d3 from ' d3 '%NWL%import topojson from ' topojson '%NWL%import data from ' . / day11_assets / us . json '%NWL%const currentDay = 11%NWL%const svgArea = document . querySelectorAll ( ' svg ' ) [ currentDay - 1 ]%NWL%const subunits = topojson . feature ( data , data . objects . subunits )%NWL%const projection = d3 . geo . mercator ( )%NWL%. translate ( [ 620 , 400 ] )%NWL%const path = d3 . geo . path ( ) . projection ( projection ) . pointRadius ( 1 )%NWL%5
opacity: 0 . 8 ,%NWL%dx: 2 ,%NWL%dy: 2 ,%NWL%} )%NWL%const onZooming = ( ) => {%NWL%projection . translate ( mapZoom . translate ( ) ) . scale ( mapZoom . scale ( ) )%NWL%d3 . select ( svgArea ) . selectAll ( ' path . countries ' )%NWL%. attr ( ' d ' , geoPath )%NWL%d3 . select ( svgArea ) . selectAll ( ' . city - selection ' )%NWL%. attr ( ' transform ' , d => `translate ( $ { projection ( [ d . x , d . y ] ) [ 0 ] } , $ { projection ( [ d . x , d . y ] ) [ 1 ] } ) ` )%NWL%d3 . select ( svgArea ) . selectAll ( ' . city - selection ' )%NWL%8
tooltip . style . display = ' none '%NWL%} )%NWL%}%NWL%newNode = document . querySelector ( ' body ' )%NWL%. insertBefore (%NWL%document . createElement ( ' div ' ) ,%NWL%document . querySelectorAll ( ' svg ' ) [ currentDay ] . parentNode%NWL%)%NWL%newNode . id = `day$ { currentDay } Input`%NWL%tooltip = document . querySelector ( ` . day$ { currentDay } ` ) . parentNode%NWL%document . createElement ( ' div ' ) ,%NWL%5
var str = vars . format . locale . value . dev . noContainer%NWL%var selector = vars . container . selector || " " ;%NWL%print . warning ( stringFormat ( str ,  " \ " "  + selector +  " \ " " )  ,  " container "  )%NWL%}%NWL%else {%NWL%if ( vars . dev . value ) print . time ( " total draw time " ) ;%NWL%vars . container . value . call ( vars . self ) ;%NWL%}%NWL%if ( typeof value === " function " && vars . history . chain . length )  {%NWL%var changesObject = { }%NWL%var method = c . method%NWL%1
height: d => yScale ( d ) ,%NWL%width: 4 ,%NWL%x: ( _ , i ) => xScale ( i )  + xLeftPadding ,%NWL%y: d => 360 - yScale ( d )  + yTopPadding ,%NWL%fill: ' #4A90E2 '%NWL%} )%NWL%. on ( ' mouseover ' , function ( )  {%NWL%d3 . select ( this )%NWL%. attr ( ' fill ' ,  ' #03336B ' )%NWL%} )%NWL%d3 . select ( this )%NWL%7
. style ( ' fill ' ,  ( _ , i ) => color ( i ) )%NWL%. style ( ' opacity ' , 0 . 5 )%NWL%. style ( ' stroke ' ,  ' black ' )%NWL%. style ( ' stroke - width ' ,  ' 2px ' )%NWL%. on ( ' mouseenter ' , function ( _ , i )  {%NWL%d3 . select ( this )%NWL%. transition ( )%NWL%. duration ( 300 )%NWL%. style ( ' fill ' , extendColor ( 10 + i ) )%NWL%} )%NWL%d3 . select ( this )%NWL%5
} )%NWL%const newNode = document . querySelector ( ' . day6 ' ) . parentNode%NWL%. insertBefore (%NWL%document . createElement ( ' div ' ) ,%NWL%document . querySelector ( ' . day6 ' )%NWL%)%NWL%tooltip = d3 . select ( newNode )%NWL%. attr ( ' id ' ,  ' day6 ' )%NWL%. classed ( { ' tooltip ' : true } )%NWL%tooltip . append ( ' text ' )%NWL%tooltip . append ( ' text ' )%NWL%9
children: [%NWL%{ name: ' leaf1 ' } ,%NWL%{ name: ' leaf2 ' } ,%NWL%{ name: ' leaf3 ' } ,%NWL%{ name: ' leaf4 ' } ,%NWL%]%NWL%}%NWL%const svgArea = document . querySelectorAll ( ' svg ' ) [ currentDay - 1 ]%NWL%const color = d3 . scale . category10 ( )%NWL%const tree = d3 . layout . tree ( )%NWL%const nodes = tree . nodes ( data )%NWL%9
. orient ( " bottom " )%NWL%. ticks ( 5 )%NWL%. tickFormat ( dotimes ? d3 . time . format ( get_time_format ( xextent ) ) : undefined ) ;%NWL%yAxis = d3 . svg . axis ( )%NWL%. scale ( yscale )%NWL%. orient ( " left " )%NWL%. ticks ( 3 ) ;%NWL%svg . append ( " g " )%NWL%. attr ( " class " ,  " x axis " )%NWL%. attr ( " transform " ,  " translate ( 0 , "  +  ( h - padding_bottom )  +  " ) " )%NWL%svg . append ( " g " )%NWL%7
. attr ( " transform " ,  " translate ( "  + padding_left +  " , 0 ) " )%NWL%. call ( yAxis ) ;%NWL%svg . append ( " text " )%NWL%. attr ( " class " ,  " label " )%NWL%. attr ( " text - anchor " ,  " end " )%NWL%. attr ( " x " , w - padding_right + 5 )%NWL%. attr ( " y " , h - 10 )%NWL%. attr ( " style " , opt . label_style || " " )%NWL%. text ( opt . xlabel ) ;%NWL%yy = padding_top;%NWL%svg . append ( " text " )%NWL%2
xx = 10;%NWL%svg . append ( " text " )%NWL%. attr ( " class " ,  " label " )%NWL%. attr ( " text - anchor " ,  " end " )%NWL%. attr ( " x " , xx )%NWL%. attr ( " y " , yy )%NWL%. text ( opt . ylabel )%NWL%. attr ( " style " , opt . label_style || " " )%NWL%. attr ( ' transform ' ,%NWL%function ( d , i , j )  { return ' rotate ( - 90 '  + xx +  ' ,  '  + yy +  ' ) ' ; } ) ;%NWL%svg . append ( " text " )%NWL%1
. attr ( " id " ,  " bar - "  + opt . div +  " - "  + i +  " - "  + j ) ;%NWL%} ) ;%NWL%_ . each ( barset . errors , function ( barerr , j )  {%NWL%chartBody . append ( " line " )%NWL%. attr ( " id " ,  " bar - error - "  + opt . div +  " - "  + i +  " - "  + j ) ;%NWL%} ) ;%NWL%} ) ;%NWL%_ . each ( linesets , function ( lineset , i )  {%NWL%chartBody . append ( " path " )%NWL%. attr ( " id " ,  " path - "  + opt . div +  " - "  + i ) ;%NWL%chartBody . append ( " line " )%NWL%3
} ) ;%NWL%_ . each ( linesets , function ( lineset , i )  {%NWL%chartBody . append ( " path " )%NWL%. attr ( " id " ,  " path - "  + opt . div +  " - "  + i ) ;%NWL%_ . each ( lineset . errors , function ( lineerr , j )  {%NWL%chartBody . append ( " line " )%NWL%. attr ( " id " ,  " line - error - "  + opt . div +  " - "  + i +  " - "  + j ) ;%NWL%} ) ;%NWL%} ) ;%NWL%_ . each ( pointsets , function ( pointset , i )  {%NWL%chartBody . append ( " line " )%NWL%5
_ . each ( pointsets , function ( pointset , i )  {%NWL%_ . each ( pointset . errors , function ( pointerr , j )  {%NWL%chartBody . append ( " line " )%NWL%. attr ( " id " ,  " point - error - "  + opt . div +  " - "  + i +  " - "  + j ) ;%NWL%} ) ;%NWL%_ . each ( pointset . values , function ( point , j )  {%NWL%chartBody . append ( " circle " )%NWL%. attr ( " id " ,  " point - "  + opt . div +  " - "  + i +  " - "  + j ) ;%NWL%} ) ;%NWL%} ) ;%NWL%chartBody . append ( " line " )%NWL%2
} ) ;%NWL%_ . each ( pointset . values , function ( point , j )  {%NWL%chartBody . append ( " circle " )%NWL%. attr ( " id " ,  " point - "  + opt . div +  " - "  + i +  " - "  + j ) ;%NWL%} ) ;%NWL%} ) ;%NWL%_ . each ( vbars , function ( v , i )  {%NWL%chartBody . append ( " line " )%NWL%. attr ( " id " ,  " vbar - "  + opt . div +  " - "  + i ) ;%NWL%} ) ;%NWL%chartBody . append ( " line " )%NWL%7
} ) ;%NWL%} ) ;%NWL%_ . each ( vbars , function ( v , i )  {%NWL%chartBody . append ( " line " )%NWL%. attr ( " id " ,  " vbar - "  + opt . div +  " - "  + i ) ;%NWL%} ) ;%NWL%_ . each ( hbars , function ( v , i )  {%NWL%chartBody . append ( " line " )%NWL%. attr ( " id " ,  " hbar - "  + opt . div +  " - "  + i ) ;%NWL%} ) ;%NWL%chartBody . append ( " line " )%NWL%3
. attr ( " y " , Y )%NWL%. attr ( " stroke " , v . note . color )%NWL%. text ( v . note . text )%NWL%. attr ( " style " , v . note . style || " " ) ;%NWL%} ) ;%NWL%}%NWL%draw ( ) ;%NWL%me . zoom [ opt . div ] = d3 . behavior . zoom ( ) ;%NWL%me . zoom [ opt . div ] . x ( xscale ) ;%NWL%me . zoom [ opt . div ] . scaleExtent ( [ 0 . 01 , 100 ] ) ;%NWL%me . xscale [ opt . div ] = xscale;%NWL%7
. attr ( " stroke " , v . note . color )%NWL%. text ( v . note . text )%NWL%. attr ( " style " , v . note . style || " " ) ;%NWL%} ) ;%NWL%}%NWL%draw ( ) ;%NWL%me . zoom [ opt . div ] = d3 . behavior . zoom ( ) ;%NWL%me . zoom [ opt . div ] . x ( xscale ) ;%NWL%me . zoom [ opt . div ] . scaleExtent ( [ 0 . 01 , 100 ] ) ;%NWL%me . zoom [ opt . div ] . on ( " zoom " , draw ) ;%NWL%me . yscale [ opt . div ] = yscale;%NWL%6
var smallestGap = require ( " . . / . . / network / smallestGap . coffee " ) ,%NWL%fetchValue = require ( " . . / . . / core / fetch / value . coffee " ) ;%NWL%var nodes = vars . nodes . restricted || vars . nodes . value ,%NWL%0
. range ( [ min_size , max_size ] )%NWL%vars . zoom . bounds = [  [ x_range [ 0 ] - max_size * 1 . 1 , y_range [ 0 ] - max_size * 1 . 1 ]%NWL%,  [ x_range [ 1 ] + max_size * 1 . 1 , y_range [ 1 ] + max_size * 1 . 1 ]  ]%NWL%var data = [ ] , lookup = { }%NWL%nodes . forEach ( function ( n ) {%NWL%var d = vars . data . viz . filter ( function ( a ) {%NWL%return a [ vars . id . value ] == n [ vars . id . value ]%NWL%} ) [ 0 ]%NWL%var obj = d || { }%NWL%obj [ vars . id . value ] = n [ vars . id . value ]%NWL%obj . d3plus . x = n . x%NWL%9
vars . zoom . bounds = [  [ x_range [ 0 ] - max_size * 1 . 1 , y_range [ 0 ] - max_size * 1 . 1 ]%NWL%,  [ x_range [ 1 ] + max_size * 1 . 1 , y_range [ 1 ] + max_size * 1 . 1 ]  ]%NWL%var data = [ ] , lookup = { }%NWL%nodes . forEach ( function ( n ) {%NWL%var d = vars . data . viz . filter ( function ( a ) {%NWL%return a [ vars . id . value ] == n [ vars . id . value ]%NWL%} ) [ 0 ]%NWL%var obj = d || { }%NWL%obj [ vars . id . value ] = n [ vars . id . value ]%NWL%obj . d3plus = { }%NWL%obj . d3plus . y = n . y%NWL%8
var data = [ ] , lookup = { }%NWL%nodes . forEach ( function ( n ) {%NWL%var d = vars . data . viz . filter ( function ( a ) {%NWL%return a [ vars . id . value ] == n [ vars . id . value ]%NWL%} ) [ 0 ]%NWL%var obj = d || { }%NWL%obj [ vars . id . value ] = n [ vars . id . value ]%NWL%obj . d3plus = { }%NWL%obj . d3plus . x = n . x%NWL%obj . d3plus . y = n . y%NWL%obj . d3plus . r = val ? radius ( val ) : radius . range ( ) [ 0 ]%NWL%6
}%NWL%l [ vars . edges . source ] . d3plus = { }%NWL%var source = lookup [ l [ vars . edges . source ] [ vars . id . value ] ]%NWL%if ( source !== undefined )  {%NWL%l [ vars . edges . source ] . d3plus . r = source . r%NWL%l [ vars . edges . source ] . d3plus . x = source . x%NWL%l [ vars . edges . source ] . d3plus . y = source . y%NWL%} else {%NWL%delete l [ vars . edges . source ] . d3plus;%NWL%}%NWL%var target = lookup [ l [ vars . edges . target ] [ vars . id . value ] ]%NWL%2
? ring_width * 1 . 4 : ring_width%NWL%, secondaryRing = ring_width * 2%NWL%, edges = [ ]%NWL%, nodes = [ ]%NWL%var center = vars . data . viz . filter ( function ( d ) {%NWL%return d [ vars . id . value ] === vars . focus . value [ 0 ]%NWL%} ) [ 0 ]%NWL%if ( !center )  {%NWL%center = {  " d3plus " : { }  }%NWL%center [ vars . id . value ] = vars . focus . value [ 0 ]%NWL%center . d3plus . x = vars . width . viz / 2%NWL%8
, secondaryRing = ring_width * 2%NWL%, edges = [ ]%NWL%, nodes = [ ]%NWL%var center = vars . data . viz . filter ( function ( d ) {%NWL%return d [ vars . id . value ] === vars . focus . value [ 0 ]%NWL%} ) [ 0 ]%NWL%if ( !center )  {%NWL%center = {  " d3plus " : { }  }%NWL%center [ vars . id . value ] = vars . focus . value [ 0 ]%NWL%}%NWL%center . d3plus . y = vars . height . viz / 2%NWL%7
, edges = [ ]%NWL%, nodes = [ ]%NWL%var center = vars . data . viz . filter ( function ( d ) {%NWL%return d [ vars . id . value ] === vars . focus . value [ 0 ]%NWL%} ) [ 0 ]%NWL%if ( !center )  {%NWL%center = {  " d3plus " : { }  }%NWL%center [ vars . id . value ] = vars . focus . value [ 0 ]%NWL%}%NWL%center . d3plus . x = vars . width . viz / 2%NWL%center . d3plus . r = primaryRing * . 65%NWL%6
var c = edge [ vars . edges . source ] [ vars . id . value ] == vars . focus . value [ 0 ] ? edge [ vars . edges . target ] : edge [ vars . edges . source ]%NWL%var n = vars . data . viz . filter ( function ( d ) {%NWL%return d [ vars . id . value ] === c [ vars . id . value ]%NWL%} ) [ 0 ]%NWL%if ( !n )  {%NWL%n = {  " d3plus " : { }  }%NWL%n [ vars . id . value ] = c [ vars . id . value ]%NWL%}%NWL%n . d3plus . edges = vars . edges . connections ( n [ vars . id . value ] , vars . id . value ) . filter ( function ( c ) {%NWL%return c [ vars . edges . source ] [ vars . id . value ] != vars . focus . value [ 0 ] && c [ vars . edges . target ] [ vars . id . value ] != vars . focus . value [ 0 ]%NWL%n . d3plus . edge = edge%NWL%5
var secondaries = [ ] , total = 0%NWL%primaries . forEach ( function ( p ) {%NWL%var primaryId = p [ vars . id . value ]%NWL%p . d3plus . edges = p . d3plus . edges . filter ( function ( c ) {%NWL%var source = c [ vars . edges . source ] [ vars . id . value ]%NWL%, target = c [ vars . edges . target ] [ vars . id . value ]%NWL%return ( claimed . indexOf ( source ) < 0 && target == primaryId )%NWL%|| ( claimed . indexOf ( target ) < 0 && source == primaryId )%NWL%} )%NWL%total + = p . d3plus . edges . length || 1%NWL%var source = c [ vars . edges . source ]%NWL%4
var c = edge [ vars . edges . source ] [ vars . id . value ] == p [ vars . id . value ]%NWL%? edge [ vars . edges . target ] : edge [ vars . edges . source ]%NWL%, s = radian / total%NWL%var d = vars . data . viz . filter ( function ( a ) {%NWL%return a [ vars . id . value ] === c [ vars . id . value ]%NWL%} ) [ 0 ]%NWL%if ( !d )  {%NWL%d = {  " d3plus " : { }  }%NWL%d [ vars . id . value ] = c [ vars . id . value ]%NWL%}%NWL%d . d3plus . radians = a%NWL%7
? edge [ vars . edges . target ] : edge [ vars . edges . source ]%NWL%, s = radian / total%NWL%var d = vars . data . viz . filter ( function ( a ) {%NWL%return a [ vars . id . value ] === c [ vars . id . value ]%NWL%} ) [ 0 ]%NWL%if ( !d )  {%NWL%d = {  " d3plus " : { }  }%NWL%d [ vars . id . value ] = c [ vars . id . value ]%NWL%}%NWL%a = ( angle - ( s * children / 2 ) + ( s / 2 ) ) + ( ( s ) * i )%NWL%d . d3plus . x = vars . width . viz / 2 +  ( ( secondaryRing )  * Math . cos ( a ) )%NWL%6
, s = radian / total%NWL%var d = vars . data . viz . filter ( function ( a ) {%NWL%return a [ vars . id . value ] === c [ vars . id . value ]%NWL%} ) [ 0 ]%NWL%if ( !d )  {%NWL%d = {  " d3plus " : { }  }%NWL%d [ vars . id . value ] = c [ vars . id . value ]%NWL%}%NWL%a = ( angle - ( s * children / 2 ) + ( s / 2 ) ) + ( ( s ) * i )%NWL%d . d3plus . radians = a%NWL%d . d3plus . y = vars . height . viz / 2 +  ( ( secondaryRing )  * Math . sin ( a ) )%NWL%5
}%NWL%function prepareCorners ( quad )  {%NWL%if ( quad . data )  {%NWL%return quad . bb = boundingBoxes [ quad . data . node . index ]%NWL%}%NWL%quad . bb = [ [ 0 , 0 ] , [ 0 , 0 ] ]%NWL%for ( var i = 0; i < 4; + + i )  {%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 0 ] < quad . bb [ 0 ] [ 0 ] )  {%NWL%quad . bb [ 0 ] [ 0 ] = quad [ i ] . bb [ 0 ] [ 0 ]%NWL%}%NWL%quad . bb [ 0 ] [ 1 ] = quad [ i ] . bb [ 0 ] [ 1 ]%NWL%8
return quad . bb = boundingBoxes [ quad . data . node . index ]%NWL%}%NWL%quad . bb = [ [ 0 , 0 ] , [ 0 , 0 ] ]%NWL%for ( var i = 0; i < 4; + + i )  {%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 0 ] < quad . bb [ 0 ] [ 0 ] )  {%NWL%quad . bb [ 0 ] [ 0 ] = quad [ i ] . bb [ 0 ] [ 0 ]%NWL%}%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 1 ] < quad . bb [ 0 ] [ 1 ] )  {%NWL%quad . bb [ 0 ] [ 1 ] = quad [ i ] . bb [ 0 ] [ 1 ]%NWL%}%NWL%quad . bb [ 1 ] [ 0 ] = quad [ i ] . bb [ 1 ] [ 0 ]%NWL%5
for ( var i = 0; i < 4; + + i )  {%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 0 ] < quad . bb [ 0 ] [ 0 ] )  {%NWL%quad . bb [ 0 ] [ 0 ] = quad [ i ] . bb [ 0 ] [ 0 ]%NWL%}%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 1 ] < quad . bb [ 0 ] [ 1 ] )  {%NWL%quad . bb [ 0 ] [ 1 ] = quad [ i ] . bb [ 0 ] [ 1 ]%NWL%}%NWL%if ( quad [ i ] && quad [ i ] . bb [ 1 ] [ 0 ] > quad . bb [ 1 ] [ 0 ] )  {%NWL%quad . bb [ 1 ] [ 0 ] = quad [ i ] . bb [ 1 ] [ 0 ]%NWL%}%NWL%quad . bb [ 1 ] [ 1 ] = quad [ i ] . bb [ 1 ] [ 1 ]%NWL%2
}%NWL%function prepareCorners ( quad )  {%NWL%if ( quad . data )  {%NWL%return quad . bb = boundingBoxes [ quad . data . node . index ]%NWL%}%NWL%quad . bb = [ [ 0 , 0 ] , [ 0 , 0 ] ]%NWL%for ( var i = 0; i < 4; + + i )  {%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 0 ] < quad . bb [ 0 ] [ 0 ] )  {%NWL%quad . bb [ 0 ] [ 0 ] = quad [ i ] . bb [ 0 ] [ 0 ]%NWL%}%NWL%quad . bb [ 0 ] [ 1 ] = quad [ i ] . bb [ 0 ] [ 1 ]%NWL%8
return quad . bb = boundingBoxes [ quad . data . node . index ]%NWL%}%NWL%quad . bb = [ [ 0 , 0 ] , [ 0 , 0 ] ]%NWL%for ( var i = 0; i < 4; + + i )  {%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 0 ] < quad . bb [ 0 ] [ 0 ] )  {%NWL%quad . bb [ 0 ] [ 0 ] = quad [ i ] . bb [ 0 ] [ 0 ]%NWL%}%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 1 ] < quad . bb [ 0 ] [ 1 ] )  {%NWL%quad . bb [ 0 ] [ 1 ] = quad [ i ] . bb [ 0 ] [ 1 ]%NWL%}%NWL%quad . bb [ 1 ] [ 0 ] = quad [ i ] . bb [ 1 ] [ 0 ]%NWL%5
for ( var i = 0; i < 4; + + i )  {%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 0 ] < quad . bb [ 0 ] [ 0 ] )  {%NWL%quad . bb [ 0 ] [ 0 ] = quad [ i ] . bb [ 0 ] [ 0 ]%NWL%}%NWL%if ( quad [ i ] && quad [ i ] . bb [ 0 ] [ 1 ] < quad . bb [ 0 ] [ 1 ] )  {%NWL%quad . bb [ 0 ] [ 1 ] = quad [ i ] . bb [ 0 ] [ 1 ]%NWL%}%NWL%if ( quad [ i ] && quad [ i ] . bb [ 1 ] [ 0 ] > quad . bb [ 1 ] [ 0 ] )  {%NWL%quad . bb [ 1 ] [ 0 ] = quad [ i ] . bb [ 1 ] [ 0 ]%NWL%}%NWL%quad . bb [ 1 ] [ 1 ] = quad [ i ] . bb [ 1 ] [ 1 ]%NWL%2
var bounds = path . bounds ( d ) ,%NWL%x0 = d . x0 = bounds [ 0 ] [ 0 ] | 0 ,%NWL%y0 = d . y0 = bounds [ 0 ] [ 1 ] | 0 ,%NWL%x1 = bounds [ 1 ] [ 0 ]  + 1 | 0 ,%NWL%y1 = bounds [ 1 ] [ 1 ]  + 1 | 0;%NWL%var Lambda0 = k [ 0 ]  / width * 360 - 180 ,%NWL%Lambda1 = ( k [ 0 ]  + 1 )  / width * 360 - 180 ,%NWL%Phi0 = k [ 1 ]  / width * 360 - 180 ,%NWL%Phi1 = ( k [ 1 ]  + 1 )  / width * 360 - 180;%NWL%mPhi0 = mercatorPhi ( Phi0 ) ,%NWL%var width = canvas . width = x1 - x0 ,%NWL%0
switch ( cartoLayer . type ( ) )  {%NWL%case " tile " :%NWL%d3Minimap . addTileLayer ( cartoLayer . path ( ) , cartoLayer . label ( ) , cartoLayer . tileType ( ) , !cartoLayer . visibility ( ) , cartoLayer )%NWL%break;%NWL%case " csv " :%NWL%d3Minimap . addXYLayer ( cartoLayer . features ( ) , cartoLayer . label ( ) , cartoLayer . cssClass ( ) , cartoLayer . markerSize ( ) ,  " canvas " , cartoLayer . x ( ) , cartoLayer . y ( ) ,  " drawAlways " , cartoLayer )%NWL%break;%NWL%case " topojson " :%NWL%d3Minimap . addFeatureLayer ( cartoLayer . features ( ) , cartoLayer . label ( ) , cartoLayer . cssClass ( ) , " canvas " ,  " drawAlways " , cartoLayer )%NWL%break;%NWL%d3Minimap . addFeatureLayer ( cartoLayer . features ( ) , cartoLayer . label ( ) , cartoLayer . cssClass ( ) , " canvas " ,  " drawAlways " , cartoLayer )%NWL%8
break;%NWL%case " topojson " :%NWL%d3Minimap . addFeatureLayer ( cartoLayer . features ( ) , cartoLayer . label ( ) , cartoLayer . cssClass ( ) , " canvas " ,  " drawAlways " , cartoLayer )%NWL%break;%NWL%case " geojson " :%NWL%d3Minimap . addFeatureLayer ( cartoLayer . features ( ) , cartoLayer . label ( ) , cartoLayer . cssClass ( ) , " canvas " ,  " drawAlways " , cartoLayer )%NWL%break;%NWL%case " xyarray " :%NWL%d3Minimap . addXYLayer ( cartoLayer . features ( ) , cartoLayer . label ( ) , cartoLayer . cssClass ( ) ,  " canvas " , cartoLayer . renderMode ( ) , cartoLayer . x ( ) , cartoLayer . y ( ) ,  " drawAlways " , cartoLayer )%NWL%break;%NWL%d3Minimap . addFeatureLayer ( cartoLayer . features ( ) , cartoLayer . label ( ) , cartoLayer . cssClass ( ) , " canvas " ,  " drawAlways " , cartoLayer )%NWL%2
}%NWL%d3Minimap . refresh ( ) ;%NWL%return this;%NWL%}%NWL%%NWL%d3CartoMiniMap . hideControls = function ( hide )  {%NWL%if ( hide )  {%NWL%d3Minimap . div ( ) . select ( " #d3MapLayerBox " ) . style ( " display " ,  " none " ) ;%NWL%d3Minimap . div ( ) . select ( " #d3MapZoomBox " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%d3Minimap . div ( ) . select ( " #d3MapLayerBox " ) . style ( " display " ,  " none " ) ;%NWL%7
d3Minimap . refresh ( ) ;%NWL%return this;%NWL%}%NWL%%NWL%d3CartoMiniMap . hideControls = function ( hide )  {%NWL%if ( hide )  {%NWL%d3Minimap . div ( ) . select ( " #d3MapLayerBox " ) . style ( " display " ,  " none " ) ;%NWL%d3Minimap . div ( ) . select ( " #d3MapZoomBox " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%else {%NWL%d3Minimap . div ( ) . select ( " #d3MapZoomBox " ) . style ( " display " ,  " none " ) ;%NWL%7
d3 . sketchy . rect = function ( selection )  {%NWL%%NWL%var rh = 50 , rw = 10 , w = 2 , c = [ 0 , 0 ] , fillColor = " red " , strokeColor= " black " , jostle = 0;%NWL%%NWL%function d3_sketchyRect ( selection )  {%NWL%selection . append ( " rect " ) . attr ( " class " ,  " sketchy " ) . attr ( " x " , c [ 0 ] ) . attr ( " y " , c [ 1 ] ) . attr ( " height " , rh ) . attr ( " width " , rw ) . style ( " fill " , fillColor )%NWL%var randomJostle = d3 . scale . linear ( ) . domain ( [ 0 , 1 ] ) . range ( [ - jostle , jostle ] ) ;%NWL%%NWL%var j = [ ] ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%9
%NWL%var rh = 50 , rw = 10 , w = 2 , c = [ 0 , 0 ] , fillColor = " red " , strokeColor= " black " , jostle = 0;%NWL%%NWL%function d3_sketchyRect ( selection )  {%NWL%selection . append ( " rect " ) . attr ( " class " ,  " sketchy " ) . attr ( " x " , c [ 0 ] ) . attr ( " y " , c [ 1 ] ) . attr ( " height " , rh ) . attr ( " width " , rw ) . style ( " fill " , fillColor )%NWL%var randomJostle = d3 . scale . linear ( ) . domain ( [ 0 , 1 ] ) . range ( [ - jostle , jostle ] ) ;%NWL%%NWL%var j = [ ] ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%8
var rh = 50 , rw = 10 , w = 2 , c = [ 0 , 0 ] , fillColor = " red " , strokeColor= " black " , jostle = 0;%NWL%%NWL%function d3_sketchyRect ( selection )  {%NWL%selection . append ( " rect " ) . attr ( " class " ,  " sketchy " ) . attr ( " x " , c [ 0 ] ) . attr ( " y " , c [ 1 ] ) . attr ( " height " , rh ) . attr ( " width " , rw ) . style ( " fill " , fillColor )%NWL%var randomJostle = d3 . scale . linear ( ) . domain ( [ 0 , 1 ] ) . range ( [ - jostle , jostle ] ) ;%NWL%%NWL%var j = [ ] ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%7
%NWL%function d3_sketchyRect ( selection )  {%NWL%selection . append ( " rect " ) . attr ( " class " ,  " sketchy " ) . attr ( " x " , c [ 0 ] ) . attr ( " y " , c [ 1 ] ) . attr ( " height " , rh ) . attr ( " width " , rw ) . style ( " fill " , fillColor )%NWL%var randomJostle = d3 . scale . linear ( ) . domain ( [ 0 , 1 ] ) . range ( [ - jostle , jostle ] ) ;%NWL%%NWL%var j = [ ] ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%j . push ( randomJostle ( Math . random ( ) ) ) ;%NWL%6
var gRectPoints = [ ] ;%NWL%gRectPoints . push ( [ c [ 0 ]  +  ( z ) , c [ 1 ]  + rh ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  -  ( z ) , c [ 1 ]  + rh ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  -  ( z *  . 55 )  + j [ 0 ] , c [ 1 ]  -  ( z *  . 55 )  + j [ 1 ] ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  + rw +  ( z *  . 35 )  + j [ 2 ] , c [ 1 ]  -  ( z *  . 35 )  + j [ 3 ] ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  + rw +  ( z *  . 25 )  + j [ 4 ] , c [ 1 ]  + rh +  ( z *  . 25 )  + j [ 5 ] ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  +  ( z ) , c [ 1 ]  + rh +  ( z *  . 1 ) ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  +  ( z ) , c [ 1 ]  + rh -  ( z *  . 1 ) ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  + rw -  ( z *  . 25 )  + j [ 4 ] , c [ 1 ]  + rh -  ( z *  . 25 )  + j [ 5 ] ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  + rw -  ( z *  . 35 )  + j [ 2 ] , c [ 1 ]  +  ( z *  . 35 )  + j [ 3 ] ] ) ;%NWL%gRectPoints . push ( [ c [ 0 ]  +  ( z ) , c [ 1 ]  + rh ] ) ;%NWL%1
if ( !arguments . length ) return jostle;%NWL%jostle = data;%NWL%return this;%NWL%}%NWL%%NWL%return d3_sketchyRect;%NWL%}%NWL%d3 . sketchy . randomColor = function ( baseColor , range )  {%NWL%var hslBase = d3 . hsl ( baseColor )%NWL%hslBase . h = hslBase . h +  ( Math . floor ( Math . random ( )  *  ( range * 255 ) )  - Math . floor ( range / 2 ) ) ;%NWL%hslBase . l = hslBase . l +  ( Math . floor ( Math . random ( )  * range )  - Math . floor ( range / 2 ) ) ;%NWL%9
legend . initDone = true;%NWL%}%NWL%legend . target . selectAll ( " g . legendCells " ) . select ( " text . breakLabels " ) . remove ( ) ;%NWL%legend . target . selectAll ( " g . legendCells " ) . select ( " rect " ) . remove ( ) ;%NWL%legend . target . selectAll ( " . legendTitle " ) . remove ( ) ;%NWL%legend . target . selectAll ( " g . legendCells " )%NWL%. data ( legendValues )%NWL%. enter ( )%NWL%. append ( " g " )%NWL%. attr ( " class " ,  " legendCells " )%NWL%legend . target . selectAll ( " g . legendCells " )%NWL%5
. enter ( )%NWL%. append ( " g " )%NWL%. attr ( " class " ,  " legendCells " )%NWL%. attr ( " transform " , function ( d , i )  { return " translate ( "  +  ( i *  ( cellWidth + cellPadding ) )  +  " , 0 ) "  } )%NWL%legend . target . selectAll ( " g . legendCells " )%NWL%. append ( " rect " )%NWL%. attr ( " class " ,  " breakRect " )%NWL%. attr ( " height " , cellHeight )%NWL%. attr ( " width " , cellWidth )%NWL%. style ( " fill " , function ( d )  { return d . color } )%NWL%legend . target . selectAll ( " g . legendCells " )%NWL%4
scale = newScale;%NWL%legendValues = [ ] ;%NWL%if ( scale . invertExtent )  {%NWL%scale . range ( ) . forEach ( function ( el )  {%NWL%var cellObject = { color: el , stop: scale . invertExtent ( el ) }%NWL%legendValues . push ( cellObject )%NWL%} )%NWL%}%NWL%else {%NWL%scale . domain ( ) . forEach ( function ( el )  {%NWL%legendValues . push ( cellObject )%NWL%5
var fetchValue = require ( " . . / . . / core / fetch / value . coffee " ) ;%NWL%var uniques  = require ( " . . / . . / util / uniques . coffee " ) ;%NWL%var copy    = require ( " . . / . . / util / copy . coffee " ) ;%NWL%var rand_col  = require ( " . . / . . / color / random . coffee " ) ;%NWL%var table = function ( vars )  {%NWL%var cols = uniques ( vars . cols . value ) ;%NWL%1
return 1;%NWL%} ) ;%NWL%return processedTimelines;%NWL%}%NWL%function relativePosition ( band , i )  {%NWL%if ( !band . parent )  {%NWL%band . level = 0;%NWL%}%NWL%else {%NWL%band . level = band . parent . level + 1;%NWL%band . y = band . parent . y +  ( band . lane * height )  +  ( padding / 2 ) ;%NWL%9
} ) ;%NWL%return processedTimelines;%NWL%}%NWL%function relativePosition ( band , i )  {%NWL%if ( !band . parent )  {%NWL%band . level = 0;%NWL%}%NWL%else {%NWL%band . level = band . parent . level + 1;%NWL%var height = band . dyp * band . parent . dy;%NWL%band . dy = Math . max ( 1 , height - padding ) ;%NWL%8
return 1;%NWL%} ) ;%NWL%return processedTimelines;%NWL%}%NWL%function relativePosition ( band , i )  {%NWL%if ( !band . parent )  {%NWL%band . level = 0;%NWL%}%NWL%else {%NWL%band . level = band . parent . level + 1;%NWL%band . y = band . parent . y +  ( band . lane * height )  +  ( padding / 2 ) ;%NWL%9
} ) ;%NWL%return processedTimelines;%NWL%}%NWL%function relativePosition ( band , i )  {%NWL%if ( !band . parent )  {%NWL%band . level = 0;%NWL%}%NWL%else {%NWL%band . level = band . parent . level + 1;%NWL%var height = band . dyp * band . parent . dy;%NWL%band . dy = Math . max ( 1 , height - padding ) ;%NWL%8
{ startAngle: _extent [ 1 ] , endAngle: _extent [ 1 ]  + _handleSize , class: " resize w " }%NWL%] ;%NWL%return this%NWL%}%NWL%_circularbrush . innerRadius = function ( _value )  {%NWL%if ( !arguments . length ) return _arc . innerRadius ( ) ;%NWL%_arc . innerRadius ( _value ) ;%NWL%return this%NWL%}%NWL%_circularbrush . outerRadius = function ( _value )  {%NWL%_arc . outerRadius ( _value ) ;%NWL%6
_circularbrushDispatch . brush ( ) ;%NWL%}%NWL%function brushRefresh ( )  {%NWL%_brushG%NWL%. selectAll ( " path . circularbrush " )%NWL%. data ( _newBrushData )%NWL%. attr ( " d " , _arc )%NWL%}%NWL%function extentUp ( )  {%NWL%_brushData = _newBrushData;%NWL%_circularbrushDispatch . brushend ( ) ;%NWL%0
{ startAngle: _extent [ 1 ] , endAngle: _extent [ 1 ]  + _handleSize , class: " resize w " }%NWL%] ;%NWL%return this%NWL%}%NWL%_circularbrush . innerRadius = function ( _value )  {%NWL%if ( !arguments . length ) return _arc . innerRadius ( ) ;%NWL%_arc . innerRadius ( _value ) ;%NWL%return this%NWL%}%NWL%_circularbrush . outerRadius = function ( _value )  {%NWL%_arc . outerRadius ( _value ) ;%NWL%6
_circularbrushDispatch . brush ( ) ;%NWL%}%NWL%function brushRefresh ( )  {%NWL%_brushG%NWL%. selectAll ( " path . circularbrush " )%NWL%. data ( _newBrushData )%NWL%. attr ( " d " , _arc )%NWL%}%NWL%function extentUp ( )  {%NWL%_brushData = _newBrushData;%NWL%_circularbrushDispatch . brushend ( ) ;%NWL%0
if ( !arguments . length ) return true;%NWL%var gNodes = gexfParsed . nodes;%NWL%var gLinks = gexfParsed . edges;%NWL%nodes = [ ] ;%NWL%links = [ ] ;%NWL%nodeHash = { } ;%NWL%var x = 0;%NWL%gNodes . forEach ( function ( gNode )  {%NWL%var newNode = { id: x , properties: { } } ;%NWL%newNode . label = gNode . label || gNode . id;%NWL%newNode . x = gNode . viz . position . x;%NWL%9
var gNodes = gexfParsed . nodes;%NWL%var gLinks = gexfParsed . edges;%NWL%nodes = [ ] ;%NWL%links = [ ] ;%NWL%nodeHash = { } ;%NWL%var x = 0;%NWL%gNodes . forEach ( function ( gNode )  {%NWL%var newNode = { id: x , properties: { } } ;%NWL%newNode . label = gNode . label || gNode . id;%NWL%newNode . rgbColor = gNode . viz . color || " rgb ( 122 , 122 , 122 ) " ;%NWL%newNode . y = gNode . viz . position . y;%NWL%8
var gLinks = gexfParsed . edges;%NWL%nodes = [ ] ;%NWL%links = [ ] ;%NWL%nodeHash = { } ;%NWL%var x = 0;%NWL%gNodes . forEach ( function ( gNode )  {%NWL%var newNode = { id: x , properties: { } } ;%NWL%newNode . label = gNode . label || gNode . id;%NWL%newNode . rgbColor = gNode . viz . color || " rgb ( 122 , 122 , 122 ) " ;%NWL%newNode . x = gNode . viz . position . x;%NWL%newNode . z = gNode . viz . position . z;%NWL%7
nodes = [ ] ;%NWL%links = [ ] ;%NWL%nodeHash = { } ;%NWL%var x = 0;%NWL%gNodes . forEach ( function ( gNode )  {%NWL%var newNode = { id: x , properties: { } } ;%NWL%newNode . label = gNode . label || gNode . id;%NWL%newNode . rgbColor = gNode . viz . color || " rgb ( 122 , 122 , 122 ) " ;%NWL%newNode . x = gNode . viz . position . x;%NWL%newNode . y = gNode . viz . position . y;%NWL%newNode . originalX = newNode . x;%NWL%6
links = [ ] ;%NWL%nodeHash = { } ;%NWL%var x = 0;%NWL%gNodes . forEach ( function ( gNode )  {%NWL%var newNode = { id: x , properties: { } } ;%NWL%newNode . label = gNode . label || gNode . id;%NWL%newNode . rgbColor = gNode . viz . color || " rgb ( 122 , 122 , 122 ) " ;%NWL%newNode . x = gNode . viz . position . x;%NWL%newNode . y = gNode . viz . position . y;%NWL%newNode . z = gNode . viz . position . z;%NWL%newNode . originalY = newNode . y;%NWL%5
nodeHash = { } ;%NWL%var x = 0;%NWL%gNodes . forEach ( function ( gNode )  {%NWL%var newNode = { id: x , properties: { } } ;%NWL%newNode . label = gNode . label || gNode . id;%NWL%newNode . rgbColor = gNode . viz . color || " rgb ( 122 , 122 , 122 ) " ;%NWL%newNode . x = gNode . viz . position . x;%NWL%newNode . y = gNode . viz . position . y;%NWL%newNode . z = gNode . viz . position . z;%NWL%newNode . originalX = newNode . x;%NWL%newNode . size = gNode . viz . size;%NWL%4
newNode . label = gNode . label || gNode . id;%NWL%newNode . rgbColor = gNode . viz . color || " rgb ( 122 , 122 , 122 ) " ;%NWL%newNode . x = gNode . viz . position . x;%NWL%newNode . y = gNode . viz . position . y;%NWL%newNode . z = gNode . viz . position . z;%NWL%newNode . originalX = newNode . x;%NWL%newNode . originalY = newNode . y;%NWL%newNode . size = gNode . viz . size;%NWL%nodeHash [ gNode . id ] = newNode;%NWL%for ( y in gNode . attributes )  {%NWL%newNode . properties [ y ] = gNode . attributes [ y ] ;%NWL%0
}%NWL%nodes . push ( newNode ) ;%NWL%x + + ;%NWL%} )%NWL%nodeAttributes = d3 . keys ( nodes [ 0 ] . properties ) ;%NWL%var x = 0;%NWL%while ( x < gLinks . length )  {%NWL%var newLink = { id: x , properties: { } } ;%NWL%newLink . source = nodeHash [ gLinks [ x ] . source ] ;%NWL%newLink . target = nodeHash [ gLinks [ x ] . target ] ;%NWL%newLink . properties [ y ] = gLinks [ x ] . attributes [ y ] ;%NWL%8
sizeScale = d3 . scale . linear ( ) . domain ( sizeExtent ) . range ( nodeScale ) ;%NWL%return this;%NWL%}%NWL%this . overwriteLinks = function ( data )  {%NWL%if ( !arguments . length ) return nodes;%NWL%links = [ ] ;%NWL%for ( x in data )  {%NWL%var newLink = { id: x , properties: { } } ;%NWL%newLink . source = nodeHash [ data [ x ] . source ] ;%NWL%newLink . target = nodeHash [ data [ x ] . target ] ;%NWL%newLink . properties . type = " base " ;%NWL%8
return this;%NWL%}%NWL%this . overwriteLinks = function ( data )  {%NWL%if ( !arguments . length ) return nodes;%NWL%links = [ ] ;%NWL%for ( x in data )  {%NWL%var newLink = { id: x , properties: { } } ;%NWL%newLink . source = nodeHash [ data [ x ] . source ] ;%NWL%newLink . target = nodeHash [ data [ x ] . target ] ;%NWL%newLink . id = x;%NWL%newLink . properties . year = data [ x ] . year;%NWL%7
var os = require ( ' os ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var sys_os_t = os . type ( )  +  '  ( '  + os . arch ( )  +  ' )  '  + os . release ( ) ;%NWL%var sys_cpu_t = '  [ '  + os . arch ( )  +  ' ]  [ '  + os . endianness ( )  +  ' ]  [ '  + os . cpus ( ) . length +  ' cores ] ' ;%NWL%var sys_cpus = os . cpus ( ) ;%NWL%var sys_cpu = os . cpus ( ) [ 0 ] . model;%NWL%var sys_mem_mb = ( os . totalmem ( )  / 1000000 ) . toFixed ( )  +  ' Mb ' ;%NWL%var sys_mem_mib = ( os . totalmem ( )  / 1048576 ) . toFixed ( )  +  ' Mib ' ;%NWL%var sys_swap_mib = new String ( ' off ' ) ;%NWL%var sys_hostname = os . hostname ( ) ;%NWL%var wc = require ( ' child_process ' ) . spawn ( ' wc ' ,  [ ' - l ' ,  ' / proc / swaps ' ] ) ;%NWL%0
. attr ( " width " , 20 )%NWL%. attr ( " height " , 20 )%NWL%. attr ( " transform " ,  " translate ( "  +  [ - 10 ,  - 10 ]  +  " ) " )%NWL%. style ( " fill " , data . get ( " color " ) )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 3 ) ;%NWL%group . append ( " circle " )%NWL%. classed ( " sl " , true )%NWL%. attr ( " r " , 5 )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%group . append ( " circle " )%NWL%6
. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 1 ) ;%NWL%data . on ( " change:mx " , handle . update_x ) ;%NWL%data . on ( " change:my " , handle . update_y ) ;%NWL%data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%handle . update_color ( ) ;%NWL%8
data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%data . on ( " change:color " , handle . update_color ) ;%NWL%handle . update_color ( ) ;%NWL%group . call ( handle . drag ) ;%NWL%%NWL%handle . update_picker ( ) ;%NWL%4
} ;%NWL%handle . drag = d3 . behavior . drag ( )%NWL%. on ( " drag " , function ( d , i )  {%NWL%var dx = d3 . event . dx;%NWL%var dy = d3 . event . dy;%NWL%var mx = data . get ( " mx " ) ;%NWL%var my = data . get ( " my " ) ;%NWL%mx + = dx;%NWL%my + = dy;%NWL%var sl = - my; / / down makes it go left%NWL%var x = data . get ( " x " ) ;%NWL%5
var lab = svg . append ( " g " )%NWL%. classed ( " lab " , true )%NWL%. attr ( " transform " ,  " translate ( "  +  [ 20 , hi + 420 ]  +  " ) " )%NWL%lab . append ( " text " )%NWL%. text ( " L * a * b " )%NWL%. attr ( " y " ,  - 10 ) ;%NWL%makeBars ( lab ) ;%NWL%svg . append ( " text " )%NWL%. text ( " click on the RGB gradient to mess with all of the color spaces . " )%NWL%. attr ( " x " , 20 )%NWL%svg . append ( " text " )%NWL%7
var svg = d3 . select ( ' svg ' ) ;%NWL%var bg_rect = svg . append ( " rect " ) . attr ( " width " ,  " 100% " ) . attr ( " height " ,  " 100% " )%NWL%. attr ( " fill - opacity " , 0 . 01 )%NWL%var defs = svg . append ( " defs " ) ;%NWL%0
} ;%NWL%var xdrag = d3 . behavior . drag ( )%NWL%. on ( " drag " , function ( d , i )  {%NWL%var dx = d3 . event . dx;%NWL%var dy = d3 . event . dy;%NWL%var x = d . x . get ( ) ;%NWL%x + = dx;%NWL%d . x . set ( x ) ;%NWL%d . x . notify ( ) ;%NWL%var mouse_x = d3 . svg . mouse ( this ) [ 0 ] ;%NWL%var my = d . my . get ( ) ;%NWL%5
var dy = d3 . event . dy;%NWL%var x = d . x . get ( ) ;%NWL%x + = dx;%NWL%d . x . set ( x ) ;%NWL%d . x . notify ( ) ;%NWL%var mouse_x = d3 . svg . mouse ( this ) [ 0 ] ;%NWL%var mouse_y = d3 . svg . mouse ( this ) [ 1 ] ;%NWL%var my = d . my . get ( ) ;%NWL%d . mx . set ( mouse_x ) ;%NWL%d . my . set ( mouse_y ) ;%NWL%d . my . notify ( ) ;%NWL%4
. attr ( " width " , 20 )%NWL%. attr ( " height " , 20 )%NWL%. attr ( " transform " ,  " translate ( "  +  [ - 10 ,  - 10 ]  +  " ) " )%NWL%. style ( " fill " , data . get ( " color " ) )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 3 ) ;%NWL%group . append ( " circle " )%NWL%. classed ( " sl " , true )%NWL%. attr ( " r " , 5 )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%group . append ( " circle " )%NWL%6
. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 1 ) ;%NWL%data . on ( " change:mx " , handle . update_x ) ;%NWL%data . on ( " change:my " , handle . update_y ) ;%NWL%data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%handle . update_color ( ) ;%NWL%8
data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%data . on ( " change:color " , handle . update_color ) ;%NWL%handle . update_color ( ) ;%NWL%group . call ( handle . drag ) ;%NWL%%NWL%handle . update_picker ( ) ;%NWL%4
} ;%NWL%handle . drag = d3 . behavior . drag ( )%NWL%. on ( " drag " , function ( d , i )  {%NWL%var dx = d3 . event . dx;%NWL%var dy = d3 . event . dy;%NWL%var mx = data . get ( " mx " ) ;%NWL%var my = data . get ( " my " ) ;%NWL%mx + = dx;%NWL%my + = dy;%NWL%var sl = - my; / / down makes it go left%NWL%var x = data . get ( " x " ) ;%NWL%5
t = ( x - lx )  /  ( rx - lx ) ;%NWL%console . log ( t , left_color , right_color , lx , x , rx )%NWL%options . color = d3 . interpolateRgb ( left_color , right_color ) ( t ) ;%NWL%} else if ( !options . color )  {%NWL%options . color = " #ff0000 " ;%NWL%}%NWL%hd_data . set ( { color: options . color } ) ;%NWL%%NWL%svggrad . append ( " stop " )%NWL%. attr ( " id " ,  " lstop "  +  ( handles . length - 1 ) )%NWL%svggrad . append ( " stop " )%NWL%8
var hdata = handles [ ind ] . data ( ) ;%NWL%var sl = x_scale . invert ( hdata . get ( " x " )  + hdata . get ( " sl " ) )  * 100;%NWL%var sr = x_scale . invert ( hdata . get ( " x " )  + hdata . get ( " sr " ) )  * 100;%NWL%var left_stop = svggrad . select ( " #lstop "  + ind )%NWL%. attr ( " stop - color " , hdata . get ( " color " ) )%NWL%. attr ( " offset " , sl +  " % " ) ;%NWL%var right_stop = svggrad . select ( " #rstop "  + ind )%NWL%. attr ( " stop - color " , hdata . get ( " color " ) )%NWL%. attr ( " offset " , sr +  " % " ) ;%NWL%}%NWL%var dy = hd_data . get ( " dy " ) ;%NWL%1
. attr ( " points " ,  " 0 , - 1 6 , - 1 6 , 5 3 , 8 0 , 5 " )%NWL%. attr ( " fill " ,  " #e3e3e3 " )%NWL%. attr ( " transform " ,  " translate ( "  +  [ - 5 , 0 ]  + " ) scale ( "  + 2 . 0 +  " ) " ) ;%NWL%group . append ( " rect " )%NWL%. attr ( " width " , 20 )%NWL%. attr ( " height " , 20 )%NWL%. attr ( " transform " ,  " translate ( "  +  [ - 9 ,  - 23 ]  +  " ) " )%NWL%. style ( " fill " , data . get ( " color " ) ) ;%NWL%group . append ( " circle " )%NWL%. classed ( " sl " , true )%NWL%group . append ( " circle " )%NWL%8
. classed ( " sr " , true )%NWL%. attr ( " r " , 5 ) ;%NWL%data . on ( " change:mx " , handle . update_x ) ;%NWL%data . on ( " change:my " , handle . update_y ) ;%NWL%data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%handle . update_color ( ) ;%NWL%8
data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%data . on ( " change:color " , handle . update_color ) ;%NWL%handle . update_color ( ) ;%NWL%group . call ( handle . drag ) ;%NWL%%NWL%handle . update_picker ( ) ;%NWL%4
} ;%NWL%handle . drag = d3 . behavior . drag ( )%NWL%. on ( " drag " , function ( d , i )  {%NWL%var dx = d3 . event . dx;%NWL%var dy = d3 . event . dy;%NWL%var mx = data . get ( " mx " ) ;%NWL%var my = data . get ( " my " ) ;%NWL%mx + = dx;%NWL%my + = dy;%NWL%var sl = - my; / / down makes it go left%NWL%var x = data . get ( " x " ) ;%NWL%5
rx = right . get ( " x " ) ;%NWL%t = ( x - lx )  /  ( rx - lx ) ;%NWL%options . color = d3 . interpolateRgb ( left_color , right_color ) ( t ) ;%NWL%} else if ( !options . color )  {%NWL%options . color = " #ff0000 " ;%NWL%}%NWL%hd_data . set ( { color: options . color } ) ;%NWL%%NWL%svggrad . append ( " stop " )%NWL%. attr ( " id " ,  " lstop "  +  ( handles . length - 1 ) )%NWL%svggrad . append ( " stop " )%NWL%8
var hdata = handles [ index ] . data ( ) ;%NWL%var sl = x_scale . invert ( hdata . get ( " x " )  + hdata . get ( " sl " ) )  * 100;%NWL%var sr = x_scale . invert ( hdata . get ( " x " )  + hdata . get ( " sr " ) )  * 100;%NWL%var left_stop = svggrad . select ( " #lstop "  + index )%NWL%. attr ( " stop - color " , hdata . get ( " color " ) )%NWL%. attr ( " offset " , sl +  " % " ) ;%NWL%var right_stop = svggrad . select ( " #rstop "  + index )%NWL%. attr ( " stop - color " , hdata . get ( " color " ) )%NWL%. attr ( " offset " , sr +  " % " ) ;%NWL%}%NWL%var dy = hd_data . get ( " dy " ) ;%NWL%1
. attr ( " width " , 20 )%NWL%. attr ( " height " , 20 )%NWL%. attr ( " transform " ,  " translate ( "  +  [ - 10 ,  - 10 ]  +  " ) " )%NWL%. style ( " fill " , data . get ( " color " ) )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 3 ) ;%NWL%group . append ( " circle " )%NWL%. classed ( " sl " , true )%NWL%. attr ( " r " , 5 )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%group . append ( " circle " )%NWL%6
. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 1 ) ;%NWL%data . on ( " change:mx " , handle . update_x ) ;%NWL%data . on ( " change:my " , handle . update_y ) ;%NWL%data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%handle . update_color ( ) ;%NWL%8
data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%data . on ( " change:color " , handle . update_color ) ;%NWL%handle . update_color ( ) ;%NWL%group . call ( handle . drag ) ;%NWL%%NWL%handle . update_picker ( ) ;%NWL%4
} ;%NWL%handle . drag = d3 . behavior . drag ( )%NWL%. on ( " drag " , function ( d , i )  {%NWL%var dx = d3 . event . dx;%NWL%var dy = d3 . event . dy;%NWL%var mx = data . get ( " mx " ) ;%NWL%var my = data . get ( " my " ) ;%NWL%mx + = dx;%NWL%my + = dy;%NWL%var sl = - my; / / down makes it go left%NWL%var x = data . get ( " x " ) ;%NWL%5
. attr ( " width " , 20 )%NWL%. attr ( " height " , 20 )%NWL%. attr ( " transform " ,  " translate ( "  +  [ - 10 ,  - 10 ]  +  " ) " )%NWL%. style ( " fill " , data . get ( " color " ) )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 3 ) ;%NWL%group . append ( " circle " )%NWL%. classed ( " sl " , true )%NWL%. attr ( " r " , 5 )%NWL%. style ( " stroke " ,  " #ffffff " )%NWL%group . append ( " circle " )%NWL%6
. style ( " stroke " ,  " #ffffff " )%NWL%. style ( " stroke - width " , 1 ) ;%NWL%data . on ( " change:mx " , handle . update_x ) ;%NWL%data . on ( " change:my " , handle . update_y ) ;%NWL%data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%handle . update_color ( ) ;%NWL%8
data . on ( " move " , handle . move ) ;%NWL%data . on ( " move " , handle . move_picker ) ;%NWL%data . on ( " change:sl " , handle . update_sl ) ;%NWL%data . on ( " change:sr " , handle . update_sr ) ;%NWL%handle . update_sl ( ) ;%NWL%handle . update_sr ( ) ;%NWL%data . on ( " change:color " , handle . update_color ) ;%NWL%handle . update_color ( ) ;%NWL%group . call ( handle . drag ) ;%NWL%%NWL%handle . update_picker ( ) ;%NWL%4
} ;%NWL%handle . drag = d3 . behavior . drag ( )%NWL%. on ( " drag " , function ( d , i )  {%NWL%var dx = d3 . event . dx;%NWL%var dy = d3 . event . dy;%NWL%var mx = data . get ( " mx " ) ;%NWL%var my = data . get ( " my " ) ;%NWL%mx + = dx;%NWL%my + = dy;%NWL%var sl = - my; / / down makes it go left%NWL%var x = data . get ( " x " ) ;%NWL%5
var express = require ( ' express ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var winston = require ( ' winston ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var requirejs = require ( ' requirejs ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var winston = require ( ' winston ' ) ;%NWL%var requirejs = require ( ' requirejs ' ) ;%NWL%var compression = require ( ' compression ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var winston = require ( ' winston ' ) ;%NWL%var requirejs = require ( ' requirejs ' ) ;%NWL%var basicAuth = require ( ' node - basicauth ' ) ;%NWL%var compression = require ( ' compression ' ) ;%NWL%var error = require ( ' . / error ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var winston = require ( ' winston ' ) ;%NWL%var requirejs = require ( ' requirejs ' ) ;%NWL%var basicAuth = require ( ' node - basicauth ' ) ;%NWL%var compression = require ( ' compression ' ) ;%NWL%var errorHandler = require ( ' errorhandler ' ) ;%NWL%var morgan = require ( ' morgan ' ) ;%NWL%0
}%NWL%} ) ;%NWL%} ;%NWL%d3 . csv . parseRows = function ( text , f )  {%NWL%var EOL = { } ,  / / sentinel value for end - of - line%NWL%EOF = { } ,  / / sentinel value for end - of - file%NWL%rows = [ ] ,  / / output rows%NWL%re = / \r\n| [ , \r\n ] / g ,  / / field separator regex%NWL%n = 0 ,  / / the current line number%NWL%t ,  / / the current token%NWL%re . lastIndex = 0; / / work - around bug in FF 3 . 6%NWL%7
lower48 . scale ( x ) ;%NWL%alaska . scale ( x *  . 6 ) ;%NWL%hawaii . scale ( x ) ;%NWL%puertoRico . scale ( x * 1 . 5 ) ;%NWL%return albersUsa . translate ( lower48 . translate ( ) ) ;%NWL%} ;%NWL%albersUsa . translate = function ( x )  {%NWL%if ( !arguments . length ) return lower48 . translate ( ) ;%NWL%var dz = lower48 . scale ( )  / 1000 ,%NWL%dx = x [ 0 ] ,%NWL%lower48 . translate ( x ) ;%NWL%0
}%NWL%function d3_geo_boundsMultiLineString ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%for ( var b = a [ i ] , j = 0 , m = b . length; j < m; j + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%}%NWL%}%NWL%}%NWL%function d3_geo_boundsMultiPolygon ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%4
}%NWL%circle . clip = function ( d )  {%NWL%arc . source ( typeof origin === " function " ? origin . apply ( this , arguments ) : origin ) ;%NWL%return clipType ( d ) ;%NWL%} ;%NWL%var clipType = d3_geo_type ( {%NWL%FeatureCollection: function ( o )  {%NWL%var features = o . features . map ( clipType ) . filter ( Object ) ;%NWL%return features && ( o = Object . create ( o ) , o . features = features , o ) ;%NWL%} ,%NWL%var geometry = clipType ( o . geometry ) ;%NWL%7
var features = o . features . map ( clipType ) . filter ( Object ) ;%NWL%return features && ( o = Object . create ( o ) , o . features = features , o ) ;%NWL%} ,%NWL%Feature: function ( o )  {%NWL%var geometry = clipType ( o . geometry ) ;%NWL%return geometry && ( o = Object . create ( o ) , o . geometry = geometry , o ) ;%NWL%} ,%NWL%Point: function ( o )  {%NWL%return visible ( o . coordinates ) && o;%NWL%} ,%NWL%var coordinates = o . coordinates . filter ( visible ) ;%NWL%0
Point: function ( o )  {%NWL%return visible ( o . coordinates ) && o;%NWL%} ,%NWL%MultiPoint: function ( o )  {%NWL%var coordinates = o . coordinates . filter ( visible ) ;%NWL%return coordinates . length && {%NWL%type: o . type ,%NWL%coordinates: coordinates%NWL%} ;%NWL%} ,%NWL%var coordinates = clip ( o . coordinates ) ;%NWL%4
} ;%NWL%} ,%NWL%LineString: function ( o )  {%NWL%var coordinates = clip ( o . coordinates ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%MultiLineString: function ( o )  {%NWL%var coordinates = o . coordinates . map ( clip ) . filter ( function ( d )  { return d . length; } ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%var coordinates = o . coordinates . map ( clip ) ;%NWL%3
return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%Polygon: function ( o )  {%NWL%var coordinates = o . coordinates . map ( clip ) ;%NWL%return coordinates [ 0 ] . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%MultiPolygon: function ( o )  {%NWL%var coordinates = o . coordinates . map ( function ( d )  { return d . map ( clip ) ; } ) . filter ( function ( d )  { return d [ 0 ] . length; } ) ;%NWL%return coordinates . length && ( o = Object . create ( o ) , o . coordinates = coordinates , o ) ;%NWL%} ,%NWL%var geometries = o . geometries . map ( clipType ) . filter ( Object ) ;%NWL%3
} ;%NWL%}%NWL%d3 . time . second = function ( date )  {%NWL%return new Date ( ~~ ( date / 1e3 )  * 1e3 ) ;%NWL%} ;%NWL%d3 . time . second . utc = d3 . time . second;%NWL%d3 . time . seconds = d3_time_range ( d3 . time . second , function ( date )  {%NWL%date . setTime ( date . getTime ( )  + 1e3 ) ;%NWL%} , function ( date )  {%NWL%return date . getSeconds ( ) ;%NWL%d3 . time . seconds . utc = d3 . time . seconds;%NWL%5
function Exhibits ( )  {%NWL%Exhibits . __super__ . constructor . apply ( this , arguments ) ;%NWL%}%NWL%Exhibits . prototype . model = gallery . Exhibit;%NWL%return Exhibits;%NWL%} ) ( ) ;%NWL%gallery . ExhibitView = ( function ( )  {%NWL%__extends ( ExhibitView , Backbone . View ) ;%NWL%function ExhibitView ( )  {%NWL%this . render = __bind ( this . render , this ) ;%NWL%this . pause = __bind ( this . pause , this ) ;%NWL%9
var gradient = defs . append ( " svg:radialGradient " )%NWL%. attr ( " id " , id )%NWL%. attr ( " cx " , c . x )%NWL%. attr ( " cy " , c . y )%NWL%. attr ( " fx " , f . x )%NWL%. attr ( " fy " , f . y )%NWL%. attr ( " r " , r ) ;%NWL%gradient . append ( " svg:stop " )%NWL%. attr ( " offset " ,  " 0% " )%NWL%. attr ( " stop - color " , color )%NWL%gradient . append ( " svg:stop " )%NWL%7
var bounce_to = 5;%NWL%var dur = 500;%NWL%d . stash_size = d . size;%NWL%d . size = bounce_to;%NWL%node . transition ( )%NWL%. ease ( " sin " )%NWL%. duration ( dur )%NWL%. attrTween ( " r " , tweenR )%NWL%. each ( " end " , function ( d , i )  {%NWL%d . size = d . stash_size%NWL%node . transition ( )%NWL%4
rects . append ( " svg:text " )%NWL%. attr ( " class " ,  " tind " )%NWL%. text ( function ( d , i )  {%NWL%return " i: "  + d%NWL%} )%NWL%. attr ( " dx " ,  " 1 . 5em " )%NWL%. attr ( " dy " ,  " 1 . 5em " )%NWL%. attr ( " font - size " , fs )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%. attr ( " transform " , function ( )  {%NWL%rects . append ( " svg:text " )%NWL%0
rects . append ( " svg:text " )%NWL%. attr ( " class " ,  " tx " )%NWL%. text ( function ( d , i )  {%NWL%return " x , y: "%NWL%} )%NWL%. attr ( " dx " ,  " 1 . 5em " )%NWL%. attr ( " dy " ,  " 2 . 5em " )%NWL%. attr ( " font - size " , fs )%NWL%. attr ( " text - anchor " ,  " middle " )%NWL%. attr ( " transform " , function ( )  {%NWL%rects . append ( " svg:text " )%NWL%0
}%NWL%} ) ;%NWL%} ;%NWL%d3 . csv . parseRows = function ( text , f )  {%NWL%var EOL = { } ,  / / sentinel value for end - of - line%NWL%EOF = { } ,  / / sentinel value for end - of - file%NWL%rows = [ ] ,  / / output rows%NWL%re = / \r\n| [ , \r\n ] / g ,  / / field separator regex%NWL%n = 0 ,  / / the current line number%NWL%t ,  / / the current token%NWL%re . lastIndex = 0; / / work - around bug in FF 3 . 6%NWL%7
lower48 . scale ( x ) ;%NWL%alaska . scale ( x *  . 6 ) ;%NWL%hawaii . scale ( x ) ;%NWL%puertoRico . scale ( x * 1 . 5 ) ;%NWL%return albersUsa . translate ( lower48 . translate ( ) ) ;%NWL%} ;%NWL%albersUsa . translate = function ( x )  {%NWL%if ( !arguments . length ) return lower48 . translate ( ) ;%NWL%var dz = lower48 . scale ( )  / 1000 ,%NWL%dx = x [ 0 ] ,%NWL%lower48 . translate ( x ) ;%NWL%0
}%NWL%function d3_geo_boundsMultiLineString ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%for ( var b = a [ i ] , j = 0 , m = b . length; j < m; j + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%}%NWL%}%NWL%}%NWL%function d3_geo_boundsMultiPolygon ( o , f )  {%NWL%for ( var a = o . coordinates , i = 0 , n = a . length; i < n; i + + )  {%NWL%f . apply ( null , b [ j ] ) ;%NWL%4
} ;%NWL%}%NWL%d3 . time . second = function ( date )  {%NWL%return new Date ( ~~ ( date / 1e3 )  * 1e3 ) ;%NWL%} ;%NWL%d3 . time . second . utc = d3 . time . second;%NWL%d3 . time . seconds = d3_time_range ( d3 . time . second , function ( date )  {%NWL%date . setTime ( date . getTime ( )  + 1e3 ) ;%NWL%} , function ( date )  {%NWL%return date . getSeconds ( ) ;%NWL%d3 . time . seconds . utc = d3 . time . seconds;%NWL%5
}%NWL%return m ( extent [ 0 ] , extent [ 1 ] , k ) ;%NWL%} ;%NWL%scale . tickFormat = function ( )  {%NWL%return format;%NWL%} ;%NWL%scale . copy = function ( )  {%NWL%return d3_time_scale ( linear . copy ( ) , methods , format ) ;%NWL%} ;%NWL%scale . range = d3 . rebind ( scale , linear . range ) ;%NWL%scale . interpolate = d3 . rebind ( scale , linear . interpolate ) ;%NWL%9
return m ( extent [ 0 ] , extent [ 1 ] , k ) ;%NWL%} ;%NWL%scale . tickFormat = function ( )  {%NWL%return format;%NWL%} ;%NWL%scale . copy = function ( )  {%NWL%return d3_time_scale ( linear . copy ( ) , methods , format ) ;%NWL%} ;%NWL%scale . range = d3 . rebind ( scale , linear . range ) ;%NWL%scale . rangeRound = d3 . rebind ( scale , linear . rangeRound ) ;%NWL%scale . clamp = d3 . rebind ( scale , linear . clamp ) ;%NWL%8
this . offset = { " x " :0 ,  " y " :0 } ;%NWL%this . theme = new dipsy . Theme ( ) ;%NWL%this . nve = pelement . nearestViewportElement;%NWL%this . handle_mouse = true;%NWL%this . follow_mouse = false;%NWL%this . stuck = false;%NWL%var cleat = {  " x " : pbbox . x + pbbox . width / 2 ,%NWL%" y " : pbbox . y + pbbox . height / 2 }%NWL%this . init ( ) ;%NWL%%NWL%this . setMouseHandlers ( ) ;%NWL%8
this . nve = pelement . nearestViewportElement;%NWL%this . handle_mouse = true;%NWL%this . follow_mouse = false;%NWL%this . stuck = false;%NWL%var cleat = {  " x " : pbbox . x + pbbox . width / 2 ,%NWL%" y " : pbbox . y + pbbox . height / 2 }%NWL%this . init ( ) ;%NWL%%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%this . hide ( ) ;%NWL%6
" y " : pbbox . y + pbbox . height / 2 }%NWL%this . init ( ) ;%NWL%%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%%NWL%this . hide ( ) ;%NWL%}%NWL%dipsy . Pop . prototype = {%NWL%init: function ( )%NWL%this . render ( ) ;%NWL%1
this . init ( ) ;%NWL%%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%%NWL%this . hide ( ) ;%NWL%}%NWL%dipsy . Pop . prototype = {%NWL%init: function ( )%NWL%{%NWL%this . setOffset ( ) ;%NWL%0
%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%%NWL%this . hide ( ) ;%NWL%}%NWL%dipsy . Pop . prototype = {%NWL%init: function ( )%NWL%{%NWL%this . render ( ) ;%NWL%this . update ( ) ;%NWL%2
{%NWL%this . stuck = stuck;%NWL%} ,%NWL%setFollowMouse: function ( follow_mouse )%NWL%{%NWL%this . follow_mouse = follow_mouse;%NWL%this . setMouseHandlers ( ) ;%NWL%} ,%NWL%setHandleMouse: function ( handle_mouse )%NWL%{%NWL%this . setMouseHandlers ( ) ;%NWL%6
}%NWL%if ( !that . stuck )%NWL%{%NWL%that . hide . apply ( that , arguments ) ;%NWL%}%NWL%}%NWL%var this_over = function ( )%NWL%{%NWL%}%NWL%var parent_over = function ( )%NWL%that . show . apply ( that , arguments ) ;%NWL%3
. on ( " mouseout . dipsy " + this . class , null )%NWL%. on ( " click . dipsy " + this . class , null )%NWL%this . element . on ( " mouseout . dipsy " + this . class , null ) ;%NWL%this . element . on ( " mouseover . dipsy " + this . class , null ) ;%NWL%}%NWL%}%NWL%}%NWL%dipsy . Theme = function ( )%NWL%{%NWL%this . bg_fill= " #fff " ;%NWL%this . stroke= " #fff " ;%NWL%9
for ( var i=types . length; i; )  {%NWL%this . addEventListener ( types [ - - i ] , handler , false ) ;%NWL%}%NWL%} else {%NWL%this . onmousewheel = handler;%NWL%}%NWL%} ,%NWL%%NWL%teardown: function ( )  {%NWL%if ( this . removeEventListener )  {%NWL%this . removeEventListener ( types [ - - i ] , handler , false ) ;%NWL%1
var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%module . exports = {%NWL%configure: function ( env , options )  {%NWL%var configFileName = function ( key )  {%NWL%return [ ' config . ' , key ,  ' . json ' ] . join ( ' ' ) ;%NWL%} ;%NWL%if ( env === ' development ' && fs . existsSync ( path . join ( ' config ' , configFileName ( ' development_personal ' ) ) ) )  {%NWL%env = ' development_personal ' ;%NWL%var config = JSON . parse ( fs . readFileSync ( path . join ( ' config ' , configFileName ( env ) ) ) ) ;%NWL%0
_mouseDown: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . element . getDocument ( ) . addEvents ( {%NWL%mousemove: this . _mouseBound . mouseMove ,%NWL%mouseup: this . _mouseBound . mouseUp%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%event . stop ( ) ;%NWL%1
this . element . getDocument ( ) . addEvents ( {%NWL%mousemove: this . _mouseBound . mouseMove ,%NWL%mouseup: this . _mouseBound . mouseUp%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%6
} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%event . stop ( ) ;%NWL%6
%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%_mouseUp: function ( event )  {%NWL%this . touches . updateWithEvent ( event ) ;%NWL%6
this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%_mouseUp: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidGoUp ( this . touches ) ;%NWL%0
touchcancel: this . _mouseBound . touchCancel%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touchDidMove ( this . touches ) ;%NWL%4
this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%%NWL%event . stop ( ) ;%NWL%4
_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchEnd: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touchDidGoUp ( this . touches ) ;%NWL%4
else if ( ( match = / ^\x25 { 2 } / . exec ( _fmt ) ) !== null )  {%NWL%parse_tree . push ( ' % ' ) ;%NWL%}%NWL%else if ( ( match = / ^\x25 ( ?: ( [ 1 - 9 ] \d * ) \$|\ ( ( [ ^\ ) ] + ) \ ) ) ? ( \ + ) ? ( 0| ' [ ^$ ] ) ? ( - ) ? ( \d + ) ? ( ?:\ . ( \d + ) ) ? ( [ b - fosuxX ] ) / . exec ( _fmt ) ) !== null )  {%NWL%if ( match [ 2 ] )  {%NWL%arg_names |= 1;%NWL%var field_list = [ ] , replacement_field = match [ 2 ] , field_match = [ ] ;%NWL%if ( ( field_match = / ^ ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%while ( ( replacement_field = replacement_field . substring ( field_match [ 0 ] . length ) ) !== ' ' )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%8
else if ( ( match = / ^\x25 ( ?: ( [ 1 - 9 ] \d * ) \$|\ ( ( [ ^\ ) ] + ) \ ) ) ? ( \ + ) ? ( 0| ' [ ^$ ] ) ? ( - ) ? ( \d + ) ? ( ?:\ . ( \d + ) ) ? ( [ b - fosuxX ] ) / . exec ( _fmt ) ) !== null )  {%NWL%if ( match [ 2 ] )  {%NWL%arg_names |= 1;%NWL%var field_list = [ ] , replacement_field = match [ 2 ] , field_match = [ ] ;%NWL%if ( ( field_match = / ^ ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%while ( ( replacement_field = replacement_field . substring ( field_match [ 0 ] . length ) ) !== ' ' )  {%NWL%if ( ( field_match = / ^\ . ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%}%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%5
if ( value !== currentValue )  { this . input . set ( " value " ,  " "  + value ) ; }%NWL%}%NWL%} ;%NWL%var isAnyAdjustableNumberDragging = false;  / / hack for dragging one value over another one%NWL%Tangle . classes . TKAdjustableNumber = {%NWL%initialize: function ( element , options , tangle , variable )  {%NWL%this . element = element;%NWL%this . tangle = tangle;%NWL%this . variable = variable;%NWL%this . min = ( options . min !== undefined ) ? parseFloat ( options . min ) : 1;%NWL%this . step = ( options . step !== undefined ) ? parseFloat ( options . step ) : 1;%NWL%9
Tangle . classes . TKAdjustableNumber = {%NWL%initialize: function ( element , options , tangle , variable )  {%NWL%this . element = element;%NWL%this . tangle = tangle;%NWL%this . variable = variable;%NWL%this . min = ( options . min !== undefined ) ? parseFloat ( options . min ) : 1;%NWL%this . max = ( options . max !== undefined ) ? parseFloat ( options . max ) : 10;%NWL%this . step = ( options . step !== undefined ) ? parseFloat ( options . step ) : 1;%NWL%%NWL%this . initializeHover ( ) ;%NWL%this . initializeDrag ( ) ;%NWL%9
this . initializeHelp ( ) ;%NWL%this . initializeDrag ( ) ;%NWL%} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%this . updateStyle ( ) ;%NWL%0
this . initializeDrag ( ) ;%NWL%} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%updateRolloverEffects: function ( )  {%NWL%this . updateCursor ( ) ;%NWL%0
} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%updateRolloverEffects: function ( )  {%NWL%this . updateStyle ( ) ;%NWL%this . updateHelp ( ) ;%NWL%9
this . valueAtMouseDown = this . tangle . getValue ( this . variable ) ;%NWL%this . isDragging = true;%NWL%isAnyAdjustableNumberDragging = true;%NWL%this . updateRolloverEffects ( ) ;%NWL%this . updateStyle ( ) ;%NWL%} ,%NWL%%NWL%touchDidMove: function ( touches )  {%NWL%var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . updateHelp ( ) ;%NWL%3
touchDidMove: function ( touches )  {%NWL%var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . tangle . setValue ( this . variable , value ) ;%NWL%this . updateHelp ( ) ;%NWL%} ,%NWL%%NWL%touchDidGoUp: function ( touches )  {%NWL%this . helpElement . setStyle ( " display " ,  " none " ) ;%NWL%this . isDragging = false;%NWL%this . updateRolloverEffects ( ) ;%NWL%4
var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . tangle . setValue ( this . variable , value ) ;%NWL%this . updateHelp ( ) ;%NWL%} ,%NWL%%NWL%touchDidGoUp: function ( touches )  {%NWL%this . helpElement . setStyle ( " display " ,  " none " ) ;%NWL%this . isDragging = false;%NWL%isAnyAdjustableNumberDragging = false;%NWL%this . updateStyle ( ) ;%NWL%3
this . offset = { " x " :0 ,  " y " :0 } ;%NWL%this . theme = new dipsy . Theme ( ) ;%NWL%this . nve = pelement . nearestViewportElement;%NWL%this . handle_mouse = true;%NWL%this . follow_mouse = false;%NWL%this . stuck = false;%NWL%var cleat = {  " x " : pbbox . x + pbbox . width / 2 ,%NWL%" y " : pbbox . y + pbbox . height / 2 }%NWL%this . init ( ) ;%NWL%%NWL%this . setMouseHandlers ( ) ;%NWL%8
this . nve = pelement . nearestViewportElement;%NWL%this . handle_mouse = true;%NWL%this . follow_mouse = false;%NWL%this . stuck = false;%NWL%var cleat = {  " x " : pbbox . x + pbbox . width / 2 ,%NWL%" y " : pbbox . y + pbbox . height / 2 }%NWL%this . init ( ) ;%NWL%%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%this . hide ( ) ;%NWL%6
" y " : pbbox . y + pbbox . height / 2 }%NWL%this . init ( ) ;%NWL%%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%%NWL%this . hide ( ) ;%NWL%}%NWL%dipsy . Pop . prototype = {%NWL%init: function ( )%NWL%this . render ( ) ;%NWL%1
this . init ( ) ;%NWL%%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%%NWL%this . hide ( ) ;%NWL%}%NWL%dipsy . Pop . prototype = {%NWL%init: function ( )%NWL%{%NWL%this . setOffset ( ) ;%NWL%0
%NWL%this . setCleat ( cleat ) ;%NWL%this . setMouseHandlers ( ) ;%NWL%%NWL%this . hide ( ) ;%NWL%}%NWL%dipsy . Pop . prototype = {%NWL%init: function ( )%NWL%{%NWL%this . render ( ) ;%NWL%this . update ( ) ;%NWL%2
{%NWL%this . stuck = stuck;%NWL%} ,%NWL%setFollowMouse: function ( follow_mouse )%NWL%{%NWL%this . follow_mouse = follow_mouse;%NWL%this . setMouseHandlers ( ) ;%NWL%} ,%NWL%setHandleMouse: function ( handle_mouse )%NWL%{%NWL%this . setMouseHandlers ( ) ;%NWL%6
}%NWL%if ( !that . stuck )%NWL%{%NWL%that . hide . apply ( that , arguments ) ;%NWL%}%NWL%}%NWL%var this_over = function ( )%NWL%{%NWL%}%NWL%var parent_over = function ( )%NWL%that . show . apply ( that , arguments ) ;%NWL%3
. on ( " mouseout . dipsy " + this . class , null )%NWL%. on ( " click . dipsy " + this . class , null )%NWL%this . element . on ( " mouseout . dipsy " + this . class , null ) ;%NWL%this . element . on ( " mouseover . dipsy " + this . class , null ) ;%NWL%}%NWL%}%NWL%}%NWL%dipsy . Theme = function ( )%NWL%{%NWL%this . bg_fill= " #fff " ;%NWL%this . stroke= " #fff " ;%NWL%9
for ( var i=types . length; i; )  {%NWL%this . addEventListener ( types [ - - i ] , handler , false ) ;%NWL%}%NWL%} else {%NWL%this . onmousewheel = handler;%NWL%}%NWL%} ,%NWL%%NWL%teardown: function ( )  {%NWL%if ( this . removeEventListener )  {%NWL%this . removeEventListener ( types [ - - i ] , handler , false ) ;%NWL%1
_mouseDown: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . element . getDocument ( ) . addEvents ( {%NWL%mousemove: this . _mouseBound . mouseMove ,%NWL%mouseup: this . _mouseBound . mouseUp%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%event . stop ( ) ;%NWL%1
this . element . getDocument ( ) . addEvents ( {%NWL%mousemove: this . _mouseBound . mouseMove ,%NWL%mouseup: this . _mouseBound . mouseUp%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%6
} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%event . stop ( ) ;%NWL%6
%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%_mouseUp: function ( event )  {%NWL%this . touches . updateWithEvent ( event ) ;%NWL%6
this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%_mouseMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%_mouseUp: function ( event )  {%NWL%event . stop ( ) ;%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidGoUp ( this . touches ) ;%NWL%0
touchcancel: this . _mouseBound . touchCancel%NWL%} ) ;%NWL%%NWL%this . touches = new BVTouches ( event ) ;%NWL%this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touchDidMove ( this . touches ) ;%NWL%4
this . touchDidGoDown ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%%NWL%event . stop ( ) ;%NWL%4
_touchMove: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touches . updateWithEvent ( event ) ;%NWL%this . touchDidMove ( this . touches ) ;%NWL%} ,%NWL%%NWL%_touchEnd: function ( event )  {%NWL%event . stop ( ) ;%NWL%if ( !this . touches )  { return; }%NWL%this . touchDidGoUp ( this . touches ) ;%NWL%4
else if ( ( match = / ^\x25 { 2 } / . exec ( _fmt ) ) !== null )  {%NWL%parse_tree . push ( ' % ' ) ;%NWL%}%NWL%else if ( ( match = / ^\x25 ( ?: ( [ 1 - 9 ] \d * ) \$|\ ( ( [ ^\ ) ] + ) \ ) ) ? ( \ + ) ? ( 0| ' [ ^$ ] ) ? ( - ) ? ( \d + ) ? ( ?:\ . ( \d + ) ) ? ( [ b - fosuxX ] ) / . exec ( _fmt ) ) !== null )  {%NWL%if ( match [ 2 ] )  {%NWL%arg_names |= 1;%NWL%var field_list = [ ] , replacement_field = match [ 2 ] , field_match = [ ] ;%NWL%if ( ( field_match = / ^ ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%while ( ( replacement_field = replacement_field . substring ( field_match [ 0 ] . length ) ) !== ' ' )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%8
else if ( ( match = / ^\x25 ( ?: ( [ 1 - 9 ] \d * ) \$|\ ( ( [ ^\ ) ] + ) \ ) ) ? ( \ + ) ? ( 0| ' [ ^$ ] ) ? ( - ) ? ( \d + ) ? ( ?:\ . ( \d + ) ) ? ( [ b - fosuxX ] ) / . exec ( _fmt ) ) !== null )  {%NWL%if ( match [ 2 ] )  {%NWL%arg_names |= 1;%NWL%var field_list = [ ] , replacement_field = match [ 2 ] , field_match = [ ] ;%NWL%if ( ( field_match = / ^ ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%while ( ( replacement_field = replacement_field . substring ( field_match [ 0 ] . length ) ) !== ' ' )  {%NWL%if ( ( field_match = / ^\ . ( [ a - z_ ] [ a - z_\d ] * ) / i . exec ( replacement_field ) ) !== null )  {%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%}%NWL%field_list . push ( field_match [ 1 ] ) ;%NWL%5
if ( value !== currentValue )  { this . input . set ( " value " ,  " "  + value ) ; }%NWL%}%NWL%} ;%NWL%var isAnyAdjustableNumberDragging = false;  / / hack for dragging one value over another one%NWL%Tangle . classes . TKAdjustableNumber = {%NWL%initialize: function ( element , options , tangle , variable )  {%NWL%this . element = element;%NWL%this . tangle = tangle;%NWL%this . variable = variable;%NWL%this . min = ( options . min !== undefined ) ? parseFloat ( options . min ) : 1;%NWL%this . step = ( options . step !== undefined ) ? parseFloat ( options . step ) : 1;%NWL%9
Tangle . classes . TKAdjustableNumber = {%NWL%initialize: function ( element , options , tangle , variable )  {%NWL%this . element = element;%NWL%this . tangle = tangle;%NWL%this . variable = variable;%NWL%this . min = ( options . min !== undefined ) ? parseFloat ( options . min ) : 1;%NWL%this . max = ( options . max !== undefined ) ? parseFloat ( options . max ) : 10;%NWL%this . step = ( options . step !== undefined ) ? parseFloat ( options . step ) : 1;%NWL%%NWL%this . initializeHover ( ) ;%NWL%this . initializeDrag ( ) ;%NWL%9
this . initializeHelp ( ) ;%NWL%this . initializeDrag ( ) ;%NWL%} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%this . updateStyle ( ) ;%NWL%0
this . initializeDrag ( ) ;%NWL%} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%updateRolloverEffects: function ( )  {%NWL%this . updateCursor ( ) ;%NWL%0
} ,%NWL%%NWL%initializeHover: function ( )  {%NWL%this . isHovering = false;%NWL%this . element . addEvent ( " mouseenter " ,  ( function ( )  { this . isHovering = true; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%this . element . addEvent ( " mouseleave " ,  ( function ( )  { this . isHovering = false; this . updateRolloverEffects ( ) ; } ) . bind ( this ) ) ;%NWL%} ,%NWL%%NWL%updateRolloverEffects: function ( )  {%NWL%this . updateStyle ( ) ;%NWL%this . updateHelp ( ) ;%NWL%9
this . valueAtMouseDown = this . tangle . getValue ( this . variable ) ;%NWL%this . isDragging = true;%NWL%isAnyAdjustableNumberDragging = true;%NWL%this . updateRolloverEffects ( ) ;%NWL%this . updateStyle ( ) ;%NWL%} ,%NWL%%NWL%touchDidMove: function ( touches )  {%NWL%var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . updateHelp ( ) ;%NWL%3
touchDidMove: function ( touches )  {%NWL%var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . tangle . setValue ( this . variable , value ) ;%NWL%this . updateHelp ( ) ;%NWL%} ,%NWL%%NWL%touchDidGoUp: function ( touches )  {%NWL%this . helpElement . setStyle ( " display " ,  " none " ) ;%NWL%this . isDragging = false;%NWL%this . updateRolloverEffects ( ) ;%NWL%4
var value = this . valueAtMouseDown + touches . translation . x / 5 * this . step;%NWL%value = ( ( value / this . step ) . round ( )  * this . step ) . limit ( this . min , this . max ) ;%NWL%this . tangle . setValue ( this . variable , value ) ;%NWL%this . updateHelp ( ) ;%NWL%} ,%NWL%%NWL%touchDidGoUp: function ( touches )  {%NWL%this . helpElement . setStyle ( " display " ,  " none " ) ;%NWL%this . isDragging = false;%NWL%isAnyAdjustableNumberDragging = false;%NWL%this . updateStyle ( ) ;%NWL%3
var gradient = defs . append ( " svg:radialGradient " )%NWL%. attr ( " id " , id )%NWL%. attr ( " cx " , c . x )%NWL%. attr ( " cy " , c . y )%NWL%. attr ( " fx " , f . x )%NWL%. attr ( " fy " , f . y )%NWL%. attr ( " r " , r )%NWL%gradient . append ( " svg:stop " )%NWL%. attr ( " offset " ,  " 0% " )%NWL%. attr ( " stop - color " , color )%NWL%gradient . append ( " svg:stop " )%NWL%7
var bounce_to = 5;%NWL%var dur = 500;%NWL%d . stash_size = d . size;%NWL%d . size = bounce_to;%NWL%node . transition ( )%NWL%. ease ( " sin " )%NWL%. duration ( dur )%NWL%. attrTween ( " r " , tweenR )%NWL%. each ( " end " , function ( d , i )  {%NWL%d . size = d . stash_size%NWL%node . transition ( )%NWL%4
p = { " x " : x ,  " y " : y } ;%NWL%function dist ( a , b )  {%NWL%var dx = ( a . x - b . x ) ;%NWL%var dy = ( a . y - b . y ) ;%NWL%return Math . sqrt ( dx * dx + dy * dy ) ;%NWL%}%NWL%var sd = strokes [ stroke_idx ] ;%NWL%if ( sd . length > 0 )  {%NWL%var pnm1 = sd [ sd . length - 1 ] ;%NWL%p . dist = dist ( p , pnm1 ) ;%NWL%p . deg = Math . acos ( dx / p . dist )  * 180 / Math . PI;%NWL%9
var svg = d3 . select ( " svg " )%NWL%. attr ( " width " , w )%NWL%var defs = svg . append ( " defs " )%NWL%0
var gradient = defs . append ( " radialGradient " )%NWL%. attr ( " id " , id )%NWL%. attr ( " cx " , c . x )%NWL%. attr ( " cy " , c . y )%NWL%. attr ( " fx " , f . x )%NWL%. attr ( " fy " , f . y )%NWL%. attr ( " r " , r )%NWL%gradient . append ( " svg:stop " )%NWL%. attr ( " offset " ,  " 0% " )%NWL%. attr ( " stop - color " , color )%NWL%gradient . append ( " svg:stop " )%NWL%7
. attr ( " stop - opacity " , 1e - 6 )%NWL%}%NWL%var wrid = " white_radial " ;%NWL%var gr = . 5;%NWL%var c = {  " x " : . 5 ,  " y " : . 5 } ;%NWL%make_radial ( wrid , c , c , gr ,  " #fff " ,  . 2 )%NWL%%NWL%svg . append ( " rect " )%NWL%. attr ( " width " ,  " 100% " )%NWL%. attr ( " height " ,  " 100% " )%NWL%svg . append ( " rect " )%NWL%7
var bounce_to = 5;%NWL%var dur = 500;%NWL%d . stash_size = d . size;%NWL%d . size = bounce_to;%NWL%node . transition ( )%NWL%. ease ( " sin " )%NWL%. duration ( dur )%NWL%. attrTween ( " r " , tweenR )%NWL%. each ( " end " , function ( d , i )  {%NWL%d . size = d . stash_size%NWL%node . transition ( )%NWL%4
var svg = d3 . select ( " svg " )%NWL%var pause = true;%NWL%jwerty . key ( ' p ' , function ( )  {%NWL%pause = !pause;%NWL%} ) ;%NWL%wait = 700;%NWL%radius = 100%NWL%var node = element . node ( )%NWL%0
var gradient = defs . append ( " svg:radialGradient " )%NWL%. attr ( " id " , id )%NWL%. attr ( " cx " , c . x )%NWL%. attr ( " cy " , c . y )%NWL%. attr ( " fx " , f . x )%NWL%. attr ( " fy " , f . y )%NWL%. attr ( " r " , r )%NWL%gradient . append ( " svg:stop " )%NWL%. attr ( " offset " ,  " 0% " )%NWL%. attr ( " stop - color " , color )%NWL%gradient . append ( " svg:stop " )%NWL%7
. attr ( " stop - opacity " , 1e - 6 )%NWL%}%NWL%var wrid = " white_radial " ;%NWL%var gr = . 5;%NWL%var c = {  " x " : . 5 ,  " y " : . 5 } ;%NWL%make_radial ( wrid , c , c , gr ,  " #fff " ,  . 2 )%NWL%%NWL%svg . append ( " svg:rect " )%NWL%. attr ( " width " ,  " 100% " )%NWL%. attr ( " height " ,  " 100% " )%NWL%svg . append ( " svg:rect " )%NWL%7
var gradient = defs . append ( " svg:radialGradient " )%NWL%. attr ( " id " , id )%NWL%. attr ( " cx " , c . x )%NWL%. attr ( " cy " , c . y )%NWL%. attr ( " fx " , f . x )%NWL%. attr ( " fy " , f . y )%NWL%. attr ( " r " , r )%NWL%gradient . append ( " svg:stop " )%NWL%. attr ( " offset " ,  " 0% " )%NWL%. attr ( " stop - color " , color )%NWL%gradient . append ( " svg:stop " )%NWL%7
var gradient = defs . append ( " svg:radialGradient " )%NWL%. attr ( " id " , id )%NWL%. attr ( " cx " , c . x )%NWL%. attr ( " cy " , c . y )%NWL%. attr ( " fx " , f . x )%NWL%. attr ( " fy " , f . y )%NWL%. attr ( " r " , r )%NWL%gradient . append ( " svg:stop " )%NWL%. attr ( " offset " ,  " 0% " )%NWL%. attr ( " stop - color " , color )%NWL%gradient . append ( " svg:stop " )%NWL%7
. attr ( " stop - opacity " , 1e - 6 )%NWL%}%NWL%var wrid = " white_radial " ;%NWL%var gr = . 5;%NWL%var c = {  " x " : . 5 ,  " y " : . 5 } ;%NWL%make_radial ( wrid , c , c , gr ,  " #fff " ,  . 2 )%NWL%%NWL%svg . append ( " svg:rect " )%NWL%. attr ( " width " ,  " 100% " )%NWL%. attr ( " height " ,  " 100% " )%NWL%svg . append ( " svg:rect " )%NWL%7
var bounce_to = 5;%NWL%var dur = 500;%NWL%d . stash_size = d . size;%NWL%d . size = bounce_to;%NWL%node . transition ( )%NWL%. ease ( " sin " )%NWL%. duration ( dur )%NWL%. attrTween ( " r " , tweenR )%NWL%. each ( " end " , function ( d , i )  {%NWL%d . size = d . stash_size%NWL%node . transition ( )%NWL%4
o . y * = sim_scale;%NWL%f = o . force;%NWL%f . y + = gravity;%NWL%var speed = Math . sqrt ( f . x * f . x + f . y * f . y ) ;%NWL%if ( speed > velocity_limit )%NWL%{%NWL%f . x * = velocity_limit / speed;%NWL%f . y * = velocity_limit / speed;%NWL%}%NWL%vnext . x = o . vel . x + f . x * dt;%NWL%vnext . x + = xsph_factor * o . xsph . x;%NWL%9
f = o . force;%NWL%f . y + = gravity;%NWL%var speed = Math . sqrt ( f . x * f . x + f . y * f . y ) ;%NWL%if ( speed > velocity_limit )%NWL%{%NWL%f . x * = velocity_limit / speed;%NWL%f . y * = velocity_limit / speed;%NWL%}%NWL%vnext . x = o . vel . x + f . x * dt;%NWL%vnext . y = o . vel . y + f . y * dt;%NWL%vnext . y + = xsph_factor * o . xsph . y;%NWL%8
vnext . y + = xsph_factor * o . xsph . y;%NWL%o . x + = vnext . x * dt;%NWL%o . y + = vnext . y * dt;%NWL%veval . x = 0 . 5 *  ( o . vel . x + vnext . x ) ;%NWL%veval . y = 0 . 5 *  ( o . vel . y + vnext . y ) ;%NWL%o . vel = vnext;%NWL%o . veleval = veval;%NWL%o . x / = sim_scale;%NWL%o . y / = sim_scale;%NWL%if ( o . fixed )%NWL%o . vel . x = 0;%NWL%1
o . x + = vnext . x * dt;%NWL%o . y + = vnext . y * dt;%NWL%veval . x = 0 . 5 *  ( o . vel . x + vnext . x ) ;%NWL%veval . y = 0 . 5 *  ( o . vel . y + vnext . y ) ;%NWL%o . vel = vnext;%NWL%o . veleval = veval;%NWL%o . x / = sim_scale;%NWL%o . y / = sim_scale;%NWL%if ( o . fixed )%NWL%{%NWL%o . vel . y = 0;%NWL%0
o . y + = vnext . y * dt;%NWL%veval . x = 0 . 5 *  ( o . vel . x + vnext . x ) ;%NWL%veval . y = 0 . 5 *  ( o . vel . y + vnext . y ) ;%NWL%o . vel = vnext;%NWL%o . veleval = veval;%NWL%o . x / = sim_scale;%NWL%o . y / = sim_scale;%NWL%if ( o . fixed )%NWL%{%NWL%o . vel . x = 0;%NWL%o . veleval . x = 0;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var PageConfig = requirejs ( ' page_config ' ) ;%NWL%var get_dashboard_and_render = require ( ' . / server / mixins / get_dashboard_and_render ' ) ;%NWL%0
. attr ( " stroke - opacity " , 1 . )%NWL%. attr ( " stroke - width " , 1 . 5 )%NWL%. on ( " mouseover " , state_mouseover )%NWL%. on ( " mouseout " , state_mouseout ) ;%NWL%function state_mouseover ( d , i )%NWL%{%NWL%d3 . select ( this )%NWL%. attr ( " fill " ,  " #ff0000 " ) ;%NWL%}%NWL%function state_mouseout ( d , i )%NWL%d3 . select ( this )%NWL%6
return new Date ( d ) ;%NWL%} ) ;%NWL%var cumu_joined = { } ;%NWL%var joined_hist = { } ;%NWL%var n = 0;%NWL%var rd;%NWL%joined . forEach ( function ( d , i )  {%NWL%n + =1;%NWL%rd = new Date ( d ) ;%NWL%rd . setHours ( 0 ) ;%NWL%rd . setSeconds ( 0 ) ;%NWL%9
} )%NWL%. attr ( " width " , aw )%NWL%. attr ( " height " , aw )%NWL%. on ( " mouseover " , function ( d , i )  {%NWL%avatars . selectAll ( " g . avitxt " )%NWL%. filter ( function ( c )  {%NWL%return c . name === d . name;%NWL%} )%NWL%. style ( " display " ,  " " )%NWL%} )%NWL%avatars . selectAll ( " g . avitxt " )%NWL%4
} ;%NWL%fisheye . nice = scale . nice;%NWL%fisheye . ticks = scale . ticks;%NWL%fisheye . tickFormat = scale . tickFormat;%NWL%return d3 . rebind ( fisheye , scale ,  " domain " ,  " range " ) ;%NWL%}%NWL%%NWL%var fisheye = d3 . fisheye . circular ( )%NWL%. radius ( 120 )%NWL%. distortion ( 2 ) ;%NWL%var mouse = d3 . mouse ( this ) ;%NWL%7
. distortion ( 2 ) ;%NWL%svg . on ( " mousemove " , function ( )  {%NWL%var mouse = d3 . mouse ( this ) ;%NWL%mouse [ 0 ]  - = xoffset;%NWL%mouse [ 1 ]  - = yoffset;%NWL%fisheye . focus ( mouse ) ;%NWL%svg . select ( " g . avatars " ) . selectAll ( " image " )%NWL%. attr ( " transform " , function ( d , i )  {%NWL%var x = i % nx *  ( aw + as ) ;%NWL%var y = parseInt ( i / nx )  *  ( aw + as ) ;%NWL%var translate =  " translate ( "  +  [ fe . x , fe . y ]  +  " ) " ;%NWL%2
svg . on ( " mousemove " , function ( )  {%NWL%var mouse = d3 . mouse ( this ) ;%NWL%mouse [ 0 ]  - = xoffset;%NWL%mouse [ 1 ]  - = yoffset;%NWL%fisheye . focus ( mouse ) ;%NWL%svg . select ( " g . avatars " ) . selectAll ( " image " )%NWL%. attr ( " transform " , function ( d , i )  {%NWL%var x = i % nx *  ( aw + as ) ;%NWL%var y = parseInt ( i / nx )  *  ( aw + as ) ;%NWL%var fe = fisheye ( { x: x , y: y } ) ;%NWL%var scale = " scale ( "  + fe . z + " ) " ;%NWL%1
return new Date ( d ) ;%NWL%} ) ;%NWL%var cumu_joined = { } ;%NWL%var joined_hist = { } ;%NWL%var n = 0;%NWL%var rd;%NWL%joined . forEach ( function ( d , i )  {%NWL%n + =1;%NWL%rd = new Date ( d ) ;%NWL%rd . setHours ( 0 ) ;%NWL%rd . setSeconds ( 0 ) ;%NWL%9
return " translate ( "  +  [ x , 0 ]  +  " ) " ;%NWL%} )%NWL%hist . append ( " text " )%NWL%. text ( " per day " )%NWL%. style ( " text - anchor " ,  " end " )%NWL%. style ( " alignment - baseline " ,  " middle " )%NWL%. attr ( " y " , histscale . range ( ) [ 1 ] / 2 )%NWL%. attr ( " x " ,  - 15 )%NWL%. style ( " font - size " , " 16 " )%NWL%. style ( " fill " , " #606164 " )%NWL%hist . append ( " text " )%NWL%2
. style ( " fill " , " #606164 " )%NWL%%NWL%hist . append ( " text " )%NWL%. text ( 0 )%NWL%. style ( " text - anchor " ,  " end " )%NWL%. style ( " alignment - baseline " ,  " middle " )%NWL%. attr ( " y " , histscale . range ( ) [ 1 ] )%NWL%. attr ( " x " ,  - 15 )%NWL%. style ( " font - size " , " 16 " )%NWL%. style ( " fill " , " #606164 " )%NWL%hist . append ( " text " )%NWL%2
. attr ( " text - anchor " ,  " middle " )%NWL%. style ( " fill " , " #1C85BA " )%NWL%. style ( " font - size " , " 17 " )%NWL%%NWL%%NWL%%NWL%evts . on ( " mouseover " , function ( )  {%NWL%d3 . select ( this ) . selectAll ( " text . label " )%NWL%. style ( " display " ,  " " )%NWL%} )%NWL%d3 . select ( this ) . selectAll ( " text . label " )%NWL%7
var requirejs = require ( ' requirejs ' ) ;%NWL%requirejs . config ( { baseUrl: __dirname +  ' / ' } ) ;%NWL%var appConfig = requirejs ( ' . / config ' ) ;%NWL%appConfig . nodeRequire = require;%NWL%requirejs . config ( appConfig ) ;%NWL%var argv = require ( ' optimist ' ) . argv;%NWL%var backbone = require ( ' backbone ' ) ,%NWL%0
var environment = process . env . NODE_ENV || argv . env || ' development ' ;%NWL%var backbone = require ( ' backbone ' ) ,%NWL%XMLHttpRequest = require ( ' xmlhttprequest ' ) . XMLHttpRequest;%NWL%global . $ = backbone . $ = global . jQuery = require ( ' jquery ' ) ;%NWL%$ . support . cors = true;%NWL%$ . ajaxSettings . xhr = function ( )  {%NWL%return new XMLHttpRequest ( ) ;%NWL%} ;%NWL%global . isServer = true;%NWL%global . isClient = false;%NWL%global . config = require ( ' . / environment_config ' ) . configure ( environment , argv ) ;%NWL%3
var backbone = require ( ' backbone ' ) ,%NWL%XMLHttpRequest = require ( ' xmlhttprequest ' ) . XMLHttpRequest;%NWL%global . $ = backbone . $ = global . jQuery = require ( ' jquery ' ) ;%NWL%$ . support . cors = true;%NWL%$ . ajaxSettings . xhr = function ( )  {%NWL%return new XMLHttpRequest ( ) ;%NWL%} ;%NWL%global . isServer = true;%NWL%global . isClient = false;%NWL%global . _ = require ( ' lodash ' ) ;%NWL%global . logger = require ( ' . / logger ' ) ;%NWL%2
}%NWL%var http = require ( ' http ' ) ,%NWL%https = require ( ' https ' ) ,%NWL%path = require ( ' path ' ) ,%NWL%spdy = require ( ' spdy ' ) ;%NWL%https . globalAgent = spdy . createAgent ( {%NWL%host: ' www . google . com ' ,%NWL%port: 443%NWL%} ) ;%NWL%var rootDir = path . join ( __dirname ,  ' . . ' ) ;%NWL%var port = process . env . SPOTLIGHT_PORT || process . env . PORT || app . get ( ' port ' ) ;%NWL%1
var express = require ( ' express ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var exphbs = require ( ' express - handlebars ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var bodyParser = require ( ' body - parser ' ) ;%NWL%var redis = require ( ' redis ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var exphbs = require ( ' express - handlebars ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var bodyParser = require ( ' body - parser ' ) ;%NWL%var cookieParser = require ( ' cookie - parser ' ) ;%NWL%var mongodb = require ( ' mongodb ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var exphbs = require ( ' express - handlebars ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var bodyParser = require ( ' body - parser ' ) ;%NWL%var cookieParser = require ( ' cookie - parser ' ) ;%NWL%var redis = require ( ' redis ' ) ;%NWL%var session = require ( ' express - session ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var exphbs = require ( ' express - handlebars ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var bodyParser = require ( ' body - parser ' ) ;%NWL%var cookieParser = require ( ' cookie - parser ' ) ;%NWL%var redis = require ( ' redis ' ) ;%NWL%var mongodb = require ( ' mongodb ' ) ;%NWL%var session = require ( ' express - session ' ) ;%NWL%var nconf = require ( ' nconf ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var exphbs = require ( ' express - handlebars ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var bodyParser = require ( ' body - parser ' ) ;%NWL%var cookieParser = require ( ' cookie - parser ' ) ;%NWL%var redis = require ( ' redis ' ) ;%NWL%var mongodb = require ( ' mongodb ' ) ;%NWL%var session = require ( ' express - session ' ) ;%NWL%var RedisStore = require ( ' connect - redis ' ) ( session ) ;%NWL%var compression = require ( ' compression ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var exphbs = require ( ' express - handlebars ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var bodyParser = require ( ' body - parser ' ) ;%NWL%var cookieParser = require ( ' cookie - parser ' ) ;%NWL%var redis = require ( ' redis ' ) ;%NWL%var mongodb = require ( ' mongodb ' ) ;%NWL%var session = require ( ' express - session ' ) ;%NWL%var RedisStore = require ( ' connect - redis ' ) ( session ) ;%NWL%var nconf = require ( ' nconf ' ) ;%NWL%var passport = require ( ' passport ' ) ;%NWL%0
var exphbs = require ( ' express - handlebars ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var bodyParser = require ( ' body - parser ' ) ;%NWL%var cookieParser = require ( ' cookie - parser ' ) ;%NWL%var redis = require ( ' redis ' ) ;%NWL%var mongodb = require ( ' mongodb ' ) ;%NWL%var session = require ( ' express - session ' ) ;%NWL%var RedisStore = require ( ' connect - redis ' ) ( session ) ;%NWL%var nconf = require ( ' nconf ' ) ;%NWL%var compression = require ( ' compression ' ) ;%NWL%var thumbnail = require ( ' . / thumbnail ' ) ;%NWL%1
} ) ;%NWL%var searchConf = nconf . get ( ' search ' ) ;%NWL%if ( searchConf )  {%NWL%var bbSearch = require ( ' blockbuilder - search ' ) ( searchConf , app , nconf . get ( " analytics:ga " ) ) ;%NWL%app . get ( ' / search ' , bbSearch . page ) ;%NWL%app . get ( ' / api / search ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . api ( req , res , next ) ;%NWL%} ) ;%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%6
var searchConf = nconf . get ( ' search ' ) ;%NWL%if ( searchConf )  {%NWL%var bbSearch = require ( ' blockbuilder - search ' ) ( searchConf , app , nconf . get ( " analytics:ga " ) ) ;%NWL%app . get ( ' / search ' , bbSearch . page ) ;%NWL%app . get ( ' / api / search ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . api ( req , res , next ) ;%NWL%} ) ;%NWL%app . get ( ' / api / aggregateD3api ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%6
if ( searchConf )  {%NWL%var bbSearch = require ( ' blockbuilder - search ' ) ( searchConf , app , nconf . get ( " analytics:ga " ) ) ;%NWL%app . get ( ' / search ' , bbSearch . page ) ;%NWL%app . get ( ' / api / search ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . api ( req , res , next ) ;%NWL%} ) ;%NWL%app . get ( ' / api / aggregateD3api ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%bbSearch . aggregateD3API ( req , res , next ) ;%NWL%6
app . get ( ' / api / search ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . api ( req , res , next ) ;%NWL%} ) ;%NWL%app . get ( ' / api / aggregateD3api ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . aggregateD3API ( req , res , next ) ;%NWL%} ) ;%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%1
res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . api ( req , res , next ) ;%NWL%} ) ;%NWL%app . get ( ' / api / aggregateD3api ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . aggregateD3API ( req , res , next ) ;%NWL%} ) ;%NWL%app . get ( ' / api / aggregateD3modules ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%1
res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . api ( req , res , next ) ;%NWL%} ) ;%NWL%app . get ( ' / api / aggregateD3api ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%res . header ( " Access - Control - Allow - Headers " ,  " Origin , X - Requested - With , Content - Type , Accept " ) ;%NWL%bbSearch . aggregateD3API ( req , res , next ) ;%NWL%} ) ;%NWL%app . get ( ' / api / aggregateD3modules ' , function ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%bbSearch . aggregateD3Modules ( req , res , next ) ;%NWL%1
res . status ( 200 ) . send ( response ) ;%NWL%indexGist ( response ) ;%NWL%} ) ;%NWL%} ) ;%NWL%app . post ( ' / api / fork ' , function ( req , res )  {%NWL%var gist = req . body . gist;%NWL%var token;%NWL%if ( req . session . passport && req . session . passport . user ) token = req . session . passport . user . accessToken;%NWL%saveGist ( gist ,  " POST " , token , function ( err , response )  {%NWL%if ( err )  { console . log ( err ) ; return res . status ( 400 ) . send ( { error: err } ) ; }%NWL%res . status ( 200 ) . send ( response ) ;%NWL%0
var exports = module . exports = { } ;%NWL%var fs = require ( ' fs ' ) ;%NWL%0
if ( !newGist . files [ fileName ] )  {%NWL%delete newGist . files [ fileName ] ;%NWL%}%NWL%} ) ;%NWL%return newGist;%NWL%}%NWL%Actions . fetchGist . listen ( function ( gistId )  {%NWL%logger . log ( ' actions:fetchGist ' ,  ' called : '  + gistId ) ;%NWL%WebAPIUtils . fetchGist ( gistId ) . then ( this . completed ) . catch ( this . failed ) ;%NWL%} ) ;%NWL%logger . log ( ' actions:fetchGist ' ,  ' called : '  + gistId ) ;%NWL%7
} ) ;%NWL%Actions . fetchTruncatedFile . listen ( function ( rawUrl , gistId , fileName )  {%NWL%logger . log ( ' actions:fetchGist ' ,  ' called : '  + gistId ) ;%NWL%WebAPIUtils . fetchRawFile ( rawUrl , gistId , fileName ) . then ( this . completed ) . catch ( this . failed ) ;%NWL%} ) ;%NWL%Actions . forkGist . listen ( function ( gist )  {%NWL%logger . log ( ' actions:forkGist ' ,  ' called : %O ' , gist ) ;%NWL%WebAPIUtils . forkGist ( gist ) . then ( this . completed ) . catch ( this . failed ) ;%NWL%} ) ;%NWL%Actions . saveGist . listen ( function ( gist )  {%NWL%WebAPIUtils . saveGist ( gist ) . then ( this . completed ) . catch ( this . failed ) ;%NWL%7
defaults: {%NWL%status: 200%NWL%} ,%NWL%initialize: function ( attrs , options )  {%NWL%this . controllers = options . ControllerMap;%NWL%this . requestId = options . requestId || ' Not - Set ' ;%NWL%this . govukRequestId = options . govukRequestId || ' Not - Set ' ;%NWL%this . set ( ' params ' , attrs . params ) ;%NWL%Model . prototype . initialize . apply ( this , arguments ) ;%NWL%} ,%NWL%this . path = path . split ( ' ? ' ) [ 0 ] ;%NWL%5
return true;%NWL%} ,%NWL%componentDidMount: function componentDidMount ( )  {%NWL%logger . log ( ' components / EditorHTML:component:componentDidMount ' ,  ' called ' ) ;%NWL%if ( this . props . gist )  {%NWL%this . setupResize ( ) ;%NWL%}%NWL%} ,%NWL%componentDidUpdate: function componentDidUpdate ( oldProps )  {%NWL%logger . log ( ' components / EditorHTML:component:componentDidUpdate ' ,  ' called ' ) ;%NWL%this . setupResize ( ) ;%NWL%5
}%NWL%var right = " calc ( 100% -  "  +  ( nx + 6 )  +  " px ) " ;%NWL%d3 . select ( " #block__code - handle " ) . style ( { left: null , right: right , width: " 12px "  } ) ;%NWL%}%NWL%}%NWL%} ,%NWL%setupResize: function setupResize ( )  {%NWL%var that = this;%NWL%var handle = d3 . select ( " #block__code - handle " ) ;%NWL%var resizing = false;%NWL%var body = d3 . select ( " body " ) ;%NWL%8
import throttle from ' . . / utils / throttle ' ;%NWL%var EditorCoffee = React . createClass ( {%NWL%componentDidMount: function componentDidMount ( )  {%NWL%logger . log ( ' components / EditorCoffee:component:componentDidMount ' ,  ' called ' ) ;%NWL%if ( this . props . gist )  {%NWL%this . setupCodeMirror ( ) ;%NWL%}%NWL%} ,%NWL%componentDidUpdate: function componentDidUpdate ( )  {%NWL%logger . log ( ' components / EditorCoffee:component:componentDidUpdate ' ,  ' called ' ) ;%NWL%this . setupCodeMirror ( ) ;%NWL%5
import throttle from ' . . / utils / throttle ' ;%NWL%var EditorCSS = React . createClass ( {%NWL%componentDidMount: function componentDidMount ( )  {%NWL%logger . log ( ' components / EditorCSS:component:componentDidMount ' ,  ' called ' ) ;%NWL%if ( this . props . gist )  {%NWL%this . setupCodeMirror ( ) ;%NWL%}%NWL%} ,%NWL%componentDidUpdate: function componentDidUpdate ( )  {%NWL%logger . log ( ' components / EditorCSS:component:componentDidUpdate ' ,  ' called ' ) ;%NWL%this . setupCodeMirror ( ) ;%NWL%5
import Actions from ' . . / actions / actions . js ' ;%NWL%var EditorHTML = React . createClass ( {%NWL%componentDidMount: function componentDidMount ( )  {%NWL%logger . log ( ' components / EditorHTML:component:componentDidMount ' ,  ' called ' ) ;%NWL%if ( this . props . gist )  {%NWL%this . setupCodeMirror ( ) ;%NWL%}%NWL%} ,%NWL%componentDidUpdate: function componentDidUpdate ( )  {%NWL%logger . log ( ' components / EditorHTML:component:componentDidUpdate ' ,  ' called ' ) ;%NWL%this . setupCodeMirror ( ) ;%NWL%5
import throttle from ' . . / utils / throttle ' ;%NWL%var EditorJS = React . createClass ( {%NWL%componentDidMount: function componentDidMount ( )  {%NWL%logger . log ( ' components / EditorJS:component:componentDidMount ' ,  ' called ' ) ;%NWL%if ( this . props . gist )  {%NWL%this . setupCodeMirror ( ) ;%NWL%}%NWL%} ,%NWL%componentDidUpdate: function componentDidUpdate ( )  {%NWL%logger . log ( ' components / EditorJS:component:componentDidUpdate ' ,  ' called ' ) ;%NWL%this . setupCodeMirror ( ) ;%NWL%5
import Actions from ' . . / actions / actions . js ' ;%NWL%var EditorMD = React . createClass ( {%NWL%componentDidMount: function componentDidMount ( )  {%NWL%logger . log ( ' components / EditorMD:component:componentDidMount ' ,  ' called ' ) ;%NWL%if ( this . props . gist )  {%NWL%this . setupCodeMirror ( ) ;%NWL%}%NWL%} ,%NWL%componentDidUpdate: function componentDidUpdate ( )  {%NWL%logger . log ( ' components / EditorMD:component:componentDidUpdate ' ,  ' called ' ) ;%NWL%this . setupCodeMirror ( ) ;%NWL%5
gist . files [ ' . block ' ] . content = yaml;%NWL%Actions . localGistUpdate ( gist ) ;%NWL%} ,%NWL%handleLicenseChange: function ( value )  {%NWL%var config = this . getConfig ( ) ;%NWL%config . license = value;%NWL%this . saveConfig ( config ) ;%NWL%} ,%NWL%handleBorderChange: function ( value )  {%NWL%var config = this . getConfig ( ) ;%NWL%this . saveConfig ( config ) ;%NWL%6
config . license = value;%NWL%this . saveConfig ( config ) ;%NWL%} ,%NWL%handleBorderChange: function ( value )  {%NWL%var config = this . getConfig ( ) ;%NWL%config . border = value;%NWL%this . saveConfig ( config ) ;%NWL%} ,%NWL%handleScrollableChange: function ( value )  {%NWL%var config = this . getConfig ( ) ;%NWL%this . saveConfig ( config ) ;%NWL%1
config . border = value;%NWL%this . saveConfig ( config ) ;%NWL%} ,%NWL%handleScrollableChange: function ( value )  {%NWL%var config = this . getConfig ( ) ;%NWL%config . scrolling = value;%NWL%this . saveConfig ( config ) ;%NWL%} ,%NWL%handleHeightChange: function ( evt )  {%NWL%var config = this . getConfig ( ) ;%NWL%this . saveConfig ( config ) ;%NWL%1
import Actions from ' . . / actions / actions . js ' ;%NWL%var EditorTXT = React . createClass ( {%NWL%componentDidMount: function componentDidMount ( )  {%NWL%logger . log ( ' components / EditorTXT:component:componentDidMount ' ,  ' called ' ) ;%NWL%if ( this . props . gist )  {%NWL%this . setupCodeMirror ( ) ;%NWL%}%NWL%} ,%NWL%componentDidUpdate: function componentDidUpdate ( )  {%NWL%logger . log ( ' components / EditorTXT:component:componentDidUpdate ' ,  ' called ' ) ;%NWL%this . setupCodeMirror ( ) ;%NWL%5
import React from ' react ' ;%NWL%import Actions from ' . . / actions / actions . js ' ;%NWL%import { IconLoader , IconPublic , IconPrivate } from ' . / icons . js ' ;%NWL%var SaveForkNav = React . createClass ( {%NWL%save: function save ( )  {%NWL%Actions . setSaveFork ( " saving " ) ;%NWL%Actions . saveGist ( this . props . gist ) ;%NWL%} ,%NWL%fork: function fork ( )  {%NWL%window . onbeforeunload = null;%NWL%Actions . forkGist ( this . props . gist ) ;%NWL%6
Actions . pauseAutoRun ( !that . props . paused ) ;%NWL%} ) ;%NWL%function save ( )  {%NWL%var user = that . props . user;%NWL%var gist = that . props . gist;%NWL%if ( user && gist && gist . owner && user . id === gist . owner . id )  {%NWL%Actions . setSaveFork ( " saving " ) ;%NWL%Actions . saveGist ( that . props . gist ) ;%NWL%} else {%NWL%window . onbeforeunload = null;%NWL%Actions . forkGist ( that . props . gist ) ;%NWL%7
handleMouseOut: function handleMouseOut ( evt )  {%NWL%if ( d3 . event . relatedTarget && d3 . event . relatedTarget === d3 . select ( " #block__iframe " ) . node ( ) ) return; / / FireFox%NWL%if ( d3 . event . toElement && d3 . event . toElement === d3 . select ( " #block__iframe " ) . node ( ) ) return;%NWL%if ( this . stayPopped ) return;%NWL%d3 . select ( " div . renderer " ) . classed ( " popped " , false ) ;%NWL%} ,%NWL%handleMouseClick: function handleMouseClick ( )  {%NWL%this . stayPopped = !this . stayPopped;%NWL%if ( this . stayPopped )  {%NWL%d3 . select ( " div . renderer " ) . classed ( " popped " , true ) ;%NWL%d3 . select ( " div . renderer " ) . classed ( " popped " , false ) ;%NWL%4
d3 . chart . scatter = function ( )  {%NWL%var data;%NWL%var g;%NWL%var width = 500;%NWL%var height = 300;%NWL%var cx = 10;%NWL%function chart ( group )  {%NWL%g = group;%NWL%group . append ( " g " )%NWL%. classed ( " axis " , true )%NWL%group . append ( " g " )%NWL%8
%NWL%var circles = g . selectAll ( " circle " )%NWL%. data ( data , function ( d )  { return d . data . id } ) ;%NWL%circles . enter ( )%NWL%. append ( " circle " )%NWL%. attr ( {%NWL%cx: 0 ,%NWL%cy: height ,%NWL%fill: function ( d )  { return colorScale ( d . data . created )  } ,%NWL%title: function ( d )  { return d . data . title +  " score: "  + d . data . score }%NWL%circles . transition ( )%NWL%3
if ( !d3 . chart ) d3 . chart = { } ;%NWL%d3 . chart . table = function ( )  {%NWL%var data;%NWL%var div;%NWL%function chart ( container )  {%NWL%div = container;%NWL%var table = div . append ( " table " )%NWL%update ( ) ;%NWL%}%NWL%var table = div . select ( " table " )%NWL%6
var data;%NWL%var div;%NWL%function chart ( container )  {%NWL%div = container;%NWL%var table = div . append ( " table " )%NWL%update ( ) ;%NWL%}%NWL%function update ( )  {%NWL%var table = div . select ( " table " )%NWL%var trs = table . selectAll ( " tr . data " )%NWL%var enter = trs . enter ( )%NWL%4
}%NWL%function update ( )  {%NWL%var table = div . select ( " table " )%NWL%var trs = table . selectAll ( " tr . data " )%NWL%. data ( data , function ( d )  { return d . data . id } )%NWL%var enter = trs . enter ( )%NWL%. append ( " tr " )%NWL%. classed ( " data " , true )%NWL%trs . exit ( ) . remove ( ) ;%NWL%enter . append ( " td " )%NWL%enter . append ( " td " )%NWL%9
var trs = table . selectAll ( " tr . data " )%NWL%. data ( data , function ( d )  { return d . data . id } )%NWL%var enter = trs . enter ( )%NWL%. append ( " tr " )%NWL%. classed ( " data " , true )%NWL%trs . exit ( ) . remove ( ) ;%NWL%enter . append ( " td " )%NWL%. text ( function ( d )  { return d . data . score } )%NWL%enter . append ( " td " )%NWL%. append ( " img " )%NWL%enter . append ( " td " )%NWL%6
. classed ( " data " , true )%NWL%trs . exit ( ) . remove ( ) ;%NWL%enter . append ( " td " )%NWL%. text ( function ( d )  { return d . data . score } )%NWL%enter . append ( " td " )%NWL%. append ( " img " )%NWL%. attr ( " src " , function ( d )  { return d . data . thumbnail } )%NWL%enter . append ( " td " )%NWL%. append ( " a " )%NWL%. attr ( " href " , function ( d )  { return d . data . url } )%NWL%enter . append ( " td " )%NWL%2
enter . append ( " td " )%NWL%. text ( function ( d )  { return d . data . score } )%NWL%enter . append ( " td " )%NWL%. append ( " img " )%NWL%. attr ( " src " , function ( d )  { return d . data . thumbnail } )%NWL%enter . append ( " td " )%NWL%. append ( " a " )%NWL%. attr ( " href " , function ( d )  { return d . data . url } )%NWL%. text ( function ( d )  { return d . data . title } )%NWL%enter . append ( " td " )%NWL%enter . append ( " td " )%NWL%0
tp = { top: pos . top + pos . height / 2 - actualHeight / 2 , left: pos . left - actualWidth - this . options . offset } ;%NWL%break;%NWL%case ' w ' :%NWL%tp = { top: pos . top + pos . height / 2 - actualHeight / 2 , left: pos . left + pos . width + this . options . offset } ;%NWL%break;%NWL%}%NWL%%NWL%if ( gravity . length == 2 )  {%NWL%if ( gravity . charAt ( 1 ) == ' w ' )  {%NWL%tp . left = pos . left + pos . width / 2 - 15;%NWL%tp . left = pos . left + pos . width / 2 - actualWidth + 15;%NWL%9
if ( options === true )  {%NWL%return this . data ( ' tipsy ' ) ;%NWL%} else if ( typeof options == ' string ' )  {%NWL%var tipsy = this . data ( ' tipsy ' ) ;%NWL%if ( tipsy ) tipsy [ options ] ( ) ;%NWL%return this;%NWL%}%NWL%%NWL%options = $ . extend ( { } , $ . fn . tipsy . defaults , options ) ;%NWL%%NWL%var tipsy = $ . data ( ele ,  ' tipsy ' ) ;%NWL%3
$ . data ( ele ,  ' tipsy ' , tipsy ) ;%NWL%}%NWL%return tipsy;%NWL%}%NWL%%NWL%function enter ( )  {%NWL%var tipsy = get ( this ) ;%NWL%tipsy . hoverState = ' in ' ;%NWL%if ( options . delayIn == 0 )  {%NWL%tipsy . show ( ) ;%NWL%tipsy . fixTitle ( ) ;%NWL%9
tipsy . show ( ) ;%NWL%} else {%NWL%tipsy . fixTitle ( ) ;%NWL%setTimeout ( function ( )  { if ( tipsy . hoverState == ' in ' ) tipsy . show ( ) ; } , options . delayIn ) ;%NWL%}%NWL%} ;%NWL%%NWL%function leave ( )  {%NWL%var tipsy = get ( this ) ;%NWL%tipsy . hoverState = ' out ' ;%NWL%tipsy . hide ( ) ;%NWL%0
}%NWL%var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%8
var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%} ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%8
this . removeEventListener ( ' mouseup ' , onDragEnd , true ) ;%NWL%}%NWL%function onKeyDown ( e )  {%NWL%if ( e . keyCode > 36 && e . keyCode < 41 )  {  / / 37 - 40: left , up , right , down%NWL%onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%6
onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%if ( !isClick )%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%' inset 0 0 20px rgba ( 0 , 127 , 255 , . 1 ) , 0 0 1px rgba ( 0 , 127 , 255 , . 4 ) ' ;%NWL%}%NWL%this . style . boxShadow = ' ' ;%NWL%2
var scriptingMode , htmlMixedMode;%NWL%function htmlDispatch ( stream , state )  {%NWL%if ( stream . match ( scriptStartRegex , false ) )  {%NWL%state . token=scriptingDispatch;%NWL%return scriptingMode . token ( stream , state . scriptState ) ;%NWL%}%NWL%else%NWL%return htmlMixedMode . token ( stream , state . htmlState ) ;%NWL%}%NWL%function scriptingDispatch ( stream , state )  {%NWL%state . token=htmlDispatch;%NWL%3
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
} else {%NWL%if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%7
if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%6
var state = cx . state , indent = state . indented;%NWL%if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
if ( stream . match ( " CDATA [ " ) ) return chain ( inBlock ( " atom " ,  " ] ] > " ) ) ;%NWL%else return null;%NWL%} else if ( stream . match ( " - - " ) )  {%NWL%return chain ( inBlock ( " comment " ,  " - - > " ) ) ;%NWL%} else if ( stream . match ( " DOCTYPE " , true , true ) )  {%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%return chain ( doctype ( 1 ) ) ;%NWL%} else {%NWL%return null;%NWL%}%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%5
ret . models . each ( function ( m )  {%NWL%type = m . get ( " type " ) ;%NWL%context = tb . make_context ( {%NWL%config: config ,%NWL%model: m ,%NWL%display: d3 . select ( options . display )%NWL%} ) ;%NWL%if ( context )  {%NWL%config . contexts . push ( context ) ;%NWL%context . render ( ) ;%NWL%context . execute ( ) ;%NWL%9
function moveToWord ( cm , regexps , dir , where )  {%NWL%var cur = cm . getCursor ( ) , ch = cur . ch , line = cm . getLine ( cur . line ) , word;%NWL%while ( true )  {%NWL%word = findWord ( line , ch , dir , regexps ) ;%NWL%ch = word [ where == " end " ? " to " : " from " ] ;%NWL%if ( ch == cur . ch && word . from != word . to ) ch = word [ dir < 0 ? " from " : " to " ] ;%NWL%else break;%NWL%}%NWL%cm . setCursor ( cur . line , word [ where == " end " ? " to " : " from " ] , true ) ;%NWL%}%NWL%var cur = cm . getCursor ( ) , ch = cur . ch , line = cm . getLine ( cur . line ) ;%NWL%1
word = findWord ( line , ch , dir , regexps ) ;%NWL%ch = word [ where == " end " ? " to " : " from " ] ;%NWL%if ( ch == cur . ch && word . from != word . to ) ch = word [ dir < 0 ? " from " : " to " ] ;%NWL%else break;%NWL%}%NWL%cm . setCursor ( cur . line , word [ where == " end " ? " to " : " from " ] , true ) ;%NWL%}%NWL%function joinLineNext ( cm )  {%NWL%var cur = cm . getCursor ( ) , ch = cur . ch , line = cm . getLine ( cur . line ) ;%NWL%CodeMirror . commands . goLineEnd ( cm ) ;%NWL%CodeMirror . commands . goLineEnd ( cm ) ;%NWL%9
}%NWL%}%NWL%function delTillMark ( cm , cHar )  {%NWL%var i = mark [ cHar ] ;%NWL%if ( i === undefined )  {%NWL%return;%NWL%}%NWL%var l = cm . getCursor ( ) . line , start = i > l ? l : i , end = i > l ? i : l;%NWL%cm . setCursor ( start ) ;%NWL%for ( var c = start; c <= end; c + + )  {%NWL%cm . removeLine ( start ) ;%NWL%8
var i = mark [ cHar ] ;%NWL%if ( i === undefined )  {%NWL%return;%NWL%}%NWL%var l = cm . getCursor ( ) . line , start = i > l ? l : i , end = i > l ? i : l;%NWL%for ( var c = start; c <= end; c + + )  {%NWL%pushInBuffer ( " \n " + cm . getLine ( c ) ) ;%NWL%}%NWL%cm . setCursor ( start ) ;%NWL%}%NWL%var cur = cm . getCursor ( ) , firstNonWS = cm . getLine ( cur . line ) . search ( / \S / ) ;%NWL%4
var l = cm . getCursor ( ) . line , start = i > l ? l : i , end = i > l ? i : l;%NWL%for ( var c = start; c <= end; c + + )  {%NWL%pushInBuffer ( " \n " + cm . getLine ( c ) ) ;%NWL%}%NWL%cm . setCursor ( start ) ;%NWL%}%NWL%function goLineStartText ( cm )  {%NWL%var cur = cm . getCursor ( ) , firstNonWS = cm . getLine ( cur . line ) . search ( / \S / ) ;%NWL%cm . setCursor ( cur . line , firstNonWS == - 1 ? line . length : firstNonWS , true ) ;%NWL%}%NWL%var cur = cm . getCursor ( ) , line = cm . getLine ( cur . line ) , idx;%NWL%0
CodeMirror . commands . goLineEnd ( cm ) ;%NWL%cm . replaceSelection ( buf ,  " end " ) ;%NWL%}%NWL%cm . setCursor ( cur + 1 ) ;%NWL%} ,%NWL%" Shift - X " : function ( cm )  { CodeMirror . commands . delCharLeft ( cm ) ; } ,%NWL%" Shift - J " : function ( cm )  { joinLineNext ( cm ) ; } ,%NWL%" Shift - P " : function ( cm )  {%NWL%var cur = cm . getCursor ( ) . line;%NWL%if ( buf!= " " )  {%NWL%CodeMirror . commands . goLineEnd ( cm ) ;%NWL%0
cm . replaceSelection ( buf ,  " end " ) ;%NWL%}%NWL%cm . setCursor ( cur + 1 ) ;%NWL%} ,%NWL%" Shift - X " : function ( cm )  { CodeMirror . commands . delCharLeft ( cm ) ; } ,%NWL%" Shift - J " : function ( cm )  { joinLineNext ( cm ) ; } ,%NWL%" Shift - P " : function ( cm )  {%NWL%var cur = cm . getCursor ( ) . line;%NWL%if ( buf!= " " )  {%NWL%CodeMirror . commands . goLineUp ( cm ) ;%NWL%cm . replaceSelection ( buf ,  " end " ) ;%NWL%0
cm . setCursor ( cur + 1 ) ;%NWL%} ,%NWL%" Shift - X " : function ( cm )  { CodeMirror . commands . delCharLeft ( cm ) ; } ,%NWL%" Shift - J " : function ( cm )  { joinLineNext ( cm ) ; } ,%NWL%" Shift - P " : function ( cm )  {%NWL%var cur = cm . getCursor ( ) . line;%NWL%if ( buf!= " " )  {%NWL%CodeMirror . commands . goLineUp ( cm ) ;%NWL%CodeMirror . commands . goLineEnd ( cm ) ;%NWL%cm . replaceSelection ( buf ,  " end " ) ;%NWL%cm . setCursor ( cur + 1 ) ;%NWL%0
while ( curPos <= lastCharPos )  {%NWL%var m = text . substr ( curPos ) . match ( modeMatchers [ i ] . regex ) ;%NWL%if ( m != null )  {%NWL%if ( m . length > 1 && m [ 1 ] . length > 0 )  {%NWL%var blockBegin = curPos + m . index + m [ 0 ] . indexOf ( m [ 1 ] ) ;%NWL%modeInfos . push (%NWL%{%NWL%pos: blockBegin ,%NWL%modeExt: modeMatchers [ i ] . modeExt ,%NWL%modeName: modeMatchers [ i ] . modeName%NWL%modeInfos . push (%NWL%5
function doSearch ( cm , rev )  {%NWL%var state = getSearchState ( cm ) ;%NWL%if ( state . query ) return findNext ( cm , rev ) ;%NWL%dialog ( cm , queryDialog ,  " Search for: " , function ( query )  {%NWL%cm . operation ( function ( )  {%NWL%if ( !query || state . query ) return;%NWL%state . query = parseQuery ( query ) ;%NWL%if ( cm . lineCount ( ) < 2000 )  {  / / This is too expensive on big documents .%NWL%for ( var cursor = cm . getSearchCursor ( query ) ; cursor . findNext ( ) ; )%NWL%state . marked . push ( cm . markText ( cursor . from ( ) , cursor . to ( ) ,  " CodeMirror - searching " ) ) ;%NWL%state . posFrom = state . posTo = cm . getCursor ( ) ;%NWL%6
var target = query . split ( " \n " ) ;%NWL%if ( target . length == 1 )%NWL%this . matches = function ( reverse , pos )  {%NWL%var line = fold ( cm . getLine ( pos . line ) ) , len = query . length , match;%NWL%if ( reverse ? ( pos . ch >= len && ( match = line . lastIndexOf ( query , pos . ch - len ) ) != - 1 )%NWL%: ( match = line . indexOf ( query , pos . ch ) ) != - 1 )%NWL%return { from: { line: pos . line , ch: match } ,%NWL%to: { line: pos . line , ch: match + len } } ;%NWL%} ;%NWL%else%NWL%var ln = pos . line , idx = ( reverse ? target . length - 1 : 0 ) , match = target [ idx ] , line = fold ( cm . getLine ( ln ) ) ;%NWL%3
return ' variable ' ;%NWL%}%NWL%stream . next ( ) ;%NWL%return ERRORCLASS;%NWL%}%NWL%function tokenFactory ( delimiter , outclass )  {%NWL%var singleline = delimiter . length == 1;%NWL%return function tokenString ( stream , state )  {%NWL%while ( !stream . eol ( ) )  {%NWL%stream . eatWhile ( / [ ^ ' " \ / \\ ] / ) ;%NWL%stream . next ( ) ;%NWL%2
break;%NWL%}%NWL%}%NWL%if ( _indent_index === - 1 )  {%NWL%return true;%NWL%}%NWL%while ( state . scopes [ 0 ] . offset !== _indent )  {%NWL%state . scopes . shift ( ) ;%NWL%}%NWL%return false%NWL%state . scopes . shift ( ) ;%NWL%7
} ;%NWL%return {%NWL%token: function ( stream )  {%NWL%var tw_pos = stream . string . search ( / [ \t ] + ?$ / ) ;%NWL%if ( !stream . sol ( ) || tw_pos === 0 )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ( " error "  +  (%NWL%TOKEN_NAMES [ stream . string . charAt ( 0 ) ] || ' ' ) ) . replace ( / $ / ,  ' ' ) ;%NWL%}%NWL%var token_name = TOKEN_NAMES [ stream . peek ( ) ] || stream . skipToEnd ( ) ;%NWL%stream . skipToEnd ( ) ;%NWL%5
}%NWL%var ch = stream . next ( ) ;%NWL%if ( ch == ' % ' )  {%NWL%stream . skipToEnd ( ) ;%NWL%return " comment " ;%NWL%}%NWL%if ( ch == ' ? ' )  {%NWL%stream . eatWhile ( idRE ) ;%NWL%return " variable - 2 " ;%NWL%}%NWL%stream . eatWhile ( idRE ) ;%NWL%7
if ( ch == ' \ ' ' )  {%NWL%return singleQuote ( stream ) ;%NWL%}%NWL%if ( ch == ' " ' )  {%NWL%return doubleQuote ( stream ) ;%NWL%}%NWL%if ( largeRE . test ( ch ) )  {%NWL%stream . eatWhile ( idRE ) ;%NWL%return " variable " ;%NWL%}%NWL%stream . eatWhile ( idRE ) ;%NWL%7
return " tag " ;        / / function application%NWL%}%NWL%}%NWL%return " atom " ;%NWL%}%NWL%if ( digitRE . test ( ch ) )  {%NWL%stream . eatWhile ( digitRE ) ;%NWL%if ( stream . eat ( ' # ' ) )  {%NWL%stream . eatWhile ( digitRE ) ;   / / 16#10 style integer%NWL%} else {%NWL%stream . eatWhile ( digitRE ) ;%NWL%6
}%NWL%if ( digitRE . test ( ch ) )  {%NWL%stream . eatWhile ( digitRE ) ;%NWL%if ( stream . eat ( ' # ' ) )  {%NWL%stream . eatWhile ( digitRE ) ;   / / 16#10 style integer%NWL%} else {%NWL%if ( stream . eat ( ' . ' ) )  {     / / float%NWL%stream . eatWhile ( digitRE ) ;%NWL%}%NWL%if ( stream . eat ( / [ eE ] / ) )  {%NWL%stream . eatWhile ( digitRE ) ;%NWL%2
}%NWL%%NWL%if ( largeRE . test ( ch ) )  {%NWL%source . eatWhile ( idRE ) ;%NWL%if ( source . eat ( ' . ' ) )  {%NWL%return " qualifier " ;%NWL%}%NWL%return " variable - 2 " ;%NWL%}%NWL%%NWL%source . eatWhile ( idRE ) ;%NWL%3
}%NWL%}%NWL%source . eatWhile ( digitRE ) ;%NWL%var t = " number " ;%NWL%if ( source . eat ( ' . ' ) )  {%NWL%t = " number " ;%NWL%source . eatWhile ( digitRE ) ; / / should require at least 1%NWL%}%NWL%if ( source . eat ( / [ eE ] / ) )  {%NWL%t = " number " ;%NWL%source . eatWhile ( digitRE ) ; / / should require at least 1%NWL%6
%NWL%function htmlDispatch ( stream , state )  {%NWL%if ( stream . match ( scriptStartRegex , false ) )  {%NWL%state . token=scriptingDispatch;%NWL%return scriptingMode . token ( stream , state . scriptState ) ;%NWL%}%NWL%else%NWL%return htmlMixedMode . token ( stream , state . htmlState ) ;%NWL%}%NWL%function scriptingDispatch ( stream , state )  {%NWL%state . token=htmlDispatch;%NWL%3
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
for ( var v = state . localVars; v; v = v . next )%NWL%if ( v . name == varname ) return;%NWL%state . localVars = { name: varname , next: state . localVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%if ( !cx . state . context ) cx . state . localVars = defaultVars;%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%8
if ( v . name == varname ) return;%NWL%state . localVars = { name: varname , next: state . localVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%if ( !cx . state . context ) cx . state . localVars = defaultVars;%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%7
var result = function ( )  {%NWL%var state = cx . state;%NWL%state . lexical = new JSLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info )%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
var state = cx . state;%NWL%state . lexical = new JSLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info )%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
break;%NWL%}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " variable - 2 " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%state . indent = state . context . indent;%NWL%8
}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " variable - 2 " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%function popContext ( state )  {%NWL%state . context = state . context . prev;%NWL%7
transitState ( state , ch ) ;%NWL%var parsedBNode = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != '  '  )  { parsedBNode + = c; return true; } return false; } ) ;%NWL%state . bnodes . push ( parsedBNode ) ;%NWL%stream . next ( ) ;%NWL%transitState ( state ,  '  ' ) ;%NWL%return ' builtin ' ;%NWL%}%NWL%if ( ch == ' " ' )  {%NWL%transitState ( state , ch ) ;%NWL%stream . next ( ) ;%NWL%4
stream . next ( ) ;%NWL%if ( stream . peek ( ) != ' @ ' && stream . peek ( ) != ' ^ '  )  {%NWL%transitState ( state ,  ' " ' ) ;%NWL%}%NWL%return ' string ' ;%NWL%}%NWL%if ( ch == ' @ '  )  {%NWL%transitState ( state ,  ' @ ' ) ;%NWL%var parsedLang = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != '  '  )  { parsedLang + = c; return true; } return false; } ) ;%NWL%stream . next ( ) ;%NWL%0
}%NWL%if ( ch == ' @ '  )  {%NWL%transitState ( state ,  ' @ ' ) ;%NWL%var parsedLang = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != '  '  )  { parsedLang + = c; return true; } return false; } ) ;%NWL%state . langs . push ( parsedLang ) ;%NWL%stream . next ( ) ;%NWL%transitState ( state ,  '  ' ) ;%NWL%return ' string - 2 ' ;%NWL%}%NWL%stream . next ( ) ;%NWL%6
state . langs . push ( parsedLang ) ;%NWL%stream . next ( ) ;%NWL%transitState ( state ,  '  ' ) ;%NWL%return ' string - 2 ' ;%NWL%}%NWL%if ( ch == ' ^ '  )  {%NWL%stream . next ( ) ;%NWL%transitState ( state ,  ' ^ ' ) ;%NWL%var parsedType = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != ' > '  )  { parsedType + = c; return true; } return false; }  ) ;%NWL%stream . next ( ) ;%NWL%1
' + + ' 				:  4 ,%NWL%' - - ' 				:  4 ,%NWL%' * * ' 				:  4 ,%NWL%' =~ ' 				:  4 ,%NWL%' !~ ' 				:  4 ,%NWL%' * ' 				:  4 ,%NWL%' / ' 				:  4 ,%NWL%' % ' 				:  4 ,%NWL%' x ' 				:  4 ,%NWL%' + ' 				:  4 ,%NWL%' . ' 				:  4 ,%NWL%3
var RXmodifiers= / [ goseximacplud ] / ;		 / / NOTE: " m " ,  " s " ,  " y " and " tr " need to correct real modifiers for each regexp type%NWL%function tokenChain ( stream , state , chain , style , tail ) { 	 / / NOTE: chain . length > 2 is not working now ( it ' s for s [ . . . ] [ . . . ] geos; )%NWL%state . chain=null;                / /                              12  3tail%NWL%state . style=null;%NWL%state . tail=null;%NWL%state . tokenize=function ( stream , state ) {%NWL%var e=false , c , i=0;%NWL%while ( c=stream . next ( ) ) {%NWL%if ( c===chain [ i ] &&!e ) {%NWL%if ( chain [ + + i ] !==undefined ) {%NWL%state . style=style;%NWL%3
state . tail=null;%NWL%state . tokenize=function ( stream , state ) {%NWL%var e=false , c , i=0;%NWL%while ( c=stream . next ( ) ) {%NWL%if ( c===chain [ i ] &&!e ) {%NWL%if ( chain [ + + i ] !==undefined ) {%NWL%state . chain=chain [ i ] ;%NWL%state . style=style;%NWL%state . tail=tail }%NWL%else if ( tail )%NWL%state . tokenize=tokenPerl;%NWL%0
state . tail=tail }%NWL%else if ( tail )%NWL%stream . eatWhile ( tail ) ;%NWL%state . tokenize=tokenPerl;%NWL%return style }%NWL%e=!e&&c== " \\ " }%NWL%return style } ;%NWL%return state . tokenize ( stream , state ) }%NWL%function tokenSOMETHING ( stream , state , string ) {%NWL%state . tokenize=function ( stream , state ) {%NWL%state . tokenize=tokenPerl;%NWL%3
if ( stream . match ( / ^ ( \ - ? ( \d * \ . \d + ( e [ + - ] ?\d + ) ?|\d + \ . \d * ) |0x [ \da - fA - F ] + |0b [ 01 ] + |\d + ( e [ + - ] ?\d + ) ? ) / ) )%NWL%return ' number ' ;%NWL%if ( stream . match ( / ^<< ( ?=\w ) / ) ) { 			 / / NOTE: <<SOMETHING\n . . . \nSOMETHING\n%NWL%stream . eatWhile ( / \w / ) ;%NWL%return tokenSOMETHING ( stream , state , stream . current ( ) . substr ( 2 ) ) }%NWL%if ( stream . sol ( ) &&stream . match ( / ^\=item ( ?!\w ) / ) ) { / / NOTE: \n=item . . . \n=cut\n%NWL%return tokenSOMETHING ( stream , state , ' =cut ' ) }%NWL%var ch=stream . next ( ) ;%NWL%if ( ch== ' " ' ||ch== " ' " ) { 				 / / NOTE: ' or " or << ' SOMETHING ' \n . . . \nSOMETHING\n or << " SOMETHING " \n . . . \nSOMETHING\n%NWL%if ( stream . prefix ( 3 ) == " << " + ch ) {%NWL%stream . eatWhile ( / \w / ) ;%NWL%3
return tokenChain ( stream , state , [ ch ] , " string " ) }%NWL%if ( ch== " q " ) {%NWL%var c=stream . look ( - 2 ) ;%NWL%if ( ! ( c&& / \w / . test ( c ) ) ) {%NWL%c=stream . look ( 0 ) ;%NWL%if ( c== " x " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%8
if ( ! ( c&& / \w / . test ( c ) ) ) {%NWL%c=stream . look ( 0 ) ;%NWL%if ( c== " x " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) } }%NWL%else if ( c== " q " ) {%NWL%c=stream . look ( 1 ) ;%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) } }%NWL%else if ( c== " q " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) } }%NWL%else if ( c== " q " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " string " ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " string " ) }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " string " ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " string " ) } }%NWL%else if ( c== " w " ) {%NWL%c=stream . look ( 1 ) ;%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " string " ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " string " ) } }%NWL%else if ( c== " w " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " bracket " ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " string " ) } }%NWL%else if ( c== " w " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " bracket " ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " bracket " ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " bracket " ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " bracket " ) }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " bracket " ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " bracket " ) }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " bracket " ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " bracket " ) } }%NWL%else if ( c== " r " ) {%NWL%c=stream . look ( 1 ) ;%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " bracket " ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " bracket " ) } }%NWL%else if ( c== " r " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " bracket " ) } }%NWL%else if ( c== " r " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) } }%NWL%else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%7
if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) } }%NWL%else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) }%NWL%stream . eatSuffix ( 1 ) ;%NWL%4
if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) } }%NWL%else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) }%NWL%stream . eatSuffix ( 1 ) ;%NWL%1
else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " string " ) }%NWL%stream . eatSuffix ( 1 ) ;%NWL%2
CodeMirror . StringStream . prototype . nsuffix=function ( c ) {%NWL%var p=this . pos;%NWL%var l=c|| ( this . string . length - this . pos + 1 ) ;%NWL%this . pos + =l;%NWL%return this . string . substr ( p , l ) } ;%NWL%CodeMirror . StringStream . prototype . eatSuffix=function ( c ) {%NWL%var x=this . pos + c;%NWL%var y;%NWL%if ( x<=0 )%NWL%this . pos=0;%NWL%this . pos=y;%NWL%9
else state . pending = { end: stream . pos , style: style } ;%NWL%stream . backUp ( cur . length - openPHP ) ;%NWL%} else if ( style == " tag " && stream . current ( ) == " > " && state . curState . context )  {%NWL%if ( / ^script$ / i . test ( state . curState . context . tagName ) )  {%NWL%state . curMode = jsMode;%NWL%state . curState = jsMode . startState ( htmlMode . indent ( state . curState ,  " " ) ) ;%NWL%state . curClose = / ^<\ / \s * script\s * > / i;%NWL%state . mode = " javascript " ;%NWL%}%NWL%else if ( / ^style$ / i . test ( state . curState . context . tagName ) )  {%NWL%state . curState = cssMode . startState ( htmlMode . indent ( state . curState ,  " " ) ) ;%NWL%5
else if ( / ^style$ / i . test ( state . curState . context . tagName ) )  {%NWL%state . curMode = cssMode;%NWL%state . curState = cssMode . startState ( htmlMode . indent ( state . curState ,  " " ) ) ;%NWL%state . curClose = / ^<\ / \s * style\s * > / i;%NWL%state . mode = " css " ;%NWL%}%NWL%}%NWL%return style;%NWL%} else if ( ( !isPHP || state . php . tokenize == null ) &&%NWL%stream . match ( state . curClose , isPHP ) )  {%NWL%state . curState = state . html;%NWL%2
else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%else if ( ch== " - " )  {%NWL%if ( stream . eat ( " - " ) ) {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " comment " ,  " comment " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%1
else if ( ch== " - " )  {%NWL%if ( stream . eat ( " - " ) ) {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " comment " ,  " comment " ) ;%NWL%}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%6
else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%else if ( ch == " - " )  {%NWL%if ( stream . eat ( " - " ) )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " comment " ,  " comment " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%1
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%else if ( ch == " @ " || ch == " $ " )  {%NWL%stream . eatWhile ( / [ \w\d\$_ ] / ) ;%NWL%return ret ( " word " ,  " variable " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
if ( stream . match ( / ^\d + \ . \d * / ) )  { floatLiteral = true; }%NWL%if ( stream . match ( / ^\ . \d + / ) )  { floatLiteral = true; }%NWL%if ( floatLiteral )  {%NWL%stream . eat ( / J / i ) ;%NWL%return ' number ' ;%NWL%}%NWL%var intLiteral = false;%NWL%if ( stream . match ( / ^0x [ 0 - 9a - f ] + / i ) )  { intLiteral = true; }%NWL%if ( stream . match ( / ^0b [ 01 ] + / i ) )  { intLiteral = true; }%NWL%if ( stream . match ( / ^0o [ 0 - 7 ] + / i ) )  { intLiteral = true; }%NWL%stream . eat ( / J / i ) ;%NWL%3
state . scopes . shift ( ) ;%NWL%}%NWL%return false%NWL%} else {%NWL%if ( type === ' py ' )  {%NWL%state . scopes [ 0 ] . offset = stream . indentation ( ) ;%NWL%return false;%NWL%} else {%NWL%if ( state . scopes [ 0 ] . type != type )  {%NWL%return true;%NWL%state . scopes . shift ( ) ;%NWL%0
token = ' link ' ;%NWL%} else if ( stream . match ( reFootnote ) )  {%NWL%token = ' quote ' ;%NWL%} else if ( stream . match ( reCitation ) )  {%NWL%token = ' quote ' ;%NWL%} else {%NWL%stream . eatSpace ( ) ;%NWL%if ( stream . eol ( ) )  {%NWL%setNormal ( state , stream ) ;%NWL%return null;%NWL%stream . skipToEnd ( ) ;%NWL%6
var delim = stream . eat ( / [ ^\w\s ] / ) ;%NWL%if ( !delim ) return " operator " ;%NWL%if ( matching . propertyIsEnumerable ( delim ) ) delim = matching [ delim ] ;%NWL%return chain ( readQuoted ( delim , style , embed , true ) , stream , state ) ;%NWL%} else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return " comment " ;%NWL%} else if ( ch == " < " && stream . eat ( " < " ) )  {%NWL%stream . eat ( " - " ) ;%NWL%stream . eat ( / [ \ ' \ " \` ] / ) ;%NWL%stream . eat ( / [ \ ' \ " \` ] / ) ;%NWL%9
while ( stream . match ( / ^\\ [ CM ] - / ) )  { }%NWL%if ( stream . eat ( " \\ " ) ) stream . eatWhile ( / \w / ) ;%NWL%else stream . next ( ) ;%NWL%return " string " ;%NWL%} else if ( ch == " : " )  {%NWL%if ( stream . eat ( " ' " ) ) return chain ( readQuoted ( " ' " ,  " atom " , false ) , stream , state ) ;%NWL%if ( stream . eat ( ' " ' ) ) return chain ( readQuoted ( ' " ' ,  " atom " , true ) , stream , state ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " atom " ;%NWL%} else if ( ch == " @ " )  {%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%7
} else if ( ch == " : " )  {%NWL%if ( stream . eat ( " ' " ) ) return chain ( readQuoted ( " ' " ,  " atom " , false ) , stream , state ) ;%NWL%if ( stream . eat ( ' " ' ) ) return chain ( readQuoted ( ' " ' ,  " atom " , true ) , stream , state ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " atom " ;%NWL%} else if ( ch == " @ " )  {%NWL%stream . eat ( " @ " ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " variable - 2 " ;%NWL%} else if ( ch == " $ " )  {%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%3
stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " atom " ;%NWL%} else if ( ch == " @ " )  {%NWL%stream . eat ( " @ " ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " variable - 2 " ;%NWL%} else if ( ch == " $ " )  {%NWL%stream . next ( ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " variable - 3 " ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%0
: " variable " ;%NWL%if ( indentWords . propertyIsEnumerable ( word ) ) kwtype = " indent " ;%NWL%else if ( dedentWords . propertyIsEnumerable ( word ) ) kwtype = " dedent " ;%NWL%else if ( ( word == " if " || word == " unless " ) && stream . column ( ) == stream . indentation ( ) )%NWL%kwtype = " indent " ;%NWL%}%NWL%if ( curPunc || ( style && style != " comment " ) ) state . lastTok = word || curPunc || style;%NWL%if ( curPunc == " | " ) state . varList = !state . varList;%NWL%if ( kwtype == " indent " || / [ \ ( \ [ \ { ] / . test ( curPunc ) )%NWL%state . context = { prev: state . context , type: curPunc || style , indented: state . indented } ;%NWL%state . context = state . context . prev;%NWL%9
var sol = stream . sol ( ) ;%NWL%var ch = stream . next ( ) ;%NWL%if ( ch === ' \ ' ' || ch === ' " ' || ch === ' ` ' )  {%NWL%state . tokens . unshift ( tokenString ( ch ) ) ;%NWL%return tokenize ( stream , state ) ;%NWL%}%NWL%if ( ch === ' # ' )  {%NWL%if ( sol && stream . eat ( ' ! ' ) )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ' meta ' ; / /  ' comment ' ?%NWL%stream . skipToEnd ( ) ;%NWL%8
if ( ch === ' - ' )  {%NWL%stream . eat ( ' - ' ) ;%NWL%stream . eatWhile ( / \w / ) ;%NWL%return ' attribute ' ;%NWL%}%NWL%if ( / \d / . test ( ch ) )  {%NWL%stream . eatWhile ( / \d / ) ;%NWL%if ( ! / \w / . test ( stream . peek ( ) ) )  {%NWL%return ' number ' ;%NWL%}%NWL%stream . eatWhile ( / \w / ) ;%NWL%2
else if ( / \d / . test ( ch ) )  {%NWL%stream . eatWhile ( / \d / ) ;%NWL%return ret ( " number " ,  " number " ) ;%NWL%}%NWL%else {%NWL%if ( state . last == " variable " )  {%NWL%if ( ch == " @ " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " property " ,  " property " ) ;%NWL%}%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%7
if ( state . last == " variable " )  {%NWL%if ( ch == " @ " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " property " ,  " property " ) ;%NWL%}%NWL%else if ( ch == " | " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " qualifier " ,  " modifier " ) ;%NWL%}%NWL%}%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%2
}%NWL%else if ( ch == " | " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " qualifier " ,  " modifier " ) ;%NWL%}%NWL%}%NWL%else if ( state . last == " whitespace " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " attribute " ,  " modifier " ) ;%NWL%}%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%2
break;%NWL%}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " string " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%state . indent = state . context . indent;%NWL%8
}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " string " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%function popContext ( state )  {%NWL%state . context = state . context . prev;%NWL%7
var plug = context [ i ] ;%NWL%if ( plug . name== " DEFAULT " )%NWL%continue;%NWL%return plug . styleIdentifier ( ) ;%NWL%}%NWL%return null;%NWL%}%NWL%function addPluginPattern ( pluginName , cmdStyle , brackets , styles )  {%NWL%return function ( )  {%NWL%this . name=pluginName;%NWL%this . style=cmdStyle;%NWL%9
}%NWL%function beginParams ( source , state )  {%NWL%var ch = source . peek ( ) ;%NWL%if ( ch == ' { ' || ch == ' [ ' )  {%NWL%var lastPlug = peekCommand ( state ) ;%NWL%var style = lastPlug . openBracket ( ch ) ;%NWL%source . eat ( ch ) ;%NWL%setState ( state , normal ) ;%NWL%return " bracket " ;%NWL%}%NWL%source . eat ( ch ) ;%NWL%6
if ( stream . match ( " CDATA [ " ) ) return chain ( inBlock ( " atom " ,  " ] ] > " ) ) ;%NWL%else return null;%NWL%}%NWL%else if ( stream . match ( " - - " ) ) return chain ( inBlock ( " comment " ,  " - - > " ) ) ;%NWL%else if ( stream . match ( " DOCTYPE " , true , true ) )  {%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%return chain ( doctype ( 1 ) ) ;%NWL%}%NWL%else return null;%NWL%}%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%5
}%NWL%%NWL%function tokenVariable ( stream , state )  {%NWL%var isVariableChar = / [ \w\$_ - ] / ;%NWL%if ( stream . eat ( " \ " " ) )  {%NWL%while ( stream . next ( ) !== ' \ " ' ) { } ;%NWL%stream . eat ( " : " ) ;%NWL%} else {%NWL%stream . eatWhile ( isVariableChar ) ;%NWL%if ( !stream . match ( " := " , false ) ) stream . eat ( " : " ) ;%NWL%stream . eatWhile ( isVariableChar ) ;%NWL%8
return " atom " ;%NWL%}%NWL%if ( state . pair && stream . match ( / ^:\s * / ) )  { state . pairStart = true; return ' meta ' ; }%NWL%%NWL%%NWL%if ( stream . match ( / ^ ( \ { |\ } |\ [ |\ ] ) / ) )  {%NWL%if ( ch == ' { ' )%NWL%state . inlinePairs + + ;%NWL%else if ( ch == ' } ' )%NWL%state . inlinePairs - - ;%NWL%state . inlineList + + ;%NWL%7
if ( state . pair && stream . match ( / ^:\s * / ) )  { state . pairStart = true; return ' meta ' ; }%NWL%%NWL%%NWL%if ( stream . match ( / ^ ( \ { |\ } |\ [ |\ ] ) / ) )  {%NWL%if ( ch == ' { ' )%NWL%state . inlinePairs + + ;%NWL%else if ( ch == ' } ' )%NWL%state . inlinePairs - - ;%NWL%else if ( ch == ' [ ' )%NWL%state . inlineList + + ;%NWL%state . inlineList - - ;%NWL%7
%NWL%%NWL%if ( state . inlineList > 0 && !esc && ch == ' , ' )  {%NWL%stream . next ( ) ;%NWL%return ' meta ' ;%NWL%}%NWL%%NWL%if ( state . inlinePairs > 0 && !esc && ch == ' , ' )  {%NWL%state . keyCol = 0;%NWL%state . pair = false;%NWL%stream . next ( ) ;%NWL%3
test ( " fromTextArea " , function ( )  {%NWL%var te = document . getElementById ( " code " ) ;%NWL%te . value = " CONTENT " ;%NWL%var cm = CodeMirror . fromTextArea ( te ) ;%NWL%is ( !te . offsetHeight ) ;%NWL%eq ( cm . getValue ( ) ,  " CONTENT " ) ;%NWL%cm . setValue ( " foo\nbar " ) ;%NWL%eq ( cm . getValue ( ) ,  " foo\nbar " ) ;%NWL%cm . save ( ) ;%NWL%is ( / ^foo\r?\nbar$ / . test ( te . value ) ) ;%NWL%cm . toTextArea ( ) ;%NWL%8
eqPos ( cm . getCursor ( true ) ,  { line: 1 , ch: 2 } ) ;%NWL%} ,  { value: " 111111\n222222\n333333 " } ) ;%NWL%testCM ( " lines " , function ( cm )  {%NWL%eq ( cm . getLine ( 0 ) ,  " 111111 " ) ;%NWL%eq ( cm . getLine ( 1 ) ,  " 222222 " ) ;%NWL%eq ( cm . getLine ( - 1 ) , null ) ;%NWL%cm . removeLine ( 1 ) ;%NWL%cm . setLine ( 1 ,  " abc " ) ;%NWL%eq ( cm . getValue ( ) ,  " 111111\nabc " ) ;%NWL%} ,  { value: " 111111\n222222\n333333 " } ) ;%NWL%cm . indentLine ( 1 ) ;%NWL%6
eq ( cm . getLine ( 0 ) ,  " 111111 " ) ;%NWL%eq ( cm . getLine ( 1 ) ,  " 222222 " ) ;%NWL%eq ( cm . getLine ( - 1 ) , null ) ;%NWL%cm . removeLine ( 1 ) ;%NWL%cm . setLine ( 1 ,  " abc " ) ;%NWL%eq ( cm . getValue ( ) ,  " 111111\nabc " ) ;%NWL%} ,  { value: " 111111\n222222\n333333 " } ) ;%NWL%testCM ( " indent " , function ( cm )  {%NWL%cm . indentLine ( 1 ) ;%NWL%eq ( cm . getLine ( 1 ) ,  "  blah ( ) ; " ) ;%NWL%cm . indentLine ( 1 ) ;%NWL%3
if ( example . index >= 0 && example . index < 64 )%NWL%eq ( cm . indexFromPos ( pos ) , example . index ) ;%NWL%}%NWL%} ) ;%NWL%testCM ( " undo " , function ( cm )  {%NWL%cm . setLine ( 0 ,  " def " ) ;%NWL%eq ( cm . historySize ( ) . undo , 1 ) ;%NWL%cm . undo ( ) ;%NWL%eq ( cm . getValue ( ) ,  " abc " ) ;%NWL%eq ( cm . historySize ( ) . undo , 0 ) ;%NWL%cm . redo ( ) ;%NWL%7
cm . setLine ( 0 ,  " def " ) ;%NWL%eq ( cm . historySize ( ) . undo , 1 ) ;%NWL%cm . undo ( ) ;%NWL%eq ( cm . getValue ( ) ,  " abc " ) ;%NWL%eq ( cm . historySize ( ) . undo , 0 ) ;%NWL%eq ( cm . historySize ( ) . redo , 1 ) ;%NWL%cm . redo ( ) ;%NWL%eq ( cm . getValue ( ) ,  " def " ) ;%NWL%eq ( cm . historySize ( ) . undo , 1 ) ;%NWL%eq ( cm . historySize ( ) . redo , 0 ) ;%NWL%cm . clearHistory ( ) ;%NWL%2
eq ( cm . historySize ( ) . undo , 1 ) ;%NWL%eq ( cm . historySize ( ) . redo , 0 ) ;%NWL%cm . setValue ( " 1\n\n\n2 " ) ;%NWL%cm . clearHistory ( ) ;%NWL%eq ( cm . historySize ( ) . undo , 0 ) ;%NWL%for ( var i = 0; i < 20; + + i )  {%NWL%cm . replaceRange ( " a " ,  { line: 0 , ch: 0 } ) ;%NWL%cm . replaceRange ( " b " ,  { line: 3 , ch: 0 } ) ;%NWL%}%NWL%eq ( cm . historySize ( ) . undo , 40 ) ;%NWL%cm . undo ( ) ;%NWL%3
cm . replaceRange ( " b " ,  { line: 3 , ch: 0 } ) ;%NWL%}%NWL%eq ( cm . historySize ( ) . undo , 40 ) ;%NWL%for ( var i = 0; i < 40; + + i )%NWL%cm . undo ( ) ;%NWL%eq ( cm . historySize ( ) . redo , 40 ) ;%NWL%eq ( cm . getValue ( ) ,  " 1\n\n\n2 " ) ;%NWL%} ,  { value: " abc " } ) ;%NWL%testCM ( " undoMultiLine " , function ( cm )  {%NWL%cm . replaceRange ( " x " ,  { line:0 , ch: 0 } ) ;%NWL%cm . undo ( ) ;%NWL%4
cm . undo ( ) ;%NWL%eq ( cm . historySize ( ) . redo , 40 ) ;%NWL%eq ( cm . getValue ( ) ,  " 1\n\n\n2 " ) ;%NWL%} ,  { value: " abc " } ) ;%NWL%testCM ( " undoMultiLine " , function ( cm )  {%NWL%cm . replaceRange ( " x " ,  { line:0 , ch: 0 } ) ;%NWL%cm . replaceRange ( " y " ,  { line:1 , ch: 0 } ) ;%NWL%cm . undo ( ) ;%NWL%eq ( cm . getValue ( ) ,  " abc\ndef\nghi " ) ;%NWL%cm . replaceRange ( " y " ,  { line:1 , ch: 0 } ) ;%NWL%cm . undo ( ) ;%NWL%0
cm . replaceRange ( " x " ,  { line:0 , ch: 0 } ) ;%NWL%cm . replaceRange ( " y " ,  { line:1 , ch: 0 } ) ;%NWL%cm . undo ( ) ;%NWL%eq ( cm . getValue ( ) ,  " abc\ndef\nghi " ) ;%NWL%cm . replaceRange ( " y " ,  { line:1 , ch: 0 } ) ;%NWL%cm . replaceRange ( " x " ,  { line:0 , ch: 0 } ) ;%NWL%cm . undo ( ) ;%NWL%eq ( cm . getValue ( ) ,  " abc\ndef\nghi " ) ;%NWL%cm . replaceRange ( " y " ,  { line:2 , ch: 0 } ) ;%NWL%cm . replaceRange ( " x " ,  { line:1 , ch: 0 } ) ;%NWL%cm . undo ( ) ;%NWL%2
return ' rgba ( '  +  ( o . R >> 0 )  +  ' , '  +  ( o . G >> 0 )  +  ' , '  +  ( o . B >> 0 )  +  ' , '  + alpha +  ' ) ' ;%NWL%} ;%NWL%root . W3_RGB = function ( o )  {%NWL%var o = o . substr ( 4 , o . length - 5 ) . split ( " , " ) ;%NWL%return {%NWL%R: parseInt ( o [ 0 ] ) ,%NWL%G: parseInt ( o [ 1 ] ) ,%NWL%B: parseInt ( o [ 2 ] )%NWL%}%NWL%} ;%NWL%var o = o . substr ( 5 , o . length - 6 ) . split ( " , " ) ;%NWL%3
return {%NWL%H: H * 360 ,%NWL%S: S * 100 ,%NWL%V: V * 100 ,%NWL%A: o . A%NWL%} ;%NWL%} ;%NWL%root . HSVA_RGBA =%NWL%root . HSV_RGB = function ( o )  {%NWL%var H = o . H / 360;%NWL%var V = o . V / 100;%NWL%9
uiHash . values = this . values ( ) ;%NWL%}%NWL%this . _trigger (  " stop " , event , uiHash ) ;%NWL%} ,%NWL%_change: function ( event , index )  {%NWL%if ( !this . _keySliding && !this . _mouseSliding )  {%NWL%var uiHash = {%NWL%handle: this . handles [ index ] ,%NWL%value: this . value ( )%NWL%} ;%NWL%uiHash . value = this . values ( index ) ;%NWL%0
this . element . addClass (  " ui - disabled "  ) ;%NWL%} else {%NWL%this . handles . propAttr (  " disabled " , false ) ;%NWL%this . element . removeClass (  " ui - disabled "  ) ;%NWL%}%NWL%break;%NWL%case " orientation " :%NWL%this . _detectOrientation ( ) ;%NWL%this . element%NWL%. removeClass (  " ui - slider - horizontal ui - slider - vertical "  )%NWL%this . _refreshValue ( ) ;%NWL%7
}%NWL%break;%NWL%case " orientation " :%NWL%this . _detectOrientation ( ) ;%NWL%this . element%NWL%. removeClass (  " ui - slider - horizontal ui - slider - vertical "  )%NWL%. addClass (  " ui - slider - "  + this . orientation ) ;%NWL%this . _refreshValue ( ) ;%NWL%break;%NWL%case " value " :%NWL%this . _refreshValue ( ) ;%NWL%3
. addClass (  " ui - slider - "  + this . orientation ) ;%NWL%this . _refreshValue ( ) ;%NWL%break;%NWL%case " value " :%NWL%this . _animateOff = true;%NWL%this . _refreshValue ( ) ;%NWL%this . _change ( null , 0 ) ;%NWL%this . _animateOff = false;%NWL%break;%NWL%case " values " :%NWL%this . _refreshValue ( ) ;%NWL%1
this . element = $ ( element ) ;%NWL%this . options = $ . extend ( true ,  { } ,%NWL%this . options ,%NWL%this . _getCreateOptions ( ) ,%NWL%options ) ;%NWL%var self = this;%NWL%this . element . bind (  " remove . "  + this . widgetName , function ( )  {%NWL%self . destroy ( ) ;%NWL%} ) ;%NWL%this . _create ( ) ;%NWL%this . _init ( ) ;%NWL%9
disable: function ( )  {%NWL%return this . _setOption (  " disabled " , true ) ;%NWL%} ,%NWL%_trigger: function ( type , event , data )  {%NWL%var prop , orig ,%NWL%callback = this . options [ type ] ;%NWL%data = data || { } ;%NWL%event = $ . Event ( event ) ;%NWL%event . type = ( type === this . widgetEventPrefix ?%NWL%type :%NWL%event . target = this . element [ 0 ] ;%NWL%8
d3 . chart . scatter = function ( )  {%NWL%var data;%NWL%var g;%NWL%var width = 500;%NWL%var height = 300;%NWL%var cx = 10;%NWL%function chart ( group )  {%NWL%g = group;%NWL%group . append ( " g " )%NWL%. classed ( " axis " , true )%NWL%group . append ( " g " )%NWL%8
%NWL%var circles = g . selectAll ( " circle " )%NWL%. data ( data , function ( d )  { return d . data . id } ) ;%NWL%circles . enter ( )%NWL%. append ( " circle " )%NWL%. attr ( {%NWL%cx: 0 ,%NWL%cy: height ,%NWL%fill: function ( d )  { return colorScale ( d . data . created )  } ,%NWL%title: function ( d )  { return d . data . title +  " score: "  + d . data . score }%NWL%circles . transition ( )%NWL%3
if ( !d3 . chart ) d3 . chart = { } ;%NWL%d3 . chart . table = function ( )  {%NWL%var data;%NWL%var div;%NWL%function chart ( container )  {%NWL%div = container;%NWL%var table = div . append ( " table " )%NWL%update ( ) ;%NWL%}%NWL%var table = div . select ( " table " )%NWL%6
var data;%NWL%var div;%NWL%function chart ( container )  {%NWL%div = container;%NWL%var table = div . append ( " table " )%NWL%update ( ) ;%NWL%}%NWL%function update ( )  {%NWL%var table = div . select ( " table " )%NWL%var trs = table . selectAll ( " tr . data " )%NWL%var enter = trs . enter ( )%NWL%4
}%NWL%function update ( )  {%NWL%var table = div . select ( " table " )%NWL%var trs = table . selectAll ( " tr . data " )%NWL%. data ( data , function ( d )  { return d . data . id } )%NWL%var enter = trs . enter ( )%NWL%. append ( " tr " )%NWL%. classed ( " data " , true )%NWL%trs . exit ( ) . remove ( ) ;%NWL%enter . append ( " td " )%NWL%enter . append ( " td " )%NWL%9
var trs = table . selectAll ( " tr . data " )%NWL%. data ( data , function ( d )  { return d . data . id } )%NWL%var enter = trs . enter ( )%NWL%. append ( " tr " )%NWL%. classed ( " data " , true )%NWL%trs . exit ( ) . remove ( ) ;%NWL%enter . append ( " td " )%NWL%. text ( function ( d )  { return d . data . score } )%NWL%enter . append ( " td " )%NWL%. append ( " img " )%NWL%enter . append ( " td " )%NWL%6
. classed ( " data " , true )%NWL%trs . exit ( ) . remove ( ) ;%NWL%enter . append ( " td " )%NWL%. text ( function ( d )  { return d . data . score } )%NWL%enter . append ( " td " )%NWL%. append ( " img " )%NWL%. attr ( " src " , function ( d )  { return d . data . thumbnail } )%NWL%enter . append ( " td " )%NWL%. append ( " a " )%NWL%. attr ( " href " , function ( d )  { return d . data . url } )%NWL%enter . append ( " td " )%NWL%2
enter . append ( " td " )%NWL%. text ( function ( d )  { return d . data . score } )%NWL%enter . append ( " td " )%NWL%. append ( " img " )%NWL%. attr ( " src " , function ( d )  { return d . data . thumbnail } )%NWL%enter . append ( " td " )%NWL%. append ( " a " )%NWL%. attr ( " href " , function ( d )  { return d . data . url } )%NWL%. text ( function ( d )  { return d . data . title } )%NWL%enter . append ( " td " )%NWL%enter . append ( " td " )%NWL%0
tp = { top: pos . top + pos . height / 2 - actualHeight / 2 , left: pos . left - actualWidth - this . options . offset } ;%NWL%break;%NWL%case ' w ' :%NWL%tp = { top: pos . top + pos . height / 2 - actualHeight / 2 , left: pos . left + pos . width + this . options . offset } ;%NWL%break;%NWL%}%NWL%%NWL%if ( gravity . length == 2 )  {%NWL%if ( gravity . charAt ( 1 ) == ' w ' )  {%NWL%tp . left = pos . left + pos . width / 2 - 15;%NWL%tp . left = pos . left + pos . width / 2 - actualWidth + 15;%NWL%9
if ( options === true )  {%NWL%return this . data ( ' tipsy ' ) ;%NWL%} else if ( typeof options == ' string ' )  {%NWL%var tipsy = this . data ( ' tipsy ' ) ;%NWL%if ( tipsy ) tipsy [ options ] ( ) ;%NWL%return this;%NWL%}%NWL%%NWL%options = $ . extend ( { } , $ . fn . tipsy . defaults , options ) ;%NWL%%NWL%var tipsy = $ . data ( ele ,  ' tipsy ' ) ;%NWL%3
$ . data ( ele ,  ' tipsy ' , tipsy ) ;%NWL%}%NWL%return tipsy;%NWL%}%NWL%%NWL%function enter ( )  {%NWL%var tipsy = get ( this ) ;%NWL%tipsy . hoverState = ' in ' ;%NWL%if ( options . delayIn == 0 )  {%NWL%tipsy . show ( ) ;%NWL%tipsy . fixTitle ( ) ;%NWL%9
tipsy . show ( ) ;%NWL%} else {%NWL%tipsy . fixTitle ( ) ;%NWL%setTimeout ( function ( )  { if ( tipsy . hoverState == ' in ' ) tipsy . show ( ) ; } , options . delayIn ) ;%NWL%}%NWL%} ;%NWL%%NWL%function leave ( )  {%NWL%var tipsy = get ( this ) ;%NWL%tipsy . hoverState = ' out ' ;%NWL%tipsy . hide ( ) ;%NWL%0
}%NWL%var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%8
var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%} ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%8
this . removeEventListener ( ' mouseup ' , onDragEnd , true ) ;%NWL%}%NWL%function onKeyDown ( e )  {%NWL%if ( e . keyCode > 36 && e . keyCode < 41 )  {  / / 37 - 40: left , up , right , down%NWL%onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%6
onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%if ( !isClick )%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%' inset 0 0 20px rgba ( 0 , 127 , 255 , . 1 ) , 0 0 1px rgba ( 0 , 127 , 255 , . 4 ) ' ;%NWL%}%NWL%this . style . boxShadow = ' ' ;%NWL%2
var scriptingMode , htmlMixedMode;%NWL%function htmlDispatch ( stream , state )  {%NWL%if ( stream . match ( scriptStartRegex , false ) )  {%NWL%state . token=scriptingDispatch;%NWL%return scriptingMode . token ( stream , state . scriptState ) ;%NWL%}%NWL%else%NWL%return htmlMixedMode . token ( stream , state . htmlState ) ;%NWL%}%NWL%function scriptingDispatch ( stream , state )  {%NWL%state . token=htmlDispatch;%NWL%3
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
} else {%NWL%if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%7
if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%6
var state = cx . state , indent = state . indented;%NWL%if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
if ( stream . match ( " CDATA [ " ) ) return chain ( inBlock ( " atom " ,  " ] ] > " ) ) ;%NWL%else return null;%NWL%} else if ( stream . match ( " - - " ) )  {%NWL%return chain ( inBlock ( " comment " ,  " - - > " ) ) ;%NWL%} else if ( stream . match ( " DOCTYPE " , true , true ) )  {%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%return chain ( doctype ( 1 ) ) ;%NWL%} else {%NWL%return null;%NWL%}%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%5
}%NWL%var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%8
var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%} ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%8
this . removeEventListener ( ' mouseup ' , onDragEnd , true ) ;%NWL%}%NWL%function onKeyDown ( e )  {%NWL%if ( e . keyCode > 36 && e . keyCode < 41 )  {  / / 37 - 40: left , up , right , down%NWL%onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%6
onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%if ( !isClick )%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%' inset 0 0 20px rgba ( 0 , 127 , 255 , . 1 ) , 0 0 1px rgba ( 0 , 127 , 255 , . 4 ) ' ;%NWL%}%NWL%this . style . boxShadow = ' ' ;%NWL%2
var scriptingMode , htmlMixedMode;%NWL%function htmlDispatch ( stream , state )  {%NWL%if ( stream . match ( scriptStartRegex , false ) )  {%NWL%state . token=scriptingDispatch;%NWL%return scriptingMode . token ( stream , state . scriptState ) ;%NWL%}%NWL%else%NWL%return htmlMixedMode . token ( stream , state . htmlState ) ;%NWL%}%NWL%function scriptingDispatch ( stream , state )  {%NWL%state . token=htmlDispatch;%NWL%3
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
} else {%NWL%if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%7
if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%6
var state = cx . state , indent = state . indented;%NWL%if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
if ( stream . match ( " CDATA [ " ) ) return chain ( inBlock ( " atom " ,  " ] ] > " ) ) ;%NWL%else return null;%NWL%} else if ( stream . match ( " - - " ) )  {%NWL%return chain ( inBlock ( " comment " ,  " - - > " ) ) ;%NWL%} else if ( stream . match ( " DOCTYPE " , true , true ) )  {%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%return chain ( doctype ( 1 ) ) ;%NWL%} else {%NWL%return null;%NWL%}%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%5
}%NWL%var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%8
var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%} ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%8
this . removeEventListener ( ' mouseup ' , onDragEnd , true ) ;%NWL%}%NWL%function onKeyDown ( e )  {%NWL%if ( e . keyCode > 36 && e . keyCode < 41 )  {  / / 37 - 40: left , up , right , down%NWL%onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%6
onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%if ( !isClick )%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%' inset 0 0 20px rgba ( 0 , 127 , 255 , . 1 ) , 0 0 1px rgba ( 0 , 127 , 255 , . 4 ) ' ;%NWL%}%NWL%this . style . boxShadow = ' ' ;%NWL%2
var scriptingMode , htmlMixedMode;%NWL%function htmlDispatch ( stream , state )  {%NWL%if ( stream . match ( scriptStartRegex , false ) )  {%NWL%state . token=scriptingDispatch;%NWL%return scriptingMode . token ( stream , state . scriptState ) ;%NWL%}%NWL%else%NWL%return htmlMixedMode . token ( stream , state . htmlState ) ;%NWL%}%NWL%function scriptingDispatch ( stream , state )  {%NWL%state . token=htmlDispatch;%NWL%3
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
} else {%NWL%if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%7
if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%6
var state = cx . state , indent = state . indented;%NWL%if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
if ( state . lexical . type == " stat " ) indent = state . lexical . indented;%NWL%state . lexical = new JSLexical ( indent , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
if ( stream . match ( " CDATA [ " ) ) return chain ( inBlock ( " atom " ,  " ] ] > " ) ) ;%NWL%else return null;%NWL%} else if ( stream . match ( " - - " ) )  {%NWL%return chain ( inBlock ( " comment " ,  " - - > " ) ) ;%NWL%} else if ( stream . match ( " DOCTYPE " , true , true ) )  {%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%return chain ( doctype ( 1 ) ) ;%NWL%} else {%NWL%return null;%NWL%}%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%5
var express = require ( ' express ' ) ;%NWL%var settings = require ( ' . / settings ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var MongoStore = require ( ' connect - mongo ' ) ( express )%NWL%var request = require ( ' request ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var MongoStore = require ( ' connect - mongo ' ) ( express )%NWL%var settings = require ( ' . / settings ' ) ;%NWL%var port = settings . port || 8888;%NWL%0
var express = require ( ' express ' ) ;%NWL%var MongoStore = require ( ' connect - mongo ' ) ( express )%NWL%var settings = require ( ' . / settings ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%var sandboxOrigin = settings . sandboxOrigin || " http: / / sandbox . localhost:8888 " ;%NWL%0
type: ' Mongo ' ,%NWL%host: ' localhost ' ,%NWL%port: 27017 ,%NWL%db: ' tributary '%NWL%}%NWL%var mongo = require ( ' mongoskin ' ) ;%NWL%var db = mongo . db ( ' mongodb: / / '  + mongoConf . host +  ' : '  + mongoConf . port +  ' / '  + mongoConf . db +  ' ?auto_reconnect ' ) ;%NWL%var $users = db . collection ( " users " ) ;%NWL%var $inlets = db . collection ( " inlets " ) ;%NWL%var $visits = db . collection ( " visits " ) ;%NWL%var cache = require ( ' . / cache ' ) ;%NWL%6
}%NWL%var user = gist . owner || gist . user%NWL%if ( user )  {%NWL%mgist . user = {%NWL%id: user . id%NWL%, login: user . login%NWL%}%NWL%}%NWL%mgist . description = gist . description%NWL%mgist . lastSave = new Date ( ) ;%NWL%var config = JSON . parse ( gist . files [ ' config . json ' ] . content ) ;%NWL%1
} ;%NWL%var limit = req . params . limit || 400;%NWL%$inlets . find ( query ,  { limit: limit } ) . sort ( { createdAt: - 1 } ) . toArray ( function ( err , inlets )  {%NWL%if ( err ) res . send ( err ) ;%NWL%res . send ( inlets ) ;%NWL%} )%NWL%}%NWL%app . get ( ' / api / latest / visits ' , latest_visits )%NWL%app . get ( ' / api / latest / visits / :start / :end ' , latest_visits )%NWL%function latest_visits ( req , res , next )  {%NWL%var start = req . params . start || new Date ( new Date ( )  -  ( 24 * 60 * 60 * 1000 ) ) ;%NWL%1
var limit = req . params . limit || 400;%NWL%$inlets . find ( query ,  { limit: limit } ) . sort ( { createdAt: - 1 } ) . toArray ( function ( err , inlets )  {%NWL%if ( err ) res . send ( err ) ;%NWL%res . send ( inlets ) ;%NWL%} )%NWL%}%NWL%app . get ( ' / api / latest / visits ' , latest_visits )%NWL%app . get ( ' / api / latest / visits / :start / :end ' , latest_visits )%NWL%function latest_visits ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%var end = req . params . end || new Date ( ) ;%NWL%0
}%NWL%app . get ( ' / api / user / :login / latest ' , user_latest )%NWL%app . get ( ' / api / user / :login / latest / :limit ' , user_latest )%NWL%app . get ( ' / api / user / :login / latest / :limit / :skip ' , user_latest )%NWL%function user_latest ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%var skip = req . params . skip || 0%NWL%var query = {%NWL%" user . login " : req . params . login%NWL%, public: { $ne: false }%NWL%var limit = req . params . limit || 200;%NWL%6
} ;%NWL%var limit = req . params . limit || 200;%NWL%$inlets . find ( query ,  { limit: limit , skip: skip } ) . sort ( { createdAt: - 1 } ) . toArray ( function ( err , inlets )  {%NWL%if ( err ) res . send ( err ) ;%NWL%res . send ( inlets ) ;%NWL%} )%NWL%}%NWL%app . get ( ' / api / counts / inlets ' , counts_inlets )%NWL%app . get ( ' / api / counts / inlets / :start / :end ' , counts_inlets )%NWL%function counts_inlets ( req , res , next )  {%NWL%var start = req . params . start || new Date ( new Date ( )  -  ( 24 * 60 * 60 * 1000 ) ) ;%NWL%1
var limit = req . params . limit || 200;%NWL%$inlets . find ( query ,  { limit: limit , skip: skip } ) . sort ( { createdAt: - 1 } ) . toArray ( function ( err , inlets )  {%NWL%if ( err ) res . send ( err ) ;%NWL%res . send ( inlets ) ;%NWL%} )%NWL%}%NWL%app . get ( ' / api / counts / inlets ' , counts_inlets )%NWL%app . get ( ' / api / counts / inlets / :start / :end ' , counts_inlets )%NWL%function counts_inlets ( req , res , next )  {%NWL%res . header ( " Access - Control - Allow - Origin " ,  " * " ) ;%NWL%var end = req . params . end || new Date ( ) ;%NWL%0
var request = require ( ' request ' ) ;%NWL%var mongoConf = {%NWL%type: ' Mongo ' ,%NWL%host: ' localhost ' ,%NWL%port: 27017 ,%NWL%db: ' tributary '%NWL%}%NWL%var db = mongo . db ( ' mongodb: / / '  + mongoConf . host +  ' : '  + mongoConf . port +  ' / '  + mongoConf . db +  ' ?auto_reconnect ' ) ;%NWL%0
cursor . nextObject ( iterator ) ;%NWL%function iterator ( err , mr_user )  {%NWL%if ( !mr_user ) return finish ( ) ;%NWL%console . log ( " user id " , mr_user . _id ) ;%NWL%$users . findOne ( { id: mr_user . _id } , function ( error , user )  {%NWL%if ( error || !user ) return cursor . nextObject ( iterator ) ;%NWL%user . inlets = mr_user . value . count || 1;%NWL%user . visits = mr_user . value . visits || 1;%NWL%user . nforks = mr_user . value . nforks || 0;%NWL%$users . update ( { id: user . id } , user ,  { safe: true } , function ( error )  {%NWL%cursor . nextObject ( iterator ) ;%NWL%0
var request = require ( ' request ' ) ;%NWL%var mongoConf = {%NWL%type: ' Mongo ' ,%NWL%host: ' localhost ' ,%NWL%port: 27017 ,%NWL%db: ' tributary '%NWL%}%NWL%var db = mongo . db ( ' mongodb: / / '  + mongoConf . host +  ' : '  + mongoConf . port +  ' / '  + mongoConf . db +  ' ?auto_reconnect ' ) ;%NWL%0
db . close ( )%NWL%} )%NWL%$visits . find ( ) . toArray ( function ( err , visits )  {%NWL%console . log ( " do visits " )%NWL%visits . forEach ( function ( visit )  {%NWL%if ( visit . time )  {%NWL%visit . createdAt = visit . time;%NWL%delete visit . time;%NWL%$visits . update ( { _id:visit . _id } , visit ,  { safe: true } , function ( error )  { if ( error ) console . log ( error ) } ) ;%NWL%}%NWL%db . close ( )%NWL%0
$visits . find ( ) . toArray ( function ( err , visits )  {%NWL%console . log ( " do visits " )%NWL%visits . forEach ( function ( visit )  {%NWL%if ( visit . time )  {%NWL%visit . createdAt = visit . time;%NWL%delete visit . time;%NWL%$visits . update ( { _id:visit . _id } , visit ,  { safe: true } , function ( error )  { if ( error ) console . log ( error ) } ) ;%NWL%}%NWL%} )%NWL%db . close ( )%NWL%db . close ( )%NWL%9
inlets . forEach ( function ( inlet )  {%NWL%if ( !inlet . description )  {%NWL%getgist ( inlet . gistid , function ( err , res , body )  {%NWL%inlet . description = JSON . parse ( body ) . description;%NWL%console . log ( " description " , inlet . description )%NWL%$inlets . update ( { gistid: inlet . gistid } , inlet ,  { safe: true } , function ( error )  { if ( error ) console . log ( error ) } ) ;%NWL%} )%NWL%}%NWL%} )%NWL%db . close ( )%NWL%db . close ( )%NWL%9
var express = require ( ' express ' ) ;%NWL%var app = express ( )%NWL%. use ( express . bodyParser ( ) ) ;%NWL%var settings = require ( ' . . / settings ' ) ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var app = express ( )%NWL%. use ( express . bodyParser ( ) ) ;%NWL%exports . app = app;%NWL%var origin = settings . origin || " http: / / localhost:8888 " ;%NWL%0
var express = require ( ' express ' ) ;%NWL%var app = express ( )%NWL%. use ( express . bodyParser ( ) ) ;%NWL%exports . app = app;%NWL%var settings = require ( ' . . / settings ' ) ;%NWL%var request = require ( ' request ' ) ;%NWL%0
res . send ( html ) ;%NWL%} ;%NWL%app . get ( " / s " , share ) ;%NWL%function share ( req , res , next )  {%NWL%var template = Handlebars . templates . inlet;%NWL%var html = template ( {%NWL%origin: origin ,%NWL%fullscreen: true ,%NWL%share: true ,%NWL%embed: false%NWL%res . send ( html ) ;%NWL%0
} ) ;%NWL%res . send ( html ) ;%NWL%} ;%NWL%app . get ( " / e " , embed ) ;%NWL%function embed ( req , res , next )  {%NWL%var template = Handlebars . templates . inlet;%NWL%var html = template ( {%NWL%origin: origin ,%NWL%fullscreen: true ,%NWL%embed: true%NWL%res . send ( html ) ;%NWL%1
. on ( " click " , function ( d )  {%NWL%var dis = d3 . select ( this ) ;%NWL%if ( dis . classed ( " active " )  )  {%NWL%console . log ( " Error logging disabled " ) ;%NWL%tributary . trace = false;%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%dis . classed ( " active " , false )%NWL%}%NWL%else {%NWL%console . log ( " Error logging initiated " ) ;%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%5
li . append ( " input " )%NWL%. attr ( " type " ,  " checkbox " )%NWL%. attr ( " checked " , true )%NWL%. on ( " change " , function ( d )  {%NWL%var reqs = that . model . get ( " require " ) ;%NWL%var ind = reqs . indexOf ( d ) ;%NWL%if ( ind >= 0 )  {%NWL%reqs . splice ( ind , 1 ) ;%NWL%that . model . set ( " require " , reqs ) ;%NWL%} else {%NWL%that . model . set ( " require " , reqs ) ;%NWL%8
this . model = options . model;%NWL%this . el = options . el;%NWL%this . config = options . config;%NWL%if ( !options . silent )  {%NWL%if ( options . preExecute )  {%NWL%this . model . on ( " change:code " , function ( )  {%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%} ) ;%NWL%tributary . __events__ . on ( " pre:execute " , this . execute , this )%NWL%} else {%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%6
this . model . trigger ( " noerror " ) ;%NWL%return true;%NWL%}%NWL%options . preExecute = true%NWL%init . call ( ctx , options ) ;%NWL%return ctx;%NWL%}%NWL%tributary . TextContext = function ( options )  {%NWL%function ctx ( )  { } ;%NWL%ctx . execute = function ( )  {%NWL%this . model . trigger ( " noerror " ) ;%NWL%0
options . preExecute = true%NWL%init . call ( ctx , options ) ;%NWL%return ctx;%NWL%}%NWL%tributary . TextContext = function ( options )  {%NWL%function ctx ( )  { } ;%NWL%ctx . execute = function ( )  {%NWL%if ( tributary . __noupdate__ ) return;%NWL%this . model . trigger ( " noerror " ) ;%NWL%return true;%NWL%init . call ( ctx , options ) ;%NWL%1
model: model ,%NWL%} ) ;%NWL%} ,%NWL%" csv " : function ( config , model )  {%NWL%model . set ( " mode " ,  " text " )%NWL%return tributary . CSVContext ( {%NWL%config: config ,%NWL%model: model ,%NWL%} ) ;%NWL%} ,%NWL%model . set ( " mode " ,  " text " )%NWL%4
} ) ;%NWL%} ,%NWL%" html " : function ( config , model , display )  {%NWL%model . set ( " mode " ,  " text / html " )%NWL%return tributary . HTMLContext ( {%NWL%config: config ,%NWL%model: model ,%NWL%el: display . node ( )%NWL%} ) ;%NWL%} ,%NWL%model . set ( " mode " ,  " text / html " )%NWL%3
this . model . on ( " delete " , function ( )  {%NWL%this . $el . remove ( ) ;%NWL%} , this )%NWL%} ,%NWL%getConfig: function ( )  {%NWL%var fileconfigs = tributary . __config__ . get ( " fileconfigs " ) ;%NWL%var fileconfig = fileconfigs [ this . model . get ( " filename " ) ]%NWL%if ( !fileconfig ) return this . defaultConfig ( ) ;%NWL%return fileconfig;%NWL%} ,%NWL%var fileconfigs = tributary . __config__ . get ( " fileconfigs " ) ;%NWL%5
} ,%NWL%getConfig: function ( )  {%NWL%var fileconfigs = tributary . __config__ . get ( " fileconfigs " ) ;%NWL%var fileconfig = fileconfigs [ this . model . get ( " filename " ) ]%NWL%if ( !fileconfig ) return this . defaultConfig ( ) ;%NWL%return fileconfig;%NWL%} ,%NWL%setConfig: function ( key , value )  {%NWL%var fileconfigs = tributary . __config__ . get ( " fileconfigs " ) ;%NWL%var fileconfig = fileconfigs [ this . model . get ( " filename " ) ]%NWL%var fileconfigs = tributary . __config__ . set ( " fileconfigs " , fileconfigs ) ;%NWL%2
var fileconfig = fileconfigs [ this . model . get ( " filename " ) ]%NWL%if ( !fileconfig ) return this . defaultConfig ( ) ;%NWL%return fileconfig;%NWL%} ,%NWL%setConfig: function ( key , value )  {%NWL%var fileconfigs = tributary . __config__ . get ( " fileconfigs " ) ;%NWL%var fileconfig = fileconfigs [ this . model . get ( " filename " ) ]%NWL%fileconfig [ key ] = value;%NWL%var fileconfigs = tributary . __config__ . set ( " fileconfigs " , fileconfigs ) ;%NWL%} ,%NWL%var fileconfigs = tributary . __config__ . get ( " fileconfigs " ) ;%NWL%5
var fileconfigs = tributary . __config__ . set ( " fileconfigs " , fileconfigs ) ;%NWL%} ,%NWL%defaultConfig: function ( )  {%NWL%var fileconfigs = tributary . __config__ . get ( " fileconfigs " ) ;%NWL%var fileconfig = {%NWL%default: true ,%NWL%vim: false ,%NWL%emacs: false ,%NWL%fontSize: 12%NWL%} ;%NWL%var fileconfigs = tributary . __config__ . set ( " fileconfigs " , fileconfigs ) ;%NWL%0
if ( that . cm . dragging || that . cm . picking ) wait = 0;%NWL%throttler . wait ( wait ) ;%NWL%throttler ( ) ;%NWL%} ) ;%NWL%this . cm . setValue ( this . model . get ( " code " ) ) ;%NWL%this . inlet = Inlet ( this . cm ) ;%NWL%this . model . on ( " error " , function ( error )  {%NWL%d3 . select ( that . el ) . select ( " . CodeMirror - gutter " )%NWL%. classed ( " error " , true ) ;%NWL%} ) ;%NWL%d3 . select ( that . el ) . select ( " . CodeMirror - gutter " )%NWL%7
var wrap = that . cm . getWrapperElement ( ) ;%NWL%d3 . select ( wrap ) . select ( " . CodeMirror - scroll " )%NWL%. style ( {%NWL%" font - size " : fontSize +  " px " ,%NWL%" line - height " : fontSize +  " px "%NWL%} )%NWL%that . cm . refresh ( ) ;%NWL%} )%NWL%var fileconfig = that . getConfig ( ) ;%NWL%var fontSize = fileconfig . fontSize;%NWL%d3 . select ( wrap ) . select ( " . CodeMirror - scroll " )%NWL%1
} )%NWL%that . cm . refresh ( ) ;%NWL%} )%NWL%var fileconfig = that . getConfig ( ) ;%NWL%var fontSize = fileconfig . fontSize;%NWL%var wrap = that . cm . getWrapperElement ( ) ;%NWL%d3 . select ( wrap ) . select ( " . CodeMirror - scroll " )%NWL%. style ( {%NWL%" font - size " : fontSize +  " px " ,%NWL%" line - height " : fontSize +  " px "%NWL%that . cm . refresh ( ) ;%NWL%1
}%NWL%var config;%NWL%try {%NWL%config = data . files [ " config . json " ] ;%NWL%} catch ( er )  {%NWL%config = false;%NWL%}%NWL%if ( config )  {%NWL%try {%NWL%ret . config = new tributary . Config ( JSON . parse ( config . content ) ) ;%NWL%ret . config = new tributary . Config ( ) ;%NWL%9
config = data . files [ " config . json " ] ;%NWL%} catch ( er )  {%NWL%config = false;%NWL%}%NWL%if ( config )  {%NWL%try {%NWL%ret . config = new tributary . Config ( JSON . parse ( config . content ) ) ;%NWL%} catch ( e ) {%NWL%ret . config = new tributary . Config ( ) ;%NWL%}%NWL%ret . config = new tributary . Config ( ) ;%NWL%6
if ( config )  {%NWL%try {%NWL%ret . config = new tributary . Config ( JSON . parse ( config . content ) ) ;%NWL%} catch ( e ) {%NWL%ret . config = new tributary . Config ( ) ;%NWL%}%NWL%} else {%NWL%ret . config = new tributary . Config ( ) ;%NWL%}%NWL%var files = _ . keys ( data . files ) ;%NWL%ret . models = new tributary . CodeModels ( ) ;%NWL%2
tributary . render = function ( )  { } ;%NWL%tributary . execute = function ( )  { } ;%NWL%tributary . clear = function ( )  { } ;%NWL%function execute ( )  {%NWL%if ( tributary . __noupdate__ ) return;%NWL%try {%NWL%if ( tributary . autoinit )  {%NWL%tributary . clear ( ) ;%NWL%tributary . __events__ . trigger ( " pre:execute " ) ;%NWL%tributary . __events__ . trigger ( " post:execute " ) ;%NWL%tributary . execute ( ) ;%NWL%7
tributary . execute = function ( )  { } ;%NWL%tributary . clear = function ( )  { } ;%NWL%function execute ( )  {%NWL%if ( tributary . __noupdate__ ) return;%NWL%try {%NWL%if ( tributary . autoinit )  {%NWL%tributary . clear ( ) ;%NWL%tributary . __events__ . trigger ( " pre:execute " ) ;%NWL%tributary . __events__ . trigger ( " post:execute " ) ;%NWL%}%NWL%tributary . render ( ) ;%NWL%6
d3 . select ( el ) . selectAll ( " * " ) . remove ( ) ;%NWL%} ;%NWL%}%NWL%}%NWL%tributary . clearAll = function ( )  {%NWL%d3 . select ( " #display " ) . selectAll ( " * " ) . remove ( ) ;%NWL%}%NWL%function makeDiv ( el )  {%NWL%tributary . __svg__ = null;%NWL%tributary . g = d3 . select ( el ) ;%NWL%d3 . select ( el ) . selectAll ( " * " ) . remove ( ) ;%NWL%0
}%NWL%function makeCanvas ( el )  {%NWL%tributary . __svg__ = null;%NWL%tributary . clear = function ( )  {%NWL%tributary . canvas . width = tributary . sw;%NWL%tributary . canvas . height = tributary . sh;%NWL%tributary . ctx . clearRect ( 0 , 0 , tributary . sw , tributary . sh ) ;%NWL%} ;%NWL%tributary . canvas = d3 . select ( el ) . append ( " canvas " )%NWL%. classed ( " tributary_canvas " , true )%NWL%tributary . ctx = tributary . canvas . getContext ( ' 2d ' ) ;%NWL%8
function makeCanvas ( el )  {%NWL%tributary . __svg__ = null;%NWL%tributary . clear = function ( )  {%NWL%tributary . canvas . width = tributary . sw;%NWL%tributary . canvas . height = tributary . sh;%NWL%tributary . ctx . clearRect ( 0 , 0 , tributary . sw , tributary . sh ) ;%NWL%} ;%NWL%tributary . canvas = d3 . select ( el ) . append ( " canvas " )%NWL%. classed ( " tributary_canvas " , true )%NWL%. node ( ) ;%NWL%tributary . g = tributary . ctx;%NWL%7
tributary . ctx . clearRect ( 0 , 0 , tributary . sw , tributary . sh ) ;%NWL%} ;%NWL%tributary . canvas = d3 . select ( el ) . append ( " canvas " )%NWL%. classed ( " tributary_canvas " , true )%NWL%. node ( ) ;%NWL%tributary . ctx = tributary . canvas . getContext ( ' 2d ' ) ;%NWL%tributary . g = tributary . ctx;%NWL%}%NWL%function makeWebgl ( )  {%NWL%tributary . __svg__ = null;%NWL%tributary . camera = new THREE . PerspectiveCamera ( 70 , tributary . sw / tributary . sh , 1 , 1e3 ) ;%NWL%2
} ;%NWL%tributary . canvas = d3 . select ( el ) . append ( " canvas " )%NWL%. classed ( " tributary_canvas " , true )%NWL%. node ( ) ;%NWL%tributary . ctx = tributary . canvas . getContext ( ' 2d ' ) ;%NWL%tributary . g = tributary . ctx;%NWL%}%NWL%function makeWebgl ( )  {%NWL%tributary . __svg__ = null;%NWL%container = el;%NWL%tributary . camera . position . y = 150;%NWL%1
tributary . canvas = d3 . select ( el ) . append ( " canvas " )%NWL%. classed ( " tributary_canvas " , true )%NWL%. node ( ) ;%NWL%tributary . ctx = tributary . canvas . getContext ( ' 2d ' ) ;%NWL%tributary . g = tributary . ctx;%NWL%}%NWL%function makeWebgl ( )  {%NWL%tributary . __svg__ = null;%NWL%container = el;%NWL%tributary . camera = new THREE . PerspectiveCamera ( 70 , tributary . sw / tributary . sh , 1 , 1e3 ) ;%NWL%tributary . camera . position . z = 500;%NWL%0
if ( event . origin !== tributary . _origin || !event . data ) return;%NWL%var data = event . data;%NWL%if ( data . request === " load " )  {%NWL%tributary . gistid = data . gistid;%NWL%parentWindow = event . source;%NWL%tributary . query = data . query;%NWL%if ( !tributary . __loading__ )  {%NWL%tributary . getGist ( ) ;%NWL%}%NWL%} else if ( data . request === " save " )  {%NWL%tributary . _screenshot ( ) ;%NWL%7
var endpoint = config . get ( " endpoint " ) ;%NWL%if ( tributary . endpoint )  {%NWL%endpoint = tributary . endpoint;%NWL%}%NWL%if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " play " , true ) ;%NWL%6
if ( tributary . endpoint )  {%NWL%endpoint = tributary . endpoint;%NWL%}%NWL%if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%7
}%NWL%if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%config . set ( " display " ,  " svg " ) ;%NWL%2
if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " play " , true ) ;%NWL%2
config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%3
config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " play " , true ) ;%NWL%3
} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%3
config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%config . set ( " display " ,  " svg " ) ;%NWL%3
config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " play " , true ) ;%NWL%3
} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%config . set ( " restart " , true ) ;%NWL%} else if ( endpoint === " fly " )  {%NWL%config . set ( " play " , true ) ;%NWL%2
config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%config . set ( " restart " , true ) ;%NWL%} else if ( endpoint === " fly " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%6
config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%config . set ( " restart " , true ) ;%NWL%} else if ( endpoint === " fly " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " restart " , true ) ;%NWL%6
}%NWL%} )%NWL%function fullscreenEvent ( fullscreen )  {%NWL%if ( fullscreen || tributary . __fullscreen__ )  {%NWL%config . set ( " fullscreen " , true ) ;%NWL%$ ( " #container " ) . addClass ( " fullscreen " )%NWL%goFullscreen ( ) ;%NWL%tributary . __events__ . trigger ( " resize " ) ;%NWL%} else {%NWL%config . set ( " fullscreen " , false ) ;%NWL%tributary . __events__ . trigger ( " resize " ) ;%NWL%7
if ( event . origin !== tributary . _origin || !event . data ) return;%NWL%var data = event . data;%NWL%if ( data . request === " load " )  {%NWL%tributary . gistid = data . gistid;%NWL%parentWindow = event . source;%NWL%tributary . query = data . query;%NWL%if ( !tributary . __loading__ )  {%NWL%tributary . getGist ( ) ;%NWL%}%NWL%} else if ( data . request === " save " )  {%NWL%tributary . _screenshot ( ) ;%NWL%7
var endpoint = config . get ( " endpoint " ) ;%NWL%if ( tributary . endpoint )  {%NWL%endpoint = tributary . endpoint;%NWL%}%NWL%if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " play " , true ) ;%NWL%6
if ( tributary . endpoint )  {%NWL%endpoint = tributary . endpoint;%NWL%}%NWL%if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%7
}%NWL%if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%config . set ( " display " ,  " svg " ) ;%NWL%2
if ( endpoint === " delta " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " play " , true ) ;%NWL%2
config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " loop " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%3
config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " play " , true ) ;%NWL%3
} else if ( endpoint === " cypress " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%3
config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%config . set ( " display " ,  " svg " ) ;%NWL%3
config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " hourglass " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " play " , true ) ;%NWL%3
} else if ( endpoint === " curiosity " )  {%NWL%config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%config . set ( " restart " , true ) ;%NWL%} else if ( endpoint === " fly " )  {%NWL%config . set ( " play " , true ) ;%NWL%2
config . set ( " display " ,  " webgl " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%config . set ( " restart " , true ) ;%NWL%} else if ( endpoint === " fly " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%6
config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , true ) ;%NWL%} else if ( endpoint === " bigfish " )  {%NWL%config . set ( " display " ,  " svg " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " autoinit " , false ) ;%NWL%config . set ( " restart " , true ) ;%NWL%} else if ( endpoint === " fly " )  {%NWL%config . set ( " display " ,  " canvas " ) ;%NWL%config . set ( " play " , true ) ;%NWL%config . set ( " restart " , true ) ;%NWL%6
}%NWL%} ) ;%NWL%function fullscreenEvent ( fullscreen )  {%NWL%if ( fullscreen || tributary . __fullscreen__ )  {%NWL%config . set ( " fullscreen " , true ) ;%NWL%$ ( " #container " ) . addClass ( " fullscreen " ) ;%NWL%goFullscreen ( ) ;%NWL%tributary . __events__ . trigger ( " resize " ) ;%NWL%} else {%NWL%config . set ( " fullscreen " , false ) ;%NWL%tributary . __events__ . trigger ( " resize " ) ;%NWL%7
var iHeight = oData . height;%NWL%aHeader . push ( 0x42 ) ; / / magic 1%NWL%aHeader . push ( 0x4D ) ;%NWL%%NWL%var iFileSize = iWidth * iHeight * 3 + 54; / / total header size = 54 bytes%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%9
aHeader . push ( 0x42 ) ; / / magic 1%NWL%aHeader . push ( 0x4D ) ;%NWL%%NWL%var iFileSize = iWidth * iHeight * 3 + 54; / / total header size = 54 bytes%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ;%NWL%9
%NWL%var iFileSize = iWidth * iHeight * 3 + 54; / / total header size = 54 bytes%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ;%NWL%7
var iFileSize = iWidth * iHeight * 3 + 54; / / total header size = 54 bytes%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 54 ) ; / / dataoffset%NWL%aHeader . push ( 0 ) ;%NWL%6
aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ; iFileSize = Math . floor ( iFileSize / 256 ) ;%NWL%aHeader . push ( iFileSize % 256 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 54 ) ; / / dataoffset%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ;%NWL%5
aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ; / / reserved%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 54 ) ; / / dataoffset%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ;%NWL%aHeader . push ( 0 ) ;%NWL%var aInfoHeader = [ ] ;%NWL%aInfoHeader . push ( 40 ) ; / / info header size%NWL%aInfoHeader . push ( 0 ) ;%NWL%aInfoHeader . push ( 0 ) ;%NWL%9
%NWL%var iImageHeight = iHeight;%NWL%aInfoHeader . push ( iImageHeight % 256 ) ; iImageHeight = Math . floor ( iImageHeight / 256 ) ;%NWL%aInfoHeader . push ( iImageHeight % 256 ) ; iImageHeight = Math . floor ( iImageHeight / 256 ) ;%NWL%aInfoHeader . push ( iImageHeight % 256 ) ; iImageHeight = Math . floor ( iImageHeight / 256 ) ;%NWL%aInfoHeader . push ( iImageHeight % 256 ) ;%NWL%%NWL%aInfoHeader . push ( 1 ) ; / / num of planes%NWL%aInfoHeader . push ( 0 ) ;%NWL%%NWL%aInfoHeader . push ( 0 ) ;%NWL%8
aInfoHeader . push ( iImageHeight % 256 ) ; iImageHeight = Math . floor ( iImageHeight / 256 ) ;%NWL%aInfoHeader . push ( iImageHeight % 256 ) ; iImageHeight = Math . floor ( iImageHeight / 256 ) ;%NWL%aInfoHeader . push ( iImageHeight % 256 ) ;%NWL%%NWL%aInfoHeader . push ( 1 ) ; / / num of planes%NWL%aInfoHeader . push ( 0 ) ;%NWL%%NWL%aInfoHeader . push ( 24 ) ; / / num of bits per pixel%NWL%aInfoHeader . push ( 0 ) ;%NWL%%NWL%aInfoHeader . push ( 0 ) ;%NWL%5
aInfoHeader . push ( iImageHeight % 256 ) ; iImageHeight = Math . floor ( iImageHeight / 256 ) ;%NWL%aInfoHeader . push ( iImageHeight % 256 ) ;%NWL%%NWL%aInfoHeader . push ( 1 ) ; / / num of planes%NWL%aInfoHeader . push ( 0 ) ;%NWL%%NWL%aInfoHeader . push ( 24 ) ; / / num of bits per pixel%NWL%aInfoHeader . push ( 0 ) ;%NWL%%NWL%aInfoHeader . push ( 0 ) ; / / compression = none%NWL%aInfoHeader . push ( 0 ) ;%NWL%4
aInfoHeader . push ( iImageHeight % 256 ) ;%NWL%%NWL%aInfoHeader . push ( 1 ) ; / / num of planes%NWL%aInfoHeader . push ( 0 ) ;%NWL%%NWL%aInfoHeader . push ( 24 ) ; / / num of bits per pixel%NWL%aInfoHeader . push ( 0 ) ;%NWL%%NWL%aInfoHeader . push ( 0 ) ; / / compression = none%NWL%aInfoHeader . push ( 0 ) ;%NWL%aInfoHeader . push ( 0 ) ;%NWL%3
}%NWL%var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%8
var getValue = function ( )  { return ' '  + value; } ;%NWL%var setValue = function setValue ( val )  {%NWL%value = ' '  + val;%NWL%isValueSet = true;%NWL%draw ( ) ;%NWL%delete slider . value;%NWL%slider . value = value;%NWL%slider . __defineGetter__ ( ' value ' , getValue ) ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%} ;%NWL%slider . __defineSetter__ ( ' value ' , setValue ) ;%NWL%8
this . removeEventListener ( ' mouseup ' , onDragEnd , true ) ;%NWL%}%NWL%function onKeyDown ( e )  {%NWL%if ( e . keyCode > 36 && e . keyCode < 41 )  {  / / 37 - 40: left , up , right , down%NWL%onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%6
onFocus . call ( this ) ;%NWL%isChanged = true;%NWL%this . value = value +  ( e . keyCode == 38 || e . keyCode == 39 ? step : - step ) ;%NWL%}%NWL%}%NWL%function onFocus ( )  {%NWL%if ( !isClick )%NWL%this . style . boxShadow = !isMac ? ' 0 0 0 2px #fb0 ' :%NWL%' inset 0 0 20px rgba ( 0 , 127 , 255 , . 1 ) , 0 0 1px rgba ( 0 , 127 , 255 , . 4 ) ' ;%NWL%}%NWL%this . style . boxShadow = ' ' ;%NWL%2
$ ( ' . report - a - problem - container . error - notification ' ) . remove ( ) ;%NWL%ReportAProblem . disableSubmitButton ( ) ;%NWL%$ . ajax ( {%NWL%type: ' POST ' ,%NWL%url: ' / contact / govuk / problem_reports ' ,%NWL%dataType: ' json ' ,%NWL%data: $ ( ' . report - a - problem - container form ' ) . serialize ( ) ,%NWL%success: ReportAProblem . showConfirmation ,%NWL%error: function ( jqXHR , status )  {%NWL%if ( status === ' error ' || !jqXHR . responseText )  {%NWL%ReportAProblem . promptUserToEnterValidData ( ) ;%NWL%1
type: ' POST ' ,%NWL%url: ' / contact / govuk / problem_reports ' ,%NWL%dataType: ' json ' ,%NWL%data: $ ( ' . report - a - problem - container form ' ) . serialize ( ) ,%NWL%success: ReportAProblem . showConfirmation ,%NWL%error: function ( jqXHR , status )  {%NWL%if ( status === ' error ' || !jqXHR . responseText )  {%NWL%if ( jqXHR . status === 422 )  {%NWL%ReportAProblem . promptUserToEnterValidData ( ) ;%NWL%}%NWL%ReportAProblem . showErrorMessage ( ) ;%NWL%8
tp = { top: pos . top + pos . height / 2 - actualHeight / 2 , left: pos . left - actualWidth - this . options . offset } ;%NWL%break;%NWL%case ' w ' :%NWL%tp = { top: pos . top + pos . height / 2 - actualHeight / 2 , left: pos . left + pos . width + this . options . offset } ;%NWL%break;%NWL%}%NWL%%NWL%if ( gravity . length == 2 )  {%NWL%if ( gravity . charAt ( 1 ) == ' w ' )  {%NWL%tp . left = pos . left + pos . width / 2 - 15;%NWL%tp . left = pos . left + pos . width / 2 - actualWidth + 15;%NWL%9
if ( options === true )  {%NWL%return this . data ( ' tipsy ' ) ;%NWL%} else if ( typeof options == ' string ' )  {%NWL%var tipsy = this . data ( ' tipsy ' ) ;%NWL%if ( tipsy ) tipsy [ options ] ( ) ;%NWL%return this;%NWL%}%NWL%%NWL%options = $ . extend ( { } , $ . fn . tipsy . defaults , options ) ;%NWL%%NWL%var tipsy = $ . data ( ele ,  ' tipsy ' ) ;%NWL%3
$ . data ( ele ,  ' tipsy ' , tipsy ) ;%NWL%}%NWL%return tipsy;%NWL%}%NWL%%NWL%function enter ( )  {%NWL%var tipsy = get ( this ) ;%NWL%tipsy . hoverState = ' in ' ;%NWL%if ( options . delayIn === 0 )  {%NWL%tipsy . show ( ) ;%NWL%tipsy . fixTitle ( ) ;%NWL%9
tipsy . show ( ) ;%NWL%} else {%NWL%tipsy . fixTitle ( ) ;%NWL%setTimeout ( function ( )  { if ( tipsy . hoverState == ' in ' ) tipsy . show ( ) ; } , options . delayIn ) ;%NWL%}%NWL%}%NWL%%NWL%function leave ( )  {%NWL%var tipsy = get ( this ) ;%NWL%tipsy . hoverState = ' out ' ;%NWL%tipsy . hide ( ) ;%NWL%0
" use strict " ;%NWL%var Tabletop = global . Tabletop = function ( options )  {%NWL%if ( !this || this === global )  {%NWL%return new Tabletop ( options ) ;%NWL%}%NWL%if ( typeof ( options ) == ' string ' )  {%NWL%options = { key : options } ;%NWL%}%NWL%this . callback = options . callback;%NWL%this . wanted = options . wanted || [ ] ;%NWL%this . simpleSheet = !!options . simpleSheet;%NWL%9
var Tabletop = global . Tabletop = function ( options )  {%NWL%if ( !this || this === global )  {%NWL%return new Tabletop ( options ) ;%NWL%}%NWL%if ( typeof ( options ) == ' string ' )  {%NWL%options = { key : options } ;%NWL%}%NWL%this . callback = options . callback;%NWL%this . wanted = options . wanted || [ ] ;%NWL%this . key = options . key;%NWL%this . parseNumbers = !!options . parseNumbers;%NWL%8
if ( !this || this === global )  {%NWL%return new Tabletop ( options ) ;%NWL%}%NWL%if ( typeof ( options ) == ' string ' )  {%NWL%options = { key : options } ;%NWL%}%NWL%this . callback = options . callback;%NWL%this . wanted = options . wanted || [ ] ;%NWL%this . key = options . key;%NWL%this . simpleSheet = !!options . simpleSheet;%NWL%this . wait = !!options . wait;%NWL%7
return new Tabletop ( options ) ;%NWL%}%NWL%if ( typeof ( options ) == ' string ' )  {%NWL%options = { key : options } ;%NWL%}%NWL%this . callback = options . callback;%NWL%this . wanted = options . wanted || [ ] ;%NWL%this . key = options . key;%NWL%this . simpleSheet = !!options . simpleSheet;%NWL%this . parseNumbers = !!options . parseNumbers;%NWL%this . postProcess = options . postProcess;%NWL%6
}%NWL%if ( typeof ( options ) == ' string ' )  {%NWL%options = { key : options } ;%NWL%}%NWL%this . callback = options . callback;%NWL%this . wanted = options . wanted || [ ] ;%NWL%this . key = options . key;%NWL%this . simpleSheet = !!options . simpleSheet;%NWL%this . parseNumbers = !!options . parseNumbers;%NWL%this . wait = !!options . wait;%NWL%this . debug = !!options . debug;%NWL%5
this . callback = options . callback;%NWL%this . wanted = options . wanted || [ ] ;%NWL%this . key = options . key;%NWL%this . simpleSheet = !!options . simpleSheet;%NWL%this . parseNumbers = !!options . parseNumbers;%NWL%this . wait = !!options . wait;%NWL%this . postProcess = options . postProcess;%NWL%this . debug = !!options . debug;%NWL%%NWL%if ( / key= / . test ( this . key ) )  {%NWL%this . key = this . key . match ( " key= ( . * ? ) & " ) [ 1 ] ;%NWL%1
if ( / key= / . test ( this . key ) )  {%NWL%this . log ( " You passed a key as a URL! Attempting to parse . " ) ;%NWL%this . key = this . key . match ( " key= ( . * ? ) & " ) [ 1 ] ;%NWL%}%NWL%if ( !this . key )  {%NWL%alert ( " You need to pass Tabletop a key! " ) ;%NWL%return;%NWL%}%NWL%this . log ( " Initializing with key %s " , this . key ) ;%NWL%this . models = { } ;%NWL%this . base_json_url = " https: / / spreadsheets . google . com / feeds / worksheets / "  + this . key +  " / public / basic?alt=json - in - script " ;%NWL%2
THREE . TrackballControls = function ( object , domElement )  {%NWL%var _this = this;%NWL%var STATE = { NONE: - 1 , ROTATE: 0 , ZOOM: 1 , PAN: 2 , TOUCH_ROTATE: 3 , TOUCH_ZOOM: 4 , TOUCH_PAN: 5 } ;%NWL%this . object = object;%NWL%this . domElement = ( domElement !== undefined ) ? domElement : document;%NWL%this . enabled = true;%NWL%this . rotateSpeed = 1 . 0;%NWL%4
THREE . TrackballControls = function ( object , domElement )  {%NWL%var _this = this;%NWL%var STATE = { NONE: - 1 , ROTATE: 0 , ZOOM: 1 , PAN: 2 , TOUCH_ROTATE: 3 , TOUCH_ZOOM: 4 , TOUCH_PAN: 5 } ;%NWL%this . object = object;%NWL%this . domElement = ( domElement !== undefined ) ? domElement : document;%NWL%this . enabled = true;%NWL%this . screen = { left: 0 , top: 0 , width: 0 , height: 0 } ;%NWL%this . zoomSpeed = 1 . 2;%NWL%4
THREE . TrackballControls = function ( object , domElement )  {%NWL%var _this = this;%NWL%var STATE = { NONE: - 1 , ROTATE: 0 , ZOOM: 1 , PAN: 2 , TOUCH_ROTATE: 3 , TOUCH_ZOOM: 4 , TOUCH_PAN: 5 } ;%NWL%this . object = object;%NWL%this . domElement = ( domElement !== undefined ) ? domElement : document;%NWL%this . enabled = true;%NWL%this . screen = { left: 0 , top: 0 , width: 0 , height: 0 } ;%NWL%this . rotateSpeed = 1 . 0;%NWL%this . panSpeed = 0 . 3;%NWL%4
this . domElement = ( domElement !== undefined ) ? domElement : document;%NWL%this . enabled = true;%NWL%this . screen = { left: 0 , top: 0 , width: 0 , height: 0 } ;%NWL%this . rotateSpeed = 1 . 0;%NWL%this . zoomSpeed = 1 . 2;%NWL%this . panSpeed = 0 . 3;%NWL%this . noRotate = false;%NWL%this . noZoom = false;%NWL%this . noPan = false;%NWL%this . noRoll = false;%NWL%this . dynamicDampingFactor = 0 . 2;%NWL%0
}%NWL%}%NWL%} ;%NWL%this . zoomCamera = function ( )  {%NWL%if ( _state === STATE . TOUCH_ZOOM )  {%NWL%var factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;%NWL%_touchZoomDistanceStart = _touchZoomDistanceEnd;%NWL%_eye . multiplyScalar ( factor ) ;%NWL%} else {%NWL%var factor = 1 . 0 +  ( _zoomEnd . y - _zoomStart . y )  * _this . zoomSpeed;%NWL%_eye . multiplyScalar ( factor ) ;%NWL%7
if ( _eye . lengthSq ( ) < _this . minDistance * _this . minDistance )  {%NWL%_this . object . position . addVectors ( _this . target , _eye . setLength ( _this . minDistance )  ) ;%NWL%}%NWL%}%NWL%} ;%NWL%this . update = function ( )  {%NWL%_eye . subVectors ( _this . object . position , _this . target ) ;%NWL%if ( !_this . noRotate )  {%NWL%_this . rotateCamera ( ) ;%NWL%}%NWL%_this . zoomCamera ( ) ;%NWL%8
}%NWL%} ;%NWL%this . update = function ( )  {%NWL%_eye . subVectors ( _this . object . position , _this . target ) ;%NWL%if ( !_this . noRotate )  {%NWL%_this . rotateCamera ( ) ;%NWL%}%NWL%if ( !_this . noZoom )  {%NWL%_this . zoomCamera ( ) ;%NWL%}%NWL%_this . panCamera ( ) ;%NWL%5
_eye . subVectors ( _this . object . position , _this . target ) ;%NWL%if ( !_this . noRotate )  {%NWL%_this . rotateCamera ( ) ;%NWL%}%NWL%if ( !_this . noZoom )  {%NWL%_this . zoomCamera ( ) ;%NWL%}%NWL%if ( !_this . noPan )  {%NWL%_this . panCamera ( ) ;%NWL%}%NWL%_this . checkDistances ( ) ;%NWL%2
event . stopPropagation ( ) ;%NWL%if ( _state === STATE . ROTATE && !_this . noRotate )  {%NWL%_rotateEnd = _this . getMouseProjectionOnBall ( event . clientX , event . clientY ) ;%NWL%} else if ( _state === STATE . ZOOM && !_this . noZoom )  {%NWL%_zoomEnd = _this . getMouseOnScreen ( event . clientX , event . clientY ) ;%NWL%} else if ( _state === STATE . PAN && !_this . noPan )  {%NWL%_panEnd = _this . getMouseOnScreen ( event . clientX , event . clientY ) ;%NWL%}%NWL%}%NWL%function mouseup ( event )  {%NWL%event . preventDefault ( ) ;%NWL%0
}%NWL%function mouseup ( event )  {%NWL%if ( _this . enabled === false ) return;%NWL%event . preventDefault ( ) ;%NWL%event . stopPropagation ( ) ;%NWL%_state = STATE . NONE;%NWL%document . removeEventListener (  ' mousemove ' , mousemove ) ;%NWL%document . removeEventListener (  ' mouseup ' , mouseup ) ;%NWL%}%NWL%function mousewheel ( event )  {%NWL%event . preventDefault ( ) ;%NWL%3
function mouseup ( event )  {%NWL%if ( _this . enabled === false ) return;%NWL%event . preventDefault ( ) ;%NWL%event . stopPropagation ( ) ;%NWL%_state = STATE . NONE;%NWL%document . removeEventListener (  ' mousemove ' , mousemove ) ;%NWL%document . removeEventListener (  ' mouseup ' , mouseup ) ;%NWL%}%NWL%function mousewheel ( event )  {%NWL%if ( _this . enabled === false ) return;%NWL%event . stopPropagation ( ) ;%NWL%2
( function ( )  {%NWL%CodeMirror . defineOption ( " placeholder " ,  " " , function ( cm , val , old )  {%NWL%var prev = old && old != CodeMirror . Init;%NWL%if ( val && !prev )  {%NWL%cm . on ( " focus " , onFocus ) ;%NWL%cm . on ( " blur " , onBlur ) ;%NWL%cm . on ( " change " , onChange ) ;%NWL%onChange ( cm ) ;%NWL%cm . off ( " focus " , onFocus ) ;%NWL%4
( function ( )  {%NWL%CodeMirror . defineOption ( " placeholder " ,  " " , function ( cm , val , old )  {%NWL%var prev = old && old != CodeMirror . Init;%NWL%if ( val && !prev )  {%NWL%cm . on ( " focus " , onFocus ) ;%NWL%cm . on ( " blur " , onBlur ) ;%NWL%cm . on ( " change " , onChange ) ;%NWL%onChange ( cm ) ;%NWL%} else if ( !val && prev )  {%NWL%cm . off ( " blur " , onBlur ) ;%NWL%5
( function ( )  {%NWL%CodeMirror . defineOption ( " placeholder " ,  " " , function ( cm , val , old )  {%NWL%var prev = old && old != CodeMirror . Init;%NWL%if ( val && !prev )  {%NWL%cm . on ( " focus " , onFocus ) ;%NWL%cm . on ( " blur " , onBlur ) ;%NWL%cm . on ( " change " , onChange ) ;%NWL%onChange ( cm ) ;%NWL%} else if ( !val && prev )  {%NWL%cm . off ( " focus " , onFocus ) ;%NWL%cm . off ( " change " , onChange ) ;%NWL%6
var selection = cm . getSelection ( ) ;%NWL%cm . replaceSelection ( left + selection + right ) ;%NWL%}%NWL%function maybeOverwrite ( cm )  {%NWL%var cur = cm . getCursor ( ) , ahead = cm . getRange ( cur , CodeMirror . Pos ( cur . line , cur . ch + 1 ) ) ;%NWL%if ( ahead != right || cm . somethingSelected ( ) ) return CodeMirror . Pass;%NWL%else cm . execCommand ( " goCharRight " ) ;%NWL%}%NWL%map [ " ' "  + left +  " ' " ] = function ( cm )  {%NWL%if ( cm . somethingSelected ( ) ) return surround ( cm ) ;%NWL%var cur = cm . getCursor ( ) , ahead = CodeMirror . Pos ( cur . line , cur . ch + 1 ) ;%NWL%4
cm . replaceSelection ( left + selection + right ) ;%NWL%}%NWL%function maybeOverwrite ( cm )  {%NWL%var cur = cm . getCursor ( ) , ahead = cm . getRange ( cur , CodeMirror . Pos ( cur . line , cur . ch + 1 ) ) ;%NWL%if ( ahead != right || cm . somethingSelected ( ) ) return CodeMirror . Pass;%NWL%else cm . execCommand ( " goCharRight " ) ;%NWL%}%NWL%map [ " ' "  + left +  " ' " ] = function ( cm )  {%NWL%if ( cm . somethingSelected ( ) ) return surround ( cm ) ;%NWL%if ( left == right && maybeOverwrite ( cm ) != CodeMirror . Pass ) return;%NWL%var line = cm . getLine ( cur . line ) , nextChar = line . charAt ( cur . ch ) ;%NWL%3
}%NWL%} ) ;%NWL%var htmlDontClose = [ " area " ,  " base " ,  " br " ,  " col " ,  " command " ,  " embed " ,  " hr " ,  " img " ,  " input " ,  " keygen " ,  " link " ,  " meta " ,  " param " ,%NWL%" source " ,  " track " ,  " wbr " ] ;%NWL%var htmlIndent = [ " applet " ,  " blockquote " ,  " body " ,  " button " ,  " div " ,  " dl " ,  " fieldset " ,  " form " ,  " frameset " ,  " h1 " ,  " h2 " ,  " h3 " ,  " h4 " ,%NWL%" h5 " ,  " h6 " ,  " head " ,  " html " ,  " iframe " ,  " layer " ,  " legend " ,  " object " ,  " ol " ,  " p " ,  " select " ,  " table " ,  " ul " ] ;%NWL%function autoCloseTag ( cm , ch )  {%NWL%var pos = cm . getCursor ( ) , tok = cm . getTokenAt ( pos ) ;%NWL%var inner = CodeMirror . innerMode ( cm . getMode ( ) , tok . state ) , state = inner . state;%NWL%if ( inner . mode . name != " xml " ) return CodeMirror . Pass;%NWL%var dontCloseTags = ( typeof opt == " object " && opt . dontCloseTags ) || ( html && htmlDontClose ) ;%NWL%7
} ) ;%NWL%var htmlDontClose = [ " area " ,  " base " ,  " br " ,  " col " ,  " command " ,  " embed " ,  " hr " ,  " img " ,  " input " ,  " keygen " ,  " link " ,  " meta " ,  " param " ,%NWL%" source " ,  " track " ,  " wbr " ] ;%NWL%var htmlIndent = [ " applet " ,  " blockquote " ,  " body " ,  " button " ,  " div " ,  " dl " ,  " fieldset " ,  " form " ,  " frameset " ,  " h1 " ,  " h2 " ,  " h3 " ,  " h4 " ,%NWL%" h5 " ,  " h6 " ,  " head " ,  " html " ,  " iframe " ,  " layer " ,  " legend " ,  " object " ,  " ol " ,  " p " ,  " select " ,  " table " ,  " ul " ] ;%NWL%function autoCloseTag ( cm , ch )  {%NWL%var pos = cm . getCursor ( ) , tok = cm . getTokenAt ( pos ) ;%NWL%var inner = CodeMirror . innerMode ( cm . getMode ( ) , tok . state ) , state = inner . state;%NWL%if ( inner . mode . name != " xml " ) return CodeMirror . Pass;%NWL%var opt = cm . getOption ( " autoCloseTags " ) , html = inner . mode . configuration == " html " ;%NWL%var indentTags = ( typeof opt == " object " && opt . indentTags ) || ( html && htmlIndent ) ;%NWL%6
( function ( )  {%NWL%var ie_lt8 = / MSIE \d / . test ( navigator . userAgent ) &&%NWL%( document . documentMode == null || document . documentMode < 8 ) ;%NWL%var Pos = CodeMirror . Pos;%NWL%var maxLineLen = 1000;%NWL%var matching = { " ( " : " ) > " ,  " ) " : " ( < " ,  " [ " : " ] > " ,  " ] " : " [ < " ,  " { " : " } > " ,  " } " : " { < " } ;%NWL%function findMatchingBracket ( cm )  {%NWL%var cur = cm . getCursor ( ) , line = cm . getLineHandle ( cur . line ) , pos = cur . ch - 1;%NWL%var match = ( pos >= 0 && matching [ line . text . charAt ( pos ) ] ) || matching [ line . text . charAt ( + + pos ) ] ;%NWL%var forward = match . charAt ( 1 ) == " > " , d = forward ? 1 : - 1;%NWL%7
enableRangeCollapsing ( cm ) ;%NWL%else if ( !val && wasOn )%NWL%disableRangeCollapsing ( cm ) ;%NWL%} ) ;%NWL%var gutterClass = " CodeMirror - collapserange " ;%NWL%function enableRangeCollapsing ( cm )  {%NWL%cm . on ( " gutterClick " , gutterClick ) ;%NWL%cm . setOption ( " gutters " ,  ( cm . getOption ( " gutters " ) || [ ] ) . concat ( [ gutterClass ] ) ) ;%NWL%}%NWL%function disableRangeCollapsing ( cm )  {%NWL%cm . off ( " gutterClick " , gutterClick ) ;%NWL%6
}%NWL%function startLinting ( cm )  {%NWL%var state = cm . _lintState , options = state . options;%NWL%if ( options . async )%NWL%options . getAnnotations ( cm , updateLinting , options ) ;%NWL%else%NWL%updateLinting ( cm , options . getAnnotations ( cm . getValue ( ) ) ) ;%NWL%}%NWL%%NWL%function updateLinting ( cm , annotationsNotSorted )  {%NWL%var state = cm . _lintState , options = state . options;%NWL%2
}%NWL%function onChange ( cm )  {%NWL%var state = cm . _lintState;%NWL%clearTimeout ( state . timeout ) ;%NWL%state . timeout = setTimeout ( function ( ) { startLinting ( cm ) ; } , state . options . delay || 500 ) ;%NWL%}%NWL%function popupSpanTooltip ( ann , e )  {%NWL%var tooltip = showTooltip ( e , annotationTooltip ( ann ) ) ;%NWL%var target = e . target || e . srcElement;%NWL%CodeMirror . on ( target ,  " mouseout " , hide ) ;%NWL%CodeMirror . off ( target ,  " mouseout " , hide ) ;%NWL%9
if ( old && old != CodeMirror . Init )  {%NWL%clearMarks ( cm ) ;%NWL%cm . off ( " change " , onChange ) ;%NWL%CodeMirror . off ( cm . getWrapperElement ( ) ,  " mouseover " , cm . _lintState . onMouseOver ) ;%NWL%delete cm . _lintState;%NWL%}%NWL%%NWL%if ( val )  {%NWL%var gutters = cm . getOption ( " gutters " ) , hasLintGutter = false;%NWL%for ( var i = 0; i < gutters . length; + + i ) if ( gutters [ i ] == GUTTER_ID ) hasLintGutter = true;%NWL%cm . on ( " change " , onChange ) ;%NWL%2
}%NWL%if ( found > - 1 ) stream . string = oldContent . slice ( 0 , found ) ;%NWL%var innerToken = curInner . mode . token ( stream , state . inner ) ;%NWL%if ( found > - 1 ) stream . string = oldContent;%NWL%var cur = stream . current ( ) , found = cur . indexOf ( curInner . close ) ;%NWL%if ( found > - 1 ) stream . backUp ( cur . length - found ) ;%NWL%return innerToken;%NWL%}%NWL%} ,%NWL%%NWL%var mode = state . innerActive ? state . innerActive . mode : outer;%NWL%4
if ( found > - 1 ) stream . backUp ( cur . length - found ) ;%NWL%return innerToken;%NWL%}%NWL%} ,%NWL%%NWL%indent: function ( state , textAfter )  {%NWL%var mode = state . innerActive ? state . innerActive . mode : outer;%NWL%if ( !mode . indent ) return CodeMirror . Pass;%NWL%return mode . indent ( state . innerActive ? state . inner : state . outer , textAfter ) ;%NWL%} ,%NWL%var mode = state . innerActive ? state . innerActive . mode : outer;%NWL%6
this . overlay = null;%NWL%}%NWL%CodeMirror . defineOption ( " highlightSelectionMatches " , false , function ( cm , val , old )  {%NWL%var prev = old && old != CodeMirror . Init;%NWL%if ( val && !prev )  {%NWL%cm . _matchHighlightState = new State ( val ) ;%NWL%cm . on ( " cursorActivity " , highlightMatches ) ;%NWL%} else if ( !val && prev )  {%NWL%var over = cm . _matchHighlightState . overlay;%NWL%if ( over ) cm . removeOverlay ( over ) ;%NWL%cm . off ( " cursorActivity " , highlightMatches ) ;%NWL%6
( function ( )  {%NWL%function searchOverlay ( query )  {%NWL%if ( typeof query == " string " ) return { token: function ( stream )  {%NWL%if ( stream . match ( query ) ) return " searching " ;%NWL%stream . next ( ) ;%NWL%stream . skipTo ( query . charAt ( 0 ) ) || stream . skipToEnd ( ) ;%NWL%} } ;%NWL%return { token: function ( stream )  {%NWL%if ( stream . match ( query ) ) return " searching " ;%NWL%stream . next ( ) ;%NWL%4
var queryDialog =%NWL%' Search: <input type= " text " style= " width: 10em " / > <span style= " color: #888 " > ( Use / re / syntax for regexp search ) < / span> ' ;%NWL%function doSearch ( cm , rev )  {%NWL%var state = getSearchState ( cm ) ;%NWL%if ( state . query ) return findNext ( cm , rev ) ;%NWL%dialog ( cm , queryDialog ,  " Search for: " , function ( query )  {%NWL%cm . operation ( function ( )  {%NWL%if ( !query || state . query ) return;%NWL%state . query = parseQuery ( query ) ;%NWL%cm . removeOverlay ( state . overlay ) ;%NWL%cm . addOverlay ( state . overlay ) ;%NWL%9
' Search: <input type= " text " style= " width: 10em " / > <span style= " color: #888 " > ( Use / re / syntax for regexp search ) < / span> ' ;%NWL%function doSearch ( cm , rev )  {%NWL%var state = getSearchState ( cm ) ;%NWL%if ( state . query ) return findNext ( cm , rev ) ;%NWL%dialog ( cm , queryDialog ,  " Search for: " , function ( query )  {%NWL%cm . operation ( function ( )  {%NWL%if ( !query || state . query ) return;%NWL%state . query = parseQuery ( query ) ;%NWL%cm . removeOverlay ( state . overlay ) ;%NWL%state . overlay = searchOverlay ( query ) ;%NWL%state . posFrom = state . posTo = cm . getCursor ( ) ;%NWL%7
var line = cm . getLine ( pos . line ) . slice ( 0 , pos . ch ) , cutOff = 0 , match , start;%NWL%for ( ;; )  {%NWL%query . lastIndex = cutOff;%NWL%var newMatch = query . exec ( line ) ;%NWL%if ( !newMatch ) break;%NWL%match = newMatch;%NWL%start = match . index;%NWL%cutOff = match . index + 1;%NWL%}%NWL%} else {%NWL%var line = cm . getLine ( pos . line ) , match = query . exec ( line ) ,%NWL%0
} else {%NWL%this . matches = function ( reverse , pos )  {%NWL%var line = fold ( cm . getLine ( pos . line ) ) , len = query . length , match;%NWL%if ( reverse ? ( pos . ch >= len && ( match = line . lastIndexOf ( query , pos . ch - len ) ) != - 1 )%NWL%: ( match = line . indexOf ( query , pos . ch ) ) != - 1 )%NWL%return { from: Pos ( pos . line , match ) ,%NWL%to: Pos ( pos . line , match + len ) } ;%NWL%} ;%NWL%}%NWL%} else {%NWL%var ln = pos . line , idx = ( reverse ? target . length - 1 : 0 ) , match = target [ idx ] , line = fold ( cm . getLine ( ln ) ) ;%NWL%2
( function ( )  {%NWL%" use strict " ;%NWL%var WRAP_CLASS = " CodeMirror - activeline " ;%NWL%var BACK_CLASS = " CodeMirror - activeline - background " ;%NWL%CodeMirror . defineOption ( " styleActiveLine " , false , function ( cm , val , old )  {%NWL%var prev = old && old != CodeMirror . Init;%NWL%if ( val && !prev )  {%NWL%updateActiveLine ( cm ) ;%NWL%cm . on ( " cursorActivity " , updateActiveLine ) ;%NWL%cm . off ( " cursorActivity " , updateActiveLine ) ;%NWL%8
( function ( )  {%NWL%" use strict " ;%NWL%CodeMirror . defineOption ( " styleSelectedText " , false , function ( cm , val , old )  {%NWL%var prev = old && old != CodeMirror . Init;%NWL%if ( val && !prev )  {%NWL%updateSelectedText ( cm ) ;%NWL%cm . on ( " cursorActivity " , updateSelectedText ) ;%NWL%cm . off ( " cursorActivity " , updateSelectedText ) ;%NWL%6
}%NWL%} ) ;%NWL%var htmlDontClose = [ " area " ,  " base " ,  " br " ,  " col " ,  " command " ,  " embed " ,  " hr " ,  " img " ,  " input " ,  " keygen " ,  " link " ,  " meta " ,  " param " ,%NWL%" source " ,  " track " ,  " wbr " ] ;%NWL%var htmlIndent = [ " applet " ,  " blockquote " ,  " body " ,  " button " ,  " div " ,  " dl " ,  " fieldset " ,  " form " ,  " frameset " ,  " h1 " ,  " h2 " ,  " h3 " ,  " h4 " ,%NWL%" h5 " ,  " h6 " ,  " head " ,  " html " ,  " iframe " ,  " layer " ,  " legend " ,  " object " ,  " ol " ,  " p " ,  " select " ,  " table " ,  " ul " ] ;%NWL%function autoCloseTag ( cm , ch )  {%NWL%var pos = cm . getCursor ( ) , tok = cm . getTokenAt ( pos ) ;%NWL%var inner = CodeMirror . innerMode ( cm . getMode ( ) , tok . state ) , state = inner . state;%NWL%if ( inner . mode . name != " xml " ) throw CodeMirror . Pass;%NWL%var dontCloseTags = ( typeof opt == " object " && opt . dontCloseTags ) || ( html && htmlDontClose ) ;%NWL%7
} ) ;%NWL%var htmlDontClose = [ " area " ,  " base " ,  " br " ,  " col " ,  " command " ,  " embed " ,  " hr " ,  " img " ,  " input " ,  " keygen " ,  " link " ,  " meta " ,  " param " ,%NWL%" source " ,  " track " ,  " wbr " ] ;%NWL%var htmlIndent = [ " applet " ,  " blockquote " ,  " body " ,  " button " ,  " div " ,  " dl " ,  " fieldset " ,  " form " ,  " frameset " ,  " h1 " ,  " h2 " ,  " h3 " ,  " h4 " ,%NWL%" h5 " ,  " h6 " ,  " head " ,  " html " ,  " iframe " ,  " layer " ,  " legend " ,  " object " ,  " ol " ,  " p " ,  " select " ,  " table " ,  " ul " ] ;%NWL%function autoCloseTag ( cm , ch )  {%NWL%var pos = cm . getCursor ( ) , tok = cm . getTokenAt ( pos ) ;%NWL%var inner = CodeMirror . innerMode ( cm . getMode ( ) , tok . state ) , state = inner . state;%NWL%if ( inner . mode . name != " xml " ) throw CodeMirror . Pass;%NWL%var opt = cm . getOption ( " autoCloseTags " ) , html = inner . mode . configuration == " html " ;%NWL%var indentTags = ( typeof opt == " object " && opt . indentTags ) || ( html && htmlIndent ) ;%NWL%6
CodeMirror . e_stop ( e ) ;%NWL%close ( ) ;%NWL%me . focus ( ) ;%NWL%if ( e . keyCode == 13 ) callback ( inp . value ) ;%NWL%}%NWL%} ) ;%NWL%inp . focus ( ) ;%NWL%CodeMirror . on ( inp ,  " blur " , close ) ;%NWL%} else if ( button = dialog . getElementsByTagName ( " button " ) [ 0 ] )  {%NWL%CodeMirror . on ( button ,  " click " , function ( )  {%NWL%me . focus ( ) ;%NWL%2
if ( this . addEventListener )  {%NWL%for ( var i=toBind . length; i; )  {%NWL%this . addEventListener ( toBind [ - - i ] , handler , false ) ;%NWL%}%NWL%} else {%NWL%this . onmousewheel = handler;%NWL%}%NWL%} ,%NWL%teardown: function ( )  {%NWL%if ( this . removeEventListener )  {%NWL%this . removeEventListener ( toBind [ - - i ] , handler , false ) ;%NWL%2
} else {%NWL%servicesText = ( kpi . valueCount === 1 ) ? ' service ' : ' services ' ;%NWL%linkText = kpi . valueCount + servicesText +  ' out of '  + servicesCount;%NWL%}%NWL%$moreinfo . prepend ( prefixText ) ;%NWL%$link . html ( linkText ) . appendTo ( $moreinfo ) ;%NWL%if ( servicesCount === 0 )  {%NWL%this . $el . find ( ' . '  + kpiName +  '  . visualisation - moreinfo ' ) . addClass ( ' hidden ' ) ;%NWL%}%NWL%} else {%NWL%this . $el . find ( ' . '  + kpiName +  '  . visualisation - moreinfo ' ) . addClass ( ' hidden ' ) ;%NWL%7
( function ( )  {%NWL%var matching = { " ( " : " ) > " ,  " ) " : " ( < " ,  " [ " : " ] > " ,  " ] " : " [ < " ,  " { " : " } > " ,  " } " : " { < " } ;%NWL%function findMatchingBracket ( cm )  {%NWL%var cur = cm . getCursor ( ) , line = cm . getLineHandle ( cur . line ) , pos = cur . ch - 1;%NWL%var match = ( pos >= 0 && matching [ line . text . charAt ( pos ) ] ) || matching [ line . text . charAt ( + + pos ) ] ;%NWL%var forward = match . charAt ( 1 ) == " > " , d = forward ? 1 : - 1;%NWL%3
}%NWL%if ( found > - 1 ) stream . string = oldContent . slice ( 0 , found ) ;%NWL%var innerToken = curInner . mode . token ( stream , state . inner ) ;%NWL%if ( found > - 1 ) stream . string = oldContent;%NWL%var cur = stream . current ( ) , found = cur . indexOf ( curInner . close ) ;%NWL%if ( found > - 1 ) stream . backUp ( cur . length - found ) ;%NWL%return innerToken;%NWL%}%NWL%} ,%NWL%%NWL%var mode = state . innerActive ? state . innerActive . mode : outer;%NWL%4
if ( found > - 1 ) stream . backUp ( cur . length - found ) ;%NWL%return innerToken;%NWL%}%NWL%} ,%NWL%%NWL%indent: function ( state , textAfter )  {%NWL%var mode = state . innerActive ? state . innerActive . mode : outer;%NWL%if ( !mode . indent ) return CodeMirror . Pass;%NWL%return mode . indent ( state . innerActive ? state . inner : state . outer , textAfter ) ;%NWL%} ,%NWL%var mode = state . innerActive ? state . innerActive . mode : outer;%NWL%6
var state = getSearchState ( cm ) ;%NWL%if ( state . query ) return findNext ( cm , rev ) ;%NWL%dialog ( cm , queryDialog ,  " Search for: " , function ( query )  {%NWL%cm . operation ( function ( )  {%NWL%if ( !query || state . query ) return;%NWL%state . query = parseQuery ( query ) ;%NWL%if ( cm . lineCount ( ) < 2000 )  {  / / This is too expensive on big documents .%NWL%for ( var cursor = getSearchCursor ( cm , state . query ) ; cursor . findNext ( ) ; )%NWL%state . marked . push ( cm . markText ( cursor . from ( ) , cursor . to ( ) ,%NWL%{ className: " CodeMirror - searching " } ) ) ;%NWL%state . posFrom = state . posTo = cm . getCursor ( ) ;%NWL%5
' jquerydeparam ' ,%NWL%' lodash '%NWL%] ,%NWL%function ( Modernizr , View , TableView , SummaryFigureView , ServicesKPIS , $ , _ )  {%NWL%return View . extend ( {%NWL%analyticsCategory: ' ppServices ' ,%NWL%events: _ . extend ( { } , View . prototype . events ,  {%NWL%' keyup #filter ' : function ( )  {%NWL%this . filter ( ' filter ' ) ;%NWL%} ,%NWL%this . filter ( ' filter ' ) ;%NWL%8
var target = query . split ( " \n " ) ;%NWL%if ( target . length == 1 )%NWL%this . matches = function ( reverse , pos )  {%NWL%var line = fold ( cm . getLine ( pos . line ) ) , len = query . length , match;%NWL%if ( reverse ? ( pos . ch >= len && ( match = line . lastIndexOf ( query , pos . ch - len ) ) != - 1 )%NWL%: ( match = line . indexOf ( query , pos . ch ) ) != - 1 )%NWL%return { from: { line: pos . line , ch: match } ,%NWL%to: { line: pos . line , ch: match + len } } ;%NWL%} ;%NWL%else%NWL%var ln = pos . line , idx = ( reverse ? target . length - 1 : 0 ) , match = target [ idx ] , line = fold ( cm . getLine ( ln ) ) ;%NWL%3
return " strong " ;%NWL%} else {%NWL%state . extenStart = false;%NWL%stream . skipToEnd ( ) ;%NWL%return " error " ;%NWL%}%NWL%} else if ( state . extenExten )  {%NWL%state . extenExten = false;%NWL%state . extenPriority = true;%NWL%stream . eatWhile ( / [ ^ , ] / ) ;%NWL%stream . skipToEnd ( ) ;%NWL%3
" goto while enum void const signed volatile " ;%NWL%function cppHook ( stream , state )  {%NWL%if ( !state . startOfLine ) return false;%NWL%for ( ;; )  {%NWL%if ( stream . skipTo ( " \\ " ) )  {%NWL%stream . next ( ) ;%NWL%if ( stream . eol ( ) )  {%NWL%state . tokenize = cppHook;%NWL%break;%NWL%}%NWL%stream . skipToEnd ( ) ;%NWL%5
}%NWL%var ch = stream . peek ( ) ;%NWL%if ( stream . match ( " #### " ) )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ' comment ' ;%NWL%}%NWL%if ( stream . match ( " ### " ) )  {%NWL%state . tokenize = longComment;%NWL%return state . tokenize ( stream , state ) ;%NWL%}%NWL%stream . skipToEnd ( ) ;%NWL%3
return ' property ' ;%NWL%}%NWL%stream . next ( ) ;%NWL%return ERRORCLASS;%NWL%}%NWL%function tokenFactory ( delimiter , outclass )  {%NWL%var singleline = delimiter . length == 1;%NWL%return function ( stream , state )  {%NWL%while ( !stream . eol ( ) )  {%NWL%stream . eatWhile ( / [ ^ ' " \ / \\ ] / ) ;%NWL%stream . next ( ) ;%NWL%2
break;%NWL%}%NWL%}%NWL%if ( _indent_index === - 1 )  {%NWL%return true;%NWL%}%NWL%while ( state . scopes [ 0 ] . offset !== _indent )  {%NWL%state . scopes . shift ( ) ;%NWL%}%NWL%return false;%NWL%state . scopes . shift ( ) ;%NWL%7
startState: function ( )  {%NWL%return { ctx: { prev: null , start: 0 , indentTo: 0 } , tokenize: base } ;%NWL%} ,%NWL%token: function ( stream , state )  {%NWL%if ( stream . sol ( ) && typeof state . ctx . indentTo != " number " )%NWL%state . ctx . indentTo = state . ctx . start + 1;%NWL%type = null;%NWL%var style = state . tokenize ( stream , state ) ;%NWL%if ( type != " ws " )  {%NWL%if ( state . ctx . indentTo == null )  {%NWL%state . ctx . indentTo = state . ctx . start + config . indentUnit;%NWL%5
} ,%NWL%token: function ( stream , state )  {%NWL%if ( stream . sol ( ) && typeof state . ctx . indentTo != " number " )%NWL%state . ctx . indentTo = state . ctx . start + 1;%NWL%type = null;%NWL%var style = state . tokenize ( stream , state ) ;%NWL%if ( type != " ws " )  {%NWL%if ( state . ctx . indentTo == null )  {%NWL%if ( type == " symbol " && assumeBody . test ( stream . current ( ) ) )%NWL%state . ctx . indentTo = state . ctx . start + config . indentUnit;%NWL%state . ctx . indentTo = " next " ;%NWL%3
if ( stream . sol ( ) && typeof state . ctx . indentTo != " number " )%NWL%state . ctx . indentTo = state . ctx . start + 1;%NWL%type = null;%NWL%var style = state . tokenize ( stream , state ) ;%NWL%if ( type != " ws " )  {%NWL%if ( state . ctx . indentTo == null )  {%NWL%if ( type == " symbol " && assumeBody . test ( stream . current ( ) ) )%NWL%state . ctx . indentTo = state . ctx . start + config . indentUnit;%NWL%else%NWL%state . ctx . indentTo = " next " ;%NWL%state . ctx . indentTo = stream . column ( ) ;%NWL%1
}%NWL%else if ( ch == " ! " )  {%NWL%stream . match ( / ^\s * \w * / ) ;%NWL%return ret ( " keyword " ,  " important " ) ;%NWL%}%NWL%else if ( / \d / . test ( ch ) )  {%NWL%stream . eatWhile ( / [ \w . % ] / ) ;%NWL%return ret ( " number " ,  " unit " ) ;%NWL%}%NWL%else if ( ch === " - " )  {%NWL%stream . eatWhile ( / [ \w . % ] / ) ;%NWL%6
state . stack . pop ( ) ;%NWL%state . stack [ state . stack . length - 1 ] = " @media { " ;%NWL%}%NWL%else {%NWL%var newContext = allowNested ? " block " : " rule " ;%NWL%state . stack . push ( newContext ) ;%NWL%}%NWL%}%NWL%else if ( type == " } " )  {%NWL%var lastState = state . stack [ state . stack . length - 1 ] ;%NWL%state . stack . pop ( ) ;%NWL%0
} ;%NWL%return {%NWL%token: function ( stream )  {%NWL%var tw_pos = stream . string . search ( / [ \t ] + ?$ / ) ;%NWL%if ( !stream . sol ( ) || tw_pos === 0 )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ( " error "  +  (%NWL%TOKEN_NAMES [ stream . string . charAt ( 0 ) ] || ' ' ) ) . replace ( / $ / ,  ' ' ) ;%NWL%}%NWL%var token_name = TOKEN_NAMES [ stream . peek ( ) ] || stream . skipToEnd ( ) ;%NWL%stream . skipToEnd ( ) ;%NWL%5
}%NWL%var ch = stream . next ( ) ;%NWL%if ( ch == ' % ' )  {%NWL%stream . skipToEnd ( ) ;%NWL%return rval ( state , stream , " comment " ) ;%NWL%}%NWL%if ( ch == ' ? ' )  {%NWL%stream . eatWhile ( anumRE ) ;%NWL%return rval ( state , stream , " macro " ) ;%NWL%}%NWL%stream . eatWhile ( anumRE ) ;%NWL%7
if ( doubleQuote ( stream ) )  {%NWL%return rval ( state , stream , " string " ) ;%NWL%} else {%NWL%return rval ( state , stream , " error " ) ;%NWL%}%NWL%}%NWL%if ( largeRE . test ( ch ) )  {%NWL%stream . eatWhile ( anumRE ) ;%NWL%return rval ( state , stream , " variable " ) ;%NWL%}%NWL%stream . eatWhile ( anumRE ) ;%NWL%7
return rval ( state , stream , " function " ) ;%NWL%}%NWL%}%NWL%return rval ( state , stream , " atom " ) ;%NWL%}%NWL%if ( digitRE . test ( ch ) )  {%NWL%stream . eatWhile ( digitRE ) ;%NWL%if ( stream . eat ( ' # ' ) )  {%NWL%stream . eatWhile ( digitRE ) ;   / / 16#10 style integer%NWL%} else {%NWL%stream . eatWhile ( digitRE ) ;%NWL%6
}%NWL%if ( digitRE . test ( ch ) )  {%NWL%stream . eatWhile ( digitRE ) ;%NWL%if ( stream . eat ( ' # ' ) )  {%NWL%stream . eatWhile ( digitRE ) ;   / / 16#10 style integer%NWL%} else {%NWL%if ( stream . eat ( ' . ' ) )  {     / / float%NWL%stream . eatWhile ( digitRE ) ;%NWL%}%NWL%if ( stream . eat ( / [ eE ] / ) )  {%NWL%stream . eatWhile ( digitRE ) ;%NWL%2
if ( stream . current ( ) . length == 1 && re . test ( stream . current ( ) ) )  {%NWL%while ( re . test ( stream . peek ( ) ) )  {%NWL%stream . next ( ) ;%NWL%}%NWL%while ( 0 < stream . current ( ) . length )  {%NWL%if ( isMember ( stream . current ( ) , words ) )  {%NWL%return true;%NWL%} else {%NWL%stream . backUp ( 1 ) ;%NWL%}%NWL%stream . next ( ) ;%NWL%2
if ( sorted === sortBy )  {%NWL%this . model . set ( ' sort - order ' , isDescending ? ' ascending ' : ' descending ' ) ;%NWL%} else {%NWL%this . model . set ( {%NWL%' sort - order ' : ' descending ' ,%NWL%' sort - by ' : sortBy%NWL%} ,  { silent: true } ) ;%NWL%this . sort ( ) ;%NWL%}%NWL%this . screenreaderAnnounceSortChange ( sortBy , this . model . get ( ' sort - order ' ) ) ;%NWL%this . updateUrlWithSort ( ) ;%NWL%7
} ,%NWL%render: function ( )  {%NWL%var bodyHtml;%NWL%%NWL%this . $ ( ' tbody ' ) . remove ( ) ;%NWL%bodyHtml = TableView . prototype . renderBody . apply ( this ) ;%NWL%this . $ ( ' table ' ) . append ( bodyHtml ) ;%NWL%this . updateSortHeadings ( ) ;%NWL%if ( Modernizr . touch )  {%NWL%this . $ ( ' table ' ) . addClass ( ' touch - table ' ) ;%NWL%this . adjustCellWidths ( ) ;%NWL%7
}%NWL%%NWL%if ( largeRE . test ( ch ) )  {%NWL%source . eatWhile ( idRE ) ;%NWL%if ( source . eat ( ' . ' ) )  {%NWL%return " qualifier " ;%NWL%}%NWL%return " variable - 2 " ;%NWL%}%NWL%%NWL%source . eatWhile ( idRE ) ;%NWL%3
}%NWL%}%NWL%source . eatWhile ( digitRE ) ;%NWL%var t = " number " ;%NWL%if ( source . eat ( ' . ' ) )  {%NWL%t = " number " ;%NWL%source . eatWhile ( digitRE ) ; / / should require at least 1%NWL%}%NWL%if ( source . eat ( / [ eE ] / ) )  {%NWL%t = " number " ;%NWL%source . eatWhile ( digitRE ) ; / / should require at least 1%NWL%6
}%NWL%else if ( stream . eat ( " / " ) )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " comment " ,  " comment " ) ;%NWL%}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%stream . skipToEnd ( ) ;%NWL%2
for ( var v = state . localVars; v; v = v . next )%NWL%if ( v . name == varname ) return;%NWL%state . localVars = { name: varname , next: state . localVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: null } ;%NWL%function pushcontext ( )  {%NWL%if ( !cx . state . context ) cx . state . localVars = defaultVars;%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%8
if ( v . name == varname ) return;%NWL%state . localVars = { name: varname , next: state . localVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: null } ;%NWL%function pushcontext ( )  {%NWL%if ( !cx . state . context ) cx . state . localVars = defaultVars;%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%7
var result = function ( )  {%NWL%var state = cx . state;%NWL%state . lexical = new HaxeLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
var state = cx . state;%NWL%state . lexical = new HaxeLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
%NWL%function htmlDispatch ( stream , state )  {%NWL%if ( stream . match ( scriptStartRegex , false ) )  {%NWL%state . token=scriptingDispatch;%NWL%return scriptingMode . token ( stream , state . scriptState ) ;%NWL%}%NWL%else%NWL%return htmlMixedMode . token ( stream , state . htmlState ) ;%NWL%}%NWL%function scriptingDispatch ( stream , state )  {%NWL%state . token=htmlDispatch;%NWL%3
}%NWL%}%NWL%function header ( stream )  {%NWL%if ( stream . sol ( ) && !stream . eat ( / [ \t ] / ) )  {%NWL%if ( stream . match ( / ^ . * ?: / ) )  {%NWL%return " atom " ;%NWL%} else {%NWL%stream . skipToEnd ( ) ;%NWL%return " error " ;%NWL%}%NWL%stream . skipToEnd ( ) ;%NWL%7
return " atom " ;%NWL%} else {%NWL%stream . skipToEnd ( ) ;%NWL%return " error " ;%NWL%}%NWL%} else {%NWL%stream . skipToEnd ( ) ;%NWL%return " string " ;%NWL%}%NWL%}%NWL%stream . skipToEnd ( ) ;%NWL%2
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
} else {%NWL%if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%7
if ( inList ( state . globalVars ) ) return;%NWL%state . globalVars = { name: varname , next: state . globalVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%cx . state . localVars = defaultVars;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%6
var result = function ( )  {%NWL%var state = cx . state;%NWL%state . lexical = new JSLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
var state = cx . state;%NWL%state . lexical = new JSLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info ) ;%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
return r . token;%NWL%}%NWL%}%NWL%stream . next ( ) ;%NWL%return ' error ' ;%NWL%}%NWL%if ( stream . match ( r = Rules [ next_rule ] ) )  {%NWL%if ( r . regex && stream . match ( r . regex ) )  {%NWL%state . next = r . next;%NWL%return r . token;%NWL%stream . next ( ) ;%NWL%3
}%NWL%if ( stream . match ( r = Rules [ next_rule ] ) )  {%NWL%if ( r . regex && stream . match ( r . regex ) )  {%NWL%state . next = r . next;%NWL%return r . token;%NWL%} else {%NWL%stream . next ( ) ;%NWL%return ' error ' ;%NWL%}%NWL%}%NWL%stream . next ( ) ;%NWL%6
if ( state . indentationDiff >= 4 )  {%NWL%state . indentation - = 4;%NWL%stream . skipToEnd ( ) ;%NWL%return code;%NWL%} else if ( stream . eatSpace ( ) )  {%NWL%return null;%NWL%} else if ( stream . peek ( ) === ' # ' || ( state . prevLineHasContent && stream . match ( headerRE ) )  )  {%NWL%state . header = true;%NWL%} else if ( stream . eat ( ' > ' ) )  {%NWL%state . indentation + + ;%NWL%stream . eatSpace ( ) ;%NWL%2
stream . skipToEnd ( ) ;%NWL%return code;%NWL%} else if ( stream . eatSpace ( ) )  {%NWL%return null;%NWL%} else if ( stream . peek ( ) === ' # ' || ( state . prevLineHasContent && stream . match ( headerRE ) )  )  {%NWL%state . header = true;%NWL%} else if ( stream . eat ( ' > ' ) )  {%NWL%state . indentation + + ;%NWL%state . quote = 1;%NWL%stream . eatSpace ( ) ;%NWL%stream . eatSpace ( ) ;%NWL%0
return code;%NWL%} else if ( stream . eatSpace ( ) )  {%NWL%return null;%NWL%} else if ( stream . peek ( ) === ' # ' || ( state . prevLineHasContent && stream . match ( headerRE ) )  )  {%NWL%state . header = true;%NWL%} else if ( stream . eat ( ' > ' ) )  {%NWL%state . indentation + + ;%NWL%state . quote = 1;%NWL%stream . eatSpace ( ) ;%NWL%while ( stream . eat ( ' > ' ) )  {%NWL%state . quote + + ;%NWL%6
while ( stream . eat ( ' > ' ) )  {%NWL%stream . eatSpace ( ) ;%NWL%state . quote + + ;%NWL%}%NWL%} else if ( stream . peek ( ) === ' [ ' )  {%NWL%return switchInline ( stream , state , footnoteLink ) ;%NWL%} else if ( stream . match ( hrRE , true ) )  {%NWL%return hr;%NWL%} else if ( ( !state . prevLineHasContent || prevLineIsList ) && ( stream . match ( ulRE , true ) || stream . match ( olRE , true ) ) )  {%NWL%state . indentation + = 4;%NWL%state . listDepth + + ;%NWL%2
} ;%NWL%}%NWL%function tokenComment ( stream , state )  {%NWL%for ( ;; )  {%NWL%if ( stream . skipTo ( " * " ) )  {%NWL%stream . next ( ) ;%NWL%if ( stream . eat ( " / " ) )  {%NWL%state . tokenize = tokenBase;%NWL%break;%NWL%}%NWL%stream . skipToEnd ( ) ;%NWL%5
} else {%NWL%stream . skipToEnd ( ) ;%NWL%break;%NWL%}%NWL%}%NWL%return " comment " ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%state . indent = state . context . indent;%NWL%8
stream . skipToEnd ( ) ;%NWL%break;%NWL%}%NWL%}%NWL%return " comment " ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%function popContext ( state )  {%NWL%state . context = state . context . prev;%NWL%7
transitState ( state , ch ) ;%NWL%var parsedBNode = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != '  '  )  { parsedBNode + = c; return true; } return false; } ) ;%NWL%state . bnodes . push ( parsedBNode ) ;%NWL%stream . next ( ) ;%NWL%transitState ( state ,  '  ' ) ;%NWL%return ' builtin ' ;%NWL%}%NWL%if ( ch == ' " ' )  {%NWL%transitState ( state , ch ) ;%NWL%stream . next ( ) ;%NWL%4
stream . next ( ) ;%NWL%if ( stream . peek ( ) != ' @ ' && stream . peek ( ) != ' ^ '  )  {%NWL%transitState ( state ,  ' " ' ) ;%NWL%}%NWL%return ' string ' ;%NWL%}%NWL%if ( ch == ' @ '  )  {%NWL%transitState ( state ,  ' @ ' ) ;%NWL%var parsedLang = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != '  '  )  { parsedLang + = c; return true; } return false; } ) ;%NWL%stream . next ( ) ;%NWL%0
}%NWL%if ( ch == ' @ '  )  {%NWL%transitState ( state ,  ' @ ' ) ;%NWL%var parsedLang = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != '  '  )  { parsedLang + = c; return true; } return false; } ) ;%NWL%state . langs . push ( parsedLang ) ;%NWL%stream . next ( ) ;%NWL%transitState ( state ,  '  ' ) ;%NWL%return ' string - 2 ' ;%NWL%}%NWL%stream . next ( ) ;%NWL%6
state . langs . push ( parsedLang ) ;%NWL%stream . next ( ) ;%NWL%transitState ( state ,  '  ' ) ;%NWL%return ' string - 2 ' ;%NWL%}%NWL%if ( ch == ' ^ '  )  {%NWL%stream . next ( ) ;%NWL%transitState ( state ,  ' ^ ' ) ;%NWL%var parsedType = ' ' ;%NWL%stream . eatWhile ( function ( c )  { if ( c != ' > '  )  { parsedType + = c; return true; } return false; }  ) ;%NWL%stream . next ( ) ;%NWL%1
if ( stream . eat ( ' * ' ) )  {%NWL%state . commentLevel + + ;%NWL%state . tokenize = tokenComment;%NWL%return state . tokenize ( stream , state ) ;%NWL%}%NWL%}%NWL%if ( ch === ' ~ ' )  {%NWL%stream . eatWhile ( / \w / ) ;%NWL%return ' variable - 2 ' ;%NWL%}%NWL%stream . eatWhile ( / \w / ) ;%NWL%7
if ( ch === ' ~ ' )  {%NWL%stream . eatWhile ( / \w / ) ;%NWL%return ' variable - 2 ' ;%NWL%}%NWL%if ( ch === ' ` ' )  {%NWL%stream . eatWhile ( / \w / ) ;%NWL%return ' quote ' ;%NWL%}%NWL%if ( / \d / . test ( ch ) )  {%NWL%stream . eatWhile ( / [ \d ] / ) ;%NWL%stream . eatWhile ( / [ \d ] / ) ;%NWL%9
' + + ' 				:  4 ,%NWL%' - - ' 				:  4 ,%NWL%' * * ' 				:  4 ,%NWL%' =~ ' 				:  4 ,%NWL%' !~ ' 				:  4 ,%NWL%' * ' 				:  4 ,%NWL%' / ' 				:  4 ,%NWL%' % ' 				:  4 ,%NWL%' x ' 				:  4 ,%NWL%' + ' 				:  4 ,%NWL%' . ' 				:  4 ,%NWL%3
var RXmodifiers= / [ goseximacplud ] / ;		 / / NOTE: " m " ,  " s " ,  " y " and " tr " need to correct real modifiers for each regexp type%NWL%function tokenChain ( stream , state , chain , style , tail ) { 	 / / NOTE: chain . length > 2 is not working now ( it ' s for s [ . . . ] [ . . . ] geos; )%NWL%state . chain=null;                / /                              12  3tail%NWL%state . style=null;%NWL%state . tail=null;%NWL%state . tokenize=function ( stream , state ) {%NWL%var e=false , c , i=0;%NWL%while ( c=stream . next ( ) ) {%NWL%if ( c===chain [ i ] &&!e ) {%NWL%if ( chain [ + + i ] !==undefined ) {%NWL%state . style=style;%NWL%3
state . tail=null;%NWL%state . tokenize=function ( stream , state ) {%NWL%var e=false , c , i=0;%NWL%while ( c=stream . next ( ) ) {%NWL%if ( c===chain [ i ] &&!e ) {%NWL%if ( chain [ + + i ] !==undefined ) {%NWL%state . chain=chain [ i ] ;%NWL%state . style=style;%NWL%state . tail=tail; }%NWL%else if ( tail )%NWL%state . tokenize=tokenPerl;%NWL%0
state . tail=tail; }%NWL%else if ( tail )%NWL%stream . eatWhile ( tail ) ;%NWL%state . tokenize=tokenPerl;%NWL%return style; }%NWL%e=!e&&c== " \\ " ; }%NWL%return style; } ;%NWL%return state . tokenize ( stream , state ) ; }%NWL%function tokenSOMETHING ( stream , state , string ) {%NWL%state . tokenize=function ( stream , state ) {%NWL%state . tokenize=tokenPerl;%NWL%3
if ( stream . match ( / ^ ( \ - ? ( \d * \ . \d + ( e [ + - ] ?\d + ) ?|\d + \ . \d * ) |0x [ \da - fA - F ] + |0b [ 01 ] + |\d + ( e [ + - ] ?\d + ) ? ) / ) )%NWL%return ' number ' ;%NWL%if ( stream . match ( / ^<< ( ?=\w ) / ) ) { 			 / / NOTE: <<SOMETHING\n . . . \nSOMETHING\n%NWL%stream . eatWhile ( / \w / ) ;%NWL%return tokenSOMETHING ( stream , state , stream . current ( ) . substr ( 2 ) ) ; }%NWL%if ( stream . sol ( ) &&stream . match ( / ^\=item ( ?!\w ) / ) ) { / / NOTE: \n=item . . . \n=cut\n%NWL%return tokenSOMETHING ( stream , state , ' =cut ' ) ; }%NWL%var ch=stream . next ( ) ;%NWL%if ( ch== ' " ' ||ch== " ' " ) { 				 / / NOTE: ' or " or << ' SOMETHING ' \n . . . \nSOMETHING\n or << " SOMETHING " \n . . . \nSOMETHING\n%NWL%if ( stream . prefix ( 3 ) == " << " + ch ) {%NWL%stream . eatWhile ( / \w / ) ;%NWL%3
return tokenChain ( stream , state , [ ch ] , " string " ) ; }%NWL%if ( ch== " q " ) {%NWL%var c=stream . look ( - 2 ) ;%NWL%if ( ! ( c&& / \w / . test ( c ) ) ) {%NWL%c=stream . look ( 0 ) ;%NWL%if ( c== " x " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%8
if ( ! ( c&& / \w / . test ( c ) ) ) {%NWL%c=stream . look ( 0 ) ;%NWL%if ( c== " x " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) ; } }%NWL%else if ( c== " q " ) {%NWL%c=stream . look ( 1 ) ;%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) ; } }%NWL%else if ( c== " q " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) ; } }%NWL%else if ( c== " q " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) ; }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " string " ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " string " ) ; }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " string " ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " string " ) ; } }%NWL%else if ( c== " w " ) {%NWL%c=stream . look ( 1 ) ;%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " string " ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " string " ) ; } }%NWL%else if ( c== " w " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " bracket " ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " string " ) ; } }%NWL%else if ( c== " w " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " bracket " ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " bracket " ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " bracket " ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " bracket " ) ; }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " bracket " ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " bracket " ) ; }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " bracket " ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " bracket " ) ; } }%NWL%else if ( c== " r " ) {%NWL%c=stream . look ( 1 ) ;%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , " bracket " ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " bracket " ) ; } }%NWL%else if ( c== " r " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%0
stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , " bracket " ) ; } }%NWL%else if ( c== " r " ) {%NWL%c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%5
c=stream . look ( 1 ) ;%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) ; }%NWL%stream . eatSuffix ( 2 ) ;%NWL%2
if ( c== " { " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) ; } }%NWL%else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%7
if ( c== " < " ) {%NWL%stream . eatSuffix ( 2 ) ;%NWL%return tokenChain ( stream , state , [ " > " ] , RXstyle , RXmodifiers ) ; }%NWL%if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) ; } }%NWL%else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) ; }%NWL%stream . eatSuffix ( 1 ) ;%NWL%4
if ( / [ \^ ' " !~\ / ] / . test ( c ) ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ stream . eat ( c ) ] , RXstyle , RXmodifiers ) ; } }%NWL%else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) ; }%NWL%stream . eatSuffix ( 1 ) ;%NWL%1
else if ( / [ \^ ' " !~\ / ( \ [ { < ] / . test ( c ) ) {%NWL%if ( c== " ( " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ) " ] , " string " ) ; }%NWL%if ( c== " [ " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " ] " ] , " string " ) ; }%NWL%if ( c== " { " ) {%NWL%stream . eatSuffix ( 1 ) ;%NWL%return tokenChain ( stream , state , [ " } " ] , " string " ) ; }%NWL%stream . eatSuffix ( 1 ) ;%NWL%2
CodeMirror . StringStream . prototype . nsuffix=function ( c ) {%NWL%var p=this . pos;%NWL%var l=c|| ( this . string . length - this . pos + 1 ) ;%NWL%this . pos + =l;%NWL%return this . string . substr ( p , l ) ; } ;%NWL%CodeMirror . StringStream . prototype . eatSuffix=function ( c ) {%NWL%var x=this . pos + c;%NWL%var y;%NWL%if ( x<=0 )%NWL%this . pos=0;%NWL%this . pos=y;%NWL%9
] ,%NWL%function ( require , Component )  {%NWL%%NWL%var InterleavedBar = Component . extend ( {%NWL%blockMarginFraction: 0 . 2 ,%NWL%align: ' left ' ,%NWL%offsetText: - 6 ,%NWL%classed: ' bar ' ,%NWL%x: function ( model , index )  {%NWL%var blockWidth = this . blockWidth . apply ( this , arguments ) ;%NWL%var barWidth = this . barWidth . apply ( this , arguments ) ;%NWL%9
barWidth: function ( )  {%NWL%var blockWidth = this . blockWidth . apply ( this , arguments ) ;%NWL%var allBlockMargins = this . blockMarginFraction * blockWidth;%NWL%return ( blockWidth - allBlockMargins ) ;%NWL%} ,%NWL%render: function ( )  {%NWL%Component . prototype . render . apply ( this , arguments ) ;%NWL%var selection = this . componentWrapper . selectAll ( ' g . group ' ) ;%NWL%selection . remove ( ) ;%NWL%var container = this . componentWrapper . append ( ' g ' ) . attr ( ' class ' ,  ' group ' ) ;%NWL%var segment = container . append ( ' g ' ) . attr ( ' class ' ,  ' segment ' ) ;%NWL%1
var container = this . componentWrapper . append ( ' g ' ) . attr ( ' class ' ,  ' group ' ) ;%NWL%this . collection . each ( function ( model , i )  {%NWL%var segment = container . append ( ' g ' ) . attr ( ' class ' ,  ' segment ' ) ;%NWL%this . updateSegment ( segment , model , i ) ;%NWL%} , this ) ;%NWL%} ,%NWL%getStrokeWidth: function ( selection )  {%NWL%return this . graph . pxToValue ( $ ( selection . node ( ) ) . css ( ' stroke - width ' ) ) ;%NWL%} ,%NWL%updateSegment: function ( segment , model , index )  {%NWL%var x = this . x ( model , index ) ;%NWL%2
updateSegment: function ( segment , model , index )  {%NWL%var width = this . barWidth ( ) ;%NWL%var x = this . x ( model , index ) ;%NWL%var xLeft = x;%NWL%var align = this . align;%NWL%if ( align === ' right ' )  {%NWL%xLeft - = width;%NWL%} else if ( align !== ' left ' )  {%NWL%xLeft - = width / 2;%NWL%}%NWL%var y = this . scales . y ( this . graph . getYPos ( index ) ) ;%NWL%2
var align = this . align;%NWL%if ( align === ' right ' )  {%NWL%xLeft - = width;%NWL%} else if ( align !== ' left ' )  {%NWL%xLeft - = width / 2;%NWL%}%NWL%var xRect = xLeft;%NWL%var y = this . scales . y ( this . graph . getYPos ( index ) ) ;%NWL%var yRect = y;%NWL%var yRect0 = this . scales . y ( this . y0 ( index ) ) ;%NWL%var rect = segment . append ( ' rect ' ) . attr ( ' class ' ,  ' stack ' ) ;%NWL%7
}%NWL%var segment = d3 . select ( this . componentWrapper . selectAll ( ' g . segment ' ) [ 0 ] [ indexSelected ] ) ;%NWL%segment . classed ( ' selected ' , true ) ;%NWL%} ,%NWL%%NWL%onHover: function ( e )  {%NWL%var best = {%NWL%dist: Infinity%NWL%} ;%NWL%this . collection . each ( function ( model , index )  {%NWL%var barWidth = this . barWidth ( model , index ) ;%NWL%1
else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%else if ( ch== " - " )  {%NWL%if ( stream . eat ( " - " ) ) {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " comment " ,  " comment " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%1
else if ( ch== " - " )  {%NWL%if ( stream . eat ( " - " ) ) {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " comment " ,  " comment " ) ;%NWL%}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%6
else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%else if ( ch == " - " )  {%NWL%if ( stream . eat ( " - " ) )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " comment " ,  " comment " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%1
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " ,  " operator " ) ;%NWL%}%NWL%}%NWL%else if ( ch == " @ " || ch == " $ " )  {%NWL%stream . eatWhile ( / [ \w\d\$_ ] / ) ;%NWL%return ret ( " word " ,  " variable " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
CodeMirror . defineMode ( " python " , function ( conf , parserConf )  {%NWL%var ERRORCLASS = ' error ' ;%NWL%function wordRegexp ( words )  {%NWL%return new RegExp ( " ^ ( ( "  + words . join ( " ) | ( " )  +  " ) ) \\b " ) ;%NWL%}%NWL%%NWL%var singleOperators = parserConf . singleOperators || new RegExp ( " ^ [ \\ + \\ - \\ * / %&|\\^~<>! ] " ) ;%NWL%var doubleOperators = parserConf . doubleOperators || new RegExp ( " ^ ( ( == ) | ( != ) | ( <= ) | ( >= ) | ( <> ) | ( << ) | ( >> ) | ( / / ) | ( \\ * \\ * ) ) " ) ;%NWL%6
CodeMirror . defineMode ( " python " , function ( conf , parserConf )  {%NWL%var ERRORCLASS = ' error ' ;%NWL%function wordRegexp ( words )  {%NWL%return new RegExp ( " ^ ( ( "  + words . join ( " ) | ( " )  +  " ) ) \\b " ) ;%NWL%}%NWL%%NWL%var singleOperators = parserConf . singleOperators || new RegExp ( " ^ [ \\ + \\ - \\ * / %&|\\^~<>! ] " ) ;%NWL%var singleDelimiters = parserConf . singleDelimiters || new RegExp ( ' ^ [ \\ ( \\ ) \\ [ \\ ] \\ { \\ } @ , :`=;\\ . ] ' ) ;%NWL%var doubleDelimiters = parserConf . doubleDelimiters || new RegExp ( " ^ ( ( \\ + = ) | ( \\ - = ) | ( \\ * = ) | ( %= ) | ( / = ) | ( &= ) | ( \\|= ) | ( \\^= ) ) " ) ;%NWL%6
CodeMirror . defineMode ( " python " , function ( conf , parserConf )  {%NWL%var ERRORCLASS = ' error ' ;%NWL%function wordRegexp ( words )  {%NWL%return new RegExp ( " ^ ( ( "  + words . join ( " ) | ( " )  +  " ) ) \\b " ) ;%NWL%}%NWL%%NWL%var singleOperators = parserConf . singleOperators || new RegExp ( " ^ [ \\ + \\ - \\ * / %&|\\^~<>! ] " ) ;%NWL%var singleDelimiters = parserConf . singleDelimiters || new RegExp ( ' ^ [ \\ ( \\ ) \\ [ \\ ] \\ { \\ } @ , :`=;\\ . ] ' ) ;%NWL%var doubleOperators = parserConf . doubleOperators || new RegExp ( " ^ ( ( == ) | ( != ) | ( <= ) | ( >= ) | ( <> ) | ( << ) | ( >> ) | ( / / ) | ( \\ * \\ * ) ) " ) ;%NWL%var tripleDelimiters = parserConf . tripleDelimiters || new RegExp ( " ^ ( ( / / = ) | ( >>= ) | ( <<= ) | ( \\ * \\ * = ) ) " ) ;%NWL%6
if ( stream . match ( / ^\d + \ . \d * / ) )  { floatLiteral = true; }%NWL%if ( stream . match ( / ^\ . \d + / ) )  { floatLiteral = true; }%NWL%if ( floatLiteral )  {%NWL%stream . eat ( / J / i ) ;%NWL%return ' number ' ;%NWL%}%NWL%var intLiteral = false;%NWL%if ( stream . match ( / ^0x [ 0 - 9a - f ] + / i ) )  { intLiteral = true; }%NWL%if ( stream . match ( / ^0b [ 01 ] + / i ) )  { intLiteral = true; }%NWL%if ( stream . match ( / ^0o [ 0 - 7 ] + / i ) )  { intLiteral = true; }%NWL%stream . eat ( / J / i ) ;%NWL%3
state . scopes . shift ( ) ;%NWL%}%NWL%return false;%NWL%} else {%NWL%if ( type === ' py ' )  {%NWL%state . scopes [ 0 ] . offset = stream . indentation ( ) ;%NWL%return false;%NWL%} else {%NWL%if ( state . scopes [ 0 ] . type != type )  {%NWL%return true;%NWL%state . scopes . shift ( ) ;%NWL%0
change ( state , to_normal ) ;%NWL%token = ' quote ' ;%NWL%} else if ( stream . match ( rx_citation ) )  {%NWL%change ( state , to_normal ) ;%NWL%token = ' quote ' ;%NWL%}%NWL%else {%NWL%stream . eatSpace ( ) ;%NWL%if ( stream . eol ( ) )  {%NWL%change ( state , to_normal ) ;%NWL%stream . skipToEnd ( ) ;%NWL%7
while ( stream . match ( / ^\\ [ CM ] - / ) )  { }%NWL%if ( stream . eat ( " \\ " ) ) stream . eatWhile ( / \w / ) ;%NWL%else stream . next ( ) ;%NWL%return " string " ;%NWL%} else if ( ch == " : " )  {%NWL%if ( stream . eat ( " ' " ) ) return chain ( readQuoted ( " ' " ,  " atom " , false ) , stream , state ) ;%NWL%if ( stream . eat ( ' " ' ) ) return chain ( readQuoted ( ' " ' ,  " atom " , true ) , stream , state ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " atom " ;%NWL%} else if ( ch == " @ " )  {%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%7
} else if ( ch == " : " )  {%NWL%if ( stream . eat ( " ' " ) ) return chain ( readQuoted ( " ' " ,  " atom " , false ) , stream , state ) ;%NWL%if ( stream . eat ( ' " ' ) ) return chain ( readQuoted ( ' " ' ,  " atom " , true ) , stream , state ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " atom " ;%NWL%} else if ( ch == " @ " )  {%NWL%stream . eat ( " @ " ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " variable - 2 " ;%NWL%} else if ( ch == " $ " )  {%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%3
stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " atom " ;%NWL%} else if ( ch == " @ " )  {%NWL%stream . eat ( " @ " ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " variable - 2 " ;%NWL%} else if ( ch == " $ " )  {%NWL%stream . next ( ) ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%return " variable - 3 " ;%NWL%stream . eatWhile ( / [ \w\? ] / ) ;%NWL%0
: " variable " ;%NWL%if ( indentWords . propertyIsEnumerable ( word ) ) kwtype = " indent " ;%NWL%else if ( dedentWords . propertyIsEnumerable ( word ) ) kwtype = " dedent " ;%NWL%else if ( ( word == " if " || word == " unless " ) && stream . column ( ) == stream . indentation ( ) )%NWL%kwtype = " indent " ;%NWL%}%NWL%if ( curPunc || ( style && style != " comment " ) ) state . lastTok = word || curPunc || style;%NWL%if ( curPunc == " | " ) state . varList = !state . varList;%NWL%if ( kwtype == " indent " || / [ \ ( \ [ \ { ] / . test ( curPunc ) )%NWL%state . context = { prev: state . context , type: curPunc || style , indented: state . indented } ;%NWL%state . context = state . context . prev;%NWL%9
var sol = stream . sol ( ) ;%NWL%var ch = stream . next ( ) ;%NWL%if ( ch === ' \ ' ' || ch === ' " ' || ch === ' ` ' )  {%NWL%state . tokens . unshift ( tokenString ( ch ) ) ;%NWL%return tokenize ( stream , state ) ;%NWL%}%NWL%if ( ch === ' # ' )  {%NWL%if ( sol && stream . eat ( ' ! ' ) )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ' meta ' ; / /  ' comment ' ?%NWL%stream . skipToEnd ( ) ;%NWL%8
if ( ch === ' - ' )  {%NWL%stream . eat ( ' - ' ) ;%NWL%stream . eatWhile ( / \w / ) ;%NWL%return ' attribute ' ;%NWL%}%NWL%if ( / \d / . test ( ch ) )  {%NWL%stream . eatWhile ( / \d / ) ;%NWL%if ( ! / \w / . test ( stream . peek ( ) ) )  {%NWL%return ' number ' ;%NWL%}%NWL%stream . eatWhile ( / \w / ) ;%NWL%2
}%NWL%if ( ch === " { " )  {%NWL%state . _indent . push ( " { " ) ;%NWL%return null;%NWL%}%NWL%%NWL%if ( ch == " ) " )  {%NWL%state . _indent . pop ( ) ;%NWL%state . _indent . pop ( ) ;%NWL%}%NWL%state . _indent . pop ( ) ;%NWL%7
if ( atoms . propertyIsEnumerable ( cur ) )%NWL%return " atom " ;%NWL%%NWL%return null;%NWL%}%NWL%function tokenMultiLineString ( stream , state )%NWL%{%NWL%state . _multiLineString = true;%NWL%if ( !stream . sol ( ) )  {%NWL%stream . eatSpace ( ) ;%NWL%stream . skipToEnd ( ) ;%NWL%9
return null;%NWL%}%NWL%function tokenMultiLineString ( stream , state )%NWL%{%NWL%state . _multiLineString = true;%NWL%if ( !stream . sol ( ) )  {%NWL%stream . eatSpace ( ) ;%NWL%if ( stream . peek ( ) == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return " comment " ;%NWL%stream . skipToEnd ( ) ;%NWL%6
else if ( / \d / . test ( ch ) )  {%NWL%stream . eatWhile ( / \d / ) ;%NWL%return ret ( " number " ,  " number " ) ;%NWL%}%NWL%else {%NWL%if ( state . last == " variable " )  {%NWL%if ( ch == " @ " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " property " ,  " property " ) ;%NWL%}%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%7
if ( state . last == " variable " )  {%NWL%if ( ch == " @ " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " property " ,  " property " ) ;%NWL%}%NWL%else if ( ch == " | " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " qualifier " ,  " modifier " ) ;%NWL%}%NWL%}%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%2
}%NWL%else if ( ch == " | " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " qualifier " ,  " modifier " ) ;%NWL%}%NWL%}%NWL%else if ( state . last == " whitespace " )  {%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%return ret ( " attribute " ,  " modifier " ) ;%NWL%}%NWL%stream . eatWhile ( regs . validIdentifier ) ;%NWL%2
break;%NWL%}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " string " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%state . indent = state . context . indent;%NWL%8
}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " string " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%function popContext ( state )  {%NWL%state . context = state . context . prev;%NWL%7
}%NWL%function beginParams ( source , state )  {%NWL%var ch = source . peek ( ) , lastPlug;%NWL%if ( ch == ' { ' || ch == ' [ ' )  {%NWL%lastPlug = peekCommand ( state ) ;%NWL%lastPlug . openBracket ( ch ) ;%NWL%source . eat ( ch ) ;%NWL%setState ( state , normal ) ;%NWL%return " bracket " ;%NWL%}%NWL%source . eat ( ch ) ;%NWL%6
callout: Tooltip ,%NWL%hover: Hover ,%NWL%tooltip: Tooltip%NWL%} ,%NWL%initialize: function ( options )  {%NWL%View . prototype . initialize . apply ( this , arguments ) ;%NWL%var collection = this . collection = options . collection;%NWL%this . listenTo ( collection ,  ' reset add remove sync ' , function ( )  {%NWL%this . getAxisPeriod ( ) ;%NWL%this . render ( ) ;%NWL%this . prepareGraphArea ( ) ;%NWL%8
} ;%NWL%} ,%NWL%showLineLabels: function ( )  {%NWL%return this . model && this . model . get ( ' show - line - labels ' ) ;%NWL%} ,%NWL%prepareGraphArea: function ( )  {%NWL%var figure = this . figure = $ ( ' <figure / > ' ) . addClass ( ' graph ' ) ;%NWL%if ( this . showLineLabels ( ) )  {%NWL%figure . addClass ( ' graph - with - labels ' ) ;%NWL%}%NWL%var graphWrapper = this . graphWrapper = $ ( ' <div class= " graph - wrapper " >< / div> ' ) ;%NWL%6
} ,%NWL%prepareGraphArea: function ( )  {%NWL%var figure = this . figure = $ ( ' <figure / > ' ) . addClass ( ' graph ' ) ;%NWL%if ( this . showLineLabels ( ) )  {%NWL%figure . addClass ( ' graph - with - labels ' ) ;%NWL%}%NWL%figure . appendTo ( this . $el ) ;%NWL%var graphWrapper = this . graphWrapper = $ ( ' <div class= " graph - wrapper " >< / div> ' ) ;%NWL%graphWrapper . appendTo ( figure ) ;%NWL%this . innerEl = $ ( ' <div class= " inner " >< / div> ' ) ;%NWL%var svg = this . svg = this . d3 . select ( graphWrapper [ 0 ] ) . append ( ' svg ' ) ;%NWL%2
} ,%NWL%hasData: function ( )  {%NWL%return this . collection . defined ( this . valueAttr ) . length > 0;%NWL%} ,%NWL%getPeriod: function ( )  {%NWL%return this . collection . getPeriod ( ) || ' week ' ;%NWL%} ,%NWL%getAxisPeriod: function ( )  {%NWL%var period = ( this . model && this . model . get ( ' axis - period ' ) ) || this . getPeriod ( ) ;%NWL%var periods = [ ' hour ' ,  ' day ' ,  ' week ' ,  ' month ' ,  ' quarter ' ] ;%NWL%var domain = this . scales . x . domain ( ) ;%NWL%8
%NWL%lineLabelOnTop: function ( )  {%NWL%return this . $el . find ( ' figcaption ' ) . css ( ' position ' ) === ' static ' ;%NWL%} ,%NWL%%NWL%resizeWithCalloutHidden: function ( )  {%NWL%var callout = this . $el . find ( ' . callout ' ) ;%NWL%var calloutHidden = callout . hasClass ( ' performance - hidden ' ) ;%NWL%callout . addClass ( ' performance - hidden ' ) ;%NWL%this . resize ( ) ;%NWL%callout . removeClass ( ' performance - hidden ' ) ;%NWL%8
break;%NWL%}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " string " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%state . indent = state . context . indent;%NWL%8
}%NWL%escaped = !escaped && ch == " \\ " ;%NWL%}%NWL%return " string " ;%NWL%} ;%NWL%}%NWL%function pushContext ( state , type , col )  {%NWL%state . context = { prev: state . context , indent: state . indent , col: col , type: type } ;%NWL%}%NWL%function popContext ( state )  {%NWL%state . context = state . context . prev;%NWL%7
else if ( stream . match ( / ^\d + \ . \d * F? / ) )  { floatLiteral = true; }%NWL%else if ( stream . match ( / ^\ . \d + F? / ) )  { floatLiteral = true; }%NWL%%NWL%if ( floatLiteral )  {%NWL%stream . eat ( / J / i ) ;%NWL%return ' number ' ;%NWL%}%NWL%var intLiteral = false;%NWL%if ( stream . match ( / ^&H [ 0 - 9a - f ] + / i ) )  { intLiteral = true; }%NWL%else if ( stream . match ( / ^&O [ 0 - 7 ] + / i ) )  { intLiteral = true; }%NWL%stream . eat ( / J / i ) ;%NWL%4
if ( stream . match ( " CDATA [ " ) ) return chain ( inBlock ( " atom " ,  " ] ] > " ) ) ;%NWL%else return null;%NWL%}%NWL%else if ( stream . match ( " - - " ) ) return chain ( inBlock ( " comment " ,  " - - > " ) ) ;%NWL%else if ( stream . match ( " DOCTYPE " , true , true ) )  {%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%return chain ( doctype ( 1 ) ) ;%NWL%}%NWL%else return null;%NWL%}%NWL%stream . eatWhile ( / [ \w\ . _\ - ] / ) ;%NWL%5
}%NWL%%NWL%function tokenVariable ( stream , state )  {%NWL%var isVariableChar = / [ \w\$_ - ] / ;%NWL%if ( stream . eat ( " \ " " ) )  {%NWL%while ( stream . next ( ) !== ' \ " ' ) { } ;%NWL%stream . eat ( " : " ) ;%NWL%} else {%NWL%stream . eatWhile ( isVariableChar ) ;%NWL%if ( !stream . match ( " := " , false ) ) stream . eat ( " : " ) ;%NWL%stream . eatWhile ( isVariableChar ) ;%NWL%8
return " atom " ;%NWL%}%NWL%if ( state . pair && stream . match ( / ^:\s * / ) )  { state . pairStart = true; return ' meta ' ; }%NWL%%NWL%%NWL%if ( stream . match ( / ^ ( \ { |\ } |\ [ |\ ] ) / ) )  {%NWL%if ( ch == ' { ' )%NWL%state . inlinePairs + + ;%NWL%else if ( ch == ' } ' )%NWL%state . inlinePairs - - ;%NWL%state . inlineList + + ;%NWL%7
if ( state . pair && stream . match ( / ^:\s * / ) )  { state . pairStart = true; return ' meta ' ; }%NWL%%NWL%%NWL%if ( stream . match ( / ^ ( \ { |\ } |\ [ |\ ] ) / ) )  {%NWL%if ( ch == ' { ' )%NWL%state . inlinePairs + + ;%NWL%else if ( ch == ' } ' )%NWL%state . inlinePairs - - ;%NWL%else if ( ch == ' [ ' )%NWL%state . inlineList + + ;%NWL%state . inlineList - - ;%NWL%7
%NWL%%NWL%if ( state . inlineList > 0 && !esc && ch == ' , ' )  {%NWL%stream . next ( ) ;%NWL%return ' meta ' ;%NWL%}%NWL%%NWL%if ( state . inlinePairs > 0 && !esc && ch == ' , ' )  {%NWL%state . keyCol = 0;%NWL%state . pair = false;%NWL%stream . next ( ) ;%NWL%3
stream . skipToEnd ( ) ;%NWL%return ' comment ' ;%NWL%}%NWL%else if ( stream . eat ( ' " ' ) )%NWL%{%NWL%while ( w = stream . next ( ) )%NWL%{%NWL%if ( w == ' " ' )%NWL%break;%NWL%%NWL%stream . next ( ) ;%NWL%0
return ' rgba ( '  +  ( o . R >> 0 )  +  ' , '  +  ( o . G >> 0 )  +  ' , '  +  ( o . B >> 0 )  +  ' , '  + alpha +  ' ) ' ;%NWL%} ;%NWL%root . W3_RGB = function ( o )  {%NWL%var o = o . substr ( 4 , o . length - 5 ) . split ( " , " ) ;%NWL%return {%NWL%R: parseInt ( o [ 0 ] ) ,%NWL%G: parseInt ( o [ 1 ] ) ,%NWL%B: parseInt ( o [ 2 ] )%NWL%}%NWL%} ;%NWL%var o = o . substr ( 5 , o . length - 6 ) . split ( " , " ) ;%NWL%3
return {%NWL%H: H * 360 ,%NWL%S: S * 100 ,%NWL%V: V * 100 ,%NWL%A: o . A%NWL%} ;%NWL%} ;%NWL%root . HSVA_RGBA =%NWL%root . HSV_RGB = function ( o )  {%NWL%var H = o . H / 360;%NWL%var V = o . V / 100;%NWL%9
} ;%NWL%}%NWL%d3 . time . second = function ( date )  {%NWL%return new Date ( ~~ ( date / 1e3 )  * 1e3 ) ;%NWL%} ;%NWL%d3 . time . second . utc = d3 . time . second;%NWL%d3 . time . seconds = d3_time_range ( d3 . time . second , function ( date )  {%NWL%date . setTime ( date . getTime ( )  + 1e3 ) ;%NWL%} , function ( date )  {%NWL%return date . getSeconds ( ) ;%NWL%d3 . time . seconds . utc = d3 . time . seconds;%NWL%5
var path = require ( ' path ' ) ;%NWL%var paperboy = require ( ' paperboy ' ) ;%NWL%0
" correct initial run " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%assert . strictEqual ( t . b . value ( ) , 21 ) ;%NWL%} ,%NWL%" correct next run " : function ( t )  {%NWL%t . a . value ( 4 )%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%assert . strictEqual ( t . b . value ( ) , 28 ) ;%NWL%} ,%NWL%" correct invalid " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%6
t . a . value ( 4 )%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%assert . strictEqual ( t . b . value ( ) , 28 ) ;%NWL%} ,%NWL%" correct invalid " : function ( t )  {%NWL%t . a . value ( null )%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%assert . strictEqual ( t . b . value ( ) , 10 ) ;%NWL%} ,%NWL%" correct on invalid change " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%1
} ,%NWL%" knows constants " : function ( )  {%NWL%var c = dvl . const ( 4 ) ;%NWL%assert . strictEqual ( dvl . knows ( c ) , true ) ;%NWL%} ,%NWL%" doesn ' t know regulars " : function ( )  {%NWL%var c = ' poo ' ;%NWL%assert . strictEqual ( dvl . knows ( c ) , false ) ;%NWL%} ,%NWL%" doesn ' t know nulls " : function ( )  {%NWL%assert . strictEqual ( dvl . knows ( c ) , false ) ;%NWL%7
} ,%NWL%" doesn ' t know regulars " : function ( )  {%NWL%var c = ' poo ' ;%NWL%assert . strictEqual ( dvl . knows ( c ) , false ) ;%NWL%} ,%NWL%" doesn ' t know nulls " : function ( )  {%NWL%var c = null;%NWL%assert . strictEqual ( dvl . knows ( c ) , false ) ;%NWL%} ,%NWL%" doesn ' t know unedefined " : function ( )  {%NWL%assert . strictEqual ( dvl . knows ( c ) , false ) ;%NWL%3
} ) ;%NWL%return t;%NWL%} ,%NWL%" correct initial run " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%} ,%NWL%" correct next run " : function ( t )  {%NWL%t . a . value ( 4 ) ;%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%} ,%NWL%t . a . value ( 4 ) ;%NWL%7
return t;%NWL%} ,%NWL%" correct initial run " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%} ,%NWL%" correct next run " : function ( t )  {%NWL%t . a . value ( 4 ) ;%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%} ,%NWL%" correct next run / same value " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 2 ) ;%NWL%7
a: dvl . const ( 3 )%NWL%}%NWL%dvl . register ( {%NWL%listen: [ t . a ] ,%NWL%fn: function ( )  { t . runs + + ; }%NWL%} ) ;%NWL%return t;%NWL%} ,%NWL%" always unchaged " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%9
dvl . register ( {%NWL%listen: [ t . a ] ,%NWL%fn: function ( )  { t . runs + + ; }%NWL%} ) ;%NWL%return t;%NWL%} ,%NWL%" always unchaged " : function ( t )  {%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%t . a . value ( 4 ) ;%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%assert . strictEqual ( t . runs , 1 ) ;%NWL%7
status: ' '%NWL%}%NWL%t . f = dvl . register ( { listen: t . a , fn: function ( )  { t . status + = ' A '  }  } ) ;%NWL%return t;%NWL%} ,%NWL%" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct pre add a change " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%6
} ,%NWL%" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct pre add a change " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . a . notify ( )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct pre add b change " : function ( t )  {%NWL%t . b . notify ( )%NWL%6
t . a . notify ( )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct pre add b change " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . b . notify ( )%NWL%assert . strictEqual ( t . status ,  ' ' ) ;%NWL%} ,%NWL%" correct add b " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%1
t . status = ' ' ;%NWL%t . b . notify ( )%NWL%assert . strictEqual ( t . status ,  ' ' ) ;%NWL%} ,%NWL%" correct add b " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . f . addListen ( t . b )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct post add a change " : function ( t )  {%NWL%t . a . notify ( )%NWL%1
t . b . notify ( )%NWL%assert . strictEqual ( t . status ,  ' ' ) ;%NWL%} ,%NWL%" correct add b " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . f . addListen ( t . b )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct post add a change " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%6
t . status = ' ' ;%NWL%t . f . addListen ( t . b )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct post add a change " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . a . notify ( )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct post add b change " : function ( t )  {%NWL%t . b . notify ( )%NWL%6
t . f . addListen ( t . b )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct post add a change " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . a . notify ( )%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct post add b change " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%1
listen: t . a ,%NWL%fn: function ( )  { t . status + = ' A ' ; }%NWL%} ) ;%NWL%return t;%NWL%} ,%NWL%" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct pre remove " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%6
" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct pre remove " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . a . notify ( ) ;%NWL%assert . strictEqual ( t . status ,  ' A ' ) ;%NWL%} ,%NWL%" correct post remove " : function ( t )  {%NWL%t . status = ' ' ;%NWL%t . a . notify ( ) ;%NWL%5
dvl . register ( { listen: t . a , fn: function ( )  { t . status + = ' A '  }  } ) ;%NWL%dvl . register ( { listen: t . a , fn: function ( )  { t . status + = ' B '  }  } ) ;%NWL%dvl . register ( { listen: t . a , fn: function ( )  { t . status + = ' C '  }  } ) ;%NWL%return t;%NWL%} ,%NWL%" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' ABC ' ) ;%NWL%} ,%NWL%" correct next run " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' ABC ' ) ;%NWL%6
dvl . register ( { listen: t . a , fn: function ( )  { t . status + = ' A '  }  } ) ;%NWL%dvl . register ( { listen: t . b , fn: function ( )  { t . status + = ' B '  }  } ) ;%NWL%dvl . register ( { listen: t . a , fn: function ( )  { t . status + = ' C '  }  } ) ;%NWL%return t;%NWL%} ,%NWL%" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' ABC ' ) ;%NWL%} ,%NWL%" correct next run " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' ABC ' ) ;%NWL%6
listen: [ t . a , t . b ] ,%NWL%fn: function ( )  { t . status + = ' B '  }%NWL%} ) ;%NWL%return t;%NWL%} ,%NWL%" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' AB ' ) ;%NWL%} ,%NWL%" correct next run " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' AB ' ) ;%NWL%6
dvl . register ( { listen: [ t . b ] , fn: function ( )  { t . status + = ' A '  }  } ) ;%NWL%dvl . register ( { listen: [ t . a ] , fn: function ( )  { t . status + = ' B '  }  } ) ;%NWL%dvl . register ( { listen: [ t . b ] , fn: function ( )  { t . status + = ' C '  }  } ) ;%NWL%return t;%NWL%} ,%NWL%" correct init run " : function ( t )  {%NWL%assert . strictEqual ( t . status ,  ' &ABC ' ) ;%NWL%} ,%NWL%" correct next run " : function ( t )  {%NWL%t . status = ' ' ;%NWL%assert . strictEqual ( t . status ,  ' &ABC ' ) ;%NWL%6
var vows = require ( " vows " ) ,%NWL%assert = require ( " assert " ) ;%NWL%var suite = vows . describe ( " dvl . def " ) ;%NWL%suite . addBatch ( {%NWL%" constants " : {%NWL%" returns the correct init value on nothing " : function ( )  {%NWL%var v = dvl . const ( ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct init value on undefined " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%7
" constants " : {%NWL%" returns the correct init value on nothing " : function ( )  {%NWL%var v = dvl . const ( ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct init value on undefined " : function ( )  {%NWL%var v = dvl . const ( undefined ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct init value on null " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%3
} ,%NWL%" returns the correct init value " : function ( )  {%NWL%var v = dvl . const ( 5 ) ;%NWL%assert . strictEqual ( v . value ( ) , 5 ) ;%NWL%} ,%NWL%" returns the correct set value on undefined " : function ( )  {%NWL%var v = dvl . const ( 3 ) . value ( undefined ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%} ,%NWL%" returns the correct set value on null " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%7
} ,%NWL%" returns the correct set value on undefined " : function ( )  {%NWL%var v = dvl . const ( 3 ) . value ( undefined ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%} ,%NWL%" returns the correct set value on null " : function ( )  {%NWL%var v = dvl . const ( 3 ) . value ( null ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%} ,%NWL%" returns the correct set value " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%3
} ,%NWL%" returns the correct set value on null " : function ( )  {%NWL%var v = dvl . const ( 3 ) . value ( null ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%} ,%NWL%" returns the correct set value " : function ( )  {%NWL%var v = dvl . const ( 3 ) . value ( 5 ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%} ,%NWL%" returns the correct set value on NaN " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%3
" returns the correct set value " : function ( )  {%NWL%var v = dvl . const ( 3 ) . value ( 5 ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%} ,%NWL%" returns the correct set value on NaN " : function ( )  {%NWL%var v = dvl . const ( 3 ) . value ( NaN ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%} ,%NWL%" set to nothing does nothing " : function ( )  {%NWL%var v = dvl . const ( 3 ) ;%NWL%assert . strictEqual ( v . value ( ) , 3 ) ;%NWL%2
} ,%NWL%}%NWL%} ) ;%NWL%suite . addBatch ( {%NWL%" variables " : {%NWL%" returns the correct init value on nothing " : function ( )  {%NWL%var v = dvl . def ( ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct init value on undefined " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%7
" variables " : {%NWL%" returns the correct init value on nothing " : function ( )  {%NWL%var v = dvl . def ( ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct init value on undefined " : function ( )  {%NWL%var v = dvl . def ( undefined ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct init value on null " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%3
} ,%NWL%" returns the correct init value on null " : function ( )  {%NWL%var v = dvl . def ( null ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct init value " : function ( )  {%NWL%var v = dvl . def ( 5 ) ;%NWL%assert . strictEqual ( v . value ( ) , 5 ) ;%NWL%} ,%NWL%" returns the correct set value on undefined " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%3
} ,%NWL%" returns the correct init value " : function ( )  {%NWL%var v = dvl . def ( 5 ) ;%NWL%assert . strictEqual ( v . value ( ) , 5 ) ;%NWL%} ,%NWL%" returns the correct set value on undefined " : function ( )  {%NWL%var v = dvl . def ( ) . value ( undefined ) ;%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%} ,%NWL%" returns the correct set value on null " : function ( )  {%NWL%assert . strictEqual ( v . value ( ) , null ) ;%NWL%7
this . componentWrapper . selectAll ( ' g . group ' ) . remove ( ) ;%NWL%this . renderLine ( ) ;%NWL%this . renderTerminators ( ) ;%NWL%} ,%NWL%renderLine: function ( getY )  {%NWL%var getX = _ . bind ( function ( model , index )  { return this . x ( index ) ; } , this ) ;%NWL%getY = getY || _ . bind ( function ( model , index )  { return this . y ( index ) ; } , this ) ;%NWL%var line = d3 . svg . line ( )%NWL%. x ( getX )%NWL%. y ( getY )%NWL%var group = this . componentWrapper . append ( ' g ' ) . attr ( ' class ' ,  ' group ' ) ;%NWL%7
this . renderLine ( ) ;%NWL%this . renderTerminators ( ) ;%NWL%} ,%NWL%renderLine: function ( getY )  {%NWL%var getX = _ . bind ( function ( model , index )  { return this . x ( index ) ; } , this ) ;%NWL%getY = getY || _ . bind ( function ( model , index )  { return this . y ( index ) ; } , this ) ;%NWL%var line = d3 . svg . line ( )%NWL%. x ( getX )%NWL%. y ( getY )%NWL%. defined ( function ( model , index )  { return getY ( model , index ) !== null; } ) ;%NWL%var path = group . append ( ' path ' ) . attr ( ' class ' ,  ' line '  + this . className ) ;%NWL%6
} , this ) ;%NWL%} ,%NWL%onChangeSelected: function ( model , index , options )  {%NWL%options = options || { } ;%NWL%if ( model )  {%NWL%if ( options . valueAttr && this . valueAttr !== options . valueAttr )  {%NWL%this . deselect ( ) ;%NWL%} else {%NWL%this . select ( index ) ;%NWL%}%NWL%this . unselect ( ) ;%NWL%6
if ( options . valueAttr && this . valueAttr !== options . valueAttr )  {%NWL%this . deselect ( ) ;%NWL%} else {%NWL%this . select ( index ) ;%NWL%}%NWL%} else {%NWL%this . unselect ( ) ;%NWL%}%NWL%} ,%NWL%select: function ( index )  {%NWL%this . moveToFront ( ) ;%NWL%1
this . deselect ( ) ;%NWL%} else {%NWL%this . select ( index ) ;%NWL%}%NWL%} else {%NWL%this . unselect ( ) ;%NWL%}%NWL%} ,%NWL%select: function ( index )  {%NWL%if ( this . y ( index ) !== null )  {%NWL%this . renderCursorLine ( index ) ;%NWL%2
} else {%NWL%this . select ( index ) ;%NWL%}%NWL%} else {%NWL%this . unselect ( ) ;%NWL%}%NWL%} ,%NWL%select: function ( index )  {%NWL%if ( this . y ( index ) !== null )  {%NWL%this . moveToFront ( ) ;%NWL%this . renderSelectionPoint ( index ) ;%NWL%1
this . unselect ( ) ;%NWL%}%NWL%} ,%NWL%select: function ( index )  {%NWL%if ( this . y ( index ) !== null )  {%NWL%this . moveToFront ( ) ;%NWL%this . renderCursorLine ( index ) ;%NWL%this . renderSelectionPoint ( index ) ;%NWL%this . componentWrapper . selectAll ( ' path . line ' ) . classed ( ' selected ' , true ) . classed ( ' not - selected ' , false ) ;%NWL%this . componentWrapper . selectAll ( ' circle . terminator ' ) . classed ( ' selected ' , true ) . classed ( ' not - selected ' , false ) ;%NWL%this . unselect ( ) ;%NWL%0
}%NWL%} ,%NWL%select: function ( index )  {%NWL%if ( this . y ( index ) !== null )  {%NWL%this . moveToFront ( ) ;%NWL%this . renderCursorLine ( index ) ;%NWL%this . renderSelectionPoint ( index ) ;%NWL%this . componentWrapper . selectAll ( ' path . line ' ) . classed ( ' selected ' , true ) . classed ( ' not - selected ' , false ) ;%NWL%this . componentWrapper . selectAll ( ' circle . terminator ' ) . classed ( ' selected ' , true ) . classed ( ' not - selected ' , false ) ;%NWL%} else {%NWL%this . renderCursorLine ( index ) ;%NWL%5
this . unselect ( ) ;%NWL%this . renderCursorLine ( index ) ;%NWL%}%NWL%} ,%NWL%deselect: function ( )  {%NWL%this . componentWrapper . selectAll ( ' . selectedIndicator ' ) . remove ( ) ;%NWL%this . componentWrapper . selectAll ( ' path . line ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , true ) ;%NWL%this . componentWrapper . selectAll ( ' circle . terminator ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , true ) ;%NWL%this . componentWrapper . selectAll ( ' line . cursorLine ' ) . remove ( ) ;%NWL%} ,%NWL%this . componentWrapper . selectAll ( ' . selectedIndicator ' ) . remove ( ) ;%NWL%5
} ,%NWL%deselect: function ( )  {%NWL%this . componentWrapper . selectAll ( ' . selectedIndicator ' ) . remove ( ) ;%NWL%this . componentWrapper . selectAll ( ' path . line ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , true ) ;%NWL%this . componentWrapper . selectAll ( ' circle . terminator ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , true ) ;%NWL%this . componentWrapper . selectAll ( ' line . cursorLine ' ) . remove ( ) ;%NWL%} ,%NWL%unselect: function ( )  {%NWL%this . componentWrapper . selectAll ( ' . selectedIndicator ' ) . remove ( ) ;%NWL%this . componentWrapper . selectAll ( ' path . line ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , false ) ;%NWL%this . componentWrapper . selectAll ( ' line . cursorLine ' ) . remove ( ) ;%NWL%5
this . componentWrapper . selectAll ( ' line . cursorLine ' ) . remove ( ) ;%NWL%} ,%NWL%unselect: function ( )  {%NWL%this . componentWrapper . selectAll ( ' . selectedIndicator ' ) . remove ( ) ;%NWL%this . componentWrapper . selectAll ( ' path . line ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , false ) ;%NWL%this . componentWrapper . selectAll ( ' circle . terminator ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , false ) ;%NWL%this . componentWrapper . selectAll ( ' line . cursorLine ' ) . remove ( ) ;%NWL%} ,%NWL%renderSelectionPoint: function ( index )  {%NWL%var x = this . x ( index ) ;%NWL%this . componentWrapper . selectAll ( ' . selectedIndicator ' ) . remove ( ) ;%NWL%3
var index;%NWL%this . collection . each ( function ( model , i )  {%NWL%var x = this . x ( i ) ;%NWL%if ( Math . abs ( x - e . x ) < diff )  {%NWL%diff = Math . abs ( x - e . x ) ;%NWL%index = i;%NWL%}%NWL%} , this ) ;%NWL%this . collection . selectItem ( index ) ;%NWL%} ,%NWL%var x = this . x ( index ) ;%NWL%2
uiHash . values = this . values ( ) ;%NWL%}%NWL%this . _trigger (  " stop " , event , uiHash ) ;%NWL%} ,%NWL%_change: function ( event , index )  {%NWL%if ( !this . _keySliding && !this . _mouseSliding )  {%NWL%var uiHash = {%NWL%handle: this . handles [ index ] ,%NWL%value: this . value ( )%NWL%} ;%NWL%uiHash . value = this . values ( index ) ;%NWL%0
this . element . addClass (  " ui - disabled "  ) ;%NWL%} else {%NWL%this . handles . propAttr (  " disabled " , false ) ;%NWL%this . element . removeClass (  " ui - disabled "  ) ;%NWL%}%NWL%break;%NWL%case " orientation " :%NWL%this . _detectOrientation ( ) ;%NWL%this . element%NWL%. removeClass (  " ui - slider - horizontal ui - slider - vertical "  )%NWL%this . _refreshValue ( ) ;%NWL%7
}%NWL%break;%NWL%case " orientation " :%NWL%this . _detectOrientation ( ) ;%NWL%this . element%NWL%. removeClass (  " ui - slider - horizontal ui - slider - vertical "  )%NWL%. addClass (  " ui - slider - "  + this . orientation ) ;%NWL%this . _refreshValue ( ) ;%NWL%break;%NWL%case " value " :%NWL%this . _refreshValue ( ) ;%NWL%3
. addClass (  " ui - slider - "  + this . orientation ) ;%NWL%this . _refreshValue ( ) ;%NWL%break;%NWL%case " value " :%NWL%this . _animateOff = true;%NWL%this . _refreshValue ( ) ;%NWL%this . _change ( null , 0 ) ;%NWL%this . _animateOff = false;%NWL%break;%NWL%case " values " :%NWL%this . _refreshValue ( ) ;%NWL%1
this . element = $ ( element ) ;%NWL%this . options = $ . extend ( true ,  { } ,%NWL%this . options ,%NWL%this . _getCreateOptions ( ) ,%NWL%options ) ;%NWL%var self = this;%NWL%this . element . bind (  " remove . "  + this . widgetName , function ( )  {%NWL%self . destroy ( ) ;%NWL%} ) ;%NWL%this . _create ( ) ;%NWL%this . _init ( ) ;%NWL%9
disable: function ( )  {%NWL%return this . _setOption (  " disabled " , true ) ;%NWL%} ,%NWL%_trigger: function ( type , event , data )  {%NWL%var prop , orig ,%NWL%callback = this . options [ type ] ;%NWL%data = data || { } ;%NWL%event = $ . Event ( event ) ;%NWL%event . type = ( type === this . widgetEventPrefix ?%NWL%type :%NWL%event . target = this . element [ 0 ] ;%NWL%8
var left = this . graph . innerWidth + this . offset;%NWL%this . componentWrapper%NWL%. classed ( this . classed , true )%NWL%. attr ( ' transform ' ,  ' translate ( '  + left +  ' , 0 ) ' ) ;%NWL%var wrapper = this . d3 . select ( this . $el [ 0 ] ) ;%NWL%this . figcaption = wrapper . selectAll ( ' figcaption ' ) . data ( [ ' one - figcaption ' ] ) ;%NWL%this . figcaption . enter ( ) . insert ( ' figcaption ' ,  ' . graph - wrapper ' ) . attr ( ' class ' ,  ' legend ' ) ;%NWL%this . figcaption . attr ( ' role ' ,  ' presentation ' ) ;%NWL%this . figcaption . attr ( ' aria - hidden ' ,  ' true ' ) ;%NWL%this . renderSummary ( ) ;%NWL%this . renderLines ( ) ;%NWL%9
var wrapper = this . d3 . select ( this . $el [ 0 ] ) ;%NWL%this . figcaption = wrapper . selectAll ( ' figcaption ' ) . data ( [ ' one - figcaption ' ] ) ;%NWL%this . figcaption . enter ( ) . insert ( ' figcaption ' ,  ' . graph - wrapper ' ) . attr ( ' class ' ,  ' legend ' ) ;%NWL%this . figcaption . attr ( ' role ' ,  ' presentation ' ) ;%NWL%this . figcaption . attr ( ' aria - hidden ' ,  ' true ' ) ;%NWL%this . renderSummary ( ) ;%NWL%this . renderLabels ( ) ;%NWL%this . renderLines ( ) ;%NWL%if ( !this . rendered )  {%NWL%this . rendered = true;%NWL%this . render ( ) ;%NWL%5
summary = ' ' ;%NWL%if ( value === null && !percentage )  {%NWL%return ' <span class= " no - data " > ( no data ) < / span> ' ;%NWL%}%NWL%if ( value !== null )  {%NWL%data . push ( this . format ( value , this . getFormatOptions ( ) ) ) ;%NWL%}%NWL%if ( percentage )  {%NWL%if ( this . graph . isOneHundredPercent ( ) )  {%NWL%data . unshift ( this . format ( percentage ,  ' percent ' ) ) ;%NWL%data . push ( this . format ( percentage ,  ' percent ' ) ) ;%NWL%9
} ) ;%NWL%}%NWL%var curMax = 0 , sumSquareDist = 0;%NWL%var bestSolution = _ . map ( items , function ( item , index )  {%NWL%item = _ . extend ( { } , item ) ;%NWL%item . index = index;%NWL%item . min = Math . max ( curMax , item . ideal ) ;%NWL%if ( _ . isNumber ( item . absoluteLowestMin ) )  {%NWL%item . min = Math . max ( item . min , item . absoluteLowestMin ) ;%NWL%}%NWL%item . min = Math . min ( item . min , item . absoluteHighestMin ) ;%NWL%8
var bestSolution = _ . map ( items , function ( item , index )  {%NWL%item = _ . extend ( { } , item ) ;%NWL%item . index = index;%NWL%item . min = Math . max ( curMax , item . ideal ) ;%NWL%if ( _ . isNumber ( item . absoluteLowestMin ) )  {%NWL%item . min = Math . max ( item . min , item . absoluteLowestMin ) ;%NWL%}%NWL%if ( _ . isNumber ( item . absoluteHighestMin ) )  {%NWL%item . min = Math . min ( item . min , item . absoluteHighestMin ) ;%NWL%}%NWL%item . dist = item . min - item . ideal;%NWL%5
item = _ . extend ( { } , item ) ;%NWL%item . index = index;%NWL%item . min = Math . max ( curMax , item . ideal ) ;%NWL%if ( _ . isNumber ( item . absoluteLowestMin ) )  {%NWL%item . min = Math . max ( item . min , item . absoluteLowestMin ) ;%NWL%}%NWL%if ( _ . isNumber ( item . absoluteHighestMin ) )  {%NWL%item . min = Math . min ( item . min , item . absoluteHighestMin ) ;%NWL%}%NWL%curMax = item . max = item . min + item . size;%NWL%item . squareDist = Math . pow ( item . dist , 2 ) ;%NWL%4
} ) ;%NWL%bestSolution . sumSquareDist = sumSquareDist;%NWL%var calcSolution = function ( items , indexToOptimise )  {%NWL%var solution = [ ] ;%NWL%var anchor = _ . extend ( { } , items [ indexToOptimise ] ) ;%NWL%var targetDist = anchor . dist * 0 . 9;%NWL%anchor . min = anchor . ideal + targetDist;%NWL%if ( _ . isNumber ( anchor . absoluteLowestMin ) )  {%NWL%anchor . min = Math . max ( anchor . min , anchor . absoluteLowestMin ) ;%NWL%}%NWL%anchor . min = Math . min ( anchor . min , anchor . absoluteHighestMin ) ;%NWL%8
var calcSolution = function ( items , indexToOptimise )  {%NWL%var solution = [ ] ;%NWL%var anchor = _ . extend ( { } , items [ indexToOptimise ] ) ;%NWL%var targetDist = anchor . dist * 0 . 9;%NWL%anchor . min = anchor . ideal + targetDist;%NWL%if ( _ . isNumber ( anchor . absoluteLowestMin ) )  {%NWL%anchor . min = Math . max ( anchor . min , anchor . absoluteLowestMin ) ;%NWL%}%NWL%if ( _ . isNumber ( anchor . absoluteHighestMin ) )  {%NWL%anchor . min = Math . min ( anchor . min , anchor . absoluteHighestMin ) ;%NWL%anchor . dist = anchor . min - anchor . ideal;%NWL%6
var targetDist = anchor . dist * 0 . 9;%NWL%anchor . min = anchor . ideal + targetDist;%NWL%if ( _ . isNumber ( anchor . absoluteLowestMin ) )  {%NWL%anchor . min = Math . max ( anchor . min , anchor . absoluteLowestMin ) ;%NWL%}%NWL%if ( _ . isNumber ( anchor . absoluteHighestMin ) )  {%NWL%anchor . min = Math . min ( anchor . min , anchor . absoluteHighestMin ) ;%NWL%}%NWL%anchor . dist = anchor . min - anchor . ideal;%NWL%var curMin = anchor . min;%NWL%anchor . squareDist = Math . pow ( anchor . dist , 2 ) ;%NWL%3
anchor . dist = anchor . min - anchor . ideal;%NWL%var curMin = anchor . min;%NWL%var curMax = anchor . max = anchor . min + anchor . size;%NWL%anchor . squareDist = Math . pow ( anchor . dist , 2 ) ;%NWL%var sumSquareDist = anchor . squareDist;%NWL%solution [ anchor . index ] = anchor;%NWL%var item;%NWL%for ( var i = indexToOptimise - 1; i >= 0; i - - )  {%NWL%item = _ . extend ( { } , items [ i ] ) ;%NWL%item . max = Math . min ( item . max , curMin ) ;%NWL%item . dist = item . min - item . ideal;%NWL%9
var curMin = anchor . min;%NWL%var curMax = anchor . max = anchor . min + anchor . size;%NWL%anchor . squareDist = Math . pow ( anchor . dist , 2 ) ;%NWL%var sumSquareDist = anchor . squareDist;%NWL%solution [ anchor . index ] = anchor;%NWL%var item;%NWL%for ( var i = indexToOptimise - 1; i >= 0; i - - )  {%NWL%item = _ . extend ( { } , items [ i ] ) ;%NWL%item . max = Math . min ( item . max , curMin ) ;%NWL%curMin = item . min = item . max - item . size;%NWL%item . squareDist = Math . pow ( item . dist , 2 ) ;%NWL%8
for ( var i = indexToOptimise - 1; i >= 0; i - - )  {%NWL%item = _ . extend ( { } , items [ i ] ) ;%NWL%item . max = Math . min ( item . max , curMin ) ;%NWL%curMin = item . min = item . max - item . size;%NWL%item . dist = item . min - item . ideal;%NWL%item . squareDist = Math . pow ( item . dist , 2 ) ;%NWL%sumSquareDist + = item . squareDist;%NWL%solution [ i ] = item;%NWL%}%NWL%for ( i = indexToOptimise + 1; i < items . length; i + + )  {%NWL%item . min = Math . max ( item . min , curMax ) ;%NWL%2
item . max = Math . min ( item . max , curMin ) ;%NWL%curMin = item . min = item . max - item . size;%NWL%item . dist = item . min - item . ideal;%NWL%item . squareDist = Math . pow ( item . dist , 2 ) ;%NWL%sumSquareDist + = item . squareDist;%NWL%solution [ i ] = item;%NWL%}%NWL%for ( i = indexToOptimise + 1; i < items . length; i + + )  {%NWL%item = _ . extend ( { } , items [ i ] ) ;%NWL%item . min = Math . max ( item . min , curMax ) ;%NWL%item . dist = item . min - item . ideal;%NWL%0
curMin = item . min = item . max - item . size;%NWL%item . dist = item . min - item . ideal;%NWL%item . squareDist = Math . pow ( item . dist , 2 ) ;%NWL%sumSquareDist + = item . squareDist;%NWL%solution [ i ] = item;%NWL%}%NWL%for ( i = indexToOptimise + 1; i < items . length; i + + )  {%NWL%item = _ . extend ( { } , items [ i ] ) ;%NWL%item . min = Math . max ( item . min , curMax ) ;%NWL%curMax = item . max = item . min + item . size;%NWL%item . squareDist = Math . pow ( item . dist , 2 ) ;%NWL%8
. on ( " click " , function ( d )  {%NWL%var dis = d3 . select ( this ) ;%NWL%if ( dis . classed ( " active " )  )  {%NWL%console . log ( " AJAX Caching disabled " ) ;%NWL%tributary . __config__ . set ( " ajax - caching " , false )%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%dis . classed ( " active " , false )%NWL%}%NWL%else {%NWL%console . log ( " AJAX Caching initiated " ) ;%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%5
var dis = d3 . select ( this ) ;%NWL%if ( dis . classed ( " active " )  )  {%NWL%console . log ( " Inline logging disabled " ) ;%NWL%tributary . __config__ . set ( " inline - console " , false )%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%dis . classed ( " active " , false )%NWL%clearWidgets ( ) ;%NWL%}%NWL%else {%NWL%console . log ( " Inline logging initiated " ) ;%NWL%tributary . __events__ . trigger ( " execute " ) ;%NWL%4
} else {%NWL%tc . select ( " button . play " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%}%NWL%function timeSlider ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%var tc = d3 . select ( el ) . select ( " . time_controls " ) ;%NWL%if ( tributary . loop )  {%NWL%var ts = tc . select ( " input . time_slider " ) ;%NWL%ts . style ( " display " ,  " " )%NWL%tributary . t = parseFloat ( this . value ) ; / / $ ( ' #slider ' ) . attr ( ' value ' ) ;%NWL%5
}%NWL%}%NWL%function onRestart ( )  {%NWL%tributary . clear ( ) ;%NWL%try {%NWL%if ( tributary . initialize )  {%NWL%tributary . initialize ( tributary . g , tributary ) ;%NWL%}%NWL%if ( tributary . init )  {%NWL%tributary . init ( tributary . g , 0 ) ;%NWL%tributary . execute ( ) ;%NWL%3
rb . style ( " display " ,  " " )%NWL%rb . on ( " click " , onRestart ) ;%NWL%onRestart ( ) ;%NWL%} else {%NWL%tributary . autoinit = true;%NWL%tc . select ( " button . restart " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%}%NWL%function init ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%tributary . loop_type = config . get ( " loop_type " ) ; / / [ " off " ,  " period " ,  " pingpong " ]%NWL%9
rb . on ( " click " , onRestart ) ;%NWL%onRestart ( ) ;%NWL%} else {%NWL%tributary . autoinit = true;%NWL%tc . select ( " button . restart " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%}%NWL%function init ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%tributary . pause = config . get ( " pause " ) ; / / pause is used to pause and unpause%NWL%tributary . bv = config . get ( " bv " ) ;%NWL%8
onRestart ( ) ;%NWL%} else {%NWL%tributary . autoinit = true;%NWL%tc . select ( " button . restart " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%}%NWL%function init ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%tributary . pause = config . get ( " pause " ) ; / / pause is used to pause and unpause%NWL%tributary . loop_type = config . get ( " loop_type " ) ; / / [ " off " ,  " period " ,  " pingpong " ]%NWL%tributary . nclones = config . get ( " nclones " ) ;%NWL%7
} else {%NWL%tributary . autoinit = true;%NWL%tc . select ( " button . restart " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%}%NWL%function init ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%tributary . pause = config . get ( " pause " ) ; / / pause is used to pause and unpause%NWL%tributary . loop_type = config . get ( " loop_type " ) ; / / [ " off " ,  " period " ,  " pingpong " ]%NWL%tributary . bv = config . get ( " bv " ) ;%NWL%tributary . clone_opacity = config . get ( " clone_opacity " ) ;%NWL%6
tributary . autoinit = true;%NWL%tc . select ( " button . restart " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%}%NWL%function init ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%tributary . pause = config . get ( " pause " ) ; / / pause is used to pause and unpause%NWL%tributary . loop_type = config . get ( " loop_type " ) ; / / [ " off " ,  " period " ,  " pingpong " ]%NWL%tributary . bv = config . get ( " bv " ) ;%NWL%tributary . nclones = config . get ( " nclones " ) ;%NWL%tributary . duration = config . get ( " duration " ) ;%NWL%5
tc . select ( " button . restart " ) . style ( " display " ,  " none " ) ;%NWL%}%NWL%}%NWL%function init ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%tributary . pause = config . get ( " pause " ) ; / / pause is used to pause and unpause%NWL%tributary . loop_type = config . get ( " loop_type " ) ; / / [ " off " ,  " period " ,  " pingpong " ]%NWL%tributary . bv = config . get ( " bv " ) ;%NWL%tributary . nclones = config . get ( " nclones " ) ;%NWL%tributary . clone_opacity = config . get ( " clone_opacity " ) ;%NWL%tributary . ease = d3 . ease ( config . get ( " ease " ) ) ;%NWL%4
}%NWL%function init ( )  {%NWL%tributary . loop = config . get ( " loop " ) ;%NWL%tributary . pause = config . get ( " pause " ) ; / / pause is used to pause and unpause%NWL%tributary . loop_type = config . get ( " loop_type " ) ; / / [ " off " ,  " period " ,  " pingpong " ]%NWL%tributary . bv = config . get ( " bv " ) ;%NWL%tributary . nclones = config . get ( " nclones " ) ;%NWL%tributary . clone_opacity = config . get ( " clone_opacity " ) ;%NWL%tributary . duration = config . get ( " duration " ) ;%NWL%tributary . ease = d3 . ease ( config . get ( " ease " ) ) ;%NWL%tributary . dt = config . get ( " dt " ) ;%NWL%2
var bits = re . exec ( color_string ) ;%NWL%if ( bits )  {%NWL%channels = processor ( bits ) ;%NWL%this . r = channels [ 0 ] ;%NWL%this . g = channels [ 1 ] ;%NWL%this . b = channels [ 2 ] ;%NWL%this . ok = true;%NWL%}%NWL%}%NWL%this . r = ( this . r < 0 || isNaN ( this . r ) ) ? 0 : ( ( this . r > 255 ) ? 255 : this . r ) ;%NWL%this . b = ( this . b < 0 || isNaN ( this . b ) ) ? 0 : ( ( this . b > 255 ) ? 255 : this . b ) ;%NWL%9
}%NWL%}%NWL%this . r = ( this . r < 0 || isNaN ( this . r ) ) ? 0 : ( ( this . r > 255 ) ? 255 : this . r ) ;%NWL%this . g = ( this . g < 0 || isNaN ( this . g ) ) ? 0 : ( ( this . g > 255 ) ? 255 : this . g ) ;%NWL%this . b = ( this . b < 0 || isNaN ( this . b ) ) ? 0 : ( ( this . b > 255 ) ? 255 : this . b ) ;%NWL%this . toRGB = function ( )  {%NWL%return ' rgb ( '  + this . r +  ' ,  '  + this . g +  ' ,  '  + this . b +  ' ) ' ;%NWL%}%NWL%this . toHex = function ( )  {%NWL%var r = this . r . toString ( 16 ) ;%NWL%var b = this . b . toString ( 16 ) ;%NWL%9
var path = require ( ' path ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%var React = require ( ' react ' ) ;%NWL%var debug = require ( ' debug ' ) ;%NWL%0
var path = require ( ' path ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%var React = require ( ' react ' ) ;%NWL%var WebpackDevServer = require ( ' webpack - dev - server ' ) ;%NWL%var webpack = require ( ' webpack ' ) ;%NWL%0
var os = require ( ' os ' ) ;%NWL%var webpack = require ( ' webpack ' ) ;%NWL%0
var os = require ( ' os ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var StatsPlugin = require ( ' . / plugins / StatsPlugin ' ) ;%NWL%0
require ( ' . / app . styl ' ) ;%NWL%var React = window . React = require ( ' react ' ) ;%NWL%var isMobile = require ( ' utils / isMobile ' ) ;%NWL%1
select: function ( )  {%NWL%this . componentWrapper . select ( ' path . stack ' ) . classed ( ' selected ' , true ) . classed ( ' not - selected ' , false ) ;%NWL%this . renderBaseLine ( ) ;%NWL%Line . prototype . select . apply ( this , arguments ) ;%NWL%} ,%NWL%deselect: function ( )  {%NWL%this . componentWrapper . selectAll ( ' . baseline ' ) . remove ( ) ;%NWL%Line . prototype . deselect . apply ( this , arguments ) ;%NWL%this . componentWrapper . select ( ' path . stack ' ) . classed ( ' selected ' , false ) . classed ( ' not - selected ' , true ) ;%NWL%} ,%NWL%this . componentWrapper . selectAll ( ' . baseline ' ) . remove ( ) ;%NWL%6
exports%NWL%, key%NWL%, Object . getOwnPropertyDescriptor ( connect . middleware , key ) ) ;%NWL%}%NWL%exports . createServer = function ( ) {%NWL%console . warn ( ' Warning: express . createServer ( ) is deprecated , express ' ) ;%NWL%console . warn ( ' applications no longer inherit from http . Server , ' ) ;%NWL%console . warn ( ' please use: ' ) ;%NWL%console . warn ( ' ' ) ;%NWL%console . warn ( '  var express = require ( " express " ) ; ' ) ;%NWL%console . warn ( ' ' ) ;%NWL%8
} else {%NWL%this . statusCode = obj;%NWL%obj = arguments [ 1 ] ;%NWL%}%NWL%}%NWL%var app = this . app;%NWL%var replacer = app . get ( ' json replacer ' ) ;%NWL%var spaces = app . get ( ' json spaces ' ) ;%NWL%var body = JSON . stringify ( obj , replacer , spaces )%NWL%. replace ( / \u2028 / g ,  ' \\u2028 ' )%NWL%var callback = this . req . query [ app . get ( ' jsonp callback name ' ) ] ;%NWL%6
res . contentType =%NWL%res . type = function ( type ) {%NWL%return this . set ( ' Content - Type ' , ~type . indexOf ( ' / ' )%NWL%? type%NWL%: mime . lookup ( type ) ) ;%NWL%} ;%NWL%res . format = function ( obj ) {%NWL%var req = this . req%NWL%, next = req . next;%NWL%var fn = obj . default;%NWL%var keys = Object . keys ( obj ) ;%NWL%7
return this . format ( value , format ) ;%NWL%} ,%NWL%onChangeSelected: function ( model , index , options )  {%NWL%options = options || { } ;%NWL%var selection = this . componentWrapper . selectAll ( ' text ' ) ;%NWL%if ( model === null )  {%NWL%selection . data ( [ ] ) . exit ( ) . remove ( ) ;%NWL%return;%NWL%}%NWL%var value = this . getValue ( model , index , options . valueAttr ) ;%NWL%selection . data ( [ ] ) . exit ( ) . remove ( ) ;%NWL%6
, paramIndex = 0%NWL%, paramVal%NWL%, route%NWL%, keys%NWL%, key;%NWL%function nextRoute ( err )  {%NWL%pass ( req . _route_index + 1 , err ) ;%NWL%}%NWL%req . route = route = self . matchRequest ( req , i ) ;%NWL%if ( !route ) return next ( err ) ;%NWL%req . params = route . params;%NWL%8
arg = argv [ + + i ] ;%NWL%if ( null == arg ) return this . optionMissingArgument ( option ) ;%NWL%if ( ' - ' == arg [ 0 ] && ' - ' != arg ) return this . optionMissingArgument ( option , arg ) ;%NWL%this . emit ( option . name ( ) , arg ) ;%NWL%} else if ( option . optional )  {%NWL%arg = argv [ i + 1 ] ;%NWL%if ( null == arg || ( ' - ' == arg [ 0 ] && ' - ' != arg ) )  {%NWL%arg = null;%NWL%} else {%NWL%+ + i;%NWL%this . emit ( option . name ( ) , arg ) ;%NWL%3
continue;%NWL%}%NWL%%NWL%args . push ( arg ) ;%NWL%}%NWL%%NWL%return { args: args , unknown: unknownOptions } ;%NWL%} ;%NWL%Command . prototype . missingArgument = function ( name ) {%NWL%console . error ( ) ;%NWL%console . error ( ) ;%NWL%9
}%NWL%%NWL%return { args: args , unknown: unknownOptions } ;%NWL%} ;%NWL%Command . prototype . missingArgument = function ( name ) {%NWL%console . error ( ) ;%NWL%console . error ( "  error: missing required argument `%s ' " , name ) ;%NWL%console . error ( ) ;%NWL%process . exit ( 1 ) ;%NWL%} ;%NWL%console . error ( ) ;%NWL%5
console . error ( "  error: missing required argument `%s ' " , name ) ;%NWL%console . error ( ) ;%NWL%process . exit ( 1 ) ;%NWL%} ;%NWL%Command . prototype . optionMissingArgument = function ( option , flag ) {%NWL%console . error ( ) ;%NWL%if ( flag )  {%NWL%console . error ( "  error: option `%s ' argument missing , got `%s ' " , option . flags , flag ) ;%NWL%} else {%NWL%console . error ( "  error: option `%s ' argument missing " , option . flags ) ;%NWL%console . error ( ) ;%NWL%1
console . error ( ) ;%NWL%process . exit ( 1 ) ;%NWL%} ;%NWL%Command . prototype . optionMissingArgument = function ( option , flag ) {%NWL%console . error ( ) ;%NWL%if ( flag )  {%NWL%console . error ( "  error: option `%s ' argument missing , got `%s ' " , option . flags , flag ) ;%NWL%} else {%NWL%console . error ( "  error: option `%s ' argument missing " , option . flags ) ;%NWL%}%NWL%process . exit ( 1 ) ;%NWL%1
Command . prototype . optionMissingArgument = function ( option , flag ) {%NWL%console . error ( ) ;%NWL%if ( flag )  {%NWL%console . error ( "  error: option `%s ' argument missing , got `%s ' " , option . flags , flag ) ;%NWL%} else {%NWL%console . error ( "  error: option `%s ' argument missing " , option . flags ) ;%NWL%}%NWL%console . error ( ) ;%NWL%process . exit ( 1 ) ;%NWL%} ;%NWL%console . error ( ) ;%NWL%1
if ( flag )  {%NWL%console . error ( "  error: option `%s ' argument missing , got `%s ' " , option . flags , flag ) ;%NWL%} else {%NWL%console . error ( "  error: option `%s ' argument missing " , option . flags ) ;%NWL%}%NWL%console . error ( ) ;%NWL%process . exit ( 1 ) ;%NWL%} ;%NWL%Command . prototype . unknownOption = function ( flag ) {%NWL%console . error ( ) ;%NWL%console . error ( ) ;%NWL%5
console . error ( "  error: option `%s ' argument missing , got `%s ' " , option . flags , flag ) ;%NWL%} else {%NWL%console . error ( "  error: option `%s ' argument missing " , option . flags ) ;%NWL%}%NWL%console . error ( ) ;%NWL%process . exit ( 1 ) ;%NWL%} ;%NWL%Command . prototype . unknownOption = function ( flag ) {%NWL%console . error ( ) ;%NWL%console . error ( "  error: unknown option `%s ' " , flag ) ;%NWL%process . exit ( 1 ) ;%NWL%5
return this [ ' promptFor '  +  ( fn . name || fn ) ] ( str , arguments [ 2 ] ) ;%NWL%}%NWL%process . stdout . write ( str ) ;%NWL%process . stdin . setEncoding ( ' utf8 ' ) ;%NWL%process . stdin . once ( ' data ' , function ( val ) {%NWL%fn ( val . trim ( ) ) ;%NWL%} ) . resume ( ) ;%NWL%} ;%NWL%Command . prototype . promptMultiLine = function ( str , fn ) {%NWL%var buf = [ ] ;%NWL%process . stdin . setEncoding ( ' utf8 ' ) ;%NWL%3
stream . _emitKeypress = true;%NWL%function onData ( b )  {%NWL%if ( stream . listeners ( ' keypress ' ) . length > 0 )  {%NWL%emitKey ( stream , b ) ;%NWL%} else {%NWL%stream . removeListener ( ' data ' , onData ) ;%NWL%stream . on ( ' newListener ' , onNewListener ) ;%NWL%}%NWL%}%NWL%function onNewListener ( event )  {%NWL%stream . on ( ' data ' , onData ) ;%NWL%5
function onData ( b )  {%NWL%if ( stream . listeners ( ' keypress ' ) . length > 0 )  {%NWL%emitKey ( stream , b ) ;%NWL%} else {%NWL%stream . removeListener ( ' data ' , onData ) ;%NWL%stream . on ( ' newListener ' , onNewListener ) ;%NWL%}%NWL%}%NWL%function onNewListener ( event )  {%NWL%if ( event == ' keypress ' )  {%NWL%stream . removeListener ( ' newListener ' , onNewListener ) ;%NWL%5
stream . removeListener ( ' data ' , onData ) ;%NWL%stream . on ( ' newListener ' , onNewListener ) ;%NWL%}%NWL%}%NWL%function onNewListener ( event )  {%NWL%if ( event == ' keypress ' )  {%NWL%stream . on ( ' data ' , onData ) ;%NWL%stream . removeListener ( ' newListener ' , onNewListener ) ;%NWL%}%NWL%}%NWL%stream . on ( ' data ' , onData ) ;%NWL%0
}%NWL%}%NWL%function onNewListener ( event )  {%NWL%if ( event == ' keypress ' )  {%NWL%stream . on ( ' data ' , onData ) ;%NWL%stream . removeListener ( ' newListener ' , onNewListener ) ;%NWL%}%NWL%}%NWL%if ( stream . listeners ( ' keypress ' ) . length > 0 )  {%NWL%stream . on ( ' data ' , onData ) ;%NWL%stream . on ( ' newListener ' , onNewListener ) ;%NWL%5
process . stdin . on ( ' keypress ' , function ( c , key )  {%NWL%console . log ( 0 , c , key )%NWL%if ( key && key . ctrl && key . name == ' c ' )  {%NWL%process . stdin . pause ( )%NWL%}%NWL%} )%NWL%process . stdin . on ( ' mousepress ' , function ( mouse )  {%NWL%console . log ( mouse )%NWL%} )%NWL%keypress . enableMouse ( process . stdout )%NWL%keypress . disableMouse ( process . stdout )%NWL%9
var http = require ( ' http ' )%NWL%, utils = require ( ' . / utils ' )%NWL%, debug = require ( ' debug ' ) ( ' connect:dispatcher ' ) ;%NWL%var env = process . env . NODE_ENV || ' development ' ;%NWL%0
var stack = this . stack%NWL%, fqdn = ~req . url . indexOf ( ' : / / ' )%NWL%, removed = ' '%NWL%, slashAdded = false%NWL%, index = 0;%NWL%function next ( err )  {%NWL%var layer , path , status , c;%NWL%if ( slashAdded )  {%NWL%req . url = req . url . substr ( 1 ) ;%NWL%slashAdded = false;%NWL%req . url = removed + req . url;%NWL%8
, fqdn = ~req . url . indexOf ( ' : / / ' )%NWL%, removed = ' '%NWL%, slashAdded = false%NWL%, index = 0;%NWL%function next ( err )  {%NWL%var layer , path , status , c;%NWL%if ( slashAdded )  {%NWL%req . url = req . url . substr ( 1 ) ;%NWL%slashAdded = false;%NWL%}%NWL%req . originalUrl = req . originalUrl || req . url;%NWL%7
? http . STATUS_CODES [ res . statusCode ]%NWL%: err . stack || err . toString ( ) ;%NWL%if ( ' test ' != env ) console . error ( err . stack || err . toString ( ) ) ;%NWL%if ( res . headerSent ) return req . socket . destroy ( ) ;%NWL%res . setHeader ( ' Content - Type ' ,  ' text / plain ' ) ;%NWL%res . setHeader ( ' Content - Length ' , Buffer . byteLength ( msg ) ) ;%NWL%if ( ' HEAD ' == req . method ) return res . end ( ) ;%NWL%res . end ( msg ) ;%NWL%} else {%NWL%debug ( ' default 404 ' ) ;%NWL%res . setHeader ( ' Content - Type ' ,  ' text / plain ' ) ;%NWL%4
return;%NWL%}%NWL%try {%NWL%path = utils . parseUrl ( req ) . pathname;%NWL%if ( undefined == path ) path = ' / ' ;%NWL%if ( 0 != path . toLowerCase ( ) . indexOf ( layer . route . toLowerCase ( ) ) ) return next ( err ) ;%NWL%c = path [ layer . route . length ] ;%NWL%if ( c && ' / ' != c && ' . ' != c ) return next ( err ) ;%NWL%removed = layer . route;%NWL%req . url = req . url . substr ( removed . length ) ;%NWL%req . url = ' / '  + req . url;%NWL%9
var http = require ( ' http ' )%NWL%, crypto = require ( ' crypto ' )%NWL%, parse = require ( ' url ' ) . parse%NWL%, signature = require ( ' cookie - signature ' )%NWL%, nodeVersion = process . versions . node . split ( ' . ' ) ;%NWL%exports . brokenPause = parseInt ( nodeVersion [ 0 ] , 10 ) === 0%NWL%&& parseInt ( nodeVersion [ 1 ] , 10 ) < 10;%NWL%var encoding = ' transfer - encoding ' in req . headers;%NWL%0
var http = require ( ' http ' )%NWL%, crypto = require ( ' crypto ' )%NWL%, parse = require ( ' url ' ) . parse%NWL%, signature = require ( ' cookie - signature ' )%NWL%, nodeVersion = process . versions . node . split ( ' . ' ) ;%NWL%exports . brokenPause = parseInt ( nodeVersion [ 0 ] , 10 ) === 0%NWL%&& parseInt ( nodeVersion [ 1 ] , 10 ) < 10;%NWL%exports . hasBody = function ( req )  {%NWL%var length = ' content - length ' in req . headers && req . headers [ ' content - length ' ] !== ' 0 ' ;%NWL%0
module . exports = function cookieParser ( secret ) {%NWL%return function cookieParser ( req , res , next )  {%NWL%if ( req . cookies ) return next ( ) ;%NWL%var cookies = req . headers . cookie;%NWL%req . secret = secret;%NWL%req . cookies = { } ;%NWL%req . signedCookies = { } ;%NWL%if ( cookies )  {%NWL%try {%NWL%req . cookies = cookie . parse ( cookies ) ;%NWL%req . signedCookies = utils . parseSignedCookies ( req . cookies , secret ) ;%NWL%9
return function cookieParser ( req , res , next )  {%NWL%if ( req . cookies ) return next ( ) ;%NWL%var cookies = req . headers . cookie;%NWL%req . secret = secret;%NWL%req . cookies = { } ;%NWL%req . signedCookies = { } ;%NWL%if ( cookies )  {%NWL%try {%NWL%req . cookies = cookie . parse ( cookies ) ;%NWL%if ( secret )  {%NWL%req . signedCookies = utils . parseJSONCookies ( req . signedCookies ) ;%NWL%8
var cookies = req . headers . cookie;%NWL%req . secret = secret;%NWL%req . cookies = { } ;%NWL%req . signedCookies = { } ;%NWL%if ( cookies )  {%NWL%try {%NWL%req . cookies = cookie . parse ( cookies ) ;%NWL%if ( secret )  {%NWL%req . signedCookies = utils . parseSignedCookies ( req . cookies , secret ) ;%NWL%req . signedCookies = utils . parseJSONCookies ( req . signedCookies ) ;%NWL%req . cookies = utils . parseJSONCookies ( req . cookies ) ;%NWL%6
var utils = require ( ' . / . . / utils ' )%NWL%, Cookie = require ( ' . / session / cookie ' )%NWL%, debug = require ( ' debug ' ) ( ' connect:cookieSession ' )%NWL%, signature = require ( ' cookie - signature ' )%NWL%, crc32 = require ( ' buffer - crc32 ' ) ;%NWL%module . exports = function cookieSession ( options ) {%NWL%var key = options . key || ' connect . sess '%NWL%0
var utils = require ( ' . / . . / utils ' )%NWL%, Cookie = require ( ' . / session / cookie ' )%NWL%, debug = require ( ' debug ' ) ( ' connect:cookieSession ' )%NWL%, signature = require ( ' cookie - signature ' )%NWL%, crc32 = require ( ' buffer - crc32 ' ) ;%NWL%module . exports = function cookieSession ( options ) {%NWL%options = options || { } ;%NWL%var key = options . key || ' connect . sess '%NWL%, trustProxy = options . proxy;%NWL%var secret = options . secret || req . secret;%NWL%0
, debug = require ( ' debug ' ) ( ' connect:cookieSession ' )%NWL%, signature = require ( ' cookie - signature ' )%NWL%, crc32 = require ( ' buffer - crc32 ' ) ;%NWL%module . exports = function cookieSession ( options ) {%NWL%options = options || { } ;%NWL%var key = options . key || ' connect . sess '%NWL%, trustProxy = options . proxy;%NWL%return function cookieSession ( req , res , next )  {%NWL%var secret = options . secret || req . secret;%NWL%if ( !secret ) throw new Error ( ' `secret` option required for cookie sessions ' ) ;%NWL%var cookie = req . session . cookie = new Cookie ( options . cookie ) ;%NWL%5
var utils = require ( ' . . / utils ' ) ;%NWL%var uid = require ( ' uid2 ' ) ;%NWL%module . exports = function csrf ( options )  {%NWL%var value = options . value || defaultValue;%NWL%0
var fs = require ( ' fs ' )%NWL%, parse = require ( ' url ' ) . parse%NWL%, utils = require ( ' . . / utils ' )%NWL%, path = require ( ' path ' )%NWL%, normalize = path . normalize%NWL%, extname = path . extname%NWL%, join = path . join;%NWL%var cache = { } ;%NWL%exports = module . exports = function directory ( root , options ) {%NWL%options = options || { } ;%NWL%var hidden = options . hidden%NWL%0
, join = path . join;%NWL%var cache = { } ;%NWL%exports = module . exports = function directory ( root , options ) {%NWL%options = options || { } ;%NWL%if ( !root ) throw new Error ( ' directory ( ) root path required ' ) ;%NWL%var hidden = options . hidden%NWL%, icons = options . icons%NWL%, filter = options . filter%NWL%, root = normalize ( root ) ;%NWL%return function directory ( req , res , next )  {%NWL%var accept = req . headers . accept || ' text / plain '%NWL%5
} ) ;%NWL%} ;%NWL%exports . json = function ( req , res , files ) {%NWL%files = JSON . stringify ( files ) ;%NWL%res . setHeader ( ' Content - Type ' ,  ' application / json ' ) ;%NWL%res . setHeader ( ' Content - Length ' , files . length ) ;%NWL%res . end ( files ) ;%NWL%} ;%NWL%exports . plain = function ( req , res , files ) {%NWL%files = files . join ( ' \n ' )  +  ' \n ' ;%NWL%res . setHeader ( ' Content - Length ' , files . length ) ;%NWL%5
} ;%NWL%exports . json = function ( req , res , files ) {%NWL%files = JSON . stringify ( files ) ;%NWL%res . setHeader ( ' Content - Type ' ,  ' application / json ' ) ;%NWL%res . setHeader ( ' Content - Length ' , files . length ) ;%NWL%res . end ( files ) ;%NWL%} ;%NWL%exports . plain = function ( req , res , files ) {%NWL%files = files . join ( ' \n ' )  +  ' \n ' ;%NWL%res . setHeader ( ' Content - Type ' ,  ' text / plain ' ) ;%NWL%res . end ( files ) ;%NWL%5
var utils = require ( ' . . / utils ' )%NWL%var env = process . env . NODE_ENV || ' development ' ;%NWL%0
var utils = require ( ' . . / utils ' )%NWL%, fs = require ( ' fs ' ) ;%NWL%var env = process . env . NODE_ENV || ' development ' ;%NWL%exports = module . exports = function errorHandler ( ) {%NWL%return function errorHandler ( err , req , res , next ) {%NWL%if ( err . status ) res . statusCode = err . status;%NWL%if ( res . statusCode < 400 ) res . statusCode = 500;%NWL%var accept = req . headers . accept || ' ' ;%NWL%0
, fs = require ( ' fs ' ) ;%NWL%var env = process . env . NODE_ENV || ' development ' ;%NWL%exports = module . exports = function errorHandler ( ) {%NWL%return function errorHandler ( err , req , res , next ) {%NWL%if ( err . status ) res . statusCode = err . status;%NWL%if ( res . statusCode < 400 ) res . statusCode = 500;%NWL%if ( ' test ' != env ) console . error ( err . stack ) ;%NWL%var accept = req . headers . accept || ' ' ;%NWL%if ( ~accept . indexOf ( ' html ' ) )  {%NWL%fs . readFile ( __dirname +  ' / . . / public / style . css ' ,  ' utf8 ' , function ( e , style ) {%NWL%var stack = ( err . stack || ' ' )%NWL%1
var utils = require ( ' . . / utils ' )%NWL%, _limit = require ( ' . / limit ' ) ;%NWL%function noop ( req , res , next )  {%NWL%next ( ) ;%NWL%}%NWL%exports = module . exports = function ( options ) {%NWL%var options = options || { }%NWL%var limit = options . limit%NWL%0
if ( immediate )  {%NWL%var line = fmt ( exports , req , res ) ;%NWL%if ( null == line ) return;%NWL%stream . write ( line +  ' \n ' ) ;%NWL%} else {%NWL%var end = res . end;%NWL%res . end = function ( chunk , encoding ) {%NWL%res . end = end;%NWL%res . end ( chunk , encoding ) ;%NWL%var line = fmt ( exports , req , res ) ;%NWL%stream . write ( line +  ' \n ' ) ;%NWL%3
var formidable = require ( ' formidable ' )%NWL%, _limit = require ( ' . / limit ' )%NWL%, utils = require ( ' . . / utils ' )%NWL%, qs = require ( ' qs ' ) ;%NWL%function noop ( req , res , next )  {%NWL%next ( ) ;%NWL%}%NWL%exports = module . exports = function ( options ) {%NWL%var limit = options . limit%NWL%0
var send = require ( ' send ' )%NWL%, utils = require ( ' . . / utils ' )%NWL%, parse = utils . parseUrl%NWL%, url = require ( ' url ' ) ;%NWL%exports = module . exports = function ( root , options ) {%NWL%options = options || { } ;%NWL%if ( !root ) throw new Error ( ' static ( ) root path required ' ) ;%NWL%var redirect = false !== options . redirect;%NWL%return function staticMiddleware ( req , res , next )  {%NWL%if ( ' GET ' != req . method && ' HEAD ' != req . method ) return next ( ) ;%NWL%var pause = utils . pause ( req ) ;%NWL%0
, content = cacheEntry . slice ( 2 ) ;%NWL%headers . age = ( new Date - new Date ( headers . date ) )  / 1000 || 0;%NWL%switch ( req . method )  {%NWL%case ' HEAD ' :%NWL%res . writeHead ( status , headers ) ;%NWL%res . end ( ) ;%NWL%break;%NWL%case ' GET ' :%NWL%if ( utils . conditionalGET ( req ) && fresh ( req . headers , headers ) )  {%NWL%headers [ ' content - length ' ] = 0;%NWL%res . end ( ) ;%NWL%5
switch ( req . method )  {%NWL%case ' HEAD ' :%NWL%res . writeHead ( status , headers ) ;%NWL%res . end ( ) ;%NWL%break;%NWL%case ' GET ' :%NWL%if ( utils . conditionalGET ( req ) && fresh ( req . headers , headers ) )  {%NWL%headers [ ' content - length ' ] = 0;%NWL%res . writeHead ( 304 , headers ) ;%NWL%res . end ( ) ;%NWL%res . writeHead ( status , headers ) ;%NWL%2
res . writeHead ( 304 , headers ) ;%NWL%res . end ( ) ;%NWL%} else {%NWL%res . writeHead ( status , headers ) ;%NWL%function write ( )  {%NWL%while ( content . length )  {%NWL%if ( false === res . write ( content . shift ( ) ) )  {%NWL%res . once ( ' drain ' , write ) ;%NWL%return;%NWL%}%NWL%res . end ( ) ;%NWL%1
res . once ( ' drain ' , write ) ;%NWL%return;%NWL%}%NWL%}%NWL%res . end ( ) ;%NWL%}%NWL%write ( ) ;%NWL%}%NWL%break;%NWL%default:%NWL%res . end ( ) ;%NWL%4
var utils = require ( ' . . / utils ' )%NWL%, _limit = require ( ' . / limit ' )%NWL%, qs = require ( ' qs ' ) ;%NWL%function noop ( req , res , next )  {%NWL%next ( ) ;%NWL%}%NWL%exports = module . exports = function ( options ) {%NWL%var limit = options . limit%NWL%0
req . body = req . body || { } ;%NWL%if ( !utils . hasBody ( req ) ) return next ( ) ;%NWL%if ( ' application / x - www - form - urlencoded ' != utils . mime ( req ) ) return next ( ) ;%NWL%req . _body = true;%NWL%limit ( req , res , function ( err ) {%NWL%if ( err ) return next ( err ) ;%NWL%var buf = ' ' ;%NWL%req . setEncoding ( ' utf8 ' ) ;%NWL%req . on ( ' data ' , function ( chunk ) { buf + = chunk } ) ;%NWL%req . on ( ' end ' , function ( ) {%NWL%req . body = buf . length%NWL%0
this . maxAge = null;%NWL%this . httpOnly = true;%NWL%if ( options ) utils . merge ( this , options ) ;%NWL%this . originalMaxAge = undefined == this . originalMaxAge%NWL%? this . maxAge%NWL%: this . originalMaxAge;%NWL%} ;%NWL%Cookie . prototype = {%NWL%%NWL%set expires ( date )  {%NWL%this . originalMaxAge = this . maxAge;%NWL%3
if ( !sess ) return fn ( ) ;%NWL%var req = { sessionID: sid , sessionStore: self } ;%NWL%sess = self . createSession ( req , sess ) ;%NWL%fn ( null , sess ) ;%NWL%} ) ;%NWL%} ;%NWL%Store . prototype . createSession = function ( req , sess ) {%NWL%var expires = sess . cookie . expires%NWL%, orig = sess . cookie . originalMaxAge;%NWL%sess . cookie = new Cookie ( sess . cookie ) ;%NWL%sess . cookie . originalMaxAge = orig;%NWL%9
partEnd: - 1 ,%NWL%headerField: - 1 ,%NWL%headerValue: - 1 ,%NWL%partData: - 1 ,%NWL%end: - 1 ,%NWL%} ;%NWL%parser . initWithBoundary ( boundary ) ;%NWL%parser . onHeaderField = function ( )  {%NWL%callbacks . headerField + + ;%NWL%} ;%NWL%callbacks . headerValue + + ;%NWL%8
partData: - 1 ,%NWL%end: - 1 ,%NWL%} ;%NWL%parser . initWithBoundary ( boundary ) ;%NWL%parser . onHeaderField = function ( )  {%NWL%callbacks . headerField + + ;%NWL%} ;%NWL%parser . onHeaderValue = function ( )  {%NWL%callbacks . headerValue + + ;%NWL%} ;%NWL%callbacks . partBegin + + ;%NWL%5
parser . initWithBoundary ( boundary ) ;%NWL%parser . onHeaderField = function ( )  {%NWL%callbacks . headerField + + ;%NWL%} ;%NWL%parser . onHeaderValue = function ( )  {%NWL%callbacks . headerValue + + ;%NWL%} ;%NWL%parser . onPartBegin = function ( )  {%NWL%callbacks . partBegin + + ;%NWL%} ;%NWL%callbacks . partData + + ;%NWL%2
} ;%NWL%parser . onHeaderValue = function ( )  {%NWL%callbacks . headerValue + + ;%NWL%} ;%NWL%parser . onPartBegin = function ( )  {%NWL%callbacks . partBegin + + ;%NWL%} ;%NWL%parser . onPartData = function ( )  {%NWL%callbacks . partData + + ;%NWL%} ;%NWL%callbacks . partEnd + + ;%NWL%2
} ;%NWL%parser . onPartBegin = function ( )  {%NWL%callbacks . partBegin + + ;%NWL%} ;%NWL%parser . onPartData = function ( )  {%NWL%callbacks . partData + + ;%NWL%} ;%NWL%parser . onPartEnd = function ( )  {%NWL%callbacks . partEnd + + ;%NWL%} ;%NWL%callbacks . end + + ;%NWL%2
this . path = null;%NWL%this . name = null;%NWL%this . type = null;%NWL%this . hash = null;%NWL%this . lastModifiedDate = null;%NWL%this . _writeStream = null;%NWL%%NWL%for ( var key in properties )  {%NWL%this [ key ] = properties [ key ] ;%NWL%}%NWL%this . hash = crypto . createHash ( properties . hash ) ;%NWL%8
this [ key ] = properties [ key ] ;%NWL%}%NWL%if ( typeof this . hash === ' string ' )  {%NWL%this . hash = crypto . createHash ( properties . hash ) ;%NWL%} else {%NWL%this . hash = null;%NWL%}%NWL%}%NWL%module . exports = File;%NWL%util . inherits ( File , EventEmitter ) ;%NWL%this . _writeStream = new WriteStream ( this . path ) ;%NWL%0
EventEmitter = require ( ' events ' ) . EventEmitter ,%NWL%Stream = require ( ' stream ' ) . Stream ,%NWL%os = require ( ' os ' ) ;%NWL%function IncomingForm ( opts )  {%NWL%if ( ! ( this instanceof IncomingForm ) ) return new IncomingForm ( opts ) ;%NWL%EventEmitter . call ( this ) ;%NWL%opts=opts|| { } ;%NWL%this . error = null;%NWL%this . ended = false;%NWL%this . maxFields = opts . maxFields || 1000;%NWL%this . keepExtensions = opts . keepExtensions || false;%NWL%9
Stream = require ( ' stream ' ) . Stream ,%NWL%os = require ( ' os ' ) ;%NWL%function IncomingForm ( opts )  {%NWL%if ( ! ( this instanceof IncomingForm ) ) return new IncomingForm ( opts ) ;%NWL%EventEmitter . call ( this ) ;%NWL%opts=opts|| { } ;%NWL%this . error = null;%NWL%this . ended = false;%NWL%this . maxFields = opts . maxFields || 1000;%NWL%this . maxFieldsSize = opts . maxFieldsSize || 2 * 1024 * 1024;%NWL%this . uploadDir = opts . uploadDir || os . tmpDir ( ) ;%NWL%8
os = require ( ' os ' ) ;%NWL%function IncomingForm ( opts )  {%NWL%if ( ! ( this instanceof IncomingForm ) ) return new IncomingForm ( opts ) ;%NWL%EventEmitter . call ( this ) ;%NWL%opts=opts|| { } ;%NWL%this . error = null;%NWL%this . ended = false;%NWL%this . maxFields = opts . maxFields || 1000;%NWL%this . maxFieldsSize = opts . maxFieldsSize || 2 * 1024 * 1024;%NWL%this . keepExtensions = opts . keepExtensions || false;%NWL%this . encoding = opts . encoding || ' utf - 8 ' ;%NWL%7
req . pause ( ) ;%NWL%} catch ( err )  {%NWL%if ( !this . ended )  {%NWL%this . _error ( err ) ;%NWL%}%NWL%return false;%NWL%}%NWL%return true;%NWL%} ;%NWL%this . resume = function ( )  {%NWL%req . resume ( ) ;%NWL%0
this . _error ( err ) ;%NWL%}%NWL%return false;%NWL%}%NWL%return true;%NWL%} ;%NWL%this . resume = function ( )  {%NWL%try {%NWL%req . resume ( ) ;%NWL%} catch ( err )  {%NWL%this . _error ( err ) ;%NWL%0
path: this . _uploadPath ( part . filename ) ,%NWL%name: part . filename ,%NWL%type: part . mime ,%NWL%hash: self . hash%NWL%} ) ;%NWL%this . emit ( ' fileBegin ' , part . name , file ) ;%NWL%file . open ( ) ;%NWL%this . openedFiles . push ( file ) ;%NWL%part . on ( ' data ' , function ( buffer )  {%NWL%self . pause ( ) ;%NWL%self . resume ( ) ;%NWL%9
this . openedFiles . push ( file ) ;%NWL%part . on ( ' data ' , function ( buffer )  {%NWL%self . pause ( ) ;%NWL%file . write ( buffer , function ( )  {%NWL%self . resume ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%part . on ( ' end ' , function ( )  {%NWL%file . end ( function ( )  {%NWL%self . _flushing - - ;%NWL%self . _maybeEnd ( ) ;%NWL%2
file . end ( function ( )  {%NWL%self . _flushing - - ;%NWL%self . emit ( ' file ' , part . name , file ) ;%NWL%self . _maybeEnd ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ;%NWL%function dummyParser ( self )  {%NWL%return {%NWL%end: function ( )  {%NWL%self . _maybeEnd ( ) ;%NWL%3
return;%NWL%}%NWL%if ( !this . headers [ ' content - type ' ] )  {%NWL%this . _error ( new Error ( ' bad content - type header , no content - type ' ) ) ;%NWL%return;%NWL%}%NWL%if ( this . headers [ ' content - type ' ] . match ( / octet - stream / i ) )  {%NWL%this . _initOctetStream ( ) ;%NWL%return;%NWL%}%NWL%this . _initUrlencoded ( ) ;%NWL%7
if ( this . headers [ ' content - type ' ] . match ( / json / i ) )  {%NWL%this . _initJSONencoded ( ) ;%NWL%return;%NWL%}%NWL%this . _error ( new Error ( ' bad content - type header , unknown content - type: ' + this . headers [ ' content - type ' ] ) ) ;%NWL%} ;%NWL%IncomingForm . prototype . _error = function ( err )  {%NWL%if ( this . error || this . ended )  {%NWL%return;%NWL%}%NWL%this . pause ( ) ;%NWL%1
file . open ( ) ;%NWL%this . emit ( ' fileBegin ' , filename , file ) ;%NWL%this . _flushing + + ;%NWL%var self = this;%NWL%self . _parser = new OctetParser ( ) ;%NWL%var outstandingWrites = 0;%NWL%self . _parser . on ( ' data ' , function ( buffer ) {%NWL%self . pause ( ) ;%NWL%outstandingWrites + + ;%NWL%file . write ( buffer , function ( )  {%NWL%self . resume ( ) ;%NWL%7
self . resume ( ) ;%NWL%if ( self . ended ) {%NWL%self . _parser . emit ( ' doneWritingFile ' ) ;%NWL%}%NWL%} ) ;%NWL%} ) ;%NWL%self . _parser . on ( ' end ' , function ( ) {%NWL%self . _flushing - - ;%NWL%self . ended = true;%NWL%var done = function ( ) {%NWL%self . _maybeEnd ( ) ;%NWL%0
} ;%NWL%exports . JSONParser = JSONParser;%NWL%JSONParser . prototype . initWithLength = function ( length )  {%NWL%this . data = new Buffer ( length ) ;%NWL%}%NWL%JSONParser . prototype . write = function ( buffer )  {%NWL%if ( this . data . length >= this . bytesWritten + buffer . length )  {%NWL%buffer . copy ( this . data , this . bytesWritten ) ;%NWL%} else {%NWL%this . data = Buffer . concat ( [ this . data , buffer ] ) ;%NWL%this . bytesWritten + = buffer . length;%NWL%9
var hashish = require ( ' hashish ' ) ;%NWL%var findit = require ( ' findit ' ) ;%NWL%0
var hashish = require ( ' hashish ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%0
var hashish = require ( ' hashish ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var findit = require ( ' findit ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var hashish = require ( ' hashish ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var findit = require ( ' findit ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%0
var hashish = require ( ' hashish ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var findit = require ( ' findit ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
var hashish = require ( ' hashish ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var findit = require ( ' findit ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var common = require ( ' . . / common ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var formidable = common . formidable;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var formidable = common . formidable;%NWL%var fs = require ( ' fs ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var formidable = common . formidable;%NWL%var http = require ( ' http ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var formidable = common . formidable;%NWL%var http = require ( ' http ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var hashish = require ( ' hashish ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var formidable = common . formidable;%NWL%var http = require ( ' http ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
var path = require ( ' path ' ) ,%NWL%fs = require ( ' fs ' ) ;%NWL%try {%NWL%global . Gently = require ( ' gently ' ) ;%NWL%} catch ( e )  {%NWL%throw new Error ( ' this test suite requires node - gently ' ) ;%NWL%}%NWL%exports . lib = path . join ( __dirname ,  ' . . / . . / lib ' ) ;%NWL%global . GENTLY = new Gently ( ) ;%NWL%global . assert = require ( ' assert ' ) ;%NWL%global . TEST_FIXTURES = path . join ( __dirname ,  ' . . / fixture ' ) ;%NWL%9
fs = require ( ' fs ' ) ;%NWL%try {%NWL%global . Gently = require ( ' gently ' ) ;%NWL%} catch ( e )  {%NWL%throw new Error ( ' this test suite requires node - gently ' ) ;%NWL%}%NWL%exports . lib = path . join ( __dirname ,  ' . . / . . / lib ' ) ;%NWL%global . GENTLY = new Gently ( ) ;%NWL%global . assert = require ( ' assert ' ) ;%NWL%global . TEST_PORT = 13532;%NWL%global . TEST_TMP = path . join ( __dirname ,  ' . . / tmp ' ) ;%NWL%8
assert . strictEqual ( buffer , BUFFER ) ;%NWL%gently . expect ( file ,  ' emit ' , function ( event , bytesWritten )  {%NWL%assert . ok ( file . lastModifiedDate instanceof Date ) ;%NWL%assert . equal ( event ,  ' progress ' ) ;%NWL%assert . equal ( bytesWritten , file . size ) ;%NWL%} ) ;%NWL%CB_STUB = gently . expect ( function writeCb ( )  {%NWL%assert . equal ( file . size , 10 ) ;%NWL%} ) ;%NWL%cb ( ) ;%NWL%assert . equal ( event ,  ' progress ' ) ;%NWL%3
gently . expect ( file ,  ' emit ' , function ( event , bytesWritten )  {%NWL%assert . ok ( file . lastModifiedDate instanceof Date ) ;%NWL%assert . equal ( event ,  ' progress ' ) ;%NWL%assert . equal ( bytesWritten , file . size ) ;%NWL%} ) ;%NWL%CB_STUB = gently . expect ( function writeCb ( )  {%NWL%assert . equal ( file . size , 10 ) ;%NWL%} ) ;%NWL%cb ( ) ;%NWL%gently . expect ( file ,  ' emit ' , function ( event , bytesWritten )  {%NWL%assert . equal ( bytesWritten , file . size ) ;%NWL%3
} ) ;%NWL%test ( function initWithBoundary ( )  {%NWL%var boundary = ' abc ' ;%NWL%parser . initWithBoundary ( boundary ) ;%NWL%assert . deepEqual ( Array . prototype . slice . call ( parser . boundary ) ,  [ 13 , 10 , 45 , 45 , 97 , 98 , 99 ] ) ;%NWL%assert . equal ( parser . state , multipartParser . START ) ;%NWL%assert . deepEqual ( parser . boundaryChars ,  { 10: true , 13: true , 45: true , 97: true , 98: true , 99: true } ) ;%NWL%} ) ;%NWL%test ( function parserError ( )  {%NWL%var boundary = ' abc ' ,%NWL%parser . initWithBoundary ( boundary ) ;%NWL%3
var assert = require ( ' assert ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%0
var assert = require ( ' assert ' ) ;%NWL%var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
}%NWL%return - 1;%NWL%} ;%NWL%var isArray = Array . isArray || function ( arr )  {%NWL%return toString . call ( arr ) == ' [ object Array ] ' ;%NWL%} ;%NWL%var objectKeys = Object . keys || function ( obj )  {%NWL%var ret = [ ] ;%NWL%for ( var key in obj ) ret . push ( key ) ;%NWL%return ret;%NWL%var forEach = typeof Array . prototype . forEach === ' function '%NWL%3
return obj;%NWL%}%NWL%function restoreProto ( obj )  {%NWL%if ( !Object . create ) return obj;%NWL%if ( isArray ( obj ) ) return obj;%NWL%if ( obj && ' object ' != typeof obj ) return obj;%NWL%for ( var key in obj )  {%NWL%if ( hasOwnProperty . call ( obj , key ) )  {%NWL%obj [ key ] = restoreProto ( obj [ key ] ) ;%NWL%}%NWL%obj . __proto__ = Object . prototype;%NWL%8
var ms = curr -  ( prev [ name ] || curr ) ;%NWL%prev [ name ] = curr;%NWL%fmt = '  \u001b [ 9 '  + c +  ' m '  + name +  '  '%NWL%+  ' \u001b [ 3 '  + c +  ' m\u001b [ 90m '%NWL%+ fmt +  ' \u001b [ 3 '  + c +  ' m '%NWL%+  '  + '  + humanize ( ms )  +  ' \u001b [ 0m ' ;%NWL%console . error . apply ( this , arguments ) ;%NWL%}%NWL%function plain ( fmt )  {%NWL%fmt = new Date ( ) . toUTCString ( )%NWL%console . error . apply ( this , arguments ) ;%NWL%6
t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' chmod ' , function ( t )  {%NWL%var mode = 0755%NWL%mkdirp ( file , mode , function ( er )  {%NWL%t . ifError ( er ,  ' should not error ' ) ;%NWL%fs . stat ( file , function ( er , stat )  {%NWL%t . ifError ( er ,  ' should exist ' ) ;%NWL%t . end ( ) ;%NWL%0
t . equal ( stat . mode & 0777 , 0755 ) ;%NWL%t . ok ( stat . isDirectory ( ) ,  ' target not a directory ' ) ;%NWL%t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%t . end ( ) ;%NWL%2
t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%if ( err ) t . fail ( err ) ;%NWL%t . end ( ) ;%NWL%t . end ( ) ;%NWL%0
var mkdirp = require ( ' . . / ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%test ( ' rel ' , function ( t )  {%NWL%t . plan ( 2 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var cwd = process . cwd ( ) ;%NWL%1
var test = require ( ' tap ' ) . test;%NWL%test ( ' return value ' , function ( t )  {%NWL%t . plan ( 4 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var file = ' / tmp / '  +  [ x , y , z ] . join ( ' / ' ) ;%NWL%mkdirp ( file , function ( err , made )  {%NWL%t . ifError ( err ) ;%NWL%t . equal ( made ,  ' / tmp / '  + x ) ;%NWL%t . ifError ( err ) ;%NWL%8
' use strict ' ;%NWL%var lpad = require ( ' lpad ' ) ;%NWL%module . exports = function ( grunt )  {%NWL%grunt . registerMultiTask ( ' concurrent ' ,  ' Run grunt tasks concurrently ' , function ( )  {%NWL%var spawnOptions;%NWL%var options = this . options ( ) ;%NWL%1
' use strict ' ;%NWL%var lpad = require ( ' lpad ' ) ;%NWL%module . exports = function ( grunt )  {%NWL%grunt . registerMultiTask ( ' concurrent ' ,  ' Run grunt tasks concurrently ' , function ( )  {%NWL%var spawnOptions;%NWL%var cb = this . async ( ) ;%NWL%var tasks = this . data . tasks || this . data;%NWL%1
exports . run = function ( code , options )  {%NWL%var answer , mainModule;%NWL%if ( options == null )  {%NWL%options = { } ;%NWL%}%NWL%mainModule = require . main;%NWL%if ( options . sourceMap == null )  {%NWL%options . sourceMap = true;%NWL%}%NWL%mainModule . filename = process . argv [ 1 ] = options . filename ? fs . realpathSync ( options . filename ) : ' . ' ;%NWL%mainModule . paths = require ( ' module ' ) . _nodeModulePaths ( path . dirname ( fs . realpathSync ( options . filename || ' . ' ) ) ) ;%NWL%9
sandbox . require = _require = function ( path )  {%NWL%return Module . _load ( path , _module , true ) ;%NWL%} ;%NWL%_module . filename = sandbox . __filename;%NWL%_ref1 = Object . getOwnPropertyNames ( require ) ;%NWL%for ( _i = 0 , _len = _ref1 . length; _i < _len; _i + + )  {%NWL%r = _ref1 [ _i ] ;%NWL%if ( r !== ' paths ' )  {%NWL%_require [ r ] = require [ r ] ;%NWL%}%NWL%_require . paths = _module . paths = Module . _nodeModulePaths ( process . cwd ( ) ) ;%NWL%8
var line , lines , maybe_code;%NWL%maybe_code = true;%NWL%lines = ( function ( )  {%NWL%var _i , _len , _ref1 , _results;%NWL%_ref1 = code . split ( ' \n ' ) ;%NWL%_results = [ ] ;%NWL%for ( _i = 0 , _len = _ref1 . length; _i < _len; _i + + )  {%NWL%line = _ref1 [ _i ] ;%NWL%if ( maybe_code && / ^ ( [  ] { 4 } | [  ] { 0 , 3 } \t ) / . test ( line ) )  {%NWL%_results . push ( line ) ;%NWL%_results . push ( line ) ;%NWL%9
useWinPathSep = false;%NWL%}%NWL%pathSep = useWinPathSep ? / \\|\ / / : / \ / / ;%NWL%parts = file . split ( pathSep ) ;%NWL%file = parts [ parts . length - 1 ] ;%NWL%if ( !stripExt )  {%NWL%return file;%NWL%}%NWL%parts = file . split ( ' . ' ) ;%NWL%parts . pop ( ) ;%NWL%parts . pop ( ) ;%NWL%9
return;%NWL%}%NWL%multiline . enabled = !multiline . enabled;%NWL%rli . line = ' ' ;%NWL%rli . cursor = 0;%NWL%rli . output . cursorTo ( 0 ) ;%NWL%rli . output . clearLine ( 1 ) ;%NWL%multiline . buffer = multiline . buffer . replace ( / \n / g ,  ' \uFF00 ' ) ;%NWL%rli . emit ( ' line ' , multiline . buffer ) ;%NWL%multiline . buffer = ' ' ;%NWL%multiline . enabled = !multiline . enabled;%NWL%7
var tok;%NWL%tok = [ tag , value ] ;%NWL%tok . generated = true;%NWL%return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%9
tok = [ tag , value ] ;%NWL%tok . generated = true;%NWL%return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%8
tok . generated = true;%NWL%return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . addImplicitIndentation ( ) ;%NWL%7
return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%this . tagPostfixConditionals ( ) ;%NWL%6
} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%this . addImplicitIndentation ( ) ;%NWL%this . addImplicitBracesAndParens ( ) ;%NWL%5
exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%this . addImplicitIndentation ( ) ;%NWL%this . tagPostfixConditionals ( ) ;%NWL%this . addLocationDataToGeneratedTokens ( ) ;%NWL%4
while ( inImplicitCall ( ) )  {%NWL%endImplicitCall ( ) ;%NWL%}%NWL%}%NWL%if ( inImplicitControl ( ) )  {%NWL%stack . pop ( ) ;%NWL%}%NWL%stack . push ( [ tag , i ] ) ;%NWL%return forward ( 1 ) ;%NWL%}%NWL%stack . push ( [ tag , i ] ) ;%NWL%7
}%NWL%if ( __indexOf . call ( EXPRESSION_END , tag ) >= 0 )  {%NWL%while ( inImplicit ( ) )  {%NWL%if ( inImplicitCall ( ) )  {%NWL%endImplicitCall ( ) ;%NWL%} else if ( inImplicitObject ( ) )  {%NWL%endImplicitObject ( ) ;%NWL%} else {%NWL%stack . pop ( ) ;%NWL%}%NWL%stack . pop ( ) ;%NWL%8
Rewriter . prototype . indentation = function ( implicit )  {%NWL%var indent , outdent;%NWL%if ( implicit == null )  {%NWL%implicit = false;%NWL%}%NWL%indent = [ ' INDENT ' , 2 ] ;%NWL%outdent = [ ' OUTDENT ' , 2 ] ;%NWL%if ( implicit )  {%NWL%indent . generated = outdent . generated = true;%NWL%}%NWL%indent . explicit = outdent . explicit = true;%NWL%8
var stylus = require ( ' stylus ' )%NWL%, nodes = stylus . nodes%NWL%, utils = stylus . utils%NWL%, Canvas%NWL%exports = module . exports = plugin;%NWL%try {%NWL%var gradient = require ( ' . / nodes / gradient ' )%NWL%0
exports . SyntaxError = SyntaxError;%NWL%SyntaxError . prototype . __proto__ = Error . prototype;%NWL%function ParseError ( msg )  {%NWL%this . name = ' ParseError ' ;%NWL%this . message = msg;%NWL%Error . captureStackTrace ( this , ParseError ) ;%NWL%}%NWL%ParseError . prototype . __proto__ = Error . prototype;%NWL%function SyntaxError ( msg )  {%NWL%this . name = ' SyntaxError ' ;%NWL%Error . captureStackTrace ( this , ParseError ) ;%NWL%5
var captures;%NWL%if ( !this . isURL ) return;%NWL%if ( captures = / ^ [ \ / :@ . ;?&= * ! , <>#%0 - 9 ] + / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' literal ' , new nodes . Literal ( captures [ 0 ] ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%sep: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%3
var captures;%NWL%if ( captures = / ^; [ \t ] * / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' ; ' ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%space: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
this . skip ( captures ) ;%NWL%return new Token ( ' space ' ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%escaped: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^\\ ( . ) [ \t ] * / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%0
var c = captures [ 1 ] ;%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' ident ' , new nodes . Literal ( c ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%literal: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%1
this . skip ( captures ) ;%NWL%return new Token ( ' null ' , nodes . null ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%keyword: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^ ( return|if|else|unless|for|in ) \b [ \t ] * / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%0
this . skip ( captures ) ;%NWL%return new Token ( keyword , keyword ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%namedop: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^ ( not|and|or|is a|is defined|isnt|is not|is ) ( ?! - ) \b ( [ \t ] * ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%0
var captures;%NWL%if ( captures = / ^@extends? [ \t ] * ( [ ^\ / { \n; ] + ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' extend ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%media: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
media: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^@media [ \t ] * ( . + ? ) ( ?=\ / \ / | [ \n { ] ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' media ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%mozdocument: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%3
var captures;%NWL%if ( captures = / ^@ - moz - document [ \t ] * ( [ ^\ / { \n ] + ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' - moz - document ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%scope: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
var captures;%NWL%if ( captures = / ^@scope [ \t ] * ( [ ^\ / { \n ] + ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' scope ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%atrule: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
ast = this . evaluator . evaluate ( ) ;%NWL%var normalizer = new Normalizer ( ast , this . options ) ;%NWL%ast = normalizer . normalize ( ) ;%NWL%var compiler = new Compiler ( ast , this . options )%NWL%, css = compiler . compile ( ) ;%NWL%this . emit ( ' end ' , css ) ;%NWL%fn ( null , css ) ;%NWL%} catch ( err )  {%NWL%var options = { } ;%NWL%options . input = err . input || this . str;%NWL%options . lineno = err . lineno || parser . lexer . lineno;%NWL%9
var Renderer = require ( ' . / renderer ' )%NWL%, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = ' 0 . 31 . 0 ' ;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%7
var Renderer = require ( ' . / renderer ' )%NWL%, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = ' 0 . 31 . 0 ' ;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%7
var Renderer = require ( ' . / renderer ' )%NWL%, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = ' 0 . 31 . 0 ' ;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Parser = require ( ' . / parser ' ) ;%NWL%7
, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = ' 0 . 31 . 0 ' ;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%exports . Evaluator = require ( ' . / visitor / evaluator ' ) ;%NWL%6
, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = ' 0 . 31 . 0 ' ;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%exports . Parser = require ( ' . / parser ' ) ;%NWL%exports . Compiler = require ( ' . / visitor / compiler ' ) ;%NWL%5
, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = ' 0 . 31 . 0 ' ;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%exports . Parser = require ( ' . / parser ' ) ;%NWL%exports . Evaluator = require ( ' . / visitor / evaluator ' ) ;%NWL%exports . convertCSS = require ( ' . / convert / css ' ) ;%NWL%4
var inspect = require ( ' util ' ) . inspect;%NWL%var Token = exports = module . exports = function Token ( type , val )  {%NWL%this . type = type;%NWL%this . val = val;%NWL%} ;%NWL%var val = '  '  + inspect ( this . val ) ;%NWL%1
exports . assertType = function ( node , type , param ) {%NWL%exports . assertPresent ( node , param ) ;%NWL%if ( node . nodeName == type ) return;%NWL%var actual = node . nodeName%NWL%, msg = ' expected " '%NWL%+ param +  ' " to be a '%NWL%+ type +  ' , but got '%NWL%+ actual +  ' : '  + node;%NWL%throw new Error ( ' TypeError: '  + msg ) ;%NWL%} ;%NWL%exports . assertPresent ( node , param ) ;%NWL%1
var utils = require ( ' . . / utils ' )%NWL%, nodes = require ( ' . . / nodes ' )%NWL%, fs = require ( ' fs ' ) ;%NWL%var Image = module . exports = function Image ( ctx , path )  {%NWL%this . ctx = ctx;%NWL%this . path = utils . lookup ( path , ctx . paths ) ;%NWL%if ( !this . path ) throw new Error ( ' failed to locate file '  + path ) ;%NWL%} ;%NWL%this . fd = fs . openSync ( this . path ,  ' r ' ) ;%NWL%5
, unit = unitMap [ name ]%NWL%, type = typeMap [ name ]%NWL%, name = componentMap [ name ] ;%NWL%if ( !name ) throw new Error ( ' invalid color component " '  + name +  ' " ' ) ;%NWL%return new nodes . Unit ( color [ type ] [ name ] , unit ) ;%NWL%} ;%NWL%exports . basename = function basename ( p , ext ) {%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%return path . basename ( p . val , ext && ext . val ) ;%NWL%} ;%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%7
return new nodes . Unit ( color [ type ] [ name ] , unit ) ;%NWL%} ;%NWL%exports . basename = function basename ( p , ext ) {%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%return path . basename ( p . val , ext && ext . val ) ;%NWL%} ;%NWL%exports . dirname = function dirname ( p ) {%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%return path . dirname ( p . val ) ;%NWL%} ;%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%3
exports . rgba = function rgba ( red , green , blue , alpha ) {%NWL%switch ( arguments . length )  {%NWL%case 1:%NWL%utils . assertColor ( red ) ;%NWL%var color = red . rgba;%NWL%return new nodes . RGBA (%NWL%color . r%NWL%, color . g%NWL%, color . b%NWL%, color . a ) ;%NWL%utils . assertColor ( red ) ;%NWL%3
return new nodes . RGBA (%NWL%color . r%NWL%, color . g%NWL%, color . b%NWL%, color . a ) ;%NWL%case 2:%NWL%utils . assertColor ( red ) ;%NWL%var color = red . rgba;%NWL%utils . assertType ( green ,  ' unit ' ,  ' alpha ' ) ;%NWL%if ( ' % ' == green . type ) green . val / = 100;%NWL%color . r%NWL%1
expr = utils . unwrap ( expr ) ;%NWL%if ( !expr . nodes . length ) return;%NWL%console . log ( ' \033 [ 90minspect:\033 [ 0m %s ' , expr . toString ( ) . replace ( / ^\ ( |\ ) $ / g ,  ' ' ) ) ;%NWL%} )%NWL%return nodes . null;%NWL%} ) . raw = true;%NWL%exports . error = function error ( msg ) {%NWL%utils . assertType ( msg ,  ' string ' ,  ' msg ' ) ;%NWL%throw new Error ( msg . val ) ;%NWL%} ;%NWL%utils . assertType ( msg ,  ' string ' ,  ' msg ' ) ;%NWL%7
case ' center ' : return ' center ' ;%NWL%default: throw new Error ( ' invalid position '  + pos ) ;%NWL%} } ) ( ) ;%NWL%expr . push ( new nodes . Literal ( pos ) ) ;%NWL%} ) ;%NWL%return expr;%NWL%} ) . raw = true;%NWL%exports [ ' image - size ' ] = function imageSize ( img )  {%NWL%utils . assertType ( img ,  ' string ' ,  ' img ' ) ;%NWL%var img = new Image ( this , img . string ) ;%NWL%var size = img . size ( ) ;%NWL%9
default: throw new Error ( ' invalid position '  + pos ) ;%NWL%} } ) ( ) ;%NWL%expr . push ( new nodes . Literal ( pos ) ) ;%NWL%} ) ;%NWL%return expr;%NWL%} ) . raw = true;%NWL%exports [ ' image - size ' ] = function imageSize ( img )  {%NWL%utils . assertType ( img ,  ' string ' ,  ' img ' ) ;%NWL%var img = new Image ( this , img . string ) ;%NWL%img . open ( ) ;%NWL%img . close ( ) ;%NWL%9
var Node = require ( ' . / node ' ) ;%NWL%var Call = module . exports = function Call ( name , args ) {%NWL%Node . call ( this ) ;%NWL%this . name = name;%NWL%this . args = args;%NWL%} ;%NWL%Call . prototype . __proto__ = Node . prototype;%NWL%var clone = new Call ( this . name , this . args . clone ( ) ) ;%NWL%1
var Node = require ( ' . / node ' ) ;%NWL%var FontFace = module . exports = function FontFace ( block ) {%NWL%Node . call ( this ) ;%NWL%this . block = block;%NWL%} ;%NWL%FontFace . prototype . __proto__ = Node . prototype;%NWL%var clone = new FontFace ( this . block . clone ( ) ) ;%NWL%1
Function . prototype . __proto__ = Node . prototype;%NWL%Function . prototype . __defineGetter__ ( ' hash ' , function ( ) {%NWL%return ' function '  + this . name;%NWL%} ) ;%NWL%Function . prototype . clone = function ( ) {%NWL%if ( this . fn )  {%NWL%var clone = new Function (%NWL%this . name%NWL%, this . fn ) ;%NWL%} else {%NWL%this . name%NWL%7
case ' && ' :%NWL%return this . rgba . operate ( op , right ) ;%NWL%default:%NWL%return this . rgba . operate ( op , right ) . hsla;%NWL%}%NWL%} ;%NWL%exports . fromRGBA = function ( rgba ) {%NWL%var r = rgba . r / 255%NWL%, g = rgba . g / 255%NWL%, b = rgba . b / 255%NWL%var min = Math . min ( r , g , b )%NWL%7
}%NWL%h %= 360;%NWL%s * = 100;%NWL%l * = 100;%NWL%return new HSLA ( h , s , l , a ) ;%NWL%} ;%NWL%HSLA . prototype . adjustLightness = function ( percent ) {%NWL%this . l = clampPercentage ( this . l + this . l *  ( percent / 100 ) ) ;%NWL%return this;%NWL%} ;%NWL%this . h = clampDegrees ( this . h + deg ) ;%NWL%7
} else {%NWL%this . negate = negate;%NWL%}%NWL%} ;%NWL%If . prototype . __proto__ = Node . prototype;%NWL%If . prototype . clone = function ( ) {%NWL%var cond = this . cond . clone ( )%NWL%, block = this . block . clone ( ) ;%NWL%var clone = new If ( cond , block ) ;%NWL%clone . elses = this . elses . map ( function ( node ) { return node . clone ( ) ; } ) ;%NWL%clone . postfix = this . postfix;%NWL%9
this . negate = negate;%NWL%}%NWL%} ;%NWL%If . prototype . __proto__ = Node . prototype;%NWL%If . prototype . clone = function ( ) {%NWL%var cond = this . cond . clone ( )%NWL%, block = this . block . clone ( ) ;%NWL%var clone = new If ( cond , block ) ;%NWL%clone . elses = this . elses . map ( function ( node ) { return node . clone ( ) ; } ) ;%NWL%clone . negate = this . negate;%NWL%clone . lineno = this . lineno;%NWL%8
}%NWL%} ;%NWL%If . prototype . __proto__ = Node . prototype;%NWL%If . prototype . clone = function ( ) {%NWL%var cond = this . cond . clone ( )%NWL%, block = this . block . clone ( ) ;%NWL%var clone = new If ( cond , block ) ;%NWL%clone . elses = this . elses . map ( function ( node ) { return node . clone ( ) ; } ) ;%NWL%clone . negate = this . negate;%NWL%clone . postfix = this . postfix;%NWL%clone . filename = this . filename;%NWL%7
exports . Charset = require ( ' . / charset ' ) ;%NWL%exports . Import = require ( ' . / import ' ) ;%NWL%exports . Extend = require ( ' . / extend ' ) ;%NWL%exports . Function = require ( ' . / function ' ) ;%NWL%exports . Property = require ( ' . / property ' ) ;%NWL%exports . Selector = require ( ' . / selector ' ) ;%NWL%exports . Expression = require ( ' . / expression ' ) ;%NWL%exports . Arguments = require ( ' . / arguments ' ) ;%NWL%exports . MozDocument = require ( ' . / mozdocument ' ) ;%NWL%exports . true = new exports . Boolean ( true ) ;%NWL%exports . null = new exports . Null;%NWL%9
var Node = require ( ' . / node ' )%NWL%, nodes = require ( ' . / ' ) ;%NWL%var Return = module . exports = function Return ( expr ) {%NWL%this . expr = expr || nodes . null;%NWL%} ;%NWL%Return . prototype . __proto__ = Node . prototype;%NWL%var clone = new Return ( this . expr . clone ( ) ) ;%NWL%2
var Node = require ( ' . / node ' ) ;%NWL%var UnaryOp = module . exports = function UnaryOp ( op , expr ) {%NWL%Node . call ( this ) ;%NWL%this . op = op;%NWL%this . expr = expr;%NWL%} ;%NWL%UnaryOp . prototype . __proto__ = Node . prototype;%NWL%var clone = new UnaryOp ( this . op , this . expr . clone ( ) ) ;%NWL%1
case ' print ' :%NWL%case ' page ' :%NWL%case ' block ' :%NWL%case ' keyframes ' :%NWL%if ( this . linenos || this . firebug ) this . debugInfo ( node ) ;%NWL%this . visit ( node ) ;%NWL%break;%NWL%case ' media ' :%NWL%case ' mozdocument ' :%NWL%case ' import ' :%NWL%this . visit ( node ) ;%NWL%5
, join = require ( ' path ' ) . join%NWL%, colors = require ( ' . . / colors ' )%NWL%, debug = require ( ' debug ' ) ( ' stylus:evaluator ' )%NWL%, fs = require ( ' fs ' ) ;%NWL%var Evaluator = module . exports = function Evaluator ( root , options )  {%NWL%options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . paths = options . paths || [ ] ;%NWL%8
, colors = require ( ' . . / colors ' )%NWL%, debug = require ( ' debug ' ) ( ' stylus:evaluator ' )%NWL%, fs = require ( ' fs ' ) ;%NWL%var Evaluator = module . exports = function Evaluator ( root , options )  {%NWL%options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . globals = options . globals || { } ;%NWL%this . filename = options . filename;%NWL%7
var Evaluator = module . exports = function Evaluator ( root , options )  {%NWL%options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . globals = options . globals || { } ;%NWL%this . paths = options . paths || [ ] ;%NWL%this . filename = options . filename;%NWL%this . includeCSS = options [ ' include css ' ] ;%NWL%this . stack . push ( this . global = new Frame ( root ) ) ;%NWL%4
options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . globals = options . globals || { } ;%NWL%this . paths = options . paths || [ ] ;%NWL%this . filename = options . filename;%NWL%this . includeCSS = options [ ' include css ' ] ;%NWL%this . paths . push ( dirname ( options . filename || ' . ' ) ) ;%NWL%this . warnings = options . warn;%NWL%3
Evaluator . prototype . evaluate = function ( ) {%NWL%debug ( ' eval %s ' , this . filename ) ;%NWL%this . setup ( ) ;%NWL%return this . visit ( this . root ) ;%NWL%} ;%NWL%Evaluator . prototype . visitGroup = function ( group ) {%NWL%group . nodes = group . nodes . map ( function ( selector ) {%NWL%selector . val = this . interpolate ( selector ) ;%NWL%debug ( ' ruleset %s ' , selector . val ) ;%NWL%return selector;%NWL%group . block = this . visit ( group . block ) ;%NWL%6
return val ? this . visit ( val ) : ident;%NWL%} else {%NWL%this . return + + ;%NWL%ident . val = this . visit ( ident . val ) ;%NWL%this . return - - ;%NWL%this . currentScope . add ( ident ) ;%NWL%return ident . val;%NWL%}%NWL%} ;%NWL%Evaluator . prototype . visitBinOp = function ( binop ) {%NWL%this . return + + ;%NWL%2
this . return - - ;%NWL%this . currentScope . add ( ident ) ;%NWL%return ident . val;%NWL%}%NWL%} ;%NWL%Evaluator . prototype . visitBinOp = function ( binop ) {%NWL%if ( ' is defined ' == binop . op ) return this . isDefined ( binop . left ) ;%NWL%this . return + + ;%NWL%var op = binop . op%NWL%, left = this . visit ( binop . left )%NWL%this . return - - ;%NWL%0
this . currentScope . add ( ident ) ;%NWL%return ident . val;%NWL%}%NWL%} ;%NWL%Evaluator . prototype . visitBinOp = function ( binop ) {%NWL%if ( ' is defined ' == binop . op ) return this . isDefined ( binop . left ) ;%NWL%this . return + + ;%NWL%var op = binop . op%NWL%, left = this . visit ( binop . left )%NWL%, right = this . visit ( binop . right ) ;%NWL%var val = binop . val%NWL%7
Evaluator . prototype . visitRoot = function ( block ) {%NWL%for ( var i = 0; i < block . nodes . length; + + i )  {%NWL%block . index = this . rootIndex = i;%NWL%block . nodes [ i ] = this . visit ( block . nodes [ i ] ) ;%NWL%}%NWL%return block;%NWL%} ;%NWL%Evaluator . prototype . visitBlock = function ( block ) {%NWL%this . stack . push ( new Frame ( block ) ) ;%NWL%for ( block . index = 0; block . index < block . nodes . length; + + block . index )  {%NWL%block . nodes [ block . index ] = this . visit ( block . nodes [ block . index ] ) ;%NWL%3
Evaluator . prototype . visitBlock = function ( block ) {%NWL%this . stack . push ( new Frame ( block ) ) ;%NWL%for ( block . index = 0; block . index < block . nodes . length; + + block . index )  {%NWL%try {%NWL%block . nodes [ block . index ] = this . visit ( block . nodes [ block . index ] ) ;%NWL%} catch ( err )  {%NWL%if ( ' return ' == err . nodeName )  {%NWL%if ( this . return )  {%NWL%this . stack . pop ( ) ;%NWL%throw err;%NWL%block . nodes [ block . index ] = err;%NWL%4
this . stack . pop ( ) ;%NWL%throw err;%NWL%} else {%NWL%block . nodes [ block . index ] = err;%NWL%break;%NWL%}%NWL%} else {%NWL%throw err;%NWL%}%NWL%}%NWL%this . stack . pop ( ) ;%NWL%0
case ' jsliteral ' :%NWL%case ' group ' :%NWL%case ' unit ' :%NWL%continue;%NWL%default:%NWL%ret . push ( this . visit ( node ) ) ;%NWL%}%NWL%}%NWL%}%NWL%for ( var i = 0 , len = block . nodes . length; i < len; + + i )  {%NWL%ret . push ( this . visit ( node ) ) ;%NWL%5
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSFontFaceRule = function CSSFontFaceRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%CSSOM . CSSFontFaceRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSFontFaceRule = function CSSFontFaceRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSFontFaceRule . prototype . constructor = CSSOM . CSSFontFaceRule;%NWL%4
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSFontFaceRule = function CSSFontFaceRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSFontFaceRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSFontFaceRule . prototype . type = 5;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleSheet: require ( " . / CSSStyleSheet " ) . CSSStyleSheet ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSImportRule = function CSSImportRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . href = " " ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . styleSheet = new CSSOM . CSSStyleSheet;%NWL%CSSOM . CSSImportRule . prototype = new CSSOM . CSSRule;%NWL%5
CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleSheet: require ( " . / CSSStyleSheet " ) . CSSStyleSheet ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSImportRule = function CSSImportRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . href = " " ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . styleSheet = new CSSOM . CSSStyleSheet;%NWL%} ;%NWL%CSSOM . CSSImportRule . prototype . constructor = CSSOM . CSSImportRule;%NWL%4
CSSStyleSheet: require ( " . / CSSStyleSheet " ) . CSSStyleSheet ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSImportRule = function CSSImportRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . href = " " ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . styleSheet = new CSSOM . CSSStyleSheet;%NWL%} ;%NWL%CSSOM . CSSImportRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSImportRule . prototype . type = 3;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleDeclaration: require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration%NWL%} ;%NWL%CSSOM . CSSKeyframeRule = function CSSKeyframeRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . keyText = ' ' ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%CSSOM . CSSKeyframeRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleDeclaration: require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration%NWL%} ;%NWL%CSSOM . CSSKeyframeRule = function CSSKeyframeRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . keyText = ' ' ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSKeyframeRule . prototype . constructor = CSSOM . CSSKeyframeRule;%NWL%4
CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleDeclaration: require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration%NWL%} ;%NWL%CSSOM . CSSKeyframeRule = function CSSKeyframeRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . keyText = ' ' ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSKeyframeRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSKeyframeRule . prototype . type = 9;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSKeyframesRule = function CSSKeyframesRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . name = ' ' ;%NWL%this . cssRules = [ ] ;%NWL%CSSOM . CSSKeyframesRule . prototype = new CSSOM . CSSRule;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSKeyframesRule = function CSSKeyframesRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . name = ' ' ;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSKeyframesRule . prototype . constructor = CSSOM . CSSKeyframesRule;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSKeyframesRule = function CSSKeyframesRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . name = ' ' ;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSKeyframesRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSKeyframesRule . prototype . type = 8;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSMediaRule = function CSSMediaRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . cssRules = [ ] ;%NWL%CSSOM . CSSMediaRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSMediaRule = function CSSMediaRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSMediaRule . prototype . constructor = CSSOM . CSSMediaRule;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSMediaRule = function CSSMediaRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSMediaRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSMediaRule . prototype . type = 4;%NWL%4
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . FONT_FACE_RULE = 5;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%CSSOM . CSSRule . PAGE_RULE = 6;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%CSSOM . CSSRule . FONT_FACE_RULE = 5;%NWL%CSSOM . CSSRule . WEBKIT_KEYFRAMES_RULE = 8;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%CSSOM . CSSRule . FONT_FACE_RULE = 5;%NWL%CSSOM . CSSRule . PAGE_RULE = 6;%NWL%CSSOM . CSSRule . WEBKIT_KEYFRAME_RULE = 9;%NWL%1
} ,%NWL%%NWL%setProperty: function ( name , value , priority )  {%NWL%if ( this [ name ] )  {%NWL%var index = Array . prototype . indexOf . call ( this , name ) ;%NWL%if ( index < 0 )  {%NWL%this [ this . length ] = name;%NWL%this . length + + ;%NWL%}%NWL%} else {%NWL%this . length + + ;%NWL%7
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSStyleRule = function CSSStyleRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . selectorText = " " ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%CSSOM . CSSStyleRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSStyleRule = function CSSStyleRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . selectorText = " " ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSStyleRule . prototype . constructor = CSSOM . CSSStyleRule;%NWL%4
CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSStyleRule = function CSSStyleRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . selectorText = " " ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSStyleRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSStyleRule . prototype . type = 1;%NWL%3
if ( state === " value " )  {%NWL%styleRule . style . setProperty ( name , buffer . trim ( ) , priority ) ;%NWL%priority = " " ;%NWL%buffer = " " ;%NWL%state = " name " ;%NWL%} else {%NWL%buffer + = character;%NWL%}%NWL%break;%NWL%case " } " :%NWL%styleRule . style . setProperty ( name , buffer . trim ( ) , priority ) ;%NWL%1
var CSSOM = {%NWL%StyleSheet: require ( " . / StyleSheet " ) . StyleSheet ,%NWL%CSSStyleRule: require ( " . / CSSStyleRule " ) . CSSStyleRule%NWL%} ;%NWL%CSSOM . CSSStyleSheet = function CSSStyleSheet ( )  {%NWL%CSSOM . StyleSheet . call ( this ) ;%NWL%this . cssRules = [ ] ;%NWL%CSSOM . CSSStyleSheet . prototype = new CSSOM . StyleSheet;%NWL%4
var CSSOM = {%NWL%StyleSheet: require ( " . / StyleSheet " ) . StyleSheet ,%NWL%CSSStyleRule: require ( " . / CSSStyleRule " ) . CSSStyleRule%NWL%} ;%NWL%CSSOM . CSSStyleSheet = function CSSStyleSheet ( )  {%NWL%CSSOM . StyleSheet . call ( this ) ;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSStyleSheet . prototype . constructor = CSSOM . CSSStyleSheet;%NWL%4
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%exports . CSSKeyframeRule = require ( ' . / CSSKeyframeRule ' ) . CSSKeyframeRule;%NWL%1
exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%exports . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%exports . parse = require ( ' . / parse ' ) . parse;%NWL%0
exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%exports . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%exports . CSSKeyframeRule = require ( ' . / CSSKeyframeRule ' ) . CSSKeyframeRule;%NWL%exports . clone = require ( ' . / clone ' ) . clone;%NWL%0
break;%NWL%}%NWL%buffer + = character;%NWL%break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%9
}%NWL%buffer + = character;%NWL%break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%8
buffer + = character;%NWL%break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSFontFaceRule = require ( " . / CSSFontFaceRule " ) . CSSFontFaceRule;%NWL%7
break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%CSSOM . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%6
}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%CSSOM . CSSFontFaceRule = require ( " . / CSSFontFaceRule " ) . CSSFontFaceRule;%NWL%CSSOM . CSSKeyframeRule = require ( ' . / CSSKeyframeRule ' ) . CSSKeyframeRule;%NWL%5
}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%CSSOM . CSSFontFaceRule = require ( " . / CSSFontFaceRule " ) . CSSFontFaceRule;%NWL%CSSOM . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%CSSOM . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%4
var ms = curr -  ( prev [ name ] || curr ) ;%NWL%prev [ name ] = curr;%NWL%fmt = '  \u001b [ 9 '  + c +  ' m '  + name +  '  '%NWL%+  ' \u001b [ 3 '  + c +  ' m\u001b [ 90m '%NWL%+ fmt +  ' \u001b [ 3 '  + c +  ' m '%NWL%+  '  + '  + humanize ( ms )  +  ' \u001b [ 0m ' ;%NWL%console . error . apply ( this , arguments ) ;%NWL%}%NWL%function plain ( fmt )  {%NWL%fmt = new Date ( ) . toUTCString ( )%NWL%console . error . apply ( this , arguments ) ;%NWL%6
t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' chmod ' , function ( t )  {%NWL%var mode = 0755%NWL%mkdirp ( file , mode , function ( er )  {%NWL%t . ifError ( er ,  ' should not error ' ) ;%NWL%fs . stat ( file , function ( er , stat )  {%NWL%t . ifError ( er ,  ' should exist ' ) ;%NWL%t . end ( ) ;%NWL%0
t . equal ( stat . mode & 0777 , 0755 ) ;%NWL%t . ok ( stat . isDirectory ( ) ,  ' target not a directory ' ) ;%NWL%t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%t . end ( ) ;%NWL%2
t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%if ( err ) t . fail ( err ) ;%NWL%t . end ( ) ;%NWL%t . end ( ) ;%NWL%0
var mkdirp = require ( ' . . / ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%test ( ' rel ' , function ( t )  {%NWL%t . plan ( 2 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var cwd = process . cwd ( ) ;%NWL%1
var test = require ( ' tap ' ) . test;%NWL%test ( ' return value ' , function ( t )  {%NWL%t . plan ( 4 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var file = ' / tmp / '  +  [ x , y , z ] . join ( ' / ' ) ;%NWL%mkdirp ( file , function ( err , made )  {%NWL%t . ifError ( err ) ;%NWL%t . equal ( made ,  ' / tmp / '  + x ) ;%NWL%t . ifError ( err ) ;%NWL%8
exports . SyntaxError = SyntaxError;%NWL%SyntaxError . prototype . __proto__ = Error . prototype;%NWL%function ParseError ( msg )  {%NWL%this . name = ' ParseError ' ;%NWL%this . message = msg;%NWL%Error . captureStackTrace ( this , ParseError ) ;%NWL%}%NWL%ParseError . prototype . __proto__ = Error . prototype;%NWL%function SyntaxError ( msg )  {%NWL%this . name = ' SyntaxError ' ;%NWL%Error . captureStackTrace ( this , ParseError ) ;%NWL%5
var captures;%NWL%if ( !this . isURL ) return;%NWL%if ( captures = / ^ [ \ / :@ . ;?&= * ! , <>#%0 - 9 ] + / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' literal ' , new nodes . Literal ( captures [ 0 ] ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%sep: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%3
var captures;%NWL%if ( captures = / ^; [ \t ] * / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' ; ' ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%space: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
this . skip ( captures ) ;%NWL%return new Token ( ' space ' ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%escaped: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^\\ ( . ) [ \t ] * / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%0
var c = captures [ 1 ] ;%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' ident ' , new nodes . Literal ( c ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%literal: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%1
this . skip ( captures ) ;%NWL%return new Token ( ' null ' , nodes . null ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%keyword: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^ ( return|if|else|unless|for|in ) \b [ \t ] * / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%0
this . skip ( captures ) ;%NWL%return new Token ( keyword , keyword ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%%NWL%namedop: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^ ( not|and|or|is a|is defined|isnt|is not|is ) ( ?! - ) \b ( [ \t ] * ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%0
var captures;%NWL%if ( captures = / ^@extends? [ \t ] * ( [ ^\ / { \n; ] + ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' extend ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%media: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
media: function ( )  {%NWL%var captures;%NWL%if ( captures = / ^@media [ \t ] * ( . + ? ) ( ?=\ / \ / | [ \n { ] ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' media ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%mozdocument: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%3
var captures;%NWL%if ( captures = / ^@ - moz - document [ \t ] * ( [ ^\ / { \n ] + ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' - moz - document ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%scope: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
var captures;%NWL%if ( captures = / ^@scope [ \t ] * ( [ ^\ / { \n ] + ) / . exec ( this . str ) )  {%NWL%this . skip ( captures ) ;%NWL%return new Token ( ' scope ' , captures [ 1 ] . trim ( ) ) ;%NWL%}%NWL%} ,%NWL%%NWL%%NWL%atrule: function ( )  {%NWL%var captures;%NWL%this . skip ( captures ) ;%NWL%2
var normalizer = new Normalizer ( ast , this . options ) ;%NWL%ast = normalizer . normalize ( ) ;%NWL%var compiler = new Compiler ( ast , this . options )%NWL%, css = compiler . compile ( ) ;%NWL%this . emit ( ' end ' , css ) ;%NWL%if ( !fn ) return css;%NWL%fn ( null , css ) ;%NWL%} catch ( err )  {%NWL%var options = { } ;%NWL%options . input = err . input || this . str;%NWL%options . lineno = err . lineno || parser . lexer . lineno;%NWL%9
var Renderer = require ( ' . / renderer ' )%NWL%, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = require ( ' . . / package ' ) . version;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%7
var Renderer = require ( ' . / renderer ' )%NWL%, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = require ( ' . . / package ' ) . version;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%7
var Renderer = require ( ' . / renderer ' )%NWL%, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = require ( ' . . / package ' ) . version;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Parser = require ( ' . / parser ' ) ;%NWL%7
, Parser = require ( ' . / parser ' )%NWL%, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = require ( ' . . / package ' ) . version;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%exports . Evaluator = require ( ' . / visitor / evaluator ' ) ;%NWL%6
, nodes = require ( ' . / nodes ' )%NWL%, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = require ( ' . . / package ' ) . version;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%exports . Parser = require ( ' . / parser ' ) ;%NWL%exports . Compiler = require ( ' . / visitor / compiler ' ) ;%NWL%5
, utils = require ( ' . / utils ' ) ;%NWL%exports = module . exports = render;%NWL%exports . version = require ( ' . . / package ' ) . version;%NWL%exports . nodes = nodes;%NWL%exports . functions = require ( ' . / functions ' ) ;%NWL%exports . utils = require ( ' . / utils ' ) ;%NWL%exports . middleware = require ( ' . / middleware ' ) ;%NWL%exports . Visitor = require ( ' . / visitor ' ) ;%NWL%exports . Parser = require ( ' . / parser ' ) ;%NWL%exports . Evaluator = require ( ' . / visitor / evaluator ' ) ;%NWL%exports . convertCSS = require ( ' . / convert / css ' ) ;%NWL%4
var inspect = require ( ' util ' ) . inspect;%NWL%var Token = exports = module . exports = function Token ( type , val )  {%NWL%this . type = type;%NWL%this . val = val;%NWL%} ;%NWL%var val = '  '  + inspect ( this . val ) ;%NWL%1
exports . assertType = function ( node , type , param ) {%NWL%exports . assertPresent ( node , param ) ;%NWL%if ( node . nodeName == type ) return;%NWL%var actual = node . nodeName%NWL%, msg = ' expected " '%NWL%+ param +  ' " to be a '%NWL%+ type +  ' , but got '%NWL%+ actual +  ' : '  + node;%NWL%throw new Error ( ' TypeError: '  + msg ) ;%NWL%} ;%NWL%exports . assertPresent ( node , param ) ;%NWL%1
var utils = require ( ' . . / utils ' )%NWL%, nodes = require ( ' . . / nodes ' )%NWL%, fs = require ( ' fs ' ) ;%NWL%var Image = module . exports = function Image ( ctx , path )  {%NWL%this . ctx = ctx;%NWL%this . path = utils . lookup ( path , ctx . paths ) ;%NWL%if ( !this . path ) throw new Error ( ' failed to locate file '  + path ) ;%NWL%} ;%NWL%this . fd = fs . openSync ( this . path ,  ' r ' ) ;%NWL%5
, unit = unitMap [ name ]%NWL%, type = typeMap [ name ]%NWL%, name = componentMap [ name ] ;%NWL%if ( !name ) throw new Error ( ' invalid color component " '  + name +  ' " ' ) ;%NWL%return new nodes . Unit ( color [ type ] [ name ] , unit ) ;%NWL%} ;%NWL%exports . basename = function basename ( p , ext ) {%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%return path . basename ( p . val , ext && ext . val ) ;%NWL%} ;%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%7
return new nodes . Unit ( color [ type ] [ name ] , unit ) ;%NWL%} ;%NWL%exports . basename = function basename ( p , ext ) {%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%return path . basename ( p . val , ext && ext . val ) ;%NWL%} ;%NWL%exports . dirname = function dirname ( p ) {%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%return path . dirname ( p . val ) ;%NWL%} ;%NWL%utils . assertString ( p ,  ' path ' ) ;%NWL%3
exports . rgba = function rgba ( red , green , blue , alpha ) {%NWL%switch ( arguments . length )  {%NWL%case 1:%NWL%utils . assertColor ( red ) ;%NWL%var color = red . rgba;%NWL%return new nodes . RGBA (%NWL%color . r%NWL%, color . g%NWL%, color . b%NWL%, color . a ) ;%NWL%utils . assertColor ( red ) ;%NWL%3
return new nodes . RGBA (%NWL%color . r%NWL%, color . g%NWL%, color . b%NWL%, color . a ) ;%NWL%case 2:%NWL%utils . assertColor ( red ) ;%NWL%var color = red . rgba;%NWL%utils . assertType ( green ,  ' unit ' ,  ' alpha ' ) ;%NWL%if ( ' % ' == green . type ) green . val / = 100;%NWL%color . r%NWL%1
expr = utils . unwrap ( expr ) ;%NWL%if ( !expr . nodes . length ) return;%NWL%console . log ( ' \033 [ 90minspect:\033 [ 0m %s ' , expr . toString ( ) . replace ( / ^\ ( |\ ) $ / g ,  ' ' ) ) ;%NWL%} )%NWL%return nodes . null;%NWL%} ) . raw = true;%NWL%exports . error = function error ( msg ) {%NWL%utils . assertType ( msg ,  ' string ' ,  ' msg ' ) ;%NWL%throw new Error ( msg . val ) ;%NWL%} ;%NWL%utils . assertType ( msg ,  ' string ' ,  ' msg ' ) ;%NWL%7
utils . assertType ( img ,  ' string ' ,  ' img ' ) ;%NWL%try {%NWL%var img = new Image ( this , img . string ) ;%NWL%} catch ( err )  {%NWL%if ( ignoreErr )  {%NWL%return [ new nodes . Unit ( 0 ) , new nodes . Unit ( 0 ) ] ;%NWL%} else {%NWL%throw err;%NWL%}%NWL%}%NWL%var size = img . size ( ) ;%NWL%2
try {%NWL%var img = new Image ( this , img . string ) ;%NWL%} catch ( err )  {%NWL%if ( ignoreErr )  {%NWL%return [ new nodes . Unit ( 0 ) , new nodes . Unit ( 0 ) ] ;%NWL%} else {%NWL%throw err;%NWL%}%NWL%}%NWL%img . open ( ) ;%NWL%img . close ( ) ;%NWL%9
var Node = require ( ' . / node ' ) ;%NWL%var Call = module . exports = function Call ( name , args ) {%NWL%Node . call ( this ) ;%NWL%this . name = name;%NWL%this . args = args;%NWL%} ;%NWL%Call . prototype . __proto__ = Node . prototype;%NWL%var clone = new Call ( this . name , this . args . clone ( ) ) ;%NWL%1
this . calloutEl = $ ( ' <div>< / div> ' ) . addClass ( this . classed +  ' performance - hidden ' ) . appendTo ( this . $el ) ;%NWL%}%NWL%} ,%NWL%onChangeSelected: function ( model , index , options )  {%NWL%var el = this . calloutEl;%NWL%if ( !model )  {%NWL%el . addClass ( ' performance - hidden ' ) ;%NWL%return;%NWL%}%NWL%options = options || { } ;%NWL%el . removeClass ( ' performance - hidden ' ) ;%NWL%6
return false;%NWL%} ,%NWL%getHeader: function ( el , model )  {%NWL%var period = this . graph . collection . query . get ( ' period ' ) || ' week ' ;%NWL%return this . formatPeriod ( model , period ) ;%NWL%} ,%NWL%getPivotingElement: function ( )  {%NWL%return this . calloutEl . find ( ' . arrow ' ) ;%NWL%} ,%NWL%renderContent: function ( el , model )  {%NWL%var arrow = $ ( ' <div> ' ) . addClass ( ' arrow ' ) . html ( ' <span class= " outer - arrow " >&#x25B2;< / span><span class= " inner - arrow " >&#x25B2;< / span> ' ) ;%NWL%3
model . get ( ' title ' )%NWL%] . join ( ' ' ) ) ;%NWL%var body = $ ( ' <dl> ' ) . html ( [%NWL%' <dt>Number of users:< / dt> ' ,%NWL%' <dd> ' ,%NWL%this . format ( val ,  { type: ' number ' , magnitude: true , pad: true } ) ,%NWL%' < / dd> ' ,%NWL%' <dt>Percentage relative to start:< / dt> ' ,%NWL%' <dd> ' ,%NWL%this . format ( val / max ,  ' percent ' ) ,%NWL%] . join ( ' ' ) ) ;%NWL%1
var Node = require ( ' . / node ' ) ;%NWL%var FontFace = module . exports = function FontFace ( block ) {%NWL%Node . call ( this ) ;%NWL%this . block = block;%NWL%} ;%NWL%FontFace . prototype . __proto__ = Node . prototype;%NWL%var clone = new FontFace ( this . block . clone ( ) ) ;%NWL%1
Function . prototype . __proto__ = Node . prototype;%NWL%Function . prototype . __defineGetter__ ( ' hash ' , function ( ) {%NWL%return ' function '  + this . name;%NWL%} ) ;%NWL%Function . prototype . clone = function ( ) {%NWL%if ( this . fn )  {%NWL%var clone = new Function (%NWL%this . name%NWL%, this . fn ) ;%NWL%} else {%NWL%this . name%NWL%7
case ' && ' :%NWL%return this . rgba . operate ( op , right ) ;%NWL%default:%NWL%return this . rgba . operate ( op , right ) . hsla;%NWL%}%NWL%} ;%NWL%exports . fromRGBA = function ( rgba ) {%NWL%var r = rgba . r / 255%NWL%, g = rgba . g / 255%NWL%, b = rgba . b / 255%NWL%var min = Math . min ( r , g , b )%NWL%7
}%NWL%h %= 360;%NWL%s * = 100;%NWL%l * = 100;%NWL%return new HSLA ( h , s , l , a ) ;%NWL%} ;%NWL%HSLA . prototype . adjustLightness = function ( percent ) {%NWL%this . l = clampPercentage ( this . l + this . l *  ( percent / 100 ) ) ;%NWL%return this;%NWL%} ;%NWL%this . h = clampDegrees ( this . h + deg ) ;%NWL%7
} else {%NWL%this . negate = negate;%NWL%}%NWL%} ;%NWL%If . prototype . __proto__ = Node . prototype;%NWL%If . prototype . clone = function ( ) {%NWL%var cond = this . cond . clone ( )%NWL%, block = this . block . clone ( ) ;%NWL%var clone = new If ( cond , block ) ;%NWL%clone . elses = this . elses . map ( function ( node ) { return node . clone ( ) ; } ) ;%NWL%clone . postfix = this . postfix;%NWL%9
this . negate = negate;%NWL%}%NWL%} ;%NWL%If . prototype . __proto__ = Node . prototype;%NWL%If . prototype . clone = function ( ) {%NWL%var cond = this . cond . clone ( )%NWL%, block = this . block . clone ( ) ;%NWL%var clone = new If ( cond , block ) ;%NWL%clone . elses = this . elses . map ( function ( node ) { return node . clone ( ) ; } ) ;%NWL%clone . negate = this . negate;%NWL%clone . lineno = this . lineno;%NWL%8
}%NWL%} ;%NWL%If . prototype . __proto__ = Node . prototype;%NWL%If . prototype . clone = function ( ) {%NWL%var cond = this . cond . clone ( )%NWL%, block = this . block . clone ( ) ;%NWL%var clone = new If ( cond , block ) ;%NWL%clone . elses = this . elses . map ( function ( node ) { return node . clone ( ) ; } ) ;%NWL%clone . negate = this . negate;%NWL%clone . postfix = this . postfix;%NWL%clone . filename = this . filename;%NWL%7
exports . Charset = require ( ' . / charset ' ) ;%NWL%exports . Import = require ( ' . / import ' ) ;%NWL%exports . Extend = require ( ' . / extend ' ) ;%NWL%exports . Function = require ( ' . / function ' ) ;%NWL%exports . Property = require ( ' . / property ' ) ;%NWL%exports . Selector = require ( ' . / selector ' ) ;%NWL%exports . Expression = require ( ' . / expression ' ) ;%NWL%exports . Arguments = require ( ' . / arguments ' ) ;%NWL%exports . MozDocument = require ( ' . / mozdocument ' ) ;%NWL%exports . true = new exports . Boolean ( true ) ;%NWL%exports . null = new exports . Null;%NWL%9
var Node = require ( ' . / node ' )%NWL%, nodes = require ( ' . / ' ) ;%NWL%var Return = module . exports = function Return ( expr ) {%NWL%this . expr = expr || nodes . null;%NWL%} ;%NWL%Return . prototype . __proto__ = Node . prototype;%NWL%var clone = new Return ( this . expr . clone ( ) ) ;%NWL%2
var Node = require ( ' . / node ' ) ;%NWL%var UnaryOp = module . exports = function UnaryOp ( op , expr ) {%NWL%Node . call ( this ) ;%NWL%this . op = op;%NWL%this . expr = expr;%NWL%} ;%NWL%UnaryOp . prototype . __proto__ = Node . prototype;%NWL%var clone = new UnaryOp ( this . op , this . expr . clone ( ) ) ;%NWL%1
define ( [%NWL%' extensions / collections / collection '%NWL%] ,%NWL%function ( Collection )  {%NWL%var CompletionCollection = Collection . extend ( {%NWL%initialize: function ( models , options )  {%NWL%this . options = options || { } ;%NWL%this . numeratorMatcher = options . numeratorMatcher;%NWL%6
define ( [%NWL%' extensions / collections / collection '%NWL%] ,%NWL%function ( Collection )  {%NWL%var CompletionCollection = Collection . extend ( {%NWL%initialize: function ( models , options )  {%NWL%this . options = options || { } ;%NWL%this . denominatorMatcher = options . denominatorMatcher;%NWL%this . matchingAttribute = options . matchingAttribute;%NWL%6
case ' print ' :%NWL%case ' page ' :%NWL%case ' block ' :%NWL%case ' keyframes ' :%NWL%if ( this . linenos || this . firebug ) this . debugInfo ( node ) ;%NWL%this . visit ( node ) ;%NWL%break;%NWL%case ' media ' :%NWL%case ' mozdocument ' :%NWL%case ' import ' :%NWL%this . visit ( node ) ;%NWL%5
node . nodes . map ( cloneNode ) ;%NWL%}%NWL%return node;%NWL%}%NWL%var Evaluator = module . exports = function Evaluator ( root , options )  {%NWL%options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . paths = options . paths || [ ] ;%NWL%8
}%NWL%return node;%NWL%}%NWL%var Evaluator = module . exports = function Evaluator ( root , options )  {%NWL%options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . globals = options . globals || { } ;%NWL%this . filename = options . filename;%NWL%7
var Evaluator = module . exports = function Evaluator ( root , options )  {%NWL%options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . globals = options . globals || { } ;%NWL%this . paths = options . paths || [ ] ;%NWL%this . filename = options . filename;%NWL%this . includeCSS = options [ ' include css ' ] ;%NWL%this . stack . push ( this . global = new Frame ( root ) ) ;%NWL%4
options = options || { } ;%NWL%Visitor . call ( this , root ) ;%NWL%this . stack = new Stack;%NWL%this . imports = options . imports || [ ] ;%NWL%this . functions = options . functions || { } ;%NWL%this . globals = options . globals || { } ;%NWL%this . paths = options . paths || [ ] ;%NWL%this . filename = options . filename;%NWL%this . includeCSS = options [ ' include css ' ] ;%NWL%this . paths . push ( dirname ( options . filename || ' . ' ) ) ;%NWL%this . warnings = options . warn;%NWL%3
Evaluator . prototype . evaluate = function ( ) {%NWL%debug ( ' eval %s ' , this . filename ) ;%NWL%this . setup ( ) ;%NWL%return this . visit ( this . root ) ;%NWL%} ;%NWL%Evaluator . prototype . visitGroup = function ( group ) {%NWL%group . nodes = group . nodes . map ( function ( selector ) {%NWL%selector . val = this . interpolate ( selector ) ;%NWL%debug ( ' ruleset %s ' , selector . val ) ;%NWL%return selector;%NWL%group . block = this . visit ( group . block ) ;%NWL%6
return val ? this . visit ( val ) : ident;%NWL%} else {%NWL%this . return + + ;%NWL%ident . val = this . visit ( ident . val ) ;%NWL%this . return - - ;%NWL%this . currentScope . add ( ident ) ;%NWL%return ident . val;%NWL%}%NWL%} ;%NWL%Evaluator . prototype . visitBinOp = function ( binop ) {%NWL%this . return + + ;%NWL%2
this . return - - ;%NWL%this . currentScope . add ( ident ) ;%NWL%return ident . val;%NWL%}%NWL%} ;%NWL%Evaluator . prototype . visitBinOp = function ( binop ) {%NWL%if ( ' is defined ' == binop . op ) return this . isDefined ( binop . left ) ;%NWL%this . return + + ;%NWL%var op = binop . op%NWL%, left = this . visit ( binop . left )%NWL%this . return - - ;%NWL%0
this . currentScope . add ( ident ) ;%NWL%return ident . val;%NWL%}%NWL%} ;%NWL%Evaluator . prototype . visitBinOp = function ( binop ) {%NWL%if ( ' is defined ' == binop . op ) return this . isDefined ( binop . left ) ;%NWL%this . return + + ;%NWL%var op = binop . op%NWL%, left = this . visit ( binop . left )%NWL%, right = this . visit ( binop . right ) ;%NWL%var val = binop . val%NWL%7
Evaluator . prototype . visitRoot = function ( block ) {%NWL%for ( var i = 0; i < block . nodes . length; + + i )  {%NWL%block . index = this . rootIndex = i;%NWL%block . nodes [ i ] = this . visit ( block . nodes [ i ] ) ;%NWL%}%NWL%return block;%NWL%} ;%NWL%Evaluator . prototype . visitBlock = function ( block ) {%NWL%this . stack . push ( new Frame ( block ) ) ;%NWL%for ( block . index = 0; block . index < block . nodes . length; + + block . index )  {%NWL%block . nodes [ block . index ] = this . visit ( block . nodes [ block . index ] ) ;%NWL%3
Evaluator . prototype . visitBlock = function ( block ) {%NWL%this . stack . push ( new Frame ( block ) ) ;%NWL%for ( block . index = 0; block . index < block . nodes . length; + + block . index )  {%NWL%try {%NWL%block . nodes [ block . index ] = this . visit ( block . nodes [ block . index ] ) ;%NWL%} catch ( err )  {%NWL%if ( ' return ' == err . nodeName )  {%NWL%if ( this . return )  {%NWL%this . stack . pop ( ) ;%NWL%throw err;%NWL%block . nodes [ block . index ] = err;%NWL%4
this . stack . pop ( ) ;%NWL%throw err;%NWL%} else {%NWL%block . nodes [ block . index ] = err;%NWL%break;%NWL%}%NWL%} else {%NWL%throw err;%NWL%}%NWL%}%NWL%this . stack . pop ( ) ;%NWL%0
}%NWL%return ret || nodes . null;%NWL%} ;%NWL%Evaluator . prototype . visitExtend = function ( extend ) {%NWL%var selector = this . interpolate ( extend . selector . clone ( ) ) ;%NWL%var block = !this . currentBlock . node . extends && this . targetBlock . node . extends ? this . targetBlock : this . currentBlock;%NWL%block . node . extends . push ( selector ) ;%NWL%return nodes . null;%NWL%} ;%NWL%Evaluator . prototype . visitImport = function ( imported ) {%NWL%var root = this . root%NWL%4
case ' jsliteral ' :%NWL%case ' group ' :%NWL%case ' unit ' :%NWL%continue;%NWL%default:%NWL%ret . push ( this . visit ( node ) ) ;%NWL%}%NWL%}%NWL%}%NWL%for ( var i = 0 , len = block . nodes . length; i < len; + + i )  {%NWL%ret . push ( this . visit ( node ) ) ;%NWL%5
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSFontFaceRule = function CSSFontFaceRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%CSSOM . CSSFontFaceRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSFontFaceRule = function CSSFontFaceRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSFontFaceRule . prototype . constructor = CSSOM . CSSFontFaceRule;%NWL%4
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSFontFaceRule = function CSSFontFaceRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSFontFaceRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSFontFaceRule . prototype . type = 5;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleSheet: require ( " . / CSSStyleSheet " ) . CSSStyleSheet ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSImportRule = function CSSImportRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . href = " " ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . styleSheet = new CSSOM . CSSStyleSheet;%NWL%CSSOM . CSSImportRule . prototype = new CSSOM . CSSRule;%NWL%5
CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleSheet: require ( " . / CSSStyleSheet " ) . CSSStyleSheet ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSImportRule = function CSSImportRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . href = " " ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . styleSheet = new CSSOM . CSSStyleSheet;%NWL%} ;%NWL%CSSOM . CSSImportRule . prototype . constructor = CSSOM . CSSImportRule;%NWL%4
CSSStyleSheet: require ( " . / CSSStyleSheet " ) . CSSStyleSheet ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSImportRule = function CSSImportRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . href = " " ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . styleSheet = new CSSOM . CSSStyleSheet;%NWL%} ;%NWL%CSSOM . CSSImportRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSImportRule . prototype . type = 3;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleDeclaration: require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration%NWL%} ;%NWL%CSSOM . CSSKeyframeRule = function CSSKeyframeRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . keyText = ' ' ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%CSSOM . CSSKeyframeRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleDeclaration: require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration%NWL%} ;%NWL%CSSOM . CSSKeyframeRule = function CSSKeyframeRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . keyText = ' ' ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSKeyframeRule . prototype . constructor = CSSOM . CSSKeyframeRule;%NWL%4
CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%CSSStyleDeclaration: require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration%NWL%} ;%NWL%CSSOM . CSSKeyframeRule = function CSSKeyframeRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . keyText = ' ' ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSKeyframeRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSKeyframeRule . prototype . type = 9;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSKeyframesRule = function CSSKeyframesRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . name = ' ' ;%NWL%this . cssRules = [ ] ;%NWL%CSSOM . CSSKeyframesRule . prototype = new CSSOM . CSSRule;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSKeyframesRule = function CSSKeyframesRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . name = ' ' ;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSKeyframesRule . prototype . constructor = CSSOM . CSSKeyframesRule;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSKeyframesRule = function CSSKeyframesRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . name = ' ' ;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSKeyframesRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSKeyframesRule . prototype . type = 8;%NWL%3
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSMediaRule = function CSSMediaRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . cssRules = [ ] ;%NWL%CSSOM . CSSMediaRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSMediaRule = function CSSMediaRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSMediaRule . prototype . constructor = CSSOM . CSSMediaRule;%NWL%4
var CSSOM = {%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule ,%NWL%MediaList: require ( " . / MediaList " ) . MediaList%NWL%} ;%NWL%CSSOM . CSSMediaRule = function CSSMediaRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . media = new CSSOM . MediaList;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSMediaRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSMediaRule . prototype . type = 4;%NWL%4
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . FONT_FACE_RULE = 5;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%CSSOM . CSSRule . PAGE_RULE = 6;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%CSSOM . CSSRule . FONT_FACE_RULE = 5;%NWL%CSSOM . CSSRule . WEBKIT_KEYFRAMES_RULE = 8;%NWL%1
var CSSOM = { } ;%NWL%CSSOM . CSSRule = function CSSRule ( )  {%NWL%this . parentRule = null;%NWL%this . parentStyleSheet = null;%NWL%} ;%NWL%CSSOM . CSSRule . STYLE_RULE = 1;%NWL%CSSOM . CSSRule . IMPORT_RULE = 3;%NWL%CSSOM . CSSRule . MEDIA_RULE = 4;%NWL%CSSOM . CSSRule . FONT_FACE_RULE = 5;%NWL%CSSOM . CSSRule . PAGE_RULE = 6;%NWL%CSSOM . CSSRule . WEBKIT_KEYFRAME_RULE = 9;%NWL%1
} ,%NWL%%NWL%setProperty: function ( name , value , priority )  {%NWL%if ( this [ name ] )  {%NWL%var index = Array . prototype . indexOf . call ( this , name ) ;%NWL%if ( index < 0 )  {%NWL%this [ this . length ] = name;%NWL%this . length + + ;%NWL%}%NWL%} else {%NWL%this . length + + ;%NWL%7
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSStyleRule = function CSSStyleRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . selectorText = " " ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%CSSOM . CSSStyleRule . prototype = new CSSOM . CSSRule;%NWL%4
var CSSOM = {%NWL%CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSStyleRule = function CSSStyleRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . selectorText = " " ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSStyleRule . prototype . constructor = CSSOM . CSSStyleRule;%NWL%4
CSSStyleDeclaration: require ( " . / CSSStyleDeclaration " ) . CSSStyleDeclaration ,%NWL%CSSRule: require ( " . / CSSRule " ) . CSSRule%NWL%} ;%NWL%CSSOM . CSSStyleRule = function CSSStyleRule ( )  {%NWL%CSSOM . CSSRule . call ( this ) ;%NWL%this . selectorText = " " ;%NWL%this . style = new CSSOM . CSSStyleDeclaration;%NWL%this . style . parentRule = this;%NWL%} ;%NWL%CSSOM . CSSStyleRule . prototype = new CSSOM . CSSRule;%NWL%CSSOM . CSSStyleRule . prototype . type = 1;%NWL%3
if ( state === " value " )  {%NWL%styleRule . style . setProperty ( name , buffer . trim ( ) , priority ) ;%NWL%priority = " " ;%NWL%buffer = " " ;%NWL%state = " name " ;%NWL%} else {%NWL%buffer + = character;%NWL%}%NWL%break;%NWL%case " } " :%NWL%styleRule . style . setProperty ( name , buffer . trim ( ) , priority ) ;%NWL%1
var CSSOM = {%NWL%StyleSheet: require ( " . / StyleSheet " ) . StyleSheet ,%NWL%CSSStyleRule: require ( " . / CSSStyleRule " ) . CSSStyleRule%NWL%} ;%NWL%CSSOM . CSSStyleSheet = function CSSStyleSheet ( )  {%NWL%CSSOM . StyleSheet . call ( this ) ;%NWL%this . cssRules = [ ] ;%NWL%CSSOM . CSSStyleSheet . prototype = new CSSOM . StyleSheet;%NWL%4
var CSSOM = {%NWL%StyleSheet: require ( " . / StyleSheet " ) . StyleSheet ,%NWL%CSSStyleRule: require ( " . / CSSStyleRule " ) . CSSStyleRule%NWL%} ;%NWL%CSSOM . CSSStyleSheet = function CSSStyleSheet ( )  {%NWL%CSSOM . StyleSheet . call ( this ) ;%NWL%this . cssRules = [ ] ;%NWL%} ;%NWL%CSSOM . CSSStyleSheet . prototype . constructor = CSSOM . CSSStyleSheet;%NWL%4
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%1
' use strict ' ;%NWL%exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%exports . CSSKeyframeRule = require ( ' . / CSSKeyframeRule ' ) . CSSKeyframeRule;%NWL%1
exports . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%exports . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%exports . parse = require ( ' . / parse ' ) . parse;%NWL%0
exports . CSSRule = require ( ' . / CSSRule ' ) . CSSRule;%NWL%exports . CSSStyleRule = require ( ' . / CSSStyleRule ' ) . CSSStyleRule;%NWL%exports . MediaList = require ( ' . / MediaList ' ) . MediaList;%NWL%exports . CSSMediaRule = require ( ' . / CSSMediaRule ' ) . CSSMediaRule;%NWL%exports . CSSImportRule = require ( ' . / CSSImportRule ' ) . CSSImportRule;%NWL%exports . CSSFontFaceRule = require ( ' . / CSSFontFaceRule ' ) . CSSFontFaceRule;%NWL%exports . StyleSheet = require ( ' . / StyleSheet ' ) . StyleSheet;%NWL%exports . CSSStyleSheet = require ( ' . / CSSStyleSheet ' ) . CSSStyleSheet;%NWL%exports . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%exports . CSSKeyframeRule = require ( ' . / CSSKeyframeRule ' ) . CSSKeyframeRule;%NWL%exports . clone = require ( ' . / clone ' ) . clone;%NWL%0
break;%NWL%}%NWL%buffer + = character;%NWL%break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%9
}%NWL%buffer + = character;%NWL%break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%8
buffer + = character;%NWL%break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSFontFaceRule = require ( " . / CSSFontFaceRule " ) . CSSFontFaceRule;%NWL%7
break;%NWL%}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%CSSOM . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%6
}%NWL%}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%CSSOM . CSSFontFaceRule = require ( " . / CSSFontFaceRule " ) . CSSFontFaceRule;%NWL%CSSOM . CSSKeyframeRule = require ( ' . / CSSKeyframeRule ' ) . CSSKeyframeRule;%NWL%5
}%NWL%return styleSheet;%NWL%} ;%NWL%exports . parse = CSSOM . parse;%NWL%CSSOM . CSSStyleSheet = require ( " . / CSSStyleSheet " ) . CSSStyleSheet;%NWL%CSSOM . CSSStyleRule = require ( " . / CSSStyleRule " ) . CSSStyleRule;%NWL%CSSOM . CSSImportRule = require ( " . / CSSImportRule " ) . CSSImportRule;%NWL%CSSOM . CSSMediaRule = require ( " . / CSSMediaRule " ) . CSSMediaRule;%NWL%CSSOM . CSSFontFaceRule = require ( " . / CSSFontFaceRule " ) . CSSFontFaceRule;%NWL%CSSOM . CSSStyleDeclaration = require ( ' . / CSSStyleDeclaration ' ) . CSSStyleDeclaration;%NWL%CSSOM . CSSKeyframesRule = require ( ' . / CSSKeyframesRule ' ) . CSSKeyframesRule;%NWL%4
var ms = curr -  ( prev [ name ] || curr ) ;%NWL%prev [ name ] = curr;%NWL%fmt = '  \u001b [ 9 '  + c +  ' m '  + name +  '  '%NWL%+  ' \u001b [ 3 '  + c +  ' m\u001b [ 90m '%NWL%+ fmt +  ' \u001b [ 3 '  + c +  ' m '%NWL%+  '  + '  + humanize ( ms )  +  ' \u001b [ 0m ' ;%NWL%console . error . apply ( this , arguments ) ;%NWL%}%NWL%function plain ( fmt )  {%NWL%fmt = new Date ( ) . toUTCString ( )%NWL%console . error . apply ( this , arguments ) ;%NWL%6
t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' chmod ' , function ( t )  {%NWL%var mode = 0755%NWL%mkdirp ( file , mode , function ( er )  {%NWL%t . ifError ( er ,  ' should not error ' ) ;%NWL%fs . stat ( file , function ( er , stat )  {%NWL%t . ifError ( er ,  ' should exist ' ) ;%NWL%t . end ( ) ;%NWL%0
t . equal ( stat . mode & 0777 , 0755 ) ;%NWL%t . ok ( stat . isDirectory ( ) ,  ' target not a directory ' ) ;%NWL%t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%t . end ( ) ;%NWL%2
t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%if ( err ) t . fail ( err ) ;%NWL%t . end ( ) ;%NWL%t . end ( ) ;%NWL%0
var mkdirp = require ( ' . . / ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%test ( ' rel ' , function ( t )  {%NWL%t . plan ( 2 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var cwd = process . cwd ( ) ;%NWL%1
var test = require ( ' tap ' ) . test;%NWL%test ( ' return value ' , function ( t )  {%NWL%t . plan ( 4 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var file = ' / tmp / '  +  [ x , y , z ] . join ( ' / ' ) ;%NWL%mkdirp ( file , function ( err , made )  {%NWL%t . ifError ( err ) ;%NWL%t . equal ( made ,  ' / tmp / '  + x ) ;%NWL%t . ifError ( err ) ;%NWL%8
' use strict ' ;%NWL%module . exports = function ( grunt )  {%NWL%grunt . registerMultiTask ( ' stylus ' ,  ' Compile Stylus files into CSS ' , function ( )  {%NWL%var done = this . async ( ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var options = this . options ( {%NWL%banner: ' ' ,%NWL%compress: true%NWL%var banner = grunt . template . process ( options . banner ) ;%NWL%4
var expected = readFile ( ' test / expected / stylus . css ' ) ;%NWL%test . equal ( expected , actual ,  ' should compile stylus to css , handling includes and compression ' ) ;%NWL%actual = readFile ( ' tmp / concat . css ' ) ;%NWL%expected = readFile ( ' test / expected / concat . css ' ) ;%NWL%test . equal ( expected , actual ,  ' should concat output when passed an array ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%nib: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / nib_ / nib_ . css ' ) ;%NWL%0
actual = readFile ( ' tmp / concat . css ' ) ;%NWL%expected = readFile ( ' test / expected / concat . css ' ) ;%NWL%test . equal ( expected , actual ,  ' should concat output when passed an array ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%nib: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / nib_ . css ' ) ;%NWL%var expected = readFile ( ' test / expected / nib_ / nib_ . css ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%nib: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / nib_ . css ' ) ;%NWL%var expected = readFile ( ' test / expected / nib_ / nib_ . css ' ) ;%NWL%test . equal ( expected , actual ,  ' Nib should be available to include ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%autocompress: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%3
' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / nib_ . css ' ) ;%NWL%var expected = readFile ( ' test / expected / nib_ / nib_ . css ' ) ;%NWL%test . equal ( expected , actual ,  ' Nib should be available to include ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%autocompress: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / autocompress . css ' ) ;%NWL%3
var actual = readFile ( ' tmp / nib_ . css ' ) ;%NWL%var expected = readFile ( ' test / expected / nib_ / nib_ . css ' ) ;%NWL%test . equal ( expected , actual ,  ' Nib should be available to include ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%autocompress: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / autocompress . css ' ) ;%NWL%var expected = readFile ( ' test / expected / autocompress . css ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%autocompress: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / autocompress . css ' ) ;%NWL%var expected = readFile ( ' test / expected / autocompress . css ' ) ;%NWL%test . equal ( expected , actual ,  ' output should be compressed when `compress` option not defined ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%plugin: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%3
' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / autocompress . css ' ) ;%NWL%var expected = readFile ( ' test / expected / autocompress . css ' ) ;%NWL%test . equal ( expected , actual ,  ' output should be compressed when `compress` option not defined ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%plugin: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / plugin / plugin . css ' ) ;%NWL%3
var actual = readFile ( ' tmp / autocompress . css ' ) ;%NWL%var expected = readFile ( ' test / expected / autocompress . css ' ) ;%NWL%test . equal ( expected , actual ,  ' output should be compressed when `compress` option not defined ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%plugin: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / plugin . css ' ) ;%NWL%var expected = readFile ( ' test / expected / plugin / plugin . css ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%plugin: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / plugin . css ' ) ;%NWL%var expected = readFile ( ' test / expected / plugin / plugin . css ' ) ;%NWL%test . equal ( expected , actual ,  ' variable defined via plugin should be accessible in stylesheet ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%embedurl: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%3
' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / plugin . css ' ) ;%NWL%var expected = readFile ( ' test / expected / plugin / plugin . css ' ) ;%NWL%test . equal ( expected , actual ,  ' variable defined via plugin should be accessible in stylesheet ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%embedurl: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / embedurl / embedurl . css ' ) ;%NWL%3
var actual = readFile ( ' tmp / plugin . css ' ) ;%NWL%var expected = readFile ( ' test / expected / plugin / plugin . css ' ) ;%NWL%test . equal ( expected , actual ,  ' variable defined via plugin should be accessible in stylesheet ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%embedurl: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / embedurl . css ' ) ;%NWL%var expected = readFile ( ' test / expected / embedurl / embedurl . css ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%embedurl: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / embedurl . css ' ) ;%NWL%var expected = readFile ( ' test / expected / embedurl / embedurl . css ' ) ;%NWL%test . equal ( expected , actual ,  ' `embedurl` mixin should embed image as Data URI ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%relative: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%3
' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / embedurl . css ' ) ;%NWL%var expected = readFile ( ' test / expected / embedurl / embedurl . css ' ) ;%NWL%test . equal ( expected , actual ,  ' `embedurl` mixin should embed image as Data URI ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%relative: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / relative / relative . css ' ) ;%NWL%3
var actual = readFile ( ' tmp / embedurl . css ' ) ;%NWL%var expected = readFile ( ' test / expected / embedurl / embedurl . css ' ) ;%NWL%test . equal ( expected , actual ,  ' `embedurl` mixin should embed image as Data URI ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%relative: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / relative . css ' ) ;%NWL%var expected = readFile ( ' test / expected / relative / relative . css ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%relative: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / relative . css ' ) ;%NWL%var expected = readFile ( ' test / expected / relative / relative . css ' ) ;%NWL%test . equal ( expected , actual ,  ' import of relative paths should work without `paths` option ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%import: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%3
' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / relative . css ' ) ;%NWL%var expected = readFile ( ' test / expected / relative / relative . css ' ) ;%NWL%test . equal ( expected , actual ,  ' import of relative paths should work without `paths` option ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%import: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / import / import . css ' ) ;%NWL%3
var actual = readFile ( ' tmp / relative . css ' ) ;%NWL%var expected = readFile ( ' test / expected / relative / relative . css ' ) ;%NWL%test . equal ( expected , actual ,  ' import of relative paths should work without `paths` option ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%import: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / import . css ' ) ;%NWL%var expected = readFile ( ' test / expected / import / import . css ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%import: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / import . css ' ) ;%NWL%var expected = readFile ( ' test / expected / import / import . css ' ) ;%NWL%test . equal ( expected , actual ,  ' import option should make imported packages available to each compiled styl file ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%define: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%3
' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / import . css ' ) ;%NWL%var expected = readFile ( ' test / expected / import / import . css ' ) ;%NWL%test . equal ( expected , actual ,  ' import option should make imported packages available to each compiled styl file ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%define: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / define / define . css ' ) ;%NWL%3
var actual = readFile ( ' tmp / import . css ' ) ;%NWL%var expected = readFile ( ' test / expected / import / import . css ' ) ;%NWL%test . equal ( expected , actual ,  ' import option should make imported packages available to each compiled styl file ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%define: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / define . css ' ) ;%NWL%var expected = readFile ( ' test / expected / define / define . css ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%define: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / define . css ' ) ;%NWL%var expected = readFile ( ' test / expected / define / define . css ' ) ;%NWL%test . equal ( expected , actual ,  ' variables defined via define object in options should be accessible in stylesheet ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%banner: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%3
' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / define . css ' ) ;%NWL%var expected = readFile ( ' test / expected / define / define . css ' ) ;%NWL%test . equal ( expected , actual ,  ' variables defined via define object in options should be accessible in stylesheet ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%banner: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var expected = readFile ( ' test / expected / banner / banner . css ' ) ;%NWL%3
var actual = readFile ( ' tmp / define . css ' ) ;%NWL%var expected = readFile ( ' test / expected / define / define . css ' ) ;%NWL%test . equal ( expected , actual ,  ' variables defined via define object in options should be accessible in stylesheet ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%banner: function ( test )  {%NWL%' use strict ' ;%NWL%test . expect ( 1 ) ;%NWL%var actual = readFile ( ' tmp / banner . css ' ) ;%NWL%var expected = readFile ( ' test / expected / banner / banner . css ' ) ;%NWL%test . done ( ) ;%NWL%3
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%1
' use strict ' ;%NWL%var util = require ( ' util ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var util = require ( ' util ' ) ;%NWL%var EE = require ( ' events ' ) . EventEmitter;%NWL%var path = require ( ' path ' ) ;%NWL%1
' use strict ' ;%NWL%var util = require ( ' util ' ) ;%NWL%var EE = require ( ' events ' ) . EventEmitter;%NWL%var fs = require ( ' fs ' ) ;%NWL%var globule = require ( ' globule ' ) ;%NWL%1
' use strict ' ;%NWL%var util = require ( ' util ' ) ;%NWL%var EE = require ( ' events ' ) . EventEmitter;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
function Gaze ( patterns , opts , done )  {%NWL%var self = this;%NWL%EE . call ( self ) ;%NWL%if ( typeof opts === ' function ' )  {%NWL%done = opts;%NWL%opts = { } ;%NWL%}%NWL%opts = opts || { } ;%NWL%opts . mark = true;%NWL%opts . interval = opts . interval || 100;%NWL%opts . cwd = opts . cwd || process . cwd ( ) ;%NWL%9
' extensions / models / data_source ' ,%NWL%' moment - timezone '%NWL%] ,%NWL%function ( GroupedCollection , DataSource , moment )  {%NWL%var format = ' YYYY - MM - DD [ T ] HH:mm:ss ' ;%NWL%return GroupedCollection . extend ( {%NWL%queryParams: function ( )  {%NWL%var params = { } ;%NWL%var options = this . dataSource . get ( ' query - params ' ) ;%NWL%params . duration = this . duration ( ) ;%NWL%params . start_at = moment ( options . startAt ) . subtract ( this . timeshift ( ) , this . getPeriod ( ) ) . format ( format ) ;%NWL%9
' moment - timezone '%NWL%] ,%NWL%function ( GroupedCollection , DataSource , moment )  {%NWL%var format = ' YYYY - MM - DD [ T ] HH:mm:ss ' ;%NWL%return GroupedCollection . extend ( {%NWL%queryParams: function ( )  {%NWL%var params = { } ;%NWL%var options = this . dataSource . get ( ' query - params ' ) ;%NWL%params . duration = this . duration ( ) ;%NWL%if ( options . startAt )  {%NWL%params . duration = this . standardDuration ( ) ;%NWL%8
' use strict ' ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var glob = require ( ' glob ' ) ;%NWL%1
' use strict ' ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var _ = require ( ' lodash ' ) ;%NWL%var minimatch = require ( ' minimatch ' ) ;%NWL%1
}%NWL%options = options || { }%NWL%this . EOF = { }%NWL%this . _emitQueue = [ ]%NWL%this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%this . cwd = options . cwd%NWL%4
options = options || { }%NWL%this . EOF = { }%NWL%this . _emitQueue = [ ]%NWL%this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%3
this . _emitQueue = [ ]%NWL%this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%this . root = options . root || path . resolve ( this . cwd ,  " / " )%NWL%1
this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%}%NWL%this . root = path . resolve ( this . root )%NWL%0
this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%}%NWL%this . root = options . root || path . resolve ( this . cwd ,  " / " )%NWL%this . root = path . resolve ( this . root )%NWL%this . root = this . root . replace ( / \\ / g ,  " / " )%NWL%0
this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%}%NWL%this . root = options . root || path . resolve ( this . cwd ,  " / " )%NWL%this . root = path . resolve ( this . root )%NWL%if ( process . platform === " win32 " )%NWL%this . nomount = !!options . nomount%NWL%4
this . root = this . root . replace ( / \\ / g ,  " / " )%NWL%this . nomount = !!options . nomount%NWL%if ( !pattern )  {%NWL%throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%this . strict = options . strict !== false%NWL%0
this . nomount = !!options . nomount%NWL%if ( !pattern )  {%NWL%throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . dot = !!options . dot%NWL%0
if ( !pattern )  {%NWL%throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . mark = !!options . mark%NWL%9
throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . sync = !!options . sync%NWL%8
}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . nounique = !!options . nounique%NWL%7
if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nonull = !!options . nonull%NWL%6
if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nosort = !!options . nosort%NWL%5
throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nocase = !!options . nocase%NWL%4
}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . stat = !!options . stat%NWL%3
pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%2
this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%this . log = console . error%NWL%0
this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if ( this . debug )%NWL%this . silent = !!options . silent%NWL%0
this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if ( this . debug )%NWL%this . log = console . error%NWL%this . silent = !!options . silent%NWL%this . options = mm . options%NWL%0
}%NWL%Glob . prototype . pause = function ( )  {%NWL%if ( this . paused ) return%NWL%if ( this . sync )%NWL%this . emit ( " error " , new Error ( " Can ' t pause / resume sync glob " ) )%NWL%this . paused = true%NWL%this . emit ( " pause " )%NWL%}%NWL%Glob . prototype . resume = function ( )  {%NWL%if ( !this . paused ) return%NWL%this . emit ( " error " , new Error ( " Can ' t pause / resume sync glob " ) )%NWL%4
}%NWL%Glob . prototype . resume = function ( )  {%NWL%if ( !this . paused ) return%NWL%if ( this . sync )%NWL%this . emit ( " error " , new Error ( " Can ' t pause / resume sync glob " ) )%NWL%this . paused = false%NWL%this . emit ( " resume " )%NWL%this . _processEmitQueue ( )%NWL%}%NWL%Glob . prototype . emitMatch = function ( m )  {%NWL%this . _processEmitQueue ( )%NWL%7
function open ( path , flags , mode , cb )  {%NWL%cb = cb || noop%NWL%fs . _curOpen + +%NWL%fs . _originalFs . open . call ( fs , path , flags , mode , function ( er , fd )  {%NWL%if ( er ) onclose ( )%NWL%cb ( er , fd )%NWL%} )%NWL%}%NWL%fs . openSync = function ( path , flags , mode )  {%NWL%var ret%NWL%fs . _curOpen + +%NWL%2
}%NWL%fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%9
fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%8
return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%7
}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . lchownSync = chownFixSync ( fs . lchownSync )%NWL%6
if ( !er || ( !process . getuid || process . getuid ( ) !== 0 )%NWL%&& ( er . code === " EINVAL " || er . code === " EPERM " ) ) return true%NWL%}%NWL%if ( !fs . lchmod )  {%NWL%fs . lchmod = function ( path , mode , cb )  {%NWL%process . nextTick ( cb )%NWL%}%NWL%fs . lchmodSync = function ( )  { }%NWL%}%NWL%if ( !fs . lchown )  {%NWL%process . nextTick ( cb )%NWL%5
t . notEqual ( fs , require ( ' fs ' ) )%NWL%t . end ( )%NWL%} )%NWL%test ( ' open an existing file works ' , function ( t )  {%NWL%var start = fs . _curOpen%NWL%var fd = fs . openSync ( __filename ,  ' r ' )%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . closeSync ( fd )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( __filename ,  ' r ' , function ( er , fd )  {%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%6
test ( ' open an existing file works ' , function ( t )  {%NWL%var start = fs . _curOpen%NWL%var fd = fs . openSync ( __filename ,  ' r ' )%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . closeSync ( fd )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( __filename ,  ' r ' , function ( er , fd )  {%NWL%if ( er ) throw er%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . close ( fd , function ( er )  {%NWL%t . equal ( fs . _curOpen , start )%NWL%5
var er%NWL%try {%NWL%var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%t . ok ( er ,  ' should throw ' )%NWL%6
try {%NWL%var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%6
var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%6
} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%6
var test = require ( ' tap ' ) . test%NWL%var fs = require ( ' . . / graceful - fs . js ' )%NWL%0
var mkdirp = require ( " mkdirp " )%NWL%var path = require ( " path " )%NWL%var tap = require ( " tap " )%NWL%0
var mkdirp = require ( " mkdirp " )%NWL%var path = require ( " path " )%NWL%var i = 0%NWL%var fs = require ( " fs " )%NWL%0
var mkdirp = require ( " mkdirp " )%NWL%var path = require ( " path " )%NWL%var i = 0%NWL%var tap = require ( " tap " )%NWL%var rimraf = require ( " rimraf " )%NWL%0
bashOutput [ pattern ] = out%NWL%t . notOk ( code ,  " bash test should finish nicely " )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%} )%NWL%tap . test ( " save fixtures " , function ( t )  {%NWL%var fname = path . resolve ( __dirname ,  " bash - results . json " )%NWL%var data = JSON . stringify ( bashOutput , null , 2 )  +  " \n "%NWL%fs . writeFile ( fname , data , function ( er )  {%NWL%t . end ( )%NWL%2
glob ( pattern , function ( er , matches )  {%NWL%if ( er )%NWL%throw er%NWL%matches = cleanResults ( matches )%NWL%t . deepEqual ( matches , expect , pattern )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%tap . test ( pattern +  " sync " , function ( t )  {%NWL%var matches = cleanResults ( glob . sync ( pattern ) )%NWL%t . end ( )%NWL%5
var tap = require ( " tap " )%NWL%var origCwd = process . cwd ( )%NWL%process . chdir ( __dirname )%NWL%tap . test ( " changing cwd and searching for * * / d " , function ( t )  {%NWL%var path = require ( ' path ' )%NWL%0
var glob = require ( ' . . / ' )%NWL%var path = require ( ' path ' )%NWL%t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' b / c / d ' ,  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
t . test ( ' a ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' b / c / d ' ,  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%4
t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' . ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd: process . cwd ( ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd: process . cwd ( ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%t . end ( )%NWL%6
t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd: process . cwd ( ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%process . chdir ( origCwd )%NWL%t . end ( )%NWL%t . end ( )%NWL%4
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%var stat = fs . stat%NWL%0
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%test ( ' mock fs ' , function ( t )  {%NWL%var statSync = fs . statSync%NWL%0
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%test ( ' mock fs ' , function ( t )  {%NWL%var stat = fs . stat%NWL%var readdir = fs . readdir%NWL%0
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%test ( ' mock fs ' , function ( t )  {%NWL%var stat = fs . stat%NWL%var statSync = fs . statSync%NWL%var readdirSync = fs . readdirSync%NWL%0
' / tmp / A ' ,%NWL%' / tmp / a '  ]%NWL%glob ( ' / tmp / a ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%throw er%NWL%t . same ( res . sort ( ) , want )%NWL%if ( - - n === 0 ) t . end ( )%NWL%} )%NWL%glob ( ' / tmp / A ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%t . same ( res . sort ( ) , want )%NWL%5
' / tMp / a ' ,%NWL%' / tmp / A ' ,%NWL%' / tmp / a '  ]%NWL%glob ( ' / tmp / * ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%throw er%NWL%t . same ( res . sort ( ) , want )%NWL%} )%NWL%glob ( ' / tmp / * ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%t . same ( res . sort ( ) , want )%NWL%6
var tap = require ( " tap " )%NWL%var origCwd = process . cwd ( )%NWL%process . chdir ( __dirname )%NWL%tap . test ( " changing root and searching for / b * * * ' ,  { globDebug: true , root: ' . ' , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [ ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
process . chdir ( __dirname )%NWL%tap . test ( " changing root and searching for / b * * * ' ,  { globDebug: true , root: ' . ' , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [ ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' / b * * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' ) , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' / b * * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' ) , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%t . end ( )%NWL%6
t . test ( ' a ' , function ( t )  {%NWL%glob ( ' / b * * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' ) , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%process . chdir ( origCwd )%NWL%t . end ( )%NWL%t . end ( )%NWL%4
} )%NWL%t . like ( matches , wanted )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' root=a , cwd=a / b ' , function ( t )  {%NWL%glob ( ' / b * / * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' )  } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] . map ( function ( m )  {%NWL%return path . join ( path . resolve ( ' a ' ) , m ) . replace ( / \\ / g ,  ' / ' )%NWL%t . end ( )%NWL%2
t . test ( ' root=a , cwd=a / b ' , function ( t )  {%NWL%glob ( ' / b * / * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' )  } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] . map ( function ( m )  {%NWL%return path . join ( path . resolve ( ' a ' ) , m ) . replace ( / \\ / g ,  ' / ' )%NWL%} ) )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%t . end ( )%NWL%6
this . hybrid = {  ' simple ' : { } ,  ' advanced ' : { }  } ;%NWL%this . uglified = { } ;%NWL%this . filePath = options . filePath;%NWL%this . isMapped = !!options . isMapped;%NWL%this . isSilent = !!options . isSilent;%NWL%this . isTemplate = !!options . isTemplate;%NWL%this . outputPath = options . outputPath;%NWL%this . sourceMapURL = options . sourceMapURL;%NWL%var modes = this . modes = options . modes;%NWL%source = this . source = preprocess ( source , options ) ;%NWL%var outputPath = this . outputPath ,%NWL%8
' Try running the command as root , via `sudo` , or manually install by running: ' ,%NWL%' ' ,%NWL%" curl - H ' Accept: "  + mediaType +  " '  "  + location . href +  ' / '  + hashId +  " | tar xvz - C ' "  + destPath +  " ' " ,%NWL%' '%NWL%] . join ( ' \n ' ) ) ;%NWL%}%NWL%ran = true;%NWL%process . removeListener ( ' uncaughtException ' , callback ) ;%NWL%onComplete ( exception ) ;%NWL%} ;%NWL%process . on ( ' uncaughtException ' , callback ) ;%NWL%7
console . log ( ' Compressing '  + path . basename ( this . outputPath ,  ' . js ' )  +  ' using '  + label +  ' . . . ' ) ;%NWL%}%NWL%try {%NWL%var uglifyJS = require ( uglifyPath ) ;%NWL%var toplevel = uglifyJS . parse ( source ) ;%NWL%toplevel . figure_out_scope ( ) ;%NWL%toplevel = toplevel . transform ( uglifyJS . Compressor ( {%NWL%' comparisons ' : false ,%NWL%' unsafe_comps ' : true ,%NWL%' warnings ' : false%NWL%toplevel . figure_out_scope ( ) ;%NWL%5
}%NWL%try {%NWL%var uglifyJS = require ( uglifyPath ) ;%NWL%var toplevel = uglifyJS . parse ( source ) ;%NWL%toplevel . figure_out_scope ( ) ;%NWL%toplevel = toplevel . transform ( uglifyJS . Compressor ( {%NWL%' comparisons ' : false ,%NWL%' unsafe_comps ' : true ,%NWL%' warnings ' : false%NWL%} ) ) ;%NWL%toplevel . compute_char_frequency ( ) ;%NWL%4
] ,%NWL%function ( Dashboard )  {%NWL%return Dashboard . extend ( {%NWL%getAggregateValues: function ( )  {%NWL%var aggregatedValues = [ ] ;%NWL%var axes = this . options . axes . y;%NWL%var kpi;%NWL%_ . each ( this . models , function ( model )  {%NWL%_ . each ( axes , function ( axis )  {%NWL%var axisKey = axis . key;%NWL%var number_of_transactions = model . get ( ' number_of_transactions ' ) ;%NWL%5
var number_of_transactions = model . get ( ' number_of_transactions ' ) ;%NWL%kpi = _ . findWhere ( aggregatedValues ,  { key: axisKey } ) ;%NWL%if ( kpi )  {%NWL%if ( ( val || val === 0 ) && number_of_transactions )  {%NWL%kpi . value + = val;%NWL%kpi . valueTimesVolume + = ( val * model . get ( ' number_of_transactions ' ) ) ;%NWL%kpi . volume + = model . get ( ' number_of_transactions ' ) ;%NWL%kpi . valueCount + + ;%NWL%} else if ( ( val || val === 0 ) && axisKey === ' total_cost ' )  {%NWL%kpi . value + = val;%NWL%kpi . valueCount + + ;%NWL%7
%NWL%QUnit . done ( function ( )  {%NWL%var ran;%NWL%return function ( details )  {%NWL%if ( ran )  {%NWL%return;%NWL%}%NWL%ran = true;%NWL%console . log ( hr ) ;%NWL%console . log ( '   PASS: '  + details . passed +  '  FAIL: '  + details . failed +  '  TOTAL: '  + details . total ) ;%NWL%console . log ( hr ) ;%NWL%8
details . message || ' ok '%NWL%] ;%NWL%if ( !result && type == ' EQ ' )  {%NWL%assertion . push ( ' Expected: '  + expected +  ' , Actual: '  + details . actual ) ;%NWL%}%NWL%QUnit . config . testStats . assertions . push ( assertion . join ( ' | ' ) ) ;%NWL%} ) ;%NWL%%NWL%QUnit . moduleStart ( function ( details )  {%NWL%console . log ( hr ) ;%NWL%console . log ( hr ) ;%NWL%9
, uname: true }%NWL%exports . fields = fields%NWL%exports . fieldSize = fieldSize%NWL%exports . fieldOffs = fieldOffs%NWL%exports . fieldEnds = fieldEnds%NWL%exports . types = types%NWL%exports . modes = modes%NWL%exports . numeric = numeric%NWL%exports . headerSize = headerSize%NWL%exports . blockSize = blockSize%NWL%exports . Pack = require ( " . / lib / pack . js " )%NWL%1
exports . fields = fields%NWL%exports . fieldSize = fieldSize%NWL%exports . fieldOffs = fieldOffs%NWL%exports . fieldEnds = fieldEnds%NWL%exports . types = types%NWL%exports . modes = modes%NWL%exports . numeric = numeric%NWL%exports . headerSize = headerSize%NWL%exports . blockSize = blockSize%NWL%exports . knownExtended = knownExtended%NWL%exports . Parse = require ( " . / lib / parse . js " )%NWL%0
exports . fieldSize = fieldSize%NWL%exports . fieldOffs = fieldOffs%NWL%exports . fieldEnds = fieldEnds%NWL%exports . types = types%NWL%exports . modes = modes%NWL%exports . numeric = numeric%NWL%exports . headerSize = headerSize%NWL%exports . blockSize = blockSize%NWL%exports . knownExtended = knownExtended%NWL%exports . Pack = require ( " . / lib / pack . js " )%NWL%exports . Extract = require ( " . / lib / extract . js " )%NWL%0
} )%NWL%me . _stream . on ( " end " , function ( )  {%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%} )%NWL%me . props = props%NWL%if ( props . type === " Directory " )  {%NWL%props . size = 0%NWL%}%NWL%props . ustar = " ustar\0 "%NWL%me . path = props . path%NWL%5
EntryWriter . prototype . write = function ( c )  {%NWL%if ( this . _ended ) return this . emit ( " error " , new Error ( " write after end " ) )%NWL%this . _buffer . push ( c )%NWL%this . _process ( )%NWL%this . _needDrain = this . _buffer . length > 0%NWL%return !this . _needDrain%NWL%}%NWL%EntryWriter . prototype . end = function ( c )  {%NWL%if ( c ) this . _buffer . push ( c )%NWL%this . _buffer . push ( EOF )%NWL%this . _process ( )%NWL%3
this . _ended = true%NWL%this . _process ( )%NWL%this . _needDrain = this . _buffer . length > 0%NWL%}%NWL%EntryWriter . prototype . pause = function ( )  {%NWL%this . _paused = true%NWL%this . emit ( " pause " )%NWL%}%NWL%EntryWriter . prototype . resume = function ( )  {%NWL%this . _paused = false%NWL%this . _process ( )%NWL%1
this . _queueLen + +%NWL%this . _read ( )%NWL%if ( this . _paused || ql > 0 )  {%NWL%this . _needDrain = true%NWL%return false%NWL%}%NWL%return true%NWL%}%NWL%, end: function ( c )  {%NWL%if ( c ) this . write ( c )%NWL%this . _read ( )%NWL%1
if ( c ) this . write ( c )%NWL%this . _ending = true%NWL%this . _read ( )%NWL%}%NWL%, pause: function ( )  {%NWL%this . _paused = true%NWL%this . emit ( " pause " )%NWL%}%NWL%, resume: function ( )  {%NWL%this . emit ( " resume " )%NWL%this . _read ( )%NWL%2
case " Link " :%NWL%case " SymbolicLink " :%NWL%case " CharacterDevice " :%NWL%case " BlockDevice " :%NWL%case " Directory " :%NWL%case " FIFO " :%NWL%default:%NWL%type = tar . types [ props . type ]%NWL%}%NWL%this . type = type%NWL%this . size = props . size%NWL%9
case " SymbolicLink " :%NWL%case " CharacterDevice " :%NWL%case " BlockDevice " :%NWL%case " Directory " :%NWL%case " FIFO " :%NWL%default:%NWL%type = tar . types [ props . type ]%NWL%}%NWL%this . type = type%NWL%this . path = props . path%NWL%this . _remaining = props . size%NWL%8
module . exports = ExtendedHeaderWriter%NWL%var inherits = require ( " . . / vendor / inherits / inherits . js " )%NWL%, EntryWriter = require ( " . / entry - writer . js " )%NWL%var tar = require ( " . . / tar . js " )%NWL%1
}%NWL%this . _sizeBuf . push ( b )%NWL%continue%NWL%case KEY:%NWL%if ( b === eq )  {%NWL%this . _state = VAL%NWL%this . _key = new Buffer ( this . _keyBuf ) . toString ( )%NWL%if ( keyTrans [ this . _key ] ) this . _key = keyTrans [ this . _key ]%NWL%this . _keyBuf . length = 0%NWL%continue%NWL%this . _keyBuf . push ( b )%NWL%1
function Extract ( opts )  {%NWL%if ( ! ( this instanceof Extract ) ) return new Extract ( opts )%NWL%tar . Parse . apply ( this )%NWL%opts . type = " Directory "%NWL%opts . Directory = true%NWL%if ( typeof opts !== " object " )  {%NWL%opts = { path: opts }%NWL%}%NWL%opts . path = opts . path || path . resolve ( " node - tar - extract " )%NWL%opts . type = " Directory "%NWL%opts . strip = + opts . strip%NWL%8
opts . strip = + opts . strip%NWL%if ( !opts . strip || opts . strip <= 0 ) opts . strip = 0%NWL%this . _fst = fstream . Writer ( opts )%NWL%this . pause ( )%NWL%var me = this%NWL%me . on ( " entry " , function ( entry )  {%NWL%if ( opts . strip )  {%NWL%var p = entry . path . split ( " / " ) . slice ( opts . strip ) . join ( " / " )%NWL%entry . path = entry . props . path = p%NWL%if ( entry . linkpath )  {%NWL%entry . linkpath = entry . props . linkpath = lp%NWL%8
var me = this%NWL%me . on ( " entry " , function ( entry )  {%NWL%if ( opts . strip )  {%NWL%var p = entry . path . split ( " / " ) . slice ( opts . strip ) . join ( " / " )%NWL%entry . path = entry . props . path = p%NWL%if ( entry . linkpath )  {%NWL%var lp = entry . linkpath . split ( " / " ) . slice ( opts . strip ) . join ( " / " )%NWL%entry . linkpath = entry . props . linkpath = lp%NWL%}%NWL%}%NWL%entry . linkpath = entry . props . linkpath =%NWL%4
if ( !obj && ! ( this instanceof TarHeader ) ) throw new Error (%NWL%" encode must be called on a TarHeader , or supplied an object " )%NWL%obj = obj || this%NWL%var block = obj . block = new Buffer ( 512 )%NWL%if ( obj . prefix )  {%NWL%obj . path = obj . prefix +  " / "  + obj . path%NWL%obj . prefix = " "%NWL%}%NWL%obj . needExtended = false%NWL%if ( obj . mode )  {%NWL%obj . mode = obj . mode & 0777%NWL%5
this . emit ( " pause " )%NWL%}%NWL%Pack . prototype . resume = function ( )  {%NWL%this . _paused = false%NWL%if ( this . _currentEntry ) this . _currentEntry . resume ( )%NWL%this . emit ( " resume " )%NWL%this . _process ( )%NWL%}%NWL%Pack . prototype . end = function ( )  {%NWL%this . _ended = true%NWL%this . _process ( )%NWL%6
me . emit ( " data " , eof )%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%return%NWL%}%NWL%var root = path . dirname ( ( entry . root || entry ) . path )%NWL%var wprops = { }%NWL%Object . keys ( entry . props ) . forEach ( function ( k )  {%NWL%wprops [ k ] = entry . props [ k ]%NWL%} )%NWL%wprops . path = path . relative ( root , entry . path )%NWL%8
me . emit ( " close " )%NWL%return%NWL%}%NWL%var root = path . dirname ( ( entry . root || entry ) . path )%NWL%var wprops = { }%NWL%Object . keys ( entry . props ) . forEach ( function ( k )  {%NWL%wprops [ k ] = entry . props [ k ]%NWL%} )%NWL%if ( me . _noProprietary ) wprops . noProprietary = true%NWL%wprops . path = path . relative ( root , entry . path )%NWL%wprops . path = wprops . path . replace ( / \\ / g ,  " / " )%NWL%6
wprops . path = wprops . path . replace ( / \\ / g ,  " / " )%NWL%}%NWL%switch ( wprops . type )  {%NWL%case " Socket " :%NWL%return%NWL%case " Directory " :%NWL%wprops . path + = " / "%NWL%wprops . size = 0%NWL%break%NWL%case " Link " :%NWL%wprops . linkpath = path . relative ( root , lp ) || " . "%NWL%0
var header = new TarHeader ( c )%NWL%, self = this%NWL%, entry%NWL%, ev%NWL%, EntryType%NWL%, onend%NWL%, meta = false%NWL%if ( null === header . size || !header . cksumValid )  {%NWL%var e = new Error ( " invalid tar file " )%NWL%e . header = header%NWL%e . tar_block = this . position / 512%NWL%9
case " FIFO " :%NWL%case " ContiguousFile " :%NWL%case " GNUDumpDir " :%NWL%EntryType = Entry%NWL%ev = " entry "%NWL%break%NWL%case " GlobalExtendedHeader " :%NWL%EntryType = ExtendedHeader%NWL%onend = function ( )  {%NWL%self . _global = self . _global || { }%NWL%self . _global [ k ] = entry . fields [ k ]%NWL%9
self . _extended = self . _extended || { }%NWL%self . _extended . linkpath = entry . body%NWL%}%NWL%ev = " longLinkpath "%NWL%meta = true%NWL%break%NWL%case " NextFileHasLongPath " :%NWL%case " OldGnuLongPath " :%NWL%EntryType = BufferEntry%NWL%onend = function ( )  {%NWL%self . _extended . path = entry . body%NWL%0
entry . on ( " data " , function ( c )  {%NWL%me . emit ( " data " , c )%NWL%} )%NWL%}%NWL%if ( onend ) entry . on ( " end " , onend )%NWL%this . _entry = entry%NWL%var me = this%NWL%entry . on ( " pause " , function ( )  {%NWL%me . pause ( )%NWL%} )%NWL%me . resume ( )%NWL%8
exports . Dir =%NWL%{ Reader : require ( " . / lib / dir - reader . js " )%NWL%, Writer : require ( " . / lib / dir - writer . js " )  }%NWL%exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%9
{ Reader : require ( " . / lib / dir - reader . js " )%NWL%, Writer : require ( " . / lib / dir - writer . js " )  }%NWL%exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%8
, Writer : require ( " . / lib / dir - writer . js " )  }%NWL%exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%7
exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . File = exports . FileWriter = exports . File . Writer%NWL%6
{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%exports . Writer . Link = exports . LinkWriter = exports . Link . Writer%NWL%5
, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%exports . Writer . File = exports . FileWriter = exports . File . Writer%NWL%exports . Writer . Proxy = exports . ProxyWriter = exports . Proxy . Writer%NWL%4
exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%exports . Writer . File = exports . FileWriter = exports . File . Writer%NWL%exports . Writer . Link = exports . LinkWriter = exports . Link . Writer%NWL%exports . collect = require ( " . / lib / collect . js " )%NWL%3
console . error ( " %s %s\n "  +%NWL%" path = %s\n "  +%NWL%" syscall = %s\n "  +%NWL%" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . syscall ,%NWL%9
" path = %s\n "  +%NWL%" syscall = %s\n "  +%NWL%" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . fstream_type ,%NWL%8
" syscall = %s\n "  +%NWL%" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . syscall ,%NWL%er . fstream_path ,%NWL%7
" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . syscall ,%NWL%er . fstream_type ,%NWL%er . fstream_unc_path ,%NWL%6
" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . syscall ,%NWL%er . fstream_type ,%NWL%er . fstream_path ,%NWL%er . fstream_class ,%NWL%5
this . emit ( " info " , msg , code )%NWL%}%NWL%Abstract . prototype . error = function ( msg , code , th )  {%NWL%var er = decorate ( msg , code , this )%NWL%if ( th ) throw er%NWL%else this . emit ( " error " , er )%NWL%}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . fstream_type = er . fstream_type || me . type%NWL%9
}%NWL%Abstract . prototype . error = function ( msg , code , th )  {%NWL%var er = decorate ( msg , code , this )%NWL%if ( th ) throw er%NWL%else this . emit ( " error " , er )%NWL%}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_path = er . fstream_path || me . path%NWL%8
var er = decorate ( msg , code , this )%NWL%if ( th ) throw er%NWL%else this . emit ( " error " , er )%NWL%}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%6
}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%if ( me . _path !== me . path )  {%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%}%NWL%er . fstream_linkpath = er . fstream_linkpath || me . linkpath%NWL%3
if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%if ( me . _path !== me . path )  {%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%}%NWL%if ( me . linkpath )  {%NWL%er . fstream_linkpath = er . fstream_linkpath || me . linkpath%NWL%er . fstream_class = er . fstream_class || me . constructor . name%NWL%1
er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%if ( me . _path !== me . path )  {%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%}%NWL%if ( me . linkpath )  {%NWL%er . fstream_linkpath = er . fstream_linkpath || me . linkpath%NWL%}%NWL%er . fstream_stack = er . fstream_stack ||%NWL%0
DirReader . prototype . _getEntries = function ( )  {%NWL%var me = this%NWL%if ( me . _gotEntries ) return%NWL%me . _gotEntries = true%NWL%fs . readdir ( me . _path , function ( er , entries )  {%NWL%if ( er ) return me . error ( er )%NWL%me . entries = entries%NWL%me . emit ( " entries " , entries )%NWL%if ( me . _paused ) me . once ( " resume " , processEntries )%NWL%else processEntries ( )%NWL%me . _length = me . entries . length%NWL%6
if ( me . _gotEntries ) return%NWL%me . _gotEntries = true%NWL%fs . readdir ( me . _path , function ( er , entries )  {%NWL%if ( er ) return me . error ( er )%NWL%me . entries = entries%NWL%me . emit ( " entries " , entries )%NWL%if ( me . _paused ) me . once ( " resume " , processEntries )%NWL%else processEntries ( )%NWL%function processEntries ( )  {%NWL%me . _length = me . entries . length%NWL%me . entries = me . entries . sort ( me . sort . bind ( me ) )%NWL%4
childProps . basename = path . basename ( p )%NWL%childProps . dirname = path . dirname ( p )%NWL%var entry = Reader ( childProps , stat )%NWL%me . _currentEntry = entry%NWL%entry . on ( " pause " , function ( who )  {%NWL%if ( !me . _paused && !entry . _disowned )  {%NWL%me . pause ( who )%NWL%}%NWL%} )%NWL%entry . on ( " resume " , function ( who )  {%NWL%me . resume ( who )%NWL%6
}%NWL%DirWriter . prototype . add = function ( entry )  {%NWL%var me = this%NWL%collect ( entry )%NWL%if ( !me . ready || me . _currentEntry )  {%NWL%me . _buffer . push ( entry )%NWL%return false%NWL%}%NWL%if ( me . _ended )  {%NWL%return me . error ( " add after end " )%NWL%me . _buffer . push ( entry )%NWL%5
stream . on ( " data " , function ( c )  {%NWL%me . _bytesEmitted + = c . length%NWL%if ( !c . length ) return%NWL%else if ( me . _paused || me . _buffer . length )  {%NWL%me . _buffer . push ( c )%NWL%me . _read ( )%NWL%} else me . emit ( " data " , c )%NWL%} )%NWL%stream . on ( " end " , function ( )  {%NWL%if ( me . _paused || me . _buffer . length )  {%NWL%me . _read ( )%NWL%5
" actual: " + me . _bytesEmitted )%NWL%}%NWL%} )%NWL%stream . on ( " close " , function ( )  {%NWL%if ( me . _paused || me . _buffer . length )  {%NWL%me . _buffer . push ( CLOSE )%NWL%me . _read ( )%NWL%} else {%NWL%me . emit ( " close " )%NWL%}%NWL%me . _read ( )%NWL%6
me . emit ( " ready " )%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%me . end = me . _finish = function ( )  { }%NWL%} else return me . error ( er )%NWL%}%NWL%finish ( me )%NWL%} )%NWL%}%NWL%function finish ( me )  {%NWL%me . emit ( " ready " )%NWL%0
ClassType = ProxyReader%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . depth = props . depth = props . depth || 0%NWL%9
break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . parent = props . parent || null%NWL%8
}%NWL%if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%7
if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%6
}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%4
me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%1
me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%me . basename = props . basename = path . basename ( me . path )%NWL%0
me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . dirname = props . dirname = path . dirname ( me . path )%NWL%0
me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = props . basename = path . basename ( me . path )%NWL%me . dirname = props . dirname = path . dirname ( me . path )%NWL%me . size = props . size%NWL%2
if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = props . basename = path . basename ( me . path )%NWL%me . dirname = props . dirname = path . dirname ( me . path )%NWL%props . parent = props . root = null%NWL%me . filter = typeof props . filter === " function " ? props . filter : null%NWL%1
} )%NWL%if ( undefined !== me . size && props . size !== me . size )  {%NWL%return me . error ( " incorrect size " )%NWL%}%NWL%me . size = props . size%NWL%var type = getType ( props )%NWL%if ( type !== " Directory " && props . nlink && props . nlink > 1 )  {%NWL%var k = props . dev +  " : "  + props . ino%NWL%if ( hardLinks [ k ] === me . _path || !hardLinks [ k ] ) hardLinks [ k ] = me . _path%NWL%else {%NWL%me . Link = me . props . Link = true%NWL%4
if ( undefined !== me . size && props . size !== me . size )  {%NWL%return me . error ( " incorrect size " )%NWL%}%NWL%me . size = props . size%NWL%var type = getType ( props )%NWL%if ( type !== " Directory " && props . nlink && props . nlink > 1 )  {%NWL%var k = props . dev +  " : "  + props . ino%NWL%if ( hardLinks [ k ] === me . _path || !hardLinks [ k ] ) hardLinks [ k ] = me . _path%NWL%else {%NWL%type = me . type = me . props . type = " Link "%NWL%me . linkpath = me . props . linkpath = hardLinks [ k ]%NWL%3
return me . error ( " incorrect size " )%NWL%}%NWL%me . size = props . size%NWL%var type = getType ( props )%NWL%if ( type !== " Directory " && props . nlink && props . nlink > 1 )  {%NWL%var k = props . dev +  " : "  + props . ino%NWL%if ( hardLinks [ k ] === me . _path || !hardLinks [ k ] ) hardLinks [ k ] = me . _path%NWL%else {%NWL%type = me . type = me . props . type = " Link "%NWL%me . Link = me . props . Link = true%NWL%me . _stat = me . _read = LinkReader . prototype . _read%NWL%2
me . abort ( )%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%}%NWL%return%NWL%}%NWL%}%NWL%var events = [ " _stat " ,  " stat " ,  " ready " ]%NWL%var e = 0%NWL%; ( function go ( )  {%NWL%me . emit ( " end " )%NWL%1
me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%}%NWL%return%NWL%}%NWL%}%NWL%var events = [ " _stat " ,  " stat " ,  " ready " ]%NWL%var e = 0%NWL%; ( function go ( )  {%NWL%if ( me . _aborted )  {%NWL%me . emit ( " close " )%NWL%1
case " SymbolicLink " :%NWL%ClassType = LinkWriter%NWL%break%NWL%case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . depth = props . depth || 0%NWL%9
ClassType = LinkWriter%NWL%break%NWL%case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%8
break%NWL%case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%7
case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%6
ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%5
}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%3
me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%0
me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%me . basename = path . basename ( props . path )%NWL%0
me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . dirname = path . dirname ( props . path )%NWL%0
me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = path . basename ( props . path )%NWL%me . linkpath = props . linkpath || null%NWL%0
if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = path . basename ( props . path )%NWL%me . dirname = path . dirname ( props . path )%NWL%me . linkpath = props . linkpath || null%NWL%me . size = props . size%NWL%1
me . dirname = path . dirname ( props . path )%NWL%me . linkpath = props . linkpath || null%NWL%props . parent = props . root = null%NWL%me . size = props . size%NWL%if ( typeof props . mode === " string " )  {%NWL%props . mode = parseInt ( props . mode , 8 )%NWL%}%NWL%me . readable = false%NWL%me . writable = true%NWL%me . _buffer = [ ]%NWL%me . filter = typeof props . filter === " function " ? props . filter: null%NWL%0
function open ( path , flags , mode , cb )  {%NWL%cb = cb || noop%NWL%fs . _curOpen + +%NWL%originalOpen . call ( fs , path , flags , mode , function ( er , fd )  {%NWL%if ( er ) onclose ( )%NWL%cb ( er , fd )%NWL%} )%NWL%}%NWL%fs . openSync = function ( path , flags , mode )  {%NWL%var ret%NWL%fs . _curOpen + +%NWL%2
}%NWL%fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%9
fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%8
return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%7
}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . lchownSync = chownFixSync ( fs . lchownSync )%NWL%6
if ( !er || ( !process . getuid || process . getuid ( ) !== 0 )%NWL%&& ( er . code === " EINVAL " || er . code === " EPERM " ) ) return true%NWL%}%NWL%if ( !fs . lchmod )  {%NWL%fs . lchmod = function ( path , mode , cb )  {%NWL%process . nextTick ( cb )%NWL%}%NWL%fs . lchmodSync = function ( )  { }%NWL%}%NWL%if ( !fs . lchown )  {%NWL%process . nextTick ( cb )%NWL%5
module . exports = rimraf%NWL%rimraf . sync = rimrafSync%NWL%var path = require ( " path " )%NWL%, fs%NWL%try {%NWL%fs = require ( " . . / . . / graceful - fs / graceful - fs . js " )%NWL%} catch ( er )  {%NWL%fs = require ( " fs " )%NWL%var lstat = " lstat "%NWL%2
var myGid = function myGid ( )  {%NWL%var g = process . getuid && process . getgid ( )%NWL%myGid = function myGid ( )  { return g }%NWL%return g%NWL%}%NWL%var myUid = function myUid ( )  {%NWL%var u = process . getuid && process . getuid ( )%NWL%myUid = function myUid ( )  { return u }%NWL%return u%NWL%}%NWL%var mode = s . mode || 0777%NWL%0
t . equal ( cache . max , 10 )%NWL%t . end ( )%NWL%} )%NWL%test ( " least recently set " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . end ( )%NWL%1
var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%cache . set ( " a " ,  " A " )%NWL%1
cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " b " ,  " B " )%NWL%1
cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%0
t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . end ( )%NWL%0
cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . equal ( cache . get ( " a " ) ,  " A " )%NWL%t . end ( )%NWL%} )%NWL%test ( " del " , function ( t )  {%NWL%cache . set ( " a " ,  " A " )%NWL%0
cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . equal ( cache . get ( " a " ) ,  " A " )%NWL%t . end ( )%NWL%} )%NWL%test ( " del " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . del ( " a " )%NWL%1
cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . equal ( cache . get ( " a " ) ,  " A " )%NWL%t . end ( )%NWL%} )%NWL%test ( " del " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . del ( " a " )%NWL%t . end ( )%NWL%4
for ( var i = 0; i < 100; i + + ) cache . set ( i , i )%NWL%t . equal ( cache . length , 100 )%NWL%for ( var i = 0; i < 100; i + + )  {%NWL%t . equal ( cache . get ( i ) , i )%NWL%}%NWL%cache . max = 3%NWL%t . equal ( cache . length , 3 )%NWL%for ( var i = 0; i < 97; i + + )  {%NWL%t . equal ( cache . get ( i ) , undefined )%NWL%}%NWL%t . equal ( cache . get ( i ) , i )%NWL%3
t . equal ( cache . length , 3 )%NWL%for ( var i = 0; i < 97; i + + )  {%NWL%t . equal ( cache . get ( i ) , undefined )%NWL%}%NWL%for ( var i = 98; i < 100; i + + )  {%NWL%t . equal ( cache . get ( i ) , i )%NWL%}%NWL%cache . max = " hello "%NWL%for ( var i = 0; i < 100; i + + ) cache . set ( i , i )%NWL%t . equal ( cache . length , 100 )%NWL%t . equal ( cache . get ( i ) , i )%NWL%5
for ( var i = 0; i < 100; i + + ) cache . set ( i , i )%NWL%t . equal ( cache . length , 100 )%NWL%for ( var i = 0; i < 100; i + + )  {%NWL%t . equal ( cache . get ( i ) , i )%NWL%}%NWL%cache . max = 3%NWL%t . equal ( cache . length , 3 )%NWL%for ( var i = 0; i < 97; i + + )  {%NWL%t . equal ( cache . get ( i ) , undefined )%NWL%}%NWL%t . equal ( cache . get ( i ) , i )%NWL%3
t . end ( )%NWL%} )%NWL%test ( " reset " , function ( t )  {%NWL%var cache = new LRU ( 10 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . reset ( )%NWL%t . equal ( cache . length , 0 )%NWL%t . equal ( cache . max , 10 )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " weighed length item too large " , function ( t )  {%NWL%var cache = new LRU ( {%NWL%max: 10 ,%NWL%length: function ( item )  { return item . size }%NWL%} )%NWL%t . equal ( cache . max , 10 )%NWL%cache . set ( " key " ,  { val: " value " , size: 50 } )%NWL%t . equal ( cache . length , 0 )%NWL%t . end ( )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " set returns proper booleans " , function ( t )  {%NWL%var cache = new LRU ( {%NWL%max: 5 ,%NWL%length: function ( item )  { return item . length }%NWL%} )%NWL%t . equal ( cache . set ( " a " ,  " A " ) , true )%NWL%t . equal ( cache . set ( " b " ,  " donuts " ) , false )%NWL%t . equal ( cache . set ( " b " ,  " B " ) , true )%NWL%t . end ( )%NWL%0
} )%NWL%test ( " stale " , function ( t )  {%NWL%var cache = new LRU ( {%NWL%maxAge: 10 ,%NWL%stale: true%NWL%} )%NWL%cache . set ( ' foo ' ,  ' bar ' )%NWL%t . equal ( cache . get ( ' foo ' ) ,  ' bar ' )%NWL%t . equal ( cache . has ( ' foo ' ) , true )%NWL%setTimeout ( function ( )  {%NWL%t . equal ( cache . get ( ' foo ' ) ,  ' bar ' )%NWL%7
t . equal ( cache . get ( ' foo ' ) , undefined )%NWL%t . end ( )%NWL%} , 15 )%NWL%} )%NWL%test ( " lru update via set " , function ( t )  {%NWL%var cache = LRU ( { max: 2 } ) ;%NWL%cache . set ( ' foo ' , 1 ) ;%NWL%cache . set ( ' bar ' , 2 ) ;%NWL%cache . del ( ' bar ' ) ;%NWL%cache . set ( ' baz ' , 3 ) ;%NWL%t . equal ( cache . get ( ' foo ' ) , undefined )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " least recently set w / peek " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%t . equal ( cache . peek ( " a " ) ,  " A " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . end ( )%NWL%0
t . equal ( cache , l )%NWL%t . equal ( key , i . toString ( ) )%NWL%t . equal ( val , i . toString ( 2 ) )%NWL%i - = 1%NWL%} )%NWL%l . get ( 6 )%NWL%l . get ( 8 )%NWL%var order = [ 8 , 6 , 9 , 7 , 5 ]%NWL%var i = 0%NWL%l . forEach ( function ( val , key , cache )  {%NWL%t . equal ( cache , l )%NWL%0
}%NWL%test ( ' no leaks ' , function ( t )  {%NWL%for ( var i = 0; i < 100; i + + )  {%NWL%l . set ( i , new X ) ;%NWL%if ( i % 2 === 0 )%NWL%l . get ( i / 2 )%NWL%}%NWL%gc ( )%NWL%var start = process . memoryUsage ( )%NWL%var startRefs = refs%NWL%l . set ( i , new X ) ;%NWL%3
for ( var i = 0; i < 100; i + + )  {%NWL%l . set ( i , new X ) ;%NWL%if ( i % 2 === 0 )%NWL%l . get ( i / 2 )%NWL%}%NWL%gc ( )%NWL%var start = process . memoryUsage ( )%NWL%var startRefs = refs%NWL%for ( var i = 0; i < 10000; i + + )  {%NWL%l . set ( i , new X ) ;%NWL%l . get ( i / 2 )%NWL%3
var http = require ( ' http ' )%NWL%var sigmund = require ( ' . / sigmund . js ' )%NWL%0
, expect = c [ 1 ] . sort ( alpha )%NWL%, options = c [ 2 ] || { }%NWL%, f = c [ 3 ] || files%NWL%, tapOpts = c [ 4 ] || { }%NWL%var m = new mm . Minimatch ( pattern , options )%NWL%var r = m . makeRe ( )%NWL%var expectRe = regexps [ re + + ]%NWL%tapOpts . re = String ( r ) || JSON . stringify ( r )%NWL%tapOpts . files = JSON . stringify ( f )%NWL%tapOpts . pattern = pattern%NWL%tapOpts . negated = m . negate%NWL%9
t . equivalent ( actual , expect%NWL%, JSON . stringify ( pattern )  +  "  "  + JSON . stringify ( expect )%NWL%, tapOpts )%NWL%t . equal ( tapOpts . re , expectRe , tapOpts )%NWL%} )%NWL%t . comment ( " time= "  +  ( Date . now ( )  - start )  +  " ms " )%NWL%t . end ( )%NWL%} )%NWL%tap . test ( " global leak test " , function ( t )  {%NWL%var globalAfter = Object . keys ( global )%NWL%t . end ( )%NWL%6
, expect = c [ 1 ] . sort ( alpha )%NWL%, options = c [ 2 ] || { }%NWL%, f = c [ 3 ] || files%NWL%, tapOpts = c [ 4 ] || { }%NWL%var Class = mm . defaults ( options ) . Minimatch%NWL%var m = new Class ( pattern ,  { } )%NWL%var r = m . makeRe ( )%NWL%tapOpts . re = String ( r ) || JSON . stringify ( r )%NWL%tapOpts . files = JSON . stringify ( f )%NWL%tapOpts . pattern = pattern%NWL%tapOpts . negated = m . negate%NWL%9
actual . sort ( alpha )%NWL%t . equivalent ( actual , expect%NWL%, JSON . stringify ( pattern )  +  "  "  + JSON . stringify ( expect )%NWL%, tapOpts )%NWL%} )%NWL%t . comment ( " time= "  +  ( Date . now ( )  - start )  +  " ms " )%NWL%t . end ( )%NWL%} )%NWL%tap . test ( " global leak test " , function ( t )  {%NWL%var globalAfter = Object . keys ( global )%NWL%t . end ( )%NWL%6
' empty set ' : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . deepEqual ( globule . match ( null ,  ' foo . js ' ) ,  [ ] ,  ' should return empty set . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' , null ) ,  [ ] ,  ' should return empty set . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ] ,  ' foo . js ' ) ,  [ ] ,  ' should return empty set . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ] ) ,  [ ] ,  ' should return empty set . ' ) ;%NWL%test . deepEqual ( globule . match ( null ,  [ ' foo . js ' ] ) ,  [ ] ,  ' should return empty set . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ] , null ) ,  [ ] ,  ' should return empty set . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . deepEqual ( globule . match ( [ ' * . js ' ] , null ) ,  [ ] ,  ' should return empty set . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' basic matching ' : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  ' foo . js ' ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . css ' ] ,  ' foo . js ' ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . done ( ) ;%NWL%1
test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . css ' ] ,  ' foo . js ' ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,  [ ' foo . js ' ,  ' bar . css ' ] ,  ' should match correctly . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' no matches ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  ' foo . css ' ) ,  [ ] ,  ' should fail to match . ' ) ;%NWL%test . done ( ) ;%NWL%5
test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should match correctly . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,  [ ' foo . js ' ,  ' bar . css ' ] ,  ' should match correctly . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' no matches ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  ' foo . css ' ) ,  [ ] ,  ' should fail to match . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . css ' ,  ' bar . css ' ] ) ,  [ ] ,  ' should fail to match . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%5
} ,%NWL%' no matches ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  ' foo . css ' ) ,  [ ] ,  ' should fail to match . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . css ' ,  ' bar . css ' ] ) ,  [ ] ,  ' should fail to match . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' unique ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ,  ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should return a uniqued set . ' ) ;%NWL%test . done ( ) ;%NWL%5
' unique ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ,  ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should return a uniqued set . ' ) ;%NWL%test . deepEqual ( globule . match ( [ ' * . js ' ,  ' * . * ' ] ,  [ ' foo . js ' ,  ' foo . js ' ] ) ,  [ ' foo . js ' ] ,  ' should return a uniqued set . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' flatten ' : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%test . deepEqual ( globule . match ( [ [ ' * . js ' ,  ' * . css ' ] ,  [ ' * . * ' ,  ' * . js ' ] ] ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,%NWL%[ ' foo . js ' ,  ' bar . css ' ] ,%NWL%test . done ( ) ;%NWL%4
' inclusion / exclusion order matters ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' options . matchBase ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ,  ' bar ' ,  ' baz / xyz . js ' ] ,  { matchBase: true } ) ,%NWL%[ ' foo . js ' ,  ' baz / xyz . js ' ] ,%NWL%' should matchBase ( minimatch ) when specified . ' ) ;%NWL%test . deepEqual ( globule . match ( ' * . js ' ,  [ ' foo . js ' ,  ' bar ' ,  ' baz / xyz . js ' ] ) ,%NWL%[ ' foo . js ' ] ,%NWL%test . done ( ) ;%NWL%1
' basic matching ' : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . ok ( globule . isMatch ( ' * . js ' ,  ' foo . js ' ) ,  ' should match correctly . ' ) ;%NWL%test . ok ( globule . isMatch ( ' * . js ' ,  [ ' foo . js ' ] ) ,  ' should match correctly . ' ) ;%NWL%test . ok ( globule . isMatch ( ' * . js ' ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,  ' should match correctly . ' ) ;%NWL%test . ok ( globule . isMatch ( [ ' * . js ' ,  ' * . css ' ] ,  ' foo . js ' ) ,  ' should match correctly . ' ) ;%NWL%test . ok ( globule . isMatch ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ] ) ,  ' should match correctly . ' ) ;%NWL%test . ok ( globule . isMatch ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,  ' should match correctly . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%test . expect ( 6 ) ;%NWL%1
test . ok ( globule . isMatch ( [ ' * . js ' ,  ' * . css ' ] ,  [ ' foo . js ' ,  ' bar . css ' ] ) ,  ' should match correctly . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' no matches ' : function ( test )  {%NWL%test . expect ( 6 ) ;%NWL%test . ok ( !globule . isMatch ( ' * . js ' ,  ' foo . css ' ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( ' * . js ' ,  [ ' foo . css ' ,  ' bar . css ' ] ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( null ,  ' foo . css ' ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( ' * . js ' , null ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( [ ] ,  ' foo . css ' ) ,  ' should fail to match . ' ) ;%NWL%test . done ( ) ;%NWL%1
test . ok ( !globule . isMatch ( ' * . js ' ,  [ ' foo . css ' ,  ' bar . css ' ] ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( null ,  ' foo . css ' ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( ' * . js ' , null ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( [ ] ,  ' foo . css ' ) ,  ' should fail to match . ' ) ;%NWL%test . ok ( !globule . isMatch ( ' * . js ' ,  [ ] ) ,  ' should fail to match . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' options . matchBase ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . ok ( globule . isMatch ( ' * . js ' ,  [ ' baz / xyz . js ' ] ,  { matchBase: true } ) ,  ' should matchBase ( minimatch ) when specified . ' ) ;%NWL%test . done ( ) ;%NWL%5
' srcBase should not prevent exclusions . ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%' options . prefixBase ' : function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%test . deepEqual ( globule . find ( [ ' * * / deep * . txt ' ] ,  { srcBase: ' deep ' , prefixBase: false } ) ,%NWL%[ ' deep . txt ' ,  ' deeper / deeper . txt ' ,  ' deeper / deepest / deepest . txt ' ] ,%NWL%' should not prefix srcBase to returned paths . ' ) ;%NWL%test . deepEqual ( globule . find ( [ ' * * / deep * . txt ' ] ,  { srcBase: ' deep ' , prefixBase: true } ) ,%NWL%[ ' deep / deep . txt ' ,  ' deep / deeper / deeper . txt ' ,  ' deep / deeper / deepest / deepest . txt ' ] ,%NWL%test . done ( ) ;%NWL%1
test . done ( ) ;%NWL%} ,%NWL%' options . srcBase ' : function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var actual = globule . findMapping ( [ ' * * / * . txt ' ] ,  { destBase: ' dest ' , srcBase: ' expand / deep ' } ) ;%NWL%var expected = [%NWL%{ dest: ' dest / deep . txt ' , src: [ ' expand / deep / deep . txt ' ] } ,%NWL%{ dest: ' dest / deeper / deeper . txt ' , src: [ ' expand / deep / deeper / deeper . txt ' ] } ,%NWL%{ dest: ' dest / deeper / deepest / deepest . txt ' , src: [ ' expand / deep / deeper / deepest / deepest . txt ' ] } ,%NWL%] ;%NWL%test . done ( ) ;%NWL%0
' use strict ' ;%NWL%var Gaze = require ( ' . . / lib / gaze . js ' ) . Gaze;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%2
' use strict ' ;%NWL%var Gaze = require ( ' . . / lib / gaze . js ' ) . Gaze;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var fixtures = path . resolve ( __dirname ,  ' fixtures ' ) ;%NWL%2
test . done ( ) ;%NWL%} ,%NWL%addLater: function ( test )  {%NWL%test . expect ( 3 ) ;%NWL%new Gaze ( ' sub / one . js ' , function ( err , watcher )  {%NWL%test . deepEqual ( watcher . relative ( ' sub ' ) ,  [ ' one . js ' ] ) ;%NWL%watcher . add ( ' sub / * . js ' , function ( )  {%NWL%test . deepEqual ( watcher . relative ( ' sub ' ) ,  [ ' one . js ' ,  ' two . js ' ] ) ;%NWL%watcher . on ( ' changed ' , function ( filepath )  {%NWL%test . equal ( ' two . js ' , path . basename ( filepath ) ) ;%NWL%test . done ( ) ;%NWL%0
test . expect ( 2 ) ;%NWL%new gaze . Gaze ( ' * * * ' , function ( err , watcher )  {%NWL%test . deepEqual ( watcher . relative ( ' sub ' , true ) ,  [ ' one . js ' ,  ' two . js ' ] ) ;%NWL%g . close ( ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%ready: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var g = new gaze . Gaze ( ' * * / * ' ) ;%NWL%test . deepEqual ( watcher . relative ( ' sub ' , true ) ,  [ ' one . js ' ,  ' two . js ' ] ) ;%NWL%2
test . deepEqual ( watcher . relative ( ' sub ' , true ) ,  [ ' one . js ' ,  ' two . js ' ] ) ;%NWL%g . close ( ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%ready: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%var g = new gaze . Gaze ( ' * * / * ' ) ;%NWL%g . on ( ' ready ' , function ( watcher )  {%NWL%test . deepEqual ( watcher . relative ( ' sub ' , true ) ,  [ ' one . js ' ,  ' two . js ' ] ) ;%NWL%test . done ( ) ;%NWL%2
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%1
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fixtures = path . resolve ( __dirname ,  ' fixtures ' ) ;%NWL%1
} ,%NWL%tearDown: cleanUp ,%NWL%globAll: function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%gaze ( ' * * * ' , function ( )  {%NWL%test . deepEqual ( this . relative ( ' sub ' , true ) ,  [ ' one . js ' ,  ' two . js ' ] ) ;%NWL%this . close ( ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . expect ( 2 ) ;%NWL%3
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%1
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
var watcher = new gaze . Gaze ( ' * * / poller . js ' , function ( err , watcher )  {%NWL%var timeout = setTimeout ( function ( )  {%NWL%test . ok ( false ,  ' watcher '  + idx +  ' did not fire event on polled file . ' ) ;%NWL%watcher . close ( ) ;%NWL%} , TIMEOUT ) ;%NWL%watcher . on ( ' all ' , function ( status , filepath )  {%NWL%if ( !filepath )  { return; }%NWL%var expected = path . relative ( process . cwd ( ) , filepath ) ;%NWL%test . equal ( expected_path , expected ,  ' watcher '  + idx +%NWL%' emitted unexpected event . ' ) ;%NWL%watcher . close ( ) ;%NWL%3
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%1
' use strict ' ;%NWL%var gaze = require ( ' . . / lib / gaze . js ' ) ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
watcher . on ( ' end ' , test . done ) ;%NWL%} ) ;%NWL%} ,%NWL%nonExistent: function ( test )  {%NWL%test . expect ( 1 ) ;%NWL%gaze ( ' non / existent * ' , function ( err , watcher )  {%NWL%test . ok ( true ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . expect ( 1 ) ;%NWL%4
test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%multipleWatchersSimultaneously: function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var did = 0;%NWL%var ready = 0;%NWL%var cwd = path . resolve ( __dirname ,  ' fixtures ' ,  ' sub ' ) ;%NWL%var watchers = [ ] ;%NWL%var timeout = setTimeout ( function ( )  {%NWL%test . done ( ) ;%NWL%0
var events  = require ( ' events ' ) ;%NWL%var WebSocket = require ( ' faye - websocket ' ) ;%NWL%module . exports = Client;%NWL%function Client ( req , socket , head )  {%NWL%this . ws = new WebSocket ( req , socket , head ) ;%NWL%this . ws . onmessage = this . message . bind ( this ) ;%NWL%this . ws . onclose = this . close . bind ( this ) ;%NWL%this . id = this . uniqueId ( ' ws ' ) ;%NWL%}%NWL%util . inherits ( Client , events . EventEmitter ) ;%NWL%var data = this . data ( event ) ;%NWL%0
var fs    = require ( ' fs ' ) ;%NWL%var path   = require ( ' path ' ) ;%NWL%0
var fs    = require ( ' fs ' ) ;%NWL%var qs    = require ( ' qs ' ) ;%NWL%var util   = require ( ' util ' ) ;%NWL%0
var fs    = require ( ' fs ' ) ;%NWL%var qs    = require ( ' qs ' ) ;%NWL%var path   = require ( ' path ' ) ;%NWL%var http   = require ( ' http ' ) ;%NWL%0
var fs    = require ( ' fs ' ) ;%NWL%var qs    = require ( ' qs ' ) ;%NWL%var path   = require ( ' path ' ) ;%NWL%var util   = require ( ' util ' ) ;%NWL%var events  = require ( ' events ' ) ;%NWL%0
var fs    = require ( ' fs ' ) ;%NWL%var qs    = require ( ' qs ' ) ;%NWL%var path   = require ( ' path ' ) ;%NWL%var util   = require ( ' util ' ) ;%NWL%var http   = require ( ' http ' ) ;%NWL%var events  = require ( ' events ' ) ;%NWL%var debug   = require ( ' debug ' ) ( ' tinylr:server ' ) ;%NWL%0
var fs    = require ( ' fs ' ) ;%NWL%var qs    = require ( ' qs ' ) ;%NWL%var path   = require ( ' path ' ) ;%NWL%var util   = require ( ' util ' ) ;%NWL%var http   = require ( ' http ' ) ;%NWL%var events  = require ( ' events ' ) ;%NWL%var parse   = require ( ' url ' ) . parse;%NWL%var debug   = require ( ' debug ' ) ( ' tinylr:server ' ) ;%NWL%var constants = require ( ' constants ' ) ;%NWL%0
req . data = req . data || ' ' ;%NWL%req . data + = chunk;%NWL%} ) ;%NWL%return this;%NWL%} ;%NWL%Server . prototype . handle = function handle ( req , res , next )  {%NWL%var url = parse ( req . url ) ;%NWL%var middleware = typeof next === ' function ' ;%NWL%req . body = { } ;%NWL%req . params = { } ;%NWL%req . body = JSON . parse ( req . data ) ;%NWL%0
if ( res ) res . end ( ) ;%NWL%Object . keys ( this . clients ) . forEach ( function ( id )  {%NWL%this . clients [ id ] . close ( ) ;%NWL%} , this ) ;%NWL%if ( this . server . _handle ) this . server . close ( this . emit . bind ( this ,  ' close ' ) ) ;%NWL%} ;%NWL%Server . prototype . error = function error ( e )  {%NWL%console . error ( ) ;%NWL%console . error ( ' . . . Uhoh . Got error %s . . . ' , e . message ) ;%NWL%console . error ( e . stack ) ;%NWL%console . error ( ) ;%NWL%7
} , this ) ;%NWL%if ( this . server . _handle ) this . server . close ( this . emit . bind ( this ,  ' close ' ) ) ;%NWL%} ;%NWL%Server . prototype . error = function error ( e )  {%NWL%console . error ( ) ;%NWL%console . error ( ' . . . Uhoh . Got error %s . . . ' , e . message ) ;%NWL%console . error ( e . stack ) ;%NWL%if ( e . code !== constants . EADDRINUSE ) return;%NWL%console . error ( ) ;%NWL%console . error ( ' You already have a server listening on %s ' , this . port ) ;%NWL%console . error ( ) ;%NWL%4
res . write ( JSON . stringify ( {%NWL%clients: clients ,%NWL%files: files%NWL%} ) ) ;%NWL%res . end ( ) ;%NWL%} ;%NWL%Server . prototype . index = function index ( req , res )  {%NWL%res . write ( JSON . stringify ( {%NWL%tinylr: ' Welcome ' ,%NWL%version: config . version%NWL%res . end ( ) ;%NWL%4
}%NWL%this . console . log ( " LiveReload found "  + links . length +  " LINKed stylesheets ,  "  + imported . length +  " @imported stylesheets " ) ;%NWL%match = pickBestMatch ( path , links . concat ( imported ) , function ( l )  {%NWL%return pathFromUrl ( _this . linkHref ( l ) ) ;%NWL%} ) ;%NWL%if ( match )  {%NWL%if ( match . object . rule )  {%NWL%this . console . log ( " LiveReload is reloading imported stylesheet: "  + match . object . href ) ;%NWL%this . reattachImportedRule ( match . object ) ;%NWL%} else {%NWL%this . reattachStylesheetLink ( match . object ) ;%NWL%8
if ( rule . __LiveReload_newHref !== href )  {%NWL%return;%NWL%}%NWL%parent . insertRule ( newRule , index ) ;%NWL%parent . deleteRule ( index + 1 ) ;%NWL%rule = parent . cssRules [ index ] ;%NWL%rule . __LiveReload_newHref = href;%NWL%return _this . Timer . start ( _this . importCacheWaitPeriod , function ( )  {%NWL%if ( rule . __LiveReload_newHref !== href )  {%NWL%return;%NWL%parent . insertRule ( newRule , index ) ;%NWL%3
var ms = curr -  ( prev [ name ] || curr ) ;%NWL%prev [ name ] = curr;%NWL%fmt = '  \u001b [ 9 '  + c +  ' m '  + name +  '  '%NWL%+  ' \u001b [ 3 '  + c +  ' m\u001b [ 90m '%NWL%+ fmt +  ' \u001b [ 3 '  + c +  ' m '%NWL%+  '  + '  + humanize ( ms )  +  ' \u001b [ 0m ' ;%NWL%console . error . apply ( this , arguments ) ;%NWL%}%NWL%function plain ( fmt )  {%NWL%fmt = new Date ( ) . toUTCString ( )%NWL%console . error . apply ( this , arguments ) ;%NWL%6
while ( message = buffer . shift ( ) )%NWL%this . send . apply ( this , message ) ;%NWL%var event = new Event ( ' open ' ) ;%NWL%event . initEvent ( ' open ' , false , false ) ;%NWL%this . dispatchEvent ( event ) ;%NWL%} ,%NWL%receive: function ( data )  {%NWL%if ( this . readyState !== API . OPEN ) return false;%NWL%var event = new Event ( ' message ' ) ;%NWL%event . initEvent ( ' message ' , false , false ) ;%NWL%this . dispatchEvent ( event ) ;%NWL%4
for ( var i = 0 , n = bytes . length; i < n; i + + )%NWL%this . _message . push ( bytes [ i ] ) ;%NWL%if ( !this . _handshake . isComplete ( ) ) return;%NWL%if ( this . _handshake . isValid ( ) )  {%NWL%this . protocol = this . _handshake . protocol || ' ' ;%NWL%this . readyState = API . OPEN;%NWL%var event = new Event ( ' open ' ) ;%NWL%event . initEvent ( ' open ' , false , false ) ;%NWL%this . dispatchEvent ( event ) ;%NWL%this . _parser . parse ( this . _message ) ;%NWL%this . readyState = API . CLOSED;%NWL%4
if ( this . _handshake . isValid ( ) )  {%NWL%this . protocol = this . _handshake . protocol || ' ' ;%NWL%this . readyState = API . OPEN;%NWL%var event = new Event ( ' open ' ) ;%NWL%event . initEvent ( ' open ' , false , false ) ;%NWL%this . dispatchEvent ( event ) ;%NWL%this . _parser . parse ( this . _message ) ;%NWL%} else {%NWL%this . readyState = API . CLOSED;%NWL%var event = new Event ( ' close ' ,  { code: 1006 , reason: ' ' } ) ;%NWL%this . dispatchEvent ( event ) ;%NWL%5
else this . _socket . close ( this . ERRORS . encoding_error , null , false ) ;%NWL%} else {%NWL%this . _mode = ' text ' ;%NWL%this . buffer ( payload ) ;%NWL%}%NWL%}%NWL%else if ( opcode === this . OPCODES . binary )  {%NWL%if ( this . _final )  {%NWL%this . _socket . receive ( payload ) ;%NWL%} else {%NWL%this . buffer ( payload ) ;%NWL%3
var crypto = require ( ' crypto ' ) ;%NWL%var Handshake = function ( uri , protocols )  {%NWL%this . _uri = uri;%NWL%this . _protocols = protocols;%NWL%var buffer = new Buffer ( 16 ) , i = 16;%NWL%while ( i - - ) buffer [ i ] = Math . floor ( Math . random ( )  * 256 ) ;%NWL%this . _key = buffer . toString ( ' base64 ' ) ;%NWL%var SHA1 = crypto . createHash ( ' sha1 ' ) ;%NWL%SHA1 . update ( this . _key + Handshake . GUID ) ;%NWL%var HTTPParser = process . binding ( ' http_parser ' ) . HTTPParser ,%NWL%0
parser   = new HTTPParser ( HTTPParser . RESPONSE || ' response ' ) ,%NWL%current  = null ,%NWL%self    = this;%NWL%this . _nodeVersion = HTTPParser . RESPONSE ? 6 : 4;%NWL%this . _complete  = false;%NWL%this . _headers   = { } ;%NWL%this . _parser   = parser;%NWL%parser . onHeaderField = function ( b , start , length )  {%NWL%current = b . toString ( ' utf8 ' , start , start + length ) ;%NWL%} ;%NWL%self . _headers [ current ] = b . toString ( ' utf8 ' , start , start + length ) ;%NWL%2
var fs   = require ( ' fs ' ) ;%NWL%var nopt  = require ( ' nopt ' ) ;%NWL%0
var fs   = require ( ' fs ' ) ;%NWL%var path  = require ( ' path ' ) ;%NWL%var util  = require ( ' . / util ' ) ;%NWL%0
var fs   = require ( ' fs ' ) ;%NWL%var path  = require ( ' path ' ) ;%NWL%var nopt  = require ( ' nopt ' ) ;%NWL%var events = require ( ' events ' ) ;%NWL%0
var fs   = require ( ' fs ' ) ;%NWL%var path  = require ( ' path ' ) ;%NWL%var nopt  = require ( ' nopt ' ) ;%NWL%var util  = require ( ' . / util ' ) ;%NWL%var collectable = require ( ' . / actions / collectable ' ) ;%NWL%0
var fs   = require ( ' fs ' ) ;%NWL%var path  = require ( ' path ' ) ;%NWL%var nopt  = require ( ' nopt ' ) ;%NWL%var util  = require ( ' . / util ' ) ;%NWL%var events = require ( ' events ' ) ;%NWL%var commandable = require ( ' . / actions / commandable ' ) ;%NWL%0
if ( opts . version )  {%NWL%console . log ( this . _version ) ;%NWL%process . exit ( 0 ) ;%NWL%}%NWL%var registered = this . registered ( opts . argv . remain ) ;%NWL%if ( opts . help )  {%NWL%if ( registered && registered . help )  {%NWL%registered . help ( ) . emit ( ' help ' ) ;%NWL%} else {%NWL%this . help ( ) . emit ( ' help ' ) ;%NWL%process . exit ( 0 ) ;%NWL%2
, h: [ " - - help " ]%NWL%, H: [ " - - help " ]%NWL%, n: [  " - - num " ,  " 125 "  ]  }%NWL%, parsed = nopt ( types%NWL%, shorthands%NWL%, process . argv%NWL%, 2 )%NWL%console . log ( " parsed " , parsed )%NWL%if ( parsed . help )  {%NWL%console . log ( " " )%NWL%console . log ( " " )%NWL%9
, rem = test [ 2 ]%NWL%, actual = nopt ( types , shorthands , argv , 0 )%NWL%, parsed = actual . argv%NWL%delete actual . argv%NWL%console . log ( util . inspect ( actual , false , 2 , true ) , parsed . remain )%NWL%for ( var i in opts )  {%NWL%var e = JSON . stringify ( opts [ i ] )%NWL%, a = JSON . stringify ( actual [ i ] === undefined ? null : actual [ i ] )%NWL%if ( e && typeof e === " object " )  {%NWL%assert . deepEqual ( e , a )%NWL%assert . equal ( e , a )%NWL%9
assert . equal ( res , str ) ;%NWL%done ( ) ;%NWL%} ) ;%NWL%program . parse ( ) ;%NWL%process . nextTick ( function ( )  {%NWL%process . stdin . emit ( ' data ' , str ) ;%NWL%process . stdin . emit ( ' end ' ) ;%NWL%} ) ;%NWL%} ) ;%NWL%it ( ' . files ( ) ' , function ( done )  {%NWL%program . parse ( ) ;%NWL%3
var qs = require ( ' . / ' ) ;%NWL%var obj = qs . parse ( ' foo ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%2
var qs = require ( ' . / ' ) ;%NWL%var obj = qs . parse ( ' foo ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' foo=bar=baz ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%2
var qs = require ( ' . / ' ) ;%NWL%var obj = qs . parse ( ' foo ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' foo=bar=baz ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%2
var qs = require ( ' . / ' ) ;%NWL%var obj = qs . parse ( ' foo ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' foo=bar=baz ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' name=tj&email=tj@vision - media . ca ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%2
var obj = qs . parse ( ' foo ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' foo=bar=baz ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' name=tj&email=tj@vision - media . ca ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] =tj&users [ ] =tobi&users [ ] =jane ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' foo=bar=baz ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' name=tj&email=tj@vision - media . ca ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] =tj&users [ ] =tobi&users [ ] =jane ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' users [ ] ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' name=tj&email=tj@vision - media . ca ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] =tj&users [ ] =tobi&users [ ] =jane ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] [ name ] [ first ] =tj&users [ ] [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' name=tj&email=tj@vision - media . ca ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] =tj&users [ ] =tobi&users [ ] =jane ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] [ name ] [ first ] =tj&users [ ] [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' a=a&a=b&a=c ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' users [ ] =tj&users [ ] =tobi&users [ ] =jane ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] [ name ] [ first ] =tj&users [ ] [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' a=a&a=b&a=c ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ tj ] =tj&user [ tj ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' users [ ] [ name ] [ first ] =tj&users [ ] [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' a=a&a=b&a=c ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ tj ] =tj&user [ tj ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ names ] =tj&user [ names ] =TJ&user [ names ] =Tyler ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' users [ ] [ name ] [ first ] =tj&users [ ] [ name ] [ last ] =holowaychuk ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' a=a&a=b&a=c ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ tj ] =tj&user [ tj ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ names ] =tj&user [ names ] =TJ&user [ names ] =Tyler ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ first ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' a=a&a=b&a=c ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ tj ] =tj&user [ tj ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ names ] =tj&user [ names ] =TJ&user [ names ] =Tyler ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ first ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ 0 ] =tj&user [ 1 ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
var obj = qs . parse ( ' user [ tj ] =tj&user [ tj ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ names ] =tj&user [ names ] =TJ&user [ names ] =Tyler ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ name ] [ first ] =tj&user [ name ] [ first ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ 0 ] =tj&user [ 1 ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%var obj = qs . parse ( ' user [ 0 ] =tj&user [ ] =TJ ' ) ;%NWL%console . log ( obj )%NWL%console . log ( obj )%NWL%1
expectation = !this . obj . length;%NWL%}%NWL%this . assert (%NWL%expectation%NWL%,  ' expected '  + i ( this . obj )  +  ' to be empty '%NWL%,  ' expected '  + i ( this . obj )  +  ' to not be empty ' ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . be =%NWL%this . assert (%NWL%2
%NWL%Assertion . prototype . be =%NWL%Assertion . prototype . equal = function ( obj )  {%NWL%this . assert (%NWL%obj === this . obj%NWL%,  ' expected '  + i ( this . obj )  +  ' to equal '  + i ( obj )%NWL%,  ' expected '  + i ( this . obj )  +  ' to not equal '  + i ( obj ) ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%this . assert (%NWL%3
%NWL%Assertion . prototype . eql = function ( obj )  {%NWL%this . assert (%NWL%expect . eql ( obj , this . obj )%NWL%,  ' expected '  + i ( this . obj )  +  ' to sort of equal '  + i ( obj )%NWL%,  ' expected '  + i ( this . obj )  +  ' to sort of not equal '  + i ( obj ) ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . within = function ( start , finish )  {%NWL%this . assert (%NWL%2
this . assert (%NWL%this . obj >= start && this . obj <= finish%NWL%,  ' expected '  + i ( this . obj )  +  ' to be within '  + range%NWL%,  ' expected '  + i ( this . obj )  +  ' to not be within '  + range ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . a =%NWL%Assertion . prototype . an = function ( type )  {%NWL%if ( ' string ' == typeof type )  {%NWL%this . assert (%NWL%0
Assertion . prototype . an = function ( type )  {%NWL%if ( ' string ' == typeof type )  {%NWL%var n = / ^ [ aeiou ] / . test ( type ) ? ' n ' : ' ' ;%NWL%this . assert (%NWL%' array ' == type ? isArray ( this . obj ) :%NWL%' object ' == type%NWL%? ' object ' == typeof this . obj && null !== this . obj%NWL%: type == typeof this . obj%NWL%,  ' expected '  + i ( this . obj )  +  ' to be a '  + n +  '  '  + type%NWL%,  ' expected '  + i ( this . obj )  +  ' not to be a '  + n +  '  '  + type ) ;%NWL%var name = type . name || ' supplied constructor ' ;%NWL%2
if ( ' string ' == typeof type )  {%NWL%var n = / ^ [ aeiou ] / . test ( type ) ? ' n ' : ' ' ;%NWL%this . assert (%NWL%' array ' == type ? isArray ( this . obj ) :%NWL%' object ' == type%NWL%? ' object ' == typeof this . obj && null !== this . obj%NWL%: type == typeof this . obj%NWL%,  ' expected '  + i ( this . obj )  +  ' to be a '  + n +  '  '  + type%NWL%,  ' expected '  + i ( this . obj )  +  ' not to be a '  + n +  '  '  + type ) ;%NWL%} else {%NWL%this . assert (%NWL%2
var name = type . name || ' supplied constructor ' ;%NWL%this . assert (%NWL%this . obj instanceof type%NWL%,  ' expected '  + i ( this . obj )  +  ' to be an instance of '  + name%NWL%,  ' expected '  + i ( this . obj )  +  ' not to be an instance of '  + name ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . greaterThan =%NWL%this . assert (%NWL%1
Assertion . prototype . greaterThan =%NWL%Assertion . prototype . above = function ( n )  {%NWL%this . assert (%NWL%this . obj > n%NWL%,  ' expected '  + i ( this . obj )  +  ' to be above '  + n%NWL%,  ' expected '  + i ( this . obj )  +  ' to be below '  + n ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . lessThan =%NWL%this . assert (%NWL%2
Assertion . prototype . lessThan =%NWL%Assertion . prototype . below = function ( n )  {%NWL%this . assert (%NWL%this . obj < n%NWL%,  ' expected '  + i ( this . obj )  +  ' to be below '  + n%NWL%,  ' expected '  + i ( this . obj )  +  ' to be above '  + n ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%%NWL%this . assert (%NWL%2
Assertion . prototype . match = function ( regexp )  {%NWL%this . assert (%NWL%regexp . exec ( this . obj )%NWL%,  ' expected '  + i ( this . obj )  +  ' to match '  + regexp%NWL%,  ' expected '  + i ( this . obj )  +  ' not to match '  + regexp ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . length = function ( n )  {%NWL%expect ( this . obj ) . to . have . property ( ' length ' ) ;%NWL%this . assert (%NWL%1
expect ( this . obj ) . to . have . property ( ' length ' ) ;%NWL%var len = this . obj . length;%NWL%this . assert (%NWL%n == len%NWL%,  ' expected '  + i ( this . obj )  +  ' to have a length of '  + n +  ' but got '  + len%NWL%,  ' expected '  + i ( this . obj )  +  ' to not have a length of '  + len ) ;%NWL%return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . property = function ( name , val )  {%NWL%this . assert (%NWL%2
} catch ( e )  {%NWL%hasProp = undefined !== this . obj [ name ]%NWL%}%NWL%%NWL%this . assert (%NWL%hasProp%NWL%,  ' expected '  + i ( this . obj )  +  ' to have a property '  + i ( name )%NWL%,  ' expected '  + i ( this . obj )  +  ' to not have a property '  + i ( name ) ) ;%NWL%}%NWL%%NWL%this . assert (%NWL%4
return this;%NWL%} ;%NWL%%NWL%Assertion . prototype . string =%NWL%Assertion . prototype . contain = function ( obj )  {%NWL%if ( ' string ' == typeof this . obj )  {%NWL%this . assert (%NWL%~this . obj . indexOf ( obj )%NWL%,  ' expected '  + i ( this . obj )  +  ' to contain '  + i ( obj )%NWL%,  ' expected '  + i ( this . obj )  +  ' to not contain '  + i ( obj ) ) ;%NWL%this . assert (%NWL%6
} ;%NWL%function isArray ( ar )  {%NWL%return Object . prototype . toString . call ( ar ) == ' [ object Array ] ' ;%NWL%} ;%NWL%function isRegExp ( re )  {%NWL%var s = ' '  + re;%NWL%return re instanceof RegExp || / / easy case%NWL%typeof ( re ) === ' function ' &&%NWL%re . constructor . name === ' RegExp ' &&%NWL%re . compile &&%NWL%re . exec &&%NWL%9
v = str ( k , value ) ;%NWL%if ( v )  {%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%}%NWL%}%NWL%}%NWL%} else {%NWL%for ( k in value )  {%NWL%if ( Object . prototype . hasOwnProperty . call ( value , k ) )  {%NWL%v = str ( k , value ) ;%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%2
var fs = require ( ' fs ' ) ;%NWL%var Server = require ( ' . . ' ) . Server;%NWL%var util = grunt . util || grunt . utils;%NWL%0
describe ( ' tiny - lr ' , function ( )  {%NWL%before ( function ( done )  {%NWL%this . app = new Server;%NWL%this . server = this . app . server;%NWL%this . request = request ( this . server )%NWL%. get ( ' / ' )%NWL%. expect ( 200 , done ) ;%NWL%} ) ;%NWL%it ( ' accepts ws clients ' , function ( done )  {%NWL%var url = parse ( this . request . url ) ;%NWL%var ws = this . ws = new WebSocket ( ' ws: / / '  + url . host +  ' / livereload ' ) ;%NWL%9
var http  = require ( ' http ' ) ;%NWL%var connect = require ( ' connect ' ) ;%NWL%0
var http  = require ( ' http ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%0
var http  = require ( ' http ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var connect = require ( ' connect ' ) ;%NWL%var express = require ( ' express ' ) ;%NWL%var debug  = require ( ' debug ' ) ( ' tinylr:test ' ) ;%NWL%0
' use strict ' ;%NWL%var path = require ( ' path ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%1
' use strict ' ;%NWL%var path = require ( ' path ' ) ;%NWL%var EE = require ( ' events ' ) . EventEmitter;%NWL%var util = require ( ' util ' ) ;%NWL%var livereload = require ( ' . / livereload ' ) ( grunt ) ;%NWL%1
' use strict ' ;%NWL%var path = require ( ' path ' ) ;%NWL%var EE = require ( ' events ' ) . EventEmitter;%NWL%var util = require ( ' util ' ) ;%NWL%module . exports = function ( grunt )  {%NWL%var livereload = require ( ' . / livereload ' ) ( grunt ) ;%NWL%function TaskRun ( target )  {%NWL%this . name = target . name || 0;%NWL%this . tasks = target . tasks || [ ] ;%NWL%7
' use strict ' ;%NWL%var path = require ( ' path ' ) ;%NWL%var EE = require ( ' events ' ) . EventEmitter;%NWL%var util = require ( ' util ' ) ;%NWL%module . exports = function ( grunt )  {%NWL%var livereload = require ( ' . / livereload ' ) ( grunt ) ;%NWL%function TaskRun ( target )  {%NWL%this . name = target . name || 0;%NWL%this . files = target . files || [ ] ;%NWL%this . options = target . options;%NWL%7
var EE = require ( ' events ' ) . EventEmitter;%NWL%var util = require ( ' util ' ) ;%NWL%module . exports = function ( grunt )  {%NWL%var livereload = require ( ' . / livereload ' ) ( grunt ) ;%NWL%function TaskRun ( target )  {%NWL%this . name = target . name || 0;%NWL%this . files = target . files || [ ] ;%NWL%this . tasks = target . tasks || [ ] ;%NWL%this . options = target . options;%NWL%this . startedAt = false;%NWL%this . changedFiles = Object . create ( null ) ;%NWL%5
module . exports = function ( grunt )  {%NWL%var livereload = require ( ' . / livereload ' ) ( grunt ) ;%NWL%function TaskRun ( target )  {%NWL%this . name = target . name || 0;%NWL%this . files = target . files || [ ] ;%NWL%this . tasks = target . tasks || [ ] ;%NWL%this . options = target . options;%NWL%this . startedAt = false;%NWL%this . spawned = null;%NWL%this . changedFiles = Object . create ( null ) ;%NWL%this . tasks = [ this . tasks ] ;%NWL%3
' use strict ' ;%NWL%var path = require ( ' path ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%1
' use strict ' ;%NWL%var path = require ( ' path ' ) ;%NWL%var EE = require ( ' events ' ) . EventEmitter;%NWL%var util = require ( ' util ' ) ;%NWL%var reloadTargets = [ ] ;%NWL%module . exports = function ( grunt )  {%NWL%var livereload = require ( ' . / livereload ' ) ( grunt ) ;%NWL%1
this . nospawn = false;%NWL%this . reload = false;%NWL%this . nameArgs = [ ] ;%NWL%this . changedFiles = Object . create ( null ) ;%NWL%}%NWL%util . inherits ( Runner , EE ) ;%NWL%Runner . prototype . init = function init ( name , defaults , done )  {%NWL%var self = this;%NWL%self . name = name || grunt . task . current . name || ' watch ' ;%NWL%self . options = self . _options ( grunt . config ( [ self . name ,  ' options ' ] ) || { } , defaults || { } ) ;%NWL%self . nameArgs = ( grunt . task . current . nameArgs ) ? grunt . task . current . nameArgs : self . name;%NWL%8
this . reload = false;%NWL%this . nameArgs = [ ] ;%NWL%this . changedFiles = Object . create ( null ) ;%NWL%}%NWL%util . inherits ( Runner , EE ) ;%NWL%Runner . prototype . init = function init ( name , defaults , done )  {%NWL%var self = this;%NWL%self . name = name || grunt . task . current . name || ' watch ' ;%NWL%self . options = self . _options ( grunt . config ( [ self . name ,  ' options ' ] ) || { } , defaults || { } ) ;%NWL%self . reload = false;%NWL%self . done = done || grunt . task . current . async ( ) ;%NWL%7
taskLRConfig = false;%NWL%}%NWL%}%NWL%if ( taskLRConfig )  {%NWL%self . livereload = livereload ( taskLRConfig ) ;%NWL%}%NWL%if ( self . running )  {%NWL%self . complete ( ) ;%NWL%} else if ( reloadTargets . length > 0 )  {%NWL%self . queue = reloadTargets;%NWL%self . run ( ) ;%NWL%7
reloadTargets = [ ] ;%NWL%self . run ( ) ;%NWL%}%NWL%var targets = self . _getTargets ( self . name ) ;%NWL%if ( self . running === false )  {%NWL%self . queue = targets . filter ( function ( tr )  {%NWL%return tr . options . atBegin === true && tr . tasks . length > 0;%NWL%} ) . map ( function ( tr )  {%NWL%return tr . name;%NWL%} ) ;%NWL%self . run ( ) ;%NWL%1
self . add ( cfg ) ;%NWL%return cfg;%NWL%} , self ) ;%NWL%if ( typeof config . files === ' string ' || Array . isArray ( config . files ) )  {%NWL%var cfg = {%NWL%files: config . files ,%NWL%tasks: config . tasks ,%NWL%name: ' default ' ,%NWL%options: self . _options ( config . options || { } , self . options ) ,%NWL%} ;%NWL%self . add ( cfg ) ;%NWL%0
if ( !tr )  { return next ( ) ; }%NWL%tr . options = self . _options ( grunt . config ( [ self . name , name ,  ' options ' ] ) || { } , tr . options , self . options ) ;%NWL%if ( tr . options . spawn === false || tr . options . nospawn === true )  {%NWL%shouldComplete = false;%NWL%}%NWL%tr . run ( next ) ;%NWL%} , function ( )  {%NWL%if ( shouldComplete )  {%NWL%self . complete ( ) ;%NWL%} else {%NWL%self . done ( ) ;%NWL%8
self . done ( ) ;%NWL%}%NWL%} ) ;%NWL%} , 250 ) ;%NWL%Runner . prototype . add = function add ( target )  {%NWL%if ( !this . targets [ target . name || 0 ] )  {%NWL%var tr = new TaskRun ( target ) ;%NWL%var lrconfig = grunt . config ( [ this . name , target . name || 0 ,  ' options ' ,  ' livereload ' ] ) ;%NWL%if ( lrconfig )  {%NWL%tr . livereload = livereload ( lrconfig ) ;%NWL%tr . livereload = this . livereload;%NWL%9
} ) ;%NWL%} ;%NWL%Runner . prototype . interrupt = function interrupt ( )  {%NWL%var self = this;%NWL%self . _completeQueue ( ) ;%NWL%grunt . task . clearQueue ( ) ;%NWL%self . emit ( ' interrupt ' ) ;%NWL%} ;%NWL%Runner . prototype . forever = function forever ( )  {%NWL%var self = this;%NWL%self . _completeQueue ( ) ;%NWL%4
} ;%NWL%Runner . prototype . interrupt = function interrupt ( )  {%NWL%var self = this;%NWL%self . _completeQueue ( ) ;%NWL%grunt . task . clearQueue ( ) ;%NWL%self . emit ( ' interrupt ' ) ;%NWL%} ;%NWL%Runner . prototype . forever = function forever ( )  {%NWL%var self = this;%NWL%function rerun ( )  {%NWL%grunt . task . clearQueue ( ) ;%NWL%4
delete require . cache [ abspath ] ;%NWL%}%NWL%} ) ;%NWL%} ;%NWL%Runner . prototype . reloadTask = function ( )  {%NWL%var self = this;%NWL%reloadTargets = self . queue;%NWL%self . emit ( ' reload ' , reloadTargets ) ;%NWL%grunt . task . init ( [ self . name ] ) ;%NWL%self . _completeQueue ( ) ;%NWL%self . done ( ) ;%NWL%9
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
var path = require ( ' path ' ) ;%NWL%module . exports = helper = { } ;%NWL%helper . fixtures = path . join ( __dirname ,  ' . . ' ,  ' fixtures ' ) ;%NWL%helper . verboseLog = function ( )  { } ;%NWL%if ( grunt . util . _ . indexOf ( process . argv ,  ' - v ' ) !== - 1 )  {%NWL%helper . verboseLog = function ( )  { console . log . apply ( null , arguments ) ; } ;%NWL%}%NWL%helper . assertTask = function assertTask ( task , options )  {%NWL%var spawn = require ( ' child_process ' ) . spawn;%NWL%task = task || ' default ' ;%NWL%var trigger = options . trigger || ' . * ( Waiting ) . * ' ;%NWL%0
helper . fixtures = path . join ( __dirname ,  ' . . ' ,  ' fixtures ' ) ;%NWL%helper . verboseLog = function ( )  { } ;%NWL%if ( grunt . util . _ . indexOf ( process . argv ,  ' - v ' ) !== - 1 )  {%NWL%helper . verboseLog = function ( )  { console . log . apply ( null , arguments ) ; } ;%NWL%}%NWL%helper . assertTask = function assertTask ( task , options )  {%NWL%var spawn = require ( ' child_process ' ) . spawn;%NWL%task = task || ' default ' ;%NWL%options = options || { } ;%NWL%var trigger = options . trigger || ' . * ( Waiting ) . * ' ;%NWL%var cwd = options . cwd || process . cwd ( ) ;%NWL%9
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%interrupt: function ( test )  {%NWL%test . expect ( 2 ) ;%NWL%var cwd = path . resolve ( fixtures ,  ' nospawn ' ) ;%NWL%var assertWatch = helper . assertTask ( ' watch ' ,  { cwd:cwd } ) ;%NWL%assertWatch ( [ function ( )  {%NWL%var write = ' var interrupt = true; ' ;%NWL%grunt . file . write ( path . join ( cwd ,  ' lib ' ,  ' interrupt . js ' ) , write ) ;%NWL%grunt . file . write ( path . join ( cwd ,  ' lib ' ,  ' interrupt . js ' ) , write ) ;%NWL%9
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%1
' use strict ' ;%NWL%var grunt = require ( ' grunt ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%1
var helper = require ( ' . / helper ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%0
if ( this . isReady )  {%NWL%return;%NWL%}%NWL%this . isReady = true;%NWL%this . lastResult . totalTimeEnd ( ) ;%NWL%emitter . emit ( ' browsers_change ' , this ) ;%NWL%emitter . emit ( ' browser_complete ' , this , result ) ;%NWL%} ;%NWL%this . onDisconnect = function ( )  {%NWL%if ( !this . isReady )  {%NWL%this . lastResult . totalTimeEnd ( ) ;%NWL%4
} ) ;%NWL%this . add = function ( browser )  {%NWL%browsers . push ( browser ) ;%NWL%emitter . emit ( ' browsers_change ' , this ) ;%NWL%} ;%NWL%this . remove = function ( browser )  {%NWL%var index = browsers . indexOf ( browser ) ;%NWL%if ( index === - 1 )  {%NWL%return false;%NWL%}%NWL%emitter . emit ( ' browsers_change ' , this ) ;%NWL%3
browsers . splice ( index , 1 ) ;%NWL%emitter . emit ( ' browsers_change ' , this ) ;%NWL%return true;%NWL%} ;%NWL%this . setAllIsReadyTo = function ( value )  {%NWL%var change = false;%NWL%browsers . forEach ( function ( browser )  {%NWL%change = change || browser . isReady !== value;%NWL%browser . isReady = value;%NWL%} ) ;%NWL%emitter . emit ( ' browsers_change ' , this ) ;%NWL%1
var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var path = require ( ' path ' ) ;%NWL%var optimist = require ( ' optimist ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%var constant = require ( ' . / constants ' ) ;%NWL%var processArgs = function ( argv , options )  {%NWL%if ( argv . help )  {%NWL%console . log ( optimist . help ( ) ) ;%NWL%process . exit ( 0 ) ;%NWL%}%NWL%if ( argv . version )  {%NWL%process . exit ( 0 ) ;%NWL%7
process . exit ( 0 ) ;%NWL%}%NWL%Object . getOwnPropertyNames ( argv ) . forEach ( function ( name )  {%NWL%if ( name !== ' _ ' && name !== ' $0 ' )  {%NWL%options [ helper . dashToCamel ( name ) ] = argv [ name ] ;%NWL%}%NWL%} ) ;%NWL%if ( helper . isString ( options . autoWatch ) )  {%NWL%options . autoWatch = options . autoWatch === ' true ' ;%NWL%}%NWL%options . colors = options . colors === ' true ' ;%NWL%8
if ( name !== ' _ ' && name !== ' $0 ' )  {%NWL%options [ helper . dashToCamel ( name ) ] = argv [ name ] ;%NWL%}%NWL%} ) ;%NWL%if ( helper . isString ( options . autoWatch ) )  {%NWL%options . autoWatch = options . autoWatch === ' true ' ;%NWL%}%NWL%if ( helper . isString ( options . colors ) )  {%NWL%options . colors = options . colors === ' true ' ;%NWL%}%NWL%options . logLevel = constant [ ' LOG_ '  + options . logLevel . toUpperCase ( ) ] || constant . LOG_DISABLE;%NWL%5
} ) ;%NWL%if ( helper . isString ( options . autoWatch ) )  {%NWL%options . autoWatch = options . autoWatch === ' true ' ;%NWL%}%NWL%if ( helper . isString ( options . colors ) )  {%NWL%options . colors = options . colors === ' true ' ;%NWL%}%NWL%if ( helper . isString ( options . logLevel ) )  {%NWL%options . logLevel = constant [ ' LOG_ '  + options . logLevel . toUpperCase ( ) ] || constant . LOG_DISABLE;%NWL%}%NWL%options . singleRun = options . singleRun === ' true ' ;%NWL%2
}%NWL%if ( helper . isString ( options . colors ) )  {%NWL%options . colors = options . colors === ' true ' ;%NWL%}%NWL%if ( helper . isString ( options . logLevel ) )  {%NWL%options . logLevel = constant [ ' LOG_ '  + options . logLevel . toUpperCase ( ) ] || constant . LOG_DISABLE;%NWL%}%NWL%if ( helper . isString ( options . singleRun ) )  {%NWL%options . singleRun = options . singleRun === ' true ' ;%NWL%}%NWL%options . browsers = options . browsers . split ( ' , ' ) ;%NWL%2
}%NWL%if ( helper . isString ( options . singleRun ) )  {%NWL%options . singleRun = options . singleRun === ' true ' ;%NWL%}%NWL%if ( helper . isString ( options . browsers ) )  {%NWL%options . browsers = options . browsers . split ( ' , ' ) ;%NWL%}%NWL%if ( options . reportSlowerThan === false )  {%NWL%options . reportSlowerThan = 0;%NWL%}%NWL%options . reporters = options . reporters . split ( ' , ' ) ;%NWL%2
options . singleRun = options . singleRun === ' true ' ;%NWL%}%NWL%if ( helper . isString ( options . browsers ) )  {%NWL%options . browsers = options . browsers . split ( ' , ' ) ;%NWL%}%NWL%if ( options . reportSlowerThan === false )  {%NWL%options . reportSlowerThan = 0;%NWL%}%NWL%if ( helper . isString ( options . reporters ) )  {%NWL%options . reporters = options . reporters . split ( ' , ' ) ;%NWL%options . configFile = path . resolve ( argv . _ . shift ( ) || ' karma . conf . js ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var vm = require ( ' vm ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var coffee = require ( ' coffee - script ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var vm = require ( ' vm ' ) ;%NWL%var coffee = require ( ' coffee - script ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var vm = require ( ' vm ' ) ;%NWL%var coffee = require ( ' coffee - script ' ) ;%NWL%var log = require ( ' . / logger ' ) . create ( ' config ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%var constant = require ( ' . / constants ' ) ;%NWL%var Pattern = function ( pattern , served , included , watched )  {%NWL%this . pattern = pattern;%NWL%this . served = helper . isDefined ( served ) ? served : true;%NWL%this . watched = helper . isDefined ( watched ) ? watched : true;%NWL%9
}%NWL%return path . resolve ( config . basePath , relativePath ) ;%NWL%} ;%NWL%var createPatternMapper = function ( resolve )  {%NWL%return function ( objectPattern )  {%NWL%objectPattern . pattern = resolve ( objectPattern . pattern ) ;%NWL%return objectPattern;%NWL%} ;%NWL%} ;%NWL%config . files = config . files . map ( createPatternObject ) . map ( createPatternMapper ( basePathResolve ) ) ;%NWL%config . junitReporter . outputFile = basePathResolve ( config . junitReporter . outputFile ) ;%NWL%9
return path . resolve ( config . basePath , relativePath ) ;%NWL%} ;%NWL%var createPatternMapper = function ( resolve )  {%NWL%return function ( objectPattern )  {%NWL%objectPattern . pattern = resolve ( objectPattern . pattern ) ;%NWL%return objectPattern;%NWL%} ;%NWL%} ;%NWL%config . files = config . files . map ( createPatternObject ) . map ( createPatternMapper ( basePathResolve ) ) ;%NWL%config . exclude = config . exclude . map ( basePathResolve ) ;%NWL%config . coverageReporter . dir = basePathResolve ( config . coverageReporter . dir ) ;%NWL%8
} ;%NWL%var createPatternMapper = function ( resolve )  {%NWL%return function ( objectPattern )  {%NWL%objectPattern . pattern = resolve ( objectPattern . pattern ) ;%NWL%return objectPattern;%NWL%} ;%NWL%} ;%NWL%config . files = config . files . map ( createPatternObject ) . map ( createPatternMapper ( basePathResolve ) ) ;%NWL%config . exclude = config . exclude . map ( basePathResolve ) ;%NWL%config . junitReporter . outputFile = basePathResolve ( config . junitReporter . outputFile ) ;%NWL%config . basePath = helper . normalizeWinPath ( config . basePath ) ;%NWL%7
var createPatternMapper = function ( resolve )  {%NWL%return function ( objectPattern )  {%NWL%objectPattern . pattern = resolve ( objectPattern . pattern ) ;%NWL%return objectPattern;%NWL%} ;%NWL%} ;%NWL%config . files = config . files . map ( createPatternObject ) . map ( createPatternMapper ( basePathResolve ) ) ;%NWL%config . exclude = config . exclude . map ( basePathResolve ) ;%NWL%config . junitReporter . outputFile = basePathResolve ( config . junitReporter . outputFile ) ;%NWL%config . coverageReporter . dir = basePathResolve ( config . coverageReporter . dir ) ;%NWL%config . files = config . files . map ( createPatternMapper ( helper . normalizeWinPath ) ) ;%NWL%6
return function ( objectPattern )  {%NWL%objectPattern . pattern = resolve ( objectPattern . pattern ) ;%NWL%return objectPattern;%NWL%} ;%NWL%} ;%NWL%config . files = config . files . map ( createPatternObject ) . map ( createPatternMapper ( basePathResolve ) ) ;%NWL%config . exclude = config . exclude . map ( basePathResolve ) ;%NWL%config . junitReporter . outputFile = basePathResolve ( config . junitReporter . outputFile ) ;%NWL%config . coverageReporter . dir = basePathResolve ( config . coverageReporter . dir ) ;%NWL%config . basePath = helper . normalizeWinPath ( config . basePath ) ;%NWL%config . exclude = config . exclude . map ( helper . normalizeWinPath ) ;%NWL%5
objectPattern . pattern = resolve ( objectPattern . pattern ) ;%NWL%return objectPattern;%NWL%} ;%NWL%} ;%NWL%config . files = config . files . map ( createPatternObject ) . map ( createPatternMapper ( basePathResolve ) ) ;%NWL%config . exclude = config . exclude . map ( basePathResolve ) ;%NWL%config . junitReporter . outputFile = basePathResolve ( config . junitReporter . outputFile ) ;%NWL%config . coverageReporter . dir = basePathResolve ( config . coverageReporter . dir ) ;%NWL%config . basePath = helper . normalizeWinPath ( config . basePath ) ;%NWL%config . files = config . files . map ( createPatternMapper ( helper . normalizeWinPath ) ) ;%NWL%config . junitReporter . outputFile = helper . normalizeWinPath ( config . junitReporter . outputFile ) ;%NWL%4
return objectPattern;%NWL%} ;%NWL%} ;%NWL%config . files = config . files . map ( createPatternObject ) . map ( createPatternMapper ( basePathResolve ) ) ;%NWL%config . exclude = config . exclude . map ( basePathResolve ) ;%NWL%config . junitReporter . outputFile = basePathResolve ( config . junitReporter . outputFile ) ;%NWL%config . coverageReporter . dir = basePathResolve ( config . coverageReporter . dir ) ;%NWL%config . basePath = helper . normalizeWinPath ( config . basePath ) ;%NWL%config . files = config . files . map ( createPatternMapper ( helper . normalizeWinPath ) ) ;%NWL%config . exclude = config . exclude . map ( helper . normalizeWinPath ) ;%NWL%config . coverageReporter . dir = helper . normalizeWinPath ( config . coverageReporter . dir ) ;%NWL%3
} ,%NWL%loggers: [ constant . CONSOLE_APPENDER ]%NWL%} ;%NWL%Object . getOwnPropertyNames ( config ) . forEach ( function ( key )  {%NWL%if ( cliOptions . hasOwnProperty ( key ) )  {%NWL%config [ key ] = cliOptions [ key ] ;%NWL%} else if ( configFromFile . hasOwnProperty ( key ) )  {%NWL%config [ key ] = configFromFile [ key ] ;%NWL%}%NWL%} ) ;%NWL%config . basePath = path . resolve ( path . dirname ( configFilePath ) , config . basePath ) ;%NWL%5
var events = require ( ' events ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var glob = require ( ' glob ' ) ;%NWL%var q = require ( ' q ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var glob = require ( ' glob ' ) ;%NWL%var mm = require ( ' minimatch ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var files = {%NWL%served: [ ] ,%NWL%included: [ ]%NWL%} ;%NWL%buckets . forEach ( function ( bucket , idx )  {%NWL%bucket . sort ( byPath ) . forEach ( function ( file )  {%NWL%if ( !uniqueMap [ file . path ] )  {%NWL%if ( patterns [ idx ] . served )  {%NWL%files . served . push ( file ) ;%NWL%}%NWL%files . included . push ( file ) ;%NWL%8
var fs  = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var OS = / ( iPhone OS|Mac OS X|Windows|Linux ) / ;%NWL%0
var fs  = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var _  = require ( ' lodash ' ) ;%NWL%var OS = / ( iPhone OS|Mac OS X|Windows|Linux ) / ;%NWL%var OS_MAP = {%NWL%' iPhone OS ' : ' iOS ' ,%NWL%' Mac OS X ' : ' Mac '%NWL%} ;%NWL%var BROWSER = / ( Chrome|Firefox|Opera|Safari|PhantomJS ) \ / ( [ 0 - 9 ] * \ . [ 0 - 9 ] * ) / ;%NWL%var MSIE = / MSIE ( [ 0 - 9 ] * \ . [ 0 - 9 ] * ) / ;%NWL%0
exports . VERSION = require ( ' . / constants ' ) . VERSION;%NWL%exports . server = require ( ' . / server ' ) ;%NWL%exports . launcher = require ( ' . / launcher ' ) ;%NWL%1
var readline = require ( ' readline ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var readline = require ( ' readline ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%0
var readline = require ( ' readline ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var glob = require ( ' glob ' ) ;%NWL%0
var readline = require ( ' readline ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var readline = require ( ' readline ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var glob = require ( ' glob ' ) ;%NWL%var launcher = require ( ' . / launcher ' ) ;%NWL%0
var readline = require ( ' readline ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var glob = require ( ' glob ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%0
var currentOptionsPointer;%NWL%var pendingQuestionId;%NWL%var done;%NWL%this . onKeypress = function ( key )  {%NWL%if ( !currentOptions || !key )  {%NWL%return;%NWL%}%NWL%if ( key . name === ' tab ' || key . name === ' right ' || key . name === ' down ' )  {%NWL%this . suggestNextOption ( ) ;%NWL%} else if ( key . name === ' left ' || key . name === ' up ' )  {%NWL%this . suggestNextOption ( ) ;%NWL%8
answers [ pendingQuestionId ] . push ( line ) ;%NWL%rli . prompt ( ) ;%NWL%if ( currentOptions )  {%NWL%currentOptions . splice ( currentOptionsPointer , 1 ) ;%NWL%currentOptionsPointer = - 1;%NWL%}%NWL%} else {%NWL%this . nextQuestion ( ) ;%NWL%}%NWL%} else {%NWL%this . nextQuestion ( ) ;%NWL%7
this . suggestNextOption ( ) ;%NWL%} else {%NWL%pendingQuestionId = null;%NWL%currentOptions = null;%NWL%done ( answers ) ;%NWL%}%NWL%} ;%NWL%this . process = function ( _questions , _done )  {%NWL%questions = _questions;%NWL%answers = { } ;%NWL%this . nextQuestion ( ) ;%NWL%0
} ;%NWL%var getReplacementsFromAnswers = function ( answers , basePath )  {%NWL%var files = answers . files . map ( answers . includedFiles ? quoteNonIncludedPattern : quote ) ;%NWL%if ( answers . includedFiles )  {%NWL%files = answers . includedFiles . map ( quote ) . concat ( files ) ;%NWL%}%NWL%if ( answers . requirejs )  {%NWL%files . unshift ( ' REQUIRE_ADAPTER ' ) ;%NWL%files . unshift ( ' REQUIRE ' ) ;%NWL%}%NWL%var framework = answers . framework . toUpperCase ( ) ;%NWL%2
var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var crypto = require ( ' crypto ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
fs . writeFile ( file . contentPath , processed , function ( err )  {%NWL%done ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%}%NWL%return process . nextTick ( done ) ;%NWL%} ;%NWL%} ;%NWL%exports . Live = require ( ' . / preprocessors / Live ' ) ;%NWL%exports . Html2js = require ( ' . / preprocessors / Html2js ' ) ;%NWL%9
done ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%}%NWL%return process . nextTick ( done ) ;%NWL%} ;%NWL%} ;%NWL%exports . Live = require ( ' . / preprocessors / Live ' ) ;%NWL%exports . Coffee = require ( ' . / preprocessors / Coffee ' ) ;%NWL%exports . Coverage = require ( ' . / preprocessors / Coverage ' ) ;%NWL%8
var Reporter = exports [ helper . ucFirst ( name )  +  ( config . colors ? ' Color ' : ' ' ) ] ;%NWL%if ( Reporter )  {%NWL%var reporter = new Reporter ( errorFormatter , config . reportSlowerThan ) ;%NWL%return multiReporter . reporters . push ( reporter ) ;%NWL%}%NWL%log . error ( ' Reporter " %s " does not exist! ' , name ) ;%NWL%} ) ;%NWL%return multiReporter;%NWL%} ;%NWL%exports . Dots = require ( ' . / reporters / Dots ' ) ;%NWL%exports . DotsColor = require ( ' . / reporters / DotsColor ' ) ;%NWL%9
if ( Reporter )  {%NWL%var reporter = new Reporter ( errorFormatter , config . reportSlowerThan ) ;%NWL%return multiReporter . reporters . push ( reporter ) ;%NWL%}%NWL%log . error ( ' Reporter " %s " does not exist! ' , name ) ;%NWL%} ) ;%NWL%return multiReporter;%NWL%} ;%NWL%exports . Dots = require ( ' . / reporters / Dots ' ) ;%NWL%exports . Progress = require ( ' . / reporters / Progress ' ) ;%NWL%exports . ProgressColor = require ( ' . / reporters / ProgressColor ' ) ;%NWL%8
var reporter = new Reporter ( errorFormatter , config . reportSlowerThan ) ;%NWL%return multiReporter . reporters . push ( reporter ) ;%NWL%}%NWL%log . error ( ' Reporter " %s " does not exist! ' , name ) ;%NWL%} ) ;%NWL%return multiReporter;%NWL%} ;%NWL%exports . Dots = require ( ' . / reporters / Dots ' ) ;%NWL%exports . Progress = require ( ' . / reporters / Progress ' ) ;%NWL%exports . DotsColor = require ( ' . / reporters / DotsColor ' ) ;%NWL%exports . JUnit = require ( ' . / reporters / JUnit ' ) ;%NWL%7
return multiReporter . reporters . push ( reporter ) ;%NWL%}%NWL%log . error ( ' Reporter " %s " does not exist! ' , name ) ;%NWL%} ) ;%NWL%return multiReporter;%NWL%} ;%NWL%exports . Dots = require ( ' . / reporters / Dots ' ) ;%NWL%exports . Progress = require ( ' . / reporters / Progress ' ) ;%NWL%exports . DotsColor = require ( ' . / reporters / DotsColor ' ) ;%NWL%exports . ProgressColor = require ( ' . / reporters / ProgressColor ' ) ;%NWL%exports . Coverage = require ( ' . / reporters / Coverage ' ) ;%NWL%6
}%NWL%log . error ( ' Reporter " %s " does not exist! ' , name ) ;%NWL%} ) ;%NWL%return multiReporter;%NWL%} ;%NWL%exports . Dots = require ( ' . / reporters / Dots ' ) ;%NWL%exports . Progress = require ( ' . / reporters / Progress ' ) ;%NWL%exports . DotsColor = require ( ' . / reporters / DotsColor ' ) ;%NWL%exports . ProgressColor = require ( ' . / reporters / ProgressColor ' ) ;%NWL%exports . JUnit = require ( ' . / reporters / JUnit ' ) ;%NWL%exports . Teamcity = exports . TeamcityColor = require ( ' . / reporters / Teamcity ' ) ;%NWL%5
log . error ( ' Reporter " %s " does not exist! ' , name ) ;%NWL%} ) ;%NWL%return multiReporter;%NWL%} ;%NWL%exports . Dots = require ( ' . / reporters / Dots ' ) ;%NWL%exports . Progress = require ( ' . / reporters / Progress ' ) ;%NWL%exports . DotsColor = require ( ' . / reporters / DotsColor ' ) ;%NWL%exports . ProgressColor = require ( ' . / reporters / ProgressColor ' ) ;%NWL%exports . JUnit = require ( ' . / reporters / JUnit ' ) ;%NWL%exports . Coverage = require ( ' . / reporters / Coverage ' ) ;%NWL%exports . Growl = require ( ' . / reporters / Growl ' ) ;%NWL%4
var net = require ( ' net ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var io = require ( ' socket . io ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var cfg = require ( ' . / config ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%0
var io = require ( ' socket . io ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var cfg = require ( ' . / config ' ) ;%NWL%var ws = require ( ' . / web - server ' ) ;%NWL%var browser = require ( ' . / browser ' ) ;%NWL%0
var io = require ( ' socket . io ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var cfg = require ( ' . / config ' ) ;%NWL%var ws = require ( ' . / web - server ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%var reporter = require ( ' . / reporter ' ) ;%NWL%0
var io = require ( ' socket . io ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var cfg = require ( ' . / config ' ) ;%NWL%var ws = require ( ' . / web - server ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%var browser = require ( ' . / browser ' ) ;%NWL%var events = require ( ' . / events ' ) ;%NWL%0
var io = require ( ' socket . io ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var cfg = require ( ' . / config ' ) ;%NWL%var ws = require ( ' . / web - server ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%var browser = require ( ' . / browser ' ) ;%NWL%var reporter = require ( ' . / reporter ' ) ;%NWL%var events = require ( ' . / events ' ) ;%NWL%var watcher = require ( ' . / watcher ' ) ;%NWL%0
var io = require ( ' socket . io ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%var cfg = require ( ' . / config ' ) ;%NWL%var ws = require ( ' . / web - server ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%var browser = require ( ' . / browser ' ) ;%NWL%var reporter = require ( ' . / reporter ' ) ;%NWL%var events = require ( ' . / events ' ) ;%NWL%var constant = require ( ' . / constants ' ) ;%NWL%var preprocessor = require ( ' . / preprocessor ' ) ;%NWL%0
var cfg = require ( ' . / config ' ) ;%NWL%var ws = require ( ' . / web - server ' ) ;%NWL%var logger = require ( ' . / logger ' ) ;%NWL%var browser = require ( ' . / browser ' ) ;%NWL%var reporter = require ( ' . / reporter ' ) ;%NWL%var events = require ( ' . / events ' ) ;%NWL%var constant = require ( ' . / constants ' ) ;%NWL%var watcher = require ( ' . / watcher ' ) ;%NWL%var preprocessor = require ( ' . / preprocessor ' ) ;%NWL%var Launcher = require ( ' . / launcher ' ) . Launcher;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%2
if ( !capturedBrowsers . length )  {%NWL%log . warn ( ' No captured browser , open http: / / '  + config . hostname +  ' : '  + config . port + config . urlRoot ) ;%NWL%socket . end ( ' No captured browser , open http: / / '  + config . hostname +  ' : '  + config . port + config . urlRoot +  ' \n ' ) ;%NWL%return;%NWL%}%NWL%log . debug ( ' Refreshing all the files / patterns ' ) ;%NWL%webServer . updateFilesPromise ( fileList . refresh ( ) ) ;%NWL%globalEmitter . once ( ' run_start ' , function ( )  {%NWL%var socketWrite = socket . write . bind ( socket ) ;%NWL%resultReporter . addAdapter ( socketWrite ) ;%NWL%resultReporter . removeAdapter ( socketWrite ) ;%NWL%9
}%NWL%} ) ;%NWL%runnerServer . on ( ' error ' , function ( e )  {%NWL%if ( e . code === ' EADDRINUSE ' )  {%NWL%log . warn ( ' Port %d in use ' , config . runnerPort ) ;%NWL%config . runnerPort + + ;%NWL%runnerServer . listen ( config . runnerPort ) ;%NWL%} else {%NWL%throw e;%NWL%}%NWL%runnerServer . listen ( config . runnerPort ) ;%NWL%6
var chokidar = require ( ' chokidar ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var querystring = require ( ' querystring ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var querystring = require ( ' querystring ' ) ;%NWL%var pause = require ( ' pause ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var querystring = require ( ' querystring ' ) ;%NWL%var httpProxy = require ( ' http - proxy ' ) ;%NWL%var mime = require ( ' mime ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var querystring = require ( ' querystring ' ) ;%NWL%var httpProxy = require ( ' http - proxy ' ) ;%NWL%var pause = require ( ' pause ' ) ;%NWL%var helper = require ( ' . / helper ' ) ;%NWL%0
var fs = require ( ' fs ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var querystring = require ( ' querystring ' ) ;%NWL%var httpProxy = require ( ' http - proxy ' ) ;%NWL%var pause = require ( ' pause ' ) ;%NWL%var mime = require ( ' mime ' ) ;%NWL%var proxy = require ( ' . / proxy ' ) ;%NWL%0
var spawn = require ( ' child_process ' ) . spawn;%NWL%var path = require ( ' path ' ) ;%NWL%var rimraf = require ( ' rimraf ' ) ;%NWL%1
self . _process . kill ( ) ;%NWL%} else {%NWL%process . nextTick ( exitCallback ) ;%NWL%}%NWL%} ;%NWL%this . _onTimeout = function ( )  {%NWL%if ( self . state !== BEING_CAPTURED )  {%NWL%return;%NWL%}%NWL%log . warn ( ' %s have not captured in %d ms , killing . ' , self . name , captureTimeout ) ;%NWL%self . _process . kill ( ) ;%NWL%0
helper . formatTimeInterval ( results . netTime ) ) ;%NWL%}%NWL%return msg;%NWL%} ;%NWL%this . renderBrowser = this . renderBrowser . bind ( this ) ;%NWL%this . write = function ( )  {%NWL%var msg = util . format . apply ( null , Array . prototype . slice . call ( arguments ) ) ;%NWL%this . adapters . forEach ( function ( adapter )  {%NWL%adapter ( msg ) ;%NWL%} ) ;%NWL%this . writeCommonMsg = this . write;%NWL%4
this . onBrowserDump = function ( browser , dump )  {%NWL%if ( dump . length === 1 )  {%NWL%dump = dump [ 0 ] ;%NWL%}%NWL%dump = util . inspect ( dump , false , undefined , this . USE_COLORS ) ;%NWL%this . writeCommonMsg ( browser +  ' LOG: '  + dump +  ' \n ' ) ;%NWL%} ;%NWL%this . onSpecComplete = function ( browser , result )  {%NWL%if ( result . skipped )  {%NWL%this . specSkipped ( browser , result ) ;%NWL%this . specSuccess ( browser , result ) ;%NWL%9
dump = dump [ 0 ] ;%NWL%}%NWL%dump = util . inspect ( dump , false , undefined , this . USE_COLORS ) ;%NWL%this . writeCommonMsg ( browser +  ' LOG: '  + dump +  ' \n ' ) ;%NWL%} ;%NWL%this . onSpecComplete = function ( browser , result )  {%NWL%if ( result . skipped )  {%NWL%this . specSkipped ( browser , result ) ;%NWL%} else if ( result . success )  {%NWL%this . specSuccess ( browser , result ) ;%NWL%this . specFailure ( browser , result ) ;%NWL%7
var colors = require ( ' colors ' ) ;%NWL%var BaseColorReporter = function ( )  {%NWL%this . USE_COLORS = true;%NWL%this . SPEC_FAILURE = ' %s %s FAILED ' . red +  ' \n ' ;%NWL%this . SPEC_SLOW = ' %s SLOW %s: %s ' . yellow +  ' \n ' ;%NWL%this . ERROR = ' %s ERROR ' . red +  ' \n ' ;%NWL%this . FINISHED_SUCCESS = ' SUCCESS ' . green;%NWL%5
var colors = require ( ' colors ' ) ;%NWL%var BaseColorReporter = function ( )  {%NWL%this . USE_COLORS = true;%NWL%this . SPEC_FAILURE = ' %s %s FAILED ' . red +  ' \n ' ;%NWL%this . SPEC_SLOW = ' %s SLOW %s: %s ' . yellow +  ' \n ' ;%NWL%this . ERROR = ' %s ERROR ' . red +  ' \n ' ;%NWL%this . FINISHED_ERROR = ' ERROR ' . red;%NWL%this . FINISHED_DISCONNECTED = ' DISCONNECTED ' . red;%NWL%5
var colors = require ( ' colors ' ) ;%NWL%var BaseColorReporter = function ( )  {%NWL%this . USE_COLORS = true;%NWL%this . SPEC_FAILURE = ' %s %s FAILED ' . red +  ' \n ' ;%NWL%this . SPEC_SLOW = ' %s SLOW %s: %s ' . yellow +  ' \n ' ;%NWL%this . ERROR = ' %s ERROR ' . red +  ' \n ' ;%NWL%this . FINISHED_ERROR = ' ERROR ' . red;%NWL%this . FINISHED_SUCCESS = ' SUCCESS ' . green;%NWL%this . X_FAILED = '  ( %d FAILED ) ' . red;%NWL%5
var colors = require ( ' colors ' ) ;%NWL%var BaseColorReporter = function ( )  {%NWL%this . USE_COLORS = true;%NWL%this . SPEC_FAILURE = ' %s %s FAILED ' . red +  ' \n ' ;%NWL%this . SPEC_SLOW = ' %s SLOW %s: %s ' . yellow +  ' \n ' ;%NWL%this . ERROR = ' %s ERROR ' . red +  ' \n ' ;%NWL%this . FINISHED_ERROR = ' ERROR ' . red;%NWL%this . FINISHED_SUCCESS = ' SUCCESS ' . green;%NWL%this . FINISHED_DISCONNECTED = ' DISCONNECTED ' . red;%NWL%this . TOTAL_SUCCESS = ' TOTAL: %d SUCCESS ' . green +  ' \n ' ;%NWL%5
var colors = require ( ' colors ' ) ;%NWL%var BaseColorReporter = function ( )  {%NWL%this . USE_COLORS = true;%NWL%this . SPEC_FAILURE = ' %s %s FAILED ' . red +  ' \n ' ;%NWL%this . SPEC_SLOW = ' %s SLOW %s: %s ' . yellow +  ' \n ' ;%NWL%this . ERROR = ' %s ERROR ' . red +  ' \n ' ;%NWL%this . FINISHED_ERROR = ' ERROR ' . red;%NWL%this . FINISHED_SUCCESS = ' SUCCESS ' . green;%NWL%this . FINISHED_DISCONNECTED = ' DISCONNECTED ' . red;%NWL%this . X_FAILED = '  ( %d FAILED ) ' . red;%NWL%this . TOTAL_FAILED = ' TOTAL: %d FAILED , %d SUCCESS ' . red +  ' \n ' ;%NWL%5
var path = require ( ' path ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var istanbul = require ( ' istanbul ' ) ;%NWL%0
var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var dateformat = require ( ' dateformat ' ) ;%NWL%0
var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%var istanbul = require ( ' istanbul ' ) ;%NWL%var helper = require ( ' . . / helper ' ) ;%NWL%0
var util = require ( ' util ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%0
var util = require ( ' util ' ) ;%NWL%var growly = require ( ' growly ' ) ;%NWL%var helper = require ( ' . . / helper ' ) ;%NWL%0
var os = require ( ' os ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%0
var os = require ( ' os ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var builder = require ( ' xmlbuilder ' ) ;%NWL%var helper = require ( ' . . / helper ' ) ;%NWL%0
var helper = require ( ' . . / helper ' ) ;%NWL%var reporters = this . reporters = [ ] ;%NWL%0
var BaseReporter = require ( ' . / Base ' ) ;%NWL%var ProgressReporter = function ( formatError , reportSlow )  {%NWL%BaseReporter . call ( this , formatError , reportSlow ) ;%NWL%this . writeCommonMsg = function ( msg )  {%NWL%this . write ( this . _remove ( )  + msg + this . _render ( ) ) ;%NWL%} ;%NWL%this . specSuccess = function ( browser )  {%NWL%this . write ( this . _refresh ( ) ) ;%NWL%} ;%NWL%this . write ( this . _refresh ( ) ) ;%NWL%7
} ;%NWL%this . specSuccess = function ( browser , result )  {%NWL%var browseResult = this . checkNewSuit ( browser , result ) ;%NWL%var testName = getTestName ( result ) ;%NWL%browseResult . log . push ( util . format ( this . TEST_START , escTCString ( testName ) ) ) ;%NWL%browseResult . log . push ( util . format ( this . TEST_END ,%NWL%escTCString ( testName ) , result . time ) ) ;%NWL%} ;%NWL%this . specFailure = function ( browser , result )  {%NWL%var browseResult = this . checkNewSuit ( browser , result ) ;%NWL%browseResult . log . push ( util . format ( this . TEST_START , escTCString ( testName ) ) ) ;%NWL%4
var testName = getTestName ( result ) ;%NWL%browseResult . log . push ( util . format ( this . TEST_START , escTCString ( testName ) ) ) ;%NWL%browseResult . log . push ( util . format ( this . TEST_END ,%NWL%escTCString ( testName ) , result . time ) ) ;%NWL%} ;%NWL%this . specFailure = function ( browser , result )  {%NWL%var browseResult = this . checkNewSuit ( browser , result ) ;%NWL%var testName = getTestName ( result ) ;%NWL%browseResult . log . push ( util . format ( this . TEST_START , escTCString ( testName ) ) ) ;%NWL%browseResult . log . push ( util . format ( this . TEST_FAILED , escTCString ( testName ) ,%NWL%browseResult . log . push ( util . format ( this . TEST_END ,%NWL%2
fs = require ( ' fs ' ) ;%NWL%sysPath = require ( ' path ' ) ;%NWL%isBinary = require ( ' . / is - binary ' ) ;%NWL%nodeVersion = process . versions . node . substring ( 0 , 3 ) ;%NWL%exports . FSWatcher = FSWatcher = ( function ( _super )  {%NWL%__extends ( FSWatcher , _super ) ;%NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%9
sysPath = require ( ' path ' ) ;%NWL%isBinary = require ( ' . / is - binary ' ) ;%NWL%nodeVersion = process . versions . node . substring ( 0 , 3 ) ;%NWL%exports . FSWatcher = FSWatcher = ( function ( _super )  {%NWL%__extends ( FSWatcher , _super ) ;%NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%8
isBinary = require ( ' . / is - binary ' ) ;%NWL%nodeVersion = process . versions . node . substring ( 0 , 3 ) ;%NWL%exports . FSWatcher = FSWatcher = ( function ( _super )  {%NWL%__extends ( FSWatcher , _super ) ;%NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%7
nodeVersion = process . versions . node . substring ( 0 , 3 ) ;%NWL%exports . FSWatcher = FSWatcher = ( function ( _super )  {%NWL%__extends ( FSWatcher , _super ) ;%NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleFile = __bind ( this . _handleFile , this ) ;%NWL%6
exports . FSWatcher = FSWatcher = ( function ( _super )  {%NWL%__extends ( FSWatcher , _super ) ;%NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%this . _watch = __bind ( this . _watch , this ) ;%NWL%5
__extends ( FSWatcher , _super ) ;%NWL%function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%this . _handleFile = __bind ( this . _handleFile , this ) ;%NWL%this . _remove = __bind ( this . _remove , this ) ;%NWL%4
function FSWatcher ( options )  {%NWL%var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%this . _handleFile = __bind ( this . _handleFile , this ) ;%NWL%this . _watch = __bind ( this . _watch , this ) ;%NWL%this . _hasReadPermissions = __bind ( this . _hasReadPermissions , this ) ;%NWL%3
var _base , _base1 , _base2 , _base3 , _base4 , _ref , _ref1 , _ref2 , _ref3 , _ref4 ,%NWL%_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%this . _handleFile = __bind ( this . _handleFile , this ) ;%NWL%this . _watch = __bind ( this . _watch , this ) ;%NWL%this . _remove = __bind ( this . _remove , this ) ;%NWL%this . _removeFromWatchedDir = __bind ( this . _removeFromWatchedDir , this ) ;%NWL%2
_this = this;%NWL%this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%this . _handleFile = __bind ( this . _handleFile , this ) ;%NWL%this . _watch = __bind ( this . _watch , this ) ;%NWL%this . _remove = __bind ( this . _remove , this ) ;%NWL%this . _hasReadPermissions = __bind ( this . _hasReadPermissions , this ) ;%NWL%this . _addToWatchedDir = __bind ( this . _addToWatchedDir , this ) ;%NWL%1
this . options = options != null ? options : { } ;%NWL%this . close = __bind ( this . close , this ) ;%NWL%this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%this . _handleFile = __bind ( this . _handleFile , this ) ;%NWL%this . _watch = __bind ( this . _watch , this ) ;%NWL%this . _remove = __bind ( this . _remove , this ) ;%NWL%this . _hasReadPermissions = __bind ( this . _hasReadPermissions , this ) ;%NWL%this . _removeFromWatchedDir = __bind ( this . _removeFromWatchedDir , this ) ;%NWL%this . _getWatchedDir = __bind ( this . _getWatchedDir , this ) ;%NWL%0
this . add = __bind ( this . add , this ) ;%NWL%this . _handle = __bind ( this . _handle , this ) ;%NWL%this . _handleDir = __bind ( this . _handleDir , this ) ;%NWL%this . _handleFile = __bind ( this . _handleFile , this ) ;%NWL%this . _watch = __bind ( this . _watch , this ) ;%NWL%this . _remove = __bind ( this . _remove , this ) ;%NWL%this . _hasReadPermissions = __bind ( this . _hasReadPermissions , this ) ;%NWL%this . _removeFromWatchedDir = __bind ( this . _removeFromWatchedDir , this ) ;%NWL%this . _addToWatchedDir = __bind ( this . _addToWatchedDir , this ) ;%NWL%this . _getWatchedDir = __bind ( this . _getWatchedDir , this ) ;%NWL%this . watched = Object . create ( null ) ;%NWL%0
global . chai = require ( ' chai ' ) ;%NWL%global . should = chai . should ( ) ;%NWL%0
exports . run = function ( code , options )  {%NWL%var answer , mainModule;%NWL%if ( options == null )  {%NWL%options = { } ;%NWL%}%NWL%mainModule = require . main;%NWL%if ( options . sourceMap == null )  {%NWL%options . sourceMap = true;%NWL%}%NWL%mainModule . filename = process . argv [ 1 ] = options . filename ? fs . realpathSync ( options . filename ) : ' . ' ;%NWL%mainModule . paths = require ( ' module ' ) . _nodeModulePaths ( path . dirname ( fs . realpathSync ( options . filename || ' . ' ) ) ) ;%NWL%9
sandbox . require = _require = function ( path )  {%NWL%return Module . _load ( path , _module , true ) ;%NWL%} ;%NWL%_module . filename = sandbox . __filename;%NWL%_ref1 = Object . getOwnPropertyNames ( require ) ;%NWL%for ( _i = 0 , _len = _ref1 . length; _i < _len; _i + + )  {%NWL%r = _ref1 [ _i ] ;%NWL%if ( r !== ' paths ' )  {%NWL%_require [ r ] = require [ r ] ;%NWL%}%NWL%_require . paths = _module . paths = Module . _nodeModulePaths ( process . cwd ( ) ) ;%NWL%8
var line , lines , maybe_code;%NWL%maybe_code = true;%NWL%lines = ( function ( )  {%NWL%var _i , _len , _ref1 , _results;%NWL%_ref1 = code . split ( ' \n ' ) ;%NWL%_results = [ ] ;%NWL%for ( _i = 0 , _len = _ref1 . length; _i < _len; _i + + )  {%NWL%line = _ref1 [ _i ] ;%NWL%if ( maybe_code && / ^ ( [  ] { 4 } | [  ] { 0 , 3 } \t ) / . test ( line ) )  {%NWL%_results . push ( line ) ;%NWL%_results . push ( line ) ;%NWL%9
useWinPathSep = false;%NWL%}%NWL%pathSep = useWinPathSep ? / \\|\ / / : / \ / / ;%NWL%parts = file . split ( pathSep ) ;%NWL%file = parts [ parts . length - 1 ] ;%NWL%if ( !stripExt )  {%NWL%return file;%NWL%}%NWL%parts = file . split ( ' . ' ) ;%NWL%parts . pop ( ) ;%NWL%parts . pop ( ) ;%NWL%9
return;%NWL%}%NWL%multiline . enabled = !multiline . enabled;%NWL%rli . line = ' ' ;%NWL%rli . cursor = 0;%NWL%rli . output . cursorTo ( 0 ) ;%NWL%rli . output . clearLine ( 1 ) ;%NWL%multiline . buffer = multiline . buffer . replace ( / \n / g ,  ' \uFF00 ' ) ;%NWL%rli . emit ( ' line ' , multiline . buffer ) ;%NWL%multiline . buffer = ' ' ;%NWL%multiline . enabled = !multiline . enabled;%NWL%7
var tok;%NWL%tok = [ tag , value ] ;%NWL%tok . generated = true;%NWL%return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%9
tok = [ tag , value ] ;%NWL%tok . generated = true;%NWL%return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%8
tok . generated = true;%NWL%return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . addImplicitIndentation ( ) ;%NWL%7
return tok;%NWL%} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%this . tagPostfixConditionals ( ) ;%NWL%6
} ;%NWL%exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%this . addImplicitIndentation ( ) ;%NWL%this . addImplicitBracesAndParens ( ) ;%NWL%5
exports . Rewriter = ( function ( )  {%NWL%function Rewriter ( )  { }%NWL%Rewriter . prototype . rewrite = function ( tokens )  {%NWL%this . tokens = tokens;%NWL%this . removeLeadingNewlines ( ) ;%NWL%this . removeMidExpressionNewlines ( ) ;%NWL%this . closeOpenCalls ( ) ;%NWL%this . closeOpenIndexes ( ) ;%NWL%this . addImplicitIndentation ( ) ;%NWL%this . tagPostfixConditionals ( ) ;%NWL%this . addLocationDataToGeneratedTokens ( ) ;%NWL%4
while ( inImplicitCall ( ) )  {%NWL%endImplicitCall ( ) ;%NWL%}%NWL%}%NWL%if ( inImplicitControl ( ) )  {%NWL%stack . pop ( ) ;%NWL%}%NWL%stack . push ( [ tag , i ] ) ;%NWL%return forward ( 1 ) ;%NWL%}%NWL%stack . push ( [ tag , i ] ) ;%NWL%7
}%NWL%if ( __indexOf . call ( EXPRESSION_END , tag ) >= 0 )  {%NWL%while ( inImplicit ( ) )  {%NWL%if ( inImplicitCall ( ) )  {%NWL%endImplicitCall ( ) ;%NWL%} else if ( inImplicitObject ( ) )  {%NWL%endImplicitObject ( ) ;%NWL%} else {%NWL%stack . pop ( ) ;%NWL%}%NWL%stack . pop ( ) ;%NWL%8
Rewriter . prototype . indentation = function ( implicit )  {%NWL%var indent , outdent;%NWL%if ( implicit == null )  {%NWL%implicit = false;%NWL%}%NWL%indent = [ ' INDENT ' , 2 ] ;%NWL%outdent = [ ' OUTDENT ' , 2 ] ;%NWL%if ( implicit )  {%NWL%indent . generated = outdent . generated = true;%NWL%}%NWL%indent . explicit = outdent . explicit = true;%NWL%8
}%NWL%options = options || { }%NWL%this . EOF = { }%NWL%this . _emitQueue = [ ]%NWL%this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%this . cwd = options . cwd%NWL%4
options = options || { }%NWL%this . EOF = { }%NWL%this . _emitQueue = [ ]%NWL%this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%3
this . _emitQueue = [ ]%NWL%this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%this . root = options . root || path . resolve ( this . cwd ,  " / " )%NWL%1
this . maxDepth = options . maxDepth || 1000%NWL%this . maxLength = options . maxLength || Infinity%NWL%this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%}%NWL%this . root = path . resolve ( this . root )%NWL%0
this . statCache = options . statCache || { }%NWL%this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%}%NWL%this . root = options . root || path . resolve ( this . cwd ,  " / " )%NWL%this . root = path . resolve ( this . root )%NWL%this . root = this . root . replace ( / \\ / g ,  " / " )%NWL%0
this . changedCwd = false%NWL%var cwd = process . cwd ( )%NWL%if ( !options . hasOwnProperty ( " cwd " ) ) this . cwd = cwd%NWL%else {%NWL%this . cwd = options . cwd%NWL%this . changedCwd = path . resolve ( options . cwd ) !== cwd%NWL%}%NWL%this . root = options . root || path . resolve ( this . cwd ,  " / " )%NWL%this . root = path . resolve ( this . root )%NWL%if ( process . platform === " win32 " )%NWL%this . nomount = !!options . nomount%NWL%4
this . root = this . root . replace ( / \\ / g ,  " / " )%NWL%this . nomount = !!options . nomount%NWL%if ( !pattern )  {%NWL%throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%this . strict = options . strict !== false%NWL%0
this . nomount = !!options . nomount%NWL%if ( !pattern )  {%NWL%throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . dot = !!options . dot%NWL%0
if ( !pattern )  {%NWL%throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . mark = !!options . mark%NWL%9
throw new Error ( " must provide pattern " )%NWL%}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . sync = !!options . sync%NWL%8
}%NWL%if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . nounique = !!options . nounique%NWL%7
if ( options . matchBase && - 1 === pattern . indexOf ( " / " ) )  {%NWL%if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nonull = !!options . nonull%NWL%6
if ( options . noglobstar )  {%NWL%throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nosort = !!options . nosort%NWL%5
throw new Error ( " base matching requires globstar " )%NWL%}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nocase = !!options . nocase%NWL%4
}%NWL%pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . stat = !!options . stat%NWL%3
pattern = " * * / "  + pattern%NWL%}%NWL%this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%2
this . strict = options . strict !== false%NWL%this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%this . log = console . error%NWL%0
this . dot = !!options . dot%NWL%this . mark = !!options . mark%NWL%this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if ( this . debug )%NWL%this . silent = !!options . silent%NWL%0
this . sync = !!options . sync%NWL%this . nounique = !!options . nounique%NWL%this . nonull = !!options . nonull%NWL%this . nosort = !!options . nosort%NWL%this . nocase = !!options . nocase%NWL%this . stat = !!options . stat%NWL%this . debug = !!options . debug || !!options . globDebug%NWL%if ( this . debug )%NWL%this . log = console . error%NWL%this . silent = !!options . silent%NWL%this . options = mm . options%NWL%0
}%NWL%Glob . prototype . pause = function ( )  {%NWL%if ( this . paused ) return%NWL%if ( this . sync )%NWL%this . emit ( " error " , new Error ( " Can ' t pause / resume sync glob " ) )%NWL%this . paused = true%NWL%this . emit ( " pause " )%NWL%}%NWL%Glob . prototype . resume = function ( )  {%NWL%if ( !this . paused ) return%NWL%this . emit ( " error " , new Error ( " Can ' t pause / resume sync glob " ) )%NWL%4
}%NWL%Glob . prototype . resume = function ( )  {%NWL%if ( !this . paused ) return%NWL%if ( this . sync )%NWL%this . emit ( " error " , new Error ( " Can ' t pause / resume sync glob " ) )%NWL%this . paused = false%NWL%this . emit ( " resume " )%NWL%this . _processEmitQueue ( )%NWL%}%NWL%Glob . prototype . emitMatch = function ( m )  {%NWL%this . _processEmitQueue ( )%NWL%7
function open ( path , flags , mode , cb )  {%NWL%cb = cb || noop%NWL%fs . _curOpen + +%NWL%fs . _originalFs . open . call ( fs , path , flags , mode , function ( er , fd )  {%NWL%if ( er ) onclose ( )%NWL%cb ( er , fd )%NWL%} )%NWL%}%NWL%fs . openSync = function ( path , flags , mode )  {%NWL%var ret%NWL%fs . _curOpen + +%NWL%2
}%NWL%fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%9
fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%8
return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%7
}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . lchownSync = chownFixSync ( fs . lchownSync )%NWL%6
if ( !er || ( !process . getuid || process . getuid ( ) !== 0 )%NWL%&& ( er . code === " EINVAL " || er . code === " EPERM " ) ) return true%NWL%}%NWL%if ( !fs . lchmod )  {%NWL%fs . lchmod = function ( path , mode , cb )  {%NWL%process . nextTick ( cb )%NWL%}%NWL%fs . lchmodSync = function ( )  { }%NWL%}%NWL%if ( !fs . lchown )  {%NWL%process . nextTick ( cb )%NWL%5
t . notEqual ( fs , require ( ' fs ' ) )%NWL%t . end ( )%NWL%} )%NWL%test ( ' open an existing file works ' , function ( t )  {%NWL%var start = fs . _curOpen%NWL%var fd = fs . openSync ( __filename ,  ' r ' )%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . closeSync ( fd )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( __filename ,  ' r ' , function ( er , fd )  {%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%6
test ( ' open an existing file works ' , function ( t )  {%NWL%var start = fs . _curOpen%NWL%var fd = fs . openSync ( __filename ,  ' r ' )%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . closeSync ( fd )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( __filename ,  ' r ' , function ( er , fd )  {%NWL%if ( er ) throw er%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . close ( fd , function ( er )  {%NWL%t . equal ( fs . _curOpen , start )%NWL%5
var er%NWL%try {%NWL%var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%t . ok ( er ,  ' should throw ' )%NWL%6
try {%NWL%var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%6
var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%6
} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%6
var test = require ( ' tap ' ) . test%NWL%var fs = require ( ' . . / graceful - fs . js ' )%NWL%0
var mkdirp = require ( " mkdirp " )%NWL%var path = require ( " path " )%NWL%var tap = require ( " tap " )%NWL%0
var mkdirp = require ( " mkdirp " )%NWL%var path = require ( " path " )%NWL%var i = 0%NWL%var fs = require ( " fs " )%NWL%0
var mkdirp = require ( " mkdirp " )%NWL%var path = require ( " path " )%NWL%var i = 0%NWL%var tap = require ( " tap " )%NWL%var rimraf = require ( " rimraf " )%NWL%0
bashOutput [ pattern ] = out%NWL%t . notOk ( code ,  " bash test should finish nicely " )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%} )%NWL%tap . test ( " save fixtures " , function ( t )  {%NWL%var fname = path . resolve ( __dirname ,  " bash - results . json " )%NWL%var data = JSON . stringify ( bashOutput , null , 2 )  +  " \n "%NWL%fs . writeFile ( fname , data , function ( er )  {%NWL%t . end ( )%NWL%2
glob ( pattern , function ( er , matches )  {%NWL%if ( er )%NWL%throw er%NWL%matches = cleanResults ( matches )%NWL%t . deepEqual ( matches , expect , pattern )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%tap . test ( pattern +  " sync " , function ( t )  {%NWL%var matches = cleanResults ( glob . sync ( pattern ) )%NWL%t . end ( )%NWL%5
var tap = require ( " tap " )%NWL%var origCwd = process . cwd ( )%NWL%process . chdir ( __dirname )%NWL%tap . test ( " changing cwd and searching for * * / d " , function ( t )  {%NWL%var path = require ( ' path ' )%NWL%0
var glob = require ( ' . . / ' )%NWL%var path = require ( ' path ' )%NWL%t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' b / c / d ' ,  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
t . test ( ' a ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' b / c / d ' ,  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
} )%NWL%t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%4
t . test ( ' a / b ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' . ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
t . test ( ' a / b / ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd:path . resolve ( ' a / b / ' ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd: process . cwd ( ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd: process . cwd ( ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%t . end ( )%NWL%6
t . test ( ' . ' , function ( t )  {%NWL%glob ( ' * * / d ' ,  { cwd: process . cwd ( ) } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' a / b / c / d ' ,  ' a / c / d '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%process . chdir ( origCwd )%NWL%t . end ( )%NWL%t . end ( )%NWL%4
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%var stat = fs . stat%NWL%0
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%test ( ' mock fs ' , function ( t )  {%NWL%var statSync = fs . statSync%NWL%0
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%test ( ' mock fs ' , function ( t )  {%NWL%var stat = fs . stat%NWL%var readdir = fs . readdir%NWL%0
var fs = require ( ' graceful - fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var glob = require ( ' . . / ' ) ;%NWL%test ( ' mock fs ' , function ( t )  {%NWL%var stat = fs . stat%NWL%var statSync = fs . statSync%NWL%var readdirSync = fs . readdirSync%NWL%0
' / tmp / A ' ,%NWL%' / tmp / a '  ]%NWL%glob ( ' / tmp / a ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%throw er%NWL%t . same ( res . sort ( ) , want )%NWL%if ( - - n === 0 ) t . end ( )%NWL%} )%NWL%glob ( ' / tmp / A ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%t . same ( res . sort ( ) , want )%NWL%5
' / tMp / a ' ,%NWL%' / tmp / A ' ,%NWL%' / tmp / a '  ]%NWL%glob ( ' / tmp / * ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%throw er%NWL%t . same ( res . sort ( ) , want )%NWL%} )%NWL%glob ( ' / tmp / * ' ,  { nocase: true } , function ( er , res )  {%NWL%if ( er )%NWL%t . same ( res . sort ( ) , want )%NWL%6
var tap = require ( " tap " )%NWL%var origCwd = process . cwd ( )%NWL%process . chdir ( __dirname )%NWL%tap . test ( " changing root and searching for / b * * * ' ,  { globDebug: true , root: ' . ' , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [ ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%t . ifError ( er )%NWL%4
process . chdir ( __dirname )%NWL%tap . test ( " changing root and searching for / b * * * ' ,  { globDebug: true , root: ' . ' , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [ ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' / b * * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' ) , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . end ( )%NWL%4
} )%NWL%} )%NWL%t . test ( ' a ' , function ( t )  {%NWL%glob ( ' / b * * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' ) , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%t . end ( )%NWL%6
t . test ( ' a ' , function ( t )  {%NWL%glob ( ' / b * * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' ) , nomount: true } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%process . chdir ( origCwd )%NWL%t . end ( )%NWL%t . end ( )%NWL%4
} )%NWL%t . like ( matches , wanted )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' root=a , cwd=a / b ' , function ( t )  {%NWL%glob ( ' / b * / * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' )  } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] . map ( function ( m )  {%NWL%return path . join ( path . resolve ( ' a ' ) , m ) . replace ( / \\ / g ,  ' / ' )%NWL%t . end ( )%NWL%2
t . test ( ' root=a , cwd=a / b ' , function ( t )  {%NWL%glob ( ' / b * / * * ' ,  { globDebug: true , root: ' a ' , cwd: path . resolve ( ' a / b ' )  } , function ( er , matches )  {%NWL%t . ifError ( er )%NWL%t . like ( matches ,  [  ' / b ' ,  ' / b / c ' ,  ' / b / c / d ' ,  ' / bc ' ,  ' / bc / e ' ,  ' / bc / e / f '  ] . map ( function ( m )  {%NWL%return path . join ( path . resolve ( ' a ' ) , m ) . replace ( / \\ / g ,  ' / ' )%NWL%} ) )%NWL%t . end ( )%NWL%} )%NWL%} )%NWL%t . test ( ' cd - ' , function ( t )  {%NWL%t . end ( )%NWL%6
gntp = new GNTP ( ' REGISTER ' ) ;%NWL%gntp . add ( ' Application - Name ' , appname ) ;%NWL%gntp . add ( ' Application - Icon ' , appicon ) ;%NWL%gntp . add ( ' Notifications - Count ' , notifications . length ) ;%NWL%gntp . newline ( ) ;%NWL%notifications . forEach ( function ( notif )  {%NWL%if ( notif . enabled === undefined ) notif . enabled = true;%NWL%gntp . add ( ' Notification - Name ' , notif . label ) ;%NWL%gntp . add ( ' Notification - Display - Name ' , notif . dispname ) ;%NWL%gntp . add ( ' Notification - Enabled ' , notif . enabled ? ' True ' : ' False ' ) ;%NWL%gntp . newline ( ) ;%NWL%4
}%NWL%} ) . listen ( 8003 ) ;%NWL%http . createServer ( function ( req , res )  {%NWL%res . writeHead ( 200 ,  {  ' Content - Type ' : ' text / plain '  } ) ;%NWL%res . write ( ' request successfully proxied to: '  + req . url +  ' \n '  + JSON . stringify ( req . headers , true , 2 ) ) ;%NWL%res . end ( ) ;%NWL%} ) . listen ( 9000 ) ;%NWL%http . createServer ( function ( req , res )  {%NWL%util . puts ( ' Receiving forward for: '  + req . url ) ;%NWL%res . writeHead ( 200 ,  {  ' Content - Type ' : ' text / plain '  } ) ;%NWL%res . end ( ) ;%NWL%5
var util = require ( ' util ' ) ,%NWL%colors = require ( ' colors ' ) ,%NWL%http = require ( ' http ' ) ,%NWL%httpProxy = require ( ' . . / . . / lib / node - http - proxy ' ) ;%NWL%var buffer = httpProxy . buffer ( req ) ;%NWL%0
var util = require ( ' util ' ) ,%NWL%colors = require ( ' colors ' ) ,%NWL%http = require ( ' http ' ) ,%NWL%httpProxy = require ( ' . . / . . / lib / node - http - proxy ' ) ;%NWL%var proxy = new httpProxy . RoutingProxy ( ) ;%NWL%var buffer = httpProxy . buffer ( req ) ;%NWL%0
http . createServer ( new Store ( ) . handler ( ) ) . listen ( 7531 , function ( )  {%NWL%http . createServer ( new Store ( ) . handler ( ) ) . listen ( 2600 , function ( )  {%NWL%var bodyParser = require ( ' connect / lib / middleware / bodyParser ' )%NWL%require ( ' . . / . . / lib / node - http - proxy ' ) . createServer (%NWL%bodyParser ( ) ,%NWL%require ( ' connect - restreamer ' ) ( ) ,%NWL%function ( req , res , proxy )  {%NWL%var port = ( req . body && req . body . type === ' insult ' ? 2600 : 7531 )%NWL%proxy . proxyRequest ( req , res ,  { host: ' localhost ' , port: port } )%NWL%}%NWL%var request = require ( ' request ' )%NWL%2
var util = require ( ' util ' ) ,%NWL%http = require ( ' http ' ) ,%NWL%colors = require ( ' colors ' ) ,%NWL%httpProxy = require ( ' . . / . . / lib / node - http - proxy ' ) ;%NWL%var io = require ( ' socket . io ' ) ,%NWL%0
var util = require ( ' util ' ) ,%NWL%http = require ( ' http ' ) ,%NWL%colors = require ( ' colors ' ) ,%NWL%httpProxy = require ( ' . . / . . / lib / node - http - proxy ' ) ;%NWL%var io = require ( ' socket . io ' ) ,%NWL%0
var util = require ( ' util ' ) ,%NWL%http = require ( ' http ' ) ,%NWL%colors = require ( ' colors ' ) ,%NWL%httpProxy = require ( ' . . / . . / lib / node - http - proxy ' ) ;%NWL%var io = require ( ' socket . io ' ) ,%NWL%0
var util = require ( ' util ' ) ,%NWL%http = require ( ' http ' ) ,%NWL%https = require ( ' https ' ) ,%NWL%events = require ( ' events ' ) ,%NWL%maxSockets = 100;%NWL%var HttpProxy  = exports . HttpProxy  = require ( ' . / node - http - proxy / http - proxy ' ) . HttpProxy ,%NWL%0
message = ' Cannot proxy without '  + missing . join ( ' ,  ' ) ;%NWL%return false;%NWL%}%NWL%return true;%NWL%}%NWL%if ( !validArguments ( ) )  {%NWL%throw new Error ( message ) ;%NWL%return;%NWL%}%NWL%options . target   = options . target   || { } ;%NWL%options . target . host = options . target . host || host;%NWL%9
options . target . host = options . target . host || host;%NWL%if ( options . target && options . target . host && options . target . port )  {%NWL%proxy = new HttpProxy ( options ) ;%NWL%handlers . push ( function ( req , res )  {%NWL%proxy . proxyRequest ( req , res ) ;%NWL%} ) ;%NWL%}%NWL%else {%NWL%proxy = new RoutingProxy ( options ) ;%NWL%if ( options . router )  {%NWL%proxy . proxyRequest ( req , res ) ;%NWL%4
obj . removeListener ( ' data ' , onData ) ;%NWL%obj . removeListener ( ' end ' , onEnd ) ;%NWL%} ,%NWL%destroy: function ( )  {%NWL%this . end ( ) ;%NWL%this . resume = function ( )  {%NWL%console . error ( " Cannot resume buffer after destroying it . " ) ;%NWL%} ;%NWL%onData = onEnd = events = obj = null;%NWL%} ,%NWL%this . end ( ) ;%NWL%4
self [ key ] . base   = httpProxy . _getBase ( self [ key ] ) ;%NWL%}%NWL%setupProxy ( ' target ' ) ;%NWL%if ( this . forward )  {%NWL%setupProxy ( ' forward ' ) ;%NWL%}%NWL%this . enable     = options . enable || { } ;%NWL%this . enable . xforward = typeof this . enable . xforward === ' boolean '%NWL%? this . enable . xforward%NWL%: true;%NWL%this . source . https = this . source . https  || options . https;%NWL%6
}%NWL%setupProxy ( ' target ' ) ;%NWL%if ( this . forward )  {%NWL%setupProxy ( ' forward ' ) ;%NWL%}%NWL%this . enable     = options . enable || { } ;%NWL%this . enable . xforward = typeof this . enable . xforward === ' boolean '%NWL%? this . enable . xforward%NWL%: true;%NWL%this . source    = options . source    || { host: ' localhost ' , port: 80 } ;%NWL%this . changeOrigin = options . changeOrigin || false;%NWL%5
reverseProxy ,%NWL%location;%NWL%if ( req . method === ' DELETE ' )  {%NWL%req . headers [ ' content - length ' ] = req . headers [ ' content - length ' ] || ' 0 ' ;%NWL%}%NWL%if ( this . enable . xforward && req . connection && req . socket )  {%NWL%if ( req . headers [ ' x - forwarded - for ' ] )  {%NWL%var addressToAppend = " , "  + req . connection . remoteAddress || req . socket . remoteAddress;%NWL%req . headers [ ' x - forwarded - for ' ]  + = addressToAppend;%NWL%}%NWL%req . headers [ ' x - forwarded - for ' ] = req . connection . remoteAddress || req . socket . remoteAddress;%NWL%3
outgoing . method   = req . method;%NWL%outgoing . path    = req . url;%NWL%outgoing . headers  = req . headers;%NWL%if ( this . changeOrigin )  {%NWL%outgoing . headers . host = this . target . host +  ' : '  + this . target . port;%NWL%}%NWL%reverseProxy = this . target . protocol . request ( outgoing , function ( response )  {%NWL%if ( req . httpVersion === ' 1 . 0 ' )  {%NWL%if ( req . headers . connection )  {%NWL%response . headers . connection = req . headers . connection%NWL%response . headers . connection = ' close '%NWL%9
}%NWL%reverseProxy = this . target . protocol . request ( outgoing , function ( response )  {%NWL%if ( req . httpVersion === ' 1 . 0 ' )  {%NWL%if ( req . headers . connection )  {%NWL%response . headers . connection = req . headers . connection%NWL%} else {%NWL%response . headers . connection = ' close '%NWL%}%NWL%} else if ( !response . headers . connection )  {%NWL%if ( req . headers . connection )  { response . headers . connection = req . headers . connection }%NWL%response . headers . connection = ' keep - alive '%NWL%4
&& !req . headers [ ' content - length ' ] ) )  {%NWL%delete response . headers [ ' transfer - encoding ' ] ;%NWL%}%NWL%if ( ( response . statusCode === 301 || response . statusCode === 302 )%NWL%&& typeof response . headers . location !== ' undefined ' )  {%NWL%location = url . parse ( response . headers . location ) ;%NWL%if ( location . host === req . headers . host )  {%NWL%if ( self . source . https && !self . target . https )  {%NWL%response . headers . location = response . headers . location . replace ( / ^http\: / ,  ' https: ' ) ;%NWL%}%NWL%response . headers . location = response . headers . location . replace ( / ^https\: / ,  ' http: ' ) ;%NWL%8
function ondata ( chunk )  {%NWL%if ( res . writable )  {%NWL%if ( false === res . write ( chunk ) && response . pause%NWL%&& response . connection . readable )  {%NWL%response . pause ( ) ;%NWL%}%NWL%}%NWL%}%NWL%response . on ( ' data ' , ondata ) ;%NWL%function ondrain ( )  {%NWL%response . resume ( ) ;%NWL%4
} , 100 ) ;%NWL%}%NWL%}%NWL%} ) ;%NWL%req . on ( ' end ' , function ( )  {%NWL%if ( !errState )  {%NWL%reverseProxy . end ( ) ;%NWL%}%NWL%} ) ;%NWL%req . on ( ' close ' , function ( )  {%NWL%reverseProxy . abort ( ) ;%NWL%6
if ( !reverseProxy )  {%NWL%proxySocket . end ( ) ;%NWL%socket . end ( ) ;%NWL%return;%NWL%}%NWL%proxySocket . on ( ' data ' , listeners . onIncoming = function ( data )  {%NWL%if ( reverseProxy . incoming . socket . writable )  {%NWL%try {%NWL%self . emit ( ' websocket:outgoing ' , req , socket , head , data ) ;%NWL%var flushed = reverseProxy . incoming . socket . write ( data ) ;%NWL%proxySocket . pause ( ) ;%NWL%1
catch ( er )  { console . error ( " reverseProxy . socket . resume error: %s " , er . message )  }%NWL%} ) ;%NWL%setTimeout ( function ( )  {%NWL%socket . emit ( ' drain ' ) ;%NWL%} , 100 ) ;%NWL%}%NWL%}%NWL%catch ( ex )  {%NWL%revSocket . removeListener ( ' data ' , handshake ) ;%NWL%return proxyError ( ex ) ;%NWL%revSocket . removeListener ( ' data ' , handshake ) ;%NWL%8
}%NWL%}%NWL%} ) ;%NWL%} ;%NWL%HttpProxy . prototype . _forwardRequest = function ( req )  {%NWL%var self = this ,%NWL%outgoing = new ( this . forward . base ) ,%NWL%forwardProxy;%NWL%outgoing . host  = this . forward . host;%NWL%outgoing . port  = this . forward . port ,%NWL%outgoing . method = req . method;%NWL%9
}%NWL%} ) ;%NWL%} ;%NWL%HttpProxy . prototype . _forwardRequest = function ( req )  {%NWL%var self = this ,%NWL%outgoing = new ( this . forward . base ) ,%NWL%forwardProxy;%NWL%outgoing . host  = this . forward . host;%NWL%outgoing . port  = this . forward . port ,%NWL%outgoing . agent  = this . forward . agent;%NWL%outgoing . path  = req . url;%NWL%8
} ) ;%NWL%} ;%NWL%HttpProxy . prototype . _forwardRequest = function ( req )  {%NWL%var self = this ,%NWL%outgoing = new ( this . forward . base ) ,%NWL%forwardProxy;%NWL%outgoing . host  = this . forward . host;%NWL%outgoing . port  = this . forward . port ,%NWL%outgoing . agent  = this . forward . agent;%NWL%outgoing . method = req . method;%NWL%outgoing . headers = req . headers;%NWL%7
var util = require ( ' util ' ) ,%NWL%events = require ( ' events ' ) ,%NWL%fs = require ( ' fs ' ) ,%NWL%url = require ( ' url ' ) ;%NWL%var ProxyTable = exports . ProxyTable = function ( options )  {%NWL%events . EventEmitter . call ( this ) ;%NWL%this . silent    = options . silent || options . silent !== true;%NWL%this . pathnameOnly = options . pathnameOnly === true;%NWL%6
var util = require ( ' util ' ) ,%NWL%events = require ( ' events ' ) ,%NWL%fs = require ( ' fs ' ) ,%NWL%url = require ( ' url ' ) ;%NWL%var ProxyTable = exports . ProxyTable = function ( options )  {%NWL%events . EventEmitter . call ( this ) ;%NWL%this . silent    = options . silent || options . silent !== true;%NWL%this . target    = options . target || { } ;%NWL%this . hostnameOnly = options . hostnameOnly === true;%NWL%6
var ProxyTable = exports . ProxyTable = function ( options )  {%NWL%events . EventEmitter . call ( this ) ;%NWL%this . silent    = options . silent || options . silent !== true;%NWL%this . target    = options . target || { } ;%NWL%this . pathnameOnly = options . pathnameOnly === true;%NWL%this . hostnameOnly = options . hostnameOnly === true;%NWL%if ( typeof options . router === ' object ' )  {%NWL%this . setRoutes ( options . router ) ;%NWL%}%NWL%else if ( typeof options . router === ' string ' )  {%NWL%this . routeFile = options . router;%NWL%2
if ( !this . router )  {%NWL%throw new Error ( ' Cannot update ProxyTable routes without router . ' ) ;%NWL%}%NWL%this . router [ route ] = target;%NWL%this . setRoutes ( this . router ) ;%NWL%} ;%NWL%ProxyTable . prototype . removeRoute = function ( route )  {%NWL%if ( !this . router )  {%NWL%throw new Error ( ' Cannot update ProxyTable routes without router . ' ) ;%NWL%}%NWL%this . setRoutes ( this . router ) ;%NWL%4
if ( options . router )  {%NWL%this . proxyTable = new ProxyTable ( options ) ;%NWL%this . proxyTable . on ( ' routes ' , function ( routes )  {%NWL%self . emit ( ' routes ' , routes ) ;%NWL%} ) ;%NWL%}%NWL%this . proxies = { } ;%NWL%this . target = { } ;%NWL%this . target . https = options . target && options . target . https;%NWL%this . target . maxSockets = options . target && options . target . maxSockets;%NWL%this . https  = this . source . https || options . https;%NWL%8
this . proxyTable = new ProxyTable ( options ) ;%NWL%this . proxyTable . on ( ' routes ' , function ( routes )  {%NWL%self . emit ( ' routes ' , routes ) ;%NWL%} ) ;%NWL%}%NWL%this . proxies = { } ;%NWL%this . target = { } ;%NWL%this . target . https = options . target && options . target . https;%NWL%this . target . maxSockets = options . target && options . target . maxSockets;%NWL%this . source = options . source  || { host: ' localhost ' , port: 8000 } ;%NWL%this . enable = options . enable;%NWL%7
this . proxyTable . on ( ' routes ' , function ( routes )  {%NWL%self . emit ( ' routes ' , routes ) ;%NWL%} ) ;%NWL%}%NWL%this . proxies = { } ;%NWL%this . target = { } ;%NWL%this . target . https = options . target && options . target . https;%NWL%this . target . maxSockets = options . target && options . target . maxSockets;%NWL%this . source = options . source  || { host: ' localhost ' , port: 8000 } ;%NWL%this . https  = this . source . https || options . https;%NWL%this . forward = options . forward;%NWL%6
self . emit ( ' routes ' , routes ) ;%NWL%} ) ;%NWL%}%NWL%this . proxies = { } ;%NWL%this . target = { } ;%NWL%this . target . https = options . target && options . target . https;%NWL%this . target . maxSockets = options . target && options . target . maxSockets;%NWL%this . source = options . source  || { host: ' localhost ' , port: 8000 } ;%NWL%this . https  = this . source . https || options . https;%NWL%this . enable = options . enable;%NWL%this . changeOrigin = options . changeOrigin || false;%NWL%5
self . proxies [ key ] . on ( evt , self . emit . bind ( self , evt ) ) ;%NWL%} ) ;%NWL%}%NWL%} ) ;%NWL%} ;%NWL%utile . inherits ( RoutingProxy , events . EventEmitter ) ;%NWL%RoutingProxy . prototype . add = function ( options )  {%NWL%var self = this ,%NWL%key = this . _getKey ( options ) ;%NWL%options . target      = options . target    || { } ;%NWL%options . target . port    = options . target . port || options . port;%NWL%9
} ) ;%NWL%}%NWL%} ) ;%NWL%} ;%NWL%utile . inherits ( RoutingProxy , events . EventEmitter ) ;%NWL%RoutingProxy . prototype . add = function ( options )  {%NWL%var self = this ,%NWL%key = this . _getKey ( options ) ;%NWL%options . target      = options . target    || { } ;%NWL%options . target . host    = options . target . host || options . host;%NWL%options . target . socketPath = options . target . socketPath || options . socketPath;%NWL%8
}%NWL%} ) ;%NWL%} ;%NWL%utile . inherits ( RoutingProxy , events . EventEmitter ) ;%NWL%RoutingProxy . prototype . add = function ( options )  {%NWL%var self = this ,%NWL%key = this . _getKey ( options ) ;%NWL%options . target      = options . target    || { } ;%NWL%options . target . host    = options . target . host || options . host;%NWL%options . target . port    = options . target . port || options . port;%NWL%options . target . https   = this . target && this . target . https ||%NWL%7
} ;%NWL%utile . inherits ( RoutingProxy , events . EventEmitter ) ;%NWL%RoutingProxy . prototype . add = function ( options )  {%NWL%var self = this ,%NWL%key = this . _getKey ( options ) ;%NWL%options . target      = options . target    || { } ;%NWL%options . target . host    = options . target . host || options . host;%NWL%options . target . port    = options . target . port || options . port;%NWL%options . target . socketPath = options . target . socketPath || options . socketPath;%NWL%options . target . https   = this . target && this . target . https ||%NWL%options . target . maxSockets = this . target && this . target . maxSockets;%NWL%5
var test = require ( ' tap ' ) . test;%NWL%var equal = require ( ' . . / ' ) ;%NWL%test ( ' equal ' , function ( t )  {%NWL%t . ok ( equal (%NWL%{ a : [ 2 , 3 ] , b : [ 4 ]  } ,%NWL%{ a : [ 2 , 3 ] , b : [ 4 ]  }%NWL%) ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . notOk ( equal (%NWL%3
t . ok ( equal (%NWL%{ a : [ 2 , 3 ] , b : [ 4 ]  } ,%NWL%{ a : [ 2 , 3 ] , b : [ 4 ]  }%NWL%) ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' not equal ' , function ( t )  {%NWL%t . notOk ( equal (%NWL%{ x : 5 , y : [ 6 ]  } ,%NWL%{ x : 5 , y : 6 }%NWL%t . end ( ) ;%NWL%4
inflect . singular ( / ( cris|ax|test ) es$ / i ,  ' $1is ' ) ;%NWL%inflect . singular ( / ( octop|vir ) i$ / i ,  ' $1us ' ) ;%NWL%inflect . singular ( / ( alias|status ) es$ / i ,  ' $1 ' ) ;%NWL%inflect . singular ( / ^ ( ox ) en / i ,  ' $1 ' ) ;%NWL%inflect . singular ( / ( vert|ind ) ices$ / i ,  ' $1ex ' ) ;%NWL%inflect . singular ( / ( matr ) ices$ / i ,  ' $1ix ' ) ;%NWL%inflect . singular ( / ( quiz ) zes$ / i ,  ' $1 ' ) ;%NWL%inflect . singular ( / ( database ) s$ / i ,  ' $1 ' ) ;%NWL%inflect . irregular ( ' child ' ,  ' children ' ) ;%NWL%inflect . irregular ( ' person ' ,  ' people ' ) ;%NWL%inflect . irregular ( ' child ' ,  ' children ' ) ;%NWL%8
this . plurals = [ ] ;%NWL%this . singulars = [ ] ;%NWL%this . uncountables = [ ] ;%NWL%this . humans = [ ] ;%NWL%require ( ' . / defaults ' ) ( this ) ;%NWL%return this;%NWL%} ;%NWL%Inflections . prototype . plural = function ( rule , replacement )  {%NWL%if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%9
return this;%NWL%} ;%NWL%Inflections . prototype . plural = function ( rule , replacement )  {%NWL%if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%}%NWL%this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%this . plurals . unshift ( [ rule , replacement ] ) ;%NWL%} ;%NWL%Inflections . prototype . singular = function ( rule , replacement )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%4
Inflections . prototype . plural = function ( rule , replacement )  {%NWL%if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%}%NWL%this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%this . plurals . unshift ( [ rule , replacement ] ) ;%NWL%} ;%NWL%Inflections . prototype . singular = function ( rule , replacement )  {%NWL%if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%2
if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%}%NWL%this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%this . plurals . unshift ( [ rule , replacement ] ) ;%NWL%} ;%NWL%Inflections . prototype . singular = function ( rule , replacement )  {%NWL%if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%}%NWL%this . singulars . unshift ( [ rule , replacement ] ) ;%NWL%4
this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%this . plurals . unshift ( [ rule , replacement ] ) ;%NWL%} ;%NWL%Inflections . prototype . singular = function ( rule , replacement )  {%NWL%if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%}%NWL%this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%this . singulars . unshift ( [ rule , replacement ] ) ;%NWL%} ;%NWL%this . uncountables = util . array . del ( this . uncountables , singular ) ;%NWL%0
this . plurals . unshift ( [ rule , replacement ] ) ;%NWL%} ;%NWL%Inflections . prototype . singular = function ( rule , replacement )  {%NWL%if ( typeof rule == ' string ' )  {%NWL%this . uncountables = util . array . del ( this . uncountables , rule ) ;%NWL%}%NWL%this . uncountables = util . array . del ( this . uncountables , replacement ) ;%NWL%this . singulars . unshift ( [ rule , replacement ] ) ;%NWL%} ;%NWL%Inflections . prototype . irregular = function ( singular , plural )  {%NWL%this . uncountables = util . array . del ( this . uncountables , plural ) ;%NWL%4
options = options || { } ;%NWL%this . options = options;%NWL%if ( !this . valueAttr )  {%NWL%this . valueAttr = options . valueAttr;%NWL%}%NWL%this . dataSource = new DataSource ( options . dataSource ,  {%NWL%flattenEverything: options . flattenEverything%NWL%} ) ;%NWL%this . dataSource . on ( ' change ' , function ( )  {%NWL%this . fetch ( { reset: true } ) ;%NWL%this . requestId = options . request_id || ' Not - Set ' ;%NWL%5
this . options = options;%NWL%if ( !this . valueAttr )  {%NWL%this . valueAttr = options . valueAttr;%NWL%}%NWL%this . dataSource = new DataSource ( options . dataSource ,  {%NWL%flattenEverything: options . flattenEverything%NWL%} ) ;%NWL%this . dataSource . on ( ' change ' , function ( )  {%NWL%this . fetch ( { reset: true } ) ;%NWL%} , this ) ;%NWL%this . govukRequestId = options . govuk_request_id || ' Not - Set ' ;%NWL%4
data = this . flatten ( data ) ;%NWL%if ( data . length )  {%NWL%_ . each ( _ . keys ( data [ 0 ] ) , function ( key )  {%NWL%if ( this . dateKey ( key ) )  {%NWL%_ . each ( data , function ( d )  {%NWL%d [ key ] = this . getMoment ( d [ key ] ) ;%NWL%} , this ) ;%NWL%}%NWL%} , this ) ;%NWL%_ . each ( data , function ( d )  {%NWL%d . _start_at = d [ ' _ '  + this . options . axisPeriod +  ' _start_at ' ] ;%NWL%5
if ( this . dateKey ( key ) )  {%NWL%_ . each ( data , function ( d )  {%NWL%d [ key ] = this . getMoment ( d [ key ] ) ;%NWL%} , this ) ;%NWL%}%NWL%} , this ) ;%NWL%_ . each ( data , function ( d )  {%NWL%if ( !d . _start_at && this . options . axisPeriod )  {%NWL%d . _start_at = d [ ' _ '  + this . options . axisPeriod +  ' _start_at ' ] ;%NWL%}%NWL%d . _end_at = d . end_at;%NWL%2
} , this ) ;%NWL%}%NWL%} , this ) ;%NWL%_ . each ( data , function ( d )  {%NWL%if ( !d . _start_at && this . options . axisPeriod )  {%NWL%d . _start_at = d [ ' _ '  + this . options . axisPeriod +  ' _start_at ' ] ;%NWL%}%NWL%if ( !d . _end_at && d . end_at )  {%NWL%d . _end_at = d . end_at;%NWL%}%NWL%d . _timestamp = d . _start_at;%NWL%5
{%NWL%' values ' : [ ] ,%NWL%' _count ' : 0 ,%NWL%' _group_count ' : 0%NWL%} ;%NWL%current [ value ] = dataset [ value ] ;%NWL%for ( var i=0; i < collect . length; i + + )  {%NWL%current [ collect [ i ] ] = 0;%NWL%}%NWL%grouped . data . push ( current ) ;%NWL%current . _count + = dataset . _count;%NWL%5
' single ' : function ( topic )  {%NWL%topic . uncountables = [ 1 , 2 , 3 ] ;%NWL%topic . humans = [ 1 , 2 , 3 ] ;%NWL%topic . clear ( ' uncountables ' ) ;%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%return assert . deepEqual ( topic . humans ,  [ 1 , 2 , 3 ] ) ;%NWL%} ,%NWL%' all ' : function ( topic )  {%NWL%assert . deepEqual ( topic . humans ,  [ 1 , 2 , 3 ] ) ;%NWL%topic . uncountables = [ 1 , 2 , 3 ] ;%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%4
} ,%NWL%' all ' : function ( topic )  {%NWL%assert . deepEqual ( topic . humans ,  [ 1 , 2 , 3 ] ) ;%NWL%topic . uncountables = [ 1 , 2 , 3 ] ;%NWL%topic . clear ( ) ;%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%return assert . isEmpty ( topic . humans ) ;%NWL%}%NWL%} ,%NWL%' uncountable ' : {%NWL%topic . clear ( ) ;%NWL%4
' all ' : function ( topic )  {%NWL%assert . deepEqual ( topic . humans ,  [ 1 , 2 , 3 ] ) ;%NWL%topic . uncountables = [ 1 , 2 , 3 ] ;%NWL%topic . clear ( ) ;%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%return assert . isEmpty ( topic . humans ) ;%NWL%}%NWL%} ,%NWL%' uncountable ' : {%NWL%' one item ' : function ( topic )  {%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%4
return assert . isEmpty ( topic . humans ) ;%NWL%}%NWL%} ,%NWL%' uncountable ' : {%NWL%' one item ' : function ( topic )  {%NWL%topic . clear ( ) ;%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%topic . uncountable ( ' money ' ) ;%NWL%return assert . deepEqual ( topic . uncountables ,  [ ' money ' ] ) ;%NWL%} ,%NWL%topic . clear ( ) ;%NWL%5
}%NWL%} ,%NWL%' uncountable ' : {%NWL%' one item ' : function ( topic )  {%NWL%topic . clear ( ) ;%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%topic . uncountable ( ' money ' ) ;%NWL%return assert . deepEqual ( topic . uncountables ,  [ ' money ' ] ) ;%NWL%} ,%NWL%' many items ' : function ( topic )  {%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%5
topic . uncountable ( ' money ' ) ;%NWL%return assert . deepEqual ( topic . uncountables ,  [ ' money ' ] ) ;%NWL%} ,%NWL%' many items ' : function ( topic )  {%NWL%topic . clear ( ) ;%NWL%assert . isEmpty ( topic . uncountables ) ;%NWL%topic . uncountable ( [ ' money ' ,  ' rice ' ] ) ;%NWL%return assert . deepEqual ( topic . uncountables ,  [ ' money ' ,  ' rice ' ] ) ;%NWL%}%NWL%} ,%NWL%topic . clear ( ) ;%NWL%4
topic . uncountable ( [ ' money ' ,  ' rice ' ] ) ;%NWL%return assert . deepEqual ( topic . uncountables ,  [ ' money ' ,  ' rice ' ] ) ;%NWL%}%NWL%} ,%NWL%' human ' : function ( topic )  {%NWL%topic . clear ( ) ;%NWL%assert . isEmpty ( topic . humans ) ;%NWL%topic . human ( " legacy_col_person_name " ,  " Name " ) ;%NWL%return assert . deepEqual ( topic . humans ,  [ [ " legacy_col_person_name " ,  " Name " ] ] ) ;%NWL%} ,%NWL%topic . clear ( ) ;%NWL%5
_results . push ( assert . equal ( topic . underscore ( i ) , words [ i ] ) ) ;%NWL%}%NWL%return _results;%NWL%} ,%NWL%' path ' : function ( topic )  {%NWL%var i , words , _i , _len , _ref , _results;%NWL%words = cases . CamelWithModuleToUnderscoreWithSlash;%NWL%_ref = Object . keys ( words ) ;%NWL%_results = [ ] ;%NWL%for ( _i = 0 , _len = _ref . length; _i < _len; _i + + )  {%NWL%_results . push ( assert . equal ( topic . underscore ( i ) , words [ i ] ) ) ;%NWL%0
t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' chmod ' , function ( t )  {%NWL%var mode = 0755%NWL%mkdirp ( file , mode , function ( er )  {%NWL%t . ifError ( er ,  ' should not error ' ) ;%NWL%fs . stat ( file , function ( er , stat )  {%NWL%t . ifError ( er ,  ' should exist ' ) ;%NWL%t . end ( ) ;%NWL%0
t . equal ( stat . mode & 0777 , 0755 ) ;%NWL%t . ok ( stat . isDirectory ( ) ,  ' target not a directory ' ) ;%NWL%t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%t . end ( ) ;%NWL%2
t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%if ( err ) t . fail ( err ) ;%NWL%t . end ( ) ;%NWL%t . end ( ) ;%NWL%0
var mkdirp = require ( ' . . / ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%test ( ' rel ' , function ( t )  {%NWL%t . plan ( 2 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var cwd = process . cwd ( ) ;%NWL%1
var test = require ( ' tap ' ) . test;%NWL%test ( ' return value ' , function ( t )  {%NWL%t . plan ( 4 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var file = ' / tmp / '  +  [ x , y , z ] . join ( ' / ' ) ;%NWL%mkdirp ( file , function ( err , made )  {%NWL%t . ifError ( err ) ;%NWL%t . equal ( made ,  ' / tmp / '  + x ) ;%NWL%t . ifError ( err ) ;%NWL%8
var assert = require ( ' assert ' ) ,%NWL%path = require ( ' path ' ) ,%NWL%rimraf = require ( ' rimraf ' ) ,%NWL%vows = require ( ' vows ' ) ,%NWL%readDirFiles = require ( ' read - dir - files ' ) ,%NWL%var fixtures = path . join ( __dirname ,  ' fixtures ' ) ,%NWL%0
module . exports = rimraf%NWL%rimraf . sync = rimrafSync%NWL%var path = require ( " path " )%NWL%, fs%NWL%try {%NWL%fs = require ( " graceful - fs " )%NWL%} catch ( er )  {%NWL%fs = require ( " fs " )%NWL%var lstat = process . platform === " win32 " ? " stat " : " lstat "%NWL%2
assert . isArray ( result ) ;%NWL%assert . lengthOf ( result , 0 ) ;%NWL%}%NWL%} ,%NWL%' with simple arguments ' : {%NWL%topic: function ( )  {%NWL%return ( function ( )  {%NWL%return utile . rargs ( arguments ) ;%NWL%} ) ( ' a ' ,  ' b ' ,  ' c ' ) ;%NWL%} ,%NWL%assert . isArray ( result ) ;%NWL%0
assert . isObject ( obj ) ;%NWL%utile . deepEqual ( obj ,  {%NWL%hello: ' World ' ,%NWL%' I am ' : [ ' the utile module ' ] ,%NWL%thisMakesMe: {%NWL%really: 1337 ,%NWL%' right? ' : true%NWL%}%NWL%} ) ;%NWL%} ;%NWL%assert . isObject ( obj ) ;%NWL%0
var vows = require ( ' vows ' )%NWL%macros = require ( ' . / macros ' ) ,%NWL%examples = macros . examples;%NWL%process . on ( ' uncaughtException ' , function ( err )  {%NWL%if ( err . code !== ' EADDRINUSE ' )  {%NWL%throw err;%NWL%}%NWL%} ) ;%NWL%vows . describe ( ' node - http - proxy / examples ' ) . addBatch (%NWL%examples . shouldHaveDeps ( )%NWL%examples . shouldHaveNoErrors ( )%NWL%9
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var url = require ( ' url ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%var nresponses = 0;%NWL%var server = http . createServer ( function ( req , res )  {%NWL%if ( req . url == ' / one ' )  {%NWL%res . writeHead ( 200 ,  [ [ ' set - cookie ' ,  ' A ' ] ,%NWL%[ ' content - type ' ,  ' text / plain ' ] ] ) ;%NWL%res . end ( ' one\n ' ) ;%NWL%res . writeHead ( 200 ,  [ [ ' set - cookie ' ,  ' A ' ] ,%NWL%6
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var net = require ( ' net ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var http = require ( ' http ' ) ;%NWL%0
var common = require ( ' . . / common ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var url = require ( ' url ' ) ;%NWL%0
var ports     = options . ports  || helpers . nextPortPair ,%NWL%output    = options . output || ' hello world from '  + ports . target ,%NWL%outputHeaders = options . outputHeaders ,%NWL%targetHeaders = options . targetHeaders ,%NWL%proxyHeaders = options . proxyHeaders ,%NWL%protocol   = helpers . protocols . proxy ,%NWL%req      = options . request || { } ,%NWL%timeout    = options . timeout || null ,%NWL%assertFn   = options . shouldFail%NWL%? exports . assertFailedRequest%NWL%req . uri = req . uri || protocol +  ' : / / 127 . 0 . 0 . 1: '  + ports . proxy;%NWL%6
async . waterfall ( [%NWL%async . apply (%NWL%async . forEach ,%NWL%locations ,%NWL%function createRouteTarget ( location , next )  {%NWL%helpers . http . createServer ( {%NWL%port: location . target . port ,%NWL%output: ' hello from '  + location . source . href%NWL%} , next ) ;%NWL%}%NWL%async . apply (%NWL%1
exports . examples = require ( ' . / examples ' ) ;%NWL%exports . ws    = require ( ' . / ws ' ) ;%NWL%0
} else if ( node . type === ' BlockStatement ' )  {%NWL%return node;%NWL%} else {%NWL%return { type: ' BlockStatement ' , body: [ node ]  } ;%NWL%}%NWL%} ,%NWL%ifBlockConverter: function ( node )  {%NWL%node . consequent = this . convertToBlock ( node . consequent ) ;%NWL%node . alternate = this . convertToBlock ( node . alternate ) ;%NWL%} ,%NWL%node . body = this . convertToBlock ( node . body ) ;%NWL%7
} ,%NWL%coverFunction: function ( node , walker )  {%NWL%var id = this . functionName ( node , walker . startLineForNode ( node ) ,  {%NWL%start: node . loc . start ,%NWL%end: { line: node . body . loc . start . line , column: node . body . loc . start . column }%NWL%} ) ,%NWL%body = node . body ,%NWL%blockBody = body . body;%NWL%blockBody . unshift (%NWL%astgen . statement (%NWL%astgen . subscript (%NWL%9
( function ( isNode )  {%NWL%%NWL%function addDerivedInfoForFile ( fileCoverage )  {%NWL%var statementMap = fileCoverage . statementMap ,%NWL%statements = fileCoverage . s ,%NWL%lineMap;%NWL%if ( !fileCoverage . l )  {%NWL%fileCoverage . l = lineMap = { } ;%NWL%var line = statementMap [ st ] . start . line ,%NWL%3
return ret;%NWL%}%NWL%function computeBranchTotals ( fileCoverage )  {%NWL%var stats = fileCoverage . b ,%NWL%ret = { total: 0 , covered: 0 } ;%NWL%Object . keys ( stats ) . forEach ( function ( key )  {%NWL%var branches = stats [ key ] ,%NWL%covered = branches . filter ( function ( num )  { return num > 0; } ) ;%NWL%ret . total + = branches . length;%NWL%ret . covered + = covered . length;%NWL%ret . pct = percent ( ret . covered , ret . total ) ;%NWL%9
return ret;%NWL%}%NWL%%NWL%function mergeFileCoverage ( first , second )  {%NWL%var ret = JSON . parse ( JSON . stringify ( first ) ) ,%NWL%i;%NWL%delete ret . l; / / remove derived info%NWL%Object . keys ( second . s ) . forEach ( function ( k )  {%NWL%ret . s [ k ]  + = second . s [ k ] ;%NWL%} ) ;%NWL%ret . f [ k ]  + = second . f [ k ] ;%NWL%8
usage: function ( )  {%NWL%console . error ( ' \nUsage: '  + this . toolName ( )  +  '  '  + this . type ( )  +  ' <options> [ <include - pattern> ] \n\nOptions are:\n\n '  +%NWL%[%NWL%formatOption ( ' - - statements <threshold> ' ,  ' The minimum statement coverage required as a percentage ' ) ,%NWL%formatOption ( ' - - functions <threshold> ' ,  ' The minimum statement threshold coverage required as a percentage ' ) ,%NWL%formatOption ( ' - - branches <threshold> ' ,  ' The minimum branch coverage required as a percentage ' ) ,%NWL%formatOption ( ' - - lines <threshold> ' ,  ' The minimum line coverage required as a percentage ' )%NWL%] . join ( ' \n\n ' )  +  ' \n ' ) ;%NWL%console . error ( ' \n ' ) ;%NWL%console . error ( ' <include - pattern> is a fileset pattern that can be used to select one or more coverage files '  +%NWL%console . error ( ' \n ' ) ;%NWL%8
usage: function ( )  {%NWL%console . error ( ' \nUsage: '  + this . toolName ( )  +  '  '  + this . type ( )  +  ' <command>\n ' ) ;%NWL%console . error ( ' Available commands are:\n ' ) ;%NWL%var commandObj;%NWL%Command . getCommandList ( ) . forEach ( function ( cmd )  {%NWL%commandObj = Command . create ( cmd ) ;%NWL%console . error ( formatOption ( cmd , commandObj . synopsis ( ) ) ) ;%NWL%console . error ( " \n " ) ;%NWL%} ) ;%NWL%console . error ( " Command names can be abbreviated as long as the abbreviation is unambiguous " ) ;%NWL%console . error ( " \n " ) ;%NWL%7
} ,%NWL%run: function ( args , callback )  {%NWL%var command;%NWL%if ( args . length === 0 )  {%NWL%this . usage ( ) ;%NWL%} else {%NWL%try {%NWL%command = Command . create ( args [ 0 ] ) ;%NWL%command . usage ( ' istanbul ' , Command . resolveCommandName ( args [ 0 ] ) ) ;%NWL%} catch ( ex )  {%NWL%this . usage ( ) ;%NWL%4
usage: function ( )  {%NWL%console . error ( ' \nUsage: '  + this . toolName ( )  +  '  '  + this . type ( )  +  ' <options> [ <format> [ <include - pattern> ]  ] \n\nOptions are:\n\n '  +%NWL%[%NWL%formatOption ( ' - - root <input - directory> ' ,  ' The input root directory for finding coverage files ' ) ,%NWL%formatOption ( ' - - dir <report - directory> ' ,  ' The output directory where files will be written . This defaults to . / coverage / ' ) ,%NWL%formatOption ( ' - - verbose ,  - v ' ,  ' verbose mode ' )%NWL%] . join ( ' \n\n ' )  +  ' \n ' ) ;%NWL%console . error ( ' \n ' ) ;%NWL%console . error ( ' <format> is one of html , lcovonly or lcov ( html + lcovonly ) . Default is lcov ' ) ;%NWL%console . error ( ' <include - pattern> is a fileset pattern that can be used to select one or more coverage files '  +%NWL%console . error ( ' \n ' ) ;%NWL%7
return;%NWL%} else {%NWL%cov = global [ coverageVar ] ;%NWL%}%NWL%mkdirp . sync ( reportingDir ) ; / / yes , do this again since some test runners could clean the dir initially created%NWL%console . log ( ' ============================================================================= ' ) ;%NWL%console . log ( ' Writing coverage object [ '  + file +  ' ] ' ) ;%NWL%fs . writeFileSync ( file , JSON . stringify ( cov ) ,  ' utf8 ' ) ;%NWL%collector = new Collector ( ) ;%NWL%collector . add ( cov ) ;%NWL%console . log ( ' ============================================================================= ' ) ;%NWL%5
function quote ( thing )  {%NWL%return ' " '  + thing +  ' " ' ;%NWL%}%NWL%function attr ( n , v )  {%NWL%return '  '  + n +  ' = '  + quote ( v )  +  '  ' ;%NWL%}%NWL%function branchCoverageByLine ( fileCoverage )  {%NWL%var branchMap = fileCoverage . branchMap ,%NWL%branches = fileCoverage . b ,%NWL%ret = { } ;%NWL%var line = branchMap [ k ] . line ,%NWL%7
identity = 1;%NWL%if ( coveragePct * identity === coveragePct )  {%NWL%return coveragePct >= 80 ? ' high ' : coveragePct >= 50 ? ' medium ' : ' low ' ;%NWL%} else {%NWL%return ' ' ;%NWL%}%NWL%}%NWL%function HtmlReport ( opts )  {%NWL%Report . call ( this ) ;%NWL%this . opts = opts || { } ;%NWL%this . opts . sourceStore = this . opts . sourceStore || Store . create ( ' fslookup ' ) ;%NWL%9
if ( coveragePct * identity === coveragePct )  {%NWL%return coveragePct >= 80 ? ' high ' : coveragePct >= 50 ? ' medium ' : ' low ' ;%NWL%} else {%NWL%return ' ' ;%NWL%}%NWL%}%NWL%function HtmlReport ( opts )  {%NWL%Report . call ( this ) ;%NWL%this . opts = opts || { } ;%NWL%this . opts . dir = this . opts . dir || path . resolve ( process . cwd ( ) ,  ' html - report ' ) ;%NWL%this . opts . linkMapper = this . opts . linkMapper || this . standardLinkMapper ( ) ;%NWL%8
return coveragePct >= 80 ? ' high ' : coveragePct >= 50 ? ' medium ' : ' low ' ;%NWL%} else {%NWL%return ' ' ;%NWL%}%NWL%}%NWL%function HtmlReport ( opts )  {%NWL%Report . call ( this ) ;%NWL%this . opts = opts || { } ;%NWL%this . opts . dir = this . opts . dir || path . resolve ( process . cwd ( ) ,  ' html - report ' ) ;%NWL%this . opts . sourceStore = this . opts . sourceStore || Store . create ( ' fslookup ' ) ;%NWL%this . opts . writer = this . opts . writer || null;%NWL%7
writeIndexPage: function ( writer , node )  {%NWL%var linkMapper = this . opts . linkMapper ,%NWL%templateData = this . opts . templateData ,%NWL%children = Array . prototype . slice . apply ( node . children ) ;%NWL%children . sort ( function ( a , b )  {%NWL%return a . name < b . name ? - 1 : 1;%NWL%} ) ;%NWL%this . fillTemplate ( node , templateData ) ;%NWL%writer . write ( headerTemplate ( templateData ) ) ;%NWL%writer . write ( summaryTableHeader ) ;%NWL%var metrics = child . metrics ,%NWL%1
var path = require ( ' path ' ) ,%NWL%Writer = require ( ' . . / util / file - writer ' ) ,%NWL%util = require ( ' util ' ) ,%NWL%Report = require ( ' . / index ' ) ;%NWL%function LcovOnlyReport ( opts )  {%NWL%this . opts = opts || { } ;%NWL%this . opts . writer = this . opts . writer || null;%NWL%5
TreeSummarizer = require ( ' . . / util / tree - summarizer ' ) ,%NWL%utils = require ( ' . . / object - utils ' ) ,%NWL%PCT_COLS = 10 ,%NWL%TAB_SIZE = 3 ,%NWL%DELIM = ' | ' ,%NWL%COL_DELIM = ' - + ' ;%NWL%function TextReport ( opts )  {%NWL%Report . call ( this ) ;%NWL%opts = opts || { } ;%NWL%this . dir = opts . dir || process . cwd ( ) ;%NWL%this . summary = opts . summary;%NWL%9
utils = require ( ' . . / object - utils ' ) ,%NWL%PCT_COLS = 10 ,%NWL%TAB_SIZE = 3 ,%NWL%DELIM = ' | ' ,%NWL%COL_DELIM = ' - + ' ;%NWL%function TextReport ( opts )  {%NWL%Report . call ( this ) ;%NWL%opts = opts || { } ;%NWL%this . dir = opts . dir || process . cwd ( ) ;%NWL%this . file = opts . file;%NWL%this . maxCols = opts . maxCols || 0;%NWL%8
last = findNameWidth ( child , level + 1 , last ) ;%NWL%} ) ;%NWL%return last;%NWL%}%NWL%function makeLine ( nameWidth )  {%NWL%var name = padding ( nameWidth ,  ' - ' ) ,%NWL%pct = padding ( PCT_COLS ,  ' - ' ) ,%NWL%elements = [ ] ;%NWL%elements . push ( name ) ;%NWL%elements . push ( pct ) ;%NWL%elements . push ( pct ) ;%NWL%9
} ) ;%NWL%return last;%NWL%}%NWL%function makeLine ( nameWidth )  {%NWL%var name = padding ( nameWidth ,  ' - ' ) ,%NWL%pct = padding ( PCT_COLS ,  ' - ' ) ,%NWL%elements = [ ] ;%NWL%elements . push ( name ) ;%NWL%elements . push ( pct ) ;%NWL%elements . push ( pct ) ;%NWL%elements . push ( pct ) ;%NWL%8
elements . push ( pct ) ;%NWL%elements . push ( pct ) ;%NWL%elements . push ( pct ) ;%NWL%return elements . join ( COL_DELIM )  + COL_DELIM;%NWL%}%NWL%function walk ( node , nameWidth , array , level )  {%NWL%var line;%NWL%if ( level === 0 )  {%NWL%line = makeLine ( nameWidth ) ;%NWL%array . push ( line ) ;%NWL%array . push ( line ) ;%NWL%9
line = makeLine ( nameWidth ) ;%NWL%array . push ( line ) ;%NWL%array . push ( tableHeader ( nameWidth ) ) ;%NWL%array . push ( line ) ;%NWL%} else {%NWL%array . push ( tableRow ( node , nameWidth , level ) ) ;%NWL%}%NWL%node . children . forEach ( function ( child )  {%NWL%walk ( child , nameWidth , array , level + 1 ) ;%NWL%} ) ;%NWL%array . push ( line ) ;%NWL%1
array . push ( line ) ;%NWL%array . push ( tableHeader ( nameWidth ) ) ;%NWL%array . push ( line ) ;%NWL%} else {%NWL%array . push ( tableRow ( node , nameWidth , level ) ) ;%NWL%}%NWL%node . children . forEach ( function ( child )  {%NWL%walk ( child , nameWidth , array , level + 1 ) ;%NWL%} ) ;%NWL%if ( level === 0 )  {%NWL%array . push ( tableRow ( node , nameWidth , level ) ) ;%NWL%4
array . push ( tableHeader ( nameWidth ) ) ;%NWL%array . push ( line ) ;%NWL%} else {%NWL%array . push ( tableRow ( node , nameWidth , level ) ) ;%NWL%}%NWL%node . children . forEach ( function ( child )  {%NWL%walk ( child , nameWidth , array , level + 1 ) ;%NWL%} ) ;%NWL%if ( level === 0 )  {%NWL%array . push ( line ) ;%NWL%array . push ( line ) ;%NWL%1
Store = require ( ' . / index ' ) ;%NWL%function makeTempDir ( )  {%NWL%var dir = path . join ( os . tmpDir ? os . tmpDir ( ) : ( process . env . TMPDIR || ' / tmp ' ) ,  ' ts '  + new Date ( ) . getTime ( ) ) ;%NWL%mkdirp . sync ( dir ) ;%NWL%return dir;%NWL%}%NWL%function TmpStore ( opts )  {%NWL%opts = opts || { } ;%NWL%this . tmp = opts . tmp || makeTempDir ( ) ;%NWL%this . map = { } ;%NWL%this . prefix = ' t '  + new Date ( ) . getTime ( )  +  ' - ' ;%NWL%8
throw new Error ( ' Could not register '  + that . kind +  ' from file '  + file ) ;%NWL%}%NWL%}%NWL%} ) ;%NWL%} ,%NWL%bindClassMethods: function ( Cons )  {%NWL%var tmpKind = this . kind . charAt ( 0 ) . toUpperCase ( )  + this . kind . substring ( 1 ) ,  / / ucfirst%NWL%allowAbbrev = this . allowAbbreviations;%NWL%Cons . mix = Factory . mix;%NWL%Cons . register = this . register . bind ( this ) ;%NWL%Cons . loadAll = this . loadStandard . bind ( this , this . dir ) ;%NWL%9
var fileset = require ( ' fileset ' ) ,%NWL%path = require ( ' path ' ) ,%NWL%seq = 0;%NWL%function filesFor ( options , callback )  {%NWL%if ( !callback && typeof options === ' function ' )  {%NWL%callback = options;%NWL%options = null;%NWL%}%NWL%var root = options . root ,%NWL%0
this . doEnd ( ) ;%NWL%fs . writeFileSync ( this . filename , this . contents ,  ' utf8 ' ) ;%NWL%} ,%NWL%startAsync: function ( fileName )  {%NWL%this . doStart ( fileName ) ;%NWL%this . stream = fs . createWriteStream ( fileName ) ;%NWL%} ,%NWL%writeAsync: function ( str )  {%NWL%this . stream . write ( str ) ;%NWL%} ,%NWL%this . doEnd ( ) ;%NWL%0
this . calculateMetrics ( root ) ;%NWL%this . root = root;%NWL%this . map = { } ;%NWL%this . indexAndSortTree ( root , this . map ) ;%NWL%} ,%NWL%fixupNodes: function ( node , prefix , parent )  {%NWL%var that = this;%NWL%if ( node . name . indexOf ( prefix ) === 0 )  {%NWL%node . name = node . name . substring ( prefix . length ) ;%NWL%}%NWL%node . name = node . name . substring ( 1 ) ;%NWL%8
} ,%NWL%fixupNodes: function ( node , prefix , parent )  {%NWL%var that = this;%NWL%if ( node . name . indexOf ( prefix ) === 0 )  {%NWL%node . name = node . name . substring ( prefix . length ) ;%NWL%}%NWL%if ( node . name . charAt ( 0 ) === SEP )  {%NWL%node . name = node . name . substring ( 1 ) ;%NWL%}%NWL%if ( parent )  {%NWL%node . relativeName = node . name . substring ( parent . name . length ) ;%NWL%4
var that = this;%NWL%if ( node . name . indexOf ( prefix ) === 0 )  {%NWL%node . name = node . name . substring ( prefix . length ) ;%NWL%}%NWL%if ( node . name . charAt ( 0 ) === SEP )  {%NWL%node . name = node . name . substring ( 1 ) ;%NWL%}%NWL%if ( parent )  {%NWL%if ( parent . name !== ' __root__ / ' )  {%NWL%node . relativeName = node . name . substring ( parent . name . length ) ;%NWL%node . relativeName = node . name;%NWL%2
}%NWL%if ( node . name . charAt ( 0 ) === SEP )  {%NWL%node . name = node . name . substring ( 1 ) ;%NWL%}%NWL%if ( parent )  {%NWL%if ( parent . name !== ' __root__ / ' )  {%NWL%node . relativeName = node . name . substring ( parent . name . length ) ;%NWL%} else {%NWL%node . relativeName = node . name;%NWL%}%NWL%node . relativeName = node . name . substring ( prefix . length ) ;%NWL%2
console = { log: print } ;%NWL%fs = { readFileSync: readFile } ;%NWL%process = { argv: arguments , exit: quit } ;%NWL%process . argv . unshift ( ' esparse . js ' ) ;%NWL%process . argv . unshift ( ' rhino ' ) ;%NWL%}%NWL%function showUsage ( )  {%NWL%console . log ( ' Usage: ' ) ;%NWL%console . log ( '  esparse [ options ] file . js ' ) ;%NWL%console . log ( ) ;%NWL%console . log ( ) ;%NWL%9
console . log ( '  esparse [ options ] file . js ' ) ;%NWL%console . log ( ) ;%NWL%console . log ( ' Available options: ' ) ;%NWL%console . log ( ) ;%NWL%console . log ( '  - - comment   Gather all line and block comments in an array ' ) ;%NWL%console . log ( '  - - loc     Include line - column location info for each syntax node ' ) ;%NWL%console . log ( '  - - range    Include index - based range for each syntax node ' ) ;%NWL%console . log ( '  - - raw     Display the raw value of literals ' ) ;%NWL%console . log ( '  - - tokens    List all tokens in an array ' ) ;%NWL%console . log ( '  - - tolerant   Tolerate errors on a best - effort basis ( experimental ) ' ) ;%NWL%console . log ( ) ;%NWL%1
} else if ( entry === ' - - raw ' )  {%NWL%options . raw = true;%NWL%} else if ( entry === ' - - tokens ' )  {%NWL%options . tokens = true;%NWL%} else if ( entry === ' - - tolerant ' )  {%NWL%options . tolerant = true;%NWL%} else if ( entry . slice ( 0 , 2 ) === ' - - ' )  {%NWL%console . log ( ' Error: unknown option '  + entry +  ' . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%} else if ( typeof fname === ' string ' )  {%NWL%process . exit ( 1 ) ;%NWL%8
console . log ( ' Error: unknown option '  + entry +  ' . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%} else if ( typeof fname === ' string ' )  {%NWL%console . log ( ' Error: more than one input file . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%} else {%NWL%fname = entry;%NWL%}%NWL%} ) ;%NWL%if ( typeof fname !== ' string ' )  {%NWL%process . exit ( 1 ) ;%NWL%1
} ) ;%NWL%if ( typeof fname !== ' string ' )  {%NWL%console . log ( ' Error: no input file . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%}%NWL%try {%NWL%content = fs . readFileSync ( fname ,  ' utf - 8 ' ) ;%NWL%syntax = esprima . parse ( content , options ) ;%NWL%console . log ( JSON . stringify ( syntax , null , 4 ) ) ;%NWL%} catch ( e )  {%NWL%process . exit ( 1 ) ;%NWL%3
console = { log: print } ;%NWL%fs = { readFileSync: readFile } ;%NWL%process = { argv: arguments , exit: quit } ;%NWL%process . argv . unshift ( ' esvalidate . js ' ) ;%NWL%process . argv . unshift ( ' rhino ' ) ;%NWL%}%NWL%function showUsage ( )  {%NWL%console . log ( ' Usage: ' ) ;%NWL%console . log ( '  esvalidate [ options ] file . js ' ) ;%NWL%console . log ( ) ;%NWL%console . log ( ) ;%NWL%9
process . argv . unshift ( ' esvalidate . js ' ) ;%NWL%process . argv . unshift ( ' rhino ' ) ;%NWL%}%NWL%function showUsage ( )  {%NWL%console . log ( ' Usage: ' ) ;%NWL%console . log ( '  esvalidate [ options ] file . js ' ) ;%NWL%console . log ( ) ;%NWL%console . log ( ' Available options: ' ) ;%NWL%console . log ( ) ;%NWL%console . log ( '  - - format=type Set the report format , plain ( default ) or junit ' ) ;%NWL%console . log ( ) ;%NWL%6
console . log ( ' ECMAScript Validator ( using Esprima version ' , esprima . version ,  ' ) ' ) ;%NWL%console . log ( ) ;%NWL%process . exit ( 0 ) ;%NWL%} else if ( entry . slice ( 0 , 9 ) === ' - - format= ' )  {%NWL%options . format = entry . slice ( 9 ) ;%NWL%if ( options . format !== ' plain ' && options . format !== ' junit ' )  {%NWL%console . log ( ' Error: unknown report format '  + options . format +  ' . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%}%NWL%} else if ( entry . slice ( 0 , 2 ) === ' - - ' )  {%NWL%process . exit ( 1 ) ;%NWL%7
process . exit ( 1 ) ;%NWL%}%NWL%} else if ( entry . slice ( 0 , 2 ) === ' - - ' )  {%NWL%console . log ( ' Error: unknown option '  + entry +  ' . ' ) ;%NWL%process . exit ( 1 ) ;%NWL%} else {%NWL%fnames . push ( entry ) ;%NWL%}%NWL%} ) ;%NWL%if ( fnames . length === 0 )  {%NWL%process . exit ( 1 ) ;%NWL%0
define ( function ( require , exports , module )  {%NWL%var util = require ( ' . / util ' ) ;%NWL%var binarySearch = require ( ' . / binary - search ' ) ;%NWL%var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%1
var util = require ( ' . / util ' ) ;%NWL%var binarySearch = require ( ' . / binary - search ' ) ;%NWL%var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%0
var binarySearch = require ( ' . / binary - search ' ) ;%NWL%var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%9
var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var sourceRoot = util . getArg ( sourceMap ,  ' sourceRoot ' , null ) ;%NWL%8
var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%var sourcesContent = util . getArg ( sourceMap ,  ' sourcesContent ' , null ) ;%NWL%7
%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%var sourceRoot = util . getArg ( sourceMap ,  ' sourceRoot ' , null ) ;%NWL%var mappings = util . getArg ( sourceMap ,  ' mappings ' ) ;%NWL%6
function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%var sourceRoot = util . getArg ( sourceMap ,  ' sourceRoot ' , null ) ;%NWL%var sourcesContent = util . getArg ( sourceMap ,  ' sourcesContent ' , null ) ;%NWL%var file = util . getArg ( sourceMap ,  ' file ' , null ) ;%NWL%5
previousOriginalColumn = mapping . originalColumn;%NWL%str = temp . rest;%NWL%if ( str . length > 0 && !mappingSeparator . test ( str . charAt ( 0 ) ) )  {%NWL%temp = base64VLQ . decode ( str ) ;%NWL%mapping . name = this . _names . at ( previousName + temp . value ) ;%NWL%previousName + = temp . value;%NWL%str = temp . rest;%NWL%}%NWL%}%NWL%this . _generatedMappings . push ( mapping ) ;%NWL%this . _originalMappings . push ( mapping ) ;%NWL%9
} ;%NWL%if ( mapping . source )  {%NWL%newMapping . source = mapping . source;%NWL%if ( sourceRoot )  {%NWL%newMapping . source = util . relative ( sourceRoot , newMapping . source ) ;%NWL%}%NWL%newMapping . original = {%NWL%line: mapping . originalLine ,%NWL%column: mapping . originalColumn%NWL%} ;%NWL%newMapping . name = mapping . name;%NWL%4
if ( content )  {%NWL%generator . setSourceContent ( sourceFile , content ) ;%NWL%}%NWL%} ) ;%NWL%return generator;%NWL%} ;%NWL%%NWL%SourceMapGenerator . prototype . addMapping =%NWL%function SourceMapGenerator_addMapping ( aArgs )  {%NWL%var generated = util . getArg ( aArgs ,  ' generated ' ) ;%NWL%var source = util . getArg ( aArgs ,  ' source ' , null ) ;%NWL%9
generator . setSourceContent ( sourceFile , content ) ;%NWL%}%NWL%} ) ;%NWL%return generator;%NWL%} ;%NWL%%NWL%SourceMapGenerator . prototype . addMapping =%NWL%function SourceMapGenerator_addMapping ( aArgs )  {%NWL%var generated = util . getArg ( aArgs ,  ' generated ' ) ;%NWL%var original = util . getArg ( aArgs ,  ' original ' , null ) ;%NWL%var name = util . getArg ( aArgs ,  ' name ' , null ) ;%NWL%8
var newNames = new ArraySet ( ) ;%NWL%this . _mappings . forEach ( function ( mapping )  {%NWL%if ( mapping . source === aSourceFile && mapping . original )  {%NWL%var original = aSourceMapConsumer . originalPositionFor ( {%NWL%line: mapping . original . line ,%NWL%column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%mapping . source = original . source;%NWL%9
if ( mapping . source === aSourceFile && mapping . original )  {%NWL%var original = aSourceMapConsumer . originalPositionFor ( {%NWL%line: mapping . original . line ,%NWL%column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%} else {%NWL%mapping . source = original . source;%NWL%mapping . original . line = original . line;%NWL%7
var original = aSourceMapConsumer . originalPositionFor ( {%NWL%line: mapping . original . line ,%NWL%column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%} else {%NWL%mapping . source = original . source;%NWL%}%NWL%mapping . original . column = original . column;%NWL%6
column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%} else {%NWL%mapping . source = original . source;%NWL%}%NWL%mapping . original . line = original . line;%NWL%mapping . original . column = original . column;%NWL%mapping . name = original . name;%NWL%4
%NWL%SourceNode . prototype . join = function SourceNode_join ( aSep )  {%NWL%var newChildren;%NWL%var i;%NWL%var len = this . children . length;%NWL%if ( len > 0 )  {%NWL%newChildren = [ ] ;%NWL%for ( i = 0; i < len - 1; i + + )  {%NWL%newChildren . push ( this . children [ i ] ) ;%NWL%newChildren . push ( aSep ) ;%NWL%newChildren . push ( this . children [ i ] ) ;%NWL%8
else if ( typeof lastChild === ' string ' )  {%NWL%this . children [ this . children . length - 1 ] = lastChild . replace ( aPattern , aReplacement ) ;%NWL%}%NWL%else {%NWL%this . children . push ( ' ' . replace ( aPattern , aReplacement ) ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%%NWL%SourceNode . prototype . setSourceContent =%NWL%this . sourceContents [ util . toSetString ( aSourceFile ) ] = aSourceContent;%NWL%1
line: generated . line ,%NWL%column: generated . column%NWL%}%NWL%} ) ;%NWL%sourceMappingActive = false;%NWL%}%NWL%chunk . split ( ' ' ) . forEach ( function ( ch )  {%NWL%if ( ch === ' \n ' )  {%NWL%generated . line + + ;%NWL%generated . column = 0;%NWL%generated . column + + ;%NWL%8
define ( [%NWL%' . / table '%NWL%] ,%NWL%function ( TableView )  {%NWL%var TableViewFallback = TableView . extend ( {%NWL%initialize: function ( options )  {%NWL%this . options = options || { } ;%NWL%this . collection = new existingCollection . constructor ( existingCollection . toJSON ( ) , existingCollection . options ) ;%NWL%6
define ( [%NWL%' . / table '%NWL%] ,%NWL%function ( TableView )  {%NWL%var TableViewFallback = TableView . extend ( {%NWL%initialize: function ( options )  {%NWL%this . options = options || { } ;%NWL%var existingCollection = this . options . collection || this . collection;%NWL%this . valueAttr = this . options . valueAttr;%NWL%6
define ( [%NWL%' . / table '%NWL%] ,%NWL%function ( TableView )  {%NWL%var TableViewFallback = TableView . extend ( {%NWL%initialize: function ( options )  {%NWL%this . options = options || { } ;%NWL%var existingCollection = this . options . collection || this . collection;%NWL%this . collection = new existingCollection . constructor ( existingCollection . toJSON ( ) , existingCollection . options ) ;%NWL%this . period = this . collection . getPeriod ( ) ;%NWL%6
define ( [%NWL%' . / table '%NWL%] ,%NWL%function ( TableView )  {%NWL%var TableViewFallback = TableView . extend ( {%NWL%initialize: function ( options )  {%NWL%this . options = options || { } ;%NWL%var existingCollection = this . options . collection || this . collection;%NWL%this . collection = new existingCollection . constructor ( existingCollection . toJSON ( ) , existingCollection . options ) ;%NWL%this . valueAttr = this . options . valueAttr;%NWL%this . collection . models = this . collection . last ( 6 ) ;%NWL%6
' . / table '%NWL%] ,%NWL%function ( TableView )  {%NWL%var TableViewFallback = TableView . extend ( {%NWL%initialize: function ( options )  {%NWL%this . options = options || { } ;%NWL%var existingCollection = this . options . collection || this . collection;%NWL%this . collection = new existingCollection . constructor ( existingCollection . toJSON ( ) , existingCollection . options ) ;%NWL%this . valueAttr = this . options . valueAttr;%NWL%this . period = this . collection . getPeriod ( ) ;%NWL%this . collection . length = this . collection . models . length;%NWL%5
#! / usr / bin / env node%NWL%var assert = require ( ' assert ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%1
#! / usr / bin / env node%NWL%var assert = require ( ' assert ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' . / source - map / util ' ) ;%NWL%1
var needle = 30;%NWL%var haystack = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] ;%NWL%assert . doesNotThrow ( function ( )  {%NWL%binarySearch . search ( needle , haystack , numberCompare ) ;%NWL%} ) ;%NWL%assert . equal ( binarySearch . search ( needle , haystack , numberCompare ) , 20 ) ;%NWL%} ;%NWL%exports [ ' test too low ' ] = function ( assert , util )  {%NWL%var needle = 1;%NWL%var haystack = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] ;%NWL%binarySearch . search ( needle , haystack , numberCompare ) ;%NWL%3
line: 1 ,%NWL%column: 1 ,%NWL%source: ' bang . coffee '%NWL%} ) ;%NWL%assert . equal ( pos . line , 2 ) ;%NWL%assert . equal ( pos . column , 2 ) ;%NWL%var pos = map . generatedPositionFor ( {%NWL%line: 1 ,%NWL%column: 1 ,%NWL%source: ' foo / bar / bang . coffee '%NWL%assert . equal ( pos . line , 2 ) ;%NWL%4
column: 1 ,%NWL%source: ' bang . coffee '%NWL%} ) ;%NWL%assert . equal ( pos . line , 2 ) ;%NWL%assert . equal ( pos . column , 2 ) ;%NWL%var pos = map . generatedPositionFor ( {%NWL%line: 1 ,%NWL%column: 1 ,%NWL%source: ' foo / bar / bang . coffee '%NWL%} ) ;%NWL%assert . equal ( pos . column , 2 ) ;%NWL%4
} ;%NWL%var nullMapping2 = {%NWL%generated: { line: 2 , column: 2 }%NWL%} ;%NWL%map1 = new SourceMapGenerator ( init ) ;%NWL%map2 = new SourceMapGenerator ( init ) ;%NWL%map1 . addMapping ( nullMapping1 ) ;%NWL%map1 . addMapping ( nullMapping1 ) ;%NWL%map2 . addMapping ( nullMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%map1 . addMapping ( nullMapping1 ) ;%NWL%6
generated: { line: 2 , column: 2 }%NWL%} ;%NWL%map1 = new SourceMapGenerator ( init ) ;%NWL%map2 = new SourceMapGenerator ( init ) ;%NWL%map1 . addMapping ( nullMapping1 ) ;%NWL%map1 . addMapping ( nullMapping1 ) ;%NWL%map2 . addMapping ( nullMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%map1 . addMapping ( nullMapping2 ) ;%NWL%map1 . addMapping ( nullMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%7
generated: { line: 2 , column: 2 } ,%NWL%original: { line: 11 , column: 0 } ,%NWL%source: ' srcMapping2 . js '%NWL%} ;%NWL%map1 = new SourceMapGenerator ( init ) ;%NWL%map2 = new SourceMapGenerator ( init ) ;%NWL%map1 . addMapping ( srcMapping1 ) ;%NWL%map1 . addMapping ( srcMapping1 ) ;%NWL%map2 . addMapping ( srcMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%map1 . addMapping ( srcMapping1 ) ;%NWL%6
source: ' srcMapping2 . js '%NWL%} ;%NWL%map1 = new SourceMapGenerator ( init ) ;%NWL%map2 = new SourceMapGenerator ( init ) ;%NWL%map1 . addMapping ( srcMapping1 ) ;%NWL%map1 . addMapping ( srcMapping1 ) ;%NWL%map2 . addMapping ( srcMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%map1 . addMapping ( srcMapping2 ) ;%NWL%map1 . addMapping ( srcMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%7
original: { line: 11 , column: 0 } ,%NWL%source: ' fullMapping2 . js ' ,%NWL%name: ' fullMapping2 '%NWL%} ;%NWL%map1 = new SourceMapGenerator ( init ) ;%NWL%map2 = new SourceMapGenerator ( init ) ;%NWL%map1 . addMapping ( fullMapping1 ) ;%NWL%map1 . addMapping ( fullMapping1 ) ;%NWL%map2 . addMapping ( fullMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%map1 . addMapping ( fullMapping1 ) ;%NWL%6
name: ' fullMapping2 '%NWL%} ;%NWL%map1 = new SourceMapGenerator ( init ) ;%NWL%map2 = new SourceMapGenerator ( init ) ;%NWL%map1 . addMapping ( fullMapping1 ) ;%NWL%map1 . addMapping ( fullMapping1 ) ;%NWL%map2 . addMapping ( fullMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%map1 . addMapping ( fullMapping2 ) ;%NWL%map1 . addMapping ( fullMapping1 ) ;%NWL%util . assertEqualMaps ( assert , map1 . toJSON ( ) , map2 . toJSON ( ) ) ;%NWL%7
render: function ( options )  {%NWL%options = options || { } ;%NWL%this . removeSubviews ( options ) ;%NWL%if ( this . template )  {%NWL%var context = _ . extend (%NWL%{ } ,%NWL%options . context ,%NWL%this . templateContext ( )%NWL%) ;%NWL%this . $el . html ( this . template ( context ) ) ;%NWL%this . renderSubviews ( options ) ;%NWL%2
node . prepend ( function ( )  { } ) ;%NWL%} ) ;%NWL%} ;%NWL%exports [ ' test . toString ( ) ' ] = function ( assert , util )  {%NWL%assert . equal ( ( new SourceNode ( null , null , null ,%NWL%[ ' function foo ( )  { ' ,%NWL%new SourceNode ( null , null , null ,  ' return 10; ' ) ,%NWL%' } ' ] ) ) . toString ( ) ,%NWL%' function foo ( )  { return 10; } ' ) ;%NWL%} ;%NWL%assert . equal ( ( new SourceNode ( null , null , null ,%NWL%4
} ) ;%NWL%assert . equal ( actual . source ,  ' a . js ' ) ;%NWL%assert . equal ( actual . line , 1 ) ;%NWL%assert . equal ( actual . column , 0 ) ;%NWL%assert . equal ( actual . name ,  ' originalCall ' ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 3 ,%NWL%column: 2%NWL%} ) ;%NWL%assert . equal ( actual . source ,  ' b . js ' ) ;%NWL%assert . equal ( actual . column , 0 ) ;%NWL%3
actual = map . originalPositionFor ( {%NWL%line: 3 ,%NWL%column: 16%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 4 ,%NWL%column: 2%NWL%assert . equal ( actual . source , null ) ;%NWL%4
line: 3 ,%NWL%column: 16%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 4 ,%NWL%column: 2%NWL%} ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%4
column: 16%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 4 ,%NWL%column: 2%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%4
function assertEqualMaps ( assert , actualMap , expectedMap )  {%NWL%assert . equal ( actualMap . version , expectedMap . version ,  " version mismatch " ) ;%NWL%assert . equal ( actualMap . file , expectedMap . file ,  " file mismatch " ) ;%NWL%assert . equal ( actualMap . names . length ,%NWL%expectedMap . names . length ,%NWL%" names length mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . names . length; i + + )  {%NWL%assert . equal ( actualMap . names [ i ] ,%NWL%expectedMap . names [ i ] ,%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%6
assert . equal ( actualMap . names . length ,%NWL%expectedMap . names . length ,%NWL%" names length mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . names . length; i + + )  {%NWL%assert . equal ( actualMap . names [ i ] ,%NWL%expectedMap . names [ i ] ,%NWL%" names [ "  + i +  " ] mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%}%NWL%expectedMap . sources . length ,%NWL%1
assert . equal ( actualMap . names [ i ] ,%NWL%expectedMap . names [ i ] ,%NWL%" names [ "  + i +  " ] mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%}%NWL%assert . equal ( actualMap . sources . length ,%NWL%expectedMap . sources . length ,%NWL%" sources length mismatch: "  +%NWL%actualMap . sources . join ( " ,  " )  +  " != "  + expectedMap . sources . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . sources . length; i + + )  {%NWL%expectedMap . sources [ i ] ,%NWL%1
" names [ "  + i +  " ] mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%}%NWL%assert . equal ( actualMap . sources . length ,%NWL%expectedMap . sources . length ,%NWL%" sources length mismatch: "  +%NWL%actualMap . sources . join ( " ,  " )  +  " != "  + expectedMap . sources . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . sources . length; i + + )  {%NWL%assert . equal ( actualMap . sources [ i ] ,%NWL%expectedMap . sources [ i ] ,%NWL%actualMap . sources . join ( " ,  " )  +  " != "  + expectedMap . sources . join ( " ,  " ) ) ;%NWL%6
v = str ( k , value ) ;%NWL%if ( v )  {%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%}%NWL%}%NWL%}%NWL%} else {%NWL%for ( k in value )  {%NWL%if ( Object . prototype . hasOwnProperty . call ( value , k ) )  {%NWL%v = str ( k , value ) ;%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%2
}%NWL%else {%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%return ret ( " operator " , null , stream . current ( ) ) ;%NWL%}%NWL%}%NWL%else if ( ch == " # " )  {%NWL%stream . skipToEnd ( ) ;%NWL%return ret ( " error " ,  " error " ) ;%NWL%}%NWL%stream . eatWhile ( isOperatorChar ) ;%NWL%2
for ( var v = state . localVars; v; v = v . next )%NWL%if ( v . name == varname ) return;%NWL%state . localVars = { name: varname , next: state . localVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%if ( !cx . state . context ) cx . state . localVars = defaultVars;%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%}%NWL%cx . state . localVars = cx . state . context . vars;%NWL%8
if ( v . name == varname ) return;%NWL%state . localVars = { name: varname , next: state . localVars } ;%NWL%}%NWL%}%NWL%var defaultVars = { name: " this " , next: { name: " arguments " } } ;%NWL%function pushcontext ( )  {%NWL%if ( !cx . state . context ) cx . state . localVars = defaultVars;%NWL%cx . state . context = { prev: cx . state . context , vars: cx . state . localVars } ;%NWL%}%NWL%function popcontext ( )  {%NWL%cx . state . context = cx . state . context . prev;%NWL%7
var result = function ( )  {%NWL%var state = cx . state;%NWL%state . lexical = new JSLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info )%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%state . indented = state . lexical . indented;%NWL%2
var state = cx . state;%NWL%state . lexical = new JSLexical ( state . indented , cx . stream . column ( ) , type , null , state . lexical , info )%NWL%} ;%NWL%result . lex = true;%NWL%return result;%NWL%}%NWL%function poplex ( )  {%NWL%var state = cx . state;%NWL%if ( state . lexical . prev )  {%NWL%if ( state . lexical . type == " ) " )%NWL%state . lexical = state . lexical . prev;%NWL%1
if ( success )  {%NWL%setText ( test +  ' - size ' , kb ( size ) ) ;%NWL%} else {%NWL%setText ( ' status ' ,  ' Please wait . Error loading '  + src ) ;%NWL%setText ( test +  ' - size ' ,  ' Error ' ) ;%NWL%}%NWL%callback . apply ( ) ;%NWL%} ;%NWL%xhr . send ( null ) ;%NWL%} catch ( e )  {%NWL%callback . apply ( ) ;%NWL%6
var xhr = new XMLHttpRequest ( ) ,%NWL%src = ' 3rdparty / '  + tst +  ' . js ' ;%NWL%if ( window . data && window . data . hasOwnProperty ( tst ) )  {%NWL%callback . apply ( ) ;%NWL%}%NWL%try {%NWL%xhr . timeout = 30000;%NWL%xhr . open ( ' GET ' , src , true ) ;%NWL%setText ( ' status ' ,  ' Please wait . Loading '  + src ) ;%NWL%xhr . ontimeout = function ( )  {%NWL%callback . apply ( ) ;%NWL%3
if ( success )  {%NWL%setText ( tst +  ' - size ' , kb ( size ) ) ;%NWL%} else {%NWL%setText ( ' status ' ,  ' Please wait . Error loading '  + src ) ;%NWL%setText ( tst +  ' - size ' ,  ' Error ' ) ;%NWL%}%NWL%callback . apply ( ) ;%NWL%} ;%NWL%xhr . send ( null ) ;%NWL%} catch ( e )  {%NWL%callback . apply ( ) ;%NWL%6
} ;%NWL%break;%NWL%case ' parsejs ' :%NWL%fn = function ( )  {%NWL%var syntax = window . parseJS . parse ( source ) ;%NWL%window . tree . push ( syntax . length ) ;%NWL%} ;%NWL%break;%NWL%case ' zeparser ' :%NWL%fn = function ( )  {%NWL%window . tree . push ( syntax . length ) ;%NWL%5
e . setAttribute ( ' class ' ,  ' code ' ) ;%NWL%setText ( e , code ) ;%NWL%report . appendChild ( e ) ;%NWL%total + = 1;%NWL%}%NWL%function reportFailure ( expected , actual )  {%NWL%var report , e;%NWL%failures + = 1;%NWL%report = document . getElementById ( ' report ' ) ;%NWL%e = document . createElement ( ' p ' ) ;%NWL%report . appendChild ( e ) ;%NWL%2
}%NWL%function reportFailure ( expected , actual )  {%NWL%var report , e;%NWL%failures + = 1;%NWL%report = document . getElementById ( ' report ' ) ;%NWL%e = document . createElement ( ' p ' ) ;%NWL%setText ( e ,  ' Expected ' ) ;%NWL%report . appendChild ( e ) ;%NWL%e = document . createElement ( ' pre ' ) ;%NWL%e . setAttribute ( ' class ' ,  ' expected ' ) ;%NWL%report . appendChild ( e ) ;%NWL%7
failures + = 1;%NWL%report = document . getElementById ( ' report ' ) ;%NWL%e = document . createElement ( ' p ' ) ;%NWL%setText ( e ,  ' Expected ' ) ;%NWL%report . appendChild ( e ) ;%NWL%e = document . createElement ( ' pre ' ) ;%NWL%e . setAttribute ( ' class ' ,  ' expected ' ) ;%NWL%setText ( e , expected ) ;%NWL%report . appendChild ( e ) ;%NWL%e = document . createElement ( ' p ' ) ;%NWL%report . appendChild ( e ) ;%NWL%4
report . appendChild ( e ) ;%NWL%e = document . createElement ( ' pre ' ) ;%NWL%e . setAttribute ( ' class ' ,  ' expected ' ) ;%NWL%setText ( e , expected ) ;%NWL%report . appendChild ( e ) ;%NWL%e = document . createElement ( ' p ' ) ;%NWL%setText ( e ,  ' Actual ' ) ;%NWL%report . appendChild ( e ) ;%NWL%e = document . createElement ( ' pre ' ) ;%NWL%e . setAttribute ( ' class ' ,  ' actual ' ) ;%NWL%report . appendChild ( e ) ;%NWL%0
tick = ( new Date ( ) )  - tick;%NWL%header = total +  ' tests .  '  + failures . length +  ' failures .  '  +%NWL%tick +  ' ms ' ;%NWL%if ( failures . length )  {%NWL%console . error ( header ) ;%NWL%failures . forEach ( function ( failure )  {%NWL%console . error ( failure . source +  ' : Expected\n   '  +%NWL%failure . expected . split ( ' \n ' ) . join ( ' \n   ' )  +%NWL%' \nto match\n   '  + failure . actual ) ;%NWL%} ) ;%NWL%console . log ( header ) ;%NWL%4
for ( var i = 0 , l = models . length; i < l; i + + )  {%NWL%this . _add ( models [ i ] , options ) ;%NWL%}%NWL%} else {%NWL%this . _add ( models , options ) ;%NWL%}%NWL%return this;%NWL%} ,%NWL%remove : function ( models , options )  {%NWL%if ( _ . isArray ( models ) )  {%NWL%this . _remove ( models [ i ] , options ) ;%NWL%1
} else {%NWL%this . _add ( models , options ) ;%NWL%}%NWL%return this;%NWL%} ,%NWL%remove : function ( models , options )  {%NWL%if ( _ . isArray ( models ) )  {%NWL%for ( var i = 0 , l = models . length; i < l; i + + )  {%NWL%this . _remove ( models [ i ] , options ) ;%NWL%}%NWL%this . _remove ( models , options ) ;%NWL%1
if ( fragment . indexOf ( this . options . root ) == 0 ) fragment = fragment . substr ( this . options . root . length ) ;%NWL%} else {%NWL%fragment = window . location . hash;%NWL%}%NWL%}%NWL%return decodeURIComponent ( fragment . replace ( hashStrip ,  ' ' ) ) ;%NWL%} ,%NWL%start : function ( options )  {%NWL%if ( historyStarted ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%this . options     = _ . extend ( { } ,  { root: ' / ' } , this . options , options ) ;%NWL%this . _hasPushState  = !! ( this . options . pushState && window . history && window . history . pushState ) ;%NWL%9
return decodeURIComponent ( fragment . replace ( hashStrip ,  ' ' ) ) ;%NWL%} ,%NWL%start : function ( options )  {%NWL%if ( historyStarted ) throw new Error ( " Backbone . history has already been started " ) ;%NWL%this . options     = _ . extend ( { } ,  { root: ' / ' } , this . options , options ) ;%NWL%this . _wantsPushState = !!this . options . pushState;%NWL%this . _hasPushState  = !! ( this . options . pushState && window . history && window . history . pushState ) ;%NWL%var fragment     = this . getFragment ( ) ;%NWL%var docMode      = document . documentMode;%NWL%var oldIE       = ( isExplorer . exec ( navigator . userAgent . toLowerCase ( ) ) && ( !docMode || docMode <= 7 ) ) ;%NWL%this . iframe = $ ( ' <iframe src= " javascript:0 " tabindex= " - 1 "  / > ' ) . hide ( ) . appendTo ( ' body ' ) [ 0 ] . contentWindow;%NWL%4
generateExpression ( expr . left , Precedence . Call )  +  '  '  + expr . operator +  '  '  +%NWL%generateExpression ( expr . right , Precedence . Assignment ) ,%NWL%Precedence . Assignment ,%NWL%precedence%NWL%) ;%NWL%break;%NWL%case Syntax . ConditionalExpression:%NWL%result = parenthesize (%NWL%generateExpression ( expr . test , Precedence . LogicalOR )  +  ' ? '  +%NWL%generateExpression ( expr . consequent , Precedence . Assignment )  +  ' : '  +%NWL%Precedence . Conditional ,%NWL%2
)%NWL%) ,%NWL%Precedence . Unary ,%NWL%precedence%NWL%) ;%NWL%break;%NWL%case Syntax . UpdateExpression:%NWL%if ( expr . prefix )  {%NWL%result = parenthesize (%NWL%expr . operator +%NWL%Precedence . Unary ,%NWL%2
if ( expr . prefix )  {%NWL%result = parenthesize (%NWL%expr . operator +%NWL%generateExpression ( expr . argument , Precedence . Unary ) ,%NWL%Precedence . Unary ,%NWL%precedence%NWL%) ;%NWL%} else {%NWL%result = parenthesize (%NWL%generateExpression ( expr . argument , Precedence . Postfix )  +%NWL%Precedence . Postfix ,%NWL%4
" && " ,%NWL%" | " ,%NWL%" ^ " ,%NWL%" & " ,%NWL%" == " ,  " != " ,  " === " ,  " !== " ,%NWL%" < " ,  " <= " ,  " >= " ,  " > " ,%NWL%" << " ,  " >> " ,  " >>> " ,%NWL%" + " ,  " - " ,%NWL%" * " ,  " / " ,  " % " ,%NWL%" ! " ,  " ~ " ,  " UNARY_PLUS " ,  " UNARY_MINUS " ,%NWL%" . " ,%NWL%0
} ;%NWL%StringMap . prototype = {%NWL%has: function ( x )  { return hasOwnProperty . call ( this . table , x ) ; } ,%NWL%set: function ( x , v )  {%NWL%if ( !hasOwnProperty . call ( this . table , x ) )%NWL%this . size + + ;%NWL%this . table [ x ] = v;%NWL%} ,%NWL%get: function ( x )  { return this . table [ x ] ; } ,%NWL%getDef: function ( x , thunk )  {%NWL%this . size + + ;%NWL%5
this . lineno + + ;%NWL%} else if ( ch === ' / ' && next === ' * ' )  {%NWL%var commentStart = + + this . cursor;%NWL%for ( ;; )  {%NWL%ch = input [ this . cursor + + ] ;%NWL%if ( ch === undefined )%NWL%throw this . newSyntaxError ( " Unterminated comment " ) ;%NWL%if ( ch === ' * ' )  {%NWL%next = input [ this . cursor ] ;%NWL%if ( next === ' / ' )  {%NWL%this . cursor + + ;%NWL%0
ch = input [ this . cursor + + ] ;%NWL%if ( ch === undefined )%NWL%throw this . newSyntaxError ( " Unterminated comment " ) ;%NWL%if ( ch === ' * ' )  {%NWL%next = input [ this . cursor ] ;%NWL%if ( next === ' / ' )  {%NWL%var commentEnd = this . cursor - 1;%NWL%this . cursor + + ;%NWL%break;%NWL%}%NWL%this . lineno + + ;%NWL%7
break;%NWL%}%NWL%} else if ( ch === ' \n ' )  {%NWL%this . lineno + + ;%NWL%}%NWL%}%NWL%this . blockComments . push ( input . substring ( commentStart , commentEnd ) ) ;%NWL%} else if ( ( ch === ' / ' && next === ' / ' ) ||%NWL%( Narcissus . options . allowHTMLComments && ch === ' < ' && next === ' ! ' &&%NWL%input [ this . cursor + 1 ] === ' - ' && input [ this . cursor + 2 ] === ' - ' &&%NWL%this . cursor + + ;%NWL%3
}%NWL%if ( ch === ' \n ' )  {%NWL%if ( this . scanNewlines )  {%NWL%this . cursor - - ;%NWL%} else {%NWL%this . lineno + + ;%NWL%}%NWL%break;%NWL%}%NWL%}%NWL%this . cursor - - ;%NWL%3
ch = input [ this . cursor + + ] ;%NWL%} while ( ch >= ' 0 ' && ch <= ' 9 ' ) ;%NWL%this . cursor - - ;%NWL%this . lexExponent ( ) ;%NWL%token . value = parseFloat (%NWL%input . substring ( token . start , this . cursor ) ) ;%NWL%} else if ( ch === ' x ' || ch === ' X ' )  {%NWL%do {%NWL%ch = input [ this . cursor + + ] ;%NWL%} while ( ( ch >= ' 0 ' && ch <= ' 9 ' ) || ( ch >= ' a ' && ch <= ' f ' ) ||%NWL%this . cursor - - ;%NWL%2
} else if ( ch === ' x ' || ch === ' X ' )  {%NWL%do {%NWL%ch = input [ this . cursor + + ] ;%NWL%} while ( ( ch >= ' 0 ' && ch <= ' 9 ' ) || ( ch >= ' a ' && ch <= ' f ' ) ||%NWL%( ch >= ' A ' && ch <= ' F ' ) ) ;%NWL%this . cursor - - ;%NWL%token . value = parseInt ( input . substring ( token . start , this . cursor ) ) ;%NWL%} else if ( ch >= ' 0 ' && ch <= ' 7 ' )  {%NWL%do {%NWL%ch = input [ this . cursor + + ] ;%NWL%this . cursor - - ;%NWL%5
} while ( ( ch >= ' 0 ' && ch <= ' 9 ' ) || ( ch >= ' a ' && ch <= ' f ' ) ||%NWL%( ch >= ' A ' && ch <= ' F ' ) ) ;%NWL%this . cursor - - ;%NWL%token . value = parseInt ( input . substring ( token . start , this . cursor ) ) ;%NWL%} else if ( ch >= ' 0 ' && ch <= ' 7 ' )  {%NWL%do {%NWL%ch = input [ this . cursor + + ] ;%NWL%} while ( ch >= ' 0 ' && ch <= ' 7 ' ) ;%NWL%this . cursor - - ;%NWL%token . value = parseInt ( input . substring ( token . start , this . cursor ) ) ;%NWL%this . cursor - - ;%NWL%2
var token = this . token , input = this . source;%NWL%token . type = REGEXP;%NWL%do {%NWL%ch = input [ this . cursor + + ] ;%NWL%if ( ch === ' \\ ' )  {%NWL%this . cursor + + ;%NWL%} else if ( ch === ' [ ' )  {%NWL%do {%NWL%if ( ch === undefined )%NWL%throw this . newSyntaxError ( " Unterminated character class " ) ;%NWL%this . cursor + + ;%NWL%5
} ,%NWL%lexOp: function ( ch )  {%NWL%var token = this . token , input = this . source;%NWL%var node = opTokens [ ch ] ;%NWL%var next = input [ this . cursor ] ;%NWL%if ( next in node )  {%NWL%node = node [ next ] ;%NWL%this . cursor + + ;%NWL%next = input [ this . cursor ] ;%NWL%if ( next in node )  {%NWL%this . cursor + + ;%NWL%7
node = node [ next ] ;%NWL%this . cursor + + ;%NWL%next = input [ this . cursor ] ;%NWL%if ( next in node )  {%NWL%node = node [ next ] ;%NWL%this . cursor + + ;%NWL%next = input [ this . cursor ] ;%NWL%}%NWL%}%NWL%var op = node . op;%NWL%this . cursor + + ;%NWL%1
%NWL%get: function ( scanOperand , keywordIsName )  {%NWL%var token;%NWL%while ( this . lookahead )  {%NWL%- - this . lookahead;%NWL%this . tokenIndex = ( this . tokenIndex + 1 ) & 3;%NWL%token = this . tokens [ this . tokenIndex ] ;%NWL%if ( token . type !== NEWLINE || this . scanNewlines )%NWL%return token . type;%NWL%}%NWL%this . tokenIndex = ( this . tokenIndex + 1 ) & 3;%NWL%5
if ( token . type !== NEWLINE || this . scanNewlines )%NWL%return token . type;%NWL%}%NWL%this . skip ( ) ;%NWL%this . tokenIndex = ( this . tokenIndex + 1 ) & 3;%NWL%token = this . tokens [ this . tokenIndex ] ;%NWL%if ( !token )%NWL%this . tokens [ this . tokenIndex ] = token = { } ;%NWL%var input = this . source;%NWL%if ( this . cursor >= input . length )%NWL%token . start = this . cursor;%NWL%5
return token . type;%NWL%}%NWL%this . skip ( ) ;%NWL%this . tokenIndex = ( this . tokenIndex + 1 ) & 3;%NWL%token = this . tokens [ this . tokenIndex ] ;%NWL%if ( !token )%NWL%this . tokens [ this . tokenIndex ] = token = { } ;%NWL%var input = this . source;%NWL%if ( this . cursor >= input . length )%NWL%return token . type = END;%NWL%token . lineno = this . lineno;%NWL%4
if ( this . cursor >= input . length )%NWL%return token . type = END;%NWL%token . start = this . cursor;%NWL%token . lineno = this . lineno;%NWL%var ich = this . getValidIdentifierChar ( true ) ;%NWL%var ch = ( ich === null ) ? input [ this . cursor + + ] : null;%NWL%if ( ich !== null )  {%NWL%this . lexIdent ( ich , keywordIsName ) ;%NWL%} else if ( scanOperand && ch === ' / ' )  {%NWL%this . lexRegExp ( ch ) ;%NWL%this . lexOp ( ch ) ;%NWL%9
token . start = this . cursor;%NWL%token . lineno = this . lineno;%NWL%var ich = this . getValidIdentifierChar ( true ) ;%NWL%var ch = ( ich === null ) ? input [ this . cursor + + ] : null;%NWL%if ( ich !== null )  {%NWL%this . lexIdent ( ich , keywordIsName ) ;%NWL%} else if ( scanOperand && ch === ' / ' )  {%NWL%this . lexRegExp ( ch ) ;%NWL%} else if ( ch in opTokens )  {%NWL%this . lexOp ( ch ) ;%NWL%this . lexDot ( ch ) ;%NWL%7
var ich = this . getValidIdentifierChar ( true ) ;%NWL%var ch = ( ich === null ) ? input [ this . cursor + + ] : null;%NWL%if ( ich !== null )  {%NWL%this . lexIdent ( ich , keywordIsName ) ;%NWL%} else if ( scanOperand && ch === ' / ' )  {%NWL%this . lexRegExp ( ch ) ;%NWL%} else if ( ch in opTokens )  {%NWL%this . lexOp ( ch ) ;%NWL%} else if ( ch === ' . ' )  {%NWL%this . lexDot ( ch ) ;%NWL%this . lexNumber ( ch ) ;%NWL%5
if ( ich !== null )  {%NWL%this . lexIdent ( ich , keywordIsName ) ;%NWL%} else if ( scanOperand && ch === ' / ' )  {%NWL%this . lexRegExp ( ch ) ;%NWL%} else if ( ch in opTokens )  {%NWL%this . lexOp ( ch ) ;%NWL%} else if ( ch === ' . ' )  {%NWL%this . lexDot ( ch ) ;%NWL%} else if ( ch >= ' 1 ' && ch <= ' 9 ' )  {%NWL%this . lexNumber ( ch ) ;%NWL%this . lexZeroNumber ( ch ) ;%NWL%3
} else if ( scanOperand && ch === ' / ' )  {%NWL%this . lexRegExp ( ch ) ;%NWL%} else if ( ch in opTokens )  {%NWL%this . lexOp ( ch ) ;%NWL%} else if ( ch === ' . ' )  {%NWL%this . lexDot ( ch ) ;%NWL%} else if ( ch >= ' 1 ' && ch <= ' 9 ' )  {%NWL%this . lexNumber ( ch ) ;%NWL%} else if ( ch === ' 0 ' )  {%NWL%this . lexZeroNumber ( ch ) ;%NWL%this . lexString ( ch ) ;%NWL%1
%NWL%this . errorStack = [ ] ;%NWL%%NWL%this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%9
this . errorStack = [ ] ;%NWL%%NWL%this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%8
%NWL%this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . regexNumber = Tokenizer . regexNumber;%NWL%7
this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%this . regexNewline = Tokenizer . regexNewline;%NWL%6
%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%this . regexNumber = Tokenizer . regexNumber;%NWL%this . regexNewline = Tokenizer . regexNewline;%NWL%this . regexBig = Tokenizer . regexBig;%NWL%4
this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%this . regexNumber = Tokenizer . regexNumber;%NWL%this . regexNewline = Tokenizer . regexNewline;%NWL%%NWL%this . regexBigAlt = Tokenizer . regexBigAlt;%NWL%3
+ + pos;%NWL%}%NWL%if ( this . regexLineTerminator . test ( inp [ pos ] ) )  {%NWL%returnValue = { start:start , stop:pos , name:14 , value:inp . substring ( start , pos ) , isString:true , tokenError:true , error:Tokenizer . Error . UnterminatedDoubleStringNewline } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%break;%NWL%}%NWL%} while ( pos < inp . length && inp [ pos ] != " ' " ) ;%NWL%if ( returnValue )  { }  / / error%NWL%else if ( inp [ pos ] != " ' " )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%4
+ + pos;%NWL%}%NWL%if ( this . regexLineTerminator . test ( inp [ pos ] ) )  {%NWL%returnValue = { start:start , stop:pos , name:14 , value:inp . substring ( start , pos ) , isString:true , tokenError:true , error:Tokenizer . Error . UnterminatedSingleStringNewline } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%break;%NWL%}%NWL%} while ( pos < inp . length && inp [ pos ] != ' " ' ) ;%NWL%if ( returnValue )  { }%NWL%else if ( inp [ pos ] != ' " ' )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%4
if ( !found || returnValue )  {%NWL%if ( !returnValue )  {%NWL%returnValue = { start:start , stop:pos , name:14 , tokenError:true , error:Tokenizer . Error . UnterminatedRegularExpressionOther } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%} else {%NWL%do + + pos;%NWL%while ( pos < inp . length && this . hashAsciiIdentifier [ inp [ pos ] ] ) ;%NWL%%NWL%if ( parens . length )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%3
this . errorStack . push ( returnValue ) ;%NWL%}%NWL%} else {%NWL%do + + pos;%NWL%while ( pos < inp . length && this . hashAsciiIdentifier [ inp [ pos ] ] ) ;%NWL%%NWL%if ( parens . length )  {%NWL%if ( parens . length > 0 ) returnValue = { start:start , stop:pos , name:14 , tokenError:true , error:Tokenizer . Error . RegexOpenGroup } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else if ( nonLethalError )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%0
%NWL%if ( found )  {%NWL%returnValue = { start:start , stop:pos , name:2 , value:inp . substring ( start , pos ) } ;%NWL%if ( returnValue . value == ' undefined ' || returnValue . value == ' null ' || returnValue . value == ' true ' || returnValue . value == ' false ' ) returnValue . isPrimitive = true;%NWL%} else {%NWL%if ( inp [ pos ] == ' ` ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . BacktickNotSupported } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else if ( inp [ pos ] == ' \\ ' )  {%NWL%if ( inp [ pos + 1 ] == ' u ' )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%7
if ( returnValue . value == ' undefined ' || returnValue . value == ' null ' || returnValue . value == ' true ' || returnValue . value == ' false ' ) returnValue . isPrimitive = true;%NWL%} else {%NWL%if ( inp [ pos ] == ' ` ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . BacktickNotSupported } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else if ( inp [ pos ] == ' \\ ' )  {%NWL%if ( inp [ pos + 1 ] == ' u ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . InvalidUnicodeEscape } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else {%NWL%this . errorStack . push ( returnValue ) ;%NWL%4
this . errorStack . push ( returnValue ) ;%NWL%} else if ( inp [ pos ] == ' \\ ' )  {%NWL%if ( inp [ pos + 1 ] == ' u ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . InvalidUnicodeEscape } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . InvalidBackslash } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%} else {%NWL%this . errorStack . push ( returnValue ) ;%NWL%0
} else {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . Unknown , value:c } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%+ + pos;%NWL%}%NWL%}%NWL%}%NWL%%NWL%if ( returnValue )  {%NWL%this . wtree . push ( returnValue ) ;%NWL%2
}%NWL%+ + pos;%NWL%}%NWL%}%NWL%}%NWL%%NWL%if ( returnValue )  {%NWL%returnValue . tokposw = this . wtree . length;%NWL%this . wtree . push ( returnValue ) ;%NWL%if ( !returnValue . isWhite )  {%NWL%this . btree . push ( returnValue ) ;%NWL%8
if ( inp [ + + pos ] == ' + ' || inp [ pos ] == ' - ' )  + + pos;%NWL%var expPosBak = pos;%NWL%while ( pos < inp . length && inp [ pos ] >= ' 0 ' && inp [ pos ] <= ' 9 ' )  + + pos;%NWL%if ( expPosBak == pos )  {%NWL%returnValue = { start:start , stop:pos , name:14 , tokenError:true , error:Tokenizer . Error . NumberExponentRequiresDigits } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%}%NWL%if ( returnValue . name != 14 )  {%NWL%if ( parsingOctal )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%5
var Handlebars = require ( ' . / lib / handlebars ' ) ;%NWL%Handlebars . registerHelper ( ' test_helper ' , function ( )  { return ' found it! '  } ) ;%NWL%Handlebars . registerPartial ( ' global_test ' ,  ' { { another_dude } } ' ) ;%NWL%var template = Handlebars . precompile ( " Dudes: { { #if foo } }  { { #if nested } }  { { > shared / dude } }  { { / if } }  { { > global_test } }  { { / if } } " ) ;%NWL%console . log ( template ) ;%NWL%return;%NWL%console . log (%NWL%template ( { cruel: " cruel " , name: " Jeepers " , another_dude: " Creepers " } ,  {%NWL%helpers: { world: function ( )  { return " world! " ; } } ,%NWL%partials: { ' shared / dude ' : " { { name } } " }%NWL%console . log ( template ) ;%NWL%4
Handlebars . AST . ProgramNode = function ( statements , inverse )  {%NWL%this . type = " program " ;%NWL%this . statements = statements;%NWL%if ( inverse )  { this . inverse = new Handlebars . AST . ProgramNode ( inverse ) ; }%NWL%} ;%NWL%Handlebars . AST . MustacheNode = function ( rawParams , hash , unescaped )  {%NWL%this . type = " mustache " ;%NWL%this . escaped = !unescaped;%NWL%this . hash = hash;%NWL%var id = this . id = rawParams [ 0 ] ;%NWL%var eligibleHelper = this . eligibleHelper = id . isSimple;%NWL%9
var compilerbase = require ( " . / base " ) ;%NWL%exports . attach = function ( Handlebars )  {%NWL%compilerbase . attach ( Handlebars ) ;%NWL%var Compiler = Handlebars . Compiler = function ( )  { } ;%NWL%var JavaScriptCompiler = Handlebars . JavaScriptCompiler = function ( )  { } ;%NWL%Compiler . prototype = {%NWL%compiler: Compiler ,%NWL%var opcodes = this . opcodes , opcode , out = [ ] , params , param;%NWL%3
this [ statement . type ] ( statement ) ;%NWL%}%NWL%this . isSimple = l === 1;%NWL%this . depths . list = this . depths . list . sort ( function ( a , b )  {%NWL%return a - b;%NWL%} ) ;%NWL%return this;%NWL%} ,%NWL%compileProgram: function ( program )  {%NWL%var result = new this . compiler ( ) . compile ( program , this . options ) ;%NWL%this . usePartial = this . usePartial || result . usePartial;%NWL%3
var guid = this . guid + + , depth;%NWL%this . usePartial = this . usePartial || result . usePartial;%NWL%this . children [ guid ] = result;%NWL%for ( var i=0 , l=result . depths . list . length; i<l; i + + )  {%NWL%depth = result . depths . list [ i ] ;%NWL%if ( depth < 2 )  { continue; }%NWL%else { this . addDepth ( depth - 1 ) ; }%NWL%}%NWL%return guid;%NWL%} ,%NWL%var mustache = block . mustache ,%NWL%0
}%NWL%var type = this . classifyMustache ( mustache ) ;%NWL%if ( type === " helper " )  {%NWL%this . helperMustache ( mustache , program , inverse ) ;%NWL%} else if ( type === " simple " )  {%NWL%this . simpleMustache ( mustache ) ;%NWL%this . opcode ( ' pushProgram ' , program ) ;%NWL%this . opcode ( ' pushProgram ' , inverse ) ;%NWL%this . opcode ( ' emptyHash ' ) ;%NWL%this . opcode ( ' blockValue ' ) ;%NWL%this . ambiguousMustache ( mustache , program , inverse ) ;%NWL%3
var type = this . classifyMustache ( mustache ) ;%NWL%if ( type === " helper " )  {%NWL%this . helperMustache ( mustache , program , inverse ) ;%NWL%} else if ( type === " simple " )  {%NWL%this . simpleMustache ( mustache ) ;%NWL%this . opcode ( ' pushProgram ' , program ) ;%NWL%this . opcode ( ' pushProgram ' , inverse ) ;%NWL%this . opcode ( ' emptyHash ' ) ;%NWL%this . opcode ( ' blockValue ' ) ;%NWL%} else {%NWL%this . opcode ( ' pushProgram ' , program ) ;%NWL%5
if ( type === " helper " )  {%NWL%this . helperMustache ( mustache , program , inverse ) ;%NWL%} else if ( type === " simple " )  {%NWL%this . simpleMustache ( mustache ) ;%NWL%this . opcode ( ' pushProgram ' , program ) ;%NWL%this . opcode ( ' pushProgram ' , inverse ) ;%NWL%this . opcode ( ' emptyHash ' ) ;%NWL%this . opcode ( ' blockValue ' ) ;%NWL%} else {%NWL%this . ambiguousMustache ( mustache , program , inverse ) ;%NWL%this . opcode ( ' pushProgram ' , inverse ) ;%NWL%5
this . helperMustache ( mustache , program , inverse ) ;%NWL%} else if ( type === " simple " )  {%NWL%this . simpleMustache ( mustache ) ;%NWL%this . opcode ( ' pushProgram ' , program ) ;%NWL%this . opcode ( ' pushProgram ' , inverse ) ;%NWL%this . opcode ( ' emptyHash ' ) ;%NWL%this . opcode ( ' blockValue ' ) ;%NWL%} else {%NWL%this . ambiguousMustache ( mustache , program , inverse ) ;%NWL%this . opcode ( ' pushProgram ' , program ) ;%NWL%this . opcode ( ' emptyHash ' ) ;%NWL%5
this . opcode ( ' append ' ) ;%NWL%} ,%NWL%content: function ( content )  {%NWL%this . opcode ( ' appendContent ' , content . string ) ;%NWL%} ,%NWL%mustache: function ( mustache )  {%NWL%var options = this . options;%NWL%var type = this . classifyMustache ( mustache ) ;%NWL%if ( type === " simple " )  {%NWL%this . simpleMustache ( mustache ) ;%NWL%this . helperMustache ( mustache ) ;%NWL%9
content: function ( content )  {%NWL%this . opcode ( ' appendContent ' , content . string ) ;%NWL%} ,%NWL%mustache: function ( mustache )  {%NWL%var options = this . options;%NWL%var type = this . classifyMustache ( mustache ) ;%NWL%if ( type === " simple " )  {%NWL%this . simpleMustache ( mustache ) ;%NWL%} else if ( type === " helper " )  {%NWL%this . helperMustache ( mustache ) ;%NWL%this . ambiguousMustache ( mustache ) ;%NWL%7
isBlock = program != null || inverse != null;%NWL%this . opcode ( ' getContext ' , id . depth ) ;%NWL%this . opcode ( ' pushProgram ' , program ) ;%NWL%this . opcode ( ' pushProgram ' , inverse ) ;%NWL%this . opcode ( ' invokeAmbiguous ' , name , isBlock ) ;%NWL%} ,%NWL%simpleMustache: function ( mustache )  {%NWL%var id = mustache . id;%NWL%if ( id . type === ' DATA ' )  {%NWL%this . DATA ( id ) ;%NWL%this . ID ( id ) ;%NWL%9
var params = mustache . params;%NWL%this . pushParams ( params ) ;%NWL%if ( mustache . hash )  {%NWL%this . hash ( mustache . hash ) ;%NWL%} else {%NWL%this . opcode ( ' emptyHash ' ) ;%NWL%}%NWL%return params;%NWL%} ,%NWL%setupFullMustacheParams: function ( mustache , program , inverse )  {%NWL%this . pushParams ( params ) ;%NWL%1
} ;%NWL%}%NWL%} ,%NWL%initializeBuffer: function ( )  {%NWL%return this . quotedString ( " " ) ;%NWL%} ,%NWL%namespace: " Handlebars " ,%NWL%compile: function ( environment , options , context , asObject )  {%NWL%this . environment = environment;%NWL%this . options = options || { } ;%NWL%this . name = this . environment . name;%NWL%9
this . lastContext = 0;%NWL%this . source = out;%NWL%} ,%NWL%createFunctionContext: function ( asObject )  {%NWL%var locals = this . stackVars . concat ( this . registers . list ) ;%NWL%if ( locals . length > 0 )  {%NWL%this . source [ 1 ] = this . source [ 1 ]  +  " ,  "  + locals . join ( " ,  " ) ;%NWL%}%NWL%if ( !this . isChild )  {%NWL%for ( var alias in this . context . aliases )  {%NWL%this . source [ 1 ] = this . source [ 1 ]  +  ' ,  '  + alias +  ' = '  + this . context . aliases [ alias ] ;%NWL%6
if ( locals . length > 0 )  {%NWL%this . source [ 1 ] = this . source [ 1 ]  +  " ,  "  + locals . join ( " ,  " ) ;%NWL%}%NWL%if ( !this . isChild )  {%NWL%for ( var alias in this . context . aliases )  {%NWL%if ( this . context . aliases . hasOwnProperty ( alias ) )  {%NWL%this . source [ 1 ] = this . source [ 1 ]  +  ' ,  '  + alias +  ' = '  + this . context . aliases [ alias ] ;%NWL%}%NWL%}%NWL%}%NWL%this . source [ 1 ] = " var "  + this . source [ 1 ] . substring ( 2 )  +  " ; " ;%NWL%1
if ( !this . isChild )  {%NWL%for ( var alias in this . context . aliases )  {%NWL%if ( this . context . aliases . hasOwnProperty ( alias ) )  {%NWL%this . source [ 1 ] = this . source [ 1 ]  +  ' ,  '  + alias +  ' = '  + this . context . aliases [ alias ] ;%NWL%}%NWL%}%NWL%}%NWL%if ( this . source [ 1 ] )  {%NWL%this . source [ 1 ] = " var "  + this . source [ 1 ] . substring ( 2 )  +  " ; " ;%NWL%}%NWL%this . source [ 1 ]  + = ' \n '  + this . context . programs . join ( ' \n ' )  +  ' \n ' ;%NWL%3
this . context . aliases . blockHelperMissing = ' helpers . blockHelperMissing ' ;%NWL%var params = [ " depth0 " ] ;%NWL%this . setupParams ( 0 , params ) ;%NWL%this . replaceStack ( function ( current )  {%NWL%params . splice ( 1 , 0 , current ) ;%NWL%return " blockHelperMissing . call ( "  + params . join ( " ,  " )  +  " ) " ;%NWL%} ) ;%NWL%} ,%NWL%ambiguousBlockValue: function ( )  {%NWL%this . context . aliases . blockHelperMissing = ' helpers . blockHelperMissing ' ;%NWL%this . setupParams ( 0 , params ) ;%NWL%2
this . setupParams ( 0 , params ) ;%NWL%this . replaceStack ( function ( current )  {%NWL%params . splice ( 1 , 0 , current ) ;%NWL%return " blockHelperMissing . call ( "  + params . join ( " ,  " )  +  " ) " ;%NWL%} ) ;%NWL%} ,%NWL%ambiguousBlockValue: function ( )  {%NWL%this . context . aliases . blockHelperMissing = ' helpers . blockHelperMissing ' ;%NWL%var params = [ " depth0 " ] ;%NWL%this . setupParams ( 0 , params ) ;%NWL%params . splice ( 1 , 0 , current ) ;%NWL%2
} ) ;%NWL%} ,%NWL%lookupData: function ( id )  {%NWL%this . push ( ' data ' ) ;%NWL%} ,%NWL%pushStringParam: function ( string , type )  {%NWL%this . pushStackLiteral ( ' depth '  + this . lastContext ) ;%NWL%this . pushString ( type ) ;%NWL%if ( typeof string === ' string ' )  {%NWL%this . pushString ( string ) ;%NWL%this . pushStackLiteral ( string ) ;%NWL%9
}%NWL%this . padding - - ;%NWL%return out;%NWL%} ;%NWL%Handlebars . PrintVisitor . prototype . block = function ( block )  {%NWL%var out = " " ;%NWL%out = out + this . pad ( " BLOCK: " ) ;%NWL%this . padding + + ;%NWL%out = out + this . accept ( block . mustache ) ;%NWL%if ( block . program )  {%NWL%this . padding + + ;%NWL%7
this . padding + + ;%NWL%out = out + this . accept ( block . mustache ) ;%NWL%if ( block . program )  {%NWL%out = out + this . pad ( " PROGRAM: " ) ;%NWL%this . padding + + ;%NWL%out = out + this . accept ( block . program ) ;%NWL%this . padding - - ;%NWL%}%NWL%if ( block . inverse )  {%NWL%if ( block . program )  { this . padding + + ; }%NWL%this . padding + + ;%NWL%0
if ( block . program )  {%NWL%out = out + this . pad ( " PROGRAM: " ) ;%NWL%this . padding + + ;%NWL%out = out + this . accept ( block . program ) ;%NWL%this . padding - - ;%NWL%}%NWL%if ( block . inverse )  {%NWL%if ( block . program )  { this . padding + + ; }%NWL%out = out + this . pad ( " { { ^ } } " ) ;%NWL%this . padding + + ;%NWL%this . padding - - ;%NWL%4
out = out + this . accept ( block . program ) ;%NWL%this . padding - - ;%NWL%}%NWL%if ( block . inverse )  {%NWL%if ( block . program )  { this . padding + + ; }%NWL%out = out + this . pad ( " { { ^ } } " ) ;%NWL%this . padding + + ;%NWL%out = out + this . accept ( block . inverse ) ;%NWL%this . padding - - ;%NWL%if ( block . program )  { this . padding - - ; }%NWL%this . padding - - ;%NWL%1
var requirejs = require ( ' requirejs ' ) ;%NWL%var sanitizer = require ( ' sanitizer ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var Backbone = require ( ' backbone ' ) ;%NWL%var sanitizer = require ( ' sanitizer ' ) ;%NWL%var ServicesView = require ( ' . . / views / services ' ) ;%NWL%var HomepageView = require ( ' . . / views / homepage ' ) ;%NWL%var ErrorView = require ( ' . . / views / error ' ) ;%NWL%var ServicesCollection = requirejs ( ' common / collections / services ' ) ;%NWL%var Collection = requirejs ( ' extensions / collections / collection ' ) ;%NWL%var get_dashboard_and_render = require ( ' . . / mixins / get_dashboard_and_render ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var Backbone = require ( ' backbone ' ) ;%NWL%var sanitizer = require ( ' sanitizer ' ) ;%NWL%var ServicesView = require ( ' . . / views / services ' ) ;%NWL%var HomepageView = require ( ' . . / views / homepage ' ) ;%NWL%var ErrorView = require ( ' . . / views / error ' ) ;%NWL%var ServicesCollection = requirejs ( ' common / collections / services ' ) ;%NWL%var Collection = requirejs ( ' extensions / collections / collection ' ) ;%NWL%var PageConfig = requirejs ( ' page_config ' ) ;%NWL%var tools = require ( ' . / tools ' ) ;%NWL%0
var task = q . tasks . shift ( ) ;%NWL%if ( q . empty && q . tasks . length === 0 )  {%NWL%q . empty ( ) ;%NWL%}%NWL%workers + = 1;%NWL%var next = function ( )  {%NWL%workers - = 1;%NWL%if ( task . callback )  {%NWL%task . callback . apply ( task , arguments ) ;%NWL%}%NWL%q . drain ( ) ;%NWL%2
q . empty ( ) ;%NWL%}%NWL%workers + = 1;%NWL%var next = function ( )  {%NWL%workers - = 1;%NWL%if ( task . callback )  {%NWL%task . callback . apply ( task , arguments ) ;%NWL%}%NWL%if ( q . drain && q . tasks . length + workers === 0 )  {%NWL%q . drain ( ) ;%NWL%q . process ( ) ;%NWL%0
} ;%NWL%async . times = function ( count , iterator , callback )  {%NWL%var counter = [ ] ;%NWL%for ( var i = 0; i < count; i + + )  {%NWL%counter . push ( i ) ;%NWL%}%NWL%return async . map ( counter , iterator , callback ) ;%NWL%} ;%NWL%async . timesSeries = function ( count , iterator , callback )  {%NWL%var counter = [ ] ;%NWL%counter . push ( i ) ;%NWL%4
var requirejs = require ( ' requirejs ' ) ;%NWL%var sanitizer = require ( ' sanitizer ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var Backbone = require ( ' backbone ' ) ;%NWL%var get_dashboard_and_render = require ( ' . . / mixins / get_dashboard_and_render ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var Backbone = require ( ' backbone ' ) ;%NWL%var sanitizer = require ( ' sanitizer ' ) ;%NWL%var get_dashboard_and_render = require ( ' . . / mixins / get_dashboard_and_render ' ) ;%NWL%var View = require ( ' . . / views / simple - dashboard - list ' ) ;%NWL%var ErrorView = require ( ' . . / views / error ' ) ;%NWL%var DashboardCollection = requirejs ( ' common / collections / dashboards ' ) ;%NWL%var tools = require ( ' . / tools ' ) ;%NWL%0
define ( function ( require , exports , module )  {%NWL%var util = require ( ' . / util ' ) ;%NWL%var binarySearch = require ( ' . / binary - search ' ) ;%NWL%var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%1
var util = require ( ' . / util ' ) ;%NWL%var binarySearch = require ( ' . / binary - search ' ) ;%NWL%var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%0
var binarySearch = require ( ' . / binary - search ' ) ;%NWL%var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%9
var ArraySet = require ( ' . / array - set ' ) . ArraySet;%NWL%var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var sourceRoot = util . getArg ( sourceMap ,  ' sourceRoot ' , null ) ;%NWL%8
var base64VLQ = require ( ' . / base64 - vlq ' ) ;%NWL%%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%var sourcesContent = util . getArg ( sourceMap ,  ' sourcesContent ' , null ) ;%NWL%7
%NWL%function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%var sourceRoot = util . getArg ( sourceMap ,  ' sourceRoot ' , null ) ;%NWL%var mappings = util . getArg ( sourceMap ,  ' mappings ' ) ;%NWL%6
function SourceMapConsumer ( aSourceMap )  {%NWL%var sourceMap = aSourceMap;%NWL%if ( typeof aSourceMap === ' string ' )  {%NWL%sourceMap = JSON . parse ( aSourceMap . replace ( / ^\ ) \ ] \ } ' / ,  ' ' ) ) ;%NWL%}%NWL%var version = util . getArg ( sourceMap ,  ' version ' ) ;%NWL%var sources = util . getArg ( sourceMap ,  ' sources ' ) ;%NWL%var names = util . getArg ( sourceMap ,  ' names ' ) ;%NWL%var sourceRoot = util . getArg ( sourceMap ,  ' sourceRoot ' , null ) ;%NWL%var sourcesContent = util . getArg ( sourceMap ,  ' sourcesContent ' , null ) ;%NWL%var file = util . getArg ( sourceMap ,  ' file ' , null ) ;%NWL%5
previousOriginalColumn = mapping . originalColumn;%NWL%str = temp . rest;%NWL%if ( str . length > 0 && !mappingSeparator . test ( str . charAt ( 0 ) ) )  {%NWL%temp = base64VLQ . decode ( str ) ;%NWL%mapping . name = this . _names . at ( previousName + temp . value ) ;%NWL%previousName + = temp . value;%NWL%str = temp . rest;%NWL%}%NWL%}%NWL%this . _generatedMappings . push ( mapping ) ;%NWL%this . _originalMappings . push ( mapping ) ;%NWL%9
} ;%NWL%if ( mapping . source )  {%NWL%newMapping . source = mapping . source;%NWL%if ( sourceRoot )  {%NWL%newMapping . source = util . relative ( sourceRoot , newMapping . source ) ;%NWL%}%NWL%newMapping . original = {%NWL%line: mapping . originalLine ,%NWL%column: mapping . originalColumn%NWL%} ;%NWL%newMapping . name = mapping . name;%NWL%4
if ( content )  {%NWL%generator . setSourceContent ( sourceFile , content ) ;%NWL%}%NWL%} ) ;%NWL%return generator;%NWL%} ;%NWL%%NWL%SourceMapGenerator . prototype . addMapping =%NWL%function SourceMapGenerator_addMapping ( aArgs )  {%NWL%var generated = util . getArg ( aArgs ,  ' generated ' ) ;%NWL%var source = util . getArg ( aArgs ,  ' source ' , null ) ;%NWL%9
generator . setSourceContent ( sourceFile , content ) ;%NWL%}%NWL%} ) ;%NWL%return generator;%NWL%} ;%NWL%%NWL%SourceMapGenerator . prototype . addMapping =%NWL%function SourceMapGenerator_addMapping ( aArgs )  {%NWL%var generated = util . getArg ( aArgs ,  ' generated ' ) ;%NWL%var original = util . getArg ( aArgs ,  ' original ' , null ) ;%NWL%var name = util . getArg ( aArgs ,  ' name ' , null ) ;%NWL%8
var newNames = new ArraySet ( ) ;%NWL%this . _mappings . forEach ( function ( mapping )  {%NWL%if ( mapping . source === aSourceFile && mapping . original )  {%NWL%var original = aSourceMapConsumer . originalPositionFor ( {%NWL%line: mapping . original . line ,%NWL%column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%mapping . source = original . source;%NWL%9
if ( mapping . source === aSourceFile && mapping . original )  {%NWL%var original = aSourceMapConsumer . originalPositionFor ( {%NWL%line: mapping . original . line ,%NWL%column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%} else {%NWL%mapping . source = original . source;%NWL%mapping . original . line = original . line;%NWL%7
var original = aSourceMapConsumer . originalPositionFor ( {%NWL%line: mapping . original . line ,%NWL%column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%} else {%NWL%mapping . source = original . source;%NWL%}%NWL%mapping . original . column = original . column;%NWL%6
column: mapping . original . column%NWL%} ) ;%NWL%if ( original . source !== null )  {%NWL%if ( sourceRoot )  {%NWL%mapping . source = util . relative ( sourceRoot , original . source ) ;%NWL%} else {%NWL%mapping . source = original . source;%NWL%}%NWL%mapping . original . line = original . line;%NWL%mapping . original . column = original . column;%NWL%mapping . name = original . name;%NWL%4
%NWL%SourceNode . prototype . join = function SourceNode_join ( aSep )  {%NWL%var newChildren;%NWL%var i;%NWL%var len = this . children . length;%NWL%if ( len > 0 )  {%NWL%newChildren = [ ] ;%NWL%for ( i = 0; i < len - 1; i + + )  {%NWL%newChildren . push ( this . children [ i ] ) ;%NWL%newChildren . push ( aSep ) ;%NWL%newChildren . push ( this . children [ i ] ) ;%NWL%8
else if ( typeof lastChild === ' string ' )  {%NWL%this . children [ this . children . length - 1 ] = lastChild . replace ( aPattern , aReplacement ) ;%NWL%}%NWL%else {%NWL%this . children . push ( ' ' . replace ( aPattern , aReplacement ) ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%%NWL%SourceNode . prototype . setSourceContent =%NWL%this . sourceContents [ util . toSetString ( aSourceFile ) ] = aSourceContent;%NWL%1
line: generated . line ,%NWL%column: generated . column%NWL%}%NWL%} ) ;%NWL%sourceMappingActive = false;%NWL%}%NWL%chunk . split ( ' ' ) . forEach ( function ( ch )  {%NWL%if ( ch === ' \n ' )  {%NWL%generated . line + + ;%NWL%generated . column = 0;%NWL%generated . column + + ;%NWL%8
#! / usr / bin / env node%NWL%var assert = require ( ' assert ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%1
#! / usr / bin / env node%NWL%var assert = require ( ' assert ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var util = require ( ' . / source - map / util ' ) ;%NWL%1
var needle = 30;%NWL%var haystack = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] ;%NWL%assert . doesNotThrow ( function ( )  {%NWL%binarySearch . search ( needle , haystack , numberCompare ) ;%NWL%} ) ;%NWL%assert . equal ( binarySearch . search ( needle , haystack , numberCompare ) , 20 ) ;%NWL%} ;%NWL%exports [ ' test too low ' ] = function ( assert , util )  {%NWL%var needle = 1;%NWL%var haystack = [ 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 , 18 , 20 ] ;%NWL%binarySearch . search ( needle , haystack , numberCompare ) ;%NWL%3
node . prepend ( function ( )  { } ) ;%NWL%} ) ;%NWL%} ;%NWL%exports [ ' test . toString ( ) ' ] = function ( assert , util )  {%NWL%assert . equal ( ( new SourceNode ( null , null , null ,%NWL%[ ' function foo ( )  { ' ,%NWL%new SourceNode ( null , null , null ,  ' return 10; ' ) ,%NWL%' } ' ] ) ) . toString ( ) ,%NWL%' function foo ( )  { return 10; } ' ) ;%NWL%} ;%NWL%assert . equal ( ( new SourceNode ( null , null , null ,%NWL%4
} ) ;%NWL%assert . equal ( actual . source ,  ' a . js ' ) ;%NWL%assert . equal ( actual . line , 1 ) ;%NWL%assert . equal ( actual . column , 0 ) ;%NWL%assert . equal ( actual . name ,  ' originalCall ' ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 3 ,%NWL%column: 2%NWL%} ) ;%NWL%assert . equal ( actual . source ,  ' b . js ' ) ;%NWL%assert . equal ( actual . column , 0 ) ;%NWL%3
actual = map . originalPositionFor ( {%NWL%line: 3 ,%NWL%column: 16%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 4 ,%NWL%column: 2%NWL%assert . equal ( actual . source , null ) ;%NWL%4
line: 3 ,%NWL%column: 16%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 4 ,%NWL%column: 2%NWL%} ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%4
column: 16%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . line , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%actual = map . originalPositionFor ( {%NWL%line: 4 ,%NWL%column: 2%NWL%} ) ;%NWL%assert . equal ( actual . source , null ) ;%NWL%assert . equal ( actual . column , null ) ;%NWL%4
function assertEqualMaps ( assert , actualMap , expectedMap )  {%NWL%assert . equal ( actualMap . version , expectedMap . version ,  " version mismatch " ) ;%NWL%assert . equal ( actualMap . file , expectedMap . file ,  " file mismatch " ) ;%NWL%assert . equal ( actualMap . names . length ,%NWL%expectedMap . names . length ,%NWL%" names length mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . names . length; i + + )  {%NWL%assert . equal ( actualMap . names [ i ] ,%NWL%expectedMap . names [ i ] ,%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%6
assert . equal ( actualMap . names . length ,%NWL%expectedMap . names . length ,%NWL%" names length mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . names . length; i + + )  {%NWL%assert . equal ( actualMap . names [ i ] ,%NWL%expectedMap . names [ i ] ,%NWL%" names [ "  + i +  " ] mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%}%NWL%expectedMap . sources . length ,%NWL%1
assert . equal ( actualMap . names [ i ] ,%NWL%expectedMap . names [ i ] ,%NWL%" names [ "  + i +  " ] mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%}%NWL%assert . equal ( actualMap . sources . length ,%NWL%expectedMap . sources . length ,%NWL%" sources length mismatch: "  +%NWL%actualMap . sources . join ( " ,  " )  +  " != "  + expectedMap . sources . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . sources . length; i + + )  {%NWL%expectedMap . sources [ i ] ,%NWL%1
" names [ "  + i +  " ] mismatch: "  +%NWL%actualMap . names . join ( " ,  " )  +  " != "  + expectedMap . names . join ( " ,  " ) ) ;%NWL%}%NWL%assert . equal ( actualMap . sources . length ,%NWL%expectedMap . sources . length ,%NWL%" sources length mismatch: "  +%NWL%actualMap . sources . join ( " ,  " )  +  " != "  + expectedMap . sources . join ( " ,  " ) ) ;%NWL%for ( var i = 0; i < actualMap . sources . length; i + + )  {%NWL%assert . equal ( actualMap . sources [ i ] ,%NWL%expectedMap . sources [ i ] ,%NWL%actualMap . sources . join ( " ,  " )  +  " != "  + expectedMap . sources . join ( " ,  " ) ) ;%NWL%6
var requirejs = require ( ' requirejs ' ) ;%NWL%var sanitizer = require ( ' sanitizer ' ) ;%NWL%0
this_client_instance . stagecraftUrlRoot = req . app . get ( ' stagecraftUrl ' )  +  ' / public / dashboards ' ;%NWL%return this_client_instance;%NWL%} ;%NWL%var get_dashboard_and_render = function ( req , res , renderContent )  {%NWL%var client_instance = get_dashboard_and_render . buildStagecraftApiClient ( req ) ;%NWL%client_instance . on ( ' error ' , function ( )  {%NWL%client_instance . off ( ) ;%NWL%res . status ( client_instance . get ( ' status ' ) ) ;%NWL%renderContent ( req , res , client_instance ) ;%NWL%} ) ;%NWL%client_instance . off ( ) ;%NWL%6
return this_client_instance;%NWL%} ;%NWL%var get_dashboard_and_render = function ( req , res , renderContent )  {%NWL%var client_instance = get_dashboard_and_render . buildStagecraftApiClient ( req ) ;%NWL%client_instance . on ( ' error ' , function ( )  {%NWL%client_instance . off ( ) ;%NWL%res . status ( client_instance . get ( ' status ' ) ) ;%NWL%renderContent ( req , res , client_instance ) ;%NWL%} ) ;%NWL%client_instance . on ( ' sync ' , function ( )  {%NWL%res . status ( client_instance . get ( ' status ' ) ) ;%NWL%6
#! / usr / bin / env node%NWL%var U = require ( " . . / tools / node " ) ;%NWL%var path = require ( " path " ) ;%NWL%var assert = require ( " assert " ) ;%NWL%2
var dir = test_directory ( " compress " ) ;%NWL%log_directory ( " compress " ) ;%NWL%var files = find_test_files ( dir ) ;%NWL%function test_file ( file )  {%NWL%log_start_file ( file ) ;%NWL%function test_case ( test )  {%NWL%log_test ( test . name ) ;%NWL%var options = U . defaults ( test . options ,  {%NWL%warnings: false%NWL%} ) ;%NWL%var expect = make_code ( as_toplevel ( test . expect ) , false ) ;%NWL%7
log_directory ( " compress " ) ;%NWL%var files = find_test_files ( dir ) ;%NWL%function test_file ( file )  {%NWL%log_start_file ( file ) ;%NWL%function test_case ( test )  {%NWL%log_test ( test . name ) ;%NWL%var options = U . defaults ( test . options ,  {%NWL%warnings: false%NWL%} ) ;%NWL%var cmp = new U . Compressor ( options , true ) ;%NWL%var input = as_toplevel ( test . input ) ;%NWL%6
options = { if_return: true , conditionals: true , dead_code: true } ;%NWL%input: {%NWL%out: {%NWL%if ( foo ) print ( " stuff " ) ;%NWL%else break out;%NWL%console . log ( " here " ) ;%NWL%}%NWL%} ;%NWL%expect: {%NWL%if ( foo )  {%NWL%console . log ( " here " ) ;%NWL%5
}%NWL%}%NWL%labels_5: {%NWL%options = { if_return: true , conditionals: true , dead_code: true } ;%NWL%input: {%NWL%while ( foo )  {%NWL%if ( bar ) break;%NWL%console . log ( " foo " ) ;%NWL%}%NWL%out: while ( foo )  {%NWL%console . log ( " foo " ) ;%NWL%7
if ( bar ) break;%NWL%console . log ( " foo " ) ;%NWL%}%NWL%out: while ( foo )  {%NWL%if ( bar ) break out;%NWL%console . log ( " foo " ) ;%NWL%}%NWL%} ;%NWL%expect: {%NWL%while ( foo )  {%NWL%console . log ( " foo " ) ;%NWL%1
if ( bar ) break out;%NWL%console . log ( " foo " ) ;%NWL%}%NWL%} ;%NWL%expect: {%NWL%while ( foo )  {%NWL%if ( bar ) break;%NWL%console . log ( " foo " ) ;%NWL%}%NWL%out: while ( foo )  {%NWL%console . log ( " foo " ) ;%NWL%1
var path = require ( " path " ) ;%NWL%var vm = require ( " vm " ) ;%NWL%0
toplevel: toplevel%NWL%} ) ;%NWL%} ) ;%NWL%if ( options . compress )  {%NWL%var compress = { warnings: options . warnings } ;%NWL%UglifyJS . merge ( compress , options . compress ) ;%NWL%toplevel . figure_out_scope ( ) ;%NWL%var sq = UglifyJS . Compressor ( compress ) ;%NWL%toplevel = toplevel . transform ( sq ) ;%NWL%}%NWL%toplevel . figure_out_scope ( ) ;%NWL%6
} ) ;%NWL%} ) ;%NWL%if ( options . compress )  {%NWL%var compress = { warnings: options . warnings } ;%NWL%UglifyJS . merge ( compress , options . compress ) ;%NWL%toplevel . figure_out_scope ( ) ;%NWL%var sq = UglifyJS . Compressor ( compress ) ;%NWL%toplevel = toplevel . transform ( sq ) ;%NWL%}%NWL%if ( options . mangle )  {%NWL%toplevel . compute_char_frequency ( ) ;%NWL%5
} ) ;%NWL%if ( props . length > 0 )  {%NWL%out . space ( ) ;%NWL%out . with_parens ( function ( ) {%NWL%props . forEach ( function ( prop , i ) {%NWL%if ( i ) out . space ( ) ;%NWL%out . print ( prop ) ;%NWL%} ) ;%NWL%} ) ;%NWL%}%NWL%out . space ( ) ;%NWL%2
props . forEach ( function ( prop , i ) {%NWL%if ( i ) out . space ( ) ;%NWL%out . print ( prop ) ;%NWL%} ) ;%NWL%} ) ;%NWL%}%NWL%if ( ctor . documentation )  {%NWL%out . space ( ) ;%NWL%out . print_string ( ctor . documentation ) ;%NWL%}%NWL%out . space ( ) ;%NWL%7
} ) ;%NWL%} ) ;%NWL%}%NWL%if ( ctor . documentation )  {%NWL%out . space ( ) ;%NWL%out . print_string ( ctor . documentation ) ;%NWL%}%NWL%if ( ctor . SUBCLASSES . length > 0 )  {%NWL%out . space ( ) ;%NWL%out . with_block ( function ( ) {%NWL%out . indent ( ) ;%NWL%4
}%NWL%if ( ctor . documentation )  {%NWL%out . space ( ) ;%NWL%out . print_string ( ctor . documentation ) ;%NWL%}%NWL%if ( ctor . SUBCLASSES . length > 0 )  {%NWL%out . space ( ) ;%NWL%out . with_block ( function ( ) {%NWL%ctor . SUBCLASSES . forEach ( function ( ctor , i ) {%NWL%out . indent ( ) ;%NWL%out . newline ( ) ;%NWL%2
t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' chmod ' , function ( t )  {%NWL%var mode = 0755%NWL%mkdirp ( file , mode , function ( er )  {%NWL%t . ifError ( er ,  ' should not error ' ) ;%NWL%fs . stat ( file , function ( er , stat )  {%NWL%t . ifError ( er ,  ' should exist ' ) ;%NWL%t . end ( ) ;%NWL%0
t . equal ( stat . mode & 0777 , 0755 ) ;%NWL%t . ok ( stat . isDirectory ( ) ,  ' target not a directory ' ) ;%NWL%t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%t . end ( ) ;%NWL%2
t . end ( ) ;%NWL%}%NWL%} )%NWL%} )%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' async root perm ' , function ( t )  {%NWL%mkdirp ( ' / tmp ' , 0755 , function ( err )  {%NWL%if ( err ) t . fail ( err ) ;%NWL%t . end ( ) ;%NWL%t . end ( ) ;%NWL%0
var mkdirp = require ( ' . . / ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%test ( ' rel ' , function ( t )  {%NWL%t . plan ( 2 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var cwd = process . cwd ( ) ;%NWL%1
var test = require ( ' tap ' ) . test;%NWL%test ( ' return value ' , function ( t )  {%NWL%t . plan ( 4 ) ;%NWL%var x = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var y = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var z = Math . floor ( Math . random ( )  * Math . pow ( 16 , 4 ) ) . toString ( 16 ) ;%NWL%var file = ' / tmp / '  +  [ x , y , z ] . join ( ' / ' ) ;%NWL%mkdirp ( file , function ( err , made )  {%NWL%t . ifError ( err ) ;%NWL%t . equal ( made ,  ' / tmp / '  + x ) ;%NWL%t . ifError ( err ) ;%NWL%8
, h: [ " - - help " ]%NWL%, H: [ " - - help " ]%NWL%, n: [  " - - num " ,  " 125 "  ]  }%NWL%, parsed = nopt ( types%NWL%, shorthands%NWL%, process . argv%NWL%, 2 )%NWL%console . log ( " parsed " , parsed )%NWL%if ( parsed . help )  {%NWL%console . log ( " " )%NWL%console . log ( " " )%NWL%9
, rem = test [ 2 ]%NWL%, actual = nopt ( types , shorthands , argv , 0 )%NWL%, parsed = actual . argv%NWL%delete actual . argv%NWL%console . log ( util . inspect ( actual , false , 2 , true ) , parsed . remain )%NWL%for ( var i in opts )  {%NWL%var e = JSON . stringify ( opts [ i ] )%NWL%, a = JSON . stringify ( actual [ i ] === undefined ? null : actual [ i ] )%NWL%if ( e && typeof e === " object " )  {%NWL%assert . deepEqual ( e , a )%NWL%assert . equal ( e , a )%NWL%9
chunk . split ( / \n / ) . forEach ( function ( c )  {%NWL%lines . push (%NWL%new Array ( start + 1 ) . join ( '  ' )%NWL%+ c . replace ( / ^\s + / ,  ' ' )%NWL%) ;%NWL%} ) ;%NWL%}%NWL%else if ( chunk . match ( / \n / ) )  {%NWL%var xs = chunk . split ( / \n / ) ;%NWL%lines [ i ]  + = xs . shift ( ) ;%NWL%lines . push (%NWL%1
var assert = require ( ' assert ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%0
var assert = require ( ' assert ' ) ;%NWL%var wordwrap = require ( ' wordwrap ' ) ;%NWL%var idleness = fs . readFileSync ( __dirname +  ' / idleness . txt ' ,  ' utf8 ' ) ;%NWL%0
env [ key ] = envVars [ key ] ;%NWL%} ) ;%NWL%handle = cp . spawn ( cmd , args ,  { env: env , cwd: OPTS . cwd || DEFAULT_CWD } ) ;%NWL%handle . stdout . setEncoding ( ' utf8 ' ) ;%NWL%handle . stderr . setEncoding ( ' utf8 ' ) ;%NWL%handle . stdout . on ( ' data ' , function ( data )  {%NWL%out + = data;%NWL%process . stdout . write ( data ) ;%NWL%} ) ;%NWL%handle . stderr . on ( ' data ' , function ( data )  {%NWL%process . stderr . write ( data ) ;%NWL%7
includes: [  ' * * instrumenter . js '  ] ,%NWL%relative: true%NWL%} , function ( err , files )  {%NWL%filesToInstrument = files;%NWL%cb ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should produce identical instrumentation results when instrumentation run on browser v / s nodejs " : function ( test )  {%NWL%if ( !phantom )  {%NWL%console . error ( ' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ' ) ;%NWL%console . error ( ' * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ' ) ;%NWL%9
test . ok ( false , err . message || err ) ;%NWL%}%NWL%}%NWL%finalFn ( ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%runPhantom ( phantom , path . resolve ( __dirname ,  ' support ' ,  ' phantom - test . client . js ' ) , port , filesToInstrument ) ;%NWL%} catch ( ex )  {%NWL%console . error ( ex . message || ex ) ;%NWL%console . error ( ex . stack ) ;%NWL%test . done ( ) ;%NWL%4
server;%NWL%function handleInitialPage ( request , response )  {%NWL%response . setHeader ( ' content - type ' ,  ' text / html ' ) ;%NWL%var template = templateFor ( ' index . html ' ) ;%NWL%response . end ( template ( { demo: server . demo ? ' yes ' : ' '  } ) ) ;%NWL%}%NWL%function handleEsprima ( request , response )  {%NWL%response . setHeader ( ' content - type ' ,  ' application / javascript ' ) ;%NWL%response . end ( esprimaSource ,  ' utf8 ' ) ;%NWL%}%NWL%response . setHeader ( ' content - type ' ,  ' application / javascript ' ) ;%NWL%7
response . end ( template ( { demo: server . demo ? ' yes ' : ' '  } ) ) ;%NWL%}%NWL%function handleEsprima ( request , response )  {%NWL%response . setHeader ( ' content - type ' ,  ' application / javascript ' ) ;%NWL%response . end ( esprimaSource ,  ' utf8 ' ) ;%NWL%}%NWL%function handleEscodegen ( request , response )  {%NWL%response . setHeader ( ' content - type ' ,  ' application / javascript ' ) ;%NWL%response . end ( escodegenSource ,  ' utf8 ' ) ;%NWL%}%NWL%response . setHeader ( ' content - type ' ,  ' application / javascript ' ) ;%NWL%3
cb ( ) ;%NWL%} ,%NWL%" should provide helpful errors when nothing passed " : function ( test )  {%NWL%helper . runCommand ( null ,  [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should provide helpful errors when only flags passed in " : function ( test )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%4
} ,%NWL%" should provide helpful errors when nothing passed " : function ( test )  {%NWL%helper . runCommand ( null ,  [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should provide helpful errors when only flags passed in " : function ( test )  {%NWL%helper . runCommand ( null ,  [  ' - v ' ,  ' - x '  ] , function ( results )  {%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%4
" should provide helpful errors when nothing passed " : function ( test )  {%NWL%helper . runCommand ( null ,  [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should provide helpful errors when only flags passed in " : function ( test )  {%NWL%helper . runCommand ( null ,  [  ' - v ' ,  ' - x '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%4
} ) ;%NWL%} ,%NWL%" should provide helpful errors when only flags passed in " : function ( test )  {%NWL%helper . runCommand ( null ,  [  ' - v ' ,  ' - x '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should provide a good message on an invalid command " : function ( test )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%4
" should provide helpful errors when only flags passed in " : function ( test )  {%NWL%helper . runCommand ( null ,  [  ' - v ' ,  ' - x '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should provide a good message on an invalid command " : function ( test )  {%NWL%helper . runCommand ( ' instrumentation ' ,  [  ' - - root ' ,  ' a / nonexistent / path '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%3
helper . runCommand ( null ,  [  ' - v ' ,  ' - x '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should provide a good message on an invalid command " : function ( test )  {%NWL%helper . runCommand ( ' instrumentation ' ,  [  ' - - root ' ,  ' a / nonexistent / path '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Invalid command \ [ instrumentation\ ] , allowed values / ) ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%" should provide a good message on an invalid command " : function ( test )  {%NWL%helper . runCommand ( ' instrumentation ' ,  [  ' - - root ' ,  ' a / nonexistent / path '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Invalid command \ [ instrumentation\ ] , allowed values / ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should print a stack trace on uncaught exception " : function ( test )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%3
test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Invalid command \ [ instrumentation\ ] , allowed values / ) ) ;%NWL%test . ok ( results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should print a stack trace on uncaught exception " : function ( test )  {%NWL%helper . runCommand ( ' instrument ' ,  [  ' - - root ' ,  ' a / nonexistent / path '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( !results . grepError ( / Try " istanbul help " for usage / ) ) ;%NWL%test . done ( ) ;%NWL%3
runCover = helper . runCommand . bind ( null , COVER_COMMAND ) ;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%runCover ( [  ' test / run . js ' ,  ' - - report ' ,  ' none '  ] , function ( results )  {%NWL%cb ( ) ;%NWL%} ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%3
cb ( ) ;%NWL%} ,%NWL%" should fail on inadequate statement coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for statements / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%3
" should fail on inadequate statement coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for statements / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail on inadequate branch coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%3
run ( [  ' - - statements ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for statements / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail on inadequate branch coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - branches ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%3
} ) ;%NWL%} ,%NWL%" should fail on inadequate branch coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - branches ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for branches / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%3
" should fail on inadequate branch coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - branches ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for branches / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail on inadequate function coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%3
run ( [  ' - - branches ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for branches / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail on inadequate function coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - functions ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%3
} ) ;%NWL%} ,%NWL%" should fail on inadequate function coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - functions ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for functions / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%3
" should fail on inadequate function coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - functions ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for functions / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail on inadequate line coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%3
run ( [  ' - - functions ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for functions / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail on inadequate line coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - lines ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%3
} ) ;%NWL%} ,%NWL%" should fail on inadequate line coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - lines ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for lines / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%3
" should fail on inadequate line coverage " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - lines ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for lines / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail with multiple reasons when multiple thresholds violated " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%3
test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - lines ' ,  ' 72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for lines / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail with multiple reasons when multiple thresholds violated " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements=72 ' , ' - - functions=50 ' , ' - - branches=72 ' , ' - - lines=72 '  ] , function ( results )  {%NWL%test . ok ( results . grepError ( / Coverage for lines / ) ) ;%NWL%3
test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should fail with multiple reasons when multiple thresholds violated " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements=72 ' , ' - - functions=50 ' , ' - - branches=72 ' , ' - - lines=72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for lines / ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for statements / ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for branches / ) ) ;%NWL%test . done ( ) ;%NWL%0
test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements=72 ' , ' - - functions=50 ' , ' - - branches=72 ' , ' - - lines=72 '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for lines / ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for statements / ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for branches / ) ) ;%NWL%test . ok ( !results . grepError ( / Coverage for functions / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%0
test . ok ( results . grepError ( / Coverage for statements / ) ) ;%NWL%test . ok ( results . grepError ( / Coverage for branches / ) ) ;%NWL%test . ok ( !results . grepError ( / Coverage for functions / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should pass with multiple reasons when all thresholds in check " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements=60 ' , ' - - functions=50 ' , ' - - branches=50 ' , ' - - lines=60 ' ,  ' - v '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%3
} ) ;%NWL%} ,%NWL%" should pass with multiple reasons when all thresholds in check " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements=60 ' , ' - - functions=50 ' , ' - - branches=50 ' , ' - - lines=60 ' ,  ' - v '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !results . grepOutput ( / \\ " actuals\\ " / ) ,  " Verbose message not printed as expected " ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%3
" should pass with multiple reasons when all thresholds in check " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements=60 ' , ' - - functions=50 ' , ' - - branches=50 ' , ' - - lines=60 ' ,  ' - v '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !results . grepOutput ( / \\ " actuals\\ " / ) ,  " Verbose message not printed as expected " ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should succeed with any threshold when no coverage found " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%3
test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements=60 ' , ' - - functions=50 ' , ' - - branches=50 ' , ' - - lines=60 ' ,  ' - v '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !results . grepOutput ( / \\ " actuals\\ " / ) ,  " Verbose message not printed as expected " ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should succeed with any threshold when no coverage found " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - statements ' ,  ' 72 ' ,  ' * * / foobar . json '  ] , function ( results )  {%NWL%test . done ( ) ;%NWL%4
cov;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%runCover ( [  ' test / run . js ' ,  ' - - report ' ,  ' none '  ] , function ( results )  {%NWL%cb ( ) ;%NWL%} ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%3
collector . add ( obj ) ;%NWL%reporter . writeReport ( collector , true ) ;%NWL%test . ok ( existsSync ( reportFile ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should produce coverage . xml at cwd when no options specified " : function ( test )  {%NWL%var file = path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ,%NWL%reportFile = path . resolve ( ' cobertura - coverage . xml ' ) ,%NWL%reporter = new Reporter ( ) ,%NWL%collector = new Collector ( ) ;%NWL%reporter . writeReport ( collector , true ) ;%NWL%1
reporter . writeReport ( collector , true ) ;%NWL%test . ok ( existsSync ( reportFile ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should produce coverage . xml at cwd when no options specified " : function ( test )  {%NWL%var file = path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ,%NWL%reportFile = path . resolve ( ' cobertura - coverage . xml ' ) ,%NWL%reporter = new Reporter ( ) ,%NWL%collector = new Collector ( ) ;%NWL%collector . add ( JSON . parse ( fs . readFileSync ( file ,  ' utf8 ' ) ) ) ;%NWL%test . ok ( existsSync ( reportFile ) ) ;%NWL%1
test . done ( ) ;%NWL%} ,%NWL%" should produce coverage . xml at cwd when no options specified " : function ( test )  {%NWL%var file = path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ,%NWL%reportFile = path . resolve ( ' cobertura - coverage . xml ' ) ,%NWL%reporter = new Reporter ( ) ,%NWL%collector = new Collector ( ) ;%NWL%collector . add ( JSON . parse ( fs . readFileSync ( file ,  ' utf8 ' ) ) ) ;%NWL%reporter . writeReport ( collector , true ) ;%NWL%test . ok ( existsSync ( reportFile ) ) ;%NWL%test . done ( ) ;%NWL%0
helper = require ( ' . . / cli - helper ' ) ,%NWL%existsSync = fs . existsSync || path . existsSync ,%NWL%run = helper . runCommand . bind ( null , COMMAND ) ;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%5
test . ok ( filtered . length === 0 ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should skip reporting when requested " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%run ( [  ' test / run . js ' ,  ' - - report ' ,  ' none ' ,  ' - - print ' ,  ' detail '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . done ( ) ;%NWL%1
run ( [  ' test / run . js ' ,  ' - - report ' ,  ' none ' ,  ' - - print ' ,  ' detail '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should use non - default report format when requested " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%1
test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should use non - default report format when requested " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%run ( [  ' test / run . js ' ,  ' - - report ' ,  ' lcovonly '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%1
test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should use non - default report format when requested " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%run ( [  ' test / run . js ' ,  ' - - report ' ,  ' lcovonly '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%1
test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should use non - default report format when requested " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%run ( [  ' test / run . js ' ,  ' - - report ' ,  ' lcovonly '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . done ( ) ;%NWL%1
run ( [  ' test / run . js ' ,  ' - - report ' ,  ' lcovonly '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should cover nothing when everything excluded " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%1
test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should cover nothing when everything excluded " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%run ( [  ' test / run . js ' ,  ' - x ' ,  ' * * / * . js '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%1
test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should cover nothing when everything excluded " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%run ( [  ' test / run . js ' ,  ' - x ' ,  ' * * / * . js '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . done ( ) ;%NWL%1
run ( [  ' test / run . js ' ,  ' - x ' ,  ' * * / * . js '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should cover everything under the sun when default excludes are suppressed " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%1
var coverage = JSON . parse ( fs . readFileSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ,  ' utf8 ' ) ) ,%NWL%filtered;%NWL%filtered = Object . keys ( coverage ) . filter ( function ( k )  { return k . match ( / node_modules / ) ; } ) ;%NWL%test . ok ( filtered . length === 1 ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf when no file is provided " : function ( test )  {%NWL%run ( [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%4
} ) ;%NWL%} ,%NWL%" should barf when no file is provided " : function ( test )  {%NWL%run ( [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Need a filename argument for the cover command / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on invalid command " : function ( test )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%4
" should barf when no file is provided " : function ( test )  {%NWL%run ( [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Need a filename argument for the cover command / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on invalid command " : function ( test )  {%NWL%run ( [  ' foobar '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%4
cov;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%runCover ( [  ' test / run . js ' ,  ' - - report ' ,  ' none '  ] , function ( results )  {%NWL%cb ( ) ;%NWL%} ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%3
test . ok ( existsSync ( fileFor ( ' lib ' ,  ' index . html ' ) ) ) ;%NWL%test . ok ( existsSync ( fileFor ( ' lib ' ,  ' util ' ,  ' index . html ' ) ) ) ;%NWL%test . ok ( existsSync ( fileFor ( ' lib ' ,  ' foo . js . html ' ) ) ) ;%NWL%test . ok ( existsSync ( fileFor ( ' lib ' ,  ' bar . js . html ' ) ) ) ;%NWL%test . ok ( existsSync ( fileFor ( ' lib ' ,  ' util ' ,  ' generate - names . js . html ' ) ) ) ;%NWL%test . ok ( fs . readFileSync ( fileFor ( ' lib ' ,  ' bar . js . html ' ) ,  ' utf8 ' ) !== ' ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" test contents " : function ( test )  {%NWL%console . error ( ' Figure out a way to run meaningful tests for HTML report contents ' ) ;%NWL%test . done ( ) ;%NWL%6
helper = require ( ' . . / cli - helper ' ) ,%NWL%existsSync = fs . existsSync || path . existsSync ,%NWL%run = helper . runCommand . bind ( null , COMMAND ) ;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%5
" should work with default options for a single file " : function ( test )  {%NWL%run ( [  ' lib / foo . js '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . doesNotThrow ( function ( )  {%NWL%vm . createScript ( results . stdout ( ) . join ( ' \n ' ) , path . resolve ( DIR ,  ' lib ' ,  ' foo . js ' ) ) ;%NWL%} ,  " Invalid code generated; logging interference perhaps? " ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should work with compact as default " : function ( test )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%2
} ,  " Invalid code generated; logging interference perhaps? " ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should work with compact as default " : function ( test )  {%NWL%run ( [  ' lib / foo . js '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%var compact = results . stdout ( ) . join ( ' \n ' ) ;%NWL%run ( [  ' lib / foo . js ' ,  ' - - no - compact '  ] , function ( results2 )  {%NWL%var full = results2 . stdout ( ) . join ( ' \n ' ) ;%NWL%test . done ( ) ;%NWL%1
test . ok ( results . succeeded ( ) ) ;%NWL%var compact = results . stdout ( ) . join ( ' \n ' ) ;%NWL%run ( [  ' lib / foo . js ' ,  ' - - no - compact '  ] , function ( results2 )  {%NWL%var full = results2 . stdout ( ) . join ( ' \n ' ) ;%NWL%test . ok ( full . length > compact . length ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ,%NWL%" should work with explicit output option for a single file " : function ( test )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%0
test . ok ( full . length > compact . length ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%} ,%NWL%" should work with explicit output option for a single file " : function ( test )  {%NWL%run ( [  ' lib / foo . js ' ,  ' - - output ' , path . resolve ( OUTPUT_DIR ,  ' foo . js ' )  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . doesNotThrow ( function ( )  {%NWL%vm . createScript ( fs . readFileSync ( path . resolve ( OUTPUT_DIR ,  ' foo . js ' ) ,  ' utf8 ' ) , path . resolve ( DIR ,  ' lib ' ,  ' foo . js ' ) ) ;%NWL%test . done ( ) ;%NWL%1
" should work with explicit output option for a single file " : function ( test )  {%NWL%run ( [  ' lib / foo . js ' ,  ' - - output ' , path . resolve ( OUTPUT_DIR ,  ' foo . js ' )  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . doesNotThrow ( function ( )  {%NWL%vm . createScript ( fs . readFileSync ( path . resolve ( OUTPUT_DIR ,  ' foo . js ' ) ,  ' utf8 ' ) , path . resolve ( DIR ,  ' lib ' ,  ' foo . js ' ) ) ;%NWL%} ,  " Invalid code generated; logging interference perhaps? " ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should instrument multiple files " : function ( test )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%2
test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' util ' ,  ' generate - names . js ' ) ) ) ;%NWL%test . ok ( !results . grepOutput ( / Processed: foo\ . js / ) ) ;%NWL%test . ok ( results . grepOutput ( / Processed \ [ \d + \ ] files in / ) ) ;%NWL%test . ok ( !results . grepOutput ( / The following 1 file\ ( s\ ) had errors and were copied as - is / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on no args " : function ( test )  {%NWL%run ( [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%4
} ) ;%NWL%} ,%NWL%" should barf on no args " : function ( test )  {%NWL%run ( [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Need exactly one filename\ / dirname argument / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on directory coverage when output option is not provided " : function ( test )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%4
" should barf on no args " : function ( test )  {%NWL%run ( [ ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Need exactly one filename\ / dirname argument / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on directory coverage when output option is not provided " : function ( test )  {%NWL%run ( [  ' lib ' ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%4
} ) ;%NWL%} ,%NWL%" should barf on directory coverage when output option is not provided " : function ( test )  {%NWL%run ( [  ' lib ' ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Need an output directory / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on directory coverage when output === input " : function ( test )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%4
" should barf on directory coverage when output option is not provided " : function ( test )  {%NWL%run ( [  ' lib ' ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( results . grepError ( / Need an output directory / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on directory coverage when output === input " : function ( test )  {%NWL%run ( [  ' lib ' ,  ' - - output ' ,  ' lib ' ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . done ( ) ;%NWL%4
cov;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%runCover ( [  ' test / run . js ' ,  ' - - report ' ,  ' none '  ] , function ( results )  {%NWL%cb ( ) ;%NWL%} ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%3
cov;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%runCover ( [  ' test / run . js ' ,  ' - - report ' ,  ' none '  ] , function ( results )  {%NWL%cb ( ) ;%NWL%} ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%3
test . done ( ) ;%NWL%} ,%NWL%" should produce lcov . info at cwd when no options specified " : function ( test )  {%NWL%var file = path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ,%NWL%lcovFile = path . resolve ( ' lcov . info ' ) ,%NWL%reporter = new Reporter ( ) ,%NWL%collector = new Collector ( ) ;%NWL%collector . add ( JSON . parse ( fs . readFileSync ( file ,  ' utf8 ' ) ) ) ;%NWL%reporter . writeReport ( collector , true ) ;%NWL%test . ok ( existsSync ( lcovFile ) ) ;%NWL%test . done ( ) ;%NWL%0
var Reporter = require ( ' . . / . . / lib / report / none ' ) ,%NWL%Report = require ( ' . . / . . / lib / report ' ) ;%NWL%module . exports = {%NWL%" should be a noop without any failures " : function ( test )  {%NWL%var reporter = new Reporter ( ) ;%NWL%test . doesNotThrow ( function ( )  { reporter . writeReport ( ) ; } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should throw when Base report class writeMethod called " : function ( test )  {%NWL%var r = new Report ( ) ;%NWL%test . done ( ) ;%NWL%6
runCover = helper . runCommand . bind ( null , COVER_COMMAND ) ;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%runCover ( [  ' test / run . js ' ,  ' - - report ' ,  ' none '  ] , function ( results )  {%NWL%cb ( ) ;%NWL%} ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%3
" should run reports consuming coverage file with lcov default " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [ ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( fs . readFileSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ,  ' utf8 ' ) !== ' ' ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%1
run ( [ ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( fs . readFileSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ,  ' utf8 ' ) !== ' ' ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should run reports with specific format " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%1
test . ok ( fs . readFileSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ,  ' utf8 ' ) !== ' ' ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should run reports with specific format " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [ ' - - report ' ,  ' html ' ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" should run reports with specific format " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [ ' - - report ' ,  ' html ' ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' index . html ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%2
run ( [ ' - - report ' ,  ' html ' ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' index . html ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on invalid format " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - report ' ,  ' gcov '  ] , function ( results )  {%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%2
test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' index . html ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should barf on invalid format " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - report ' ,  ' gcov '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . done ( ) ;%NWL%2
} ,%NWL%" should barf on invalid format " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - report ' ,  ' gcov '  ] , function ( results )  {%NWL%test . ok ( !results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( results . grepError ( / Invalid report format / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%2
test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( results . grepError ( / Invalid report format / ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should respect input pattern " : function ( test )  {%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%run ( [  ' - - report ' ,  ' lcovonly ' ,  ' * * / foobar . json '  ] , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . done ( ) ;%NWL%2
helper = require ( ' . . / cli - helper ' ) ,%NWL%existsSync = fs . existsSync || path . existsSync ,%NWL%run = helper . runCommand . bind ( null , COMMAND ) ;%NWL%module . exports = {%NWL%setUp: function ( cb )  {%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%mkdirp . sync ( OUTPUT_DIR ) ;%NWL%helper . resetOpts ( ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%rimraf . sync ( OUTPUT_DIR ) ;%NWL%5
run ( [  ' test / run . js '  ] ,  { npm_config_coverage: ' '  } , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should run coverage when npm coverage is enabled " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%1
test . ok ( !existsSync ( path . resolve ( OUTPUT_DIR ,  ' coverage . json ' ) ) ) ;%NWL%test . done ( ) ;%NWL%} ) ;%NWL%} ,%NWL%" should run coverage when npm coverage is enabled " : function ( test )  {%NWL%helper . setOpts ( { lazyHook : true } ) ;%NWL%run ( [  ' test / run . js '  ] ,  { npm_config_coverage: ' 1 '  } , function ( results )  {%NWL%test . ok ( results . succeeded ( ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov . info ' ) ) ) ;%NWL%test . ok ( existsSync ( path . resolve ( OUTPUT_DIR ,  ' lcov - report ' ) ) ) ;%NWL%test . done ( ) ;%NWL%1
' output = i; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should provide correct line coverage " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 ] , 10 ,  { lines: { 1: 1 , 2: 10 , 3: 1 } , branches: { } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 10 ,  ' 4 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover single - entry into while " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' output = i; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should provide correct line coverage " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 ] , 10 ,  { lines: { 1: 1 , 2: 1 , 3: 10 , 5: 1 } , branches: { } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 10 ,  ' 4 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover single - entry into while " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' output = x; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and one branch " : function ( test )  {%NWL%verifier . verify ( test ,  [  - 1 ] , false ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 0 ] } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line , both branches but return false " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover line and one branch " : function ( test )  {%NWL%verifier . verify ( test ,  [  - 1 ] , false ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 0 ] } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line , both branches but return false " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 ] , false ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 1 ] } , functions: { } , statements:  {  ' 1 ' : 1 ,  ' 2 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line , both branches and return true " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' output = x; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and one branch " : function ( test )  {%NWL%verifier . verify ( test ,  [  - 1 ] , false ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 0 , 0 ] } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line , both branches but return false " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover line and one branch " : function ( test )  {%NWL%verifier . verify ( test ,  [  - 1 ] , false ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 0 , 0 ] } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line , both branches but return false " : function ( test )  {%NWL%verifier . verify ( test ,  [ 9 ] , false ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 1 , 1 ] } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line , both branches and return true " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 10 ,  ' 4 ' : 1 }%NWL%} ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not cover loop at all " : function ( test )  {%NWL%verifier . verify ( test ,  [  - 1 ] ,  - 10 ,  {%NWL%lines: { 1: 1 , 2: 1 , 3: 0 , 4: 1 } ,%NWL%branches: { } ,%NWL%functions: { } ,%NWL%statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 }%NWL%test . done ( ) ;%NWL%2
statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 10 ,  ' 4 ' : 1 }%NWL%} ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not cover loop at all " : function ( test )  {%NWL%verifier . verify ( test ,  [  - 1 ] ,  - 10 ,  {%NWL%lines: { 1: 1 , 2: 1 , 3: 1 } ,%NWL%branches: { } ,%NWL%functions: { } ,%NWL%statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 }%NWL%test . done ( ) ;%NWL%2
' output = x < 5 ? foo ( ) : 15; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and function " : function ( test )  {%NWL%verifier . verify ( test ,  [ 2 ] , 42 ,  { lines: { 1: 1 , 2: 1 , 3: 1 , 5: 1 } , branches: { 1: [ 1 , 0 ]  } , functions: { 1: 1 } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not cover function " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' output = x < 5 ? ( function ( )  { return 42; } ( ) ) : 15; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and function " : function ( test )  {%NWL%verifier . verify ( test ,  [ 2 ] , 42 ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 0 ]  } , functions: { 1: 1 } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not cover function " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' : 15; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and function " : function ( test )  {%NWL%verifier . verify ( test ,  [ 2 ] , 42 ,  { lines: { 1: 1 , 2: 1 , 4: 1 } , branches: { 1: [ 1 , 0 ]  } , functions: { 1: 1 } , statements: { 1: 1 , 2: 1 , 3: 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not cover function " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
'  output = args [ 0 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( null ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 , 2: 1 , 3: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 , 2: 1 , 3: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' if ( args [ 0 ] > args [ 1 ] ) output = args [ 0 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' if ( args [ 0 ] > args [ 1 ] )  { output = args [ 0 ] ; } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
'  output = args [ 1 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( null ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 , 2: 1 , 4: 0 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 , 2: 1 , 4: 0 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' if ( args [ 0 ] > args [ 1 ] ) output = args [ 0 ] ; else output = args [ 1 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' if ( args [ 0 ] > args [ 1 ] )  { output = args [ 0 ] ; } else { output = args [ 1 ] ; } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' if ( args [ 0 ] > args [ 1 ] )  { output = args [ 0 ] ; } else output = args [ 1 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' if ( args [ 0 ] > args [ 1 ] ) output = args [ 0 ] ; else { output = args [ 1 ] ; } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 ] , 20 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover else path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' if ( args [ 0 ] > args [ 1 ] ) if ( args [ 1 ] > args [ 2 ] ) output = args [ 2 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover first else and nothing below " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 , 20 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover first else and nothing below " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 , 20 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 0 ] ,  ' 2 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then and second then " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' if ( args [ 0 ] > args [ 1 ] )  { if ( args [ 1 ] > args [ 2 ] )  { output = args [ 2 ] ; }  } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover first else and nothing below " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 , 20 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover first else and nothing below " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 , 20 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 0 ] ,  ' 2 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then and second then " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' if ( args [ 0 ] > args [ 1 ] ) if ( args [ 1 ] > args [ 2 ] ) output = args [ 2 ] ; else output = args [ 1 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover first else and nothing below " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 , 20 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 ,  ' 5 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover first else and nothing below " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 , 20 , 15 ] ,  - 1 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 ,  ' 5 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then " : function ( test )  {%NWL%verifier . verify ( test ,  [ 20 , 10 , 15 ] , 10 ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 0 ] ,  ' 2 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover first then and second then " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 0 , 8: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 0 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 0 , 8: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 0 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 1 , 8: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 1 , 8: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 2 , 3 , 1 ] , 2 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 1 , 5: 0 , 6: 0 , 8: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 1 , 0 ] ,  ' 3 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover uppermost then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
'   output = args [ 3 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 0 , 8: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 0 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 0 , 8: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 0 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 1 , 8: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 1 , 8: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 2 , 3 , 1 ] , 2 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 1 , 5: 0 , 6: 0 , 8: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 1 , 0 ] ,  ' 3 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover uppermost then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' if ( args [ 0 ] < args [ 1 ] ) output = args [ 0 ] ; else if ( args [ 1 ] < args [ 2 ] ) output = args [ 1 ] ; else if ( args [ 2 ] < args [ 3 ] ) output = args [ 2 ] ; else output = args [ 3 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 0 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 0 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 2 , 3 , 1 ] , 2 ,  { lines: { 1: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 1 , 0 ] ,  ' 3 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 0 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover uppermost then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
'   output = args [ 2 ] ; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover all else paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 2 , 1 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 0 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 1 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
} ,%NWL%" should cover one then path " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 3 , 1 , 2 ] , 1 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 0 , 5: 1 , 6: 1 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 0 , 1 ] ,  ' 3 ' : [ 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 1 ,  ' 7 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover upper then paths " : function ( test )  {%NWL%verifier . verify ( test ,  [ 4 , 2 , 3 , 1 ] , 2 ,  { lines: { 1: 1 , 2: 0 , 3: 1 , 4: 1 , 5: 0 , 6: 0 } , branches: {  ' 1 ' : [ 0 , 1 ] ,  ' 2 ' : [ 1 , 0 ] ,  ' 3 ' : [ 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 ,  ' 5 ' : 1 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover uppermost then paths " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' output = x; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and one branch " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 ] , 10 ,  { lines: { 1: 1 , 2: 1 } , branches: { 1: [ 1 , 0 ] } , functions: { } , statements: { 1: 1 , 2: 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line and other branch " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
" should have verification errors " : function ( test )  {%NWL%verifier . verifyError ( test ) ;%NWL%test . done ( ) ;%NWL%}%NWL%} ,%NWL%" with code that is not a string " : {%NWL%" should have verification errors " : function ( test )  {%NWL%test . throws ( function ( )  {%NWL%var instrumenter = new Instrumenter ( ) ;%NWL%instrumenter . instrumentSync ( { } ,  ' foo . js ' ) ;%NWL%test . done ( ) ;%NWL%2
' output = x; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and one branch " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 ] , 10 ,  { lines: { 2: 1 , 3: 1 } , branches: { 1: [ 1 , 0 ] } , functions: { } , statements: { 1: 1 , 2: 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line and other branch " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' output = x; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ,  { noAutoWrap: true } ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover line and one branch " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 ] , 10 ,  { lines: { 2: 1 , 3: 1 } , branches: { 1: [ 1 , 0 ] } , functions: { } , statements: { 1: 1 , 2: 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover line and other branch " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( null ) ;%NWL%} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " one " ,  { lines: { 1: 1 , 2: 1 , 3: 1 , 4: 0 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: { 1: 1 , 2: 1 , 3: 1 , 4: 1 , 5: 0 , 6: 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " one " ,  { lines: { 1: 1 , 2: 1 , 3: 1 , 4: 0 } , branches: {  ' 1 ' : [ 1 , 0 ]  } , functions: { } , statements: { 1: 1 , 2: 1 , 3: 1 , 4: 1 , 5: 0 , 6: 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 2 "  ] ,  " two " ,  { lines: { 1: 1 , 2: 1 , 3: 0 , 4: 1 } , branches: {  ' 1 ' : [ 0 , 1 ]  } , functions: { } , statements: { 1: 1 , 2: 1 , 3: 0 , 4: 0 , 5: 1 , 6: 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover unknown path " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( null ) ;%NWL%} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " one " ,  { lines: { 1: 1 , 2: 1 , 3: 1 , 4: 0 , 5: 0 } , branches: {  ' 1 ' : [ 1 , 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " one " ,  { lines: { 1: 1 , 2: 1 , 3: 1 , 4: 0 , 5: 0 } , branches: {  ' 1 ' : [ 1 , 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 2 "  ] ,  " two " ,  { lines: { 1: 1 , 2: 1 , 3: 0 , 4: 1 , 5: 0 } , branches: {  ' 1 ' : [ 0 , 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover unknown path " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( null ) ;%NWL%} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " one " ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " one " ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 0 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 2 "  ] ,  " two " ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 , 0 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 0 ,  ' 5 ' : 1 ,  ' 6 ' : 1 ,  ' 7 ' : 0 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover unknown path " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( null ) ;%NWL%} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " onetwothree " ,  { lines: { 1: 1 , 2: 1 , 3: 1 , 4: 1 , 5: 1 } , branches: {  ' 1 ' : [ 1 , 1 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " onetwothree " ,  { lines: { 1: 1 , 2: 1 , 3: 1 , 4: 1 , 5: 1 } , branches: {  ' 1 ' : [ 1 , 1 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 2 "  ] ,  " twothree " ,  { lines: { 1: 1 , 2: 1 , 3: 0 , 4: 1 , 5: 1 } , branches: {  ' 1 ' : [ 0 , 1 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 ,  ' 5 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover unknown path " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' } '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( null ) ;%NWL%} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " onetwothree " ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 1 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
} ,%NWL%" should cover one path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 1 "  ] ,  " onetwothree " ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 1 , 1 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 ,  ' 5 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover two path " : function ( test )  {%NWL%verifier . verify ( test ,  [  " 2 "  ] ,  " twothree " ,  { lines: { 1: 1 , 2: 1 } , branches: {  ' 1 ' : [ 0 , 1 , 1 ]  } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 0 ,  ' 4 ' : 1 ,  ' 5 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover unknown path " : function ( test )  {%NWL%test . done ( ) ;%NWL%3
' output = i; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover loop exactly once " : function ( test )  {%NWL%verifier . verify ( test ,  [ 1 ] , 1 ,  { lines: { 1: 1 , 2: 1 , 3: 1 } , branches: { } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should cover loop multiple times " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
' output = i; '%NWL%] ;%NWL%verifier = helper . verifier ( __filename , code ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" should cover loop one time " : function ( test )  {%NWL%verifier . verify ( test ,  [ 10 ] , 10 ,  { lines: { 1: 1 , 2: 1 , 3: 10 , 4: 1 } , branches: { } , functions: { } , statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 10 ,  ' 4 ' : 1 }  } ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not cover loop at all " : function ( test )  {%NWL%test . done ( ) ;%NWL%7
statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 10 ,  ' 5 ' : 10 ,  ' 6 ' : 19 ,  ' 7 ' : 19 ,  ' 8 ' : 9 }%NWL%} ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should provide line / branch coverage when nothing exercised " : function ( test )  {%NWL%verifier . verify ( test ,  [  - 1 ] , 0 ,  {%NWL%lines: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 } ,%NWL%branches: {  ' 1 ' : [ 0 , 0 ]  } ,%NWL%functions: { } ,%NWL%statements: {  ' 1 ' : 1 ,  ' 2 ' : 1 ,  ' 3 ' : 1 ,  ' 4 ' : 0 ,  ' 5 ' : 0 ,  ' 6 ' : 0 ,  ' 7 ' : 0 ,  ' 8 ' : 0 }%NWL%test . done ( ) ;%NWL%2
help . run ( [ ' foobar ' ,  ' foobar ' ,  ' foobar ' ] , handler ) ;%NWL%cmdList . forEach ( function ( name )  {%NWL%if ( name !== ' help ' )  {%NWL%help . run ( [ name ] , handler ) ;%NWL%}%NWL%} ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should throw on non - existent command " : function ( test )  {%NWL%test . throws ( function ( )  { Command . create ( ' nonexistent - command ' ) ; } ,%NWL%test . done ( ) ;%NWL%6
cb ( ) ;%NWL%} ,%NWL%tearDown: function ( cb )  {%NWL%writer = null;%NWL%if ( exists ( FOO ) )  { fs . unlinkSync ( FOO ) ; }%NWL%if ( exists ( BAR ) )  { fs . unlinkSync ( BAR ) ; }%NWL%cb ( ) ;%NWL%} ,%NWL%" should write file with a series of calls " : function ( test )  {%NWL%writer . start ( FOO ) ;%NWL%writer . end ( FOO ) ;%NWL%9
" should not allow end before start " : function ( test )  {%NWL%test . throws ( function ( )  {%NWL%writer . end ( ) ;%NWL%} ,  / Attempt to end a file without starting it / ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not allow start when started " : function ( test )  {%NWL%writer . start ( BAR ) ;%NWL%test . throws ( function ( )  {%NWL%writer . start ( FOO ) ;%NWL%test . done ( ) ;%NWL%4
var formatOption = require ( ' . . / . . / lib / util / help - formatter ' ) . formatOption ,%NWL%THRESHOLD = 20;%NWL%module . exports = {%NWL%" should format small option + text on a single line " : function ( test )  {%NWL%var formatted = formatOption ( ' - f ' ,  ' specify force override of defaults ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < 0 ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format small option + big text on multiple lines " : function ( test )  {%NWL%console . log ( formatted ) ;%NWL%5
module . exports = {%NWL%" should format small option + text on a single line " : function ( test )  {%NWL%var formatted = formatOption ( ' - f ' ,  ' specify force override of defaults ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < 0 ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format small option + big text on multiple lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - f ' ,  ' an option whose description should exceed the length of a line if we have done our job well ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . done ( ) ;%NWL%5
test . ok ( formatted . indexOf ( ' \n ' ) < 0 ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format small option + big text on multiple lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - f ' ,  ' an option whose description should exceed the length of a line if we have done our job well ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) > THRESHOLD ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format long option + small text on multiple lines " : function ( test )  {%NWL%console . log ( formatted ) ;%NWL%5
" should format small option + big text on multiple lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - f ' ,  ' an option whose description should exceed the length of a line if we have done our job well ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) > THRESHOLD ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format long option + small text on multiple lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - - [ no ] force ' ,  ' specify force override of defaults ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . done ( ) ;%NWL%4
test . done ( ) ;%NWL%} ,%NWL%" should format long option + small text on multiple lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - - [ no ] force ' ,  ' specify force override of defaults ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . ok ( formatted . lastIndexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format long option + big text on 3 lines " : function ( test )  {%NWL%console . log ( formatted ) ;%NWL%4
} ,%NWL%" should format long option + small text on multiple lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - - [ no ] force ' ,  ' specify force override of defaults ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . ok ( formatted . lastIndexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format long option + big text on 3 lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - - [ no ] force ' ,  ' an option whose description should exceed the length of a line if we have done our job well ' ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%4
var formatted = formatOption ( ' - - [ no ] force ' ,  ' specify force override of defaults ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . ok ( formatted . lastIndexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should format long option + big text on 3 lines " : function ( test )  {%NWL%var formatted = formatOption ( ' - - [ no ] force ' ,  ' an option whose description should exceed the length of a line if we have done our job well ' ) ;%NWL%console . log ( formatted ) ;%NWL%test . ok ( formatted . indexOf ( ' \n ' ) < THRESHOLD ) ;%NWL%test . done ( ) ;%NWL%4
} ,%NWL%" foo should be transformed " : function ( test )  {%NWL%var foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( foo . bar ) ;%NWL%test . equals ( ' bar ' , foo . bar ( ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" but baz should be skipped " : function ( test )  {%NWL%var foo = require ( ' . / data / baz ' ) ;%NWL%test . ok ( foo . baz ) ;%NWL%test . done ( ) ;%NWL%5
test . equals ( ' baz ' , foo . baz ( ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" postLoadHook should be called " : function ( test )  {%NWL%var called = null ,%NWL%opts = { postLoadHook: function ( file )  { called = file; } } ,%NWL%foo;%NWL%hook . unhookRequire ( ) ;%NWL%hook . hookRequire ( matcher , transformer , opts ) ;%NWL%foo = require ( ' . / data / foo ' ) ;%NWL%test . done ( ) ;%NWL%1
" postLoadHook should be called " : function ( test )  {%NWL%var called = null ,%NWL%opts = { postLoadHook: function ( file )  { called = file; } } ,%NWL%foo;%NWL%hook . unhookRequire ( ) ;%NWL%hook . hookRequire ( matcher , transformer , opts ) ;%NWL%foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( called . match ( / foo\ . js / ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%hook . unhookRequire ( ) ;%NWL%4
hook . hookRequire ( matcher , transformer , opts ) ;%NWL%foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( called . match ( / foo\ . js / ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" and cache should be un - and reloaded " : function ( test )  {%NWL%hook . unhookRequire ( ) ;%NWL%hook . hookRequire ( matcher , transformer2 ) ;%NWL%var foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( foo . blah ) ;%NWL%test . done ( ) ;%NWL%3
test . done ( ) ;%NWL%} ,%NWL%" and cache should be un - and reloaded " : function ( test )  {%NWL%hook . unhookRequire ( ) ;%NWL%hook . hookRequire ( matcher , transformer2 ) ;%NWL%var foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( foo . blah ) ;%NWL%test . equals ( ' blah ' , foo . blah ( ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%hook . unhookRequire ( ) ;%NWL%3
" and cache should be un - and reloaded " : function ( test )  {%NWL%hook . unhookRequire ( ) ;%NWL%hook . hookRequire ( matcher , transformer2 ) ;%NWL%var foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( foo . blah ) ;%NWL%test . equals ( ' blah ' , foo . blah ( ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" bad transformer should return original code " : function ( test )  {%NWL%hook . unhookRequire ( ) ;%NWL%var foo = require ( ' . / data / foo ' ) ;%NWL%3
var foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( foo . blah ) ;%NWL%test . equals ( ' blah ' , foo . blah ( ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" bad transformer should return original code " : function ( test )  {%NWL%hook . unhookRequire ( ) ;%NWL%hook . hookRequire ( matcher , badTransformer ) ;%NWL%var foo = require ( ' . / data / foo ' ) ;%NWL%test . ok ( foo . foo ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%" should be able to span hello " : function ( test )  {%NWL%it . insertAt ( 0 ,  ' <span class= " h " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <span class= " h " >hello< / span> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to span world " : function ( test )  {%NWL%it . insertAt ( 6 ,  ' <span class= " w " > ' ) ;%NWL%it . insertAt ( 11 ,  ' < / span> ' ) ;%NWL%test . done ( ) ;%NWL%5
it . insertAt ( 6 ,  ' <span class= " w " > ' ) ;%NWL%it . insertAt ( 11 ,  ' < / span> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' hello <span class= " w " >world< / span> ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to nest spans around hello ( improperly ) " : function ( test )  {%NWL%it . insertAt ( 0 ,  ' <span class= " h " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%it . insertAt ( 0 ,  ' <div class= " w " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / div> ' ) ;%NWL%test . done ( ) ;%NWL%3
} ,%NWL%" should be able to nest spans around hello ( improperly ) " : function ( test )  {%NWL%it . insertAt ( 0 ,  ' <span class= " h " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%it . insertAt ( 0 ,  ' <div class= " w " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <span class= " h " ><div class= " w " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to nest spans around hello ( properly ) " : function ( test )  {%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%3
it . insertAt ( 0 ,  ' <span class= " h " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%it . insertAt ( 0 ,  ' <div class= " w " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <span class= " h " ><div class= " w " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to nest spans around hello ( properly ) " : function ( test )  {%NWL%it . insertAt ( 0 ,  ' <span class= " w " > ' , true ) ;%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%it . insertAt ( 5 ,  ' < / div> ' ) ;%NWL%3
it . insertAt ( 0 ,  ' <div class= " w " > ' ) ;%NWL%it . insertAt ( 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <span class= " h " ><div class= " w " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to nest spans around hello ( properly ) " : function ( test )  {%NWL%it . insertAt ( 0 ,  ' <span class= " w " > ' , true ) ;%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%it . insertAt ( 0 ,  ' <div class= " h " > ' , true ) ;%NWL%it . insertAt ( 5 ,  ' < / div> ' ) ;%NWL%test . done ( ) ;%NWL%3
it . insertAt ( 0 ,  ' <span class= " w " > ' , true ) ;%NWL%it . insertAt ( 5 ,  ' < / span> ' ) ;%NWL%it . insertAt ( 0 ,  ' <div class= " h " > ' , true ) ;%NWL%it . insertAt ( 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <div class= " h " ><span class= " w " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to use syntactic sugar for wrapping text " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) ;%NWL%it . wrap ( 0 ,  ' <div class= " w " > ' , 5 ,  ' < / div> ' ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" should be able to use syntactic sugar for wrapping text " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) ;%NWL%it . wrap ( 0 ,  ' <div class= " w " > ' , 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <div class= " w " ><span class= " h " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to chain calls for wrapping text " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) .%NWL%test . equals ( it . toString ( ) ,  ' <div class= " w " ><span class= " h " >hello< / span>< / div> world ' ) ;%NWL%5
} ,%NWL%" should be able to use syntactic sugar for wrapping text " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) ;%NWL%it . wrap ( 0 ,  ' <div class= " w " > ' , 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <div class= " w " ><span class= " h " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to chain calls for wrapping text " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) .%NWL%wrap ( 0 ,  ' <div class= " w " > ' , 5 ,  ' < / div> ' ) ;%NWL%test . done ( ) ;%NWL%5
it . wrap ( 0 ,  ' <div class= " w " > ' , 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <div class= " w " ><span class= " h " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to chain calls for wrapping text " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) .%NWL%wrap ( 0 ,  ' <div class= " w " > ' , 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <div class= " w " ><span class= " h " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) .%NWL%5
} ,%NWL%" should be able to chain calls for wrapping text " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) .%NWL%wrap ( 0 ,  ' <div class= " w " > ' , 5 ,  ' < / div> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <div class= " w " ><span class= " h " >hello< / span>< / div> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to insert text between two insertions " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) .%NWL%insertAt ( 3 ,  " w " ) ;%NWL%test . done ( ) ;%NWL%5
test . done ( ) ;%NWL%} ,%NWL%" should be able to insert text between two insertions " : function ( test )  {%NWL%it . wrap ( 0 ,  ' <span class= " h " > ' , 5 ,  ' < / span> ' ) .%NWL%insertAt ( 3 ,  " w " ) ;%NWL%test . equals ( it . toString ( ) ,  ' <span class= " h " >helwlo< / span> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should prepend on negative insertion index " : function ( test )  {%NWL%it . insertAt ( - 3 ,  " XXX " ) ;%NWL%test . done ( ) ;%NWL%0
test . equals ( it . toString ( ) ,  ' <span class= " h " >helwlo< / span> world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should prepend on negative insertion index " : function ( test )  {%NWL%it . insertAt ( - 3 ,  " XXX " ) ;%NWL%test . equals ( it . toString ( ) ,  ' XXXhello world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should append on out - of - bounds insertion index " : function ( test )  {%NWL%it . insertAt ( 100 ,  " XXX " ) ;%NWL%test . done ( ) ;%NWL%1
test . equals ( it . toString ( ) ,  ' XXXhello world ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should append on out - of - bounds insertion index " : function ( test )  {%NWL%it . insertAt ( 100 ,  " XXX " ) ;%NWL%test . equals ( it . toString ( ) ,  ' hello worldXXX ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should wrap entire line correctly " : function ( test )  {%NWL%it . wrapLine ( ' <span> ' ,  ' < / span> ' ) ;%NWL%test . done ( ) ;%NWL%1
test . done ( ) ;%NWL%} ,%NWL%" should wrap entire line correctly " : function ( test )  {%NWL%it . wrapLine ( ' <span> ' ,  ' < / span> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <span>hello world< / span> ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to consume blanks in an individual call " : function ( test )  {%NWL%it = new InsertionText ( "  hello world  " ) ;%NWL%it . wrap ( 2 ,  ' <span> ' , 13 ,  ' < / span> ' , true ) ;%NWL%test . done ( ) ;%NWL%0
test . done ( ) ;%NWL%}%NWL%} ,%NWL%" with a blank consuming insertion text and input with spaces on either end " : {%NWL%setUp: function ( cb )  {%NWL%it = new InsertionText ( "   hello world   " , true ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" spanning first word should consume leading spaces " : function ( test )  {%NWL%it . wrap ( 4 ,  ' <span class= " h " > ' , 9 ,  ' < / span> ' ) ;%NWL%test . done ( ) ;%NWL%0
it = new InsertionText ( "   hello world   " , true ) ;%NWL%cb ( ) ;%NWL%} ,%NWL%" spanning first word should consume leading spaces " : function ( test )  {%NWL%it . wrap ( 4 ,  ' <span class= " h " > ' , 9 ,  ' < / span> ' ) ;%NWL%test . equals ( it . toString ( ) ,  ' <span class= " h " >  hello< / span> world   ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" spanning second word should consume trailing spaces " : function ( test )  {%NWL%it . wrap ( 10 ,  ' <span class= " h " > ' , 15 ,  ' < / span> ' ) ;%NWL%test . done ( ) ;%NWL%6
test . done ( ) ;%NWL%} ,%NWL%" spanning second word should consume trailing spaces " : function ( test )  {%NWL%it . wrap ( 10 ,  ' <span class= " h " > ' , 15 ,  ' < / span> ' ) ;%NWL%test . equals ( it . toString ( ) ,  '   hello <span class= " h " >world  < / span> ' ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should be able to suppress blank consumption in an individual call " : function ( test )  {%NWL%it = new InsertionText ( "  hello world  " ) ;%NWL%it . wrap ( 2 ,  ' <span> ' , 13 ,  ' < / span> ' , false ) ;%NWL%test . done ( ) ;%NWL%0
cb ( ) ;%NWL%} ,%NWL%" should add / remove derived coverage correctly " : function ( test )  {%NWL%utils . addDerivedInfo ( it ) ;%NWL%var l = it . foo . l;%NWL%test . ok ( l ) ;%NWL%test . equals ( 3 , Object . keys ( l ) . length ) ;%NWL%test . equals ( 1 , l [ 1 ] ) ;%NWL%test . equals ( 3 , l [ 2 ] ) ;%NWL%test . equals ( 4 , l [ 7 ] ) ;%NWL%utils . addDerivedInfo ( it ) ;%NWL%3
" should add / remove derived coverage correctly " : function ( test )  {%NWL%utils . addDerivedInfo ( it ) ;%NWL%var l = it . foo . l;%NWL%test . ok ( l ) ;%NWL%test . equals ( 3 , Object . keys ( l ) . length ) ;%NWL%test . equals ( 1 , l [ 1 ] ) ;%NWL%test . equals ( 3 , l [ 2 ] ) ;%NWL%test . equals ( 4 , l [ 7 ] ) ;%NWL%l [ 7 ] = 0;%NWL%utils . addDerivedInfo ( it ) ;%NWL%utils . removeDerivedInfo ( it ) ;%NWL%1
test . deepEqual ( { total: 2 , covered: 1 , pct: 50 } , ret . functions ) ;%NWL%test . deepEqual ( { total: 5 , covered: 2 , pct: 40 } , ret . branches ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should return a pct of 100 when nothing is available " : function ( test )  {%NWL%it . foo . b = { } ;%NWL%var ret = utils . summarizeFileCoverage ( it . foo ) ;%NWL%test . deepEqual ( { total: 4 , covered: 3 , pct: 75 } , ret . lines ) ;%NWL%test . deepEqual ( { total: 5 , covered: 4 , pct: 80 } , ret . statements ) ;%NWL%test . deepEqual ( { total: 2 , covered: 1 , pct: 50 } , ret . functions ) ;%NWL%test . done ( ) ;%NWL%2
test . deepEqual ( { total: 0 , covered: 0 , pct: 100 } , ret . branches ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should merge summary correctly " : function ( test )  {%NWL%var s1 = utils . summarizeFileCoverage ( it . foo ) ,%NWL%s2 = utils . summarizeFileCoverage ( it2 . foo ) ,%NWL%ret = utils . mergeSummaryObjects ( s1 , s2 ) ;%NWL%test . deepEqual ( { total: 8 , covered: 6 , pct: 75 } , ret . lines ) ;%NWL%test . deepEqual ( { total: 10 , covered: 8 , pct: 80 } , ret . statements ) ;%NWL%test . deepEqual ( { total: 4 , covered: 2 , pct: 50 } , ret . functions ) ;%NWL%test . done ( ) ;%NWL%1
test . deepEqual ( { total: 4 , covered: 2 , pct: 50 } , ret . functions ) ;%NWL%test . deepEqual ( { total: 10 , covered: 4 , pct: 40 } , ret . branches ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should merge summary correctly in one call " : function ( test )  {%NWL%var coverage = { foo: it . foo ,  ' bar ' : it2 . foo } ,%NWL%ret = utils . summarizeCoverage ( coverage ) ;%NWL%test . deepEqual ( { total: 8 , covered: 6 , pct: 75 } , ret . lines ) ;%NWL%test . deepEqual ( { total: 10 , covered: 8 , pct: 80 } , ret . statements ) ;%NWL%test . deepEqual ( { total: 4 , covered: 2 , pct: 50 } , ret . functions ) ;%NWL%test . done ( ) ;%NWL%2
test . deepEqual ( { total: 10 , covered: 4 , pct: 40 } , ret . branches ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" can merge with a blank object in first position " : function ( test )  {%NWL%var s1 = null ,%NWL%s2 = utils . summarizeFileCoverage ( it2 . foo ) ,%NWL%ret = utils . mergeSummaryObjects ( s1 , s2 ) ;%NWL%test . deepEqual ( { total: 4 , covered: 3 , pct: 75 } , ret . lines ) ;%NWL%test . deepEqual ( { total: 5 , covered: 4 , pct: 80 } , ret . statements ) ;%NWL%test . deepEqual ( { total: 2 , covered: 1 , pct: 50 } , ret . functions ) ;%NWL%test . done ( ) ;%NWL%1
test . deepEqual ( { total: 5 , covered: 2 , pct: 40 } , ret . branches ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" can merge with a blank object in second position " : function ( test )  {%NWL%var s1 = utils . summarizeFileCoverage ( it2 . foo ) ,%NWL%s2 = null ,%NWL%ret = utils . mergeSummaryObjects ( s1 , s2 ) ;%NWL%test . deepEqual ( { total: 4 , covered: 3 , pct: 75 } , ret . lines ) ;%NWL%test . deepEqual ( { total: 5 , covered: 4 , pct: 80 } , ret . statements ) ;%NWL%test . deepEqual ( { total: 2 , covered: 1 , pct: 50 } , ret . functions ) ;%NWL%test . done ( ) ;%NWL%1
test . deepEqual ( { total: 5 , covered: 2 , pct: 40 } , ret . branches ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" can turn it into a YUI coverage object " : function ( test )  {%NWL%var ret = utils . toYUICoverage ( it ) ;%NWL%test . deepEqual ( {  ' 1 ' : 1 ,  ' 2 ' : 3 ,  ' 7 ' : 4 ,  ' 41 ' : 0 } , ret . foo . lines ) ;%NWL%test . deepEqual ( {  ' foo:1 ' : 10 ,  ' anonymous_1:7 ' : 0 } , ret . foo . functions ) ;%NWL%test . equal ( 3 , ret . foo . calledLines ) ;%NWL%test . equal ( 4 , ret . foo . coveredLines ) ;%NWL%test . equal ( 1 , ret . foo . calledFunctions ) ;%NWL%test . done ( ) ;%NWL%1
test . equals ( ' baz content ' , store . get ( baz ) ) ;%NWL%test . throws ( function ( )  {%NWL%store . get ( anon ) ;%NWL%} ) ;%NWL%store . dispose ( ) ;%NWL%test . ok ( !store . hasKey ( foo ) ) ;%NWL%test . equal ( 0 , store . keys ( ) . length ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" memory store should work as expected " : function ( test )  {%NWL%test . equal ( 0 , store . keys ( ) . length ) ;%NWL%6
} ;%NWL%NStore . TYPE = ' nstore ' ;%NWL%Store . register ( NStore ) ;%NWL%var store = Store . create ( ' nstore ' ) ;%NWL%test . ok ( store ) ;%NWL%test . equals ( ' x ' , store . set ( ' foo ' ,  ' bar ' ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not be able to register an invalid store " : function ( test )  {%NWL%function NStore ( opts )  { }%NWL%Store . register ( NStore ) ;%NWL%2
var store = Store . create ( ' nstore ' ) ;%NWL%test . ok ( store ) ;%NWL%test . equals ( ' x ' , store . set ( ' foo ' ,  ' bar ' ) ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" should not be able to register an invalid store " : function ( test )  {%NWL%function NStore ( opts )  { }%NWL%test . throws ( function ( )  {%NWL%Store . register ( NStore ) ;%NWL%} ,%NWL%test . done ( ) ;%NWL%3
test . throws ( function ( )  {%NWL%Store . register ( NStore ) ;%NWL%} ,%NWL%/ TYPE / ) ;%NWL%test . done ( ) ;%NWL%} ,%NWL%" invalid store should not be created " : function ( test )  {%NWL%test . throws (%NWL%function ( )  { Store . create ( ' foo ' ) ; } ,%NWL%/ Invalid store \ [ foo\ ] , allowed values are /%NWL%test . done ( ) ;%NWL%4
utilSummary = utils . mergeSummaryObjects ( s3 ) ,%NWL%libSummary = utils . mergeSummaryObjects ( s1 , s2 ) ,%NWL%fullSummary = utils . mergeSummaryObjects ( utilSummary , libSummary ) ;%NWL%test . equal ( ' / tmp / ' , node . fullPath ( ) ) ;%NWL%test . equal ( ' ' , node . displayShortName ( ) ) ;%NWL%test . equal ( 2 , node . children . length ) ;%NWL%test . deepEqual ( fullSummary , node . metrics ) ;%NWL%test . ok ( node === tree . getNode ( ' ' ) ) ;%NWL%node = tree . root . children [ 0 ] ;%NWL%test . equal ( ' / tmp / lib / ' , node . fullPath ( ) ) ;%NWL%test . equal ( 2 , node . children . length ) ;%NWL%5
utilSummary = utils . mergeSummaryObjects ( s3 ) ,%NWL%libSummary = utils . mergeSummaryObjects ( s1 , s2 ) ,%NWL%fullSummary = utils . mergeSummaryObjects ( utilSummary , libSummary ) ;%NWL%test . equal ( ' / tmp / lib / ' , node . fullPath ( ) ) ;%NWL%test . equal ( ' ' , node . displayShortName ( ) ) ;%NWL%test . equal ( 2 , node . children . length ) ;%NWL%test . deepEqual ( fullSummary , node . metrics ) ;%NWL%test . ok ( node === tree . getNode ( ' ' ) ) ;%NWL%node = tree . root . children [ 0 ] ;%NWL%test . equal ( ' / tmp / lib / main / ' , node . fullPath ( ) ) ;%NWL%test . equal ( 2 , node . children . length ) ;%NWL%5
utilSummary = utils . mergeSummaryObjects ( s3 ) ,%NWL%libSummary = utils . mergeSummaryObjects ( s1 , s2 ) ,%NWL%fullSummary = utils . mergeSummaryObjects ( utilSummary , libSummary ) ;%NWL%test . equal ( ' / ' , node . fullPath ( ) ) ;%NWL%test . equal ( ' ' , node . displayShortName ( ) ) ;%NWL%test . equal ( 2 , node . children . length ) ;%NWL%test . deepEqual ( fullSummary , node . metrics ) ;%NWL%test . ok ( node === tree . getNode ( ' ' ) ) ;%NWL%node = tree . root . children [ 0 ] ;%NWL%test . equal ( ' / __root__ / ' , node . fullPath ( ) ) ;%NWL%test . equal ( 2 , node . children . length ) ;%NWL%5
var argv , o , $args , that , filename , join$ = [ ] . join;%NWL%argv = process . argv;%NWL%global . LiveScript = require ( ' . / livescript ' ) ;%NWL%global . fs = require ( ' fs ' ) ;%NWL%global . path = require ( ' path ' ) ;%NWL%global . util = require ( ' util ' ) ;%NWL%global . say = function ( it ) {%NWL%process . stdout . write ( it +  ' \n ' ) ;%NWL%} ;%NWL%process . stderr . write ( it +  ' \n ' ) ;%NWL%7
} ;%NWL%try {%NWL%LiveScript . emit ( ' lex ' , t ) ;%NWL%t . tokens = LiveScript . tokens ( t . input ,  {%NWL%raw: o . lex%NWL%} ) ;%NWL%if ( o . lex || o . tokens )  {%NWL%printTokens ( t . tokens ) ;%NWL%throw null;%NWL%}%NWL%t . ast = LiveScript . ast ( t . tokens ) ;%NWL%3
values = function ( object ) {%NWL%var i$ , x , results$ = [ ] ;%NWL%for ( i$ in object )  {%NWL%x = object [ i$ ] ;%NWL%results$ . push ( x ) ;%NWL%}%NWL%return results$;%NWL%} ;%NWL%keys = function ( object ) {%NWL%var x , results$ = [ ] ;%NWL%results$ . push ( x ) ;%NWL%4
isMapped = _ . contains ( options ,  ' - p ' ) || _ . contains ( options ,  ' - - source - map ' ) ,%NWL%isSilent = _ . contains ( options ,  ' - s ' ) || _ . contains ( options ,  ' - - silent ' ) ,%NWL%isTemplate = _ . contains ( options ,  ' - t ' ) || _ . contains ( options ,  ' - - template ' ) ,%NWL%outputPath = path . join ( path . dirname ( filePath ) , path . basename ( filePath ,  ' . js ' )  +  ' . min . js ' ) ;%NWL%modes = options . reduce ( function ( result , value )  {%NWL%var match = value . match ( / modes= ( . * ) $ / ) ;%NWL%return match ? match [ 1 ] . split ( / ,  * / ) : result;%NWL%} , modes ) ;%NWL%outputPath = options . reduce ( function ( result , value , index )  {%NWL%if ( / - o| - - output / . test ( value ) )  {%NWL%var dirname = path . dirname ( result ) ;%NWL%5
this . hybrid = {  ' simple ' : { } ,  ' advanced ' : { }  } ;%NWL%this . uglified = { } ;%NWL%this . filePath = options . filePath;%NWL%this . isMapped = !!options . isMapped;%NWL%this . isSilent = !!options . isSilent;%NWL%this . isTemplate = !!options . isTemplate;%NWL%this . outputPath = options . outputPath;%NWL%this . sourceMapURL = options . sourceMapURL;%NWL%var modes = this . modes = options . modes;%NWL%source = this . source = preprocess ( source , options ) ;%NWL%var outputPath = this . outputPath ,%NWL%8
' Try running the command as root , via `sudo` , or manually install by running: ' ,%NWL%' ' ,%NWL%" curl - H ' Accept: "  + mediaType +  " '  "  + location . href +  ' / '  + hashId +  " | tar xvz - C ' "  + destPath +  " ' " ,%NWL%' '%NWL%] . join ( ' \n ' ) ) ;%NWL%}%NWL%ran = true;%NWL%process . removeListener ( ' uncaughtException ' , callback ) ;%NWL%onComplete ( exception ) ;%NWL%} ;%NWL%process . on ( ' uncaughtException ' , callback ) ;%NWL%7
}%NWL%try {%NWL%var uglifyJS = require ( uglifyPath ) ;%NWL%var toplevel = uglifyJS . parse ( source ) ;%NWL%toplevel . figure_out_scope ( ) ;%NWL%toplevel = toplevel . transform ( uglifyJS . Compressor ( {%NWL%' comparisons ' : false ,%NWL%' unsafe ' : true ,%NWL%' unsafe_comps ' : true ,%NWL%' warnings ' : false%NWL%toplevel . figure_out_scope ( ) ;%NWL%4
try {%NWL%var uglifyJS = require ( uglifyPath ) ;%NWL%var toplevel = uglifyJS . parse ( source ) ;%NWL%toplevel . figure_out_scope ( ) ;%NWL%toplevel = toplevel . transform ( uglifyJS . Compressor ( {%NWL%' comparisons ' : false ,%NWL%' unsafe ' : true ,%NWL%' unsafe_comps ' : true ,%NWL%' warnings ' : false%NWL%} ) ) ;%NWL%toplevel . compute_char_frequency ( ) ;%NWL%3
, uname: true }%NWL%exports . fields = fields%NWL%exports . fieldSize = fieldSize%NWL%exports . fieldOffs = fieldOffs%NWL%exports . fieldEnds = fieldEnds%NWL%exports . types = types%NWL%exports . modes = modes%NWL%exports . numeric = numeric%NWL%exports . headerSize = headerSize%NWL%exports . blockSize = blockSize%NWL%exports . Pack = require ( " . / lib / pack . js " )%NWL%1
exports . fields = fields%NWL%exports . fieldSize = fieldSize%NWL%exports . fieldOffs = fieldOffs%NWL%exports . fieldEnds = fieldEnds%NWL%exports . types = types%NWL%exports . modes = modes%NWL%exports . numeric = numeric%NWL%exports . headerSize = headerSize%NWL%exports . blockSize = blockSize%NWL%exports . knownExtended = knownExtended%NWL%exports . Parse = require ( " . / lib / parse . js " )%NWL%0
exports . fieldSize = fieldSize%NWL%exports . fieldOffs = fieldOffs%NWL%exports . fieldEnds = fieldEnds%NWL%exports . types = types%NWL%exports . modes = modes%NWL%exports . numeric = numeric%NWL%exports . headerSize = headerSize%NWL%exports . blockSize = blockSize%NWL%exports . knownExtended = knownExtended%NWL%exports . Pack = require ( " . / lib / pack . js " )%NWL%exports . Extract = require ( " . / lib / extract . js " )%NWL%0
viewOptions: function ( )  {%NWL%return _ . extend ( oldViewOptions . apply ( this , arguments ) ,  { ' url ' : null } ) ;%NWL%} ,%NWL%initialize: function ( )  {%NWL%this . modules = _ . map ( this . model . get ( ' modules ' ) , function ( module )  {%NWL%module . controller = SectionModule . map [ module [ ' module - type ' ] ] ;%NWL%return module;%NWL%} , this ) ;%NWL%parent . prototype . initialize . apply ( this , arguments ) ;%NWL%} ,%NWL%this . sectionModules = this . renderModules (%NWL%4
} )%NWL%me . _stream . on ( " end " , function ( )  {%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%} )%NWL%me . props = props%NWL%if ( props . type === " Directory " )  {%NWL%props . size = 0%NWL%}%NWL%props . ustar = " ustar\0 "%NWL%me . path = props . path%NWL%5
EntryWriter . prototype . write = function ( c )  {%NWL%if ( this . _ended ) return this . emit ( " error " , new Error ( " write after end " ) )%NWL%this . _buffer . push ( c )%NWL%this . _process ( )%NWL%this . _needDrain = this . _buffer . length > 0%NWL%return !this . _needDrain%NWL%}%NWL%EntryWriter . prototype . end = function ( c )  {%NWL%if ( c ) this . _buffer . push ( c )%NWL%this . _buffer . push ( EOF )%NWL%this . _process ( )%NWL%3
this . _ended = true%NWL%this . _process ( )%NWL%this . _needDrain = this . _buffer . length > 0%NWL%}%NWL%EntryWriter . prototype . pause = function ( )  {%NWL%this . _paused = true%NWL%this . emit ( " pause " )%NWL%}%NWL%EntryWriter . prototype . resume = function ( )  {%NWL%this . _paused = false%NWL%this . _process ( )%NWL%1
this . _queueLen + +%NWL%this . _read ( )%NWL%if ( this . _paused || ql > 0 )  {%NWL%this . _needDrain = true%NWL%return false%NWL%}%NWL%return true%NWL%}%NWL%, end: function ( c )  {%NWL%if ( c ) this . write ( c )%NWL%this . _read ( )%NWL%1
if ( c ) this . write ( c )%NWL%this . _ending = true%NWL%this . _read ( )%NWL%}%NWL%, pause: function ( )  {%NWL%this . _paused = true%NWL%this . emit ( " pause " )%NWL%}%NWL%, resume: function ( )  {%NWL%this . emit ( " resume " )%NWL%this . _read ( )%NWL%2
case " Link " :%NWL%case " SymbolicLink " :%NWL%case " CharacterDevice " :%NWL%case " BlockDevice " :%NWL%case " Directory " :%NWL%case " FIFO " :%NWL%default:%NWL%type = tar . types [ props . type ]%NWL%}%NWL%this . type = type%NWL%this . size = props . size%NWL%9
case " SymbolicLink " :%NWL%case " CharacterDevice " :%NWL%case " BlockDevice " :%NWL%case " Directory " :%NWL%case " FIFO " :%NWL%default:%NWL%type = tar . types [ props . type ]%NWL%}%NWL%this . type = type%NWL%this . path = props . path%NWL%this . _remaining = props . size%NWL%8
module . exports = ExtendedHeaderWriter%NWL%var inherits = require ( " . . / vendor / inherits / inherits . js " )%NWL%, EntryWriter = require ( " . / entry - writer . js " )%NWL%var tar = require ( " . . / tar . js " )%NWL%1
}%NWL%this . _sizeBuf . push ( b )%NWL%continue%NWL%case KEY:%NWL%if ( b === eq )  {%NWL%this . _state = VAL%NWL%this . _key = new Buffer ( this . _keyBuf ) . toString ( )%NWL%if ( keyTrans [ this . _key ] ) this . _key = keyTrans [ this . _key ]%NWL%this . _keyBuf . length = 0%NWL%continue%NWL%this . _keyBuf . push ( b )%NWL%1
function Extract ( opts )  {%NWL%if ( ! ( this instanceof Extract ) ) return new Extract ( opts )%NWL%tar . Parse . apply ( this )%NWL%opts . type = " Directory "%NWL%opts . Directory = true%NWL%if ( typeof opts !== " object " )  {%NWL%opts = { path: opts }%NWL%}%NWL%opts . path = opts . path || path . resolve ( " node - tar - extract " )%NWL%opts . type = " Directory "%NWL%opts . strip = + opts . strip%NWL%8
opts . strip = + opts . strip%NWL%if ( !opts . strip || opts . strip <= 0 ) opts . strip = 0%NWL%this . _fst = fstream . Writer ( opts )%NWL%this . pause ( )%NWL%var me = this%NWL%me . on ( " entry " , function ( entry )  {%NWL%if ( opts . strip )  {%NWL%var p = entry . path . split ( " / " ) . slice ( opts . strip ) . join ( " / " )%NWL%entry . path = entry . props . path = p%NWL%if ( entry . linkpath )  {%NWL%entry . linkpath = entry . props . linkpath = lp%NWL%8
var me = this%NWL%me . on ( " entry " , function ( entry )  {%NWL%if ( opts . strip )  {%NWL%var p = entry . path . split ( " / " ) . slice ( opts . strip ) . join ( " / " )%NWL%entry . path = entry . props . path = p%NWL%if ( entry . linkpath )  {%NWL%var lp = entry . linkpath . split ( " / " ) . slice ( opts . strip ) . join ( " / " )%NWL%entry . linkpath = entry . props . linkpath = lp%NWL%}%NWL%}%NWL%entry . linkpath = entry . props . linkpath =%NWL%4
if ( !obj && ! ( this instanceof TarHeader ) ) throw new Error (%NWL%" encode must be called on a TarHeader , or supplied an object " )%NWL%obj = obj || this%NWL%var block = obj . block = new Buffer ( 512 )%NWL%if ( obj . prefix )  {%NWL%obj . path = obj . prefix +  " / "  + obj . path%NWL%obj . prefix = " "%NWL%}%NWL%obj . needExtended = false%NWL%if ( obj . mode )  {%NWL%obj . mode = obj . mode & 0777%NWL%5
this . emit ( " pause " )%NWL%}%NWL%Pack . prototype . resume = function ( )  {%NWL%this . _paused = false%NWL%if ( this . _currentEntry ) this . _currentEntry . resume ( )%NWL%this . emit ( " resume " )%NWL%this . _process ( )%NWL%}%NWL%Pack . prototype . end = function ( )  {%NWL%this . _ended = true%NWL%this . _process ( )%NWL%6
me . emit ( " data " , eof )%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%return%NWL%}%NWL%var root = path . dirname ( ( entry . root || entry ) . path )%NWL%var wprops = { }%NWL%Object . keys ( entry . props || { } ) . forEach ( function ( k )  {%NWL%wprops [ k ] = entry . props [ k ]%NWL%} )%NWL%wprops . path = path . relative ( root , entry . path || ' ' )%NWL%8
me . emit ( " close " )%NWL%return%NWL%}%NWL%var root = path . dirname ( ( entry . root || entry ) . path )%NWL%var wprops = { }%NWL%Object . keys ( entry . props || { } ) . forEach ( function ( k )  {%NWL%wprops [ k ] = entry . props [ k ]%NWL%} )%NWL%if ( me . _noProprietary ) wprops . noProprietary = true%NWL%wprops . path = path . relative ( root , entry . path || ' ' )%NWL%wprops . path = wprops . path . replace ( / \\ / g ,  " / " )%NWL%6
var header = new TarHeader ( c )%NWL%, self = this%NWL%, entry%NWL%, ev%NWL%, EntryType%NWL%, onend%NWL%, meta = false%NWL%if ( null === header . size || !header . cksumValid )  {%NWL%var e = new Error ( " invalid tar file " )%NWL%e . header = header%NWL%e . tar_block = this . position / 512%NWL%9
case " FIFO " :%NWL%case " ContiguousFile " :%NWL%case " GNUDumpDir " :%NWL%EntryType = Entry%NWL%ev = " entry "%NWL%break%NWL%case " GlobalExtendedHeader " :%NWL%EntryType = ExtendedHeader%NWL%onend = function ( )  {%NWL%self . _global = self . _global || { }%NWL%self . _global [ k ] = entry . fields [ k ]%NWL%9
self . _extended = self . _extended || { }%NWL%self . _extended . linkpath = entry . body%NWL%}%NWL%ev = " longLinkpath "%NWL%meta = true%NWL%break%NWL%case " NextFileHasLongPath " :%NWL%case " OldGnuLongPath " :%NWL%EntryType = BufferEntry%NWL%onend = function ( )  {%NWL%self . _extended . path = entry . body%NWL%0
entry . on ( " data " , function ( c )  {%NWL%me . emit ( " data " , c )%NWL%} )%NWL%}%NWL%if ( onend ) entry . on ( " end " , onend )%NWL%this . _entry = entry%NWL%var me = this%NWL%entry . on ( " pause " , function ( )  {%NWL%me . pause ( )%NWL%} )%NWL%me . resume ( )%NWL%8
exports . Dir =%NWL%{ Reader : require ( " . / lib / dir - reader . js " )%NWL%, Writer : require ( " . / lib / dir - writer . js " )  }%NWL%exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%9
{ Reader : require ( " . / lib / dir - reader . js " )%NWL%, Writer : require ( " . / lib / dir - writer . js " )  }%NWL%exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%8
, Writer : require ( " . / lib / dir - writer . js " )  }%NWL%exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%7
exports . Link =%NWL%{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . File = exports . FileWriter = exports . File . Writer%NWL%6
{ Reader : require ( " . / lib / link - reader . js " )%NWL%, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%exports . Writer . Link = exports . LinkWriter = exports . Link . Writer%NWL%5
, Writer : require ( " . / lib / link - writer . js " )  }%NWL%exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%exports . Writer . File = exports . FileWriter = exports . File . Writer%NWL%exports . Writer . Proxy = exports . ProxyWriter = exports . Proxy . Writer%NWL%4
exports . Proxy =%NWL%{ Reader : require ( " . / lib / proxy - reader . js " )%NWL%, Writer : require ( " . / lib / proxy - writer . js " )  }%NWL%exports . Reader . Dir = exports . DirReader = exports . Dir . Reader%NWL%exports . Reader . File = exports . FileReader = exports . File . Reader%NWL%exports . Reader . Link = exports . LinkReader = exports . Link . Reader%NWL%exports . Reader . Proxy = exports . ProxyReader = exports . Proxy . Reader%NWL%exports . Writer . Dir = exports . DirWriter = exports . Dir . Writer%NWL%exports . Writer . File = exports . FileWriter = exports . File . Writer%NWL%exports . Writer . Link = exports . LinkWriter = exports . Link . Writer%NWL%exports . collect = require ( " . / lib / collect . js " )%NWL%3
console . error ( " %s %s\n "  +%NWL%" path = %s\n "  +%NWL%" syscall = %s\n "  +%NWL%" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . syscall ,%NWL%9
" path = %s\n "  +%NWL%" syscall = %s\n "  +%NWL%" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . fstream_type ,%NWL%8
" syscall = %s\n "  +%NWL%" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . syscall ,%NWL%er . fstream_path ,%NWL%7
" fstream_type = %s\n "  +%NWL%" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . syscall ,%NWL%er . fstream_type ,%NWL%er . fstream_unc_path ,%NWL%6
" fstream_path = %s\n "  +%NWL%" fstream_unc_path = %s\n "  +%NWL%" fstream_class = %s\n "  +%NWL%" fstream_stack =\n%s\n " ,%NWL%code || " UNKNOWN " ,%NWL%er . stack ,%NWL%er . path ,%NWL%er . syscall ,%NWL%er . fstream_type ,%NWL%er . fstream_path ,%NWL%er . fstream_class ,%NWL%5
this . emit ( " info " , msg , code )%NWL%}%NWL%Abstract . prototype . error = function ( msg , code , th )  {%NWL%var er = decorate ( msg , code , this )%NWL%if ( th ) throw er%NWL%else this . emit ( " error " , er )%NWL%}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . fstream_type = er . fstream_type || me . type%NWL%9
}%NWL%Abstract . prototype . error = function ( msg , code , th )  {%NWL%var er = decorate ( msg , code , this )%NWL%if ( th ) throw er%NWL%else this . emit ( " error " , er )%NWL%}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_path = er . fstream_path || me . path%NWL%8
var er = decorate ( msg , code , this )%NWL%if ( th ) throw er%NWL%else this . emit ( " error " , er )%NWL%}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%6
}%NWL%function decorate ( er , code , me )  {%NWL%if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%if ( me . _path !== me . path )  {%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%}%NWL%er . fstream_linkpath = er . fstream_linkpath || me . linkpath%NWL%3
if ( ! ( er instanceof Error ) ) er = new Error ( er )%NWL%er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%if ( me . _path !== me . path )  {%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%}%NWL%if ( me . linkpath )  {%NWL%er . fstream_linkpath = er . fstream_linkpath || me . linkpath%NWL%er . fstream_class = er . fstream_class || me . constructor . name%NWL%1
er . code = er . code || code%NWL%er . path = er . path || me . path%NWL%er . fstream_type = er . fstream_type || me . type%NWL%er . fstream_path = er . fstream_path || me . path%NWL%if ( me . _path !== me . path )  {%NWL%er . fstream_unc_path = er . fstream_unc_path || me . _path%NWL%}%NWL%if ( me . linkpath )  {%NWL%er . fstream_linkpath = er . fstream_linkpath || me . linkpath%NWL%}%NWL%er . fstream_stack = er . fstream_stack ||%NWL%0
DirReader . prototype . _getEntries = function ( )  {%NWL%var me = this%NWL%if ( me . _gotEntries ) return%NWL%me . _gotEntries = true%NWL%fs . readdir ( me . _path , function ( er , entries )  {%NWL%if ( er ) return me . error ( er )%NWL%me . entries = entries%NWL%me . emit ( " entries " , entries )%NWL%if ( me . _paused ) me . once ( " resume " , processEntries )%NWL%else processEntries ( )%NWL%me . _length = me . entries . length%NWL%6
if ( me . _gotEntries ) return%NWL%me . _gotEntries = true%NWL%fs . readdir ( me . _path , function ( er , entries )  {%NWL%if ( er ) return me . error ( er )%NWL%me . entries = entries%NWL%me . emit ( " entries " , entries )%NWL%if ( me . _paused ) me . once ( " resume " , processEntries )%NWL%else processEntries ( )%NWL%function processEntries ( )  {%NWL%me . _length = me . entries . length%NWL%me . entries = me . entries . sort ( me . sort . bind ( me ) )%NWL%4
childProps . basename = path . basename ( p )%NWL%childProps . dirname = path . dirname ( p )%NWL%var entry = Reader ( childProps , stat )%NWL%me . _currentEntry = entry%NWL%entry . on ( " pause " , function ( who )  {%NWL%if ( !me . _paused && !entry . _disowned )  {%NWL%me . pause ( who )%NWL%}%NWL%} )%NWL%entry . on ( " resume " , function ( who )  {%NWL%me . resume ( who )%NWL%6
}%NWL%DirWriter . prototype . add = function ( entry )  {%NWL%var me = this%NWL%collect ( entry )%NWL%if ( !me . ready || me . _currentEntry )  {%NWL%me . _buffer . push ( entry )%NWL%return false%NWL%}%NWL%if ( me . _ended )  {%NWL%return me . error ( " add after end " )%NWL%me . _buffer . push ( entry )%NWL%5
stream . on ( " data " , function ( c )  {%NWL%me . _bytesEmitted + = c . length%NWL%if ( !c . length ) return%NWL%else if ( me . _paused || me . _buffer . length )  {%NWL%me . _buffer . push ( c )%NWL%me . _read ( )%NWL%} else me . emit ( " data " , c )%NWL%} )%NWL%stream . on ( " end " , function ( )  {%NWL%if ( me . _paused || me . _buffer . length )  {%NWL%me . _read ( )%NWL%5
" actual: " + me . _bytesEmitted )%NWL%}%NWL%} )%NWL%stream . on ( " close " , function ( )  {%NWL%if ( me . _paused || me . _buffer . length )  {%NWL%me . _buffer . push ( CLOSE )%NWL%me . _read ( )%NWL%} else {%NWL%me . emit ( " close " )%NWL%}%NWL%me . _read ( )%NWL%6
me . emit ( " ready " )%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%me . end = me . _finish = function ( )  { }%NWL%} else return me . error ( er )%NWL%}%NWL%finish ( me )%NWL%} )%NWL%}%NWL%function finish ( me )  {%NWL%me . emit ( " ready " )%NWL%0
var ModuleController = require ( ' . . / controllers / module ' ) ;%NWL%var TabController = requirejs ( ' common / modules / tab ' ) ;%NWL%var TabView = require ( ' . . / views / modules / tab ' ) ;%NWL%var parent = ModuleController . extend ( TabController ) ;%NWL%var TabModule = parent . extend ( {%NWL%visualisationClass: TabView ,%NWL%initialize: function ( )  {%NWL%this . tabs = _ . map ( this . model . get ( ' tabs ' ) , function ( tab )  {%NWL%tab . controller = TabModule . map [ tab [ ' module - type ' ] ] ;%NWL%tab . slug = this . model . get ( ' slug ' )  +  ' - '  + tab . slug;%NWL%tab . info = this . model . get ( ' info ' ) ;%NWL%9
this . tabs = _ . map ( this . model . get ( ' tabs ' ) , function ( tab )  {%NWL%tab . controller = TabModule . map [ tab [ ' module - type ' ] ] ;%NWL%tab . slug = this . model . get ( ' slug ' )  +  ' - '  + tab . slug;%NWL%if ( !tab . info )  {%NWL%tab . info = this . model . get ( ' info ' ) ;%NWL%}%NWL%return tab;%NWL%} , this ) ;%NWL%parent . prototype . initialize . apply ( this , arguments ) ;%NWL%} ,%NWL%this . tabModules = this . renderModules (%NWL%0
ClassType = ProxyReader%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . depth = props . depth = props . depth || 0%NWL%9
break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . parent = props . parent || null%NWL%8
}%NWL%if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%7
if ( ! ( me instanceof ClassType ) )  {%NWL%return new ClassType ( props )%NWL%}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%6
}%NWL%Abstract . call ( me )%NWL%me . readable = true%NWL%me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%4
me . writable = false%NWL%me . type = type%NWL%me . props = props%NWL%me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%1
me . depth = props . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%me . basename = props . basename = path . basename ( me . path )%NWL%0
me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . dirname = props . dirname = path . dirname ( me . path )%NWL%0
me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = props . basename = path . basename ( me . path )%NWL%me . dirname = props . dirname = path . dirname ( me . path )%NWL%me . size = props . size%NWL%2
if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = props . basename = path . basename ( me . path )%NWL%me . dirname = props . dirname = path . dirname ( me . path )%NWL%props . parent = props . root = null%NWL%me . filter = typeof props . filter === " function " ? props . filter : null%NWL%1
} )%NWL%if ( undefined !== me . size && props . size !== me . size )  {%NWL%return me . error ( " incorrect size " )%NWL%}%NWL%me . size = props . size%NWL%var type = getType ( props )%NWL%if ( type !== " Directory " && props . nlink && props . nlink > 1 )  {%NWL%var k = props . dev +  " : "  + props . ino%NWL%if ( hardLinks [ k ] === me . _path || !hardLinks [ k ] ) hardLinks [ k ] = me . _path%NWL%else {%NWL%me . Link = me . props . Link = true%NWL%4
if ( undefined !== me . size && props . size !== me . size )  {%NWL%return me . error ( " incorrect size " )%NWL%}%NWL%me . size = props . size%NWL%var type = getType ( props )%NWL%if ( type !== " Directory " && props . nlink && props . nlink > 1 )  {%NWL%var k = props . dev +  " : "  + props . ino%NWL%if ( hardLinks [ k ] === me . _path || !hardLinks [ k ] ) hardLinks [ k ] = me . _path%NWL%else {%NWL%type = me . type = me . props . type = " Link "%NWL%me . linkpath = me . props . linkpath = hardLinks [ k ]%NWL%3
return me . error ( " incorrect size " )%NWL%}%NWL%me . size = props . size%NWL%var type = getType ( props )%NWL%if ( type !== " Directory " && props . nlink && props . nlink > 1 )  {%NWL%var k = props . dev +  " : "  + props . ino%NWL%if ( hardLinks [ k ] === me . _path || !hardLinks [ k ] ) hardLinks [ k ] = me . _path%NWL%else {%NWL%type = me . type = me . props . type = " Link "%NWL%me . Link = me . props . Link = true%NWL%me . _stat = me . _read = LinkReader . prototype . _read%NWL%2
me . abort ( )%NWL%me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%}%NWL%return%NWL%}%NWL%}%NWL%var events = [ " _stat " ,  " stat " ,  " ready " ]%NWL%var e = 0%NWL%; ( function go ( )  {%NWL%me . emit ( " end " )%NWL%1
me . emit ( " end " )%NWL%me . emit ( " close " )%NWL%}%NWL%return%NWL%}%NWL%}%NWL%var events = [ " _stat " ,  " stat " ,  " ready " ]%NWL%var e = 0%NWL%; ( function go ( )  {%NWL%if ( me . _aborted )  {%NWL%me . emit ( " close " )%NWL%1
case " SymbolicLink " :%NWL%ClassType = LinkWriter%NWL%break%NWL%case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . depth = props . depth || 0%NWL%9
ClassType = LinkWriter%NWL%break%NWL%case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%8
break%NWL%case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . parent = props . parent || null%NWL%7
case null:%NWL%ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%6
ClassType = ProxyWriter%NWL%break%NWL%}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%5
}%NWL%if ( ! ( me instanceof ClassType ) ) return new ClassType ( props )%NWL%Abstract . call ( me )%NWL%me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%3
me . type = props . type%NWL%me . props = props%NWL%me . depth = props . depth || 0%NWL%me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%0
me . clobber = false === props . clobber ? props . clobber : true%NWL%me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%me . basename = path . basename ( props . path )%NWL%0
me . parent = props . parent || null%NWL%me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . dirname = path . dirname ( props . path )%NWL%0
me . root = props . root || ( props . parent && props . parent . root ) || me%NWL%me . _path = me . path = path . resolve ( props . path )%NWL%if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = path . basename ( props . path )%NWL%me . linkpath = props . linkpath || null%NWL%0
if ( process . platform === " win32 " )  {%NWL%me . path = me . _path = me . path . replace ( / \? / g ,  " _ " )%NWL%if ( me . _path . length >= 260 )  {%NWL%me . _swallowErrors = true%NWL%me . _path = " \\\\?\\ "  + me . path . replace ( / \ / / g ,  " \\ " )%NWL%}%NWL%}%NWL%me . basename = path . basename ( props . path )%NWL%me . dirname = path . dirname ( props . path )%NWL%me . linkpath = props . linkpath || null%NWL%me . size = props . size%NWL%1
me . dirname = path . dirname ( props . path )%NWL%me . linkpath = props . linkpath || null%NWL%props . parent = props . root = null%NWL%me . size = props . size%NWL%if ( typeof props . mode === " string " )  {%NWL%props . mode = parseInt ( props . mode , 8 )%NWL%}%NWL%me . readable = false%NWL%me . writable = true%NWL%me . _buffer = [ ]%NWL%me . filter = typeof props . filter === " function " ? props . filter: null%NWL%0
function open ( path , flags , mode , cb )  {%NWL%cb = cb || noop%NWL%fs . _curOpen + +%NWL%originalOpen . call ( fs , path , flags , mode , function ( er , fd )  {%NWL%if ( er ) onclose ( )%NWL%cb ( er , fd )%NWL%} )%NWL%}%NWL%fs . openSync = function ( path , flags , mode )  {%NWL%var ret%NWL%fs . _curOpen + +%NWL%2
}%NWL%fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%9
fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%8
return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%7
}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . lchownSync = chownFixSync ( fs . lchownSync )%NWL%6
if ( !er || ( !process . getuid || process . getuid ( ) !== 0 )%NWL%&& ( er . code === " EINVAL " || er . code === " EPERM " ) ) return true%NWL%}%NWL%if ( !fs . lchmod )  {%NWL%fs . lchmod = function ( path , mode , cb )  {%NWL%process . nextTick ( cb )%NWL%}%NWL%fs . lchmodSync = function ( )  { }%NWL%}%NWL%if ( !fs . lchown )  {%NWL%process . nextTick ( cb )%NWL%5
} )%NWL%}%NWL%function rimrafSync ( p )  {%NWL%try {%NWL%fs . unlinkSync ( p )%NWL%} catch ( er )  {%NWL%if ( er . code === " ENOENT " )%NWL%return%NWL%if ( er . code !== " EPERM " && er . code !== " EISDIR " )%NWL%throw er%NWL%fs . rmdirSync ( p )%NWL%4
try {%NWL%fs . rmdirSync ( p )%NWL%} catch ( er2 )  {%NWL%if ( er2 . code === " ENOENT " )%NWL%return%NWL%if ( er2 . code === " ENOTDIR " )%NWL%throw er%NWL%if ( er2 . code === " ENOTEMPTY " )  {%NWL%fs . readdirSync ( p ) . forEach ( function ( f )  {%NWL%rimrafSync ( path . join ( p , f ) )%NWL%fs . rmdirSync ( p )%NWL%1
var zlib = require ( ' zlib ' ) ;%NWL%var levels = require ( ' . . / levels ' ) ;%NWL%0
var zlib = require ( ' zlib ' ) ;%NWL%var layouts = require ( ' . . / layouts ' ) ;%NWL%var dgram = require ( ' dgram ' ) ;%NWL%0
var zlib = require ( ' zlib ' ) ;%NWL%var layouts = require ( ' . . / layouts ' ) ;%NWL%var levels = require ( ' . . / levels ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var client = dgram . createSocket ( " udp4 " ) ;%NWL%process . on ( ' exit ' , function ( )  {%NWL%if ( client ) client . close ( ) ;%NWL%} ) ;%NWL%function preparePacket ( loggingEvent )  {%NWL%var msg = { } ;%NWL%msg . full_message = layout ( loggingEvent ) ;%NWL%msg . short_message = msg . full_message;%NWL%msg . version= " 1 . 0 " ;%NWL%msg . timestamp = msg . timestamp || new Date ( ) . getTime ( )  / 1000 >> 0;%NWL%msg . level = levelMapping [ loggingEvent . level || levels . DEBUG ] ;%NWL%9
var log4js = require ( ' . . / log4js ' ) ;%NWL%var layouts = require ( ' . . / layouts ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
function getBufferedHook ( hook , eventName )  {%NWL%var hookBuffer = [ ] ;%NWL%var hookReady = false;%NWL%hook . on ( ' hook::ready ' , function emptyBuffer ( )  {%NWL%hookBuffer . forEach ( function logBufferItem ( loggingEvent )  {%NWL%hook . emit ( eventName , loggingEvent ) ;%NWL%} )%NWL%hookReady = true;%NWL%} ) ;%NWL%return function log ( loggingEvent )  {%NWL%hook . emit ( eventName , loggingEvent ) ;%NWL%5
var log4js = require ( ' . . / log4js ' ) ;%NWL%function logLevelFilter ( levelString , appender )  {%NWL%var level = levels . toLevel ( levelString ) ;%NWL%return function ( logEvent )  {%NWL%if ( logEvent . level . isGreaterThanOrEqualTo ( level ) )  {%NWL%appender ( logEvent ) ;%NWL%}%NWL%}%NWL%}%NWL%function configure ( config )  {%NWL%var appender = log4js . appenderMakers [ config . appender . type ] ( config . appender ) ;%NWL%0
loggingEvent = JSON . parse ( msg ) ;%NWL%loggingEvent . startTime = new Date ( loggingEvent . startTime ) ;%NWL%loggingEvent . level = log4js . levels . toLevel ( loggingEvent . level . levelStr ) ;%NWL%} catch ( e )  {%NWL%loggingEvent = {%NWL%startTime: new Date ( ) ,%NWL%categoryName: ' log4js ' ,%NWL%level: log4js . levels . ERROR ,%NWL%data: [  ' Unable to parse log: ' , msg ]%NWL%} ;%NWL%loggingEvent . remoteAddress = clientSocket . remoteAddress;%NWL%1
loggingEvent . startTime = new Date ( loggingEvent . startTime ) ;%NWL%loggingEvent . level = log4js . levels . toLevel ( loggingEvent . level . levelStr ) ;%NWL%} catch ( e )  {%NWL%loggingEvent = {%NWL%startTime: new Date ( ) ,%NWL%categoryName: ' log4js ' ,%NWL%level: log4js . levels . ERROR ,%NWL%data: [  ' Unable to parse log: ' , msg ]%NWL%} ;%NWL%}%NWL%loggingEvent . remotePort = clientSocket . remotePort;%NWL%0
var layouts = require ( " . . / layouts " ) ,%NWL%mailer = require ( " nodemailer " ) ,%NWL%os = require ( ' os ' ) ;%NWL%function smtpAppender ( config , layout )  {%NWL%layout = layout || layouts . basicLayout;%NWL%var sendInterval = config . sendInterval * 1000 || 0;%NWL%0
var subjectLayout = layouts . messagePassThroughLayout;%NWL%var sendInterval = config . sendInterval * 1000 || 0;%NWL%%NWL%var logEventBuffer = [ ] ;%NWL%var sendTimer;%NWL%%NWL%function sendBuffer ( )  {%NWL%if ( logEventBuffer . length == 0 )  {%NWL%return;%NWL%}%NWL%var transport = mailer . createTransport ( config . transport , config [ config . transport ] ) ;%NWL%1
debug = function ( )  {  } ;%NWL%}%NWL%function DateRollingFileStream ( filename , pattern , options , now )  {%NWL%debug ( " Now is "  + now ) ;%NWL%if ( pattern && typeof ( pattern ) === ' object ' )  {%NWL%now = options;%NWL%options = pattern;%NWL%pattern = null;%NWL%}%NWL%this . pattern = pattern || ' . yyyy - MM - dd ' ;%NWL%this . lastTimeWeWroteSomething = format . asString ( this . pattern , new Date ( this . now ( ) ) ) ;%NWL%9
DateRollingFileStream . prototype . roll = function ( filename , callback )  {%NWL%var that = this;%NWL%debug ( " Starting roll " ) ;%NWL%if ( this . alwaysIncludePattern )  {%NWL%this . filename = this . baseFilename + this . lastTimeWeWroteSomething;%NWL%async . series ( [%NWL%this . closeTheStream . bind ( this ) ,%NWL%this . openTheStream . bind ( this )%NWL%] , callback ) ;%NWL%} else {%NWL%async . series ( [%NWL%5
var that = this;%NWL%debug ( " Starting roll " ) ;%NWL%if ( this . alwaysIncludePattern )  {%NWL%this . filename = this . baseFilename + this . lastTimeWeWroteSomething;%NWL%async . series ( [%NWL%this . closeTheStream . bind ( this ) ,%NWL%this . openTheStream . bind ( this )%NWL%] , callback ) ;%NWL%} else {%NWL%var newFilename = this . baseFilename + this . previousTime;%NWL%this . closeTheStream . bind ( this ) ,%NWL%5
this . filename = this . baseFilename + this . lastTimeWeWroteSomething;%NWL%async . series ( [%NWL%this . closeTheStream . bind ( this ) ,%NWL%this . openTheStream . bind ( this )%NWL%] , callback ) ;%NWL%} else {%NWL%var newFilename = this . baseFilename + this . previousTime;%NWL%async . series ( [%NWL%this . closeTheStream . bind ( this ) ,%NWL%deleteAnyExistingFile ,%NWL%this . openTheStream . bind ( this )%NWL%3
this . next = this%NWL%this . prev = this%NWL%}%NWL%Node . prototype . append = function ( n )  {%NWL%n . next = this . next%NWL%n . prev = this%NWL%this . next . prev = n%NWL%this . next = n%NWL%return n%NWL%}%NWL%n . prev = this . prev%NWL%4
var Transform = require ( ' . / lib / _stream_transform . js ' ) ;%NWL%var binding = process . binding ( ' zlib ' ) ;%NWL%var assert = require ( ' assert ' ) . ok;%NWL%1
flow ( ) ;%NWL%function flow ( )  {%NWL%var chunk;%NWL%while ( null !== ( chunk = engine . read ( ) ) )  {%NWL%buffers . push ( chunk ) ;%NWL%nread + = chunk . length;%NWL%}%NWL%engine . once ( ' readable ' , flow ) ;%NWL%}%NWL%function onError ( err )  {%NWL%engine . removeListener ( ' readable ' , flow ) ;%NWL%7
if ( readable !== src ) return;%NWL%cleanup ( ) ;%NWL%}%NWL%function onend ( )  {%NWL%dest . end ( ) ;%NWL%}%NWL%var ondrain = pipeOnDrain ( src ) ;%NWL%dest . on ( ' drain ' , ondrain ) ;%NWL%function cleanup ( )  {%NWL%dest . removeListener ( ' close ' , onclose ) ;%NWL%dest . removeListener ( ' drain ' , ondrain ) ;%NWL%7
unpipe ( ) ;%NWL%if ( EE . listenerCount ( dest ,  ' error ' ) === 0 )%NWL%dest . emit ( ' error ' , er ) ;%NWL%}%NWL%dest . once ( ' error ' , onerror ) ;%NWL%function onclose ( )  {%NWL%dest . removeListener ( ' finish ' , onfinish ) ;%NWL%unpipe ( ) ;%NWL%}%NWL%dest . once ( ' close ' , onclose ) ;%NWL%dest . removeListener ( ' close ' , onclose ) ;%NWL%9
}%NWL%dest . once ( ' error ' , onerror ) ;%NWL%function onclose ( )  {%NWL%dest . removeListener ( ' finish ' , onfinish ) ;%NWL%unpipe ( ) ;%NWL%}%NWL%dest . once ( ' close ' , onclose ) ;%NWL%function onfinish ( )  {%NWL%dest . removeListener ( ' close ' , onclose ) ;%NWL%unpipe ( ) ;%NWL%dest . once ( ' finish ' , onfinish ) ;%NWL%3
this . removeListener ( ' readable ' , pipeOnReadable ) ;%NWL%state . flowing = false;%NWL%if ( dest )%NWL%dest . emit ( ' unpipe ' , this ) ;%NWL%return this;%NWL%}%NWL%if ( !dest )  {%NWL%var dests = state . pipes;%NWL%var len = state . pipesCount;%NWL%state . pipes = null;%NWL%this . removeListener ( ' readable ' , pipeOnReadable ) ;%NWL%0
Readable . prototype . on = function ( ev , fn )  {%NWL%var res = Stream . prototype . on . call ( this , ev , fn ) ;%NWL%if ( ev === ' data ' && !this . _readableState . flowing )%NWL%emitDataEvents ( this ) ;%NWL%if ( ev === ' readable ' && !this . _readableState . reading )%NWL%this . read ( 0 ) ;%NWL%return res;%NWL%} ;%NWL%Readable . prototype . addListener = Readable . prototype . on;%NWL%Readable . prototype . resume = function ( )  {%NWL%this . read ( 0 ) ;%NWL%5
} ;%NWL%stream . resume = function ( )  {%NWL%paused = false;%NWL%if ( readable )%NWL%process . nextTick ( function ( )  {%NWL%stream . emit ( ' readable ' ) ;%NWL%} ) ;%NWL%else%NWL%this . read ( 0 ) ;%NWL%this . emit ( ' resume ' ) ;%NWL%stream . emit ( ' readable ' ) ;%NWL%5
var len = state . objectMode ? 1 : chunk . length;%NWL%doWrite ( stream , state , len , chunk , encoding , cb ) ;%NWL%if ( state . writing )  {%NWL%c + + ;%NWL%break;%NWL%}%NWL%}%NWL%state . bufferProcessing = false;%NWL%if ( c < state . buffer . length )%NWL%state . buffer = state . buffer . slice ( c ) ;%NWL%state . buffer . length = 0;%NWL%9
var assert = require ( ' assert ' ) ;%NWL%exports . testDir = path . dirname ( __filename ) ;%NWL%exports . fixturesDir = path . join ( exports . testDir ,  ' fixtures ' ) ;%NWL%exports . libDir = path . join ( exports . testDir ,  ' . . / lib ' ) ;%NWL%exports . tmpDir = path . join ( exports . testDir ,  ' tmp ' ) ;%NWL%exports . PORT = 12346;%NWL%if ( process . platform === ' win32 ' )  {%NWL%exports . PIPE = ' \\\\ . \\pipe\\libuv - test ' ;%NWL%} else {%NWL%exports . PIPE = exports . tmpDir +  ' / test . sock ' ;%NWL%var util = require ( ' util ' ) ;%NWL%0
return spawn ( ' pwd ' ,  [ ] , options ) ;%NWL%}%NWL%} ;%NWL%exports . globalCheck = true;%NWL%process . on ( ' exit ' , function ( )  {%NWL%if ( !exports . globalCheck ) return;%NWL%var knownGlobals = [ setTimeout ,%NWL%setInterval ,%NWL%global . setImmediate ,%NWL%clearTimeout ,%NWL%global . clearImmediate ,%NWL%8
var common = require ( ' . . / common . js ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var R = require ( ' . . / . . / lib / _stream_readable ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var R = require ( ' . . / . . / lib / _stream_readable ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var Readable = require ( ' . . / . . / lib / _stream_readable ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
assert . deepEqual ( v2 ,  { two: ' 2 '  } ) ;%NWL%assert . deepEqual ( v3 , null ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' can pipe objects into stream ' , function ( t )  {%NWL%var r = fromArray ( [ { one: ' 1 ' } ,  { two: ' 2 '  } ] ) ;%NWL%r . pipe ( toArray ( function ( list )  {%NWL%assert . deepEqual ( list ,  [%NWL%{ one: ' 1 '  } ,%NWL%{ two: ' 2 '  }%NWL%t . end ( ) ;%NWL%2
assert . deepEqual ( list ,  [%NWL%{ one: ' 1 '  } ,%NWL%{ two: ' 2 '  }%NWL%] ) ;%NWL%t . end ( ) ;%NWL%} ) ) ;%NWL%} ) ;%NWL%test ( ' read ( n ) is ignored ' , function ( t )  {%NWL%var r = fromArray ( [ { one: ' 1 ' } ,  { two: ' 2 '  } ] ) ;%NWL%var value = r . read ( 2 ) ;%NWL%t . end ( ) ;%NWL%4
assert . equal ( bool , i === 5 ? false : true ) ;%NWL%}%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' can write objects to stream ' , function ( t )  {%NWL%var w = new Writable ( { objectMode: true } ) ;%NWL%w . _write = function ( chunk , encoding , cb )  {%NWL%assert . deepEqual ( chunk ,  { foo: ' bar '  } ) ;%NWL%cb ( ) ;%NWL%} ;%NWL%t . end ( ) ;%NWL%2
var common = require ( ' . . / common . js ' ) ;%NWL%var stream = require ( ' . . / . . / readable ' ) ;%NWL%var Readable = stream . Readable;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var stream = require ( ' . . / . . / readable ' ) ;%NWL%var Readable = stream . Readable;%NWL%var Writable = stream . Writable;%NWL%var util = require ( ' util ' ) ;%NWL%0
process . nextTick ( cb ) ;%NWL%} ;%NWL%writer . on ( ' finish ' , finish ) ;%NWL%var chunk = " asdfg " ;%NWL%var set = 0;%NWL%readStart ( ) ;%NWL%data ( ) ;%NWL%function data ( )  {%NWL%assert ( reading ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%9
writer . on ( ' finish ' , finish ) ;%NWL%var chunk = " asdfg " ;%NWL%var set = 0;%NWL%readStart ( ) ;%NWL%data ( ) ;%NWL%function data ( )  {%NWL%assert ( reading ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%assert ( reading ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%7
var set = 0;%NWL%readStart ( ) ;%NWL%data ( ) ;%NWL%function data ( )  {%NWL%assert ( reading ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%assert ( reading ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%assert ( reading ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%source . emit ( ' data ' , chunk ) ;%NWL%5
} ;%NWL%function drain ( )  {%NWL%assert ( buffered <= 2 ) ;%NWL%buffered = 0;%NWL%w . emit ( ' drain ' ) ;%NWL%}%NWL%var wended = false;%NWL%w . end = function ( )  {%NWL%wended = true;%NWL%} ;%NWL%w . emit ( ' drain ' ) ;%NWL%4
var bytesread = 0;%NWL%test . on ( ' readable ' , function ( )  {%NWL%var b = len - bytesread - 1;%NWL%var res = test . read ( b ) ;%NWL%if ( res )  {%NWL%bytesread + = res . length;%NWL%console . error ( ' br=%d len=%d ' , bytesread , len ) ;%NWL%setTimeout ( next ) ;%NWL%}%NWL%test . read ( 0 ) ;%NWL%test . read ( 0 ) ;%NWL%9
var common = require ( ' . . / common . js ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var path = require ( ' path ' ) ;%NWL%var View = require ( ' . / govuk ' ) ;%NWL%var templatePath = path . resolve ( __dirname ,  ' . . / templates / error . html ' ) ;%NWL%module . exports = View . extend ( {%NWL%var status = this . model . get ( ' status ' ) ;%NWL%0
ret . fill ( ' x ' ) ;%NWL%pt . push ( ret ) ;%NWL%cb ( ) ;%NWL%} ;%NWL%pt . write ( new Buffer ( ' foog ' ) ) ;%NWL%pt . write ( new Buffer ( ' bark ' ) ) ;%NWL%pt . write ( new Buffer ( ' bazy ' ) ) ;%NWL%pt . write ( new Buffer ( ' kuel ' ) ) ;%NWL%pt . end ( ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' xxxxx ' ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' xxxxx ' ) ;%NWL%9
t . equal ( pt . read ( 5 ) . toString ( ) ,  ' zykue ' ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' l ' ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' assymetric transform ( expand ) ' , function ( t )  {%NWL%var pt = new Transform;%NWL%pt . _transform = function ( chunk , encoding , cb )  {%NWL%setTimeout ( function ( )  {%NWL%pt . push ( chunk ) ;%NWL%pt . push ( chunk ) ;%NWL%9
var s = chunk . toString ( ) ;%NWL%setTimeout ( function ( )  {%NWL%this . state + = s . charAt ( 0 ) ;%NWL%if ( this . state . length === 3 )  {%NWL%pt . push ( new Buffer ( this . state ) ) ;%NWL%this . state = ' ' ;%NWL%}%NWL%cb ( ) ;%NWL%} . bind ( this ) , 10 ) ;%NWL%} ;%NWL%pt . push ( new Buffer ( this . state ) ) ;%NWL%4
} ;%NWL%pt . _flush = function ( cb )  {%NWL%pt . push ( new Buffer ( this . state ) ) ;%NWL%this . state = ' ' ;%NWL%cb ( ) ;%NWL%} ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%6
pt . _flush = function ( cb )  {%NWL%pt . push ( new Buffer ( this . state ) ) ;%NWL%this . state = ' ' ;%NWL%cb ( ) ;%NWL%} ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%6
pt . push ( new Buffer ( this . state ) ) ;%NWL%this . state = ' ' ;%NWL%cb ( ) ;%NWL%} ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%6
this . state = ' ' ;%NWL%cb ( ) ;%NWL%} ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%6
cb ( ) ;%NWL%} ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%6
} ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%1
pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%1
pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%1
pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' cccc ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%pt . write ( new Buffer ( ' eeee ' ) ) ;%NWL%pt . write ( new Buffer ( ' aaaa ' ) ) ;%NWL%pt . write ( new Buffer ( ' bbbb ' ) ) ;%NWL%pt . write ( new Buffer ( ' dddd ' ) ) ;%NWL%1
console . error ( ' should have emitted , but not again ' ) ;%NWL%pt . write ( new Buffer ( ' kuel ' ) ) ;%NWL%console . error ( ' should have emitted readable now 2 === %d ' , emits ) ;%NWL%t . equal ( emits , 2 ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' arkba ' ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' zykue ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%console . error ( ' need emit 2 ' ) ;%NWL%pt . end ( ) ;%NWL%t . equal ( emits , 3 ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%6
console . error ( ' should have emitted readable now 2 === %d ' , emits ) ;%NWL%t . equal ( emits , 2 ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' arkba ' ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' zykue ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%console . error ( ' need emit 2 ' ) ;%NWL%pt . end ( ) ;%NWL%t . equal ( emits , 3 ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' l ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%t . equal ( emits , 3 ) ;%NWL%7
} ) ;%NWL%pt . write ( new Buffer ( ' foog ' ) ) ;%NWL%console . error ( ' need emit 0 ' ) ;%NWL%pt . write ( new Buffer ( ' bark ' ) ) ;%NWL%console . error ( ' should have emitted readable now 1 === %d ' , emits ) ;%NWL%t . equal ( emits , 1 ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' foogb ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%console . error ( ' need emit 1 ' ) ;%NWL%pt . once ( ' readable ' , function ( )  {%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%7
console . error ( ' should have emitted readable now 1 === %d ' , emits ) ;%NWL%t . equal ( emits , 1 ) ;%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' foogb ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%console . error ( ' need emit 1 ' ) ;%NWL%pt . once ( ' readable ' , function ( )  {%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' arkba ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%console . error ( ' need emit 2 ' ) ;%NWL%pt . once ( ' readable ' , function ( )  {%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%3
t . equal ( pt . read ( 5 ) , null ) ;%NWL%console . error ( ' need emit 1 ' ) ;%NWL%pt . once ( ' readable ' , function ( )  {%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' arkba ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%console . error ( ' need emit 2 ' ) ;%NWL%pt . once ( ' readable ' , function ( )  {%NWL%t . equal ( pt . read ( 5 ) . toString ( ) ,  ' zykue ' ) ;%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%pt . once ( ' readable ' , function ( )  {%NWL%t . equal ( pt . read ( 5 ) , null ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var crypto = require ( ' crypto ' ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var stream = require ( ' . . / . . / readable ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
var crypto = require ( ' crypto ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%function TestWriter ( )  {%NWL%stream . Writable . call ( this ) ;%NWL%}%NWL%util . inherits ( TestWriter , stream . Writable ) ;%NWL%TestWriter . prototype . _write = function ( buffer , encoding , callback )  {%NWL%console . log ( ' write called ' ) ;%NWL%} ;%NWL%var dest = new TestWriter ( ) ;%NWL%stream . Readable . call ( this ) ;%NWL%3
this . reads + = 1;%NWL%this . push ( crypto . randomBytes ( size ) ) ;%NWL%} ;%NWL%var src1 = new TestReader ( ) ;%NWL%var src2 = new TestReader ( ) ;%NWL%src1 . pipe ( dest ) ;%NWL%src1 . once ( ' readable ' , function ( )  {%NWL%process . nextTick ( function ( )  {%NWL%src2 . pipe ( dest ) ;%NWL%src2 . once ( ' readable ' , function ( )  {%NWL%src1 . unpipe ( dest ) ;%NWL%5
var common = require ( ' . . / common . js ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%var stream = require ( ' . . / . . / readable ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
assert . equal ( src . listeners ( ' end ' ) . length , 0 ) ;%NWL%assert . equal ( src . listeners ( ' readable ' ) . length , 0 ) ;%NWL%assert . equal ( dest . listeners ( ' unpipe ' ) . length , 0 ) ;%NWL%assert . equal ( dest . listeners ( ' drain ' ) . length , 0 ) ;%NWL%assert . equal ( dest . listeners ( ' error ' ) . length , 0 ) ;%NWL%assert . equal ( dest . listeners ( ' close ' ) . length , 0 ) ;%NWL%assert . equal ( dest . listeners ( ' finish ' ) . length , 0 ) ;%NWL%console . error ( src . _readableState ) ;%NWL%process . on ( ' exit ' , function ( )  {%NWL%assert ( src . _readableState . length >= src . _readableState . highWaterMark ) ;%NWL%console . error ( src . _readableState ) ;%NWL%7
var common = require ( ' . . / common . js ' ) ;%NWL%var W = require ( ' . . / . . / lib / _stream_writable ' ) ;%NWL%var assert = require ( ' assert ' ) ;%NWL%0
var common = require ( ' . . / common . js ' ) ;%NWL%var W = require ( ' . . / . . / lib / _stream_writable ' ) ;%NWL%var D = require ( ' . . / . . / lib / _stream_duplex ' ) ;%NWL%var util = require ( ' util ' ) ;%NWL%0
t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%chunks . forEach ( function ( chunk , i )  {%NWL%tw . write ( chunk , callbacks [ ' callback - '  + i ] ) ;%NWL%} ) ;%NWL%tw . end ( ) ;%NWL%} ) ;%NWL%test ( ' end callback ' , function ( t )  {%NWL%var tw = new TestWriter ( ) ;%NWL%t . end ( ) ;%NWL%0
tw . end ( ) ;%NWL%} ) ;%NWL%test ( ' end callback ' , function ( t )  {%NWL%var tw = new TestWriter ( ) ;%NWL%tw . end ( function ( )  {%NWL%t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' end callback with chunk ' , function ( t )  {%NWL%var tw = new TestWriter ( ) ;%NWL%t . end ( ) ;%NWL%5
} ) ;%NWL%} ) ;%NWL%test ( ' end callback with chunk ' , function ( t )  {%NWL%var tw = new TestWriter ( ) ;%NWL%tw . end ( new Buffer ( ' hello world ' ) , function ( )  {%NWL%t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' end callback with chunk and encoding ' , function ( t )  {%NWL%var tw = new TestWriter ( ) ;%NWL%t . end ( ) ;%NWL%5
} ) ;%NWL%test ( ' end callback with chunk and encoding ' , function ( t )  {%NWL%var tw = new TestWriter ( ) ;%NWL%tw . end ( ' hello world ' ,  ' ascii ' , function ( )  {%NWL%t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' end callback after . write ( ) call ' , function ( t )  {%NWL%var tw = new TestWriter ( ) ;%NWL%tw . write ( new Buffer ( ' hello world ' ) ) ;%NWL%t . end ( ) ;%NWL%4
var tw = new TestWriter ( ) ;%NWL%tw . write ( new Buffer ( ' hello world ' ) ) ;%NWL%tw . end ( function ( )  {%NWL%t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' encoding should be ignored for buffers ' , function ( t )  {%NWL%var tw = new W ( ) ;%NWL%var hex = ' 018b5e9a8f6236ffe30e31baf80d2cf6eb ' ;%NWL%tw . _write = function ( chunk , encoding , cb )  {%NWL%t . end ( ) ;%NWL%3
var requirejs = require ( ' requirejs ' ) ;%NWL%var serialize = require ( ' serialize - javascript ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var serialize = require ( ' serialize - javascript ' ) ;%NWL%var templater = require ( ' . . / mixins / templater ' ) ;%NWL%0
' Date extensions ' : {%NWL%topic: function ( )  {%NWL%return new Date ( 2010 , 0 , 11 , 14 , 31 , 30 , 5 ) ;%NWL%} ,%NWL%' should format a date as string using a pattern ' : function ( date )  {%NWL%assert . equal (%NWL%dateFormat . asString ( dateFormat . DATETIME_FORMAT , date ) ,%NWL%" 11 01 2010 14:31:30 . 005 "%NWL%) ;%NWL%} ,%NWL%assert . equal (%NWL%5
var vows = require ( ' vows ' ) ,%NWL%assert = require ( ' assert ' ) ;%NWL%vows . describe ( ' log4js global loglevel ' ) . addBatch ( {%NWL%' global loglevel ' : {%NWL%var log4js = require ( ' . . / lib / log4js ' ) ;%NWL%0
var vows = require ( ' vows ' ) ,%NWL%assert = require ( ' assert ' ) ;%NWL%vows . describe ( ' log4js global loglevel ' ) . addBatch ( {%NWL%' global loglevel ' : {%NWL%topic: function ( )  {%NWL%var log4js = require ( ' . . / lib / log4js ' ) ;%NWL%return log4js;%NWL%} ,%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%0
var log4js = require ( ' . . / lib / log4js ' ) ;%NWL%return log4js;%NWL%} ,%NWL%' set global loglevel on creation ' : function ( log4js )  {%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , level ) ;%NWL%9
return log4js;%NWL%} ,%NWL%' set global loglevel on creation ' : function ( log4js )  {%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%log4js . setGlobalLogLevel ( level ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%3
var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%log4js . setGlobalLogLevel ( level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , level ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%} ,%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%7
if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%log4js . setGlobalLogLevel ( level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , level ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%} ,%NWL%' global change loglevel ' : function ( log4js )  {%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%6
assert . equal ( log1 . level . toString ( ) , level ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%} ,%NWL%' global change loglevel ' : function ( log4js )  {%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%0
assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%} ,%NWL%' global change loglevel ' : function ( log4js )  {%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , level ) ;%NWL%9
var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%log4js . setGlobalLogLevel ( level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , level ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%} ,%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%0
log4js . setGlobalLogLevel ( level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , level ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%} ,%NWL%' override loglevel ' : function ( log4js )  {%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%1
if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%var oldLevel = log1 . level . toString ( ) ;%NWL%assert . equal ( log2 . level . toString ( ) , oldLevel ) ;%NWL%log2 . setLevel ( level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , oldLevel ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%assert . notEqual ( oldLevel , level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , oldLevel ) ;%NWL%7
level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%var oldLevel = log1 . level . toString ( ) ;%NWL%assert . equal ( log2 . level . toString ( ) , oldLevel ) ;%NWL%log2 . setLevel ( level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , oldLevel ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%assert . notEqual ( oldLevel , level ) ;%NWL%log2 . removeLevel ( ) ;%NWL%assert . equal ( log2 . level . toString ( ) , oldLevel ) ;%NWL%4
} ,%NWL%' preload loglevel ' : function ( log4js )  {%NWL%var log1 = log4js . getLogger ( ' log1 ' ) ;%NWL%var level = ' OFF ' ;%NWL%if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%var oldLevel = log1 . level . toString ( ) ;%NWL%log4js . getLogger ( ' log2 ' ) . setLevel ( level ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%2
if ( log1 . level . toString ( ) == level )  {%NWL%level = ' TRACE ' ;%NWL%}%NWL%assert . notEqual ( log1 . level . toString ( ) , level ) ;%NWL%var oldLevel = log1 . level . toString ( ) ;%NWL%log4js . getLogger ( ' log2 ' ) . setLevel ( level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , oldLevel ) ;%NWL%var log2 = log4js . getLogger ( ' log2 ' ) ;%NWL%assert . equal ( log2 . level . toString ( ) , level ) ;%NWL%assert . notEqual ( oldLevel , level ) ;%NWL%assert . equal ( log1 . level . toString ( ) , oldLevel ) ;%NWL%6
fakeHookIo . Hook . prototype . on = function ( eventName , functionToExec )  {%NWL%result . ons [ eventName ] = { functionToExec: functionToExec } ;%NWL%if ( eventName === ' hook::ready ' )  {%NWL%functionToExec ( ) ;%NWL%}%NWL%} ;%NWL%fakeHookIo . Hook . prototype . emit = function ( eventName , data )  {%NWL%result . emissions [ eventName ] = result . emissions [ eventName ] || [ ] ;%NWL%result . emissions [ eventName ] . push ( { data: data } ) ;%NWL%var on = ' * :: '  + eventName;%NWL%result . ons [ on ] . callingCount = result . ons [ on ] . callingCount ? result . ons [ on ] . callingCount + = 1 : 1;%NWL%7
colour: " green "%NWL%, toString: function ( )  { return " ERROR " ; }%NWL%}%NWL%} ) ;%NWL%} ,%NWL%' should print error the contained error message ' : function ( layoutOutput )  {%NWL%var m = layoutOutput . match ( / \ { \ [ Error: My Unique Error Message\ ] / ) ;%NWL%assert . isArray ( m ) ;%NWL%} ,%NWL%' should print error augmented string attributes ' : function ( layoutOutput )  {%NWL%assert . isArray ( m ) ;%NWL%7
} ,%NWL%' should print error the contained error message ' : function ( layoutOutput )  {%NWL%var m = layoutOutput . match ( / \ { \ [ Error: My Unique Error Message\ ] / ) ;%NWL%assert . isArray ( m ) ;%NWL%} ,%NWL%' should print error augmented string attributes ' : function ( layoutOutput )  {%NWL%var m = layoutOutput . match ( / augmented:\s ' My Unique attribute value ' / ) ;%NWL%assert . isArray ( m ) ;%NWL%} ,%NWL%' should print error augmented object attributes ' : function ( layoutOutput )  {%NWL%assert . isArray ( m ) ;%NWL%3
} ,%NWL%' toLevel ' : {%NWL%' with lowercase argument ' : {%NWL%topic: levels . toLevel ( " debug " ) ,%NWL%' should take the string and return the corresponding level ' : function ( level )  {%NWL%assert . equal ( level , levels . DEBUG ) ;%NWL%}%NWL%} ,%NWL%' with uppercase argument ' : {%NWL%topic: levels . toLevel ( " DEBUG " ) ,%NWL%assert . equal ( level , levels . DEBUG ) ;%NWL%5
}%NWL%} ,%NWL%' with uppercase argument ' : {%NWL%topic: levels . toLevel ( " DEBUG " ) ,%NWL%' should take the string and return the corresponding level ' : function ( level )  {%NWL%assert . equal ( level , levels . DEBUG ) ;%NWL%}%NWL%} ,%NWL%' with varying case ' : {%NWL%topic: levels . toLevel ( " DeBuG " ) ,%NWL%assert . equal ( level , levels . DEBUG ) ;%NWL%5
) ;%NWL%log4js . clearAppenders ( ) ;%NWL%log4js . addAppender ( function ( evt )  {%NWL%logEvents . push ( evt ) ;%NWL%} ) ;%NWL%return { log4js: log4js , logEvents: logEvents , fakeConsole: fakeConsole } ;%NWL%}%NWL%vows . describe ( ' log4js ' ) . addBatch ( {%NWL%' getLogger ' : {%NWL%topic: function ( )  {%NWL%log4js . clearAppenders ( ) ;%NWL%1
' configure ' : {%NWL%topic: function ( )  {%NWL%var log4js = require ( ' . . / lib / log4js ' )%NWL%, logger;%NWL%remove ( __dirname +  ' / logLevelFilter . log ' ) ;%NWL%remove ( __dirname +  ' / logLevelFilter - warnings . log ' ) ;%NWL%log4js . configure ( ' test / with - logLevelFilter . json ' ) ;%NWL%logger = log4js . getLogger ( " tests " ) ;%NWL%logger . info ( ' main ' ) ;%NWL%logger . error ( ' both ' ) ;%NWL%logger . debug ( ' main ' ) ;%NWL%8
{%NWL%requires: {%NWL%' net ' : fakeNet%NWL%}%NWL%}%NWL%) . appender ( { mode: ' worker ' , loggerPort: 1234 , loggerHost: ' pants '  } ) ;%NWL%appender ( ' before connect ' ) ;%NWL%fakeNet . cbs [ ' connect ' ] ( ) ;%NWL%appender ( ' after connect ' ) ;%NWL%fakeNet . cbs [ ' close ' ] ( true ) ;%NWL%fakeNet . cbs [ ' connect ' ] ( ) ;%NWL%7
appender ( ' after error , after connect ' ) ;%NWL%return fakeNet;%NWL%} ,%NWL%' should open a socket to the loggerPort and loggerHost ' : function ( net )  {%NWL%assert . equal ( net . port , 1234 ) ;%NWL%assert . equal ( net . host ,  ' pants ' ) ;%NWL%} ,%NWL%' should buffer messages written before socket is connected ' : function ( net )  {%NWL%assert . equal ( net . data [ 0 ] , JSON . stringify ( ' before connect ' ) ) ;%NWL%} ,%NWL%assert . equal ( net . data [ 0 ] , JSON . stringify ( ' before connect ' ) ) ;%NWL%8
' net ' : fakeNet%NWL%}%NWL%}%NWL%) . appender ( { mode: ' worker '  } ) ;%NWL%appender ( ' before connect ' ) ;%NWL%fakeNet . cbs [ ' connect ' ] ( ) ;%NWL%appender ( ' after connect ' ) ;%NWL%fakeNet . cbs [ ' timeout ' ] ( ) ;%NWL%appender ( ' after timeout , before close ' ) ;%NWL%fakeNet . cbs [ ' close ' ] ( ) ;%NWL%fakeNet . cbs [ ' connect ' ] ( ) ;%NWL%5
var vows = require ( ' vows ' ) ;%NWL%var log4js = require ( ' . . / lib / log4js ' ) ;%NWL%0
' with stream arguments ' : {%NWL%topic: new DateRollingFileStream ( __dirname +  ' / test - date - rolling - file - stream - 3 ' ,  ' yyyy - MM - dd ' ,  { mode: 0666 } ) ,%NWL%teardown: cleanUp ( __dirname +  ' / test - date - rolling - file - stream - 3 ' ) ,%NWL%' should pass them to the underlying stream ' : function ( stream )  {%NWL%assert . equal ( stream . theStream . mode , 0666 ) ;%NWL%}%NWL%} ,%NWL%' with stream arguments but no pattern ' : {%NWL%topic: new DateRollingFileStream ( __dirname +  ' / test - date - rolling - file - stream - 4 ' ,  { mode: 0666 } ) ,%NWL%teardown: cleanUp ( __dirname +  ' / test - date - rolling - file - stream - 4 ' ) ,%NWL%assert . equal ( stream . theStream . mode , 0666 ) ;%NWL%4
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / module ' ) ;%NWL%var templatePath = path . resolve ( __dirname ,  ' . . / templates / module . html ' ) ;%NWL%var Table = requirejs ( ' extensions / views / table ' ) ;%NWL%var templater = require ( ' . . / mixins / templater ' ) ;%NWL%0
t . equal ( cache . max , 10 )%NWL%t . end ( )%NWL%} )%NWL%test ( " least recently set " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . end ( )%NWL%1
var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%cache . set ( " a " ,  " A " )%NWL%1
cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " b " ,  " B " )%NWL%1
cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . set ( " c " ,  " C " )%NWL%0
t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " lru recently gotten " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . end ( )%NWL%0
cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . equal ( cache . get ( " a " ) ,  " A " )%NWL%t . end ( )%NWL%} )%NWL%test ( " del " , function ( t )  {%NWL%cache . set ( " a " ,  " A " )%NWL%0
cache . set ( " b " ,  " B " )%NWL%cache . get ( " a " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . equal ( cache . get ( " a " ) ,  " A " )%NWL%t . end ( )%NWL%} )%NWL%test ( " del " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . del ( " a " )%NWL%1
cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) , undefined )%NWL%t . equal ( cache . get ( " a " ) ,  " A " )%NWL%t . end ( )%NWL%} )%NWL%test ( " del " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . del ( " a " )%NWL%t . end ( )%NWL%4
for ( var i = 0; i < 100; i + + ) cache . set ( i , i )%NWL%t . equal ( cache . length , 100 )%NWL%for ( var i = 0; i < 100; i + + )  {%NWL%t . equal ( cache . get ( i ) , i )%NWL%}%NWL%cache . max = 3%NWL%t . equal ( cache . length , 3 )%NWL%for ( var i = 0; i < 97; i + + )  {%NWL%t . equal ( cache . get ( i ) , undefined )%NWL%}%NWL%t . equal ( cache . get ( i ) , i )%NWL%3
t . equal ( cache . length , 3 )%NWL%for ( var i = 0; i < 97; i + + )  {%NWL%t . equal ( cache . get ( i ) , undefined )%NWL%}%NWL%for ( var i = 98; i < 100; i + + )  {%NWL%t . equal ( cache . get ( i ) , i )%NWL%}%NWL%cache . max = " hello "%NWL%for ( var i = 0; i < 100; i + + ) cache . set ( i , i )%NWL%t . equal ( cache . length , 100 )%NWL%t . equal ( cache . get ( i ) , i )%NWL%5
for ( var i = 0; i < 100; i + + ) cache . set ( i , i )%NWL%t . equal ( cache . length , 100 )%NWL%for ( var i = 0; i < 100; i + + )  {%NWL%t . equal ( cache . get ( i ) , i )%NWL%}%NWL%cache . max = 3%NWL%t . equal ( cache . length , 3 )%NWL%for ( var i = 0; i < 97; i + + )  {%NWL%t . equal ( cache . get ( i ) , undefined )%NWL%}%NWL%t . equal ( cache . get ( i ) , i )%NWL%3
t . end ( )%NWL%} )%NWL%test ( " reset " , function ( t )  {%NWL%var cache = new LRU ( 10 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%cache . reset ( )%NWL%t . equal ( cache . length , 0 )%NWL%t . equal ( cache . max , 10 )%NWL%t . equal ( cache . get ( " a " ) , undefined )%NWL%t . end ( )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " weighed length item too large " , function ( t )  {%NWL%var cache = new LRU ( {%NWL%max: 10 ,%NWL%length: function ( item )  { return item . size }%NWL%} )%NWL%t . equal ( cache . max , 10 )%NWL%cache . set ( " key " ,  { val: " value " , size: 50 } )%NWL%t . equal ( cache . length , 0 )%NWL%t . end ( )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " set returns proper booleans " , function ( t )  {%NWL%var cache = new LRU ( {%NWL%max: 5 ,%NWL%length: function ( item )  { return item . length }%NWL%} )%NWL%t . equal ( cache . set ( " a " ,  " A " ) , true )%NWL%t . equal ( cache . set ( " b " ,  " donuts " ) , false )%NWL%t . equal ( cache . set ( " b " ,  " B " ) , true )%NWL%t . end ( )%NWL%0
} )%NWL%test ( " stale " , function ( t )  {%NWL%var cache = new LRU ( {%NWL%maxAge: 10 ,%NWL%stale: true%NWL%} )%NWL%cache . set ( ' foo ' ,  ' bar ' )%NWL%t . equal ( cache . get ( ' foo ' ) ,  ' bar ' )%NWL%t . equal ( cache . has ( ' foo ' ) , true )%NWL%setTimeout ( function ( )  {%NWL%t . equal ( cache . get ( ' foo ' ) ,  ' bar ' )%NWL%7
t . equal ( cache . get ( ' foo ' ) , undefined )%NWL%t . end ( )%NWL%} , 15 )%NWL%} )%NWL%test ( " lru update via set " , function ( t )  {%NWL%var cache = LRU ( { max: 2 } ) ;%NWL%cache . set ( ' foo ' , 1 ) ;%NWL%cache . set ( ' bar ' , 2 ) ;%NWL%cache . del ( ' bar ' ) ;%NWL%cache . set ( ' baz ' , 3 ) ;%NWL%t . equal ( cache . get ( ' foo ' ) , undefined )%NWL%0
t . end ( )%NWL%} )%NWL%test ( " least recently set w / peek " , function ( t )  {%NWL%var cache = new LRU ( 2 )%NWL%cache . set ( " a " ,  " A " )%NWL%cache . set ( " b " ,  " B " )%NWL%t . equal ( cache . peek ( " a " ) ,  " A " )%NWL%cache . set ( " c " ,  " C " )%NWL%t . equal ( cache . get ( " c " ) ,  " C " )%NWL%t . equal ( cache . get ( " b " ) ,  " B " )%NWL%t . end ( )%NWL%0
t . equal ( cache , l )%NWL%t . equal ( key , i . toString ( ) )%NWL%t . equal ( val , i . toString ( 2 ) )%NWL%i - = 1%NWL%} )%NWL%l . get ( 6 )%NWL%l . get ( 8 )%NWL%var order = [ 8 , 6 , 9 , 7 , 5 ]%NWL%var i = 0%NWL%l . forEach ( function ( val , key , cache )  {%NWL%t . equal ( cache , l )%NWL%0
}%NWL%test ( ' no leaks ' , function ( t )  {%NWL%for ( var i = 0; i < 100; i + + )  {%NWL%l . set ( i , new X ) ;%NWL%if ( i % 2 === 0 )%NWL%l . get ( i / 2 )%NWL%}%NWL%gc ( )%NWL%var start = process . memoryUsage ( )%NWL%var startRefs = refs%NWL%l . set ( i , new X ) ;%NWL%3
for ( var i = 0; i < 100; i + + )  {%NWL%l . set ( i , new X ) ;%NWL%if ( i % 2 === 0 )%NWL%l . get ( i / 2 )%NWL%}%NWL%gc ( )%NWL%var start = process . memoryUsage ( )%NWL%var startRefs = refs%NWL%for ( var i = 0; i < 10000; i + + )  {%NWL%l . set ( i , new X ) ;%NWL%l . get ( i / 2 )%NWL%3
var http = require ( ' http ' )%NWL%var sigmund = require ( ' . / sigmund . js ' )%NWL%0
, expect = c [ 1 ] . sort ( alpha )%NWL%, options = c [ 2 ] || { }%NWL%, f = c [ 3 ] || files%NWL%, tapOpts = c [ 4 ] || { }%NWL%var m = new mm . Minimatch ( pattern , options )%NWL%var r = m . makeRe ( )%NWL%var expectRe = regexps [ re + + ]%NWL%tapOpts . re = String ( r ) || JSON . stringify ( r )%NWL%tapOpts . files = JSON . stringify ( f )%NWL%tapOpts . pattern = pattern%NWL%tapOpts . negated = m . negate%NWL%9
t . equivalent ( actual , expect%NWL%, JSON . stringify ( pattern )  +  "  "  + JSON . stringify ( expect )%NWL%, tapOpts )%NWL%t . equal ( tapOpts . re , expectRe , tapOpts )%NWL%} )%NWL%t . comment ( " time= "  +  ( Date . now ( )  - start )  +  " ms " )%NWL%t . end ( )%NWL%} )%NWL%tap . test ( " global leak test " , function ( t )  {%NWL%var globalAfter = Object . keys ( global )%NWL%t . end ( )%NWL%6
, expect = c [ 1 ] . sort ( alpha )%NWL%, options = c [ 2 ] || { }%NWL%, f = c [ 3 ] || files%NWL%, tapOpts = c [ 4 ] || { }%NWL%var Class = mm . defaults ( options ) . Minimatch%NWL%var m = new Class ( pattern ,  { } )%NWL%var r = m . makeRe ( )%NWL%tapOpts . re = String ( r ) || JSON . stringify ( r )%NWL%tapOpts . files = JSON . stringify ( f )%NWL%tapOpts . pattern = pattern%NWL%tapOpts . negated = m . negate%NWL%9
actual . sort ( alpha )%NWL%t . equivalent ( actual , expect%NWL%, JSON . stringify ( pattern )  +  "  "  + JSON . stringify ( expect )%NWL%, tapOpts )%NWL%} )%NWL%t . comment ( " time= "  +  ( Date . now ( )  - start )  +  " ms " )%NWL%t . end ( )%NWL%} )%NWL%tap . test ( " global leak test " , function ( t )  {%NWL%var globalAfter = Object . keys ( global )%NWL%t . end ( )%NWL%6
var path = require ( ' path ' ) ;%NWL%var wordwrap = require ( ' wordwrap ' ) ;%NWL%var inst = Argv ( process . argv . slice ( 2 ) ) ;%NWL%Object . keys ( inst ) . forEach ( function ( key )  {%NWL%Argv [ key ] = typeof inst [ key ] == ' function '%NWL%? inst [ key ] . bind ( inst )%NWL%: inst [ key ] ;%NWL%var exports = module . exports = Argv;%NWL%0
else {%NWL%if ( opt . alias ) self . alias ( key , opt . alias ) ;%NWL%if ( opt . demand ) self . demand ( key ) ;%NWL%if ( typeof opt . default !== ' undefined ' )  {%NWL%self . default ( key , opt . default ) ;%NWL%}%NWL%%NWL%if ( opt . boolean || opt . type === ' boolean ' )  {%NWL%self . boolean ( key ) ;%NWL%}%NWL%self . string ( key ) ;%NWL%8
desc = wordwrap ( switchlen + 4 , wrap ) ( desc )%NWL%. slice ( switchlen + 4 )%NWL%;%NWL%}%NWL%%NWL%var spadding = new Array (%NWL%Math . max ( switchlen - kswitch . length + 3 , 0 )%NWL%) . join ( '  ' ) ;%NWL%%NWL%var dpadding = new Array (%NWL%) . join ( '  ' ) ;%NWL%7
chunk . split ( / \n / ) . forEach ( function ( c )  {%NWL%lines . push (%NWL%new Array ( start + 1 ) . join ( '  ' )%NWL%+ c . replace ( / ^\s + / ,  ' ' )%NWL%) ;%NWL%} ) ;%NWL%}%NWL%else if ( chunk . match ( / \n / ) )  {%NWL%var xs = chunk . split ( / \n / ) ;%NWL%lines [ i ]  + = xs . shift ( ) ;%NWL%lines . push (%NWL%1
var assert = require ( ' assert ' ) ;%NWL%var fs = require ( ' fs ' ) ;%NWL%0
var assert = require ( ' assert ' ) ;%NWL%var wordwrap = require ( ' wordwrap ' ) ;%NWL%var idleness = fs . readFileSync ( __dirname +  ' / idleness . txt ' ,  ' utf8 ' ) ;%NWL%0
var optimist = require ( ' . . / index ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var test = require ( ' tap ' ) . test;%NWL%var $0 = ' node . / '  + path . relative ( process . cwd ( ) , __filename ) ;%NWL%var parse = optimist . parse ( [  ' - b '  ] ) ;%NWL%1
test ( ' short boolean ' , function ( t )  {%NWL%var parse = optimist . parse ( [  ' - b '  ] ) ;%NWL%t . same ( parse ,  { b : true , _ : [ ] , $0 : $0 } ) ;%NWL%t . same ( typeof parse . b ,  ' boolean ' ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' long boolean ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - bool '  ] ) ,%NWL%{ bool : true , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%4
t . end ( ) ;%NWL%} ) ;%NWL%test ( ' long boolean ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - bool '  ] ) ,%NWL%{ bool : true , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%t . same (%NWL%3
optimist . parse ( [  ' - - bool '  ] ) ,%NWL%{ bool : true , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%test ( ' bare ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' foo ' ,  ' bar ' ,  ' baz '  ] ) ,%NWL%{ _ : [  ' foo ' ,  ' bar ' ,  ' baz '  ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%3
t . end ( ) ;%NWL%} ) ;%NWL%%NWL%test ( ' bare ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' foo ' ,  ' bar ' ,  ' baz '  ] ) ,%NWL%{ _ : [  ' foo ' ,  ' bar ' ,  ' baz '  ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%4
t . same (%NWL%optimist . parse ( [  ' foo ' ,  ' bar ' ,  ' baz '  ] ) ,%NWL%{ _ : [  ' foo ' ,  ' bar ' ,  ' baz '  ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' short group ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - cats '  ] ) ,%NWL%{ c : true , a : true , t : true , s : true , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%4
) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' short group ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - cats '  ] ) ,%NWL%{ c : true , a : true , t : true , s : true , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%4
t . same (%NWL%optimist . parse ( [  ' - cats '  ] ) ,%NWL%{ c : true , a : true , t : true , s : true , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' short group next ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - cats ' ,  ' meow '  ] ) ,%NWL%{ c : true , a : true , t : true , s : ' meow ' , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%4
t . end ( ) ;%NWL%} ) ;%NWL%test ( ' short group next ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - cats ' ,  ' meow '  ] ) ,%NWL%{ c : true , a : true , t : true , s : ' meow ' , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%t . same (%NWL%3
optimist . parse ( [  ' - cats ' ,  ' meow '  ] ) ,%NWL%{ c : true , a : true , t : true , s : ' meow ' , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%test ( ' short capture ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost '  ] ) ,%NWL%{ h : ' localhost ' , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%3
t . end ( ) ;%NWL%} ) ;%NWL%%NWL%test ( ' short capture ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost '  ] ) ,%NWL%{ h : ' localhost ' , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%4
t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost '  ] ) ,%NWL%{ h : ' localhost ' , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' short captures ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - p ' ,  ' 555 '  ] ) ,%NWL%{ h : ' localhost ' , p : 555 , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%4
) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' short captures ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - p ' ,  ' 555 '  ] ) ,%NWL%{ h : ' localhost ' , p : 555 , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%4
t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - p ' ,  ' 555 '  ] ) ,%NWL%{ h : ' localhost ' , p : 555 , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' long capture sp ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - pow ' ,  ' xixxle '  ] ) ,%NWL%{ pow : ' xixxle ' , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%4
) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' long capture sp ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - pow ' ,  ' xixxle '  ] ) ,%NWL%{ pow : ' xixxle ' , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%4
) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' long capture eq ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - pow=xixxle '  ] ) ,%NWL%{ pow : ' xixxle ' , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( )%NWL%} ) ;%NWL%t . same (%NWL%4
) ;%NWL%t . end ( )%NWL%} ) ;%NWL%test ( ' long captures sp ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - host ' ,  ' localhost ' ,  ' - - port ' ,  ' 555 '  ] ) ,%NWL%{ host : ' localhost ' , port : 555 , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%4
t . same (%NWL%optimist . parse ( [  ' - - host ' ,  ' localhost ' ,  ' - - port ' ,  ' 555 '  ] ) ,%NWL%{ host : ' localhost ' , port : 555 , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' long captures eq ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - host=localhost ' ,  ' - - port=555 '  ] ) ,%NWL%{ host : ' localhost ' , port : 555 , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%4
) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' long captures eq ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - host=localhost ' ,  ' - - port=555 '  ] ) ,%NWL%{ host : ' localhost ' , port : 555 , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%4
) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' mixed short bool and capture ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - fp ' ,  ' 555 ' ,  ' script . js '  ] ) ,%NWL%{%NWL%f : true , p : 555 , h : ' localhost ' ,%NWL%_ : [  ' script . js '  ] , $0 : $0 ,%NWL%}%NWL%t . end ( ) ;%NWL%1
t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - fp ' ,  ' 555 ' ,  ' script . js '  ] ) ,%NWL%{%NWL%f : true , p : 555 , h : ' localhost ' ,%NWL%_ : [  ' script . js '  ] , $0 : $0 ,%NWL%}%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%t . same (%NWL%0
optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - fp ' ,  ' 555 ' ,  ' script . js '  ] ) ,%NWL%{%NWL%f : true , p : 555 , h : ' localhost ' ,%NWL%_ : [  ' script . js '  ] , $0 : $0 ,%NWL%}%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%test ( ' short and long ' , function ( t )  {%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - fp ' ,  ' 555 ' ,  ' script . js '  ] ) ,%NWL%0
t . end ( ) ;%NWL%} ) ;%NWL%%NWL%test ( ' short and long ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - fp ' ,  ' 555 ' ,  ' script . js '  ] ) ,%NWL%{%NWL%f : true , p : 555 , h : ' localhost ' ,%NWL%_ : [  ' script . js '  ] , $0 : $0 ,%NWL%}%NWL%t . end ( ) ;%NWL%0
test ( ' short and long ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - h ' ,  ' localhost ' ,  ' - fp ' ,  ' 555 ' ,  ' script . js '  ] ) ,%NWL%{%NWL%f : true , p : 555 , h : ' localhost ' ,%NWL%_ : [  ' script . js '  ] , $0 : $0 ,%NWL%}%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%t . same (%NWL%1
f : true , p : 555 , h : ' localhost ' ,%NWL%_ : [  ' script . js '  ] , $0 : $0 ,%NWL%}%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' no ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - no - moo '  ] ) ,%NWL%{ moo : false , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%4
t . end ( ) ;%NWL%} ) ;%NWL%test ( ' no ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - - no - moo '  ] ) ,%NWL%{ moo : false , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%t . same (%NWL%3
optimist . parse ( [  ' - - no - moo '  ] ) ,%NWL%{ moo : false , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%test ( ' multi ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - v ' ,  ' a ' ,  ' - v ' ,  ' b ' ,  ' - v ' ,  ' c '  ] ) ,%NWL%{ v : [ ' a ' , ' b ' , ' c ' ] , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%3
} ) ;%NWL%%NWL%test ( ' multi ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - v ' ,  ' a ' ,  ' - v ' ,  ' b ' ,  ' - v ' ,  ' c '  ] ) ,%NWL%{ v : [ ' a ' , ' b ' , ' c ' ] , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%t . same (%NWL%3
t . same ( typeof argv . y ,  ' number ' ) ;%NWL%t . same ( typeof argv . z ,  ' number ' ) ;%NWL%t . same ( typeof argv . w ,  ' string ' ) ;%NWL%t . same ( typeof argv . hex ,  ' number ' ) ;%NWL%t . same ( typeof argv . _ [ 0 ] ,  ' number ' ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' flag boolean ' , function ( t )  {%NWL%var parse = optimist ( [  ' - t ' ,  ' moo '  ] ) . boolean ( [ ' t ' ] ) . argv;%NWL%t . same ( parse ,  { t : true , _ : [  ' moo '  ] , $0 : $0 } ) ;%NWL%t . end ( ) ;%NWL%5
%NWL%t . same ( typeof parse . x ,  ' boolean ' ) ;%NWL%t . same ( typeof parse . y ,  ' boolean ' ) ;%NWL%t . same ( typeof parse . z ,  ' boolean ' ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' strings '  , function ( t )  {%NWL%var s = optimist ( [  ' - s ' ,  ' 0001234 '  ] ) . string ( ' s ' ) . argv . s;%NWL%t . same ( s ,  ' 0001234 ' ) ;%NWL%t . same ( typeof s ,  ' string ' ) ;%NWL%var x = optimist ( [  ' - x ' ,  ' 56 '  ] ) . string ( ' x ' ) . argv . x;%NWL%7
t . same ( typeof parse . z ,  ' boolean ' ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' strings '  , function ( t )  {%NWL%var s = optimist ( [  ' - s ' ,  ' 0001234 '  ] ) . string ( ' s ' ) . argv . s;%NWL%t . same ( s ,  ' 0001234 ' ) ;%NWL%t . same ( typeof s ,  ' string ' ) ;%NWL%%NWL%var x = optimist ( [  ' - x ' ,  ' 56 '  ] ) . string ( ' x ' ) . argv . x;%NWL%t . same ( x ,  ' 56 ' ) ;%NWL%t . end ( ) ;%NWL%1
t . same ( x ,  ' 56 ' ) ;%NWL%t . same ( typeof x ,  ' string ' ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' stringArgs ' , function ( t )  {%NWL%var s = optimist ( [  '  ' ,  '  '  ] ) . string ( ' _ ' ) . argv . _;%NWL%t . same ( s . length , 2 ) ;%NWL%t . same ( typeof s [ 0 ] ,  ' string ' ) ;%NWL%t . same ( s [ 0 ] ,  '  ' ) ;%NWL%t . same ( typeof s [ 1 ] ,  ' string ' ) ;%NWL%t . end ( ) ;%NWL%2
t . same ( typeof s [ 0 ] ,  ' string ' ) ;%NWL%t . same ( s [ 0 ] ,  '  ' ) ;%NWL%t . same ( typeof s [ 1 ] ,  ' string ' ) ;%NWL%t . same ( s [ 1 ] ,  '  ' ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' slashBreak ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - I / foo / bar / baz '  ] ) ,%NWL%{ I : ' / foo / bar / baz ' , _ : [ ] , $0 : $0 }%NWL%t . same (%NWL%7
t . end ( ) ;%NWL%} ) ;%NWL%test ( ' slashBreak ' , function ( t )  {%NWL%t . same (%NWL%optimist . parse ( [  ' - I / foo / bar / baz '  ] ) ,%NWL%{ I : ' / foo / bar / baz ' , _ : [ ] , $0 : $0 }%NWL%) ;%NWL%t . same (%NWL%optimist . parse ( [  ' - xyz / foo / bar / baz '  ] ) ,%NWL%{ x : true , y : true , z : ' / foo / bar / baz ' , _ : [ ] , $0 : $0 }%NWL%t . end ( ) ;%NWL%0
) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' alias ' , function ( t )  {%NWL%var argv = optimist ( [  ' - f ' ,  ' 11 ' ,  ' - - zoom ' ,  ' 55 '  ] )%NWL%. alias ( ' z ' ,  ' zoom ' )%NWL%. argv%NWL%;%NWL%t . equal ( argv . zoom , 55 ) ;%NWL%t . equal ( argv . z , argv . zoom ) ;%NWL%t . end ( ) ;%NWL%1
;%NWL%t . equal ( argv . zoom , 55 ) ;%NWL%t . equal ( argv . z , argv . zoom ) ;%NWL%t . equal ( argv . f , 11 ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' multiAlias ' , function ( t )  {%NWL%var argv = optimist ( [  ' - f ' ,  ' 11 ' ,  ' - - zoom ' ,  ' 55 '  ] )%NWL%. alias ( ' z ' ,  [  ' zm ' ,  ' zoom '  ] )%NWL%. argv%NWL%t . equal ( argv . zoom , 55 ) ;%NWL%1
t . equal ( argv . zoom , 55 ) ;%NWL%t . equal ( argv . z , argv . zoom ) ;%NWL%t . equal ( argv . f , 11 ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' multiAlias ' , function ( t )  {%NWL%var argv = optimist ( [  ' - f ' ,  ' 11 ' ,  ' - - zoom ' ,  ' 55 '  ] )%NWL%. alias ( ' z ' ,  [  ' zm ' ,  ' zoom '  ] )%NWL%. argv%NWL%;%NWL%t . equal ( argv . z , argv . zoom ) ;%NWL%1
t . equal ( argv . f , 11 ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' multiAlias ' , function ( t )  {%NWL%var argv = optimist ( [  ' - f ' ,  ' 11 ' ,  ' - - zoom ' ,  ' 55 '  ] )%NWL%. alias ( ' z ' ,  [  ' zm ' ,  ' zoom '  ] )%NWL%. argv%NWL%;%NWL%t . equal ( argv . zoom , 55 ) ;%NWL%t . equal ( argv . z , argv . zoom ) ;%NWL%t . equal ( argv . f , 11 ) ;%NWL%0
t . end ( ) ;%NWL%} ) ;%NWL%test ( ' multiAlias ' , function ( t )  {%NWL%var argv = optimist ( [  ' - f ' ,  ' 11 ' ,  ' - - zoom ' ,  ' 55 '  ] )%NWL%. alias ( ' z ' ,  [  ' zm ' ,  ' zoom '  ] )%NWL%. argv%NWL%;%NWL%t . equal ( argv . zoom , 55 ) ;%NWL%t . equal ( argv . z , argv . zoom ) ;%NWL%t . equal ( argv . z , argv . zm ) ;%NWL%t . end ( ) ;%NWL%0
t . end ( ) ;%NWL%} ) ;%NWL%test ( ' boolean default true ' , function ( t )  {%NWL%var argv = optimist . options ( {%NWL%sometrue: {%NWL%boolean: true ,%NWL%default: true%NWL%}%NWL%} ) . argv;%NWL%%NWL%t . end ( ) ;%NWL%0
t . equal ( argv . sometrue , true ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' boolean default false ' , function ( t )  {%NWL%var argv = optimist . options ( {%NWL%somefalse: {%NWL%boolean: true ,%NWL%default: false%NWL%}%NWL%} ) . argv;%NWL%t . end ( ) ;%NWL%1
' $0 ' : $0 ,%NWL%} ;%NWL%t . same ( aliasedArgv , expected ) ;%NWL%t . same ( propertyArgv , expected ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' boolean and - - x=true ' , function ( t )  {%NWL%var parsed = optimist ( [ ' - - boool ' ,  ' - - other=true ' ] ) . boolean ( ' boool ' ) . argv;%NWL%t . same ( parsed . boool , true ) ;%NWL%t . same ( parsed . other ,  ' true ' ) ;%NWL%t . same ( parsed . boool , true ) ;%NWL%8
t . same ( aliasedArgv , expected ) ;%NWL%t . same ( propertyArgv , expected ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' boolean and - - x=true ' , function ( t )  {%NWL%var parsed = optimist ( [ ' - - boool ' ,  ' - - other=true ' ] ) . boolean ( ' boool ' ) . argv;%NWL%t . same ( parsed . boool , true ) ;%NWL%t . same ( parsed . other ,  ' true ' ) ;%NWL%parsed = optimist ( [ ' - - boool ' ,  ' - - other=false ' ] ) . boolean ( ' boool ' ) . argv;%NWL%t . same ( parsed . boool , true ) ;%NWL%t . end ( ) ;%NWL%2
test ( ' usageFail ' , function ( t )  {%NWL%var r = checkUsage ( function ( )  {%NWL%return optimist ( ' - x 10 - z 20 ' . split ( '  ' ) )%NWL%. usage ( ' Usage: $0 - x NUM - y NUM ' )%NWL%. demand ( [ ' x ' , ' y ' ] )%NWL%. argv;%NWL%} ) ;%NWL%t . same (%NWL%r . result ,%NWL%{ x : 10 , z : 20 , _ : [ ] , $0 : ' . / usage '  }%NWL%t . same (%NWL%7
. usage ( ' Usage: $0 - x NUM - y NUM ' )%NWL%. check ( function ( argv )  {%NWL%if ( ! ( ' x ' in argv ) ) throw ' You forgot about - x ' ;%NWL%if ( ! ( ' y ' in argv ) ) throw ' You forgot about - y ' ;%NWL%} )%NWL%. argv;%NWL%} ) ;%NWL%t . same (%NWL%r . result ,%NWL%{ x : 10 , z : 20 , _ : [ ] , $0 : ' . / usage '  }%NWL%t . same (%NWL%7
}%NWL%var r = checkUsage ( function ( )  {%NWL%return optimist ( ' - x 10 - z 20 ' . split ( '  ' ) )%NWL%. usage ( ' Usage: $0 - x NUM - y NUM ' )%NWL%. check ( checker )%NWL%. argv;%NWL%} ) ;%NWL%t . same (%NWL%r . result ,%NWL%{ x : 10 , z : 20 , _ : [ ] , $0 : ' . / usage '  }%NWL%t . same (%NWL%7
test ( ' countFail ' , function ( t )  {%NWL%var r = checkUsage ( function ( )  {%NWL%return optimist ( ' 1 2 - - moo ' . split ( '  ' ) )%NWL%. usage ( ' Usage: $0 [ x ]  [ y ]  [ z ]  { OPTIONS } ' )%NWL%. demand ( 3 )%NWL%. argv;%NWL%} ) ;%NWL%t . same (%NWL%r . result ,%NWL%{ _ : [  ' 1 ' ,  ' 2 '  ] , moo : true , $0 : ' . / usage '  }%NWL%t . same (%NWL%7
baz : 70 ,%NWL%bar : 20 ,%NWL%quux : 30 ,%NWL%} ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%test ( ' rebase ' , function ( t )  {%NWL%t . equal (%NWL%optimist . rebase ( ' / home / substack ' ,  ' / home / substack / foo / bar / baz ' ) ,%NWL%' . / foo / bar / baz '%NWL%t . equal (%NWL%7
t . end ( ) ;%NWL%} ) ;%NWL%test ( ' rebase ' , function ( t )  {%NWL%t . equal (%NWL%optimist . rebase ( ' / home / substack ' ,  ' / home / substack / foo / bar / baz ' ) ,%NWL%' . / foo / bar / baz '%NWL%) ;%NWL%t . equal (%NWL%optimist . rebase ( ' / home / substack / foo / bar / baz ' ,  ' / home / substack ' ) ,%NWL%' . . / . . / . . '%NWL%t . equal (%NWL%3
' . . / pow / zoom . txt '%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%function checkUsage ( f )  {%NWL%var exit = false;%NWL%process . _exit = process . exit;%NWL%process . _env = process . env;%NWL%process . _argv = process . argv;%NWL%process . exit = function ( t )  { exit = true } ;%NWL%process . argv = [  ' . / usage '  ] ;%NWL%9
process . _argv = process . argv;%NWL%process . exit = function ( t )  { exit = true } ;%NWL%process . env = Hash . merge ( process . env ,  { _ : ' node '  } ) ;%NWL%process . argv = [  ' . / usage '  ] ;%NWL%var errors = [ ] ;%NWL%var logs = [ ] ;%NWL%console . _error = console . error;%NWL%console . error = function ( msg )  { errors . push ( msg )  } ;%NWL%console . _log = console . log;%NWL%console . log = function ( msg )  { logs . push ( msg )  } ;%NWL%process . exit = process . _exit;%NWL%1
process . exit = function ( t )  { exit = true } ;%NWL%process . env = Hash . merge ( process . env ,  { _ : ' node '  } ) ;%NWL%process . argv = [  ' . / usage '  ] ;%NWL%var errors = [ ] ;%NWL%var logs = [ ] ;%NWL%console . _error = console . error;%NWL%console . error = function ( msg )  { errors . push ( msg )  } ;%NWL%console . _log = console . log;%NWL%console . log = function ( msg )  { logs . push ( msg )  } ;%NWL%var result = f ( ) ;%NWL%process . env = process . _env;%NWL%0
process . env = Hash . merge ( process . env ,  { _ : ' node '  } ) ;%NWL%process . argv = [  ' . / usage '  ] ;%NWL%var errors = [ ] ;%NWL%var logs = [ ] ;%NWL%console . _error = console . error;%NWL%console . error = function ( msg )  { errors . push ( msg )  } ;%NWL%console . _log = console . log;%NWL%console . log = function ( msg )  { logs . push ( msg )  } ;%NWL%var result = f ( ) ;%NWL%process . exit = process . _exit;%NWL%process . argv = process . _argv;%NWL%0
var which = spawn ( ' which ' ,  [ ' node ' ] ) ;%NWL%%NWL%which . stdout . on ( ' data ' , function ( buf )  {%NWL%t . test (%NWL%testCmd ( buf . toString ( ) . trim ( )  +  ' bin . js ' ,  [ ] )%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%which . stderr . on ( ' data ' , function ( err )  {%NWL%t . end ( ) ;%NWL%6
which . stderr . on ( ' data ' , function ( err )  {%NWL%assert . error ( err ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%} ) ;%NWL%test ( ' whichNodeArgs ' , function ( t )  {%NWL%var which = spawn ( ' which ' ,  [ ' node ' ] ) ;%NWL%which . stdout . on ( ' data ' , function ( buf )  {%NWL%t . test (%NWL%testCmd ( buf . toString ( ) . trim ( )  +  ' bin . js ' ,  [  ' q ' ,  ' r '  ] )%NWL%t . end ( ) ;%NWL%2
test ( ' whichNodeArgs ' , function ( t )  {%NWL%var which = spawn ( ' which ' ,  [ ' node ' ] ) ;%NWL%which . stdout . on ( ' data ' , function ( buf )  {%NWL%t . test (%NWL%testCmd ( buf . toString ( ) . trim ( )  +  ' bin . js ' ,  [  ' q ' ,  ' r '  ] )%NWL%) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%which . stderr . on ( ' data ' , function ( err )  {%NWL%t . end ( ) ;%NWL%6
process . chdir ( oldDir ) ;%NWL%%NWL%bin . stderr . on ( ' data ' , function ( err )  {%NWL%t . error ( err ) ;%NWL%t . end ( ) ;%NWL%} ) ;%NWL%%NWL%bin . stdout . on ( ' data ' , function ( buf )  {%NWL%clearTimeout ( to ) ;%NWL%var _ = JSON . parse ( buf . toString ( ) ) ;%NWL%t . end ( ) ;%NWL%4
var requirejs = require ( ' requirejs ' ) ;%NWL%var SingleStatView = requirejs ( ' common / views / visualisations / volumetrics / number ' ) ;%NWL%module . exports = SingleStatView . extend ( {%NWL%changeOnSelected: false ,%NWL%valueTag: ' p ' ,%NWL%initialize: function ( options )  {%NWL%SingleStatView . prototype . initialize . apply ( this , arguments ) ;%NWL%this . delta = options . delta || 12;%NWL%this . timeAttr = options . timeAttr || ' _start_at ' ;%NWL%7
this . timeAttr = options . timeAttr || ' _start_at ' ;%NWL%} ,%NWL%render: function ( )  {%NWL%SingleStatView . prototype . render . apply ( this , arguments ) ;%NWL%this . $el . find ( ' p:first ' ) . addClass ( ' change impact - number ' ) ;%NWL%this . $el . find ( ' p ' ) . removeClass ( ' increase decrease no - change ' ) ;%NWL%this . $el . find ( ' p ' ) . addClass ( this . trend ) ;%NWL%} ,%NWL%getValue: function ( )  {%NWL%var model = this . collection . last ( ) ;%NWL%this . trend = change . trend;%NWL%0
} )%NWL%}%NWL%function rimrafSync ( p )  {%NWL%try {%NWL%fs . unlinkSync ( p )%NWL%} catch ( er )  {%NWL%if ( er . code === " ENOENT " )%NWL%return%NWL%if ( er . code !== " EPERM " && er . code !== " EISDIR " )%NWL%throw er%NWL%fs . rmdirSync ( p )%NWL%4
try {%NWL%fs . rmdirSync ( p )%NWL%} catch ( er2 )  {%NWL%if ( er2 . code === " ENOENT " )%NWL%return%NWL%if ( er2 . code === " ENOTDIR " )%NWL%throw er%NWL%if ( er2 . code === " ENOTEMPTY " )  {%NWL%fs . readdirSync ( p ) . forEach ( function ( f )  {%NWL%rimrafSync ( path . join ( p , f ) )%NWL%fs . rmdirSync ( p )%NWL%1
function open ( path , flags , mode , cb )  {%NWL%cb = cb || noop%NWL%fs . _curOpen + +%NWL%fs . _originalFs . open . call ( fs , path , flags , mode , function ( er , fd )  {%NWL%if ( er ) onclose ( )%NWL%cb ( er , fd )%NWL%} )%NWL%}%NWL%fs . openSync = function ( path , flags , mode )  {%NWL%var ret%NWL%fs . _curOpen + +%NWL%2
}%NWL%fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%9
fs . lutimesSync = function ( path , at , mt )  {%NWL%return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%8
return fs . utimensatSync ( path , at , mt , constants . AT_SYMLINK_NOFOLLOW )%NWL%}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . fchownSync = chownFixSync ( fs . fchownSync )%NWL%7
}%NWL%} else {%NWL%fs . lutimes = function ( _a , _b , _c , cb )  { process . nextTick ( cb )  }%NWL%fs . lutimesSync = function ( )  { }%NWL%}%NWL%}%NWL%fs . chown = chownFix ( fs . chown )%NWL%fs . fchown = chownFix ( fs . fchown )%NWL%fs . lchown = chownFix ( fs . lchown )%NWL%fs . chownSync = chownFixSync ( fs . chownSync )%NWL%fs . lchownSync = chownFixSync ( fs . lchownSync )%NWL%6
if ( !er || ( !process . getuid || process . getuid ( ) !== 0 )%NWL%&& ( er . code === " EINVAL " || er . code === " EPERM " ) ) return true%NWL%}%NWL%if ( !fs . lchmod )  {%NWL%fs . lchmod = function ( path , mode , cb )  {%NWL%process . nextTick ( cb )%NWL%}%NWL%fs . lchmodSync = function ( )  { }%NWL%}%NWL%if ( !fs . lchown )  {%NWL%process . nextTick ( cb )%NWL%5
t . notEqual ( fs , require ( ' fs ' ) )%NWL%t . end ( )%NWL%} )%NWL%test ( ' open an existing file works ' , function ( t )  {%NWL%var start = fs . _curOpen%NWL%var fd = fs . openSync ( __filename ,  ' r ' )%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . closeSync ( fd )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( __filename ,  ' r ' , function ( er , fd )  {%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%6
test ( ' open an existing file works ' , function ( t )  {%NWL%var start = fs . _curOpen%NWL%var fd = fs . openSync ( __filename ,  ' r ' )%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . closeSync ( fd )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( __filename ,  ' r ' , function ( er , fd )  {%NWL%if ( er ) throw er%NWL%t . equal ( fs . _curOpen , start + 1 )%NWL%fs . close ( fd , function ( er )  {%NWL%t . equal ( fs . _curOpen , start )%NWL%5
var er%NWL%try {%NWL%var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%t . ok ( er ,  ' should throw ' )%NWL%6
try {%NWL%var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%6
var fd = fs . openSync ( ' this file does not exist ' ,  ' r ' )%NWL%} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%6
} catch ( x )  {%NWL%er = x%NWL%}%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( er . code ,  ' ENOENT ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%fs . open ( ' neither does this file ' ,  ' r ' , function ( er , fd )  {%NWL%t . ok ( er ,  ' should throw ' )%NWL%t . notOk ( fd ,  ' should not get an fd ' )%NWL%t . equal ( fs . _curOpen , start )%NWL%6
var test = require ( ' tap ' ) . test%NWL%var fs = require ( ' . . / graceful - fs . js ' )%NWL%0
, MemoryStore = require ( ' . / stores / memory ' )%NWL%, SocketNamespace = require ( ' . / namespace ' )%NWL%, Static = require ( ' . / static ' )%NWL%, EventEmitter = process . EventEmitter;%NWL%exports = module . exports = Manager;%NWL%var defaultTransports = exports . defaultTransports = [%NWL%' websocket '%NWL%,  ' htmlfile '%NWL%,  ' xhr - polling '%NWL%,  ' jsonp - polling '%NWL%var parent = module . parent . exports%NWL%5
this . sequenceNumber = Date . now ( ) | 0;%NWL%%NWL%this . log . info ( ' socket . io started ' ) ;%NWL%} ;%NWL%Manager . prototype . __proto__ = EventEmitter . prototype%NWL%Manager . prototype . __defineGetter__ ( ' store ' , function ( )  {%NWL%var store = this . get ( ' store ' ) ;%NWL%store . manager = this;%NWL%return store;%NWL%} ) ;%NWL%var logger = this . get ( ' logger ' ) ;%NWL%6
} ;%NWL%Manager . prototype . __proto__ = EventEmitter . prototype%NWL%Manager . prototype . __defineGetter__ ( ' store ' , function ( )  {%NWL%var store = this . get ( ' store ' ) ;%NWL%store . manager = this;%NWL%return store;%NWL%} ) ;%NWL%Manager . prototype . __defineGetter__ ( ' log ' , function ( )  {%NWL%var logger = this . get ( ' logger ' ) ;%NWL%logger . level = this . get ( ' log level ' ) || - 1;%NWL%logger . enabled = this . enabled ( ' log ' ) ;%NWL%9
Manager . prototype . get = function ( key )  {%NWL%return this . settings [ key ] ;%NWL%} ;%NWL%Manager . prototype . set = function ( key , value )  {%NWL%if ( arguments . length == 1 ) return this . get ( key ) ;%NWL%this . settings [ key ] = value;%NWL%this . emit ( ' set: '  + key , this . settings [ key ] , key ) ;%NWL%return this;%NWL%} ;%NWL%Manager . prototype . enable = function ( key )  {%NWL%this . emit ( ' set: '  + key , this . settings [ key ] , key ) ;%NWL%6
this . settings [ key ] = value;%NWL%this . emit ( ' set: '  + key , this . settings [ key ] , key ) ;%NWL%return this;%NWL%} ;%NWL%Manager . prototype . enable = function ( key )  {%NWL%this . settings [ key ] = true;%NWL%this . emit ( ' set: '  + key , this . settings [ key ] , key ) ;%NWL%return this;%NWL%} ;%NWL%Manager . prototype . disable = function ( key )  {%NWL%this . emit ( ' set: '  + key , this . settings [ key ] , key ) ;%NWL%1
this . closed = { } ;%NWL%this . rooms = { } ;%NWL%this . roomClients = { } ;%NWL%var self = this;%NWL%this . store . subscribe ( ' handshake ' , function ( id , data )  {%NWL%self . onHandshake ( id , data ) ;%NWL%} ) ;%NWL%this . store . subscribe ( ' connect ' , function ( id )  {%NWL%self . onConnect ( id ) ;%NWL%} ) ;%NWL%self . onOpen ( id ) ;%NWL%8
} ) ;%NWL%this . store . subscribe ( ' connect ' , function ( id )  {%NWL%self . onConnect ( id ) ;%NWL%} ) ;%NWL%this . store . subscribe ( ' open ' , function ( id )  {%NWL%self . onOpen ( id ) ;%NWL%} ) ;%NWL%this . store . subscribe ( ' join ' , function ( id , room )  {%NWL%self . onJoin ( id , room ) ;%NWL%} ) ;%NWL%self . onLeave ( id , room ) ;%NWL%8
} ) ;%NWL%this . store . subscribe ( ' open ' , function ( id )  {%NWL%self . onOpen ( id ) ;%NWL%} ) ;%NWL%this . store . subscribe ( ' join ' , function ( id , room )  {%NWL%self . onJoin ( id , room ) ;%NWL%} ) ;%NWL%this . store . subscribe ( ' leave ' , function ( id , room )  {%NWL%self . onLeave ( id , room ) ;%NWL%} ) ;%NWL%self . onClose ( id ) ;%NWL%2
} ) ;%NWL%this . store . subscribe ( ' leave ' , function ( id , room )  {%NWL%self . onLeave ( id , room ) ;%NWL%} ) ;%NWL%this . store . subscribe ( ' close ' , function ( id )  {%NWL%self . onClose ( id ) ;%NWL%} ) ;%NWL%this . store . subscribe ( ' dispatch ' , function ( room , packet , volatile , exceptions )  {%NWL%self . onDispatch ( room , packet , volatile , exceptions ) ;%NWL%} ) ;%NWL%self . onDisconnect ( id ) ;%NWL%5
}%NWL%return;%NWL%}%NWL%if ( data . protocol != protocol )  {%NWL%res . writeHead ( 500 ) ;%NWL%res . end ( ' Protocol version not supported . ' ) ;%NWL%this . log . info ( ' client protocol version unsupported ' ) ;%NWL%} else {%NWL%if ( data . id )  {%NWL%this . handleHTTPRequest ( data , req , res ) ;%NWL%this . handleHandshake ( data , req , res ) ;%NWL%9
socket . end ( ) ;%NWL%this . log . debug ( ' destroying non - socket . io upgrade ' ) ;%NWL%}%NWL%return;%NWL%}%NWL%req . head = head;%NWL%this . handleClient ( data , req ) ;%NWL%req . head = null;%NWL%} ;%NWL%Manager . prototype . handleHTTPRequest = function ( data , req , res )  {%NWL%this . handleClient ( data , req ) ;%NWL%6
if ( this . transports [ data . id ] && this . transports [ data . id ] . open )  {%NWL%this . transports [ data . id ] . onForcedDisconnect ( ) ;%NWL%} else {%NWL%this . store . publish ( ' disconnect - force: '  + data . id ) ;%NWL%}%NWL%req . res . writeHead ( 200 ) ;%NWL%req . res . end ( ) ;%NWL%return;%NWL%}%NWL%if ( !~this . get ( ' transports ' ) . indexOf ( data . transport ) )  {%NWL%req . connection . end ( ) ;%NWL%6
req . res . end ( ) ;%NWL%return;%NWL%}%NWL%if ( !~this . get ( ' transports ' ) . indexOf ( data . transport ) )  {%NWL%this . log . warn ( ' unknown transport: " '  + data . transport +  ' " ' ) ;%NWL%req . connection . end ( ) ;%NWL%return;%NWL%}%NWL%var transport = new transports [ data . transport ] ( this , data , req )%NWL%, handshaken = this . handshaken [ data . id ] ;%NWL%req . connection . end ( ) ;%NWL%0
if ( handshaken )  {%NWL%if ( transport . open )  {%NWL%if ( this . closed [ data . id ] && this . closed [ data . id ] . length )  {%NWL%transport . payload ( this . closed [ data . id ] ) ;%NWL%this . closed [ data . id ] = [ ] ;%NWL%}%NWL%this . onOpen ( data . id ) ;%NWL%this . store . publish ( ' open ' , data . id ) ;%NWL%this . transports [ data . id ] = transport;%NWL%}%NWL%this . onConnect ( data . id ) ;%NWL%6
var reasons = exports . reasons = {%NWL%' transport not supported ' : 0%NWL%,  ' client not handshaken ' : 1%NWL%,  ' unauthorized ' : 2%NWL%}%NWL%, reasonslist = Object . keys ( reasons ) ;%NWL%var advice = exports . advice = {%NWL%' reconnect ' : 0%NWL%}%NWL%, advicelist = Object . keys ( advice ) ;%NWL%var type = packets [ packet . type ]%NWL%0
packet . ack = ' data ' ;%NWL%else%NWL%packet . ack = true;%NWL%}%NWL%switch ( packet . type )  {%NWL%case ' message ' :%NWL%packet . data = data || ' ' ;%NWL%break;%NWL%case ' event ' :%NWL%pieces = parse ( data ) ;%NWL%packet . name = pieces . name;%NWL%6
else%NWL%packet . ack = true;%NWL%}%NWL%switch ( packet . type )  {%NWL%case ' message ' :%NWL%packet . data = data || ' ' ;%NWL%break;%NWL%case ' event ' :%NWL%pieces = parse ( data ) ;%NWL%if ( pieces )  {%NWL%packet . args = pieces . args;%NWL%5
}%NWL%switch ( packet . type )  {%NWL%case ' message ' :%NWL%packet . data = data || ' ' ;%NWL%break;%NWL%case ' event ' :%NWL%pieces = parse ( data ) ;%NWL%if ( pieces )  {%NWL%packet . name = pieces . name;%NWL%packet . args = pieces . args;%NWL%packet . args = packet . args || [ ] ;%NWL%3
var accept = req . headers [ ' accept - encoding ' ] || ' '%NWL%, gzip = !!~accept . toLowerCase ( ) . indexOf ( ' gzip ' )%NWL%, mime = reply . mime%NWL%, versioned = reply . versioned%NWL%, headers = {%NWL%' Content - Type ' : mime . type%NWL%} ;%NWL%if ( self . manager . enabled ( ' browser client etag ' ) && reply . etag && !versioned )  {%NWL%headers [ ' Etag ' ] = reply . etag;%NWL%}%NWL%var expires = self . manager . get ( ' browser client expires ' ) ;%NWL%0
return this . manager . store;%NWL%} ) ;%NWL%Transport . prototype . handleRequest = function ( req )  {%NWL%this . log . debug ( ' setting request ' , req . method , req . url ) ;%NWL%this . req = req;%NWL%if ( req . method == ' GET ' )  {%NWL%this . socket = req . socket;%NWL%this . open = true;%NWL%this . drained = true;%NWL%this . setHeartbeatInterval ( ) ;%NWL%this . onSocketConnect ( ) ;%NWL%9
this . setHandlers ( ) ;%NWL%this . onSocketConnect ( ) ;%NWL%}%NWL%} ;%NWL%Transport . prototype . onSocketConnect = function ( )  {  } ;%NWL%Transport . prototype . setHandlers = function ( )  {%NWL%var self = this;%NWL%this . store . subscribe ( ' heartbeat - clear: '  + this . id , function ( )  {%NWL%self . onHeartbeatClear ( ) ;%NWL%} ) ;%NWL%self . onForcedDisconnect ( ) ;%NWL%8
Transport . prototype . onSocketError = function ( err )  {%NWL%if ( this . open )  {%NWL%this . socket . destroy ( ) ;%NWL%this . onClose ( ) ;%NWL%}%NWL%this . log . info ( ' socket error '  + err . stack ) ;%NWL%} ;%NWL%Transport . prototype . onSocketDrain = function ( )  {%NWL%this . drained = true;%NWL%} ;%NWL%this . clearHeartbeatTimeout ( ) ;%NWL%3
if ( this . open )  {%NWL%this . socket . destroy ( ) ;%NWL%this . onClose ( ) ;%NWL%}%NWL%this . log . info ( ' socket error '  + err . stack ) ;%NWL%} ;%NWL%Transport . prototype . onSocketDrain = function ( )  {%NWL%this . drained = true;%NWL%} ;%NWL%Transport . prototype . onHeartbeatClear = function ( )  {%NWL%this . setHeartbeatInterval ( ) ;%NWL%2
this . log . info ( ' transport end by forced client disconnection ' ) ;%NWL%if ( this . open )  {%NWL%this . packet ( { type: ' disconnect '  } ) ;%NWL%}%NWL%this . end ( ' booted ' ) ;%NWL%}%NWL%} ;%NWL%Transport . prototype . onDispatch = function ( packet , volatile )  {%NWL%if ( volatile )  {%NWL%this . writeVolatile ( packet ) ;%NWL%this . write ( packet ) ;%NWL%9
var self = this;%NWL%this . heartbeatInterval = setTimeout ( function ( )  {%NWL%self . heartbeat ( ) ;%NWL%self . heartbeatInterval = null;%NWL%} , this . manager . get ( ' heartbeat interval ' )  * 1000 ) ;%NWL%this . log . debug ( ' set heartbeat interval for client ' , this . id ) ;%NWL%}%NWL%} ;%NWL%Transport . prototype . clearTimeouts = function ( )  {%NWL%this . clearCloseTimeout ( ) ;%NWL%this . clearHeartbeatInterval ( ) ;%NWL%9
}%NWL%} ;%NWL%Transport . prototype . clearTimeouts = function ( )  {%NWL%this . clearCloseTimeout ( ) ;%NWL%this . clearHeartbeatTimeout ( ) ;%NWL%this . clearHeartbeatInterval ( ) ;%NWL%} ;%NWL%Transport . prototype . heartbeat = function ( )  {%NWL%if ( this . open )  {%NWL%this . log . debug ( ' emitting heartbeat for client ' , this . id ) ;%NWL%this . setHeartbeatTimeout ( ) ;%NWL%3
if ( ' heartbeat ' == packet . type )  {%NWL%this . log . debug ( ' got heartbeat packet ' ) ;%NWL%if ( current && current . open )  {%NWL%current . onHeartbeatClear ( ) ;%NWL%} else {%NWL%this . store . publish ( ' heartbeat - clear: '  + this . id ) ;%NWL%}%NWL%} else {%NWL%if ( ' disconnect ' == packet . type && packet . endpoint == ' ' )  {%NWL%this . log . debug ( ' got disconnection packet ' ) ;%NWL%current . onForcedDisconnect ( ) ;%NWL%3
this . end ( reason ) ;%NWL%return this;%NWL%} ;%NWL%Transport . prototype . close = function ( )  {%NWL%if ( this . open )  {%NWL%this . doClose ( ) ;%NWL%this . onClose ( ) ;%NWL%}%NWL%} ;%NWL%Transport . prototype . onClose = function ( )  {%NWL%this . setCloseTimeout ( ) ;%NWL%5
return this;%NWL%} ;%NWL%Transport . prototype . close = function ( )  {%NWL%if ( this . open )  {%NWL%this . doClose ( ) ;%NWL%this . onClose ( ) ;%NWL%}%NWL%} ;%NWL%Transport . prototype . onClose = function ( )  {%NWL%if ( this . open )  {%NWL%this . clearHandlers ( ) ;%NWL%4
this . setCloseTimeout ( ) ;%NWL%this . clearHandlers ( ) ;%NWL%this . open = false;%NWL%this . manager . onClose ( this . id ) ;%NWL%this . store . publish ( ' close ' , this . id ) ;%NWL%}%NWL%} ;%NWL%Transport . prototype . end = function ( reason )  {%NWL%if ( !this . disconnected )  {%NWL%this . log . info ( ' transport end ( '  + reason +  ' ) ' ) ;%NWL%this . close ( ) ;%NWL%0
this . clearHandlers ( ) ;%NWL%this . open = false;%NWL%this . manager . onClose ( this . id ) ;%NWL%this . store . publish ( ' close ' , this . id ) ;%NWL%}%NWL%} ;%NWL%Transport . prototype . end = function ( reason )  {%NWL%if ( !this . disconnected )  {%NWL%this . log . info ( ' transport end ( '  + reason +  ' ) ' ) ;%NWL%var local = this . manager . transports [ this . id ] ;%NWL%this . clearTimeouts ( ) ;%NWL%0
, Store = require ( ' . . / store ' )%NWL%, assert = require ( ' assert ' ) ;%NWL%exports = module . exports = Redis;%NWL%Redis . Client = Client;%NWL%function Redis ( opts )  {%NWL%opts = opts || { } ;%NWL%var nodeId = opts . nodeId || function ( )  {%NWL%return Math . abs ( Math . random ( )  * Math . random ( )  * Date . now ( ) | 0 ) ;%NWL%} ;%NWL%this . nodeId = nodeId ( ) ;%NWL%this . pack = opts . pack;%NWL%9
, assert = require ( ' assert ' ) ;%NWL%exports = module . exports = Redis;%NWL%Redis . Client = Client;%NWL%function Redis ( opts )  {%NWL%opts = opts || { } ;%NWL%var nodeId = opts . nodeId || function ( )  {%NWL%return Math . abs ( Math . random ( )  * Math . random ( )  * Date . now ( ) | 0 ) ;%NWL%} ;%NWL%this . nodeId = nodeId ( ) ;%NWL%if ( opts . pack )  {%NWL%this . unpack = opts . unpack;%NWL%8
function Redis ( opts )  {%NWL%opts = opts || { } ;%NWL%var nodeId = opts . nodeId || function ( )  {%NWL%return Math . abs ( Math . random ( )  * Math . random ( )  * Date . now ( ) | 0 ) ;%NWL%} ;%NWL%this . nodeId = nodeId ( ) ;%NWL%if ( opts . pack )  {%NWL%this . pack = opts . pack;%NWL%this . unpack = opts . unpack;%NWL%} else {%NWL%var msgpack = require ( ' msgpack ' ) ;%NWL%2
opts = opts || { } ;%NWL%var nodeId = opts . nodeId || function ( )  {%NWL%return Math . abs ( Math . random ( )  * Math . random ( )  * Date . now ( ) | 0 ) ;%NWL%} ;%NWL%this . nodeId = nodeId ( ) ;%NWL%if ( opts . pack )  {%NWL%this . pack = opts . pack;%NWL%this . unpack = opts . unpack;%NWL%} else {%NWL%try {%NWL%this . pack = msgpack . pack;%NWL%4
var nodeId = opts . nodeId || function ( )  {%NWL%return Math . abs ( Math . random ( )  * Math . random ( )  * Date . now ( ) | 0 ) ;%NWL%} ;%NWL%this . nodeId = nodeId ( ) ;%NWL%if ( opts . pack )  {%NWL%this . pack = opts . pack;%NWL%this . unpack = opts . unpack;%NWL%} else {%NWL%try {%NWL%var msgpack = require ( ' msgpack ' ) ;%NWL%this . unpack = msgpack . unpack;%NWL%3
} ;%NWL%this . nodeId = nodeId ( ) ;%NWL%if ( opts . pack )  {%NWL%this . pack = opts . pack;%NWL%this . unpack = opts . unpack;%NWL%} else {%NWL%try {%NWL%var msgpack = require ( ' msgpack ' ) ;%NWL%this . pack = msgpack . pack;%NWL%this . unpack = msgpack . unpack;%NWL%this . pack = JSON . stringify;%NWL%1
this . nodeId = nodeId ( ) ;%NWL%if ( opts . pack )  {%NWL%this . pack = opts . pack;%NWL%this . unpack = opts . unpack;%NWL%} else {%NWL%try {%NWL%var msgpack = require ( ' msgpack ' ) ;%NWL%this . pack = msgpack . pack;%NWL%this . unpack = msgpack . unpack;%NWL%} catch ( e )  {%NWL%this . unpack = JSON . parse;%NWL%0
this . unpack = opts . unpack;%NWL%} else {%NWL%try {%NWL%var msgpack = require ( ' msgpack ' ) ;%NWL%this . pack = msgpack . pack;%NWL%this . unpack = msgpack . unpack;%NWL%} catch ( e )  {%NWL%this . pack = JSON . stringify;%NWL%this . unpack = JSON . parse;%NWL%}%NWL%var redis = opts . redis || require ( ' redis ' )%NWL%3
fn ( ) ;%NWL%client . removeListener ( ' unsubscribe ' , unsubscribe ) ;%NWL%}%NWL%} ) ;%NWL%}%NWL%this . emit ( ' unsubscribe ' , name , fn ) ;%NWL%} ;%NWL%Redis . prototype . destroy = function ( )  {%NWL%Store . prototype . destroy . call ( this ) ;%NWL%this . pub . end ( ) ;%NWL%this . cmd . end ( ) ;%NWL%9
manager . on ( ' set:origins ' , function ( value , key )  {%NWL%if ( !server ) return;%NWL%server . origins = Array . isArray ( value ) ? value : [ value ] ;%NWL%server . compile ( ) ;%NWL%} ) ;%NWL%manager . on ( ' set:flash policy port ' , function ( value , key )  {%NWL%var transports = manager . get ( ' transports ' ) ;%NWL%if ( ~transports . indexOf ( ' flashsocket ' ) )  {%NWL%if ( server )  {%NWL%if ( server . port === value ) return;%NWL%server . close ( ) ;%NWL%3
clearTimeout ( this . pollTimeout ) ;%NWL%this . pollTimeout = null;%NWL%this . log . debug ( ' clearing poll timeout ' ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%HTTPPolling . prototype . clearTimeouts = function ( )  {%NWL%HTTPTransport . prototype . clearTimeouts . call ( this ) ;%NWL%this . clearPollTimeout ( ) ;%NWL%} ;%NWL%this . clearPollTimeout ( ) ;%NWL%8
} ;%NWL%HTTPPolling . prototype . clearTimeouts = function ( )  {%NWL%HTTPTransport . prototype . clearTimeouts . call ( this ) ;%NWL%this . clearPollTimeout ( ) ;%NWL%} ;%NWL%HTTPPolling . prototype . doWrite = function ( )  {%NWL%this . clearPollTimeout ( ) ;%NWL%} ;%NWL%HTTPPolling . prototype . write = function ( data , close )  {%NWL%this . doWrite ( data ) ;%NWL%this . onClose ( ) ;%NWL%3
this . clearPollTimeout ( ) ;%NWL%} ;%NWL%HTTPPolling . prototype . doWrite = function ( )  {%NWL%this . clearPollTimeout ( ) ;%NWL%} ;%NWL%HTTPPolling . prototype . write = function ( data , close )  {%NWL%this . doWrite ( data ) ;%NWL%this . response . end ( ) ;%NWL%this . onClose ( ) ;%NWL%} ;%NWL%this . clearPollTimeout ( ) ;%NWL%0
function WebSocket ( mng , data , req )  {%NWL%var self = this;%NWL%this . parser = new Parser ( ) ;%NWL%this . parser . on ( ' data ' , function ( packet )  {%NWL%self . log . debug ( self . name +  ' received data packet ' , packet ) ;%NWL%self . onMessage ( parser . decodePacket ( packet ) ) ;%NWL%} ) ;%NWL%this . parser . on ( ' close ' , function ( )  {%NWL%self . end ( ) ;%NWL%} ) ;%NWL%self . end ( ) ;%NWL%8
} ) ;%NWL%this . parser . on ( ' ping ' , function ( )  {%NWL%try {%NWL%self . socket . write ( ' \u008a\u0000 ' ) ;%NWL%}%NWL%catch ( e )  {%NWL%self . end ( ) ;%NWL%return;%NWL%}%NWL%} ) ;%NWL%self . end ( ) ;%NWL%6
}%NWL%catch ( e )  {%NWL%self . end ( ) ;%NWL%return;%NWL%}%NWL%} ) ;%NWL%this . parser . on ( ' close ' , function ( )  {%NWL%self . end ( ) ;%NWL%} ) ;%NWL%this . parser . on ( ' error ' , function ( reason )  {%NWL%self . end ( ) ;%NWL%2
this . end ( ) ;%NWL%return;%NWL%}%NWL%var origin = this . req . headers [ ' sec - websocket - origin ' ]%NWL%, location = ( ( this . manager . settings [ ' match origin protocol ' ] ?%NWL%origin . match ( / ^https / ) : this . socket . encrypted ) ?%NWL%' wss ' : ' ws ' )%NWL%+  ' : / / '  + this . req . headers . host + this . req . url;%NWL%%NWL%if ( !this . verifyOrigin ( origin ) )  {%NWL%this . end ( ) ;%NWL%0
' wss ' : ' ws ' )%NWL%+  ' : / / '  + this . req . headers . host + this . req . url;%NWL%%NWL%if ( !this . verifyOrigin ( origin ) )  {%NWL%this . log . warn ( this . name +  ' connection invalid: origin mismatch ' ) ;%NWL%this . end ( ) ;%NWL%return;%NWL%}%NWL%%NWL%if ( !this . req . headers [ ' sec - websocket - key ' ] )  {%NWL%this . end ( ) ;%NWL%5
self . emit ( ' close ' ) ;%NWL%self . reset ( ) ;%NWL%} ,%NWL%' 9 ' : function ( data )  {%NWL%if ( self . state . lastFragment == false )  {%NWL%self . error ( ' fragmented ping is not supported ' ) ;%NWL%return;%NWL%}%NWL%%NWL%var finish = function ( mask , data )  {%NWL%self . endPacket ( ) ;%NWL%1
this . state . lastFragment = ( data [ 0 ] & 0x80 ) == 0x80;%NWL%this . state . masked = ( data [ 1 ] & 0x80 ) == 0x80;%NWL%var opcode = data [ 0 ] & 0xf;%NWL%if ( opcode == 0 )  {%NWL%this . state . opcode = this . state . activeFragmentedOperation;%NWL%if ( ! ( this . state . opcode == 1 || this . state . opcode == 2 ) )  {%NWL%this . error ( ' continuation frame cannot follow current opcode ' )%NWL%return;%NWL%}%NWL%}%NWL%this . state . opcode = opcode;%NWL%4
var opcode = data [ 0 ] & 0xf;%NWL%if ( opcode == 0 )  {%NWL%this . state . opcode = this . state . activeFragmentedOperation;%NWL%if ( ! ( this . state . opcode == 1 || this . state . opcode == 2 ) )  {%NWL%this . error ( ' continuation frame cannot follow current opcode ' )%NWL%return;%NWL%}%NWL%}%NWL%else {%NWL%this . state . opcode = opcode;%NWL%this . state . activeFragmentedOperation = opcode;%NWL%2
} ) ;%NWL%this . parser . on ( ' ping ' , function ( )  {%NWL%try {%NWL%self . socket . write ( ' \u008a\u0000 ' ) ;%NWL%}%NWL%catch ( e )  {%NWL%self . end ( ) ;%NWL%return;%NWL%}%NWL%} ) ;%NWL%self . end ( ) ;%NWL%6
}%NWL%catch ( e )  {%NWL%self . end ( ) ;%NWL%return;%NWL%}%NWL%} ) ;%NWL%this . parser . on ( ' close ' , function ( )  {%NWL%self . end ( ) ;%NWL%} ) ;%NWL%this . parser . on ( ' error ' , function ( reason )  {%NWL%self . end ( ) ;%NWL%2
this . end ( ) ;%NWL%return;%NWL%}%NWL%var origin = this . req . headers [ ' origin ' ] || ' '%NWL%, location = ( ( this . manager . settings [ ' match origin protocol ' ] ?%NWL%origin . match ( / ^https / ) : this . socket . encrypted ) ?%NWL%' wss ' : ' ws ' )%NWL%+  ' : / / '  + this . req . headers . host + this . req . url;%NWL%%NWL%if ( !this . verifyOrigin ( origin ) )  {%NWL%this . end ( ) ;%NWL%0
' wss ' : ' ws ' )%NWL%+  ' : / / '  + this . req . headers . host + this . req . url;%NWL%%NWL%if ( !this . verifyOrigin ( origin ) )  {%NWL%this . log . warn ( this . name +  ' connection invalid: origin mismatch ' ) ;%NWL%this . end ( ) ;%NWL%return;%NWL%}%NWL%%NWL%if ( !this . req . headers [ ' sec - websocket - key ' ] )  {%NWL%this . end ( ) ;%NWL%5
self . emit ( ' close ' ) ;%NWL%self . reset ( ) ;%NWL%} ,%NWL%' 9 ' : function ( data )  {%NWL%if ( self . state . lastFragment == false )  {%NWL%self . error ( ' fragmented ping is not supported ' ) ;%NWL%return;%NWL%}%NWL%%NWL%var finish = function ( mask , data )  {%NWL%self . endPacket ( ) ;%NWL%1
this . state . lastFragment = ( data [ 0 ] & 0x80 ) == 0x80;%NWL%this . state . masked = ( data [ 1 ] & 0x80 ) == 0x80;%NWL%var opcode = data [ 0 ] & 0xf;%NWL%if ( opcode == 0 )  {%NWL%this . state . opcode = this . state . activeFragmentedOperation;%NWL%if ( ! ( this . state . opcode == 1 || this . state . opcode == 2 ) )  {%NWL%this . error ( ' continuation frame cannot follow current opcode ' )%NWL%return;%NWL%}%NWL%}%NWL%this . state . opcode = opcode;%NWL%4
var opcode = data [ 0 ] & 0xf;%NWL%if ( opcode == 0 )  {%NWL%this . state . opcode = this . state . activeFragmentedOperation;%NWL%if ( ! ( this . state . opcode == 1 || this . state . opcode == 2 ) )  {%NWL%this . error ( ' continuation frame cannot follow current opcode ' )%NWL%return;%NWL%}%NWL%}%NWL%else {%NWL%this . state . opcode = opcode;%NWL%this . state . activeFragmentedOperation = opcode;%NWL%2
var slice = Array . prototype . slice%NWL%, net = require ( ' net ' ) ;%NWL%function Server ( options , origins )  {%NWL%var me = this;%NWL%this . origins = origins || [ ' * : * ' ] ;%NWL%this . log = console . log;%NWL%4
var me = this;%NWL%this . origins = origins || [ ' * : * ' ] ;%NWL%this . port = 843;%NWL%this . log = console . log;%NWL%Object . keys ( options ) . forEach ( function ( key )  {%NWL%me [ key ] && ( me [ key ] = options [ key ] )%NWL%} ) ;%NWL%this . socket = net . createServer ( function createServer ( socket )  {%NWL%socket . on ( ' error ' , function socketError ( )  {%NWL%me . responder . call ( me , socket ) ;%NWL%me . responder . call ( me , socket ) ;%NWL%9
, args . filter ( function filter ( value )  {%NWL%return !!value;%NWL%} )%NWL%) ;%NWL%this . compile ( ) ;%NWL%return this;%NWL%} ;%NWL%Server . prototype . remove = function remove ( origin ) {%NWL%var position = this . origins . indexOf ( origin ) ;%NWL%if ( position > 0 )  {%NWL%this . compile ( ) ;%NWL%4
this . socket [ key ] . apply ( this . socket , arguments ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%} ) ;%NWL%exports . createServer = function createServer ( options , origins ) {%NWL%origins = Array . isArray ( origins ) ? origins : ( Array . isArray ( options ) ? options : false ) ;%NWL%options = !Array . isArray ( options ) && options ? options : { } ;%NWL%return new Server ( options , origins ) ;%NWL%} ;%NWL%exports . version = ' 0 . 0 . 4 ' ;%NWL%5
server2 . origins . length . should . equal ( 1 ) ;%NWL%server2 . origins [ 0 ] . should . equal ( ' blog . 3rd - Eden . com:1337 ' ) ;%NWL%%NWL%( typeof server . log ) . should . be . equal ( ' function ' ) ;%NWL%server . origins . length . should . equal ( 1 ) ;%NWL%server . origins [ 0 ] . should . equal ( ' * : * ' ) ;%NWL%%NWL%assert . ok ( server instanceof fspfs . Server ) ;%NWL%assert . ok ( !!server . buffer ) ;%NWL%%NWL%server . origins . length . should . equal ( 1 ) ;%NWL%4
server . origins [ 0 ] . should . equal ( ' * : * ' ) ;%NWL%%NWL%assert . ok ( server instanceof fspfs . Server ) ;%NWL%assert . ok ( !!server . buffer ) ;%NWL%%NWL%server = fspfs . createServer ( [ ' blog . 3rd - Eden . com:80 ' ] ) ;%NWL%server . origins . length . should . equal ( 1 ) ;%NWL%server . origins [ 0 ] . should . equal ( ' blog . 3rd - Eden . com:80 ' ) ;%NWL%%NWL%server = fspfs . createServer ( { log:false } , [ ' blog . 3rd - Eden . com:80 ' ] ) ;%NWL%server . origins . length . should . equal ( 1 ) ;%NWL%6
%NWL%assert . ok ( server instanceof fspfs . Server ) ;%NWL%assert . ok ( !!server . buffer ) ;%NWL%%NWL%server = fspfs . createServer ( [ ' blog . 3rd - Eden . com:80 ' ] ) ;%NWL%server . origins . length . should . equal ( 1 ) ;%NWL%server . origins [ 0 ] . should . equal ( ' blog . 3rd - Eden . com:80 ' ) ;%NWL%%NWL%server = fspfs . createServer ( { log:false } , [ ' blog . 3rd - Eden . com:80 ' ] ) ;%NWL%server . log . should . be . false;%NWL%server . origins [ 0 ] . should . equal ( ' blog . 3rd - Eden . com:80 ' ) ;%NWL%6
var server = fspfs . createServer ( ) ;%NWL%%NWL%Buffer . isBuffer ( server . buffer ) . should . be . true;%NWL%server . buffer . toString ( ) . indexOf ( ' to - ports= " * " ' ) . should . be . above ( 0 ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' domain= " * " ' ) . should . be . above ( 0 ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' domain= " google . com " ' ) . should . equal ( - 1 ) ;%NWL%%NWL%server . add ( ' google . com:80 ' ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' to - ports= " 80 " ' ) . should . be . above ( 0 ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' domain= " google . com " ' ) . should . be . above ( 0 ) ;%NWL%server . remove ( ' google . com:80 ' ) ;%NWL%7
Buffer . isBuffer ( server . buffer ) . should . be . true;%NWL%server . buffer . toString ( ) . indexOf ( ' to - ports= " * " ' ) . should . be . above ( 0 ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' domain= " * " ' ) . should . be . above ( 0 ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' domain= " google . com " ' ) . should . equal ( - 1 ) ;%NWL%%NWL%server . add ( ' google . com:80 ' ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' to - ports= " 80 " ' ) . should . be . above ( 0 ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' domain= " google . com " ' ) . should . be . above ( 0 ) ;%NWL%%NWL%server . remove ( ' google . com:80 ' ) ;%NWL%server . buffer . toString ( ) . indexOf ( ' domain= " google . com " ' ) . should . equal ( - 1 ) ;%NWL%3
}%NWL%}%NWL%parsers . push ( require ( " . / lib / parser / javascript " ) ) ;%NWL%function RedisClient ( stream , options )  {%NWL%this . stream = stream;%NWL%this . options = options = options || { } ;%NWL%this . connection_id = + + connection_id;%NWL%this . connected = false;%NWL%this . ready = false;%NWL%this . connections = 0;%NWL%this . options . socket_nodelay = true;%NWL%5
function RedisClient ( stream , options )  {%NWL%this . stream = stream;%NWL%this . options = options = options || { } ;%NWL%this . connection_id = + + connection_id;%NWL%this . connected = false;%NWL%this . ready = false;%NWL%this . connections = 0;%NWL%if ( this . options . socket_nodelay === undefined )  {%NWL%this . options . socket_nodelay = true;%NWL%}%NWL%this . command_queue_high_water = this . options . command_queue_high_water || 1000;%NWL%2
this . stream = stream;%NWL%this . options = options = options || { } ;%NWL%this . connection_id = + + connection_id;%NWL%this . connected = false;%NWL%this . ready = false;%NWL%this . connections = 0;%NWL%if ( this . options . socket_nodelay === undefined )  {%NWL%this . options . socket_nodelay = true;%NWL%}%NWL%this . should_buffer = false;%NWL%this . command_queue_low_water = this . options . command_queue_low_water || 0;%NWL%1
this . connected = false;%NWL%this . ready = false;%NWL%this . connections = 0;%NWL%if ( this . options . socket_nodelay === undefined )  {%NWL%this . options . socket_nodelay = true;%NWL%}%NWL%this . should_buffer = false;%NWL%this . command_queue_high_water = this . options . command_queue_high_water || 1000;%NWL%this . command_queue_low_water = this . options . command_queue_low_water || 0;%NWL%this . max_attempts = null;%NWL%this . max_attempts = + options . max_attempts;%NWL%7
this . command_queue_high_water = this . options . command_queue_high_water || 1000;%NWL%this . command_queue_low_water = this . options . command_queue_low_water || 0;%NWL%this . max_attempts = null;%NWL%if ( options . max_attempts && !isNaN ( options . max_attempts ) && options . max_attempts > 0 )  {%NWL%this . max_attempts = + options . max_attempts;%NWL%}%NWL%this . command_queue = new Queue ( ) ; / / holds sent commands to de - pipeline them%NWL%this . offline_queue = new Queue ( ) ; / / holds commands issued but not able to be sent%NWL%this . commands_sent = 0;%NWL%this . connect_timeout = false;%NWL%this . connect_timeout = + options . connect_timeout;%NWL%0
var command_obj;%NWL%while ( this . offline_queue . length > 0 )  {%NWL%command_obj = this . offline_queue . shift ( ) ;%NWL%if ( typeof command_obj . callback === " function " )  {%NWL%command_obj . callback ( message ) ;%NWL%}%NWL%}%NWL%this . offline_queue = new Queue ( ) ;%NWL%while ( this . command_queue . length > 0 )  {%NWL%command_obj = this . command_queue . shift ( ) ;%NWL%command_obj . callback ( message ) ;%NWL%4
if ( exports . debug_mode )  {%NWL%console . log ( " Auth succeeded "  + self . host +  " : "  + self . port +  " id "  + self . connection_id ) ;%NWL%}%NWL%if ( self . auth_callback )  {%NWL%self . auth_callback ( err , res ) ;%NWL%self . auth_callback = null;%NWL%}%NWL%self . emit ( " connect " ) ;%NWL%if ( self . options . no_ready_check )  {%NWL%self . on_ready ( ) ;%NWL%self . ready_check ( ) ;%NWL%9
this . connected = true;%NWL%this . ready = false;%NWL%this . attempts = 0;%NWL%this . connections + = 1;%NWL%this . command_queue = new Queue ( ) ;%NWL%this . emitted_end = false;%NWL%this . initialize_retry_vars ( ) ;%NWL%if ( this . options . socket_nodelay )  {%NWL%this . stream . setNoDelay ( ) ;%NWL%}%NWL%this . init_parser ( ) ;%NWL%6
this . attempts = 0;%NWL%this . connections + = 1;%NWL%this . command_queue = new Queue ( ) ;%NWL%this . emitted_end = false;%NWL%this . initialize_retry_vars ( ) ;%NWL%if ( this . options . socket_nodelay )  {%NWL%this . stream . setNoDelay ( ) ;%NWL%}%NWL%this . stream . setTimeout ( 0 ) ;%NWL%this . init_parser ( ) ;%NWL%this . do_auth ( ) ;%NWL%4
this . initialize_retry_vars ( ) ;%NWL%if ( this . options . socket_nodelay )  {%NWL%this . stream . setNoDelay ( ) ;%NWL%}%NWL%this . stream . setTimeout ( 0 ) ;%NWL%this . init_parser ( ) ;%NWL%if ( this . auth_pass )  {%NWL%this . do_auth ( ) ;%NWL%} else {%NWL%this . emit ( " connect " ) ;%NWL%this . on_ready ( ) ;%NWL%0
this . stream . setNoDelay ( ) ;%NWL%}%NWL%this . stream . setTimeout ( 0 ) ;%NWL%this . init_parser ( ) ;%NWL%if ( this . auth_pass )  {%NWL%this . do_auth ( ) ;%NWL%} else {%NWL%this . emit ( " connect " ) ;%NWL%if ( this . options . no_ready_check )  {%NWL%this . on_ready ( ) ;%NWL%this . ready_check ( ) ;%NWL%3
} ;%NWL%RedisClient . prototype . AUTH = RedisClient . prototype . auth;%NWL%RedisClient . prototype . hmget = function ( arg1 , arg2 , arg3 )  {%NWL%if ( Array . isArray ( arg2 ) && typeof arg3 === " function " )  {%NWL%return this . send_command ( " hmget " ,  [ arg1 ] . concat ( arg2 ) , arg3 ) ;%NWL%} else if ( Array . isArray ( arg1 ) && typeof arg2 === " function " )  {%NWL%return this . send_command ( " hmget " , arg1 , arg2 ) ;%NWL%} else {%NWL%return this . send_command ( " hmget " , to_array ( arguments ) ) ;%NWL%}%NWL%RedisClient . prototype . HMGET = RedisClient . prototype . hmget;%NWL%1
var self = this;%NWL%this . args = args;%NWL%%NWL%this . callback = null;%NWL%this . clients = [ ] ;%NWL%this . clients_ready = 0;%NWL%this . commands_sent = 0;%NWL%this . commands_completed = 0;%NWL%this . max_pipeline = this . args . pipeline || num_requests;%NWL%this . client_options = args . client_options || client_options;%NWL%this . connect_latency = new metrics . Histogram ( ) ;%NWL%9
this . args = args;%NWL%%NWL%this . callback = null;%NWL%this . clients = [ ] ;%NWL%this . clients_ready = 0;%NWL%this . commands_sent = 0;%NWL%this . commands_completed = 0;%NWL%this . max_pipeline = this . args . pipeline || num_requests;%NWL%this . client_options = args . client_options || client_options;%NWL%%NWL%this . ready_latency = new metrics . Histogram ( ) ;%NWL%8
%NWL%this . callback = null;%NWL%this . clients = [ ] ;%NWL%this . clients_ready = 0;%NWL%this . commands_sent = 0;%NWL%this . commands_completed = 0;%NWL%this . max_pipeline = this . args . pipeline || num_requests;%NWL%this . client_options = args . client_options || client_options;%NWL%%NWL%this . connect_latency = new metrics . Histogram ( ) ;%NWL%this . command_latency = new metrics . Histogram ( ) ;%NWL%7
new_client = redis . createClient ( 6379 ,  " 127 . 0 . 0 . 1 " , this . client_options ) ;%NWL%new_client . create_time = Date . now ( ) ;%NWL%new_client . on ( " connect " , function ( )  {%NWL%self . connect_latency . update ( Date . now ( )  - new_client . create_time ) ;%NWL%} ) ;%NWL%new_client . on ( " ready " , function ( )  {%NWL%if ( ! versions_logged )  {%NWL%console . log ( " Client count: "  + num_clients +  " , node version: "  + process . versions . node +  " , server version: "  +%NWL%new_client . server_info . redis_version +  " , parser: "  + new_client . reply_parser . name ) ;%NWL%versions_logged = true;%NWL%self . ready_latency . update ( Date . now ( )  - new_client . create_time ) ;%NWL%3
} ;%NWL%Test . prototype . on_clients_ready = function ( )  {%NWL%process . stdout . write ( lpad ( this . args . descr , 13 )  +  " ,  "  + lpad ( this . args . pipeline , 5 )  +  " / "  + this . clients_ready +  "  " ) ;%NWL%this . test_start = Date . now ( ) ;%NWL%this . fill_pipeline ( ) ;%NWL%} ;%NWL%Test . prototype . fill_pipeline = function ( )  {%NWL%var pipeline = this . commands_sent - this . commands_completed;%NWL%while ( this . commands_sent < num_requests && pipeline < this . max_pipeline )  {%NWL%this . commands_sent + + ;%NWL%this . send_next ( ) ;%NWL%4
this . fill_pipeline ( ) ;%NWL%} ;%NWL%Test . prototype . fill_pipeline = function ( )  {%NWL%var pipeline = this . commands_sent - this . commands_completed;%NWL%while ( this . commands_sent < num_requests && pipeline < this . max_pipeline )  {%NWL%this . commands_sent + + ;%NWL%pipeline + + ;%NWL%this . send_next ( ) ;%NWL%}%NWL%%NWL%this . print_stats ( ) ;%NWL%0
} ;%NWL%Test . prototype . fill_pipeline = function ( )  {%NWL%var pipeline = this . commands_sent - this . commands_completed;%NWL%while ( this . commands_sent < num_requests && pipeline < this . max_pipeline )  {%NWL%this . commands_sent + + ;%NWL%pipeline + + ;%NWL%this . send_next ( ) ;%NWL%}%NWL%%NWL%if ( this . commands_completed === num_requests )  {%NWL%this . stop_clients ( ) ;%NWL%6
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / applications ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
var client = require ( ' . . / index ' ) . createClient ( )%NWL%, client2 = require ( ' . . / index ' ) . createClient ( )%NWL%, assert = require ( ' assert ' ) ;%NWL%client . once ( ' subscribe ' , function ( channel , count )  {%NWL%client . unsubscribe ( ' x ' ) ;%NWL%client . subscribe ( ' x ' , function ( )  {%NWL%client . quit ( ) ;%NWL%client2 . quit ( ) ;%NWL%} ) ;%NWL%client2 . publish ( ' x ' ,  ' hi ' ) ;%NWL%client . subscribe ( ' x ' ) ;%NWL%4
var client = require ( " redis " ) . createClient ( ) ,%NWL%client2 = require ( " redis " ) . createClient ( ) ;%NWL%client . subscribe ( " something " ) ;%NWL%client . on ( " subscribe " , function ( channel , count )  {%NWL%client . unsubscribe ( " something " ) ;%NWL%2
var profiler = require ( ' v8 - profiler ' ) ;%NWL%var codec = require ( ' . . / codec ' ) ;%NWL%var sent = 0;%NWL%var pub = require ( ' redis ' ) . createClient ( null , null ,  {%NWL%} )%NWL%. on ( ' ready ' , function ( )  {%NWL%this . emit ( ' drain ' ) ;%NWL%} )%NWL%. on ( ' drain ' , function ( )  {%NWL%process . nextTick ( exec ) ;%NWL%var payload = ' 1 ' ; for ( var i = 0; i < 12; + + i ) payload + = payload;%NWL%0
this . emit ( ' drain ' ) ;%NWL%} )%NWL%. on ( ' drain ' , function ( )  {%NWL%process . nextTick ( exec ) ;%NWL%} ) ;%NWL%var payload = ' 1 ' ; for ( var i = 0; i < 12; + + i ) payload + = payload;%NWL%console . log ( ' Message payload length ' , payload . length ) ;%NWL%function exec ( )  {%NWL%pub . publish ( ' timeline ' , codec . encode ( { foo: payload } ) ) ;%NWL%+ + sent;%NWL%process . nextTick ( exec ) ;%NWL%3
var codec = require ( ' . . / codec ' ) ;%NWL%var sent = 0;%NWL%var pub = require ( ' redis ' ) . createClient ( null , null ,  {%NWL%} )%NWL%. on ( ' ready ' , function ( )  {%NWL%this . del ( ' timeline ' ) ;%NWL%this . emit ( ' drain ' ) ;%NWL%} )%NWL%. on ( ' drain ' , function ( )  {%NWL%process . nextTick ( exec ) ;%NWL%var payload = ' 1 ' ; for ( var i = 0; i < 12; + + i ) payload + = payload;%NWL%0
this . emit ( ' drain ' ) ;%NWL%} )%NWL%. on ( ' drain ' , function ( )  {%NWL%process . nextTick ( exec ) ;%NWL%} ) ;%NWL%var payload = ' 1 ' ; for ( var i = 0; i < 12; + + i ) payload + = payload;%NWL%console . log ( ' Message payload length ' , payload . length ) ;%NWL%function exec ( )  {%NWL%pub . rpush ( ' timeline ' , codec . encode ( { foo: payload } ) ) ;%NWL%+ + sent;%NWL%process . nextTick ( exec ) ;%NWL%3
if ( client . hset ( " test hash " ,  " val "  + remaining_ops , remaining_ops ) === false )  {%NWL%console . log ( " Pausing at "  + remaining_ops ) ;%NWL%paused = true;%NWL%} else {%NWL%process . nextTick ( op ) ;%NWL%}%NWL%}%NWL%client . on ( " drain " , function ( )  {%NWL%if ( paused )  {%NWL%console . log ( " Resuming at "  + remaining_ops ) ;%NWL%process . nextTick ( op ) ;%NWL%4
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / availability ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
client1 . on ( " punsubscribe " , function ( pattern , count )  {%NWL%console . log ( " client1 punsubscribed from "  + pattern +  " ,  "  + count +  " total subscriptions " ) ;%NWL%client4 . end ( ) ;%NWL%client3 . end ( ) ;%NWL%client2 . end ( ) ;%NWL%client1 . end ( ) ;%NWL%} ) ;%NWL%client1 . on ( " pmessage " , function ( pattern , channel , message )  {%NWL%console . log ( " ( " +  pattern + " ) "  +  " client1 received message on "  + channel +  " : "  + message ) ;%NWL%msg_count + = 1;%NWL%client1 . punsubscribe ( ) ;%NWL%5
client1 . on ( " unsubscribe " , function ( channel , count )  {%NWL%console . log ( " client1 unsubscribed from "  + channel +  " ,  "  + count +  " total subscriptions " ) ;%NWL%if ( count === 0 )  {%NWL%client2 . end ( ) ;%NWL%client1 . end ( ) ;%NWL%}%NWL%} ) ;%NWL%client1 . on ( " message " , function ( channel , message )  {%NWL%console . log ( " client1 channel "  + channel +  " : "  + message ) ;%NWL%msg_count + = 1;%NWL%client1 . unsubscribe ( ) ;%NWL%4
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / bar_chart_with_number ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / column ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
this . send_reply ( + small_toString ( this . return_buffer , this . return_buffer . end ) ) ;%NWL%this . state = states . FINAL_LF;%NWL%} else {%NWL%this . return_buffer [ this . return_buffer . end ] = incoming_buf [ pos ] ;%NWL%this . return_buffer . end + = 1;%NWL%}%NWL%pos + = 1;%NWL%break;%NWL%case 6: / / states . ERROR_LINE%NWL%if ( incoming_buf [ pos ] === 13 )  {%NWL%this . state = states . FINAL_LF;%NWL%3
} else {%NWL%this . return_buffer [ this . return_buffer . end ] = incoming_buf [ pos ] ;%NWL%this . return_buffer . end + = 1;%NWL%}%NWL%pos + = 1;%NWL%break;%NWL%case 6: / / states . ERROR_LINE%NWL%if ( incoming_buf [ pos ] === 13 )  {%NWL%this . send_error ( this . return_buffer . toString ( " ascii " , 0 , this . return_buffer . end ) ) ;%NWL%this . state = states . FINAL_LF;%NWL%this . return_buffer [ this . return_buffer . end ] = incoming_buf [ pos ] ;%NWL%1
this . return_buffer [ this . return_buffer . end ] = incoming_buf [ pos ] ;%NWL%this . return_buffer . end + = 1;%NWL%}%NWL%pos + = 1;%NWL%break;%NWL%case 6: / / states . ERROR_LINE%NWL%if ( incoming_buf [ pos ] === 13 )  {%NWL%this . send_error ( this . return_buffer . toString ( " ascii " , 0 , this . return_buffer . end ) ) ;%NWL%this . state = states . FINAL_LF;%NWL%} else {%NWL%this . return_buffer . end + = 1;%NWL%0
this . send_error ( this . return_buffer . toString ( " ascii " , 0 , this . return_buffer . end ) ) ;%NWL%this . state = states . FINAL_LF;%NWL%} else {%NWL%this . return_buffer [ this . return_buffer . end ] = incoming_buf [ pos ] ;%NWL%this . return_buffer . end + = 1;%NWL%}%NWL%pos + = 1;%NWL%break;%NWL%case 2: / / states . SINGLE_LINE%NWL%if ( incoming_buf [ pos ] === 13 )  {%NWL%this . state = states . FINAL_LF;%NWL%3
} else {%NWL%this . return_buffer [ this . return_buffer . end ] = incoming_buf [ pos ] ;%NWL%this . return_buffer . end + = 1;%NWL%}%NWL%pos + = 1;%NWL%break;%NWL%case 2: / / states . SINGLE_LINE%NWL%if ( incoming_buf [ pos ] === 13 )  {%NWL%this . send_reply ( this . return_string ) ;%NWL%this . state = states . FINAL_LF;%NWL%this . return_string + = String . fromCharCode ( incoming_buf [ pos ] ) ;%NWL%1
if ( this . multi_bulk_length > 0 || this . multi_bulk_nested_length > 0 )  {%NWL%this . add_multi_bulk_reply ( reply ) ;%NWL%} else {%NWL%this . emit ( " reply error " , reply ) ;%NWL%}%NWL%} ;%NWL%RedisReplyParser . prototype . send_reply = function ( reply )  {%NWL%if ( this . multi_bulk_length > 0 || this . multi_bulk_nested_length > 0 )  {%NWL%if ( !this . options . return_buffers && Buffer . isBuffer ( reply ) )  {%NWL%this . add_multi_bulk_reply ( reply . toString ( " utf8 " ) ) ;%NWL%this . add_multi_bulk_reply ( reply ) ;%NWL%1
fs . write (%NWL%fs . openSync ( __dirname +  ' / . . / dist / socket . io . js ' ,  ' w ' )%NWL%, content%NWL%, 0%NWL%,  ' utf8 '%NWL%) ;%NWL%console . log ( ' Successfully generated the development build: socket . io . js ' ) ;%NWL%} ) ;%NWL%builder ( args . length ? args : false , function ( err , content )  {%NWL%if ( err ) return console . error ( err ) ;%NWL%fs . write (%NWL%0
v = str ( k , value ) ;%NWL%if ( v )  {%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%}%NWL%}%NWL%}%NWL%} else {%NWL%for ( k in value )  {%NWL%if ( Object . prototype . hasOwnProperty . call ( value , k ) )  {%NWL%v = str ( k , value ) ;%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%2
var Emitter;%NWL%try {%NWL%Emitter = require ( ' emitter ' ) ;%NWL%} catch ( e ) {%NWL%Emitter = require ( ' emitter - component ' ) ;%NWL%}%NWL%module . exports = Emitter;%NWL%Emitter . prototype . addEventListener = Emitter . prototype . on;%NWL%Emitter . prototype . removeListener = Emitter . prototype . off;%NWL%7
if ( ! ( this instanceof Socket ) ) return new Socket ( opts ) ;%NWL%if ( ' string ' == typeof opts )  {%NWL%var uri = util . parseUri ( opts ) ;%NWL%opts = arguments [ 1 ] || { } ;%NWL%opts . host = uri . host;%NWL%opts . secure = uri . protocol == ' https ' || uri . protocol == ' wss ' ;%NWL%opts . port = uri . port;%NWL%}%NWL%opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%9
var uri = util . parseUri ( opts ) ;%NWL%opts = arguments [ 1 ] || { } ;%NWL%opts . host = uri . host;%NWL%opts . secure = uri . protocol == ' https ' || uri . protocol == ' wss ' ;%NWL%opts . port = uri . port;%NWL%}%NWL%opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query . uid = rnd ( ) ;%NWL%7
opts = arguments [ 1 ] || { } ;%NWL%opts . host = uri . host;%NWL%opts . secure = uri . protocol == ' https ' || uri . protocol == ' wss ' ;%NWL%opts . port = uri . port;%NWL%}%NWL%opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%6
opts . host = uri . host;%NWL%opts . secure = uri . protocol == ' https ' || uri . protocol == ' wss ' ;%NWL%opts . port = uri . port;%NWL%}%NWL%opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . resource = opts . resource || ' default ' ;%NWL%5
opts . secure = uri . protocol == ' https ' || uri . protocol == ' wss ' ;%NWL%opts . port = uri . port;%NWL%}%NWL%opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%this . path = ( opts . path || ' / engine . io ' ) . replace ( / \ / $ / ,  ' ' ) ;%NWL%4
opts . port = uri . port;%NWL%}%NWL%opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%this . resource = opts . resource || ' default ' ;%NWL%this . path + = ' / '  + this . resource +  ' / ' ;%NWL%3
}%NWL%opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%this . resource = opts . resource || ' default ' ;%NWL%this . path = ( opts . path || ' / engine . io ' ) . replace ( / \ / $ / ,  ' ' ) ;%NWL%this . forceJSONP = !!opts . forceJSONP;%NWL%2
opts = opts || { } ;%NWL%this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%this . resource = opts . resource || ' default ' ;%NWL%this . path = ( opts . path || ' / engine . io ' ) . replace ( / \ / $ / ,  ' ' ) ;%NWL%this . path + = ' / '  + this . resource +  ' / ' ;%NWL%this . timestampParam = opts . timestampParam || ' t ' ;%NWL%1
this . secure = null != opts . secure ? opts . secure : ( global . location && ' https: ' == location . protocol ) ;%NWL%this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%this . resource = opts . resource || ' default ' ;%NWL%this . path = ( opts . path || ' / engine . io ' ) . replace ( / \ / $ / ,  ' ' ) ;%NWL%this . path + = ' / '  + this . resource +  ' / ' ;%NWL%this . forceJSONP = !!opts . forceJSONP;%NWL%this . timestampRequests = !!opts . timestampRequests;%NWL%0
this . host = opts . host || opts . hostname || ( global . location ? location . hostname : ' localhost ' ) ;%NWL%this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%this . resource = opts . resource || ' default ' ;%NWL%this . path = ( opts . path || ' / engine . io ' ) . replace ( / \ / $ / ,  ' ' ) ;%NWL%this . path + = ' / '  + this . resource +  ' / ' ;%NWL%this . forceJSONP = !!opts . forceJSONP;%NWL%this . timestampParam = opts . timestampParam || ' t ' ;%NWL%this . flashPath = opts . flashPath || ' ' ;%NWL%0
this . port = opts . port || ( global . location && location . port ? location . port : ( this . secure ? 443 : 80 ) ) ;%NWL%this . query = opts . query || { } ;%NWL%this . query . uid = rnd ( ) ;%NWL%this . upgrade = false !== opts . upgrade;%NWL%this . resource = opts . resource || ' default ' ;%NWL%this . path = ( opts . path || ' / engine . io ' ) . replace ( / \ / $ / ,  ' ' ) ;%NWL%this . path + = ' / '  + this . resource +  ' / ' ;%NWL%this . forceJSONP = !!opts . forceJSONP;%NWL%this . timestampParam = opts . timestampParam || ' t ' ;%NWL%this . timestampRequests = !!opts . timestampRequests;%NWL%this . transports = opts . transports || [ ' polling ' ,  ' websocket ' ,  ' flashsocket ' ] ;%NWL%0
this . upgrade = false !== opts . upgrade;%NWL%this . resource = opts . resource || ' default ' ;%NWL%this . path = ( opts . path || ' / engine . io ' ) . replace ( / \ / $ / ,  ' ' ) ;%NWL%this . path + = ' / '  + this . resource +  ' / ' ;%NWL%this . forceJSONP = !!opts . forceJSONP;%NWL%this . timestampParam = opts . timestampParam || ' t ' ;%NWL%this . timestampRequests = !!opts . timestampRequests;%NWL%this . flashPath = opts . flashPath || ' ' ;%NWL%this . transports = opts . transports || [ ' polling ' ,  ' websocket ' ,  ' flashsocket ' ] ;%NWL%this . readyState = ' ' ;%NWL%this . policyPort = opts . policyPort || 843;%NWL%1
Socket . sockets . evs . emit ( ' add ' , this ) ;%NWL%} ;%NWL%Emitter ( Socket . prototype ) ;%NWL%Socket . protocol = 1;%NWL%Socket . sockets = [ ] ;%NWL%Socket . sockets . evs = new Emitter;%NWL%Socket . Socket = Socket;%NWL%Socket . Transport = require ( ' . / transport ' ) ;%NWL%Socket . Emitter = require ( ' . / emitter ' ) ;%NWL%Socket . transports = require ( ' . / transports ' ) ;%NWL%Socket . parser = require ( ' . / parser ' ) ;%NWL%9
transport . once ( ' error ' , onerror ) ;%NWL%function onerror ( err )  {%NWL%if ( failed ) return;%NWL%failed = true;%NWL%var error = new Error ( ' probe error: '  + err ) ;%NWL%error . transport = transport . name;%NWL%transport . close ( ) ;%NWL%transport = null;%NWL%debug ( ' probe transport " %s " failed because of error: %s ' , name , err ) ;%NWL%self . emit ( ' error ' , error ) ;%NWL%transport . open ( ) ;%NWL%6
error . transport = transport . name;%NWL%transport . close ( ) ;%NWL%transport = null;%NWL%debug ( ' probe transport " %s " failed because of error: %s ' , name , err ) ;%NWL%self . emit ( ' error ' , error ) ;%NWL%} ;%NWL%transport . open ( ) ;%NWL%this . once ( ' close ' , function ( )  {%NWL%if ( transport )  {%NWL%debug ( ' socket closed prematurely - aborting probe ' ) ;%NWL%transport . close ( ) ;%NWL%1
this . once ( ' close ' , function ( )  {%NWL%if ( transport )  {%NWL%debug ( ' socket closed prematurely - aborting probe ' ) ;%NWL%failed = true;%NWL%transport . close ( ) ;%NWL%transport = null;%NWL%}%NWL%} ) ;%NWL%this . once ( ' upgrading ' , function ( to )  {%NWL%if ( transport && to . name != transport . name )  {%NWL%transport . close ( ) ;%NWL%4
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / completion_rate ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
return this;%NWL%} ;%NWL%Transport . prototype . open = function ( )  {%NWL%if ( ' closed ' == this . readyState || ' ' == this . readyState )  {%NWL%this . readyState = ' opening ' ;%NWL%this . doOpen ( ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%Transport . prototype . close = function ( )  {%NWL%this . doClose ( ) ;%NWL%5
} ;%NWL%Transport . prototype . open = function ( )  {%NWL%if ( ' closed ' == this . readyState || ' ' == this . readyState )  {%NWL%this . readyState = ' opening ' ;%NWL%this . doOpen ( ) ;%NWL%}%NWL%return this;%NWL%} ;%NWL%Transport . prototype . close = function ( )  {%NWL%if ( ' opening ' == this . readyState || ' open ' == this . readyState )  {%NWL%this . onClose ( ) ;%NWL%4
if ( util . ua . gecko )  {%NWL%setTimeout ( function ( )  {%NWL%var iframe = document . createElement ( ' iframe ' ) ;%NWL%document . body . appendChild ( iframe ) ;%NWL%document . body . removeChild ( iframe ) ;%NWL%} , 100 ) ;%NWL%}%NWL%} ;%NWL%JSONPPolling . prototype . doWrite = function ( data , fn )  {%NWL%var self = this;%NWL%var form = document . createElement ( ' form ' )%NWL%2
req . on ( ' data ' , function ( data ) {%NWL%self . onData ( data ) ;%NWL%} ) ;%NWL%req . on ( ' error ' , function ( err ) {%NWL%self . onError ( ' xhr poll error ' , err ) ;%NWL%} ) ;%NWL%this . pollXhr = req;%NWL%} ;%NWL%function Request ( opts ) {%NWL%this . method = opts . method || ' GET ' ;%NWL%this . xd = !!opts . xd;%NWL%9
self . onData ( data ) ;%NWL%} ) ;%NWL%req . on ( ' error ' , function ( err ) {%NWL%self . onError ( ' xhr poll error ' , err ) ;%NWL%} ) ;%NWL%this . pollXhr = req;%NWL%} ;%NWL%function Request ( opts ) {%NWL%this . method = opts . method || ' GET ' ;%NWL%this . uri = opts . uri;%NWL%this . async = false !== opts . async;%NWL%8
} ) ;%NWL%req . on ( ' error ' , function ( err ) {%NWL%self . onError ( ' xhr poll error ' , err ) ;%NWL%} ) ;%NWL%this . pollXhr = req;%NWL%} ;%NWL%function Request ( opts ) {%NWL%this . method = opts . method || ' GET ' ;%NWL%this . uri = opts . uri;%NWL%this . xd = !!opts . xd;%NWL%this . data = undefined != opts . data ? opts . data : null;%NWL%7
if ( xobject )  {%NWL%this . index = Request . requestsCount + + ;%NWL%Request . requests [ this . index ] = this;%NWL%}%NWL%} ;%NWL%Request . prototype . onSuccess = function ( ) {%NWL%this . emit ( ' success ' ) ;%NWL%this . cleanup ( ) ;%NWL%} ;%NWL%Request . prototype . onData = function ( data ) {%NWL%this . onSuccess ( ) ;%NWL%7
} ;%NWL%Request . prototype . onSuccess = function ( ) {%NWL%this . emit ( ' success ' ) ;%NWL%this . cleanup ( ) ;%NWL%} ;%NWL%Request . prototype . onData = function ( data ) {%NWL%this . emit ( ' data ' , data ) ;%NWL%this . onSuccess ( ) ;%NWL%} ;%NWL%Request . prototype . onError = function ( err ) {%NWL%this . cleanup ( ) ;%NWL%3
WS . prototype . name = ' websocket ' ;%NWL%WS . prototype . doOpen = function ( ) {%NWL%if ( !this . check ( ) )  {%NWL%return;%NWL%}%NWL%var self = this;%NWL%this . socket = new ( ws ( ) ) ( this . uri ( ) ) ;%NWL%this . socket . onopen = function ( ) {%NWL%self . onOpen ( ) ;%NWL%} ;%NWL%self . onClose ( ) ;%NWL%8
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' extensions / views / view ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
%NWL%io . transports = [ ] ;%NWL%%NWL%io . j = [ ] ;%NWL%%NWL%io . sockets = { } ;%NWL%%NWL%if ( ' object ' === typeof module && ' function ' === typeof require )  {%NWL%%NWL%io . util = require ( ' . / util ' ) . util;%NWL%io . JSON = require ( ' . / json ' ) . JSON;%NWL%9
%NWL%io . j = [ ] ;%NWL%%NWL%io . sockets = { } ;%NWL%%NWL%if ( ' object ' === typeof module && ' function ' === typeof require )  {%NWL%%NWL%io . util = require ( ' . / util ' ) . util;%NWL%%NWL%io . JSON = require ( ' . / json ' ) . JSON;%NWL%io . parser = require ( ' . / parser ' ) . parser;%NWL%7
%NWL%io . sockets = { } ;%NWL%%NWL%if ( ' object ' === typeof module && ' function ' === typeof require )  {%NWL%%NWL%io . util = require ( ' . / util ' ) . util;%NWL%%NWL%io . JSON = require ( ' . / json ' ) . JSON;%NWL%%NWL%io . parser = require ( ' . / parser ' ) . parser;%NWL%io . EventEmitter = require ( ' . / events ' ) . EventEmitter;%NWL%5
%NWL%if ( ' object ' === typeof module && ' function ' === typeof require )  {%NWL%%NWL%io . util = require ( ' . / util ' ) . util;%NWL%%NWL%io . JSON = require ( ' . / json ' ) . JSON;%NWL%%NWL%io . parser = require ( ' . / parser ' ) . parser;%NWL%%NWL%io . EventEmitter = require ( ' . / events ' ) . EventEmitter;%NWL%io . SocketNamespace = require ( ' . / namespace ' ) . SocketNamespace;%NWL%3
%NWL%io . util = require ( ' . / util ' ) . util;%NWL%%NWL%io . JSON = require ( ' . / json ' ) . JSON;%NWL%%NWL%io . parser = require ( ' . / parser ' ) . parser;%NWL%%NWL%io . EventEmitter = require ( ' . / events ' ) . EventEmitter;%NWL%%NWL%io . SocketNamespace = require ( ' . / namespace ' ) . SocketNamespace;%NWL%io . Transport = require ( ' . / transport ' ) . Transport;%NWL%1
%NWL%io . parser = require ( ' . / parser ' ) . parser;%NWL%%NWL%io . EventEmitter = require ( ' . / events ' ) . EventEmitter;%NWL%%NWL%io . SocketNamespace = require ( ' . / namespace ' ) . SocketNamespace;%NWL%%NWL%io . Transport = require ( ' . / transport ' ) . Transport;%NWL%%NWL%io . transports = [ ' websocket ' ,  ' xhr - polling ' ] ;%NWL%io . Transport . XHR = require ( ' . / transports / xhr ' ) . XHR;%NWL%1
io . transports = [ ' websocket ' ,  ' xhr - polling ' ] ;%NWL%%NWL%io . Transport . XHR = require ( ' . / transports / xhr ' ) . XHR;%NWL%io . transports . forEach ( function ( t )  {%NWL%io . Transport [ t ] = require ( ' . / transports / '  + t ) [ t ] ;%NWL%} ) ;%NWL%%NWL%io . Socket = require ( ' . / socket ' ) . Socket;%NWL%%NWL%io . dist = __dirname +  ' / . . / dist ' ;%NWL%io . builder = require ( ' . . / bin / builder ' ) ;%NWL%9
io . builder = require ( ' . . / bin / builder ' ) ;%NWL%}%NWL%%NWL%io . connect = function ( host , details )  {%NWL%var uri = io . util . parseUri ( host )%NWL%, uuri%NWL%, socket;%NWL%if ( global && global . location )  {%NWL%uri . protocol = uri . protocol || global . location . protocol . slice ( 0 ,  - 1 ) ;%NWL%uri . host = uri . host || ( global . document%NWL%uri . port = uri . port || global . location . port;%NWL%8
v = str ( k , value ) ;%NWL%if ( v )  {%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%}%NWL%}%NWL%}%NWL%} else {%NWL%for ( k in value )  {%NWL%if ( Object . prototype . hasOwnProperty . call ( value , k ) )  {%NWL%v = str ( k , value ) ;%NWL%partial . push ( quote ( k )  +  ( gap ? ' : ' : ' : ' )  + v ) ;%NWL%2
var params = [ ' message ' , packet . data ] ;%NWL%if ( packet . ack == ' data ' )  {%NWL%params . push ( ack ) ;%NWL%} else if ( packet . ack )  {%NWL%this . packet ( { type: ' ack ' , ackId: packet . id } ) ;%NWL%}%NWL%this . $emit . apply ( this , params ) ;%NWL%break;%NWL%case ' event ' :%NWL%var params = [ packet . name ] . concat ( packet . args ) ;%NWL%params . push ( ack ) ;%NWL%2
if ( packet . ack == ' data ' )  {%NWL%params . push ( ack ) ;%NWL%} else if ( packet . ack )  {%NWL%this . packet ( { type: ' ack ' , ackId: packet . id } ) ;%NWL%}%NWL%this . $emit . apply ( this , params ) ;%NWL%break;%NWL%case ' event ' :%NWL%var params = [ packet . name ] . concat ( packet . args ) ;%NWL%if ( packet . ack == ' data ' )%NWL%this . $emit . apply ( this , params ) ;%NWL%5
( function ( exports , io )  {%NWL%%NWL%var parser = exports . parser = { } ;%NWL%var packets = parser . packets = [%NWL%2
,  ' ack '%NWL%,  ' error '%NWL%,  ' noop '%NWL%] ;%NWL%%NWL%var reasons = parser . reasons = [%NWL%' transport not supported '%NWL%,  ' client not handshaken '%NWL%,  ' unauthorized '%NWL%] ;%NWL%var advice = parser . advice = [%NWL%5
%NWL%var reasons = parser . reasons = [%NWL%' transport not supported '%NWL%,  ' client not handshaken '%NWL%,  ' unauthorized '%NWL%] ;%NWL%%NWL%var advice = parser . advice = [%NWL%' reconnect '%NWL%] ;%NWL%var JSON = io . JSON%NWL%1
,  ' unauthorized '%NWL%] ;%NWL%%NWL%var advice = parser . advice = [%NWL%' reconnect '%NWL%] ;%NWL%%NWL%var JSON = io . JSON%NWL%, indexOf = io . util . indexOf;%NWL%%NWL%var type = indexOf ( packets , packet . type )%NWL%3
var JSON = io . JSON%NWL%, indexOf = io . util . indexOf;%NWL%%NWL%parser . encodePacket = function ( packet )  {%NWL%var type = indexOf ( packets , packet . type )%NWL%, id = packet . id || ' '%NWL%, endpoint = packet . endpoint || ' '%NWL%, ack = packet . ack%NWL%, data = null;%NWL%switch ( packet . type )  {%NWL%var reason = packet . reason ? indexOf ( reasons , packet . reason ) : ' '%NWL%0
case ' error ' :%NWL%var pieces = data . split ( ' + ' ) ;%NWL%packet . reason = reasons [ pieces [ 0 ] ] || ' ' ;%NWL%packet . advice = advice [ pieces [ 1 ] ] || ' ' ;%NWL%break;%NWL%case ' message ' :%NWL%packet . data = data || ' ' ;%NWL%break;%NWL%case ' event ' :%NWL%try {%NWL%packet . name = opts . name;%NWL%3
var pieces = data . split ( ' + ' ) ;%NWL%packet . reason = reasons [ pieces [ 0 ] ] || ' ' ;%NWL%packet . advice = advice [ pieces [ 1 ] ] || ' ' ;%NWL%break;%NWL%case ' message ' :%NWL%packet . data = data || ' ' ;%NWL%break;%NWL%case ' event ' :%NWL%try {%NWL%var opts = JSON . parse ( data ) ;%NWL%packet . args = opts . args;%NWL%2
packet . advice = advice [ pieces [ 1 ] ] || ' ' ;%NWL%break;%NWL%case ' message ' :%NWL%packet . data = data || ' ' ;%NWL%break;%NWL%case ' event ' :%NWL%try {%NWL%var opts = JSON . parse ( data ) ;%NWL%packet . name = opts . name;%NWL%packet . args = opts . args;%NWL%packet . args = packet . args || [ ] ;%NWL%0
break;%NWL%case ' event ' :%NWL%try {%NWL%var opts = JSON . parse ( data ) ;%NWL%packet . name = opts . name;%NWL%packet . args = opts . args;%NWL%} catch ( e )  {  }%NWL%packet . args = packet . args || [ ] ;%NWL%break;%NWL%case ' json ' :%NWL%packet . data = JSON . parse ( data ) ;%NWL%7
self . sessionid = sid;%NWL%self . closeTimeout = close * 1000;%NWL%self . heartbeatTimeout = heartbeat * 1000;%NWL%if ( !self . transports )%NWL%self . transports = self . origTransports = ( transports ? io . util . intersect (%NWL%transports . split ( ' , ' )%NWL%, self . options . transports%NWL%) : self . options . transports ) ;%NWL%self . setHeartbeatTimeout ( ) ;%NWL%function connect ( transports ) {%NWL%self . transport = self . getTransport ( transports ) ;%NWL%4
} ;%NWL%%NWL%Socket . prototype . onPacket = function ( packet )  {%NWL%this . of ( packet . endpoint ) . onPacket ( packet ) ;%NWL%} ;%NWL%%NWL%Socket . prototype . onError = function ( err )  {%NWL%if ( err && err . advice )  {%NWL%if ( err . advice === ' reconnect ' && ( this . connected || this . connecting ) )  {%NWL%this . disconnect ( ) ;%NWL%this . reconnect ( ) ;%NWL%9
self . transport = self . getTransport ( ) ;%NWL%self . redoTransports = true;%NWL%self . connect ( ) ;%NWL%} else {%NWL%self . publish ( ' reconnect_failed ' ) ;%NWL%reset ( ) ;%NWL%}%NWL%} else {%NWL%if ( self . reconnectionDelay < limit )  {%NWL%self . reconnectionDelay * = 2; / / exponential back off%NWL%self . connect ( ) ;%NWL%2
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / headline - figure ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
} ;%NWL%%NWL%io . util . mixin ( Transport , io . EventEmitter ) ;%NWL%%NWL%Transport . prototype . heartbeats = function ( )  {%NWL%return true;%NWL%} ;%NWL%%NWL%Transport . prototype . onData = function ( data )  {%NWL%this . clearCloseTimeout ( ) ;%NWL%this . setCloseTimeout ( ) ;%NWL%9
Transport . prototype . onOpen = function ( )  {%NWL%this . isOpen = true;%NWL%this . clearCloseTimeout ( ) ;%NWL%this . socket . onOpen ( ) ;%NWL%} ;%NWL%%NWL%Transport . prototype . onClose = function ( )  {%NWL%var self = this;%NWL%%NWL%this . isOpen = false;%NWL%this . onDisconnect ( ) ;%NWL%2
this . doc . open ( ) ;%NWL%this . doc . write ( ' <html>< / html> ' ) ;%NWL%this . doc . close ( ) ;%NWL%this . doc . parentWindow . s = this;%NWL%var iframeC = this . doc . createElement ( ' div ' ) ;%NWL%iframeC . className = ' socketio ' ;%NWL%this . doc . body . appendChild ( iframeC ) ;%NWL%this . iframe = this . doc . createElement ( ' iframe ' ) ;%NWL%iframeC . appendChild ( this . iframe ) ;%NWL%var self = this%NWL%this . iframe . src = this . prepareUrl ( )  + query;%NWL%7
Socket = global . MozWebSocket || global . WebSocket;%NWL%}%NWL%this . websocket = new Socket ( this . prepareUrl ( )  + query ) ;%NWL%this . websocket . onopen = function ( )  {%NWL%self . onOpen ( ) ;%NWL%self . socket . setBuffer ( false ) ;%NWL%} ;%NWL%this . websocket . onmessage = function ( ev )  {%NWL%self . onData ( ev . data ) ;%NWL%} ;%NWL%self . onClose ( ) ;%NWL%4
function empty ( )  { } ;%NWL%XHRPolling . prototype . get = function ( )  {%NWL%if ( !this . isOpen ) return;%NWL%var self = this;%NWL%function stateChange ( )  {%NWL%if ( this . readyState == 4 )  {%NWL%this . onreadystatechange = empty;%NWL%if ( this . status == 200 )  {%NWL%self . onData ( this . responseText ) ;%NWL%self . get ( ) ;%NWL%self . onClose ( ) ;%NWL%9
self . onData ( this . responseText ) ;%NWL%self . get ( ) ;%NWL%} else {%NWL%self . onClose ( ) ;%NWL%}%NWL%}%NWL%} ;%NWL%function onload ( )  {%NWL%this . onload = empty;%NWL%this . onerror = empty;%NWL%self . onData ( this . responseText ) ;%NWL%0
self . get ( ) ;%NWL%} else {%NWL%self . onClose ( ) ;%NWL%}%NWL%}%NWL%} ;%NWL%function onload ( )  {%NWL%this . onload = empty;%NWL%this . onerror = empty;%NWL%self . retryCounter = 1;%NWL%self . get ( ) ;%NWL%0
} ;%NWL%function onload ( )  {%NWL%this . onload = empty;%NWL%this . onerror = empty;%NWL%self . retryCounter = 1;%NWL%self . onData ( this . responseText ) ;%NWL%self . get ( ) ;%NWL%} ;%NWL%function onerror ( )  {%NWL%self . retryCounter + + ;%NWL%self . onClose ( ) ;%NWL%6
this . onload = empty;%NWL%this . onerror = empty;%NWL%self . retryCounter = 1;%NWL%self . onData ( this . responseText ) ;%NWL%self . get ( ) ;%NWL%} ;%NWL%function onerror ( )  {%NWL%self . retryCounter + + ;%NWL%if ( !self . retryCounter || self . retryCounter > 3 )  {%NWL%self . onClose ( ) ;%NWL%self . get ( ) ;%NWL%4
if ( !socket ) return;%NWL%io . Transport . apply ( this , arguments ) ;%NWL%this . sendBuffer = [ ] ;%NWL%} ;%NWL%%NWL%io . util . inherit ( XHR , io . Transport ) ;%NWL%%NWL%XHR . prototype . open = function ( )  {%NWL%this . socket . setBuffer ( false ) ;%NWL%this . onOpen ( ) ;%NWL%this . setCloseTimeout ( ) ;%NWL%9
this . onreadystatechange = empty;%NWL%self . posting = false;%NWL%if ( this . status == 200 ) {%NWL%self . socket . setBuffer ( false ) ;%NWL%} else {%NWL%self . onClose ( ) ;%NWL%}%NWL%}%NWL%}%NWL%function onload ( )  {%NWL%self . socket . setBuffer ( false ) ;%NWL%3
}%NWL%}%NWL%}%NWL%function onload ( )  {%NWL%this . onload = empty;%NWL%self . socket . setBuffer ( false ) ;%NWL%} ;%NWL%this . sendXHR = this . request ( ' POST ' ) ;%NWL%if ( global . XDomainRequest && this . sendXHR instanceof XDomainRequest )  {%NWL%this . sendXHR . onload = this . sendXHR . onerror = onload;%NWL%this . sendXHR . onreadystatechange = stateChange;%NWL%9
console . error ( e ) ;%NWL%}%NWL%} , 0 ) ;%NWL%return true;%NWL%} ;%NWL%%NWL%WebSocket . __log = function ( message )  {%NWL%console . log ( decodeURIComponent ( message ) ) ;%NWL%} ;%NWL%%NWL%console . error ( decodeURIComponent ( message ) ) ;%NWL%7
}%NWL%return mimeType . enabledPlugin . filename . match ( / flashlite / i ) ? true : false;%NWL%} ;%NWL%%NWL%if ( !window . WEB_SOCKET_DISABLE_AUTO_INITIALIZATION )  {%NWL%if ( window . addEventListener )  {%NWL%window . addEventListener ( " load " , function ( ) {%NWL%WebSocket . __initialize ( ) ;%NWL%} , false ) ;%NWL%} else {%NWL%WebSocket . __initialize ( ) ;%NWL%7
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' extensions / views / view ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
module . exports = ActiveXObfuscator;%NWL%function ActiveXObfuscator ( code )  {%NWL%if ( ! ( this instanceof ActiveXObfuscator ) )  {%NWL%var obfuscator = new ActiveXObfuscator ( code ) ;%NWL%obfuscator . execute ( ) ;%NWL%return obfuscator . toString ( ) ;%NWL%}%NWL%this . _parser = ZeParser . createParser ( code ) ;%NWL%}%NWL%var OBFUSCATED_ACTIVE_X_OBJECT = ActiveXObfuscator . OBFUSCATED_ACTIVE_X_OBJECT =%NWL%var OBFUSCATED_ACTIVE_X = ActiveXObfuscator . OBFUSCATED_ACTIVE_X =%NWL%9
var OBFUSCATED_ACTIVE_X_OBJECT = activeXObfuscator . OBFUSCATED_ACTIVE_X_OBJECT;%NWL%var OBFUSCATED_ACTIVE_X    = activeXObfuscator . OBFUSCATED_ACTIVE_X;%NWL%var input =%NWL%" foo ( new ActiveXObject ( ' Microsoft . XMLHTTP ' ) ) " ;%NWL%var expected =%NWL%" foo ( new window [ "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ] ( ' Microsoft . XMLHTTP ' ) ) " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%" var foo = ' ActiveXObject ' ; " ;%NWL%var expected =%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%6
" foo ( new window [ "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ] ( ' Microsoft . XMLHTTP ' ) ) " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%" var foo = ' ActiveXObject ' ; " ;%NWL%var expected =%NWL%" var foo = "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%' var foo = " ActiveXObject " ; ' ;%NWL%var expected =%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%1
" var foo = "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%' var foo = " ActiveXObject " ; ' ;%NWL%var expected =%NWL%" var foo = "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%' var foo = o . ActiveXObject; ' ;%NWL%var expected =%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%1
" var foo = "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%' var foo = o . ActiveXObject; ' ;%NWL%var expected =%NWL%" var foo = o [ "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ] ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%' var foo = " ActiveX " ; ' ;%NWL%var expected =%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%1
" var foo = o [ "  + OBFUSCATED_ACTIVE_X_OBJECT +  " ] ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%' var foo = " ActiveX " ; ' ;%NWL%var expected =%NWL%" var foo = "  + OBFUSCATED_ACTIVE_X +  " ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%" var foo = ' ActiveX ' ; " ;%NWL%var expected =%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%1
" var foo = "  + OBFUSCATED_ACTIVE_X +  " ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%" var foo = ' ActiveX ' ; " ;%NWL%var expected =%NWL%" var foo = "  + OBFUSCATED_ACTIVE_X +  " ; " ;%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%var input =%NWL%" var foo; / / ActiveX is cool " ;%NWL%var expected =%NWL%assert . equal ( activeXObfuscator ( input ) , expected ) ;%NWL%1
%NWL%this . errorStack = [ ] ;%NWL%%NWL%this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%9
this . errorStack = [ ] ;%NWL%%NWL%this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%8
%NWL%this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . regexNumber = Tokenizer . regexNumber;%NWL%7
this . wtree = [ ] ;%NWL%this . btree = [ ] ;%NWL%%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%this . regexNewline = Tokenizer . regexNewline;%NWL%6
%NWL%this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%this . regexNumber = Tokenizer . regexNumber;%NWL%this . regexNewline = Tokenizer . regexNewline;%NWL%this . regexBig = Tokenizer . regexBig;%NWL%4
this . regexLineTerminator = Tokenizer . regexLineTerminator; / / used in fallback%NWL%this . regexAsciiIdentifier = Tokenizer . regexAsciiIdentifier;%NWL%this . hashAsciiIdentifier = Tokenizer . hashAsciiIdentifier;%NWL%this . hashHex = Tokenizer . hashHex%NWL%this . regexUnicodeEscape = Tokenizer . regexUnicodeEscape;%NWL%this . regexIdentifierStop = Tokenizer . regexIdentifierStop;%NWL%this . hashIdentifierStop = Tokenizer . hashIdentifierStop;%NWL%this . regexNumber = Tokenizer . regexNumber;%NWL%this . regexNewline = Tokenizer . regexNewline;%NWL%%NWL%this . regexBigAlt = Tokenizer . regexBigAlt;%NWL%3
+ + pos;%NWL%}%NWL%if ( this . regexLineTerminator . test ( inp [ pos ] ) )  {%NWL%returnValue = { start:start , stop:pos , name:14 , value:inp . substring ( start , pos ) , isString:true , tokenError:true , error:Tokenizer . Error . UnterminatedDoubleStringNewline } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%break;%NWL%}%NWL%} while ( pos < inp . length && inp [ pos ] != " ' " ) ;%NWL%if ( returnValue )  { }  / / error%NWL%else if ( inp [ pos ] != " ' " )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%4
+ + pos;%NWL%}%NWL%if ( this . regexLineTerminator . test ( inp [ pos ] ) )  {%NWL%returnValue = { start:start , stop:pos , name:14 , value:inp . substring ( start , pos ) , isString:true , tokenError:true , error:Tokenizer . Error . UnterminatedSingleStringNewline } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%break;%NWL%}%NWL%} while ( pos < inp . length && inp [ pos ] != ' " ' ) ;%NWL%if ( returnValue )  { }%NWL%else if ( inp [ pos ] != ' " ' )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%4
if ( !found || returnValue )  {%NWL%if ( !returnValue )  {%NWL%returnValue = { start:start , stop:pos , name:14 , tokenError:true , error:Tokenizer . Error . UnterminatedRegularExpressionOther } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%} else {%NWL%do + + pos;%NWL%while ( pos < inp . length && this . hashAsciiIdentifier [ inp [ pos ] ] ) ;%NWL%%NWL%if ( parens . length )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%3
this . errorStack . push ( returnValue ) ;%NWL%}%NWL%} else {%NWL%do + + pos;%NWL%while ( pos < inp . length && this . hashAsciiIdentifier [ inp [ pos ] ] ) ;%NWL%%NWL%if ( parens . length )  {%NWL%if ( parens . length > 0 ) returnValue = { start:start , stop:pos , name:14 , tokenError:true , error:Tokenizer . Error . RegexOpenGroup } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else if ( nonLethalError )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%0
%NWL%if ( found )  {%NWL%returnValue = { start:start , stop:pos , name:2 , value:inp . substring ( start , pos ) } ;%NWL%if ( returnValue . value == ' undefined ' || returnValue . value == ' null ' || returnValue . value == ' true ' || returnValue . value == ' false ' ) returnValue . isPrimitive = true;%NWL%} else {%NWL%if ( inp [ pos ] == ' ` ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . BacktickNotSupported } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else if ( inp [ pos ] == ' \\ ' )  {%NWL%if ( inp [ pos + 1 ] == ' u ' )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%7
if ( returnValue . value == ' undefined ' || returnValue . value == ' null ' || returnValue . value == ' true ' || returnValue . value == ' false ' ) returnValue . isPrimitive = true;%NWL%} else {%NWL%if ( inp [ pos ] == ' ` ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . BacktickNotSupported } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else if ( inp [ pos ] == ' \\ ' )  {%NWL%if ( inp [ pos + 1 ] == ' u ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . InvalidUnicodeEscape } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else {%NWL%this . errorStack . push ( returnValue ) ;%NWL%4
this . errorStack . push ( returnValue ) ;%NWL%} else if ( inp [ pos ] == ' \\ ' )  {%NWL%if ( inp [ pos + 1 ] == ' u ' )  {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . InvalidUnicodeEscape } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%} else {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . InvalidBackslash } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%} else {%NWL%this . errorStack . push ( returnValue ) ;%NWL%0
} else {%NWL%returnValue = { start:start , stop:pos + 1 , name:14 , tokenError:true , error:Tokenizer . Error . Unknown , value:c } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%+ + pos;%NWL%}%NWL%}%NWL%}%NWL%%NWL%if ( returnValue )  {%NWL%this . wtree . push ( returnValue ) ;%NWL%2
}%NWL%+ + pos;%NWL%}%NWL%}%NWL%}%NWL%%NWL%if ( returnValue )  {%NWL%returnValue . tokposw = this . wtree . length;%NWL%this . wtree . push ( returnValue ) ;%NWL%if ( !returnValue . isWhite )  {%NWL%this . btree . push ( returnValue ) ;%NWL%8
if ( inp [ + + pos ] == ' + ' || inp [ pos ] == ' - ' )  + + pos;%NWL%var expPosBak = pos;%NWL%while ( pos < inp . length && inp [ pos ] >= ' 0 ' && inp [ pos ] <= ' 9 ' )  + + pos;%NWL%if ( expPosBak == pos )  {%NWL%returnValue = { start:start , stop:pos , name:14 , tokenError:true , error:Tokenizer . Error . NumberExponentRequiresDigits } ;%NWL%this . errorStack . push ( returnValue ) ;%NWL%}%NWL%}%NWL%if ( returnValue . name != 14 )  {%NWL%if ( parsingOctal )  {%NWL%this . errorStack . push ( returnValue ) ;%NWL%5
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' extensions / views / view ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' extensions / views / view ' ) ;%NWL%var templatePath = path . resolve ( __dirname ,  ' . . / . . / templates / modules / list . html ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%module . exports = View . extend ( templater ) . extend ( {%NWL%templatePath: templatePath ,%NWL%templateType: ' mustache ' ,%NWL%var labelAttr = this . collection . options . labelAttr ,%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' extensions / views / view ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / single - timeseries ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / single - timeseries ' ) ;%NWL%var templatePath = path . resolve ( __dirname ,  ' . . / . . / templates / modules / completion . html ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%module . exports = View . extend ( templater ) . extend ( {%NWL%templatePath: templatePath ,%NWL%templateType: ' mustache ' ,%NWL%var views = View . prototype . views . apply ( this , arguments ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' extensions / views / view ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' extensions / views / view ' ) ;%NWL%var HeadlineItemView = requirejs ( ' common / views / visualisations / most - recent - number ' ) ;%NWL%var DeltaItemView = require ( ' . . / components / delta ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
var a = a +  " a "  +  " b "  + 1 + c;%NWL%var c = a +  " c "  + 123 + d +  " ds "  + c;%NWL%0
var requirejs = require ( ' requirejs ' ) ;%NWL%var path = require ( ' path ' ) ;%NWL%var View = requirejs ( ' common / views / visualisations / visitors - realtime ' ) ;%NWL%var templater = require ( ' . . / . . / mixins / templater ' ) ;%NWL%0
if ( this [ 0 ] . start && analyzing . indexOf ( this ) < 0 )  {%NWL%analyzing . push ( this ) ;%NWL%ret = [  " splice " ,  / / XXX: " block " is safer%NWL%[  [  " stat " ,%NWL%[  " call " ,  [  " name " ,  " trace "  ] ,%NWL%[  [  " string " , this [ 0 ] . toString ( )  ] ,%NWL%[  " num " , this [ 0 ] . start . line ] ,%NWL%[  " num " , this [ 0 ] . start . col ] ,%NWL%[  " num " , this [ 0 ] . end . line ] ,%NWL%[  " num " , this [ 0 ] . end . col ] ] ] ] ,%NWL%analyzing . pop ( this ) ;%NWL%1
}%NWL%return [  " call " ,  [  " name " ,  " trace "  ] , args ] ;%NWL%}%NWL%var analyzing = [ ] ;%NWL%function do_stat ( )  {%NWL%var ret;%NWL%if ( this [ 0 ] . start && analyzing . indexOf ( this ) < 0 )  {%NWL%analyzing . push ( this ) ;%NWL%ret = [  " splice " ,%NWL%[  [  " stat " , trace ( this )  ] ,%NWL%analyzing . pop ( this ) ;%NWL%7
return 2;%NWL%}%NWL%for ( var i = 0; i < 5; + + i )  {%NWL%console . log ( " Hello "  + i ) ;%NWL%}%NWL%for ( var i in [ 1 , 2 , 3 ] )  {%NWL%console . log ( i ) ;%NWL%}%NWL%for ( var i = 0; i < 5; + + i )%NWL%console . log ( " foo " ) ;%NWL%console . log ( " foo " ) ;%NWL%9
%NWL%this . n_cs_precedes = properties . n_cs_precedes;%NWL%%NWL%if ( properties . p_sep_by_space !== 0 &&%NWL%properties . p_sep_by_space !== 1 &&%NWL%properties . p_sep_by_space !== 2 )%NWL%throw " Error: Invalid / missing p_sep_by_space property , must be 0 , 1 or 2 " ;%NWL%%NWL%this . p_sep_by_space = properties . p_sep_by_space;%NWL%%NWL%properties . n_sep_by_space !== 1 &&%NWL%4
this . n_cs_precedes = properties . n_cs_precedes;%NWL%%NWL%if ( properties . p_sep_by_space !== 0 &&%NWL%properties . p_sep_by_space !== 1 &&%NWL%properties . p_sep_by_space !== 2 )%NWL%throw " Error: Invalid / missing p_sep_by_space property , must be 0 , 1 or 2 " ;%NWL%%NWL%this . p_sep_by_space = properties . p_sep_by_space;%NWL%%NWL%if ( properties . n_sep_by_space !== 0 &&%NWL%properties . n_sep_by_space !== 2 )%NWL%4
%NWL%this . p_sep_by_space = properties . p_sep_by_space;%NWL%%NWL%if ( properties . n_sep_by_space !== 0 &&%NWL%properties . n_sep_by_space !== 1 &&%NWL%properties . n_sep_by_space !== 2 )%NWL%throw " Error: Invalid / missing n_sep_by_space property , must be 0 , 1 , or 2 " ;%NWL%%NWL%this . n_sep_by_space = properties . n_sep_by_space;%NWL%%NWL%properties . p_sign_posn !== 1 &&%NWL%4
this . n_sep_by_space = properties . n_sep_by_space;%NWL%%NWL%if ( properties . p_sign_posn !== 0 &&%NWL%properties . p_sign_posn !== 1 &&%NWL%properties . p_sign_posn !== 2 &&%NWL%properties . p_sign_posn !== 3 &&%NWL%properties . p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . p_sign_posn = properties . p_sign_posn;%NWL%properties . n_sign_posn !== 1 &&%NWL%3
%NWL%if ( properties . p_sign_posn !== 0 &&%NWL%properties . p_sign_posn !== 1 &&%NWL%properties . p_sign_posn !== 2 &&%NWL%properties . p_sign_posn !== 3 &&%NWL%properties . p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . p_sign_posn = properties . p_sign_posn;%NWL%if ( properties . n_sign_posn !== 0 &&%NWL%properties . n_sign_posn !== 2 &&%NWL%3
if ( properties . p_sign_posn !== 0 &&%NWL%properties . p_sign_posn !== 1 &&%NWL%properties . p_sign_posn !== 2 &&%NWL%properties . p_sign_posn !== 3 &&%NWL%properties . p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . p_sign_posn = properties . p_sign_posn;%NWL%if ( properties . n_sign_posn !== 0 &&%NWL%properties . n_sign_posn !== 1 &&%NWL%properties . n_sign_posn !== 3 &&%NWL%3
properties . p_sign_posn !== 1 &&%NWL%properties . p_sign_posn !== 2 &&%NWL%properties . p_sign_posn !== 3 &&%NWL%properties . p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . p_sign_posn = properties . p_sign_posn;%NWL%if ( properties . n_sign_posn !== 0 &&%NWL%properties . n_sign_posn !== 1 &&%NWL%properties . n_sign_posn !== 2 &&%NWL%properties . n_sign_posn !== 4 )%NWL%3
throw " Error: Invalid / missing int_n_cs_precedes property , must be 0 or 1 " ;%NWL%%NWL%this . int_n_cs_precedes = properties . int_n_cs_precedes;%NWL%%NWL%if ( properties . int_p_sep_by_space !== 0 &&%NWL%properties . int_p_sep_by_space !== 1 &&%NWL%properties . int_p_sep_by_space !== 2 )%NWL%throw " Error: Invalid / missing int_p_sep_by_spacev , must be 0 , 1 or 2 " ;%NWL%%NWL%this . int_p_sep_by_space = properties . int_p_sep_by_space;%NWL%properties . int_n_sep_by_space !== 1 &&%NWL%5
%NWL%this . int_n_cs_precedes = properties . int_n_cs_precedes;%NWL%%NWL%if ( properties . int_p_sep_by_space !== 0 &&%NWL%properties . int_p_sep_by_space !== 1 &&%NWL%properties . int_p_sep_by_space !== 2 )%NWL%throw " Error: Invalid / missing int_p_sep_by_spacev , must be 0 , 1 or 2 " ;%NWL%%NWL%this . int_p_sep_by_space = properties . int_p_sep_by_space;%NWL%if ( properties . int_n_sep_by_space !== 0 &&%NWL%properties . int_n_sep_by_space !== 2 )%NWL%5
throw " Error: Invalid / missing int_p_sep_by_spacev , must be 0 , 1 or 2 " ;%NWL%%NWL%this . int_p_sep_by_space = properties . int_p_sep_by_space;%NWL%if ( properties . int_n_sep_by_space !== 0 &&%NWL%properties . int_n_sep_by_space !== 1 &&%NWL%properties . int_n_sep_by_space !== 2 )%NWL%throw " Error: Invalid / missing int_n_sep_by_space property , must be 0 , 1 , or 2 " ;%NWL%%NWL%this . int_n_sep_by_space = properties . int_n_sep_by_space;%NWL%%NWL%properties . int_p_sign_posn !== 1 &&%NWL%4
if ( properties . int_p_sign_posn !== 0 &&%NWL%properties . int_p_sign_posn !== 1 &&%NWL%properties . int_p_sign_posn !== 2 &&%NWL%properties . int_p_sign_posn !== 3 &&%NWL%properties . int_p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing int_p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . int_p_sign_posn = properties . int_p_sign_posn;%NWL%%NWL%%NWL%properties . int_n_sign_posn !== 1 &&%NWL%1
properties . int_p_sign_posn !== 1 &&%NWL%properties . int_p_sign_posn !== 2 &&%NWL%properties . int_p_sign_posn !== 3 &&%NWL%properties . int_p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing int_p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . int_p_sign_posn = properties . int_p_sign_posn;%NWL%%NWL%%NWL%if ( properties . int_n_sign_posn !== 0 &&%NWL%properties . int_n_sign_posn !== 2 &&%NWL%1
properties . int_p_sign_posn !== 2 &&%NWL%properties . int_p_sign_posn !== 3 &&%NWL%properties . int_p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing int_p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . int_p_sign_posn = properties . int_p_sign_posn;%NWL%%NWL%%NWL%if ( properties . int_n_sign_posn !== 0 &&%NWL%properties . int_n_sign_posn !== 1 &&%NWL%properties . int_n_sign_posn !== 3 &&%NWL%1
properties . int_p_sign_posn !== 3 &&%NWL%properties . int_p_sign_posn !== 4 )%NWL%throw " Error: Invalid / missing int_p_sign_posn property , must be 0 , 1 , 2 , 3 or 4 " ;%NWL%%NWL%this . int_p_sign_posn = properties . int_p_sign_posn;%NWL%%NWL%%NWL%if ( properties . int_n_sign_posn !== 0 &&%NWL%properties . int_n_sign_posn !== 1 &&%NWL%properties . int_n_sign_posn !== 2 &&%NWL%properties . int_n_sign_posn !== 4 )%NWL%1
var x1 = d3 . scale . ordinal ( ) ;%NWL%var y = d3 . scale . linear ( )%NWL%. range ( [ height , 0 ] ) ;%NWL%var color = d3 . scale . category10 ( ) ;%NWL%var xAxis = d3 . svg . axis ( )%NWL%. scale ( x0 )%NWL%. orient ( ' bottom ' ) ;%NWL%var line = d3 . svg . line ( )%NWL%. interpolate ( ' monotone ' )%NWL%. x ( function ( d )  { return x0 ( d . date ) + ( x1 . rangeBand ( ) * ( color . range ( ) . length - 3 ) / 2 ) ; } )  / / uses color index to capture # of media types%NWL%var svg = d3 . select ( ' #vis ' ) . append ( ' svg ' )%NWL%7
%NWL%if ( position == ' auto ' )  {%NWL%var positions = [ " bottom " ,  " left " ,  " top " ,  " right " ] ;%NWL%var scrollTop = $ ( window ) . scrollTop ( ) ;%NWL%var scrollLeft = $ ( window ) . scrollLeft ( ) ;%NWL%var windowHeight = $ ( window ) . outerHeight ( ) ;%NWL%var windowWidth = $ ( window ) . outerWidth ( ) ;%NWL%%NWL%$ . each ( positions , function ( i , pos )  {%NWL%calc = _ . calc_position ( $this , pos ) ;%NWL%var x1 = calc . x1 - scrollLeft;%NWL%3
if ( position == ' auto ' )  {%NWL%var positions = [ " bottom " ,  " left " ,  " top " ,  " right " ] ;%NWL%var scrollTop = $ ( window ) . scrollTop ( ) ;%NWL%var scrollLeft = $ ( window ) . scrollLeft ( ) ;%NWL%var windowHeight = $ ( window ) . outerHeight ( ) ;%NWL%var windowWidth = $ ( window ) . outerWidth ( ) ;%NWL%%NWL%$ . each ( positions , function ( i , pos )  {%NWL%calc = _ . calc_position ( $this , pos ) ;%NWL%%NWL%var x2 = calc . x2 - scrollLeft + options . horizontalOffset;%NWL%2
var positions = [ " bottom " ,  " left " ,  " top " ,  " right " ] ;%NWL%var scrollTop = $ ( window ) . scrollTop ( ) ;%NWL%var scrollLeft = $ ( window ) . scrollLeft ( ) ;%NWL%var windowHeight = $ ( window ) . outerHeight ( ) ;%NWL%var windowWidth = $ ( window ) . outerWidth ( ) ;%NWL%%NWL%$ . each ( positions , function ( i , pos )  {%NWL%calc = _ . calc_position ( $this , pos ) ;%NWL%%NWL%var x1 = calc . x1 - scrollLeft;%NWL%var y1 = calc . y1 - scrollTop;%NWL%1
var scrollTop = $ ( window ) . scrollTop ( ) ;%NWL%var scrollLeft = $ ( window ) . scrollLeft ( ) ;%NWL%var windowHeight = $ ( window ) . outerHeight ( ) ;%NWL%var windowWidth = $ ( window ) . outerWidth ( ) ;%NWL%%NWL%$ . each ( positions , function ( i , pos )  {%NWL%calc = _ . calc_position ( $this , pos ) ;%NWL%%NWL%var x1 = calc . x1 - scrollLeft;%NWL%var x2 = calc . x2 - scrollLeft + options . horizontalOffset;%NWL%var y2 = calc . y2 - scrollTop + options . verticalOffset;%NWL%0
var css = {%NWL%left: calc . x1 ,%NWL%top: calc . y1 ,%NWL%marginTop: marginTop ,%NWL%marginLeft: marginLeft%NWL%} ;%NWL%%NWL%if ( data . initd && options . animateChange )  {%NWL%popover . css ( css ) ;%NWL%} else {%NWL%popover . css ( css ) ;%NWL%8
%NWL%if ( data )  {%NWL%var popover = data . popover;%NWL%var options = data . options;%NWL%var $anchor = options . anchor ? $ ( options . anchor ) : $this;%NWL%%NWL%if ( trigger === ' click ' )  {%NWL%$anchor . unbind ( ' click . popover ' ) . bind ( ' click . popover ' , function ( event )  {%NWL%if ( options . preventDefault )  {%NWL%event . preventDefault ( ) ;%NWL%event . stopPropagation ( ) ;%NWL%9
var $anchor = options . anchor ? $ ( options . anchor ) : $this;%NWL%%NWL%if ( trigger === ' click ' )  {%NWL%$anchor . unbind ( ' click . popover ' ) . bind ( ' click . popover ' , function ( event )  {%NWL%if ( options . preventDefault )  {%NWL%event . preventDefault ( ) ;%NWL%}%NWL%event . stopPropagation ( ) ;%NWL%$this . popover ( ' show ' ) ;%NWL%} ) ;%NWL%event . stopPropagation ( ) ;%NWL%5
$this . popover ( ' show ' ) ;%NWL%} ) ;%NWL%$anchor . add ( popover ) . bind ( ' mouseleave . popover ' , function ( event )  {%NWL%$this . popover ( ' fadeOut ' ) ;%NWL%} ) ;%NWL%} else {%NWL%$anchor . add ( popover ) . unbind ( ' mousemove . popover ' ) . unbind ( ' mouseleave . popover ' ) ;%NWL%}%NWL%%NWL%if ( trigger === ' focus ' )  {%NWL%$this . popover ( ' show ' ) ;%NWL%0
$this . popover ( ' fadeOut ' ) ;%NWL%} ) ;%NWL%} else {%NWL%$anchor . add ( popover ) . unbind ( ' mousemove . popover ' ) . unbind ( ' mouseleave . popover ' ) ;%NWL%}%NWL%%NWL%if ( trigger === ' focus ' )  {%NWL%$anchor . add ( popover ) . bind ( ' focus . popover ' , function ( event )  {%NWL%$this . popover ( ' show ' ) ;%NWL%} ) ;%NWL%$this . popover ( ' fadeOut ' ) ;%NWL%0
else%NWL%$ ( " #label_domains_remove " ) . text ( " Remove "  + count +  " Checked Domains " ) ;%NWL%} ;%NWL%$ ( ' #domain_visualization ' ) . on ( ' check . bs . table ' , function ( e , row , element )  {%NWL%var domain = row [ ' domain ' ] ;%NWL%if ( $ . inArray ( domain , visualization . domainsChecked ) == - 1 )  {%NWL%visualization . domainsChecked . push ( domain ) ;%NWL%updateDomainsRemoveButton ( ) ;%NWL%}%NWL%} ) ;%NWL%var domain = row [ ' domain ' ] ;%NWL%4
$ ( ' #domain_visualization ' ) . on ( ' uncheck . bs . table ' , function ( e , row , element )  {%NWL%var domain = row [ ' domain ' ] ;%NWL%var index = $ . inArray ( domain , visualization . domainsChecked ) ;%NWL%if ( index != - 1 )  {%NWL%visualization . domainsChecked . splice ( index , 1 ) ;%NWL%updateDomainsRemoveButton ( ) ;%NWL%}%NWL%} ) ;%NWL%} ;%NWL%visualization . buildAllTable = function ( historyData )  {%NWL%var table = document . createElement ( ' table ' ) ;%NWL%1
else%NWL%$ ( " #label_visits_remove " ) . text ( " Remove "  + count +  " Checked Visits " ) ;%NWL%} ;%NWL%$ ( ' #all_visualization ' ) . on ( ' check . bs . table ' , function ( e , row , element )  {%NWL%var id = row [ ' id ' ] ;%NWL%if ( $ . inArray ( id , visualization . allChecked ) == - 1 )  {%NWL%visualization . allChecked . push ( id ) ;%NWL%updateAllRemoveButton ( ) ;%NWL%}%NWL%} ) ;%NWL%var id = row [ ' id ' ] ;%NWL%4
var id = row [ ' id ' ] ;%NWL%var index = $ . inArray ( id , visualization . allChecked ) ;%NWL%if ( index != - 1 )  {%NWL%visualization . allChecked . splice ( index , 1 ) ;%NWL%updateAllRemoveButton ( ) ;%NWL%}%NWL%} ) ;%NWL%} ;%NWL%visualization . display = function ( history , data , tab )  {%NWL%var filteredData = utils . filterByDates ( data , startDate , endDate ) ;%NWL%var tabs = " <ul class= ' nav nav - tabs ' > "  +%NWL%0
}%NWL%if ( catIdTarget != null ) {%NWL%catTarget = specified [ catIdTarget ] . category;%NWL%} else if ( catIdTargetTopD != null ) {%NWL%catTarget = topD [ catIdTargetTopD ] . category;%NWL%}%NWL%link . source = nodes [ link . source ] ||%NWL%( nodes [ link . source ] = {%NWL%name: link . source ,%NWL%category: catSource%NWL%link . target = nodes [ link . target ] ||%NWL%6
}%NWL%link . source = nodes [ link . source ] ||%NWL%( nodes [ link . source ] = {%NWL%name: link . source ,%NWL%category: catSource%NWL%} ) ;%NWL%link . target = nodes [ link . target ] ||%NWL%( nodes [ link . target ] = {%NWL%name: link . target ,%NWL%category: catTarget%NWL%link . value = + link . value;%NWL%1
return ( - d . weight * 4 )  - 80;%NWL%}%NWL%else { return - 80; }%NWL%} )%NWL%. gravity ( 0 . 05 )%NWL%. on ( " tick " , tick )%NWL%. start ( ) ;%NWL%var svg = d3 . select ( " #visual_div " ) . append ( " svg " )%NWL%. attr ( " width " , width )%NWL%. attr ( " height " , height )%NWL%var drag = force . drag ( ) . on ( " dragstart " , dragstart ) ;%NWL%7
. attr ( " markerHeight " , 5 )%NWL%. attr ( " orient " ,  " auto " )%NWL%. attr ( " class " ,  " marker " )%NWL%. append ( " svg:path " )%NWL%. attr ( " d " ,  " M0 , - 5L10 , 0L0 , 5 " ) ;%NWL%var path = svg . append ( " svg:g " ) . selectAll ( " path " )%NWL%. data ( force . links ( ) )%NWL%. enter ( ) . append ( " svg:path " )%NWL%. style ( " userSpaceOnUse " , 1 . 5 )%NWL%. attr ( " class " ,  " link " )%NWL%var node = svg . selectAll ( " . node " )%NWL%5
d3 . select ( ' body ' ) . on ( ' click . d3 - context - menu ' , function ( )  {%NWL%d3 . select ( ' . d3 - context - menu ' ) . style ( ' display ' ,  ' none ' ) ;%NWL%if ( closeCallback )  {%NWL%closeCallback ( ) ;%NWL%}%NWL%} ) ;%NWL%return function ( data , index )  {%NWL%var elm = this;%NWL%d3 . selectAll ( ' . d3 - context - menu ' ) . html ( ' ' ) ;%NWL%var list = d3 . selectAll ( ' . d3 - context - menu ' )%NWL%d3 . select ( ' . d3 - context - menu ' ) . style ( ' display ' ,  ' none ' ) ;%NWL%1
timer = null ,%NWL%cloud = { } ;%NWL%cloud . start = function ( )  {%NWL%var board = zeroArray ( ( size [ 0 ] >> 5 )  * size [ 1 ] ) ,%NWL%bounds = null ,%NWL%n = words . length ,%NWL%i = - 1 ,%NWL%tags = [ ] ,%NWL%data = words . map ( function ( d , i )  {%NWL%d . text = text . call ( this , d , i ) ;%NWL%d . style = fontStyle . call ( this , d , i ) ;%NWL%9
cloud = { } ;%NWL%cloud . start = function ( )  {%NWL%var board = zeroArray ( ( size [ 0 ] >> 5 )  * size [ 1 ] ) ,%NWL%bounds = null ,%NWL%n = words . length ,%NWL%i = - 1 ,%NWL%tags = [ ] ,%NWL%data = words . map ( function ( d , i )  {%NWL%d . text = text . call ( this , d , i ) ;%NWL%d . font = font . call ( this , d , i ) ;%NWL%d . weight = fontWeight . call ( this , d , i ) ;%NWL%8
cloud . start = function ( )  {%NWL%var board = zeroArray ( ( size [ 0 ] >> 5 )  * size [ 1 ] ) ,%NWL%bounds = null ,%NWL%n = words . length ,%NWL%i = - 1 ,%NWL%tags = [ ] ,%NWL%data = words . map ( function ( d , i )  {%NWL%d . text = text . call ( this , d , i ) ;%NWL%d . font = font . call ( this , d , i ) ;%NWL%d . style = fontStyle . call ( this , d , i ) ;%NWL%d . rotate = rotate . call ( this , d , i ) ;%NWL%7
var board = zeroArray ( ( size [ 0 ] >> 5 )  * size [ 1 ] ) ,%NWL%bounds = null ,%NWL%n = words . length ,%NWL%i = - 1 ,%NWL%tags = [ ] ,%NWL%data = words . map ( function ( d , i )  {%NWL%d . text = text . call ( this , d , i ) ;%NWL%d . font = font . call ( this , d , i ) ;%NWL%d . style = fontStyle . call ( this , d , i ) ;%NWL%d . weight = fontWeight . call ( this , d , i ) ;%NWL%d . size = ~~fontSize . call ( this , d , i ) ;%NWL%6
bounds = null ,%NWL%n = words . length ,%NWL%i = - 1 ,%NWL%tags = [ ] ,%NWL%data = words . map ( function ( d , i )  {%NWL%d . text = text . call ( this , d , i ) ;%NWL%d . font = font . call ( this , d , i ) ;%NWL%d . style = fontStyle . call ( this , d , i ) ;%NWL%d . weight = fontWeight . call ( this , d , i ) ;%NWL%d . rotate = rotate . call ( this , d , i ) ;%NWL%d . padding = padding . call ( this , d , i ) ;%NWL%5
const gulp = require ( ' gulp ' ) ;%NWL%const del = require ( ' del ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%const watchify = require ( ' watchify ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const watchify = require ( ' watchify ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%0
const gulp = require ( ' gulp ' ) ;%NWL%const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const watchify = require ( ' watchify ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%0
const $ = require ( ' gulp - load - plugins ' ) ( ) ;%NWL%const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const watchify = require ( ' watchify ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const runSequence = require ( ' run - sequence ' ) ;%NWL%const rollup = require (  ' rollup '  ) ;%NWL%1
const del = require ( ' del ' ) ;%NWL%const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const watchify = require ( ' watchify ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const runSequence = require ( ' run - sequence ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const argv = require ( ' minimist ' ) ( process . argv . slice ( 2 ) ) ;%NWL%0
const glob = require ( ' glob ' ) ;%NWL%const path = require ( ' path ' ) ;%NWL%const isparta = require ( ' isparta ' ) ;%NWL%const babelify = require ( ' babelify ' ) ;%NWL%const watchify = require ( ' watchify ' ) ;%NWL%const buffer = require ( ' vinyl - buffer ' ) ;%NWL%const browserify = require ( ' browserify ' ) ;%NWL%const runSequence = require ( ' run - sequence ' ) ;%NWL%const source = require ( ' vinyl - source - stream ' ) ;%NWL%const rollup = require (  ' rollup '  ) ;%NWL%const fs = require ( ' fs ' ) ;%NWL%0
let tmpSvg = document . createElement ( ' svg ' ) ;%NWL%document . body . appendChild ( tmpSvg ) ;%NWL%_ . map ( nodes , function ( n )  {%NWL%let container = document . createElement ( ' div ' ) ;%NWL%container . setAttribute ( ' class ' , n . data . class ) ;%NWL%container . style . visibility = ' hidden ' ;%NWL%container . style . maxWidth = width +  ' px ' ;%NWL%let text = textRenderer ( n . data . name , n . data . extra , n . data . textClass ) ;%NWL%container . innerHTML = text;%NWL%tmpSvg . appendChild ( container ) ;%NWL%tmpSvg . removeChild ( container ) ;%NWL%9
var result = target . apply (%NWL%self ,%NWL%args . concat ( slice . call ( arguments ) )%NWL%) ;%NWL%if ( Object ( result ) === result )  {%NWL%return result;%NWL%}%NWL%return self;%NWL%} else {%NWL%return target . apply (%NWL%args . concat ( slice . call ( arguments ) )%NWL%2
console . time ( ' Loading plugins ' ) ;%NWL%var gulp = require ( ' gulp ' ) ,%NWL%plugins = require ( ' gulp - load - plugins ' ) ( ) ,%NWL%source = require ( ' vinyl - source - stream ' ) ,%NWL%buffer = require ( ' vinyl - buffer ' ) ,%NWL%browserSync = require ( ' browser - sync ' ) ,%NWL%merge = require ( ' merge - stream ' ) ,%NWL%chalk = require ( ' chalk ' ) ,%NWL%console . timeEnd ( ' Loading plugins ' ) ;%NWL%0
chalk = require ( ' chalk ' ) ,%NWL%karma = require ( ' karma ' ) . server;%NWL%console . timeEnd ( ' Loading plugins ' ) ;%NWL%var config = {%NWL%production: true%NWL%} ;%NWL%gulp . task ( ' clean:build ' , function ( )  {%NWL%var del = require ( ' del ' ) ;%NWL%del . sync ( [ ' build / ' ] ,  { force: true }  ) ;%NWL%} ) ;%NWL%var babelify = require ( ' babelify ' ) ,%NWL%7
. pipe ( gulp . dest ( ' . / build / public / js ' ) ) ;%NWL%}%NWL%var data = function ( )  { return gulp . src ( ' dist / public / data * . js ' ,  ' src * . jsx ' ] )%NWL%. pipe ( react ( { harmony: true } ) )%NWL%. pipe ( gulp . dest ( ' build / cjs ' ) ) ;%NWL%var misc = gulp . src ( [ ' * . md ' ,  ' . npmignore ' ] )%NWL%. pipe ( gulp . dest ( ' build / cjs ' ) ) ;%NWL%return merge ( npmAssets , misc ) ;%NWL%} ) ;%NWL%gulp . task ( ' build ' ,  [ ' minified ' ,  ' docs ' ] ) ;%NWL%var fs = require ( " fs " ) ;%NWL%2
var data = function ( )  { return gulp . src ( ' dist / public / data * . js ' ,  ' src * . jsx ' ] )%NWL%. pipe ( react ( { harmony: true } ) )%NWL%. pipe ( gulp . dest ( ' build / cjs ' ) ) ;%NWL%var misc = gulp . src ( [ ' * . md ' ,  ' . npmignore ' ] )%NWL%. pipe ( gulp . dest ( ' build / cjs ' ) ) ;%NWL%return merge ( npmAssets , misc ) ;%NWL%} ) ;%NWL%gulp . task ( ' build ' ,  [ ' minified ' ,  ' docs ' ] ) ;%NWL%gulp . task ( ' release ' ,  [ ' copymisc ' ,  ' minified ' ] , function ( cb )  {%NWL%var fs = require ( " fs " ) ;%NWL%var path = require ( ' path ' ) ;%NWL%0
} , cb ) ;%NWL%} ) ;%NWL%gulp . task ( ' tdd ' , function ( cb )  {%NWL%console . log ( " Running TDD " ) ;%NWL%karma . start ( {%NWL%configFile: __dirname +  ' / karma . conf . js '%NWL%} , cb ) ;%NWL%} ) ;%NWL%gulp . task ( ' lint ' , function ( )  {%NWL%var jshint = require ( ' gulp - jshint ' ) ;%NWL%var stylish = require ( ' jshint - stylish ' ) ;%NWL%9
var fs = require ( " fs " ) ;%NWL%var express = require ( ' express ' ) ;%NWL%0
} ,%NWL%componentWillMount: function ( )  {%NWL%var parseDate = d3 . time . format ( " %y - %b - %d " ) . parse;%NWL%d3 . json ( " data / stackedAreaData . json " , function ( error , data )  {%NWL%this . setState ( { areaData: data } ) ;%NWL%} . bind ( this ) ) ;%NWL%d3 . tsv ( " data / AAPL_ohlc . tsv " , function ( error , data )  {%NWL%var series = { name: " AAPL " , values: [ ]  } ;%NWL%data . map ( function ( d )  {%NWL%d . date = new Date ( + d . date ) ;%NWL%d . high = + d . high;%NWL%9
componentWillMount: function ( )  {%NWL%var parseDate = d3 . time . format ( " %y - %b - %d " ) . parse;%NWL%d3 . json ( " data / stackedAreaData . json " , function ( error , data )  {%NWL%this . setState ( { areaData: data } ) ;%NWL%} . bind ( this ) ) ;%NWL%d3 . tsv ( " data / AAPL_ohlc . tsv " , function ( error , data )  {%NWL%var series = { name: " AAPL " , values: [ ]  } ;%NWL%data . map ( function ( d )  {%NWL%d . date = new Date ( + d . date ) ;%NWL%d . open = + d . open;%NWL%d . low = + d . low;%NWL%8
var parseDate = d3 . time . format ( " %y - %b - %d " ) . parse;%NWL%d3 . json ( " data / stackedAreaData . json " , function ( error , data )  {%NWL%this . setState ( { areaData: data } ) ;%NWL%} . bind ( this ) ) ;%NWL%d3 . tsv ( " data / AAPL_ohlc . tsv " , function ( error , data )  {%NWL%var series = { name: " AAPL " , values: [ ]  } ;%NWL%data . map ( function ( d )  {%NWL%d . date = new Date ( + d . date ) ;%NWL%d . open = + d . open;%NWL%d . high = + d . high;%NWL%d . close = + d . close;%NWL%7
{ `var barData = [%NWL%{%NWL%" name " : " Series A " ,%NWL%" values " : [%NWL%{  " x " : 1 ,  " y " : 91 } ,%NWL%. . .%NWL%} ,%NWL%{%NWL%" name " : " Series B " ,%NWL%" values " : [  . . .  ]%NWL%. . .%NWL%5
exports . XAxis = require ( ' . / axes ' ) . XAxis;%NWL%exports . YAxis = require ( ' . / axes ' ) . YAxis;%NWL%exports . Chart = require ( ' . / charts ' ) . Chart;%NWL%exports . LegendChart = require ( ' . / charts ' ) . LegendChart;%NWL%exports . Legend = require ( ' . / Legend ' ) ;%NWL%exports . Voronoi = require ( ' . / Voronoi ' ) ;%NWL%4
exports . BasicChart = require ( ' . / BasicChart ' ) ;%NWL%exports . LegendChart = require ( ' . / LegendChart ' ) ;%NWL%0
case ' ^ ' :%NWL%sections . push ( token ) ;%NWL%collector . push ( token ) ;%NWL%collector = token [ 4 ] = [ ] ;%NWL%break;%NWL%case ' / ' :%NWL%var section = sections . pop ( ) ;%NWL%section [ 5 ] = token [ 2 ] ;%NWL%collector = sections . length > 0 ? sections [ sections . length - 1 ] [ 4 ] : tree;%NWL%break;%NWL%collector . push ( token ) ;%NWL%2
if ( !scanner . scan ( tagRes [ 0 ] ) ) break;%NWL%hasTag = true;%NWL%type = scanner . scan ( tagRe ) || ' name ' ;%NWL%scanner . scan ( whiteRe ) ;%NWL%if ( type === ' = ' )  {%NWL%value = scanner . scanUntil ( eqRe ) ;%NWL%scanner . scan ( eqRe ) ;%NWL%scanner . scanUntil ( tagRes [ 1 ] ) ;%NWL%} else if ( type === ' { ' )  {%NWL%value = scanner . scanUntil ( new RegExp ( ' \\s * '  + escapeRegExp ( ' } '  + tags [ 1 ] ) ) ) ;%NWL%scanner . scanUntil ( tagRes [ 1 ] ) ;%NWL%7
exports . CartesianChartPropsMixin = require ( ' . / CartesianChartPropsMixin ' ) ;%NWL%exports . ViewBoxMixin = require ( ' . / ViewBoxMixin ' ) ;%NWL%0
exports . CartesianChartPropsMixin = require ( ' . / CartesianChartPropsMixin ' ) ;%NWL%exports . DefaultAccessorsMixin = require ( ' . / DefaultAccessorsMixin ' ) ;%NWL%exports . TooltipMixin = require ( ' . / TooltipMixin ' ) ;%NWL%0
TestUtils . Simulate . mouseOver ( circle ) ;%NWL%expect ( circle . props . r ) . to . be . above ( circleRadius ) ;%NWL%expect ( circle . props . fill ) . to . not . equal ( circleColor ) ;%NWL%TestUtils . SimulateNative . mouseOut ( circle ) ;%NWL%expect ( circle . props . r ) . to . equal ( circleRadius ) ;%NWL%expect ( circle . props . fill ) . to . equal ( circleColor ) ;%NWL%} ) ;%NWL%it ( ' render tooltip when circle animates ' , function ( )  {%NWL%var circle = TestUtils . scryRenderedDOMComponentsWithClass (%NWL%scatterchart , CIRCLE_CLASS_NAME ) [ 0 ] ;%NWL%TestUtils . Simulate . mouseOver ( circle ) ;%NWL%0
' use strict ' ;%NWL%var expect = require ( ' chai ' ) . expect;%NWL%describe ( ' Voronoi ' , function ( )  {%NWL%it ( ' renders and tests voronoi component ' , function ( )  {%NWL%var React = require ( ' react / addons ' ) ;%NWL%var Voronoi = require ( ' . . / src / common / Voronoi ' ) ;%NWL%var generate = require ( ' . / utils / datagen ' ) . generateArrayOfPoints;%NWL%var utils = require ( ' . . / src / utils ' ) ;%NWL%5
var areaController = $controllers [ 0 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addArea ( )  {%NWL%if ( $attrs . value )  {%NWL%area = chart . addSeries ( [ $attrs . field ] , dimple . plot . area ) ;%NWL%graphController . filter ( $attrs ) ;%NWL%area . lineMarkers = true;%NWL%} else {%NWL%var values = dimple . getUniqueValues ( $scope . data , $attrs . field ) ;%NWL%angular . forEach ( values , function ( value ) {%NWL%graphController . filter ( $attrs ) ;%NWL%5
var width = $attrs . width ? $attrs . width : ' 100% ' ;%NWL%var height = $attrs . height ? $attrs . height : ' 100% ' ;%NWL%autoresize = $attrs . autoresize ? $attrs . autoresize . toLowerCase ( ) === ' true ' : false;%NWL%var svg = dimple . newSvg ( ' #dng - ' + id + ' ' , width , height ) ;%NWL%var data = $scope . data;%NWL%chart = new dimple . chart ( svg , data ) ;%NWL%if ( $attrs . margin )  {%NWL%chart . setMargins ( $attrs . margin ) ;%NWL%} else {%NWL%chart . setMargins ( 60 , 60 , 20 , 40 ) ;%NWL%var autoStyle = $attrs . autoStyle === ' false ' ? true : false;%NWL%0
if ( attrs . value !== undefined )  {%NWL%$scope . filters . push ( attrs . value ) ;%NWL%}%NWL%if ( $scope . filters . length )  {%NWL%chart . data = dimple . filterData ( $scope . data , attrs . field , $scope . filters ) ;%NWL%}%NWL%if ( attrs . filter !== undefined )  {%NWL%console . log ( " i see a filter " ) ;%NWL%var thisFilter = attrs . filter . split ( ' : ' ) ;%NWL%var field = thisFilter [ 0 ] ;%NWL%chart . data = dimple . filterData ( $scope . data , field , value ) ;%NWL%4
restrict: ' E ' ,%NWL%replace: true ,%NWL%require: [ ' graphLegend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var height = $attrs . height ? $attrs . height : " 10% " ;%NWL%9
replace: true ,%NWL%require: [ ' graphLegend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var top = $attrs . top ? $attrs . top : " 4% " ;%NWL%var width = $attrs . width ? $attrs . width : " 90% " ;%NWL%8
require: [ ' graphLegend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var top = $attrs . top ? $attrs . top : " 4% " ;%NWL%var height = $attrs . height ? $attrs . height : " 10% " ;%NWL%var position = $attrs . position ? $attrs . position : ' left ' ;%NWL%7
try {%NWL%stringBuffer = new java . lang . StringBuffer ( ) ;%NWL%line = input . readLine ( ) ;%NWL%if ( line && line . length ( ) && line . charAt ( 0 ) === 0xfeff )  {%NWL%line = line . substring ( 1 ) ;%NWL%}%NWL%if ( line !== null )  {%NWL%stringBuffer . append ( line ) ;%NWL%}%NWL%while ( ( line = input . readLine ( ) ) !== null )  {%NWL%stringBuffer . append ( line ) ;%NWL%7
var areaController = $controllers [ 0 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addArea ( )  {%NWL%if ( $attrs . value )  {%NWL%area = chart . addSeries ( [ $attrs . field ] , dimple . plot . area ) ;%NWL%graphController . filter ( $attrs ) ;%NWL%area . lineMarkers = true;%NWL%} else {%NWL%var values = dimple . getUniqueValues ( $scope . data , $attrs . field ) ;%NWL%angular . forEach ( values , function ( value ) {%NWL%graphController . filter ( $attrs ) ;%NWL%5
var width = $attrs . width ? $attrs . width : ' 100% ' ;%NWL%var height = $attrs . height ? $attrs . height : ' 100% ' ;%NWL%autoresize = $attrs . autoresize ? $attrs . autoresize . toLowerCase ( ) === ' true ' : false;%NWL%var svg = dimple . newSvg ( ' #dng - ' + id + ' ' , width , height ) ;%NWL%var data = $scope . data;%NWL%chart = new dimple . chart ( svg , data ) ;%NWL%if ( $attrs . margin )  {%NWL%chart . setMargins ( $attrs . margin ) ;%NWL%} else {%NWL%chart . setMargins ( 60 , 60 , 20 , 40 ) ;%NWL%var autoStyle = $attrs . autoStyle === ' false ' ? true : false;%NWL%0
if ( attrs . value !== undefined )  {%NWL%$scope . filters . push ( attrs . value ) ;%NWL%}%NWL%if ( $scope . filters . length )  {%NWL%chart . data = dimple . filterData ( $scope . data , attrs . field , $scope . filters ) ;%NWL%}%NWL%if ( attrs . filter !== undefined )  {%NWL%console . log ( " i see a filter " ) ;%NWL%var thisFilter = attrs . filter . split ( ' : ' ) ;%NWL%var field = thisFilter [ 0 ] ;%NWL%chart . data = dimple . filterData ( $scope . data , field , value ) ;%NWL%4
restrict: ' E ' ,%NWL%replace: true ,%NWL%require: [ ' graphLegend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var height = $attrs . height ? $attrs . height : " 10% " ;%NWL%9
replace: true ,%NWL%require: [ ' graphLegend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var top = $attrs . top ? $attrs . top : " 4% " ;%NWL%var width = $attrs . width ? $attrs . width : " 90% " ;%NWL%8
require: [ ' graphLegend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var top = $attrs . top ? $attrs . top : " 4% " ;%NWL%var height = $attrs . height ? $attrs . height : " 10% " ;%NWL%var position = $attrs . position ? $attrs . position : ' left ' ;%NWL%7
var areaController = $controllers [ 0 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addArea ( )  {%NWL%if ( $attrs . value )  {%NWL%area = chart . addSeries ( [ $attrs . field ] , dimple . plot . area ) ;%NWL%graphController . filter ( $attrs ) ;%NWL%area . lineMarkers = true;%NWL%} else {%NWL%var values = dimple . getUniqueValues ( $scope . data , $attrs . field ) ;%NWL%angular . forEach ( values , function ( value ) {%NWL%graphController . filter ( $attrs ) ;%NWL%5
if ( attrs . value !== undefined )  {%NWL%$scope . filters . push ( attrs . value ) ;%NWL%}%NWL%if ( $scope . filters . length )  {%NWL%chart . data = dimple . filterData ( $scope . data , attrs . field , $scope . filters ) ;%NWL%}%NWL%if ( attrs . filter !== undefined )  {%NWL%console . log ( " i see a filter " ) ;%NWL%var thisFilter = attrs . filter . split ( ' : ' ) ;%NWL%var field = thisFilter [ 0 ] ;%NWL%chart . data = dimple . filterData ( $scope . data , field , value ) ;%NWL%4
restrict: ' E ' ,%NWL%replace: true ,%NWL%require: [ ' legend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var height = $attrs . height ? $attrs . height : " 10% " ;%NWL%9
replace: true ,%NWL%require: [ ' legend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var top = $attrs . top ? $attrs . top : " 4% " ;%NWL%var width = $attrs . width ? $attrs . width : " 90% " ;%NWL%8
require: [ ' legend ' ,  ' ^graph ' ] ,%NWL%controller: [ ' $scope ' ,  ' $element ' ,  ' $attrs ' , function ( $scope , $element , $attrs )  {%NWL%} ] ,%NWL%link: function ( $scope , $element , $attrs , $controllers )  {%NWL%var graphController = $controllers [ 1 ] ;%NWL%var chart = graphController . getChart ( ) ;%NWL%function addLegend ( )  {%NWL%var left = $attrs . left ? $attrs . left : " 10% " ;%NWL%var top = $attrs . top ? $attrs . top : " 4% " ;%NWL%var height = $attrs . height ? $attrs . height : " 10% " ;%NWL%var position = $attrs . position ? $attrs . position : ' left ' ;%NWL%7
return this . _x;%NWL%}%NWL%set x ( x )  {%NWL%this . _x = x;%NWL%this . updatePosition ( ) ;%NWL%}%NWL%get y ( )  {%NWL%return this . _y;%NWL%}%NWL%set y ( y )  {%NWL%this . updatePosition ( ) ;%NWL%4
return this . _y;%NWL%}%NWL%set y ( y )  {%NWL%this . _y = y;%NWL%this . updatePosition ( ) ;%NWL%}%NWL%get dx ( )  {%NWL%return this . _dx;%NWL%}%NWL%set dx ( dx )  {%NWL%this . updateOffset ( ) ;%NWL%4
return this . _dx;%NWL%}%NWL%set dx ( dx )  {%NWL%this . _dx = dx;%NWL%this . updateOffset ( ) ;%NWL%}%NWL%get dy ( )  {%NWL%return this . _dy;%NWL%}%NWL%set dy ( dy )  {%NWL%this . updateOffset ( ) ;%NWL%4
this . updateOffset ( ) ;%NWL%}%NWL%get dy ( )  {%NWL%return this . _dy;%NWL%}%NWL%set dy ( dy )  {%NWL%this . _dy = dy;%NWL%this . updateOffset ( ) ;%NWL%}%NWL%set nx ( nx )  {%NWL%this . updateOffset ( ) ;%NWL%0
}%NWL%set dy ( dy )  {%NWL%this . _dy = dy;%NWL%this . updateOffset ( ) ;%NWL%}%NWL%set nx ( nx )  {%NWL%this . _dx = nx - this . _x;%NWL%this . updateOffset ( ) ;%NWL%}%NWL%set ny ( ny )  {%NWL%this . updateOffset ( ) ;%NWL%3
}%NWL%set ny ( ny )  {%NWL%this . _dy = ny - this . _y;%NWL%this . updateOffset ( ) ;%NWL%}%NWL%get offset ( )  {%NWL%return { x: this . _dx , y: this . _dy } ;%NWL%}%NWL%set offset ( { x , y } )  {%NWL%this . _dx = x;%NWL%this . updateOffset ( ) ;%NWL%3
set offset ( { x , y } )  {%NWL%this . _dx = x;%NWL%this . _dy = y;%NWL%this . updateOffset ( ) ;%NWL%}%NWL%get position ( )  {%NWL%return { x: this . _x , y: this . _y } ;%NWL%}%NWL%set position ( { x , y } )  {%NWL%this . _x = x;%NWL%this . updatePosition ( ) ;%NWL%3
export default class AnnotationCollection {%NWL%constructor ( { annotations , accessors , accessorsInverse } )  {%NWL%this . accessors = accessors;%NWL%this . accessorsInverse = accessorsInverse;%NWL%this . annotations = annotations;%NWL%}%NWL%clearTypes ( newSettings )  {%NWL%this . annotations . forEach ( d => {%NWL%d . type = undefined;%NWL%d . subject = ( newSettings && newSettings . subject ) || d . subject;%NWL%d . note = ( newSettings && newSettings . note ) || d . note;%NWL%9
%NWL%this . a = a == null ? 1 : a;%NWL%this . b = b || 0;%NWL%this . c = c || 0;%NWL%this . d = b == null ? 1 : d;%NWL%this . tx = tx || 0;%NWL%this . ty = ty || 0;%NWL%return this;%NWL%} ;%NWL%%NWL%this . a = this . d = 1;%NWL%1
this . a = a == null ? 1 : a;%NWL%this . b = b || 0;%NWL%this . c = c || 0;%NWL%this . d = b == null ? 1 : d;%NWL%this . tx = tx || 0;%NWL%this . ty = ty || 0;%NWL%return this;%NWL%} ;%NWL%%NWL%reset = function ( )  {%NWL%this . b = this . c = this . tx = this . ty = 0;%NWL%0
%NWL%clone = function ( )  {%NWL%return new Matrix2D ( this . a , this . b , this . c , this . d , this . tx , this . ty ) ;%NWL%} ;%NWL%%NWL%prepend = function ( a , b , c , d , tx , ty )  {%NWL%var a1 = this . a;%NWL%var c1 = this . c;%NWL%var tx1 = this . tx;%NWL%this . a = a * a1 + c * this . b;%NWL%this . c = a * c1 + c * this . d;%NWL%9
clone = function ( )  {%NWL%return new Matrix2D ( this . a , this . b , this . c , this . d , this . tx , this . ty ) ;%NWL%} ;%NWL%%NWL%prepend = function ( a , b , c , d , tx , ty )  {%NWL%var a1 = this . a;%NWL%var c1 = this . c;%NWL%var tx1 = this . tx;%NWL%this . a = a * a1 + c * this . b;%NWL%this . b = b * a1 + d * this . b;%NWL%this . d = b * c1 + d * this . d;%NWL%8
return new Matrix2D ( this . a , this . b , this . c , this . d , this . tx , this . ty ) ;%NWL%} ;%NWL%%NWL%prepend = function ( a , b , c , d , tx , ty )  {%NWL%var a1 = this . a;%NWL%var c1 = this . c;%NWL%var tx1 = this . tx;%NWL%this . a = a * a1 + c * this . b;%NWL%this . b = b * a1 + d * this . b;%NWL%this . c = a * c1 + c * this . d;%NWL%this . tx = a * tx1 + c * this . ty + tx;%NWL%7
} ;%NWL%%NWL%prepend = function ( a , b , c , d , tx , ty )  {%NWL%var a1 = this . a;%NWL%var c1 = this . c;%NWL%var tx1 = this . tx;%NWL%this . a = a * a1 + c * this . b;%NWL%this . b = b * a1 + d * this . b;%NWL%this . c = a * c1 + c * this . d;%NWL%this . d = b * c1 + d * this . d;%NWL%this . ty = b * tx1 + d * this . ty + ty;%NWL%6
append = function ( a , b , c , d , tx , ty )  {%NWL%var a1 = this . a;%NWL%var b1 = this . b;%NWL%var c1 = this . c;%NWL%var d1 = this . d;%NWL%if ( a !== 1 || b !== 0 || c !== 0 || d !== 1 )  {%NWL%this . a = a1 * a + c1 * b;%NWL%this . b = b1 * a + d1 * b;%NWL%this . c = a1 * c + c1 * d;%NWL%this . d = b1 * c + d1 * d;%NWL%this . tx = a1 * tx + c1 * ty + this . tx;%NWL%6
var a1 = this . a;%NWL%var b1 = this . b;%NWL%var c1 = this . c;%NWL%var d1 = this . d;%NWL%if ( a !== 1 || b !== 0 || c !== 0 || d !== 1 )  {%NWL%this . a = a1 * a + c1 * b;%NWL%this . b = b1 * a + d1 * b;%NWL%this . c = a1 * c + c1 * d;%NWL%this . d = b1 * c + d1 * d;%NWL%}%NWL%this . ty = b1 * tx + d1 * ty + this . ty;%NWL%5
let amount = Math . max ( 1 , Math . round ( ratio ) ) ;%NWL%if ( this . props . clockwise )  {%NWL%amount * = - 1;%NWL%}%NWL%this . requestValueChange ( amount ) ;%NWL%} else if ( ratio <= - 1 * this . props . moveThreshold || vx < - 1 * this . props . velocityThreshold )  {%NWL%let amount = Math . min ( - 1 , Math . round ( ratio ) ) ;%NWL%if ( this . props . clockwise )%NWL%{%NWL%amount * = - 1;%NWL%this . requestValueChange ( amount ) ;%NWL%4
}%NWL%render ( )  {%NWL%return (%NWL%<Animated . View%NWL%{ . . . this . panResponder . panHandlers }%NWL%style= { [%NWL%{%NWL%paddingTop: this . props . childRadius * this . props . sizeMultiplier%NWL%} ,%NWL%this . props . style%NWL%<Animated . View%NWL%3
' strokeMiterlimit '%NWL%] ;%NWL%function getPropList ( nextProps , prevProps )  {%NWL%let propList = [ ] ;%NWL%fillKeys . forEach ( name => {%NWL%if ( nextProps . hasOwnProperty ( name ) || prevProps . hasOwnProperty ( name ) )  {%NWL%propList . push ( name ) ;%NWL%}%NWL%} ) ;%NWL%strokeKeys . forEach ( name => {%NWL%propList . push ( name ) ;%NWL%6
) ;%NWL%}%NWL%updateCache ( props )  {%NWL%this . prevProps = pick ( props , KEYS ) ;%NWL%}%NWL%setNativeProps = props => {%NWL%props . propList = getPropList ( props , this . prevProps ) ;%NWL%if ( props . fill )  {%NWL%props . fill = extractBrush ( props . fill ) ;%NWL%}%NWL%props . stroke = extractBrush ( props . stroke ) ;%NWL%8
constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . matrix = listen ( props . matrix , _ =>%NWL%this . setNativeProps ( { _listener: true } )%NWL%) ;%NWL%this . _components = { } ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%3
} ;%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const matrixChanged = nextProps . matrix !== this . props . matrix;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%if ( matrixChanged )  {%NWL%this . matrix = listen ( nextProps . matrix , _ =>%NWL%7
constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . values = listen ( props . values , _ =>%NWL%this . setNativeProps ( { _listener: true } )%NWL%) ;%NWL%this . _components = { } ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%3
} ;%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const valuesChanged = nextProps . values !== this . props . values;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%if ( valuesChanged )  {%NWL%this . values = listen ( nextProps . values , _ =>%NWL%7
constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . data = listen ( props . data , _ =>%NWL%this . setNativeProps ( { _listener: true } )%NWL%) ;%NWL%this . _components = { } ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%3
} ;%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const dataChanged = nextProps . data !== this . props . data;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%if ( dataChanged )  {%NWL%this . data = listen ( nextProps . data , _ =>%NWL%7
_components: Object;%NWL%constructor ( props: Props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . object = listen ( props . object , _ =>%NWL%this . setNativeProps ( { _listener: true } )%NWL%) ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%4
} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const objectChanged = nextProps . object !== this . props . object;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%if ( objectChanged )  {%NWL%this . object = listen ( nextProps . object , _ =>%NWL%7
constructor ( props: Props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . points = listen ( props . points , _ =>%NWL%this . setNativeProps ( { _listener: true } )%NWL%) ;%NWL%this . _components = { } ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%3
} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const pointsChanged = nextProps . points !== this . props . points;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%if ( pointsChanged )  {%NWL%this . points = listen ( nextProps . points , _ =>%NWL%7
this . generator = createGenerator ( props , this . generator ) ;%NWL%this . node = getNode ( this . generator , this . props . root ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0
this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%this . node = getNode ( this . generator , nextProps . root ) ;%NWL%8
this . generator = createGenerator ( props , this . generator ) ;%NWL%this . node = getNode ( this . generator , this . props . root ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0
this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%this . node = getNode ( this . generator , nextProps . root ) ;%NWL%8
this . generator = createGenerator ( props , this . generator ) ;%NWL%this . node = getNode ( this . generator , this . props . root ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0
this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%this . node = getNode ( this . generator , nextProps . root ) ;%NWL%8
this . generator = createGenerator ( props , this . generator ) ;%NWL%this . node = getNode ( this . generator , this . props . root ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0
this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%this . node = getNode ( this . generator , nextProps . root ) ;%NWL%8
this . generator = createGenerator ( props , this . generator ) ;%NWL%this . node = getNode ( this . generator , this . props . root ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0
this . _component && this . _component . setNativeProps ( props ) ;%NWL%} ;%NWL%shouldComponentUpdate ( nextProps: Props )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const rootChanged = nextProps . root !== this . props . root;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%this . node = getNode ( this . generator , nextProps . root ) ;%NWL%8
} ;%NWL%shouldComponentUpdate ( nextProps )  {%NWL%if ( nextProps . children !== this . props . children )  {%NWL%this . removeAllListeners ( ) ;%NWL%this . listeners = [ ] ;%NWL%this . listenToChildren ( nextProps ) ;%NWL%return true;%NWL%}%NWL%return false;%NWL%}%NWL%this . removeAllListeners ( ) ;%NWL%3
constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . values = listen ( props . values , _ =>%NWL%this . setNativeProps ( { _listener: true } )%NWL%) ;%NWL%this . _components = { } ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%3
} ;%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some (%NWL%( key , index ) => nextProps [ key ] !== this . props [ key ]%NWL%) ;%NWL%const valuesChanged = nextProps . values !== this . props . values;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%}%NWL%if ( valuesChanged )  {%NWL%this . values = listen ( nextProps . values , _ =>%NWL%7
setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%if ( argChanged )  {%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%props . d = createPath ( this . generator , pick ( props , args ) ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%}%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some ( ( key , index ) => nextProps [ key ] !== this . props [ key ] ) ;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%3
class SvgD3ShapeArea extends Component {%NWL%generator: Area;%NWL%data: AnimatedListener;%NWL%constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . data = listen ( props . data , _ => this . setNativeProps ( { _listener: true } ) ) ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%6
listeners: any [ ] ;%NWL%generator: AreaRadial;%NWL%data: AnimatedListener;%NWL%constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . data = listen ( props . data , _ => this . setNativeProps ( { _listener: true } ) ) ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%6
this . generator = createGenerator ( props , this . generator ) ;%NWL%}%NWL%if ( argChanged || props . _listener )  {%NWL%props . d = createPath ( this . generator , this . data . values ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%}%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some ( ( key , index ) => nextProps [ key ] !== this . props [ key ] ) ;%NWL%const dataChanged = nextProps . data !== this . props . data;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0
class SvgD3ShapeLine extends Component {%NWL%generator: Line;%NWL%data: AnimatedListener;%NWL%constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . data = listen ( props . data , _ => this . setNativeProps ( { _listener: true } ) ) ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%6
this . generator = createGenerator ( props , this . generator ) ;%NWL%}%NWL%if ( argChanged || props . _listener )  {%NWL%props . d = createPath ( this . generator , this . data . values ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%}%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some ( ( key , index ) => nextProps [ key ] !== this . props [ key ] ) ;%NWL%const dataChanged = nextProps . data !== this . props . data;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0
class SvgD3ShapeLineRadial extends Component {%NWL%generator: LineRadial;%NWL%data: AnimatedListener;%NWL%constructor ( props )  {%NWL%super ( props ) ;%NWL%this . generator = createGenerator ( props ) ;%NWL%this . data = listen ( props . data , _ => this . setNativeProps ( { _listener: true } ) ) ;%NWL%}%NWL%setNativeProps = ( props = { } ) => {%NWL%const argChanged = args . some ( ( key , index ) => props [ key ] != null ) ;%NWL%this . generator = createGenerator ( props , this . generator ) ;%NWL%6
this . generator = createGenerator ( props , this . generator ) ;%NWL%}%NWL%if ( argChanged || props . _listener )  {%NWL%props . d = createPath ( this . generator , this . data . values ) ;%NWL%}%NWL%this . _component && this . _component . setNativeProps ( props ) ;%NWL%}%NWL%shouldComponentUpdate ( nextProps )  {%NWL%const argChanged = args . some ( ( key , index ) => nextProps [ key ] !== this . props [ key ] ) ;%NWL%const dataChanged = nextProps . data !== this . props . data;%NWL%this . generator = createGenerator ( nextProps , this . generator ) ;%NWL%0